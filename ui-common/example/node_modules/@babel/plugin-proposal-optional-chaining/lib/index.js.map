{"version":3,"file":"index.js","sources":["../src/util.ts","../src/transform.ts","../src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport { isTransparentExprWrapper } from \"@babel/helper-skip-transparent-expression-wrappers\";\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n * It respects transparent expression wrappers defined in\n * \"@babel/helper-skip-transparent-expression-wrappers\"\n *\n * @example\n * // returns true\n * const nodePathADotB = NodePath(\"if (a.b) {}\").get(\"test\"); // a.b\n * willPathCastToBoolean(nodePathADotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a.b\"))\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n\n/**\n * Return the outermost transparent expression wrapper of a given path,\n * otherwise returns path itself.\n * @example\n * const nodePathADotB = NodePath(\"(a.b as any)\").get(\"expression\"); // a.b\n * // returns NodePath(\"(a.b as any)\")\n * findOutermostTransparentParent(nodePathADotB);\n * @param {NodePath} path\n * @returns {NodePath}\n */\nexport function findOutermostTransparentParent(path: NodePath): NodePath {\n  let maybeWrapped = path;\n  path.findParent(p => {\n    if (!isTransparentExprWrapper(p.node)) return true;\n    maybeWrapped = p;\n  });\n  return maybeWrapped;\n}\n","import { types as t, template } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport {\n  skipTransparentExprWrapperNodes,\n  skipTransparentExprWrappers,\n} from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport { willPathCastToBoolean, findOutermostTransparentParent } from \"./util\";\n\nconst { ast } = template.expression;\n\nfunction isSimpleMemberExpression(expression) {\n  expression = skipTransparentExprWrapperNodes(expression);\n  return (\n    t.isIdentifier(expression) ||\n    t.isSuper(expression) ||\n    (t.isMemberExpression(expression) &&\n      !expression.computed &&\n      isSimpleMemberExpression(expression.object))\n  );\n}\n\n/**\n * Test if a given optional chain `path` needs to be memoized\n * @param {NodePath} path\n * @returns {boolean}\n */\nfunction needsMemoize(path) {\n  let optionalPath = path;\n  const { scope } = path;\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    const childKey = optionalPath.isOptionalMemberExpression()\n      ? \"object\"\n      : \"callee\";\n    const childPath = skipTransparentExprWrappers(optionalPath.get(childKey));\n    if (node.optional) {\n      return !scope.isStatic(childPath.node);\n    }\n\n    optionalPath = childPath;\n  }\n}\n\nexport function transform(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n  {\n    pureGetters,\n    noDocumentAll,\n  }: { pureGetters: boolean; noDocumentAll: boolean },\n) {\n  const { scope } = path;\n  // maybeWrapped points to the outermost transparent expression wrapper\n  // or the path itself\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const { parentPath } = maybeWrapped;\n  const willReplacementCastToBoolean = willPathCastToBoolean(maybeWrapped);\n  let isDeleteOperation = false;\n  const parentIsCall =\n    parentPath.isCallExpression({ callee: maybeWrapped.node }) &&\n    // note that the first condition must implies that `path.optional` is `true`,\n    // otherwise the parentPath should be an OptionalCallExpression\n    path.isOptionalMemberExpression();\n\n  const optionals = [];\n\n  let optionalPath = path;\n  // Replace `function (a, x = a.b?.c) {}` to `function (a, x = (() => a.b?.c)() ){}`\n  // so the temporary variable can be injected in correct scope\n  if (scope.path.isPattern() && needsMemoize(optionalPath)) {\n    path.replaceWith(template.ast`(() => ${path.node})()` as t.Statement);\n    // The injected optional chain will be queued and eventually transformed when visited\n    return;\n  }\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    if (node.optional) {\n      optionals.push(node);\n    }\n\n    if (optionalPath.isOptionalMemberExpression()) {\n      // @ts-expect-error todo(flow->ts) avoid changing more type\n      optionalPath.node.type = \"MemberExpression\";\n      // @ts-expect-error todo(flow->ts)\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      // @ts-expect-error todo(flow->ts) avoid changing more type\n      optionalPath.node.type = \"CallExpression\";\n      // @ts-expect-error todo(flow->ts)\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    }\n  }\n\n  let replacementPath: NodePath<any> = path;\n  if (parentPath.isUnaryExpression({ operator: \"delete\" })) {\n    replacementPath = parentPath;\n    isDeleteOperation = true;\n  }\n  for (let i = optionals.length - 1; i >= 0; i--) {\n    const node = optionals[i];\n\n    const isCall = t.isCallExpression(node);\n    const replaceKey = isCall ? \"callee\" : \"object\";\n\n    const chainWithTypes = node[replaceKey];\n    const chain = skipTransparentExprWrapperNodes(chainWithTypes);\n\n    let ref;\n    let check;\n    if (isCall && t.isIdentifier(chain, { name: \"eval\" })) {\n      check = ref = chain;\n      // `eval?.()` is an indirect eval call transformed to `(0,eval)()`\n      node[replaceKey] = t.sequenceExpression([t.numericLiteral(0), ref]);\n    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {\n      // If we assume getters are pure (avoiding a Function#call) and we are at the call,\n      // we can avoid a needless memoize. We only do this if the callee is a simple member\n      // expression, to avoid multiple calls to nested call expressions.\n      check = ref = chainWithTypes;\n    } else {\n      ref = scope.maybeGenerateMemoised(chain);\n      if (ref) {\n        check = t.assignmentExpression(\n          \"=\",\n          t.cloneNode(ref),\n          // Here `chainWithTypes` MUST NOT be cloned because it could be\n          // updated when generating the memoised context of a call\n          // expression\n          chainWithTypes,\n        );\n\n        node[replaceKey] = ref;\n      } else {\n        check = ref = chainWithTypes;\n      }\n    }\n\n    // Ensure call expressions have the proper `this`\n    // `foo.bar()` has context `foo`.\n    if (isCall && t.isMemberExpression(chain)) {\n      if (pureGetters && isSimpleMemberExpression(chain)) {\n        // To avoid a Function#call, we can instead re-grab the property from the context object.\n        // `a.?b.?()` translates roughly to `_a.b != null && _a.b()`\n        node.callee = chainWithTypes;\n      } else {\n        // Otherwise, we need to memoize the context object, and change the call into a Function#call.\n        // `a.?b.?()` translates roughly to `(_b = _a.b) != null && _b.call(_a)`\n        const { object } = chain;\n        let context: t.Expression = scope.maybeGenerateMemoised(object);\n        if (context) {\n          chain.object = t.assignmentExpression(\"=\", context, object);\n        } else if (t.isSuper(object)) {\n          context = t.thisExpression();\n        } else {\n          context = object;\n        }\n\n        node.arguments.unshift(t.cloneNode(context));\n        // @ts-expect-error node.callee can not be an V8IntrinsicIdentifier: V8 intrinsic is disallowed in optional chain\n        node.callee = t.memberExpression(node.callee, t.identifier(\"call\"));\n      }\n    }\n    let replacement = replacementPath.node;\n    // Ensure (a?.b)() has proper `this`\n    // The `parentIsCall` is constant within loop, we should check i === 0\n    // to ensure that it is only applied to the first optional chain element\n    // i.e. `?.b` in `(a?.b.c)()`\n    if (i === 0 && parentIsCall) {\n      // `(a?.b)()` to `(a == null ? undefined : a.b.bind(a))()`\n      const object = skipTransparentExprWrapperNodes(replacement.object);\n      let baseRef;\n      if (!pureGetters || !isSimpleMemberExpression(object)) {\n        // memoize the context object when getters are not always pure\n        // or the object is not a simple member expression\n        // `(a?.b.c)()` to `(a == null ? undefined : (_a$b = a.b).c.bind(_a$b))()`\n        baseRef = scope.maybeGenerateMemoised(object);\n        if (baseRef) {\n          replacement.object = t.assignmentExpression(\"=\", baseRef, object);\n        }\n      }\n      replacement = t.callExpression(\n        t.memberExpression(replacement, t.identifier(\"bind\")),\n        [t.cloneNode(baseRef ?? object)],\n      );\n    }\n\n    if (willReplacementCastToBoolean) {\n      // `if (a?.b) {}` transformed to `if (a != null && a.b) {}`\n      // we don't need to return `void 0` because the returned value will\n      // eveutally cast to boolean.\n      const nonNullishCheck = noDocumentAll\n        ? ast`${t.cloneNode(check)} != null`\n        : ast`\n            ${t.cloneNode(check)} !== null && ${t.cloneNode(ref)} !== void 0`;\n      replacementPath.replaceWith(\n        t.logicalExpression(\"&&\", nonNullishCheck, replacement),\n      );\n      replacementPath = skipTransparentExprWrappers(\n        // @ts-expect-error todo(flow->ts)\n        replacementPath.get(\"right\"),\n      );\n    } else {\n      const nullishCheck = noDocumentAll\n        ? ast`${t.cloneNode(check)} == null`\n        : ast`\n            ${t.cloneNode(check)} === null || ${t.cloneNode(ref)} === void 0`;\n\n      const returnValue = isDeleteOperation ? ast`true` : ast`void 0`;\n      replacementPath.replaceWith(\n        t.conditionalExpression(nullishCheck, returnValue, replacement),\n      );\n      replacementPath = skipTransparentExprWrappers(\n        // @ts-expect-error todo(flow->ts)\n        replacementPath.get(\"alternate\"),\n      );\n    }\n  }\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxOptionalChaining from \"@babel/plugin-syntax-optional-chaining\";\nimport { transform } from \"./transform\";\n\nexport default declare((api, options) => {\n  api.assertVersion(7);\n\n  const { loose = false } = options;\n  const noDocumentAll = api.assumption(\"noDocumentAll\") ?? loose;\n  const pureGetters = api.assumption(\"pureGetters\") ?? loose;\n\n  return {\n    name: \"proposal-optional-chaining\",\n    inherits: syntaxOptionalChaining.default,\n\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        transform(path, { noDocumentAll, pureGetters });\n      },\n    },\n  };\n});\n\nexport { transform };\n"],"names":["willPathCastToBoolean","path","maybeWrapped","findOutermostTransparentParent","node","parentPath","isLogicalExpression","operator","right","isSequenceExpression","expressions","length","isConditional","test","isUnaryExpression","isLoop","findParent","p","isTransparentExprWrapper","ast","template","expression","isSimpleMemberExpression","skipTransparentExprWrapperNodes","t","isIdentifier","isSuper","isMemberExpression","computed","object","needsMemoize","optionalPath","scope","isOptionalMemberExpression","isOptionalCallExpression","childKey","childPath","skipTransparentExprWrappers","get","optional","isStatic","transform","pureGetters","noDocumentAll","willReplacementCastToBoolean","isDeleteOperation","parentIsCall","isCallExpression","callee","optionals","isPattern","replaceWith","push","type","replacementPath","i","isCall","replaceKey","chainWithTypes","chain","ref","check","name","sequenceExpression","numericLiteral","maybeGenerateMemoised","assignmentExpression","cloneNode","context","thisExpression","arguments","unshift","memberExpression","identifier","replacement","baseRef","callExpression","nonNullishCheck","logicalExpression","nullishCheck","returnValue","conditionalExpression","declare","api","options","assertVersion","loose","assumption","inherits","syntaxOptionalChaining","default","visitor"],"mappings":"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"}
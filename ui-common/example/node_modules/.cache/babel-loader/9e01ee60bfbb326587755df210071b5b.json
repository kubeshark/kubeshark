{"ast":null,"code":"/**\n * @typedef {import('../types.js').OmitHandle} OmitHandle\n * @typedef {import('../types.js').Child} Child\n */\nimport { isElement } from 'hast-util-is-element';\nimport { comment } from './util/comment.js';\nimport { siblingBefore, siblingAfter } from './util/siblings.js';\nimport { whitespaceStart } from './util/whitespace-start.js';\nimport { closing } from './closing.js';\nimport { omission } from './omission.js';\nexport const opening = omission({\n  html,\n  head,\n  body,\n  colgroup,\n  tbody\n});\n/**\n * Whether to omit `<html>`.\n *\n * @type {OmitHandle}\n */\n\nfunction html(node) {\n  const head = siblingAfter(node, -1);\n  return !head || !comment(head);\n}\n/**\n * Whether to omit `<head>`.\n *\n * @type {OmitHandle}\n */\n\n\nfunction head(node) {\n  const children = node.children;\n  /** @type {Array.<string>} */\n\n  const seen = [];\n  let index = -1;\n  /** @type {Child} */\n\n  let child;\n\n  while (++index < children.length) {\n    child = children[index];\n\n    if (isElement(child, ['title', 'base'])) {\n      if (seen.includes(child.tagName)) return false;\n      seen.push(child.tagName);\n    }\n  }\n\n  return children.length > 0;\n}\n/**\n * Whether to omit `<body>`.\n *\n * @type {OmitHandle}\n */\n\n\nfunction body(node) {\n  const head = siblingAfter(node, -1, true);\n  return !head || !comment(head) && !whitespaceStart(head) && !isElement(head, ['meta', 'link', 'script', 'style', 'template']);\n}\n/**\n * Whether to omit `<colgroup>`.\n * The spec describes some logic for the opening tag, but it’s easier to\n * implement in the closing tag, to the same effect, so we handle it there\n * instead.\n *\n * @type {OmitHandle}\n */\n\n\nfunction colgroup(node, index, parent) {\n  const previous = siblingBefore(parent, index);\n  const head = siblingAfter(node, -1, true); // Previous colgroup was already omitted.\n\n  if (isElement(previous, 'colgroup') && closing(previous, parent.children.indexOf(previous), parent)) {\n    return false;\n  }\n\n  return head && isElement(head, 'col');\n}\n/**\n * Whether to omit `<tbody>`.\n *\n * @type {OmitHandle}\n */\n\n\nfunction tbody(node, index, parent) {\n  const previous = siblingBefore(parent, index);\n  const head = siblingAfter(node, -1); // Previous table section was already omitted.\n\n  if (isElement(previous, ['thead', 'tbody']) && closing(previous, parent.children.indexOf(previous), parent)) {\n    return false;\n  }\n\n  return head && isElement(head, 'tr');\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/hast-util-to-html/lib/omission/opening.js"],"names":["isElement","comment","siblingBefore","siblingAfter","whitespaceStart","closing","omission","opening","html","head","body","colgroup","tbody","node","children","seen","index","child","length","includes","tagName","push","parent","previous","indexOf"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('../types.js').OmitHandle} OmitHandle\n * @typedef {import('../types.js').Child} Child\n */\n\nimport {isElement} from 'hast-util-is-element'\nimport {comment} from './util/comment.js'\nimport {siblingBefore, siblingAfter} from './util/siblings.js'\nimport {whitespaceStart} from './util/whitespace-start.js'\nimport {closing} from './closing.js'\nimport {omission} from './omission.js'\n\nexport const opening = omission({\n  html,\n  head,\n  body,\n  colgroup,\n  tbody\n})\n\n/**\n * Whether to omit `<html>`.\n *\n * @type {OmitHandle}\n */\nfunction html(node) {\n  const head = siblingAfter(node, -1)\n  return !head || !comment(head)\n}\n\n/**\n * Whether to omit `<head>`.\n *\n * @type {OmitHandle}\n */\nfunction head(node) {\n  const children = node.children\n  /** @type {Array.<string>} */\n  const seen = []\n  let index = -1\n  /** @type {Child} */\n  let child\n\n  while (++index < children.length) {\n    child = children[index]\n    if (isElement(child, ['title', 'base'])) {\n      if (seen.includes(child.tagName)) return false\n      seen.push(child.tagName)\n    }\n  }\n\n  return children.length > 0\n}\n\n/**\n * Whether to omit `<body>`.\n *\n * @type {OmitHandle}\n */\nfunction body(node) {\n  const head = siblingAfter(node, -1, true)\n\n  return (\n    !head ||\n    (!comment(head) &&\n      !whitespaceStart(head) &&\n      !isElement(head, ['meta', 'link', 'script', 'style', 'template']))\n  )\n}\n\n/**\n * Whether to omit `<colgroup>`.\n * The spec describes some logic for the opening tag, but it’s easier to\n * implement in the closing tag, to the same effect, so we handle it there\n * instead.\n *\n * @type {OmitHandle}\n */\nfunction colgroup(node, index, parent) {\n  const previous = siblingBefore(parent, index)\n  const head = siblingAfter(node, -1, true)\n\n  // Previous colgroup was already omitted.\n  if (\n    isElement(previous, 'colgroup') &&\n    closing(previous, parent.children.indexOf(previous), parent)\n  ) {\n    return false\n  }\n\n  return head && isElement(head, 'col')\n}\n\n/**\n * Whether to omit `<tbody>`.\n *\n * @type {OmitHandle}\n */\nfunction tbody(node, index, parent) {\n  const previous = siblingBefore(parent, index)\n  const head = siblingAfter(node, -1)\n\n  // Previous table section was already omitted.\n  if (\n    isElement(previous, ['thead', 'tbody']) &&\n    closing(previous, parent.children.indexOf(previous), parent)\n  ) {\n    return false\n  }\n\n  return head && isElement(head, 'tr')\n}\n"]},"metadata":{},"sourceType":"module"}
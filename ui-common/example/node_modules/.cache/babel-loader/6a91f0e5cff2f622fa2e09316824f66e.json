{"ast":null,"code":"import warning from 'tiny-warning';\nimport { createRule } from 'jss';\nvar now = Date.now();\nvar fnValuesNs = \"fnValues\" + now;\nvar fnRuleNs = \"fnStyle\" + ++now;\n\nvar functionPlugin = function functionPlugin() {\n  return {\n    onCreateRule: function onCreateRule(name, decl, options) {\n      if (typeof decl !== 'function') return null;\n      var rule = createRule(name, {}, options);\n      rule[fnRuleNs] = decl;\n      return rule;\n    },\n    onProcessStyle: function onProcessStyle(style, rule) {\n      // We need to extract function values from the declaration, so that we can keep core unaware of them.\n      // We need to do that only once.\n      // We don't need to extract functions on each style update, since this can happen only once.\n      // We don't support function values inside of function rules.\n      if (fnValuesNs in rule || fnRuleNs in rule) return style;\n      var fnValues = {};\n\n      for (var prop in style) {\n        var value = style[prop];\n        if (typeof value !== 'function') continue;\n        delete style[prop];\n        fnValues[prop] = value;\n      }\n\n      rule[fnValuesNs] = fnValues;\n      return style;\n    },\n    onUpdate: function onUpdate(data, rule, sheet, options) {\n      var styleRule = rule;\n      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object\n      // will be returned from that function.\n\n      if (fnRule) {\n        // Empty object will remove all currently defined props\n        // in case function rule returns a falsy value.\n        styleRule.style = fnRule(data) || {};\n\n        if (process.env.NODE_ENV === 'development') {\n          for (var prop in styleRule.style) {\n            if (typeof styleRule.style[prop] === 'function') {\n              process.env.NODE_ENV !== \"production\" ? warning(false, '[JSS] Function values inside function rules are not supported.') : void 0;\n              break;\n            }\n          }\n        }\n      }\n\n      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.\n\n      if (fnValues) {\n        for (var _prop in fnValues) {\n          styleRule.prop(_prop, fnValues[_prop](data), options);\n        }\n      }\n    }\n  };\n};\n\nexport default functionPlugin;","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js"],"names":["warning","createRule","now","Date","fnValuesNs","fnRuleNs","functionPlugin","onCreateRule","name","decl","options","rule","onProcessStyle","style","fnValues","prop","value","onUpdate","data","sheet","styleRule","fnRule","process","env","NODE_ENV","_prop"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,cAApB;AACA,SAASC,UAAT,QAA2B,KAA3B;AAEA,IAAIC,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAV;AACA,IAAIE,UAAU,GAAG,aAAaF,GAA9B;AACA,IAAIG,QAAQ,GAAG,YAAY,EAAEH,GAA7B;;AAEA,IAAII,cAAc,GAAG,SAASA,cAAT,GAA0B;AAC7C,SAAO;AACLC,IAAAA,YAAY,EAAE,SAASA,YAAT,CAAsBC,IAAtB,EAA4BC,IAA5B,EAAkCC,OAAlC,EAA2C;AACvD,UAAI,OAAOD,IAAP,KAAgB,UAApB,EAAgC,OAAO,IAAP;AAChC,UAAIE,IAAI,GAAGV,UAAU,CAACO,IAAD,EAAO,EAAP,EAAWE,OAAX,CAArB;AACAC,MAAAA,IAAI,CAACN,QAAD,CAAJ,GAAiBI,IAAjB;AACA,aAAOE,IAAP;AACD,KANI;AAOLC,IAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBC,KAAxB,EAA+BF,IAA/B,EAAqC;AACnD;AACA;AACA;AACA;AACA,UAAIP,UAAU,IAAIO,IAAd,IAAsBN,QAAQ,IAAIM,IAAtC,EAA4C,OAAOE,KAAP;AAC5C,UAAIC,QAAQ,GAAG,EAAf;;AAEA,WAAK,IAAIC,IAAT,IAAiBF,KAAjB,EAAwB;AACtB,YAAIG,KAAK,GAAGH,KAAK,CAACE,IAAD,CAAjB;AACA,YAAI,OAAOC,KAAP,KAAiB,UAArB,EAAiC;AACjC,eAAOH,KAAK,CAACE,IAAD,CAAZ;AACAD,QAAAA,QAAQ,CAACC,IAAD,CAAR,GAAiBC,KAAjB;AACD;;AAEDL,MAAAA,IAAI,CAACP,UAAD,CAAJ,GAAmBU,QAAnB;AACA,aAAOD,KAAP;AACD,KAxBI;AAyBLI,IAAAA,QAAQ,EAAE,SAASA,QAAT,CAAkBC,IAAlB,EAAwBP,IAAxB,EAA8BQ,KAA9B,EAAqCT,OAArC,EAA8C;AACtD,UAAIU,SAAS,GAAGT,IAAhB;AACA,UAAIU,MAAM,GAAGD,SAAS,CAACf,QAAD,CAAtB,CAFsD,CAEpB;AAClC;;AAEA,UAAIgB,MAAJ,EAAY;AACV;AACA;AACAD,QAAAA,SAAS,CAACP,KAAV,GAAkBQ,MAAM,CAACH,IAAD,CAAN,IAAgB,EAAlC;;AAEA,YAAII,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,aAA7B,EAA4C;AAC1C,eAAK,IAAIT,IAAT,IAAiBK,SAAS,CAACP,KAA3B,EAAkC;AAChC,gBAAI,OAAOO,SAAS,CAACP,KAAV,CAAgBE,IAAhB,CAAP,KAAiC,UAArC,EAAiD;AAC/CO,cAAAA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCxB,OAAO,CAAC,KAAD,EAAQ,gEAAR,CAA/C,GAA2H,KAAK,CAAhI;AACA;AACD;AACF;AACF;AACF;;AAED,UAAIc,QAAQ,GAAGM,SAAS,CAAChB,UAAD,CAAxB,CApBsD,CAoBhB;;AAEtC,UAAIU,QAAJ,EAAc;AACZ,aAAK,IAAIW,KAAT,IAAkBX,QAAlB,EAA4B;AAC1BM,UAAAA,SAAS,CAACL,IAAV,CAAeU,KAAf,EAAsBX,QAAQ,CAACW,KAAD,CAAR,CAAgBP,IAAhB,CAAtB,EAA6CR,OAA7C;AACD;AACF;AACF;AApDI,GAAP;AAsDD,CAvDD;;AAyDA,eAAeJ,cAAf","sourcesContent":["import warning from 'tiny-warning';\nimport { createRule } from 'jss';\n\nvar now = Date.now();\nvar fnValuesNs = \"fnValues\" + now;\nvar fnRuleNs = \"fnStyle\" + ++now;\n\nvar functionPlugin = function functionPlugin() {\n  return {\n    onCreateRule: function onCreateRule(name, decl, options) {\n      if (typeof decl !== 'function') return null;\n      var rule = createRule(name, {}, options);\n      rule[fnRuleNs] = decl;\n      return rule;\n    },\n    onProcessStyle: function onProcessStyle(style, rule) {\n      // We need to extract function values from the declaration, so that we can keep core unaware of them.\n      // We need to do that only once.\n      // We don't need to extract functions on each style update, since this can happen only once.\n      // We don't support function values inside of function rules.\n      if (fnValuesNs in rule || fnRuleNs in rule) return style;\n      var fnValues = {};\n\n      for (var prop in style) {\n        var value = style[prop];\n        if (typeof value !== 'function') continue;\n        delete style[prop];\n        fnValues[prop] = value;\n      }\n\n      rule[fnValuesNs] = fnValues;\n      return style;\n    },\n    onUpdate: function onUpdate(data, rule, sheet, options) {\n      var styleRule = rule;\n      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object\n      // will be returned from that function.\n\n      if (fnRule) {\n        // Empty object will remove all currently defined props\n        // in case function rule returns a falsy value.\n        styleRule.style = fnRule(data) || {};\n\n        if (process.env.NODE_ENV === 'development') {\n          for (var prop in styleRule.style) {\n            if (typeof styleRule.style[prop] === 'function') {\n              process.env.NODE_ENV !== \"production\" ? warning(false, '[JSS] Function values inside function rules are not supported.') : void 0;\n              break;\n            }\n          }\n        }\n      }\n\n      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.\n\n      if (fnValues) {\n        for (var _prop in fnValues) {\n          styleRule.prop(_prop, fnValues[_prop](data), options);\n        }\n      }\n    }\n  };\n};\n\nexport default functionPlugin;\n"]},"metadata":{},"sourceType":"module"}
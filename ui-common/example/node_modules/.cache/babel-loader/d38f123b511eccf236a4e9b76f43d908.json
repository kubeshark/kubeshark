{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('hast').Element} Element\n *\n * @typedef {string} TagName\n * @typedef {null|undefined|TagName|TestFunctionAnything|Array.<TagName|TestFunctionAnything>} Test\n */\n\n/**\n * @template {Element} T\n * @typedef {null|undefined|T['tagName']|TestFunctionPredicate<T>|Array.<T['tagName']|TestFunctionPredicate<T>>} PredicateTest\n */\n\n/**\n * Check if an element passes a test\n *\n * @callback TestFunctionAnything\n * @param {Element} element\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean|void}\n */\n\n/**\n * Check if an element passes a certain node test\n *\n * @template {Element} X\n * @callback TestFunctionPredicate\n * @param {Element} element\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {element is X}\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @callback AssertAnything\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean}\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @template {Element} Y\n * @callback AssertPredicate\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is Y}\n */\n// Check if `node` is an `element` and whether it passes the given test.\nexport const isElement =\n/**\n * Check if a node is an element and passes a test.\n * When a `parent` node is known the `index` of node should also be given.\n *\n * @type {(\n *   (() => false) &\n *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &\n *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)\n * )}\n */\n\n/**\n * Check if a node passes a test.\n * When a `parent` node is known the `index` of node should also be given.\n *\n * @param {unknown} [node] Node to check\n * @param {Test} [test] When nullish, checks if `node` is a `Node`.\n * When `string`, works like passing `function (node) {return node.type === test}`.\n * When `function` checks if function passed the node is true.\n * When `array`, checks any one of the subtests pass.\n * @param {number} [index] Position of `node` in `parent`\n * @param {Parent} [parent] Parent of `node`\n * @param {unknown} [context] Context object to invoke `test` with\n * @returns {boolean} Whether test passed and `node` is an `Element` (object with `type` set to `element` and `tagName` set to a non-empty string).\n */\n// eslint-disable-next-line max-params\nfunction (node, test, index, parent, context) {\n  const check = convertElement(test);\n\n  if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\n    throw new Error('Expected positive finite index for child node');\n  }\n\n  if (parent !== undefined && parent !== null && (!parent.type || !parent.children)) {\n    throw new Error('Expected parent node');\n  } // @ts-expect-error Looks like a node.\n\n\n  if (!node || !node.type || typeof node.type !== 'string') {\n    return false;\n  }\n\n  if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\n    throw new Error('Expected both parent and index');\n  }\n\n  return check.call(context, node, index, parent);\n};\nexport const convertElement =\n/**\n * @type {(\n *   (<T extends Element>(test: T['tagName']|TestFunctionPredicate<T>) => AssertPredicate<T>) &\n *   ((test?: Test) => AssertAnything)\n * )}\n */\n\n/**\n * Generate an assertion from a check.\n * @param {Test} [test]\n * When nullish, checks if `node` is a `Node`.\n * When `string`, works like passing `function (node) {return node.type === test}`.\n * When `function` checks if function passed the node is true.\n * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n * When `array`, checks any one of the subtests pass.\n * @returns {AssertAnything}\n */\nfunction (test) {\n  if (test === undefined || test === null) {\n    return element;\n  }\n\n  if (typeof test === 'string') {\n    return tagNameFactory(test);\n  }\n\n  if (typeof test === 'object') {\n    return anyFactory(test);\n  }\n\n  if (typeof test === 'function') {\n    return castFactory(test);\n  }\n\n  throw new Error('Expected function, string, or array as test');\n};\n/**\n * @param {Array.<TagName|TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\n\nfunction anyFactory(tests) {\n  /** @type {Array.<AssertAnything>} */\n  const checks = [];\n  let index = -1;\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index]);\n  }\n\n  return castFactory(any);\n  /**\n   * @this {unknown}\n   * @param {unknown[]} parameters\n   * @returns {boolean}\n   */\n\n  function any() {\n    let index = -1;\n\n    for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {\n      parameters[_key] = arguments[_key];\n    }\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n/**\n * Utility to convert a string into a function which checks a given node’s tag\n * name for said string.\n *\n * @param {TagName} check\n * @returns {AssertAnything}\n */\n\n\nfunction tagNameFactory(check) {\n  return tagName;\n  /**\n   * @param {unknown} node\n   * @returns {boolean}\n   */\n\n  function tagName(node) {\n    return element(node) && node.tagName === check;\n  }\n}\n/**\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\n\n\nfunction castFactory(check) {\n  return assertion;\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array.<unknown>} parameters\n   * @returns {boolean}\n   */\n\n  function assertion(node) {\n    for (var _len2 = arguments.length, parameters = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      parameters[_key2 - 1] = arguments[_key2];\n    }\n\n    // @ts-expect-error: fine.\n    return element(node) && Boolean(check.call(this, node, ...parameters));\n  }\n}\n/**\n * Utility to return true if this is an element.\n * @param {unknown} node\n * @returns {node is Element}\n */\n\n\nfunction element(node) {\n  return Boolean(node && typeof node === 'object' && // @ts-expect-error Looks like a node.\n  node.type === 'element' && // @ts-expect-error Looks like an element.\n  typeof node.tagName === 'string');\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/hast-util-is-element/index.js"],"names":["isElement","node","test","index","parent","context","check","convertElement","undefined","Number","POSITIVE_INFINITY","Error","type","children","call","element","tagNameFactory","anyFactory","castFactory","tests","checks","length","any","parameters","tagName","assertion","Boolean"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('hast').Element} Element\n *\n * @typedef {string} TagName\n * @typedef {null|undefined|TagName|TestFunctionAnything|Array.<TagName|TestFunctionAnything>} Test\n */\n\n/**\n * @template {Element} T\n * @typedef {null|undefined|T['tagName']|TestFunctionPredicate<T>|Array.<T['tagName']|TestFunctionPredicate<T>>} PredicateTest\n */\n\n/**\n * Check if an element passes a test\n *\n * @callback TestFunctionAnything\n * @param {Element} element\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean|void}\n */\n\n/**\n * Check if an element passes a certain node test\n *\n * @template {Element} X\n * @callback TestFunctionPredicate\n * @param {Element} element\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {element is X}\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @callback AssertAnything\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean}\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @template {Element} Y\n * @callback AssertPredicate\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is Y}\n */\n\n// Check if `node` is an `element` and whether it passes the given test.\nexport const isElement =\n  /**\n   * Check if a node is an element and passes a test.\n   * When a `parent` node is known the `index` of node should also be given.\n   *\n   * @type {(\n   *   (() => false) &\n   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &\n   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * Check if a node passes a test.\n     * When a `parent` node is known the `index` of node should also be given.\n     *\n     * @param {unknown} [node] Node to check\n     * @param {Test} [test] When nullish, checks if `node` is a `Node`.\n     * When `string`, works like passing `function (node) {return node.type === test}`.\n     * When `function` checks if function passed the node is true.\n     * When `array`, checks any one of the subtests pass.\n     * @param {number} [index] Position of `node` in `parent`\n     * @param {Parent} [parent] Parent of `node`\n     * @param {unknown} [context] Context object to invoke `test` with\n     * @returns {boolean} Whether test passed and `node` is an `Element` (object with `type` set to `element` and `tagName` set to a non-empty string).\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convertElement(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index for child node')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!parent.type || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      // @ts-expect-error Looks like a node.\n      if (!node || !node.type || typeof node.type !== 'string') {\n        return false\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return check.call(context, node, index, parent)\n    }\n  )\n\nexport const convertElement =\n  /**\n   * @type {(\n   *   (<T extends Element>(test: T['tagName']|TestFunctionPredicate<T>) => AssertPredicate<T>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * Generate an assertion from a check.\n     * @param {Test} [test]\n     * When nullish, checks if `node` is a `Node`.\n     * When `string`, works like passing `function (node) {return node.type === test}`.\n     * When `function` checks if function passed the node is true.\n     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n     * When `array`, checks any one of the subtests pass.\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return element\n      }\n\n      if (typeof test === 'string') {\n        return tagNameFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return anyFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or array as test')\n    }\n  )\n\n/**\n * @param {Array.<TagName|TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array.<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {unknown[]} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Utility to convert a string into a function which checks a given node’s tag\n * name for said string.\n *\n * @param {TagName} check\n * @returns {AssertAnything}\n */\nfunction tagNameFactory(check) {\n  return tagName\n\n  /**\n   * @param {unknown} node\n   * @returns {boolean}\n   */\n  function tagName(node) {\n    return element(node) && node.tagName === check\n  }\n}\n\n/**\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array.<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    // @ts-expect-error: fine.\n    return element(node) && Boolean(check.call(this, node, ...parameters))\n  }\n}\n\n/**\n * Utility to return true if this is an element.\n * @param {unknown} node\n * @returns {node is Element}\n */\nfunction element(node) {\n  return Boolean(\n    node &&\n      typeof node === 'object' &&\n      // @ts-expect-error Looks like a node.\n      node.type === 'element' &&\n      // @ts-expect-error Looks like an element.\n      typeof node.tagName === 'string'\n  )\n}\n"]},"metadata":{},"sourceType":"module"}
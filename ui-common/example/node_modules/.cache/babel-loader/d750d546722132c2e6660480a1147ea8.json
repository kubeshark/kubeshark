{"ast":null,"code":"/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').DocType} Doctype\n * @typedef {Parent['children'][number]} Child\n * @typedef {Element['children'][number]} ElementChild\n * @typedef {Child|Root} Node\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentType} P5Doctype\n * @typedef {import('parse5').CommentNode} P5Comment\n * @typedef {import('parse5').TextNode} P5Text\n * @typedef {import('parse5').Element} P5Element\n * @typedef {import('parse5').ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Location} P5Location\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {import('parse5').Node} P5Node\n *\n * @typedef {'html'|'svg'} Space\n *\n * @callback Handler\n * @param {Context} ctx\n * @param {P5Node} node\n * @param {Array.<Child>} [children]\n * @returns {Node}\n *\n * @typedef Options\n * @property {Space} [space='html'] Whether the root of the tree is in the `'html'` or `'svg'` space. If an element in with the SVG namespace is found in `ast`, `fromParse5` automatically switches to the SVG space when entering the element, and switches back when leaving\n * @property {VFile} [file] `VFile`, used to add positional information to nodes. If given, the file should have the original HTML source as its contents\n * @property {boolean} [verbose=false] Whether to add extra positional information about starting tags, closing tags, and attributes to elements. Note: not used without `file`\n *\n * @typedef Context\n * @property {Schema} schema\n * @property {VFile|undefined} file\n * @property {boolean|undefined} verbose\n * @property {boolean} location\n */\nimport { h, s } from 'hastscript';\nimport { html, svg, find } from 'property-information';\nimport { location } from 'vfile-location';\nimport { webNamespaces } from 'web-namespaces';\nconst own = {}.hasOwnProperty; // Handlers.\n\nconst map = {\n  '#document': root,\n  '#document-fragment': root,\n  '#text': text,\n  '#comment': comment,\n  '#documentType': doctype\n};\n/**\n * Transform Parse5’s AST to a hast tree.\n *\n * @param {P5Node} ast\n * @param {Options|VFile} [options]\n */\n\nexport function fromParse5(ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /** @type {Options} */\n  let settings;\n  /** @type {VFile|undefined} */\n\n  let file;\n\n  if (isFile(options)) {\n    file = options;\n    settings = {};\n  } else {\n    file = options.file;\n    settings = options;\n  }\n\n  return transform({\n    schema: settings.space === 'svg' ? svg : html,\n    file,\n    verbose: settings.verbose,\n    location: false\n  }, ast);\n}\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {P5Node} ast\n * @returns {Node}\n */\n\nfunction transform(ctx, ast) {\n  const schema = ctx.schema;\n  /** @type {Handler} */\n  // @ts-expect-error: index is fine.\n\n  const fn = own.call(map, ast.nodeName) ? map[ast.nodeName] : element;\n  /** @type {Array.<Child>|undefined} */\n\n  let children; // Element.\n\n  if ('tagName' in ast) {\n    ctx.schema = ast.namespaceURI === webNamespaces.svg ? svg : html;\n  }\n\n  if ('childNodes' in ast) {\n    children = nodes(ctx, ast.childNodes);\n  }\n\n  const result = fn(ctx, ast, children);\n\n  if ('sourceCodeLocation' in ast && ast.sourceCodeLocation && ctx.file) {\n    // @ts-expect-error It’s fine.\n    const position = createLocation(ctx, result, ast.sourceCodeLocation);\n\n    if (position) {\n      ctx.location = true;\n      result.position = position;\n    }\n  }\n\n  ctx.schema = schema;\n  return result;\n}\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {Array.<P5Node>} children\n * @returns {Array.<Child>}\n */\n\n\nfunction nodes(ctx, children) {\n  let index = -1;\n  /** @type {Array.<Child>} */\n\n  const result = [];\n\n  while (++index < children.length) {\n    // @ts-expect-error Assume no roots in children.\n    result[index] = transform(ctx, children[index]);\n  }\n\n  return result;\n}\n/**\n * Transform a document.\n * Stores `ast.quirksMode` in `node.data.quirksMode`.\n *\n * @type {Handler}\n * @param {P5Document} ast\n * @param {Array.<Child>} children\n * @returns {Root}\n */\n\n\nfunction root(ctx, ast, children) {\n  /** @type {Root} */\n  const result = {\n    type: 'root',\n    children,\n    data: {\n      quirksMode: ast.mode === 'quirks' || ast.mode === 'limited-quirks'\n    }\n  };\n\n  if (ctx.file && ctx.location) {\n    const doc = String(ctx.file);\n    const loc = location(doc);\n    result.position = {\n      start: loc.toPoint(0),\n      end: loc.toPoint(doc.length)\n    };\n  }\n\n  return result;\n}\n/**\n * Transform a doctype.\n *\n * @type {Handler}\n * @returns {Doctype}\n */\n\n\nfunction doctype() {\n  // @ts-expect-error Types are out of date.\n  return {\n    type: 'doctype'\n  };\n}\n/**\n * Transform a text.\n *\n * @type {Handler}\n * @param {P5Text} ast\n * @returns {Text}\n */\n\n\nfunction text(_, ast) {\n  return {\n    type: 'text',\n    value: ast.value\n  };\n}\n/**\n * Transform a comment.\n *\n * @type {Handler}\n * @param {P5Comment} ast\n * @returns {Comment}\n */\n\n\nfunction comment(_, ast) {\n  return {\n    type: 'comment',\n    value: ast.data\n  };\n}\n/**\n * Transform an element.\n *\n * @type {Handler}\n * @param {P5Element} ast\n * @param {Array.<ElementChild>} children\n * @returns {Element}\n */\n\n\nfunction element(ctx, ast, children) {\n  const fn = ctx.schema.space === 'svg' ? s : h;\n  let index = -1;\n  /** @type {Object.<string, string>} */\n\n  const props = {};\n\n  while (++index < ast.attrs.length) {\n    const attribute = ast.attrs[index];\n    props[(attribute.prefix ? attribute.prefix + ':' : '') + attribute.name] = attribute.value;\n  }\n\n  const result = fn(ast.tagName, props, children);\n\n  if (result.tagName === 'template' && 'content' in ast) {\n    const pos = ast.sourceCodeLocation;\n    const startTag = pos && pos.startTag && position(pos.startTag);\n    const endTag = pos && pos.endTag && position(pos.endTag);\n    /** @type {Root} */\n    // @ts-expect-error Types are wrong.\n\n    const content = transform(ctx, ast.content);\n\n    if (startTag && endTag && ctx.file) {\n      content.position = {\n        start: startTag.end,\n        end: endTag.start\n      };\n    }\n\n    result.content = content;\n  }\n\n  return result;\n}\n/**\n * Create clean positional information.\n *\n * @param {Context} ctx\n * @param {Node} node\n * @param {P5ElementLocation} location\n * @returns {Position|null}\n */\n\n\nfunction createLocation(ctx, node, location) {\n  const result = position(location);\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]; // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n\n    if (result && !location.endTag && tail && tail.position && tail.position.end) {\n      result.end = Object.assign({}, tail.position.end);\n    }\n\n    if (ctx.verbose) {\n      /** @type {Object.<string, Position|null>} */\n      const props = {};\n      /** @type {string} */\n\n      let key;\n\n      for (key in location.attrs) {\n        if (own.call(location.attrs, key)) {\n          props[find(ctx.schema, key).property] = position(location.attrs[key]);\n        }\n      }\n\n      node.data = {\n        position: {\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      };\n    }\n  }\n\n  return result;\n}\n/**\n * @param {P5Location} loc\n * @returns {Position|null}\n */\n\n\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  });\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  }); // @ts-expect-error `null` is fine.\n\n  return start || end ? {\n    start,\n    end\n  } : null;\n}\n/**\n * @param {Point} point\n * @returns {Point|null}\n */\n\n\nfunction point(point) {\n  return point.line && point.column ? point : null;\n}\n/**\n * @param {VFile|Options} value\n * @returns {value is VFile}\n */\n\n\nfunction isFile(value) {\n  return 'messages' in value;\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/hast-util-from-parse5/lib/index.js"],"names":["h","s","html","svg","find","location","webNamespaces","own","hasOwnProperty","map","root","text","comment","doctype","fromParse5","ast","options","settings","file","isFile","transform","schema","space","verbose","ctx","fn","call","nodeName","element","children","namespaceURI","nodes","childNodes","result","sourceCodeLocation","position","createLocation","index","length","type","data","quirksMode","mode","doc","String","loc","start","toPoint","end","_","value","props","attrs","attribute","prefix","name","tagName","pos","startTag","endTag","content","node","tail","Object","assign","key","property","opening","closing","properties","point","line","startLine","column","startCol","offset","startOffset","endLine","endCol","endOffset"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').DocType} Doctype\n * @typedef {Parent['children'][number]} Child\n * @typedef {Element['children'][number]} ElementChild\n * @typedef {Child|Root} Node\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentType} P5Doctype\n * @typedef {import('parse5').CommentNode} P5Comment\n * @typedef {import('parse5').TextNode} P5Text\n * @typedef {import('parse5').Element} P5Element\n * @typedef {import('parse5').ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Location} P5Location\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {import('parse5').Node} P5Node\n *\n * @typedef {'html'|'svg'} Space\n *\n * @callback Handler\n * @param {Context} ctx\n * @param {P5Node} node\n * @param {Array.<Child>} [children]\n * @returns {Node}\n *\n * @typedef Options\n * @property {Space} [space='html'] Whether the root of the tree is in the `'html'` or `'svg'` space. If an element in with the SVG namespace is found in `ast`, `fromParse5` automatically switches to the SVG space when entering the element, and switches back when leaving\n * @property {VFile} [file] `VFile`, used to add positional information to nodes. If given, the file should have the original HTML source as its contents\n * @property {boolean} [verbose=false] Whether to add extra positional information about starting tags, closing tags, and attributes to elements. Note: not used without `file`\n *\n * @typedef Context\n * @property {Schema} schema\n * @property {VFile|undefined} file\n * @property {boolean|undefined} verbose\n * @property {boolean} location\n */\n\nimport {h, s} from 'hastscript'\nimport {html, svg, find} from 'property-information'\nimport {location} from 'vfile-location'\nimport {webNamespaces} from 'web-namespaces'\n\nconst own = {}.hasOwnProperty\n\n// Handlers.\nconst map = {\n  '#document': root,\n  '#document-fragment': root,\n  '#text': text,\n  '#comment': comment,\n  '#documentType': doctype\n}\n\n/**\n * Transform Parse5’s AST to a hast tree.\n *\n * @param {P5Node} ast\n * @param {Options|VFile} [options]\n */\nexport function fromParse5(ast, options = {}) {\n  /** @type {Options} */\n  let settings\n  /** @type {VFile|undefined} */\n  let file\n\n  if (isFile(options)) {\n    file = options\n    settings = {}\n  } else {\n    file = options.file\n    settings = options\n  }\n\n  return transform(\n    {\n      schema: settings.space === 'svg' ? svg : html,\n      file,\n      verbose: settings.verbose,\n      location: false\n    },\n    ast\n  )\n}\n\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {P5Node} ast\n * @returns {Node}\n */\nfunction transform(ctx, ast) {\n  const schema = ctx.schema\n  /** @type {Handler} */\n  // @ts-expect-error: index is fine.\n  const fn = own.call(map, ast.nodeName) ? map[ast.nodeName] : element\n  /** @type {Array.<Child>|undefined} */\n  let children\n\n  // Element.\n  if ('tagName' in ast) {\n    ctx.schema = ast.namespaceURI === webNamespaces.svg ? svg : html\n  }\n\n  if ('childNodes' in ast) {\n    children = nodes(ctx, ast.childNodes)\n  }\n\n  const result = fn(ctx, ast, children)\n\n  if ('sourceCodeLocation' in ast && ast.sourceCodeLocation && ctx.file) {\n    // @ts-expect-error It’s fine.\n    const position = createLocation(ctx, result, ast.sourceCodeLocation)\n\n    if (position) {\n      ctx.location = true\n      result.position = position\n    }\n  }\n\n  ctx.schema = schema\n\n  return result\n}\n\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {Array.<P5Node>} children\n * @returns {Array.<Child>}\n */\nfunction nodes(ctx, children) {\n  let index = -1\n  /** @type {Array.<Child>} */\n  const result = []\n\n  while (++index < children.length) {\n    // @ts-expect-error Assume no roots in children.\n    result[index] = transform(ctx, children[index])\n  }\n\n  return result\n}\n\n/**\n * Transform a document.\n * Stores `ast.quirksMode` in `node.data.quirksMode`.\n *\n * @type {Handler}\n * @param {P5Document} ast\n * @param {Array.<Child>} children\n * @returns {Root}\n */\nfunction root(ctx, ast, children) {\n  /** @type {Root} */\n  const result = {\n    type: 'root',\n    children,\n    data: {quirksMode: ast.mode === 'quirks' || ast.mode === 'limited-quirks'}\n  }\n\n  if (ctx.file && ctx.location) {\n    const doc = String(ctx.file)\n    const loc = location(doc)\n    result.position = {\n      start: loc.toPoint(0),\n      end: loc.toPoint(doc.length)\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform a doctype.\n *\n * @type {Handler}\n * @returns {Doctype}\n */\nfunction doctype() {\n  // @ts-expect-error Types are out of date.\n  return {type: 'doctype'}\n}\n\n/**\n * Transform a text.\n *\n * @type {Handler}\n * @param {P5Text} ast\n * @returns {Text}\n */\nfunction text(_, ast) {\n  return {type: 'text', value: ast.value}\n}\n\n/**\n * Transform a comment.\n *\n * @type {Handler}\n * @param {P5Comment} ast\n * @returns {Comment}\n */\nfunction comment(_, ast) {\n  return {type: 'comment', value: ast.data}\n}\n\n/**\n * Transform an element.\n *\n * @type {Handler}\n * @param {P5Element} ast\n * @param {Array.<ElementChild>} children\n * @returns {Element}\n */\nfunction element(ctx, ast, children) {\n  const fn = ctx.schema.space === 'svg' ? s : h\n  let index = -1\n  /** @type {Object.<string, string>} */\n  const props = {}\n\n  while (++index < ast.attrs.length) {\n    const attribute = ast.attrs[index]\n    props[(attribute.prefix ? attribute.prefix + ':' : '') + attribute.name] =\n      attribute.value\n  }\n\n  const result = fn(ast.tagName, props, children)\n\n  if (result.tagName === 'template' && 'content' in ast) {\n    const pos = ast.sourceCodeLocation\n    const startTag = pos && pos.startTag && position(pos.startTag)\n    const endTag = pos && pos.endTag && position(pos.endTag)\n\n    /** @type {Root} */\n    // @ts-expect-error Types are wrong.\n    const content = transform(ctx, ast.content)\n\n    if (startTag && endTag && ctx.file) {\n      content.position = {start: startTag.end, end: endTag.start}\n    }\n\n    result.content = content\n  }\n\n  return result\n}\n\n/**\n * Create clean positional information.\n *\n * @param {Context} ctx\n * @param {Node} node\n * @param {P5ElementLocation} location\n * @returns {Position|null}\n */\nfunction createLocation(ctx, node, location) {\n  const result = position(location)\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (\n      result &&\n      !location.endTag &&\n      tail &&\n      tail.position &&\n      tail.position.end\n    ) {\n      result.end = Object.assign({}, tail.position.end)\n    }\n\n    if (ctx.verbose) {\n      /** @type {Object.<string, Position|null>} */\n      const props = {}\n      /** @type {string} */\n      let key\n\n      for (key in location.attrs) {\n        if (own.call(location.attrs, key)) {\n          props[find(ctx.schema, key).property] = position(location.attrs[key])\n        }\n      }\n\n      node.data = {\n        position: {\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {P5Location} loc\n * @returns {Position|null}\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  })\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  })\n  // @ts-expect-error `null` is fine.\n  return start || end ? {start, end} : null\n}\n\n/**\n * @param {Point} point\n * @returns {Point|null}\n */\nfunction point(point) {\n  return point.line && point.column ? point : null\n}\n\n/**\n * @param {VFile|Options} value\n * @returns {value is VFile}\n */\nfunction isFile(value) {\n  return 'messages' in value\n}\n"]},"metadata":{},"sourceType":"module"}
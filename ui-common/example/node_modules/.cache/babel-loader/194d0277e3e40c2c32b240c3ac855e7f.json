{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\nimport { bail } from 'bail';\nimport isBuffer from 'is-buffer';\nimport extend from 'extend';\nimport isPlainObj from 'is-plain-obj';\nimport { trough } from 'trough';\nimport { VFile } from 'vfile'; // Expose a frozen processor.\n\nexport const unified = base().freeze();\nconst own = {}.hasOwnProperty; // Function to create the first processor.\n\n/**\n * @returns {Processor}\n */\n\nfunction base() {\n  const transformers = trough();\n  /** @type {Processor['attachers']} */\n\n  const attachers = [];\n  /** @type {Record<string, unknown>} */\n\n  let namespace = {};\n  /** @type {boolean|undefined} */\n\n  let frozen;\n  let freezeIndex = -1; // Data management.\n  // @ts-expect-error: overloads are handled.\n\n  processor.data = data;\n  processor.Parser = undefined;\n  processor.Compiler = undefined; // Lock.\n\n  processor.freeze = freeze; // Plugins.\n\n  processor.attachers = attachers; // @ts-expect-error: overloads are handled.\n\n  processor.use = use; // API.\n\n  processor.parse = parse;\n  processor.stringify = stringify; // @ts-expect-error: overloads are handled.\n\n  processor.run = run;\n  processor.runSync = runSync; // @ts-expect-error: overloads are handled.\n\n  processor.process = process;\n  processor.processSync = processSync; // Expose.\n\n  return processor; // Create a new processor based on the processor in the current scope.\n\n  /** @type {Processor} */\n\n  function processor() {\n    const destination = base();\n    let index = -1;\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index]);\n    }\n\n    destination.data(extend(true, {}, namespace));\n    return destination;\n  }\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n\n\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen);\n        namespace[key] = value;\n        return processor;\n      } // Get `key`.\n\n\n      return own.call(namespace, key) && namespace[key] || null;\n    } // Set space.\n\n\n    if (key) {\n      assertUnfrozen('data', frozen);\n      namespace = key;\n      return processor;\n    } // Get space.\n\n\n    return namespace;\n  }\n  /** @type {Processor['freeze']} */\n\n\n  function freeze() {\n    if (frozen) {\n      return processor;\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex];\n\n      if (options[0] === false) {\n        continue;\n      }\n\n      if (options[0] === true) {\n        options[1] = undefined;\n      }\n      /** @type {Transformer|void} */\n\n\n      const transformer = attacher.call(processor, ...options);\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer);\n      }\n    }\n\n    frozen = true;\n    freezeIndex = Number.POSITIVE_INFINITY;\n    return processor;\n  }\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n\n\n  function use(value) {\n    for (var _len = arguments.length, options = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      options[_key - 1] = arguments[_key];\n    }\n\n    /** @type {Record<string, unknown>|undefined} */\n    let settings;\n    assertUnfrozen('use', frozen);\n\n    if (value === null || value === undefined) {// Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options);\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value);\n      } else {\n        addPreset(value);\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`');\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings);\n    }\n\n    return processor;\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value);\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value;\n          addPlugin(plugin, ...options);\n        } else {\n          addPreset(value);\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`');\n      }\n    }\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n\n\n    function addPreset(result) {\n      addList(result.plugins);\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings);\n      }\n    }\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n\n\n    function addList(plugins) {\n      let index = -1;\n\n      if (plugins === null || plugins === undefined) {// Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index];\n          add(thing);\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`');\n      }\n    }\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n\n\n    function addPlugin(plugin, value) {\n      let index = -1;\n      /** @type {Processor['attachers'][number]|undefined} */\n\n      let entry;\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index];\n          break;\n        }\n      }\n\n      if (entry) {\n        if (isPlainObj(entry[1]) && isPlainObj(value)) {\n          value = extend(true, entry[1], value);\n        }\n\n        entry[1] = value;\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments]);\n      }\n    }\n  }\n  /** @type {Processor['parse']} */\n\n\n  function parse(doc) {\n    processor.freeze();\n    const file = vfile(doc);\n    const Parser = processor.Parser;\n    assertParser('parse', Parser);\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse();\n    } // @ts-expect-error: `newable` checks this.\n\n\n    return Parser(String(file), file); // eslint-disable-line new-cap\n  }\n  /** @type {Processor['stringify']} */\n\n\n  function stringify(node, doc) {\n    processor.freeze();\n    const file = vfile(doc);\n    const Compiler = processor.Compiler;\n    assertCompiler('stringify', Compiler);\n    assertNode(node);\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile();\n    } // @ts-expect-error: `newable` checks this.\n\n\n    return Compiler(node, file); // eslint-disable-line new-cap\n  }\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n\n\n  function run(node, doc, callback) {\n    assertNode(node);\n    processor.freeze();\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc;\n      doc = undefined;\n    }\n\n    if (!callback) {\n      return new Promise(executor);\n    }\n\n    executor(null, callback);\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` canâ€™t be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done);\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n\n      function done(error, tree, file) {\n        tree = tree || node;\n\n        if (error) {\n          reject(error);\n        } else if (resolve) {\n          resolve(tree);\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file);\n        }\n      }\n    }\n  }\n  /** @type {Processor['runSync']} */\n\n\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result;\n    /** @type {boolean|undefined} */\n\n    let complete;\n    processor.run(node, file, done);\n    assertDone('runSync', 'run', complete); // @ts-expect-error: we either bailed on an error or have a tree.\n\n    return result;\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n\n    function done(error, tree) {\n      bail(error);\n      result = tree;\n      complete = true;\n    }\n  }\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n\n\n  function process(doc, callback) {\n    processor.freeze();\n    assertParser('process', processor.Parser);\n    assertCompiler('process', processor.Compiler);\n\n    if (!callback) {\n      return new Promise(executor);\n    }\n\n    executor(null, callback);\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n\n    function executor(resolve, reject) {\n      const file = vfile(doc);\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error);\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file);\n\n          if (result === undefined || result === null) {// Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result;\n          } else {\n            file.result = result;\n          }\n\n          done(error, file);\n        }\n      });\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n\n      function done(error, file) {\n        if (error || !file) {\n          reject(error);\n        } else if (resolve) {\n          resolve(file);\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file);\n        }\n      }\n    }\n  }\n  /** @type {Processor['processSync']} */\n\n\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete;\n    processor.freeze();\n    assertParser('processSync', processor.Parser);\n    assertCompiler('processSync', processor.Compiler);\n    const file = vfile(doc);\n    processor.process(file, done);\n    assertDone('processSync', 'process', complete);\n    return file;\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n\n    function done(error) {\n      complete = true;\n      bail(error);\n    }\n  }\n}\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\n\n\nfunction newable(value, name) {\n  return typeof value === 'function' && // Prototypes do exist.\n  // type-coverage:ignore-next-line\n  value.prototype && ( // A function with keys in its prototype is probably a constructor.\n  // Classesâ€™ prototype methods are not enumerable, so we check if some value\n  // exists in the prototype.\n  // type-coverage:ignore-next-line\n  keys(value.prototype) || name in value.prototype);\n}\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\n\n\nfunction keys(value) {\n  /** @type {string} */\n  let key;\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\n\n\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`');\n  }\n}\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\n\n\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`');\n  }\n}\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\n\n\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error('Cannot call `' + name + '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.');\n  }\n}\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\n\n\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`'); // Fine.\n  }\n}\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\n\n\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');\n  }\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\n\n\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value);\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\n\n\nfunction looksLikeAVFile(value) {\n  return Boolean(value && typeof value === 'object' && 'message' in value && 'messages' in value);\n}\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\n\n\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || isBuffer(value);\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/unified/lib/index.js"],"names":["bail","isBuffer","extend","isPlainObj","trough","VFile","unified","base","freeze","own","hasOwnProperty","transformers","attachers","namespace","frozen","freezeIndex","processor","data","Parser","undefined","Compiler","use","parse","stringify","run","runSync","process","processSync","destination","index","length","key","value","arguments","assertUnfrozen","call","attacher","options","transformer","Number","POSITIVE_INFINITY","settings","addPlugin","Array","isArray","addList","addPreset","TypeError","Object","assign","add","plugin","result","plugins","thing","entry","push","doc","file","vfile","assertParser","newable","String","node","assertCompiler","assertNode","compile","callback","Promise","executor","resolve","reject","done","error","tree","complete","assertDone","looksLikeAVFileValue","name","prototype","keys","Error","type","asyncName","looksLikeAVFile","Boolean"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\n\nimport {bail} from 'bail'\nimport isBuffer from 'is-buffer'\nimport extend from 'extend'\nimport isPlainObj from 'is-plain-obj'\nimport {trough} from 'trough'\nimport {VFile} from 'vfile'\n\n// Expose a frozen processor.\nexport const unified = base().freeze()\n\nconst own = {}.hasOwnProperty\n\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */\nfunction base() {\n  const transformers = trough()\n  /** @type {Processor['attachers']} */\n  const attachers = []\n  /** @type {Record<string, unknown>} */\n  let namespace = {}\n  /** @type {boolean|undefined} */\n  let frozen\n  let freezeIndex = -1\n\n  // Data management.\n  // @ts-expect-error: overloads are handled.\n  processor.data = data\n  processor.Parser = undefined\n  processor.Compiler = undefined\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  // @ts-expect-error: overloads are handled.\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  // @ts-expect-error: overloads are handled.\n  processor.run = run\n  processor.runSync = runSync\n  // @ts-expect-error: overloads are handled.\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  /** @type {Processor} */\n  function processor() {\n    const destination = base()\n    let index = -1\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  /** @type {Processor['freeze']} */\n  function freeze() {\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[1] = undefined\n      }\n\n      /** @type {Transformer|void} */\n      const transformer = attacher.call(processor, ...options)\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Number.POSITIVE_INFINITY\n\n    return processor\n  }\n\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n  function use(value, ...options) {\n    /** @type {Record<string, unknown>|undefined} */\n    let settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value\n          addPlugin(plugin, ...options)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n    function addPlugin(plugin, value) {\n      let index = -1\n      /** @type {Processor['attachers'][number]|undefined} */\n      let entry\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index]\n          break\n        }\n      }\n\n      if (entry) {\n        if (isPlainObj(entry[1]) && isPlainObj(value)) {\n          value = extend(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments])\n      }\n    }\n  }\n\n  /** @type {Processor['parse']} */\n  function parse(doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /** @type {Processor['stringify']} */\n  function stringify(node, doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n  function run(node, doc, callback) {\n    assertNode(node)\n    processor.freeze()\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc\n      doc = undefined\n    }\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` canâ€™t be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done)\n\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['runSync']} */\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    // @ts-expect-error: we either bailed on an error or have a tree.\n    return result\n\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n    function done(error, tree) {\n      bail(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n  function process(doc, callback) {\n    processor.freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      const file = vfile(doc)\n\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error)\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file)\n\n          if (result === undefined || result === null) {\n            // Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result\n          } else {\n            file.result = result\n          }\n\n          done(error, file)\n        }\n      })\n\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n      function done(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['processSync']} */\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n\n    const file = vfile(doc)\n\n    processor.process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n    function done(error) {\n      complete = true\n      bail(error)\n    }\n  }\n}\n\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classesâ€™ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\nfunction keys(value) {\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value)\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || isBuffer(value)\n}\n"]},"metadata":{},"sourceType":"module"}
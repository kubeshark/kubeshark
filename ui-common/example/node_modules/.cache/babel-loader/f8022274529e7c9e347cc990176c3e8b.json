{"ast":null,"code":"import { Children, cloneElement, isValidElement } from 'react';\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\n\nexport function getChildMapping(children, mapFn) {\n  var mapper = function mapper(child) {\n    return mapFn && isValidElement(child) ? mapFn(child) : child;\n  };\n\n  var result = Object.create(null);\n  if (children) Children.map(children, function (c) {\n    return c;\n  }).forEach(function (child) {\n    // run the map function here instead so that the key is the computed one\n    result[child.key] = mapper(child);\n  });\n  return result;\n}\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\n\nexport function mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    return key in next ? next[key] : prev[key];\n  } // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  var nextKeysPending = Object.create(null);\n  var pendingKeys = [];\n\n  for (var prevKey in prev) {\n    if (prevKey in next) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i;\n  var childMapping = {};\n\n  for (var nextKey in next) {\n    if (nextKeysPending[nextKey]) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nfunction getProp(child, prop, props) {\n  return props[prop] != null ? props[prop] : child.props[prop];\n}\n\nexport function getInitialChildMapping(props, onExited) {\n  return getChildMapping(props.children, function (child) {\n    return cloneElement(child, {\n      onExited: onExited.bind(null, child),\n      in: true,\n      appear: getProp(child, 'appear', props),\n      enter: getProp(child, 'enter', props),\n      exit: getProp(child, 'exit', props)\n    });\n  });\n}\nexport function getNextChildMapping(nextProps, prevChildMapping, onExited) {\n  var nextChildMapping = getChildMapping(nextProps.children);\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\n  Object.keys(children).forEach(function (key) {\n    var child = children[key];\n    if (!isValidElement(child)) return;\n    var hasPrev = (key in prevChildMapping);\n    var hasNext = (key in nextChildMapping);\n    var prevChild = prevChildMapping[key];\n    var isLeaving = isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)\n\n    if (hasNext && (!hasPrev || isLeaving)) {\n      // console.log('entering', key)\n      children[key] = cloneElement(child, {\n        onExited: onExited.bind(null, child),\n        in: true,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    } else if (!hasNext && hasPrev && !isLeaving) {\n      // item is old (exiting)\n      // console.log('leaving', key)\n      children[key] = cloneElement(child, {\n        in: false\n      });\n    } else if (hasNext && hasPrev && isValidElement(prevChild)) {\n      // item hasn't changed transition states\n      // copy over the last transition props;\n      // console.log('unchanged', key)\n      children[key] = cloneElement(child, {\n        onExited: onExited.bind(null, child),\n        in: prevChild.props.in,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    }\n  });\n  return children;\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/react-transition-group/esm/utils/ChildMapping.js"],"names":["Children","cloneElement","isValidElement","getChildMapping","children","mapFn","mapper","child","result","Object","create","map","c","forEach","key","mergeChildMappings","prev","next","getValueForKey","nextKeysPending","pendingKeys","prevKey","length","push","i","childMapping","nextKey","pendingNextKey","getProp","prop","props","getInitialChildMapping","onExited","bind","in","appear","enter","exit","getNextChildMapping","nextProps","prevChildMapping","nextChildMapping","keys","hasPrev","hasNext","prevChild","isLeaving"],"mappings":"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","sourcesContent":["import { Children, cloneElement, isValidElement } from 'react';\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\n\nexport function getChildMapping(children, mapFn) {\n  var mapper = function mapper(child) {\n    return mapFn && isValidElement(child) ? mapFn(child) : child;\n  };\n\n  var result = Object.create(null);\n  if (children) Children.map(children, function (c) {\n    return c;\n  }).forEach(function (child) {\n    // run the map function here instead so that the key is the computed one\n    result[child.key] = mapper(child);\n  });\n  return result;\n}\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\n\nexport function mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    return key in next ? next[key] : prev[key];\n  } // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  var nextKeysPending = Object.create(null);\n  var pendingKeys = [];\n\n  for (var prevKey in prev) {\n    if (prevKey in next) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i;\n  var childMapping = {};\n\n  for (var nextKey in next) {\n    if (nextKeysPending[nextKey]) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nfunction getProp(child, prop, props) {\n  return props[prop] != null ? props[prop] : child.props[prop];\n}\n\nexport function getInitialChildMapping(props, onExited) {\n  return getChildMapping(props.children, function (child) {\n    return cloneElement(child, {\n      onExited: onExited.bind(null, child),\n      in: true,\n      appear: getProp(child, 'appear', props),\n      enter: getProp(child, 'enter', props),\n      exit: getProp(child, 'exit', props)\n    });\n  });\n}\nexport function getNextChildMapping(nextProps, prevChildMapping, onExited) {\n  var nextChildMapping = getChildMapping(nextProps.children);\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\n  Object.keys(children).forEach(function (key) {\n    var child = children[key];\n    if (!isValidElement(child)) return;\n    var hasPrev = (key in prevChildMapping);\n    var hasNext = (key in nextChildMapping);\n    var prevChild = prevChildMapping[key];\n    var isLeaving = isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)\n\n    if (hasNext && (!hasPrev || isLeaving)) {\n      // console.log('entering', key)\n      children[key] = cloneElement(child, {\n        onExited: onExited.bind(null, child),\n        in: true,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    } else if (!hasNext && hasPrev && !isLeaving) {\n      // item is old (exiting)\n      // console.log('leaving', key)\n      children[key] = cloneElement(child, {\n        in: false\n      });\n    } else if (hasNext && hasPrev && isValidElement(prevChild)) {\n      // item hasn't changed transition states\n      // copy over the last transition props;\n      // console.log('unchanged', key)\n      children[key] = cloneElement(child, {\n        onExited: onExited.bind(null, child),\n        in: prevChild.props.in,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    }\n  });\n  return children;\n}"]},"metadata":{},"sourceType":"module"}
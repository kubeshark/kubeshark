{"ast":null,"code":"export class SelectionText {\n  constructor(elm) {\n    this.elm = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.value = void 0;\n    var {\n      selectionStart,\n      selectionEnd\n    } = elm;\n    this.elm = elm;\n    this.start = selectionStart;\n    this.end = selectionEnd;\n    this.value = this.elm.value;\n  }\n\n  position(start, end) {\n    var {\n      selectionStart,\n      selectionEnd\n    } = this.elm;\n    this.start = typeof start === 'number' && !isNaN(start) ? start : selectionStart;\n    this.end = typeof end === 'number' && !isNaN(end) ? end : selectionEnd;\n    this.elm.selectionStart = this.start;\n    this.elm.selectionEnd = this.end;\n    return this;\n  }\n\n  insertText(text) {\n    // Most of the used APIs only work with the field selected\n    this.elm.focus();\n    this.elm.setRangeText(text);\n    this.value = this.elm.value;\n    this.position();\n    return this;\n  }\n\n  getSelectedValue(start, end) {\n    var {\n      selectionStart,\n      selectionEnd\n    } = this.elm;\n    return this.value.slice(typeof start === 'number' && !isNaN(start) ? start : selectionStart, typeof end === 'number' && !isNaN(end) ? start : selectionEnd);\n  }\n\n  getLineStartNumber() {\n    var start = this.start;\n\n    while (start > 0) {\n      start--;\n\n      if (this.value.charAt(start) === '\\n') {\n        start++;\n        break;\n      }\n    }\n\n    return start;\n  }\n  /** Indent on new lines */\n\n\n  getIndentText() {\n    var start = this.getLineStartNumber();\n    var str = this.getSelectedValue(start);\n    var indent = '';\n    str.replace(/(^(\\s)+)/, (str, old) => indent = old);\n    return indent;\n  }\n\n  lineStarInstert(text) {\n    if (text) {\n      var oldStart = this.start;\n      var start = this.getLineStartNumber();\n      var str = this.getSelectedValue(start);\n      this.position(start, this.end).insertText(str.split('\\n').map(txt => text + txt).join('\\n')).position(oldStart + text.length, this.end);\n    }\n\n    return this;\n  }\n\n  lineStarRemove(text) {\n    if (text) {\n      var oldStart = this.start;\n      var start = this.getLineStartNumber();\n      var str = this.getSelectedValue(start);\n      var reg = new RegExp(\"^\" + text, 'g');\n      var newStart = oldStart - text.length;\n\n      if (!reg.test(str)) {\n        newStart = oldStart;\n      }\n\n      this.position(start, this.end).insertText(str.split('\\n').map(txt => txt.replace(reg, '')).join('\\n')).position(newStart, this.end);\n    }\n  }\n  /** Notify any possible listeners of the change */\n\n\n  notifyChange() {\n    var event = new Event('input', {\n      bubbles: true,\n      cancelable: false\n    });\n    this.elm.dispatchEvent(event);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["SelectionText","constructor","elm","start","end","value","selectionStart","selectionEnd","position","isNaN","insertText","text","focus","setRangeText","getSelectedValue","slice","getLineStartNumber","charAt","getIndentText","str","indent","replace","old","lineStarInstert","oldStart","split","map","txt","join","length","lineStarRemove","reg","RegExp","newStart","test","notifyChange","event","Event","bubbles","cancelable","dispatchEvent"],"sources":["../src/SelectionText.ts"],"sourcesContent":["export class SelectionText {\n  elm: HTMLTextAreaElement;\n  start: number;\n  end: number;\n  value: string;\n  constructor(elm: HTMLTextAreaElement) {\n    const { selectionStart, selectionEnd } = elm;\n    this.elm = elm;\n    this.start = selectionStart;\n    this.end = selectionEnd;\n    this.value = this.elm.value;\n  }\n  position(start?: number, end?: number) {\n    const { selectionStart, selectionEnd } = this.elm;\n    this.start = typeof start === 'number' && !isNaN(start) ? start : selectionStart;\n    this.end = typeof end === 'number' && !isNaN(end) ? end : selectionEnd;\n    this.elm.selectionStart = this.start;\n    this.elm.selectionEnd = this.end;\n    return this;\n  }\n  insertText(text: string) {\n    // Most of the used APIs only work with the field selected\n    this.elm.focus();\n    this.elm.setRangeText(text);\n    this.value = this.elm.value;\n    this.position();\n    return this;\n  }\n  getSelectedValue(start?: number, end?: number) {\n    const { selectionStart, selectionEnd } = this.elm;\n    return this.value.slice(\n      typeof start === 'number' && !isNaN(start) ? start : selectionStart,\n      typeof end === 'number' && !isNaN(end) ? start : selectionEnd,\n    );\n  }\n  getLineStartNumber() {\n    let start = this.start;\n    while (start > 0) {\n      start--;\n      if (this.value.charAt(start) === '\\n') {\n        start++;\n        break;\n      }\n    }\n    return start;\n  }\n  /** Indent on new lines */\n  getIndentText() {\n    const start = this.getLineStartNumber();\n    const str = this.getSelectedValue(start);\n    let indent = '';\n    str.replace(/(^(\\s)+)/, (str, old) => (indent = old));\n    return indent;\n  }\n  lineStarInstert(text: string) {\n    if (text) {\n      const oldStart = this.start;\n      const start = this.getLineStartNumber();\n      const str = this.getSelectedValue(start);\n      this.position(start, this.end)\n        .insertText(\n          str\n            .split('\\n')\n            .map((txt) => text + txt)\n            .join('\\n'),\n        )\n        .position(oldStart + text.length, this.end);\n    }\n    return this;\n  }\n  lineStarRemove(text: string) {\n    if (text) {\n      const oldStart = this.start;\n      const start = this.getLineStartNumber();\n      const str = this.getSelectedValue(start);\n      const reg = new RegExp(`^${text}`, 'g');\n      let newStart = oldStart - text.length;\n      if (!reg.test(str)) {\n        newStart = oldStart;\n      }\n      this.position(start, this.end)\n        .insertText(\n          str\n            .split('\\n')\n            .map((txt) => txt.replace(reg, ''))\n            .join('\\n'),\n        )\n        .position(newStart, this.end);\n    }\n  }\n  /** Notify any possible listeners of the change */\n  notifyChange() {\n    const event = new Event('input', { bubbles: true, cancelable: false });\n    this.elm.dispatchEvent(event);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
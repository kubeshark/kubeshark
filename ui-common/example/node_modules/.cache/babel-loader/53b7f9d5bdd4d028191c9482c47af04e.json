{"ast":null,"code":"/**\n * @typedef {import('./util/schema.js').Schema} Schema\n */\nimport { normalize } from './normalize.js';\nimport { DefinedInfo } from './util/defined-info.js';\nimport { Info } from './util/info.js';\nconst valid = /^data[-\\w.:]+$/i;\nconst dash = /-[a-z]/g;\nconst cap = /[A-Z]/g;\n/**\n * @param {Schema} schema\n * @param {string} value\n * @returns {Info}\n */\n\nexport function find(schema, value) {\n  const normal = normalize(value);\n  let prop = value;\n  let Type = Info;\n\n  if (normal in schema.normal) {\n    return schema.property[schema.normal[normal]];\n  }\n\n  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {\n    // Attribute or property.\n    if (value.charAt(4) === '-') {\n      // Turn it into a property.\n      const rest = value.slice(5).replace(dash, camelcase);\n      prop = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1);\n    } else {\n      // Turn it into an attribute.\n      const rest = value.slice(4);\n\n      if (!dash.test(rest)) {\n        let dashes = rest.replace(cap, kebab);\n\n        if (dashes.charAt(0) !== '-') {\n          dashes = '-' + dashes;\n        }\n\n        value = 'data' + dashes;\n      }\n    }\n\n    Type = DefinedInfo;\n  }\n\n  return new Type(prop, value);\n}\n/**\n * @param {string} $0\n * @returns {string}\n */\n\nfunction kebab($0) {\n  return '-' + $0.toLowerCase();\n}\n/**\n * @param {string} $0\n * @returns {string}\n */\n\n\nfunction camelcase($0) {\n  return $0.charAt(1).toUpperCase();\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/hast-util-from-parse5/node_modules/property-information/lib/find.js"],"names":["normalize","DefinedInfo","Info","valid","dash","cap","find","schema","value","normal","prop","Type","property","length","slice","test","charAt","rest","replace","camelcase","toUpperCase","dashes","kebab","$0","toLowerCase"],"mappings":"AAAA;AACA;AACA;AAEA,SAAQA,SAAR,QAAwB,gBAAxB;AACA,SAAQC,WAAR,QAA0B,wBAA1B;AACA,SAAQC,IAAR,QAAmB,gBAAnB;AAEA,MAAMC,KAAK,GAAG,iBAAd;AACA,MAAMC,IAAI,GAAG,SAAb;AACA,MAAMC,GAAG,GAAG,QAAZ;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,IAAT,CAAcC,MAAd,EAAsBC,KAAtB,EAA6B;AAClC,QAAMC,MAAM,GAAGT,SAAS,CAACQ,KAAD,CAAxB;AACA,MAAIE,IAAI,GAAGF,KAAX;AACA,MAAIG,IAAI,GAAGT,IAAX;;AAEA,MAAIO,MAAM,IAAIF,MAAM,CAACE,MAArB,EAA6B;AAC3B,WAAOF,MAAM,CAACK,QAAP,CAAgBL,MAAM,CAACE,MAAP,CAAcA,MAAd,CAAhB,CAAP;AACD;;AAED,MAAIA,MAAM,CAACI,MAAP,GAAgB,CAAhB,IAAqBJ,MAAM,CAACK,KAAP,CAAa,CAAb,EAAgB,CAAhB,MAAuB,MAA5C,IAAsDX,KAAK,CAACY,IAAN,CAAWP,KAAX,CAA1D,EAA6E;AAC3E;AACA,QAAIA,KAAK,CAACQ,MAAN,CAAa,CAAb,MAAoB,GAAxB,EAA6B;AAC3B;AACA,YAAMC,IAAI,GAAGT,KAAK,CAACM,KAAN,CAAY,CAAZ,EAAeI,OAAf,CAAuBd,IAAvB,EAA6Be,SAA7B,CAAb;AACAT,MAAAA,IAAI,GAAG,SAASO,IAAI,CAACD,MAAL,CAAY,CAAZ,EAAeI,WAAf,EAAT,GAAwCH,IAAI,CAACH,KAAL,CAAW,CAAX,CAA/C;AACD,KAJD,MAIO;AACL;AACA,YAAMG,IAAI,GAAGT,KAAK,CAACM,KAAN,CAAY,CAAZ,CAAb;;AAEA,UAAI,CAACV,IAAI,CAACW,IAAL,CAAUE,IAAV,CAAL,EAAsB;AACpB,YAAII,MAAM,GAAGJ,IAAI,CAACC,OAAL,CAAab,GAAb,EAAkBiB,KAAlB,CAAb;;AAEA,YAAID,MAAM,CAACL,MAAP,CAAc,CAAd,MAAqB,GAAzB,EAA8B;AAC5BK,UAAAA,MAAM,GAAG,MAAMA,MAAf;AACD;;AAEDb,QAAAA,KAAK,GAAG,SAASa,MAAjB;AACD;AACF;;AAEDV,IAAAA,IAAI,GAAGV,WAAP;AACD;;AAED,SAAO,IAAIU,IAAJ,CAASD,IAAT,EAAeF,KAAf,CAAP;AACD;AAED;AACA;AACA;AACA;;AACA,SAASc,KAAT,CAAeC,EAAf,EAAmB;AACjB,SAAO,MAAMA,EAAE,CAACC,WAAH,EAAb;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASL,SAAT,CAAmBI,EAAnB,EAAuB;AACrB,SAAOA,EAAE,CAACP,MAAH,CAAU,CAAV,EAAaI,WAAb,EAAP;AACD","sourcesContent":["/**\n * @typedef {import('./util/schema.js').Schema} Schema\n */\n\nimport {normalize} from './normalize.js'\nimport {DefinedInfo} from './util/defined-info.js'\nimport {Info} from './util/info.js'\n\nconst valid = /^data[-\\w.:]+$/i\nconst dash = /-[a-z]/g\nconst cap = /[A-Z]/g\n\n/**\n * @param {Schema} schema\n * @param {string} value\n * @returns {Info}\n */\nexport function find(schema, value) {\n  const normal = normalize(value)\n  let prop = value\n  let Type = Info\n\n  if (normal in schema.normal) {\n    return schema.property[schema.normal[normal]]\n  }\n\n  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {\n    // Attribute or property.\n    if (value.charAt(4) === '-') {\n      // Turn it into a property.\n      const rest = value.slice(5).replace(dash, camelcase)\n      prop = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1)\n    } else {\n      // Turn it into an attribute.\n      const rest = value.slice(4)\n\n      if (!dash.test(rest)) {\n        let dashes = rest.replace(cap, kebab)\n\n        if (dashes.charAt(0) !== '-') {\n          dashes = '-' + dashes\n        }\n\n        value = 'data' + dashes\n      }\n    }\n\n    Type = DefinedInfo\n  }\n\n  return new Type(prop, value)\n}\n\n/**\n * @param {string} $0\n * @returns {string}\n */\nfunction kebab($0) {\n  return '-' + $0.toLowerCase()\n}\n\n/**\n * @param {string} $0\n * @returns {string}\n */\nfunction camelcase($0) {\n  return $0.charAt(1).toUpperCase()\n}\n"]},"metadata":{},"sourceType":"module"}
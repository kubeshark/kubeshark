{"ast":null,"code":"'use strict';\n\nconst Mixin = require('../../utils/mixin');\n\nconst Tokenizer = require('../../tokenizer');\n\nconst LocationInfoTokenizerMixin = require('./tokenizer-mixin');\n\nconst LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\n\nconst HTML = require('../../common/html'); //Aliases\n\n\nconst $ = HTML.TAG_NAMES;\n\nclass LocationInfoParserMixin extends Mixin {\n  constructor(parser) {\n    super(parser);\n    this.parser = parser;\n    this.treeAdapter = this.parser.treeAdapter;\n    this.posTracker = null;\n    this.lastStartTagToken = null;\n    this.lastFosterParentingLocation = null;\n    this.currentToken = null;\n  }\n\n  _setStartLocation(element) {\n    let loc = null;\n\n    if (this.lastStartTagToken) {\n      loc = Object.assign({}, this.lastStartTagToken.location);\n      loc.startTag = this.lastStartTagToken.location;\n    }\n\n    this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n  }\n\n  _setEndLocation(element, closingToken) {\n    const loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n    if (loc) {\n      if (closingToken.location) {\n        const ctLoc = closingToken.location;\n        const tn = this.treeAdapter.getTagName(element); // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n\n        const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n        const endLoc = {};\n\n        if (isClosingEndTag) {\n          endLoc.endTag = Object.assign({}, ctLoc);\n          endLoc.endLine = ctLoc.endLine;\n          endLoc.endCol = ctLoc.endCol;\n          endLoc.endOffset = ctLoc.endOffset;\n        } else {\n          endLoc.endLine = ctLoc.startLine;\n          endLoc.endCol = ctLoc.startCol;\n          endLoc.endOffset = ctLoc.startOffset;\n        }\n\n        this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);\n      }\n    }\n  }\n\n  _getOverriddenMethods(mxn, orig) {\n    return {\n      _bootstrap(document, fragmentContext) {\n        orig._bootstrap.call(this, document, fragmentContext);\n\n        mxn.lastStartTagToken = null;\n        mxn.lastFosterParentingLocation = null;\n        mxn.currentToken = null;\n        const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n        mxn.posTracker = tokenizerMixin.posTracker;\n        Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n          onItemPop: function (element) {\n            mxn._setEndLocation(element, mxn.currentToken);\n          }\n        });\n      },\n\n      _runParsingLoop(scriptHandler) {\n        orig._runParsingLoop.call(this, scriptHandler); // NOTE: generate location info for elements\n        // that remains on open element stack\n\n\n        for (let i = this.openElements.stackTop; i >= 0; i--) {\n          mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n        }\n      },\n\n      //Token processing\n      _processTokenInForeignContent(token) {\n        mxn.currentToken = token;\n\n        orig._processTokenInForeignContent.call(this, token);\n      },\n\n      _processToken(token) {\n        mxn.currentToken = token;\n\n        orig._processToken.call(this, token); //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n        //their end location explicitly.\n\n\n        const requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY));\n\n        if (requireExplicitUpdate) {\n          for (let i = this.openElements.stackTop; i >= 0; i--) {\n            const element = this.openElements.items[i];\n\n            if (this.treeAdapter.getTagName(element) === token.tagName) {\n              mxn._setEndLocation(element, token);\n\n              break;\n            }\n          }\n        }\n      },\n\n      //Doctype\n      _setDocumentType(token) {\n        orig._setDocumentType.call(this, token);\n\n        const documentChildren = this.treeAdapter.getChildNodes(this.document);\n        const cnLength = documentChildren.length;\n\n        for (let i = 0; i < cnLength; i++) {\n          const node = documentChildren[i];\n\n          if (this.treeAdapter.isDocumentTypeNode(node)) {\n            this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n            break;\n          }\n        }\n      },\n\n      //Elements\n      _attachElementToTree(element) {\n        //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n        //So we will use token location stored in this methods for the element.\n        mxn._setStartLocation(element);\n\n        mxn.lastStartTagToken = null;\n\n        orig._attachElementToTree.call(this, element);\n      },\n\n      _appendElement(token, namespaceURI) {\n        mxn.lastStartTagToken = token;\n\n        orig._appendElement.call(this, token, namespaceURI);\n      },\n\n      _insertElement(token, namespaceURI) {\n        mxn.lastStartTagToken = token;\n\n        orig._insertElement.call(this, token, namespaceURI);\n      },\n\n      _insertTemplate(token) {\n        mxn.lastStartTagToken = token;\n\n        orig._insertTemplate.call(this, token);\n\n        const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n        this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n      },\n\n      _insertFakeRootElement() {\n        orig._insertFakeRootElement.call(this);\n\n        this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n      },\n\n      //Comments\n      _appendCommentNode(token, parent) {\n        orig._appendCommentNode.call(this, token, parent);\n\n        const children = this.treeAdapter.getChildNodes(parent);\n        const commentNode = children[children.length - 1];\n        this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n      },\n\n      //Text\n      _findFosterParentingLocation() {\n        //NOTE: store last foster parenting location, so we will be able to find inserted text\n        //in case of foster parenting\n        mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n        return mxn.lastFosterParentingLocation;\n      },\n\n      _insertCharacters(token) {\n        orig._insertCharacters.call(this, token);\n\n        const hasFosterParent = this._shouldFosterParentOnInsertion();\n\n        const parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;\n        const siblings = this.treeAdapter.getChildNodes(parent);\n        const textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;\n        const textNode = siblings[textNodeIdx]; //NOTE: if we have location assigned by another token, then just update end position\n\n        const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n        if (tnLoc) {\n          const {\n            endLine,\n            endCol,\n            endOffset\n          } = token.location;\n          this.treeAdapter.updateNodeSourceCodeLocation(textNode, {\n            endLine,\n            endCol,\n            endOffset\n          });\n        } else {\n          this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n        }\n      }\n\n    };\n  }\n\n}\n\nmodule.exports = LocationInfoParserMixin;","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/parse5/lib/extensions/location-info/parser-mixin.js"],"names":["Mixin","require","Tokenizer","LocationInfoTokenizerMixin","LocationInfoOpenElementStackMixin","HTML","$","TAG_NAMES","LocationInfoParserMixin","constructor","parser","treeAdapter","posTracker","lastStartTagToken","lastFosterParentingLocation","currentToken","_setStartLocation","element","loc","Object","assign","location","startTag","setNodeSourceCodeLocation","_setEndLocation","closingToken","getNodeSourceCodeLocation","ctLoc","tn","getTagName","isClosingEndTag","type","END_TAG_TOKEN","tagName","endLoc","endTag","endLine","endCol","endOffset","startLine","startCol","startOffset","updateNodeSourceCodeLocation","_getOverriddenMethods","mxn","orig","_bootstrap","document","fragmentContext","call","tokenizerMixin","install","tokenizer","openElements","onItemPop","_runParsingLoop","scriptHandler","i","stackTop","items","_processTokenInForeignContent","token","_processToken","requireExplicitUpdate","BODY","hasInScope","_setDocumentType","documentChildren","getChildNodes","cnLength","length","node","isDocumentTypeNode","_attachElementToTree","_appendElement","namespaceURI","_insertElement","_insertTemplate","tmplContent","getTemplateContent","current","_insertFakeRootElement","_appendCommentNode","parent","children","commentNode","_findFosterParentingLocation","_insertCharacters","hasFosterParent","_shouldFosterParentOnInsertion","currentTmplContent","siblings","textNodeIdx","beforeElement","indexOf","textNode","tnLoc","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Mixin = require('../../utils/mixin');\nconst Tokenizer = require('../../tokenizer');\nconst LocationInfoTokenizerMixin = require('./tokenizer-mixin');\nconst LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\nconst HTML = require('../../common/html');\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\n\nclass LocationInfoParserMixin extends Mixin {\n    constructor(parser) {\n        super(parser);\n\n        this.parser = parser;\n        this.treeAdapter = this.parser.treeAdapter;\n        this.posTracker = null;\n        this.lastStartTagToken = null;\n        this.lastFosterParentingLocation = null;\n        this.currentToken = null;\n    }\n\n    _setStartLocation(element) {\n        let loc = null;\n\n        if (this.lastStartTagToken) {\n            loc = Object.assign({}, this.lastStartTagToken.location);\n            loc.startTag = this.lastStartTagToken.location;\n        }\n\n        this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n    }\n\n    _setEndLocation(element, closingToken) {\n        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n        if (loc) {\n            if (closingToken.location) {\n                const ctLoc = closingToken.location;\n                const tn = this.treeAdapter.getTagName(element);\n\n                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n                const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n                const endLoc = {};\n                if (isClosingEndTag) {\n                    endLoc.endTag = Object.assign({}, ctLoc);\n                    endLoc.endLine = ctLoc.endLine;\n                    endLoc.endCol = ctLoc.endCol;\n                    endLoc.endOffset = ctLoc.endOffset;\n                } else {\n                    endLoc.endLine = ctLoc.startLine;\n                    endLoc.endCol = ctLoc.startCol;\n                    endLoc.endOffset = ctLoc.startOffset;\n                }\n\n                this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);\n            }\n        }\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        return {\n            _bootstrap(document, fragmentContext) {\n                orig._bootstrap.call(this, document, fragmentContext);\n\n                mxn.lastStartTagToken = null;\n                mxn.lastFosterParentingLocation = null;\n                mxn.currentToken = null;\n\n                const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n\n                mxn.posTracker = tokenizerMixin.posTracker;\n\n                Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n                    onItemPop: function(element) {\n                        mxn._setEndLocation(element, mxn.currentToken);\n                    }\n                });\n            },\n\n            _runParsingLoop(scriptHandler) {\n                orig._runParsingLoop.call(this, scriptHandler);\n\n                // NOTE: generate location info for elements\n                // that remains on open element stack\n                for (let i = this.openElements.stackTop; i >= 0; i--) {\n                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n                }\n            },\n\n            //Token processing\n            _processTokenInForeignContent(token) {\n                mxn.currentToken = token;\n                orig._processTokenInForeignContent.call(this, token);\n            },\n\n            _processToken(token) {\n                mxn.currentToken = token;\n                orig._processToken.call(this, token);\n\n                //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n                //their end location explicitly.\n                const requireExplicitUpdate =\n                    token.type === Tokenizer.END_TAG_TOKEN &&\n                    (token.tagName === $.HTML || (token.tagName === $.BODY && this.openElements.hasInScope($.BODY)));\n\n                if (requireExplicitUpdate) {\n                    for (let i = this.openElements.stackTop; i >= 0; i--) {\n                        const element = this.openElements.items[i];\n\n                        if (this.treeAdapter.getTagName(element) === token.tagName) {\n                            mxn._setEndLocation(element, token);\n                            break;\n                        }\n                    }\n                }\n            },\n\n            //Doctype\n            _setDocumentType(token) {\n                orig._setDocumentType.call(this, token);\n\n                const documentChildren = this.treeAdapter.getChildNodes(this.document);\n                const cnLength = documentChildren.length;\n\n                for (let i = 0; i < cnLength; i++) {\n                    const node = documentChildren[i];\n\n                    if (this.treeAdapter.isDocumentTypeNode(node)) {\n                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n                        break;\n                    }\n                }\n            },\n\n            //Elements\n            _attachElementToTree(element) {\n                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n                //So we will use token location stored in this methods for the element.\n                mxn._setStartLocation(element);\n                mxn.lastStartTagToken = null;\n                orig._attachElementToTree.call(this, element);\n            },\n\n            _appendElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._appendElement.call(this, token, namespaceURI);\n            },\n\n            _insertElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._insertElement.call(this, token, namespaceURI);\n            },\n\n            _insertTemplate(token) {\n                mxn.lastStartTagToken = token;\n                orig._insertTemplate.call(this, token);\n\n                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n\n                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n            },\n\n            _insertFakeRootElement() {\n                orig._insertFakeRootElement.call(this);\n                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n            },\n\n            //Comments\n            _appendCommentNode(token, parent) {\n                orig._appendCommentNode.call(this, token, parent);\n\n                const children = this.treeAdapter.getChildNodes(parent);\n                const commentNode = children[children.length - 1];\n\n                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n            },\n\n            //Text\n            _findFosterParentingLocation() {\n                //NOTE: store last foster parenting location, so we will be able to find inserted text\n                //in case of foster parenting\n                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n\n                return mxn.lastFosterParentingLocation;\n            },\n\n            _insertCharacters(token) {\n                orig._insertCharacters.call(this, token);\n\n                const hasFosterParent = this._shouldFosterParentOnInsertion();\n\n                const parent =\n                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||\n                    this.openElements.currentTmplContent ||\n                    this.openElements.current;\n\n                const siblings = this.treeAdapter.getChildNodes(parent);\n\n                const textNodeIdx =\n                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement\n                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1\n                        : siblings.length - 1;\n\n                const textNode = siblings[textNodeIdx];\n\n                //NOTE: if we have location assigned by another token, then just update end position\n                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n                if (tnLoc) {\n                    const { endLine, endCol, endOffset } = token.location;\n                    this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });\n                } else {\n                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n                }\n            }\n        };\n    }\n}\n\nmodule.exports = LocationInfoParserMixin;\n"]},"metadata":{},"sourceType":"script"}
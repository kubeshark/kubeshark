{"ast":null,"code":"'use strict';\n\nmodule.exports = stan;\nstan.displayName = 'stan';\nstan.aliases = [];\n\nfunction stan(Prism) {\n  ;\n\n  (function (Prism) {\n    // https://mc-stan.org/docs/2_28/reference-manual/bnf-grammars.html\n    var higherOrderFunctions = /\\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\\b/;\n    Prism.languages.stan = {\n      comment: /\\/\\/.*|\\/\\*[\\s\\S]*?\\*\\/|#(?!include).*/,\n      string: {\n        // String literals can contain spaces and any printable ASCII characters except for \" and \\\n        // https://mc-stan.org/docs/2_24/reference-manual/print-statements-section.html#string-literals\n        pattern: /\"[\\x20\\x21\\x23-\\x5B\\x5D-\\x7E]*\"/,\n        greedy: true\n      },\n      directive: {\n        pattern: /^([ \\t]*)#include\\b.*/m,\n        lookbehind: true,\n        alias: 'property'\n      },\n      'function-arg': {\n        pattern: RegExp('(' + higherOrderFunctions.source + /\\s*\\(\\s*/.source + ')' + /[a-zA-Z]\\w*/.source),\n        lookbehind: true,\n        alias: 'function'\n      },\n      constraint: {\n        pattern: /(\\b(?:int|matrix|real|row_vector|vector)\\s*)<[^<>]*>/,\n        lookbehind: true,\n        inside: {\n          expression: {\n            pattern: /(=\\s*)\\S(?:\\S|\\s+(?!\\s))*?(?=\\s*(?:>$|,\\s*\\w+\\s*=))/,\n            lookbehind: true,\n            inside: null // see below\n\n          },\n          property: /\\b[a-z]\\w*(?=\\s*=)/i,\n          operator: /=/,\n          punctuation: /^<|>$|,/\n        }\n      },\n      keyword: [{\n        pattern: /\\bdata(?=\\s*\\{)|\\b(?:functions|generated|model|parameters|quantities|transformed)\\b/,\n        alias: 'program-block'\n      }, /\\b(?:array|break|cholesky_factor_corr|cholesky_factor_cov|complex|continue|corr_matrix|cov_matrix|data|else|for|if|in|increment_log_prob|int|matrix|ordered|positive_ordered|print|real|reject|return|row_vector|simplex|target|unit_vector|vector|void|while)\\b/, // these are functions that are known to take another function as their first argument.\n      higherOrderFunctions],\n      function: /\\b[a-z]\\w*(?=\\s*\\()/i,\n      number: /(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:E[+-]?\\d+(?:_\\d+)*)?i?(?!\\w)/i,\n      boolean: /\\b(?:false|true)\\b/,\n      operator: /<-|\\.[*/]=?|\\|\\|?|&&|[!=<>+\\-*/]=?|['^%~?:]/,\n      punctuation: /[()\\[\\]{},;]/\n    };\n    Prism.languages.stan.constraint.inside.expression.inside = Prism.languages.stan;\n  })(Prism);\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/refractor/lang/stan.js"],"names":["module","exports","stan","displayName","aliases","Prism","higherOrderFunctions","languages","comment","string","pattern","greedy","directive","lookbehind","alias","RegExp","source","constraint","inside","expression","property","operator","punctuation","keyword","function","number","boolean"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,IAAjB;AACAA,IAAI,CAACC,WAAL,GAAmB,MAAnB;AACAD,IAAI,CAACE,OAAL,GAAe,EAAf;;AACA,SAASF,IAAT,CAAcG,KAAd,EAAqB;AACnB;;AAAC,GAAC,UAAUA,KAAV,EAAiB;AACjB;AACA,QAAIC,oBAAoB,GACtB,6MADF;AAEAD,IAAAA,KAAK,CAACE,SAAN,CAAgBL,IAAhB,GAAuB;AACrBM,MAAAA,OAAO,EAAE,wCADY;AAErBC,MAAAA,MAAM,EAAE;AACN;AACA;AACAC,QAAAA,OAAO,EAAE,iCAHH;AAINC,QAAAA,MAAM,EAAE;AAJF,OAFa;AAQrBC,MAAAA,SAAS,EAAE;AACTF,QAAAA,OAAO,EAAE,wBADA;AAETG,QAAAA,UAAU,EAAE,IAFH;AAGTC,QAAAA,KAAK,EAAE;AAHE,OARU;AAarB,sBAAgB;AACdJ,QAAAA,OAAO,EAAEK,MAAM,CACb,MACET,oBAAoB,CAACU,MADvB,GAEE,WAAWA,MAFb,GAGE,GAHF,GAIE,cAAcA,MALH,CADD;AAQdH,QAAAA,UAAU,EAAE,IARE;AASdC,QAAAA,KAAK,EAAE;AATO,OAbK;AAwBrBG,MAAAA,UAAU,EAAE;AACVP,QAAAA,OAAO,EAAE,sDADC;AAEVG,QAAAA,UAAU,EAAE,IAFF;AAGVK,QAAAA,MAAM,EAAE;AACNC,UAAAA,UAAU,EAAE;AACVT,YAAAA,OAAO,EAAE,qDADC;AAEVG,YAAAA,UAAU,EAAE,IAFF;AAGVK,YAAAA,MAAM,EAAE,IAHE,CAGG;;AAHH,WADN;AAMNE,UAAAA,QAAQ,EAAE,qBANJ;AAONC,UAAAA,QAAQ,EAAE,GAPJ;AAQNC,UAAAA,WAAW,EAAE;AARP;AAHE,OAxBS;AAsCrBC,MAAAA,OAAO,EAAE,CACP;AACEb,QAAAA,OAAO,EACL,qFAFJ;AAGEI,QAAAA,KAAK,EAAE;AAHT,OADO,EAMP,kQANO,EAM6P;AACpQR,MAAAA,oBAPO,CAtCY;AA+CrBkB,MAAAA,QAAQ,EAAE,sBA/CW;AAgDrBC,MAAAA,MAAM,EACJ,6FAjDmB;AAkDrBC,MAAAA,OAAO,EAAE,oBAlDY;AAmDrBL,MAAAA,QAAQ,EAAE,6CAnDW;AAoDrBC,MAAAA,WAAW,EAAE;AApDQ,KAAvB;AAsDAjB,IAAAA,KAAK,CAACE,SAAN,CAAgBL,IAAhB,CAAqBe,UAArB,CAAgCC,MAAhC,CAAuCC,UAAvC,CAAkDD,MAAlD,GACEb,KAAK,CAACE,SAAN,CAAgBL,IADlB;AAED,GA5DA,EA4DEG,KA5DF;AA6DF","sourcesContent":["'use strict'\n\nmodule.exports = stan\nstan.displayName = 'stan'\nstan.aliases = []\nfunction stan(Prism) {\n  ;(function (Prism) {\n    // https://mc-stan.org/docs/2_28/reference-manual/bnf-grammars.html\n    var higherOrderFunctions =\n      /\\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\\b/\n    Prism.languages.stan = {\n      comment: /\\/\\/.*|\\/\\*[\\s\\S]*?\\*\\/|#(?!include).*/,\n      string: {\n        // String literals can contain spaces and any printable ASCII characters except for \" and \\\n        // https://mc-stan.org/docs/2_24/reference-manual/print-statements-section.html#string-literals\n        pattern: /\"[\\x20\\x21\\x23-\\x5B\\x5D-\\x7E]*\"/,\n        greedy: true\n      },\n      directive: {\n        pattern: /^([ \\t]*)#include\\b.*/m,\n        lookbehind: true,\n        alias: 'property'\n      },\n      'function-arg': {\n        pattern: RegExp(\n          '(' +\n            higherOrderFunctions.source +\n            /\\s*\\(\\s*/.source +\n            ')' +\n            /[a-zA-Z]\\w*/.source\n        ),\n        lookbehind: true,\n        alias: 'function'\n      },\n      constraint: {\n        pattern: /(\\b(?:int|matrix|real|row_vector|vector)\\s*)<[^<>]*>/,\n        lookbehind: true,\n        inside: {\n          expression: {\n            pattern: /(=\\s*)\\S(?:\\S|\\s+(?!\\s))*?(?=\\s*(?:>$|,\\s*\\w+\\s*=))/,\n            lookbehind: true,\n            inside: null // see below\n          },\n          property: /\\b[a-z]\\w*(?=\\s*=)/i,\n          operator: /=/,\n          punctuation: /^<|>$|,/\n        }\n      },\n      keyword: [\n        {\n          pattern:\n            /\\bdata(?=\\s*\\{)|\\b(?:functions|generated|model|parameters|quantities|transformed)\\b/,\n          alias: 'program-block'\n        },\n        /\\b(?:array|break|cholesky_factor_corr|cholesky_factor_cov|complex|continue|corr_matrix|cov_matrix|data|else|for|if|in|increment_log_prob|int|matrix|ordered|positive_ordered|print|real|reject|return|row_vector|simplex|target|unit_vector|vector|void|while)\\b/, // these are functions that are known to take another function as their first argument.\n        higherOrderFunctions\n      ],\n      function: /\\b[a-z]\\w*(?=\\s*\\()/i,\n      number:\n        /(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:E[+-]?\\d+(?:_\\d+)*)?i?(?!\\w)/i,\n      boolean: /\\b(?:false|true)\\b/,\n      operator: /<-|\\.[*/]=?|\\|\\|?|&&|[!=<>+\\-*/]=?|['^%~?:]/,\n      punctuation: /[()\\[\\]{},;]/\n    }\n    Prism.languages.stan.constraint.inside.expression.inside =\n      Prism.languages.stan\n  })(Prism)\n}\n"]},"metadata":{},"sourceType":"script"}
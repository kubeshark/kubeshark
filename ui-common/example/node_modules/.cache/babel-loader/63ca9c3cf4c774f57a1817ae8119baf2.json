{"ast":null,"code":"/**\n * @typedef {import('hast').Root} Root\n * @typedef {Pick<import('hast-util-from-parse5').Options, 'space' | 'verbose'>} FromParse5Options\n *\n * @typedef {keyof errors} ErrorCode\n * @typedef {0|1|2|boolean|null|undefined} ErrorSeverity\n * @typedef {Partial<Record<ErrorCode, ErrorSeverity>>} ErrorFields\n *\n * @typedef ParseFields\n * @property {boolean|undefined} [fragment=false]\n *   Specify whether to parse a fragment, instead of a complete document.\n *   In document mode, unopened `html`, `head`, and `body` elements are opened\n *   in just the right places.\n * @property {boolean|undefined} [emitParseErrors=false]\n *   > ⚠️ Parse errors are currently being added to HTML.\n *   > Not all errors emitted by parse5 (or rehype-parse) are specced yet.\n *   > Some documentation may still be missing.\n *\n *   Emit parse errors while parsing on the vfile.\n *   Setting this to `true` starts emitting HTML parse errors.\n *\n *   Specific rules can be turned off by setting them to `false` (or `0`).\n *   The default, when `emitParseErrors: true`, is `true` (or `1`), and means\n *   that rules emit as warnings.\n *   Rules can also be configured with `2`, to turn them into fatal errors.\n *\n * @typedef {FromParse5Options & ParseFields & ErrorFields} Options\n */\n// @ts-expect-error: remove when typed\nimport Parser5 from 'parse5/lib/parser/index.js';\nimport { fromParse5 } from 'hast-util-from-parse5';\nimport { errors } from './errors.js';\nconst base = 'https://html.spec.whatwg.org/multipage/parsing.html#parse-error-';\nconst fatalities = {\n  2: true,\n  1: false,\n  0: null\n};\n/** @type {import('unified').Plugin<[Options?] | Array<void>, string, Root>} */\n\nexport default function rehypeParse(options) {\n  const processorSettings =\n  /** @type {Options} */\n  this.data('settings');\n  const settings = Object.assign({}, processorSettings, options);\n  Object.assign(this, {\n    Parser: parser\n  });\n  /** @type {import('unified').ParserFunction<Root>} */\n\n  function parser(doc, file) {\n    const fn = settings.fragment ? 'parseFragment' : 'parse';\n    const onParseError = settings.emitParseErrors ? onerror : null;\n    const parse5 = new Parser5({\n      sourceCodeLocationInfo: true,\n      onParseError,\n      scriptingEnabled: false\n    }); // @ts-expect-error: `parse5` returns document or fragment, which are always\n    // mapped to roots.\n\n    return fromParse5(parse5[fn](doc), {\n      space: settings.space,\n      file,\n      verbose: settings.verbose\n    });\n    /**\n     * @param {{code: string, startLine: number, startCol: number, startOffset: number, endLine: number, endCol: number, endOffset: number}} error\n     */\n\n    function onerror(error) {\n      const code = error.code;\n      const name = camelcase(code);\n      const setting = settings[name];\n      const config = setting === undefined || setting === null ? true : setting;\n      const level = typeof config === 'number' ? config : config ? 1 : 0;\n      const start = {\n        line: error.startLine,\n        column: error.startCol,\n        offset: error.startOffset\n      };\n      const end = {\n        line: error.endLine,\n        column: error.endCol,\n        offset: error.endOffset\n      };\n\n      if (level) {\n        /* c8 ignore next */\n        const info = errors[name] || {\n          reason: '',\n          description: '',\n          url: ''\n        };\n        const message = file.message(format(info.reason), {\n          start,\n          end\n        });\n        message.source = 'parse-error';\n        message.ruleId = code;\n        message.fatal = fatalities[level];\n        message.note = format(info.description);\n        message.url = 'url' in info && info.url === false ? null : base + code;\n      }\n      /**\n       * @param {string} value\n       * @returns {string}\n       */\n\n\n      function format(value) {\n        return value.replace(/%c(?:-(\\d+))?/g, (_,\n        /** @type {string} */\n        $1) => {\n          const offset = $1 ? -Number.parseInt($1, 10) : 0;\n          const char = doc.charAt(error.startOffset + offset);\n          return char === '`' ? '` ` `' : char;\n        }).replace(/%x/g, () => '0x' + doc.charCodeAt(error.startOffset).toString(16).toUpperCase());\n      }\n    }\n  }\n}\n/**\n * @param {string} value\n * @returns {ErrorCode}\n */\n\nfunction camelcase(value) {\n  // @ts-expect-error: this returns a valid error code.\n  return value.replace(/-[a-z]/g, $0 => $0.charAt(1).toUpperCase());\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/rehype-parse/lib/index.js"],"names":["Parser5","fromParse5","errors","base","fatalities","rehypeParse","options","processorSettings","data","settings","Object","assign","Parser","parser","doc","file","fn","fragment","onParseError","emitParseErrors","onerror","parse5","sourceCodeLocationInfo","scriptingEnabled","space","verbose","error","code","name","camelcase","setting","config","undefined","level","start","line","startLine","column","startCol","offset","startOffset","end","endLine","endCol","endOffset","info","reason","description","url","message","format","source","ruleId","fatal","note","value","replace","_","$1","Number","parseInt","char","charAt","charCodeAt","toString","toUpperCase","$0"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('hast').Root} Root\n * @typedef {Pick<import('hast-util-from-parse5').Options, 'space' | 'verbose'>} FromParse5Options\n *\n * @typedef {keyof errors} ErrorCode\n * @typedef {0|1|2|boolean|null|undefined} ErrorSeverity\n * @typedef {Partial<Record<ErrorCode, ErrorSeverity>>} ErrorFields\n *\n * @typedef ParseFields\n * @property {boolean|undefined} [fragment=false]\n *   Specify whether to parse a fragment, instead of a complete document.\n *   In document mode, unopened `html`, `head`, and `body` elements are opened\n *   in just the right places.\n * @property {boolean|undefined} [emitParseErrors=false]\n *   > ⚠️ Parse errors are currently being added to HTML.\n *   > Not all errors emitted by parse5 (or rehype-parse) are specced yet.\n *   > Some documentation may still be missing.\n *\n *   Emit parse errors while parsing on the vfile.\n *   Setting this to `true` starts emitting HTML parse errors.\n *\n *   Specific rules can be turned off by setting them to `false` (or `0`).\n *   The default, when `emitParseErrors: true`, is `true` (or `1`), and means\n *   that rules emit as warnings.\n *   Rules can also be configured with `2`, to turn them into fatal errors.\n *\n * @typedef {FromParse5Options & ParseFields & ErrorFields} Options\n */\n\n// @ts-expect-error: remove when typed\nimport Parser5 from 'parse5/lib/parser/index.js'\nimport {fromParse5} from 'hast-util-from-parse5'\nimport {errors} from './errors.js'\n\nconst base = 'https://html.spec.whatwg.org/multipage/parsing.html#parse-error-'\n\nconst fatalities = {2: true, 1: false, 0: null}\n\n/** @type {import('unified').Plugin<[Options?] | Array<void>, string, Root>} */\nexport default function rehypeParse(options) {\n  const processorSettings = /** @type {Options} */ (this.data('settings'))\n  const settings = Object.assign({}, processorSettings, options)\n\n  Object.assign(this, {Parser: parser})\n\n  /** @type {import('unified').ParserFunction<Root>} */\n  function parser(doc, file) {\n    const fn = settings.fragment ? 'parseFragment' : 'parse'\n    const onParseError = settings.emitParseErrors ? onerror : null\n    const parse5 = new Parser5({\n      sourceCodeLocationInfo: true,\n      onParseError,\n      scriptingEnabled: false\n    })\n\n    // @ts-expect-error: `parse5` returns document or fragment, which are always\n    // mapped to roots.\n    return fromParse5(parse5[fn](doc), {\n      space: settings.space,\n      file,\n      verbose: settings.verbose\n    })\n\n    /**\n     * @param {{code: string, startLine: number, startCol: number, startOffset: number, endLine: number, endCol: number, endOffset: number}} error\n     */\n    function onerror(error) {\n      const code = error.code\n      const name = camelcase(code)\n      const setting = settings[name]\n      const config = setting === undefined || setting === null ? true : setting\n      const level = typeof config === 'number' ? config : config ? 1 : 0\n      const start = {\n        line: error.startLine,\n        column: error.startCol,\n        offset: error.startOffset\n      }\n      const end = {\n        line: error.endLine,\n        column: error.endCol,\n        offset: error.endOffset\n      }\n      if (level) {\n        /* c8 ignore next */\n        const info = errors[name] || {reason: '', description: '', url: ''}\n        const message = file.message(format(info.reason), {start, end})\n        message.source = 'parse-error'\n        message.ruleId = code\n        message.fatal = fatalities[level]\n        message.note = format(info.description)\n        message.url = 'url' in info && info.url === false ? null : base + code\n      }\n\n      /**\n       * @param {string} value\n       * @returns {string}\n       */\n      function format(value) {\n        return value\n          .replace(/%c(?:-(\\d+))?/g, (_, /** @type {string} */ $1) => {\n            const offset = $1 ? -Number.parseInt($1, 10) : 0\n            const char = doc.charAt(error.startOffset + offset)\n            return char === '`' ? '` ` `' : char\n          })\n          .replace(\n            /%x/g,\n            () =>\n              '0x' +\n              doc.charCodeAt(error.startOffset).toString(16).toUpperCase()\n          )\n      }\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @returns {ErrorCode}\n */\nfunction camelcase(value) {\n  // @ts-expect-error: this returns a valid error code.\n  return value.replace(/-[a-z]/g, ($0) => $0.charAt(1).toUpperCase())\n}\n"]},"metadata":{},"sourceType":"module"}
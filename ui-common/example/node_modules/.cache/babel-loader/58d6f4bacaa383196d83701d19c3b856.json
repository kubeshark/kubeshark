{"ast":null,"code":"'use strict';\n\nmodule.exports = zig;\nzig.displayName = 'zig';\nzig.aliases = [];\n\nfunction zig(Prism) {\n  ;\n\n  (function (Prism) {\n    function literal(str) {\n      return function () {\n        return str;\n      };\n    }\n\n    var keyword = /\\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/;\n    var IDENTIFIER = '\\\\b(?!' + keyword.source + ')(?!\\\\d)\\\\w+\\\\b';\n    var ALIGN = /align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source;\n    var PREFIX_TYPE_OP = /(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(/<ALIGN>/g, literal(ALIGN));\n    var SUFFIX_EXPR = /(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(/<ID>/g, literal(IDENTIFIER));\n    var TYPE = '(?!\\\\s)(?:!?\\\\s*(?:' + PREFIX_TYPE_OP + '\\\\s*)*' + SUFFIX_EXPR + ')+';\n    /*\n     * A simplified grammar for Zig compile time type literals:\n     *\n     * TypeExpr = ( \"!\"? PREFIX_TYPE_OP* SUFFIX_EXPR )+\n     *\n     * SUFFIX_EXPR = ( \\b \"promise\" \\b | ( \\b \"error\" \".\" )? IDENTIFIER ( \".\" IDENTIFIER )* (?! \\s+ IDENTIFIER ) )\n     *\n     * PREFIX_TYPE_OP = \"?\"\n     *                | \\b \"promise\" \"->\"\n     *                | ( \"[\" [^\\[\\]]* \"]\" | \"*\" | \"**\" ) ( ALIGN | \"const\" \\b | \"volatile\" \\b | \"allowzero\" \\b )*\n     *\n     * ALIGN = \"align\" \"(\" ( [^()] | \"(\" [^()]* \")\" )* \")\"\n     *\n     * IDENTIFIER = \\b (?! KEYWORD ) [a-zA-Z_] \\w* \\b\n     *\n     */\n\n    Prism.languages.zig = {\n      comment: [{\n        pattern: /\\/\\/[/!].*/,\n        alias: 'doc-comment'\n      }, /\\/{2}.*/],\n      string: [{\n        // \"string\" and c\"string\"\n        pattern: /(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n        lookbehind: true,\n        greedy: true\n      }, {\n        // multiline strings and c-strings\n        pattern: /([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,\n        lookbehind: true,\n        greedy: true\n      }],\n      char: {\n        // characters 'a', '\\n', '\\xFF', '\\u{10FFFF}'\n        pattern: /(^|[^\\\\])'(?:[^'\\\\\\r\\n]|[\\uD800-\\uDFFF]{2}|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,\n        lookbehind: true,\n        greedy: true\n      },\n      builtin: /\\B@(?!\\d)\\w+(?=\\s*\\()/,\n      label: {\n        pattern: /(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,\n        lookbehind: true\n      },\n      'class-name': [// const Foo = struct {};\n      /\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/, {\n        // const x: i32 = 9;\n        // var x: Bar;\n        // fn foo(x: bool, y: f32) void {}\n        pattern: RegExp(/(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n        lookbehind: true,\n        inside: null // see below\n\n      }, {\n        // extern fn foo(x: f64) f64; (optional alignment)\n        pattern: RegExp(/(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n        lookbehind: true,\n        inside: null // see below\n\n      }],\n      'builtin-type': {\n        pattern: /\\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\\b/,\n        alias: 'keyword'\n      },\n      keyword: keyword,\n      function: /\\b(?!\\d)\\w+(?=\\s*\\()/,\n      number: /\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+(?:\\.[a-fA-F\\d]*)?(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\b/,\n      boolean: /\\b(?:false|true)\\b/,\n      operator: /\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,\n      punctuation: /[.:,;(){}[\\]]/\n    };\n    Prism.languages.zig['class-name'].forEach(function (obj) {\n      if (obj.inside === null) {\n        obj.inside = Prism.languages.zig;\n      }\n    });\n  })(Prism);\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/refractor/lang/zig.js"],"names":["module","exports","zig","displayName","aliases","Prism","literal","str","keyword","IDENTIFIER","source","ALIGN","PREFIX_TYPE_OP","replace","SUFFIX_EXPR","TYPE","languages","comment","pattern","alias","string","lookbehind","greedy","char","builtin","label","RegExp","inside","function","number","boolean","operator","punctuation","forEach","obj"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = zig\nzig.displayName = 'zig'\nzig.aliases = []\nfunction zig(Prism) {\n  ;(function (Prism) {\n    function literal(str) {\n      return function () {\n        return str\n      }\n    }\n    var keyword =\n      /\\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/\n    var IDENTIFIER = '\\\\b(?!' + keyword.source + ')(?!\\\\d)\\\\w+\\\\b'\n    var ALIGN = /align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source\n    var PREFIX_TYPE_OP =\n      /(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(\n        /<ALIGN>/g,\n        literal(ALIGN)\n      )\n    var SUFFIX_EXPR =\n      /(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(\n        /<ID>/g,\n        literal(IDENTIFIER)\n      )\n    var TYPE =\n      '(?!\\\\s)(?:!?\\\\s*(?:' + PREFIX_TYPE_OP + '\\\\s*)*' + SUFFIX_EXPR + ')+'\n    /*\n     * A simplified grammar for Zig compile time type literals:\n     *\n     * TypeExpr = ( \"!\"? PREFIX_TYPE_OP* SUFFIX_EXPR )+\n     *\n     * SUFFIX_EXPR = ( \\b \"promise\" \\b | ( \\b \"error\" \".\" )? IDENTIFIER ( \".\" IDENTIFIER )* (?! \\s+ IDENTIFIER ) )\n     *\n     * PREFIX_TYPE_OP = \"?\"\n     *                | \\b \"promise\" \"->\"\n     *                | ( \"[\" [^\\[\\]]* \"]\" | \"*\" | \"**\" ) ( ALIGN | \"const\" \\b | \"volatile\" \\b | \"allowzero\" \\b )*\n     *\n     * ALIGN = \"align\" \"(\" ( [^()] | \"(\" [^()]* \")\" )* \")\"\n     *\n     * IDENTIFIER = \\b (?! KEYWORD ) [a-zA-Z_] \\w* \\b\n     *\n     */\n    Prism.languages.zig = {\n      comment: [\n        {\n          pattern: /\\/\\/[/!].*/,\n          alias: 'doc-comment'\n        },\n        /\\/{2}.*/\n      ],\n      string: [\n        {\n          // \"string\" and c\"string\"\n          pattern: /(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n          lookbehind: true,\n          greedy: true\n        },\n        {\n          // multiline strings and c-strings\n          pattern: /([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,\n          lookbehind: true,\n          greedy: true\n        }\n      ],\n      char: {\n        // characters 'a', '\\n', '\\xFF', '\\u{10FFFF}'\n        pattern:\n          /(^|[^\\\\])'(?:[^'\\\\\\r\\n]|[\\uD800-\\uDFFF]{2}|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,\n        lookbehind: true,\n        greedy: true\n      },\n      builtin: /\\B@(?!\\d)\\w+(?=\\s*\\()/,\n      label: {\n        pattern:\n          /(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,\n        lookbehind: true\n      },\n      'class-name': [\n        // const Foo = struct {};\n        /\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/,\n        {\n          // const x: i32 = 9;\n          // var x: Bar;\n          // fn foo(x: bool, y: f32) void {}\n          pattern: RegExp(\n            /(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source\n              .replace(/<TYPE>/g, literal(TYPE))\n              .replace(/<ALIGN>/g, literal(ALIGN))\n          ),\n          lookbehind: true,\n          inside: null // see below\n        },\n        {\n          // extern fn foo(x: f64) f64; (optional alignment)\n          pattern: RegExp(\n            /(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source\n              .replace(/<TYPE>/g, literal(TYPE))\n              .replace(/<ALIGN>/g, literal(ALIGN))\n          ),\n          lookbehind: true,\n          inside: null // see below\n        }\n      ],\n      'builtin-type': {\n        pattern:\n          /\\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\\b/,\n        alias: 'keyword'\n      },\n      keyword: keyword,\n      function: /\\b(?!\\d)\\w+(?=\\s*\\()/,\n      number:\n        /\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+(?:\\.[a-fA-F\\d]*)?(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\b/,\n      boolean: /\\b(?:false|true)\\b/,\n      operator:\n        /\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,\n      punctuation: /[.:,;(){}[\\]]/\n    }\n    Prism.languages.zig['class-name'].forEach(function (obj) {\n      if (obj.inside === null) {\n        obj.inside = Prism.languages.zig\n      }\n    })\n  })(Prism)\n}\n"]},"metadata":{},"sourceType":"script"}
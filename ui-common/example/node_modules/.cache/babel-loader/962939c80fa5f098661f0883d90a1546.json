{"ast":null,"code":"/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {Root['children'][number]} Child\n * @typedef {Child|Root} Node\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {Root|Element} HResult\n * @typedef {string|number} HStyleValue\n * @typedef {Object.<string, HStyleValue>} HStyle\n * @typedef {string|number|boolean|null|undefined} HPrimitiveValue\n * @typedef {Array.<string|number>} HArrayValue\n * @typedef {HPrimitiveValue|HArrayValue} HPropertyValue\n * @typedef {{[property: string]: HPropertyValue|HStyle}} HProperties\n *\n * @typedef {string|number|null|undefined} HPrimitiveChild\n * @typedef {Array.<Node|HPrimitiveChild>} HArrayChild\n * @typedef {Node|HPrimitiveChild|HArrayChild} HChild\n */\nimport { find, normalize } from 'property-information';\nimport { parseSelector } from 'hast-util-parse-selector';\nimport { parse as spaces } from 'space-separated-tokens';\nimport { parse as commas } from 'comma-separated-tokens';\nconst buttonTypes = new Set(['menu', 'submit', 'reset', 'button']);\nconst own = {}.hasOwnProperty;\n/**\n * @param {Schema} schema\n * @param {string} defaultTagName\n * @param {Array.<string>} [caseSensitive]\n */\n\nexport function core(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive);\n\n  const h =\n  /**\n   * @type {{\n   *   (): Root\n   *   (selector: null|undefined, ...children: HChild[]): Root\n   *   (selector: string, properties?: HProperties, ...children: HChild[]): Element\n   *   (selector: string, ...children: HChild[]): Element\n   * }}\n   */\n\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @param {string|null} [selector]\n   * @param {HProperties|HChild} [properties]\n   * @param {HChild[]} children\n   * @returns {HResult}\n   */\n  function (selector, properties) {\n    let index = -1;\n    /** @type {HResult} */\n\n    let node;\n\n    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      children[_key - 2] = arguments[_key];\n    }\n\n    if (selector === undefined || selector === null) {\n      node = {\n        type: 'root',\n        children: []\n      }; // @ts-expect-error Properties are not supported for roots.\n\n      children.unshift(properties);\n    } else {\n      node = parseSelector(selector, defaultTagName); // Normalize the name.\n\n      node.tagName = node.tagName.toLowerCase();\n\n      if (adjust && own.call(adjust, node.tagName)) {\n        node.tagName = adjust[node.tagName];\n      } // Handle props.\n\n\n      if (isProperties(properties, node.tagName)) {\n        /** @type {string} */\n        let key;\n\n        for (key in properties) {\n          if (own.call(properties, key)) {\n            // @ts-expect-error `node.properties` is set.\n            addProperty(schema, node.properties, key, properties[key]);\n          }\n        }\n      } else {\n        children.unshift(properties);\n      }\n    } // Handle children.\n\n\n    while (++index < children.length) {\n      addChild(node.children, children[index]);\n    }\n\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {\n        type: 'root',\n        children: node.children\n      };\n      node.children = [];\n    }\n\n    return node;\n  };\n\n  return h;\n}\n/**\n * @param {HProperties|HChild} value\n * @param {string} name\n * @returns {value is HProperties}\n */\n\nfunction isProperties(value, name) {\n  if (value === null || value === undefined || typeof value !== 'object' || Array.isArray(value)) {\n    return false;\n  }\n\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\n    return true;\n  }\n\n  if ('children' in value && Array.isArray(value.children)) {\n    return false;\n  }\n\n  if (name === 'button') {\n    return buttonTypes.has(value.type.toLowerCase());\n  }\n\n  return !('value' in value);\n}\n/**\n * @param {Schema} schema\n * @param {Properties} properties\n * @param {string} key\n * @param {HStyle|HPropertyValue} value\n * @returns {void}\n */\n\n\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key);\n  let index = -1;\n  /** @type {HPropertyValue} */\n\n  let result; // Ignore nullish and NaN values.\n\n  if (value === undefined || value === null) return;\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return;\n    result = value;\n  } // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value;\n  } // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value);\n    } else if (info.commaSeparated) {\n      result = commas(value);\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '));\n    } else {\n      result = parsePrimitive(info, info.property, value);\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat();\n  } else {\n    result = info.property === 'style' ? style(value) : String(value);\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array.<string|number>} */\n    const finalResult = [];\n\n    while (++index < result.length) {\n      // @ts-expect-error Assume no booleans in array.\n      finalResult[index] = parsePrimitive(info, info.property, result[index]);\n    }\n\n    result = finalResult;\n  } // Class names (which can be added both on the `selector` and here).\n\n\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // @ts-expect-error Assume no booleans in `className`.\n    result = properties.className.concat(result);\n  }\n\n  properties[info.property] = result;\n}\n/**\n * @param {Array.<Child>} nodes\n * @param {HChild} value\n * @returns {void}\n */\n\n\nfunction addChild(nodes, value) {\n  let index = -1;\n\n  if (value === undefined || value === null) {// Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({\n      type: 'text',\n      value: String(value)\n    });\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index]);\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children);\n    } else {\n      nodes.push(value);\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`');\n  }\n}\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n * @param {string} name\n * @param {HPrimitiveValue} value\n * @returns {HPrimitiveValue}\n */\n\n\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value);\n    }\n\n    if ((info.boolean || info.overloadedBoolean) && (value === '' || normalize(value) === normalize(name))) {\n      return true;\n    }\n  }\n\n  return value;\n}\n/**\n * @param {HStyle} value\n * @returns {string}\n */\n\n\nfunction style(value) {\n  /** @type {Array.<string>} */\n  const result = [];\n  /** @type {string} */\n\n  let key;\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '));\n    }\n  }\n\n  return result.join('; ');\n}\n/**\n * @param {Array.<string>} values\n * @returns {Object.<string, string>}\n */\n\n\nfunction createAdjustMap(values) {\n  /** @type {Object.<string, string>} */\n  const result = {};\n  let index = -1;\n\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index];\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/hast-util-from-parse5/node_modules/hastscript/lib/core.js"],"names":["find","normalize","parseSelector","parse","spaces","commas","buttonTypes","Set","own","hasOwnProperty","core","schema","defaultTagName","caseSensitive","adjust","createAdjustMap","h","selector","properties","index","node","children","undefined","type","unshift","tagName","toLowerCase","call","isProperties","key","addProperty","length","addChild","content","value","name","Array","isArray","has","info","result","Number","isNaN","spaceSeparated","commaSeparated","commaOrSpaceSeparated","join","parsePrimitive","property","concat","style","String","finalResult","className","nodes","push","Error","number","boolean","overloadedBoolean","values"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {Root['children'][number]} Child\n * @typedef {Child|Root} Node\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {Root|Element} HResult\n * @typedef {string|number} HStyleValue\n * @typedef {Object.<string, HStyleValue>} HStyle\n * @typedef {string|number|boolean|null|undefined} HPrimitiveValue\n * @typedef {Array.<string|number>} HArrayValue\n * @typedef {HPrimitiveValue|HArrayValue} HPropertyValue\n * @typedef {{[property: string]: HPropertyValue|HStyle}} HProperties\n *\n * @typedef {string|number|null|undefined} HPrimitiveChild\n * @typedef {Array.<Node|HPrimitiveChild>} HArrayChild\n * @typedef {Node|HPrimitiveChild|HArrayChild} HChild\n */\n\nimport {find, normalize} from 'property-information'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {parse as spaces} from 'space-separated-tokens'\nimport {parse as commas} from 'comma-separated-tokens'\n\nconst buttonTypes = new Set(['menu', 'submit', 'reset', 'button'])\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Schema} schema\n * @param {string} defaultTagName\n * @param {Array.<string>} [caseSensitive]\n */\nexport function core(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive)\n\n  const h =\n    /**\n     * @type {{\n     *   (): Root\n     *   (selector: null|undefined, ...children: HChild[]): Root\n     *   (selector: string, properties?: HProperties, ...children: HChild[]): Element\n     *   (selector: string, ...children: HChild[]): Element\n     * }}\n     */\n    (\n      /**\n       * Hyperscript compatible DSL for creating virtual hast trees.\n       *\n       * @param {string|null} [selector]\n       * @param {HProperties|HChild} [properties]\n       * @param {HChild[]} children\n       * @returns {HResult}\n       */\n      function (selector, properties, ...children) {\n        let index = -1\n        /** @type {HResult} */\n        let node\n\n        if (selector === undefined || selector === null) {\n          node = {type: 'root', children: []}\n          // @ts-expect-error Properties are not supported for roots.\n          children.unshift(properties)\n        } else {\n          node = parseSelector(selector, defaultTagName)\n          // Normalize the name.\n          node.tagName = node.tagName.toLowerCase()\n          if (adjust && own.call(adjust, node.tagName)) {\n            node.tagName = adjust[node.tagName]\n          }\n\n          // Handle props.\n          if (isProperties(properties, node.tagName)) {\n            /** @type {string} */\n            let key\n\n            for (key in properties) {\n              if (own.call(properties, key)) {\n                // @ts-expect-error `node.properties` is set.\n                addProperty(schema, node.properties, key, properties[key])\n              }\n            }\n          } else {\n            children.unshift(properties)\n          }\n        }\n\n        // Handle children.\n        while (++index < children.length) {\n          addChild(node.children, children[index])\n        }\n\n        if (node.type === 'element' && node.tagName === 'template') {\n          node.content = {type: 'root', children: node.children}\n          node.children = []\n        }\n\n        return node\n      }\n    )\n\n  return h\n}\n\n/**\n * @param {HProperties|HChild} value\n * @param {string} name\n * @returns {value is HProperties}\n */\nfunction isProperties(value, name) {\n  if (\n    value === null ||\n    value === undefined ||\n    typeof value !== 'object' ||\n    Array.isArray(value)\n  ) {\n    return false\n  }\n\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\n    return true\n  }\n\n  if ('children' in value && Array.isArray(value.children)) {\n    return false\n  }\n\n  if (name === 'button') {\n    return buttonTypes.has(value.type.toLowerCase())\n  }\n\n  return !('value' in value)\n}\n\n/**\n * @param {Schema} schema\n * @param {Properties} properties\n * @param {string} key\n * @param {HStyle|HPropertyValue} value\n * @returns {void}\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  let index = -1\n  /** @type {HPropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === undefined || value === null) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value)\n    } else if (info.commaSeparated) {\n      result = commas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat()\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array.<string|number>} */\n    const finalResult = []\n\n    while (++index < result.length) {\n      // @ts-expect-error Assume no booleans in array.\n      finalResult[index] = parsePrimitive(info, info.property, result[index])\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // @ts-expect-error Assume no booleans in `className`.\n    result = properties.className.concat(result)\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array.<Child>} nodes\n * @param {HChild} value\n * @returns {void}\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n * @param {string} name\n * @param {HPrimitiveValue} value\n * @returns {HPrimitiveValue}\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * @param {HStyle} value\n * @returns {string}\n */\nfunction style(value) {\n  /** @type {Array.<string>} */\n  const result = []\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '))\n    }\n  }\n\n  return result.join('; ')\n}\n\n/**\n * @param {Array.<string>} values\n * @returns {Object.<string, string>}\n */\nfunction createAdjustMap(values) {\n  /** @type {Object.<string, string>} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index]\n  }\n\n  return result\n}\n"]},"metadata":{},"sourceType":"module"}
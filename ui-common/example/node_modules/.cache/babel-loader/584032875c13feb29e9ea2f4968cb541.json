{"ast":null,"code":"/**\n * @typedef {Object} XMLFormatterOptions\n *  @property {String} [indentation='    '] The value used for indentation\n *  @property {function(node): boolean} [filter] Return false to exclude the node.\n *  @property {Boolean} [collapseContent=false] True to keep content in the same line as the element. Only works if element contains at least one text node\n *  @property {String} [lineSeparator='\\r\\n'] The line separator to use\n *  @property {String} [whiteSpaceAtEndOfSelfclosingTag=false] to either end ad self closing tag with `<tag/>` or `<tag />`\n */\n\n/**\n * @typedef {Object} XMLFormatterState\n * @param {String} content\n * @param {Number} level\n * @param {XMLFormatterOptions} options\n */\n\n/**\n * @param {XMLFormatterState} state\n * @return {void}\n */\nfunction newLine(state) {\n  if (!state.options.indentation && !state.options.lineSeparator) return;\n  state.content += state.options.lineSeparator;\n  let i;\n\n  for (i = 0; i < state.level; i++) {\n    state.content += state.options.indentation;\n  }\n}\n/**\n * @param {XMLFormatterState} state\n * @param {String} content\n * @return {void}\n */\n\n\nfunction appendContent(state, content) {\n  state.content += content;\n}\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @param {Boolean} preserveSpace\n * @return {void}\n */\n\n\nfunction processNode(node, state, preserveSpace) {\n  if (typeof node.content === 'string') {\n    processContentNode(node, state, preserveSpace);\n  } else if (node.type === 'Element') {\n    processElementNode(node, state, preserveSpace);\n  } else if (node.type === 'ProcessingInstruction') {\n    processProcessingIntruction(node, state, preserveSpace);\n  } else {\n    throw new Error('Unknown node type: ' + node.type);\n  }\n}\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @param {Boolean} preserveSpace\n * @return {void}\n */\n\n\nfunction processContentNode(node, state, preserveSpace) {\n  if (!preserveSpace) {\n    node.content = node.content.trim();\n  }\n\n  if (node.content.length > 0) {\n    if (!preserveSpace && state.content.length > 0) {\n      newLine(state);\n    }\n\n    appendContent(state, node.content);\n  }\n}\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @param {Boolean} preserveSpace\n * @return {void}\n */\n\n\nfunction processElementNode(node, state, preserveSpace) {\n  if (!preserveSpace && state.content.length > 0) {\n    newLine(state);\n  }\n\n  appendContent(state, '<' + node.name);\n  processAttributes(state, node.attributes);\n\n  if (node.children === null) {\n    const selfClosingNodeClosingTag = state.options.whiteSpaceAtEndOfSelfclosingTag ? ' />' : '/>'; // self-closing node\n\n    appendContent(state, selfClosingNodeClosingTag);\n  } else if (node.children.length === 0) {\n    // empty node\n    appendContent(state, '></' + node.name + '>');\n  } else {\n    appendContent(state, '>');\n    state.level++;\n    let nodePreserveSpace = node.attributes['xml:space'] === 'preserve';\n\n    if (!nodePreserveSpace && state.options.collapseContent) {\n      let containsTextNodes = false;\n      let containsTextNodesWithLineBreaks = false;\n      let containsNonTextNodes = false;\n      node.children.forEach(function (child, index) {\n        if (child.type === 'Text') {\n          if (child.content.includes('\\n')) {\n            containsTextNodesWithLineBreaks = true;\n            child.content = child.content.trim();\n          } else if (index === 0 || index === node.children.length - 1) {\n            if (child.content.trim().length === 0) {\n              // If the text node is at the start or end and is empty, it should be ignored when formatting\n              child.content = '';\n            }\n          }\n\n          if (child.content.length > 0) {\n            containsTextNodes = true;\n          }\n        } else if (child.type === 'CDATA') {\n          containsTextNodes = true;\n        } else {\n          containsNonTextNodes = true;\n        }\n      });\n\n      if (containsTextNodes && (!containsNonTextNodes || !containsTextNodesWithLineBreaks)) {\n        nodePreserveSpace = true;\n      }\n    }\n\n    node.children.forEach(function (child) {\n      processNode(child, state, preserveSpace || nodePreserveSpace, state.options);\n    });\n    state.level--;\n\n    if (!preserveSpace && !nodePreserveSpace) {\n      newLine(state);\n    }\n\n    appendContent(state, '</' + node.name + '>');\n  }\n}\n/**\n * @param {XMLFormatterState} state\n * @param {Record<String, String>} attributes\n * @return {void}\n */\n\n\nfunction processAttributes(state, attributes) {\n  Object.keys(attributes).forEach(function (attr) {\n    const escaped = attributes[attr].replace(/\"/g, '&quot;');\n    appendContent(state, ' ' + attr + '=\"' + escaped + '\"');\n  });\n}\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @return {void}\n */\n\n\nfunction processProcessingIntruction(node, state) {\n  if (state.content.length > 0) {\n    newLine(state);\n  }\n\n  appendContent(state, '<?' + node.name);\n  processAttributes(state, node.attributes);\n  appendContent(state, '?>');\n}\n/**\n * Converts the given XML into human readable format.\n *\n * @param {String} xml\n * @param {XMLFormatterOptions} options\n * @returns {string}\n */\n\n\nfunction format(xml) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options.indentation = 'indentation' in options ? options.indentation : '    ';\n  options.collapseContent = options.collapseContent === true;\n  options.lineSeparator = 'lineSeparator' in options ? options.lineSeparator : '\\r\\n';\n  options.whiteSpaceAtEndOfSelfclosingTag = !!options.whiteSpaceAtEndOfSelfclosingTag;\n\n  const parser = require('xml-parser-xo');\n\n  const parsedXml = parser(xml, {\n    filter: options.filter\n  });\n  const state = {\n    content: '',\n    level: 0,\n    options: options\n  };\n\n  if (parsedXml.declaration) {\n    processProcessingIntruction(parsedXml.declaration, state);\n  }\n\n  parsedXml.children.forEach(function (child) {\n    processNode(child, state, false);\n  });\n  return state.content.replace(/\\r\\n/g, '\\n').replace(/\\n/g, options.lineSeparator);\n}\n\nmodule.exports = format;","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/xml-formatter/index.js"],"names":["newLine","state","options","indentation","lineSeparator","content","i","level","appendContent","processNode","node","preserveSpace","processContentNode","type","processElementNode","processProcessingIntruction","Error","trim","length","name","processAttributes","attributes","children","selfClosingNodeClosingTag","whiteSpaceAtEndOfSelfclosingTag","nodePreserveSpace","collapseContent","containsTextNodes","containsTextNodesWithLineBreaks","containsNonTextNodes","forEach","child","index","includes","Object","keys","attr","escaped","replace","format","xml","parser","require","parsedXml","filter","declaration","module","exports"],"mappings":"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","sourcesContent":["/**\n * @typedef {Object} XMLFormatterOptions\n *  @property {String} [indentation='    '] The value used for indentation\n *  @property {function(node): boolean} [filter] Return false to exclude the node.\n *  @property {Boolean} [collapseContent=false] True to keep content in the same line as the element. Only works if element contains at least one text node\n *  @property {String} [lineSeparator='\\r\\n'] The line separator to use\n *  @property {String} [whiteSpaceAtEndOfSelfclosingTag=false] to either end ad self closing tag with `<tag/>` or `<tag />`\n */\n\n/**\n * @typedef {Object} XMLFormatterState\n * @param {String} content\n * @param {Number} level\n * @param {XMLFormatterOptions} options\n */\n\n/**\n * @param {XMLFormatterState} state\n * @return {void}\n */\nfunction newLine(state) {\n    if (!state.options.indentation && !state.options.lineSeparator) return;\n    state.content += state.options.lineSeparator;\n    let i;\n    for (i = 0; i < state.level; i++) {\n        state.content += state.options.indentation;\n    }\n}\n\n/**\n * @param {XMLFormatterState} state\n * @param {String} content\n * @return {void}\n */\nfunction appendContent(state, content) {\n    state.content += content;\n}\n\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @param {Boolean} preserveSpace\n * @return {void}\n */\nfunction processNode(node, state, preserveSpace) {\n    if (typeof node.content === 'string') {\n        processContentNode(node, state, preserveSpace);\n    } else if (node.type === 'Element') {\n        processElementNode(node, state, preserveSpace);\n    } else if (node.type === 'ProcessingInstruction') {\n        processProcessingIntruction(node, state, preserveSpace);\n    } else {\n        throw new Error('Unknown node type: ' + node.type);\n    }\n}\n\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @param {Boolean} preserveSpace\n * @return {void}\n */\nfunction processContentNode(node, state, preserveSpace) {\n    if (!preserveSpace) {\n        node.content = node.content.trim();\n    }\n    if (node.content.length > 0) {\n        if (!preserveSpace && state.content.length > 0) {\n            newLine(state);\n        }\n        appendContent(state, node.content);\n    }\n}\n\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @param {Boolean} preserveSpace\n * @return {void}\n */\nfunction processElementNode(node, state, preserveSpace) {\n    if (!preserveSpace && state.content.length > 0) {\n        newLine(state);\n    }\n\n    appendContent(state, '<' + node.name);\n    processAttributes(state, node.attributes);\n\n    if (node.children === null) {\n        const selfClosingNodeClosingTag = state.options.whiteSpaceAtEndOfSelfclosingTag ? ' />' : '/>'\n        // self-closing node\n        appendContent(state, selfClosingNodeClosingTag);\n    } else if (node.children.length === 0) {\n        // empty node\n        appendContent(state, '></' + node.name + '>');\n    } else {\n\n        appendContent(state, '>');\n\n        state.level++;\n\n        let nodePreserveSpace = node.attributes['xml:space'] === 'preserve';\n\n        if (!nodePreserveSpace && state.options.collapseContent) {\n            let containsTextNodes = false;\n            let containsTextNodesWithLineBreaks = false;\n            let containsNonTextNodes = false;\n\n            node.children.forEach(function(child, index) {\n                if (child.type === 'Text') {\n                    if (child.content.includes('\\n')) {\n                        containsTextNodesWithLineBreaks = true;\n                        child.content = child.content.trim();\n                    } else if (index === 0 || index === node.children.length - 1) {\n                        if (child.content.trim().length === 0) {\n                            // If the text node is at the start or end and is empty, it should be ignored when formatting\n                            child.content = '';\n                        }\n                    }\n                    if (child.content.length > 0) {\n                        containsTextNodes = true;\n                    }\n                } else if (child.type === 'CDATA') {\n                    containsTextNodes = true;\n                } else {\n                    containsNonTextNodes = true;\n                }\n            });\n\n            if (containsTextNodes && (!containsNonTextNodes || !containsTextNodesWithLineBreaks)) {\n                nodePreserveSpace = true;\n            }\n        }\n\n        node.children.forEach(function(child) {\n            processNode(child, state, preserveSpace || nodePreserveSpace, state.options);\n        });\n\n        state.level--;\n\n        if (!preserveSpace && !nodePreserveSpace) {\n            newLine(state);\n        }\n        appendContent(state, '</' + node.name + '>');\n    }\n}\n\n/**\n * @param {XMLFormatterState} state\n * @param {Record<String, String>} attributes\n * @return {void}\n */\nfunction processAttributes(state, attributes) {\n    Object.keys(attributes).forEach(function(attr) {\n        const escaped = attributes[attr].replace(/\"/g, '&quot;');\n        appendContent(state, ' ' + attr + '=\"' + escaped + '\"');\n    });\n}\n\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @return {void}\n */\nfunction processProcessingIntruction(node, state) {\n    if (state.content.length > 0) {\n        newLine(state);\n    }\n    appendContent(state, '<?' + node.name);\n    processAttributes(state, node.attributes);\n    appendContent(state, '?>');\n}\n\n\n/**\n * Converts the given XML into human readable format.\n *\n * @param {String} xml\n * @param {XMLFormatterOptions} options\n * @returns {string}\n */\nfunction format(xml, options = {}) {\n    options.indentation = 'indentation' in options ? options.indentation : '    ';\n    options.collapseContent = options.collapseContent === true;\n    options.lineSeparator = 'lineSeparator' in options ? options.lineSeparator : '\\r\\n';\n    options.whiteSpaceAtEndOfSelfclosingTag = !!options.whiteSpaceAtEndOfSelfclosingTag;\n\n    const parser = require('xml-parser-xo');\n    const parsedXml = parser(xml, {filter: options.filter});\n    const state = {content: '', level: 0, options: options};\n\n    if (parsedXml.declaration) {\n        processProcessingIntruction(parsedXml.declaration, state);\n    }\n\n    parsedXml.children.forEach(function(child) {\n        processNode(child, state, false);\n    });\n\n    return state.content\n        .replace(/\\r\\n/g, '\\n')\n        .replace(/\\n/g, options.lineSeparator);\n}\n\n\nmodule.exports = format;\n"]},"metadata":{},"sourceType":"script"}
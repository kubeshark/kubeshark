{"ast":null,"code":"/**\n * @typedef {Object} ParsingOptions\n *  @property {function(node)} filter Returns false to exclude a node. Default is true.\n */\n\n/**\n * Parse the given XML string into an object.\n *\n * @param {String} xml\n * @param {ParsingOptions} [options]\n * @return {Object}\n * @api public\n */\nfunction parse(xml) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  options.filter = options.filter || (() => true);\n\n  function nextChild() {\n    return tag() || content() || comment() || cdata();\n  }\n\n  function nextRootChild() {\n    match(/\\s*/);\n    return tag(true) || comment() || doctype() || processingInstruction(false);\n  }\n\n  function document() {\n    const decl = declaration();\n    const children = [];\n    let documentRootNode;\n    let child = nextRootChild();\n\n    while (child) {\n      if (child.node.type === 'Element') {\n        if (documentRootNode) {\n          throw new Error('Found multiple root nodes');\n        }\n\n        documentRootNode = child.node;\n      }\n\n      if (!child.excluded) {\n        children.push(child.node);\n      }\n\n      child = nextRootChild();\n    }\n\n    if (!documentRootNode) {\n      throw new Error('Failed to parse XML');\n    }\n\n    return {\n      declaration: decl ? decl.node : null,\n      root: documentRootNode,\n      children\n    };\n  }\n\n  function declaration() {\n    return processingInstruction(true);\n  }\n\n  function processingInstruction(matchDeclaration) {\n    const m = matchDeclaration ? match(/^<\\?(xml)\\s*/) : match(/^<\\?([\\w-:.]+)\\s*/);\n    if (!m) return; // tag\n\n    const node = {\n      name: m[1],\n      type: 'ProcessingInstruction',\n      attributes: {}\n    }; // attributes\n\n    while (!(eos() || is('?>'))) {\n      const attr = attribute();\n      if (!attr) return node;\n      node.attributes[attr.name] = attr.value;\n    }\n\n    match(/\\?>/);\n    return {\n      excluded: matchDeclaration ? false : options.filter(node) === false,\n      node\n    };\n  }\n\n  function tag(matchRoot) {\n    const m = match(/^<([\\w-:.]+)\\s*/);\n    if (!m) return; // name\n\n    const node = {\n      type: 'Element',\n      name: m[1],\n      attributes: {},\n      children: []\n    }; // attributes\n\n    while (!(eos() || is('>') || is('?>') || is('/>'))) {\n      const attr = attribute();\n      if (!attr) return node;\n      node.attributes[attr.name] = attr.value;\n    }\n\n    const excluded = matchRoot ? false : options.filter(node) === false; // self closing tag\n\n    if (match(/^\\s*\\/>/)) {\n      node.children = null;\n      return {\n        excluded,\n        node\n      };\n    }\n\n    match(/\\??>/);\n\n    if (!excluded) {\n      // children\n      let child = nextChild();\n\n      while (child) {\n        if (!child.excluded) {\n          node.children.push(child.node);\n        }\n\n        child = nextChild();\n      }\n    } // closing\n\n\n    match(/^<\\/[\\w-:.]+>/);\n    return {\n      excluded,\n      node\n    };\n  }\n\n  function doctype() {\n    const m = match(/^<!DOCTYPE\\s+[^>]*>/);\n\n    if (m) {\n      const node = {\n        type: 'DocumentType',\n        content: m[0]\n      };\n      return {\n        excluded: options.filter(node) === false,\n        node\n      };\n    }\n  }\n\n  function cdata() {\n    if (xml.startsWith('<![CDATA[')) {\n      const endPositionStart = xml.indexOf(']]>');\n\n      if (endPositionStart > -1) {\n        const endPositionFinish = endPositionStart + 3;\n        const node = {\n          type: 'CDATA',\n          content: xml.substring(0, endPositionFinish)\n        };\n        xml = xml.slice(endPositionFinish);\n        return {\n          excluded: options.filter(node) === false,\n          node\n        };\n      }\n    }\n  }\n\n  function comment() {\n    const m = match(/^<!--[\\s\\S]*?-->/);\n\n    if (m) {\n      const node = {\n        type: 'Comment',\n        content: m[0]\n      };\n      return {\n        excluded: options.filter(node) === false,\n        node\n      };\n    }\n  }\n\n  function content() {\n    const m = match(/^([^<]+)/);\n\n    if (m) {\n      const node = {\n        type: 'Text',\n        content: m[1]\n      };\n      return {\n        excluded: options.filter(node) === false,\n        node\n      };\n    }\n  }\n\n  function attribute() {\n    const m = match(/([\\w-:.]+)\\s*=\\s*(\"[^\"]*\"|'[^']*'|\\w+)\\s*/);\n    if (!m) return;\n    return {\n      name: m[1],\n      value: strip(m[2])\n    };\n  }\n  /**\n   * Strip quotes from `val`.\n   */\n\n\n  function strip(val) {\n    return val.replace(/^['\"]|['\"]$/g, '');\n  }\n  /**\n   * Match `re` and advance the string.\n   */\n\n\n  function match(re) {\n    const m = xml.match(re);\n    if (!m) return;\n    xml = xml.slice(m[0].length);\n    return m;\n  }\n  /**\n   * End-of-source.\n   */\n\n\n  function eos() {\n    return 0 === xml.length;\n  }\n  /**\n   * Check for `prefix`.\n   */\n\n\n  function is(prefix) {\n    return 0 === xml.indexOf(prefix);\n  }\n\n  xml = xml.trim();\n  return document();\n}\n\nmodule.exports = parse;","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/xml-parser-xo/index.js"],"names":["parse","xml","options","filter","nextChild","tag","content","comment","cdata","nextRootChild","match","doctype","processingInstruction","document","decl","declaration","children","documentRootNode","child","node","type","Error","excluded","push","root","matchDeclaration","m","name","attributes","eos","is","attr","attribute","value","matchRoot","startsWith","endPositionStart","indexOf","endPositionFinish","substring","slice","strip","val","replace","re","length","prefix","trim","module","exports"],"mappings":"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","sourcesContent":["/**\n * @typedef {Object} ParsingOptions\n *  @property {function(node)} filter Returns false to exclude a node. Default is true.\n */\n\n/**\n * Parse the given XML string into an object.\n *\n * @param {String} xml\n * @param {ParsingOptions} [options]\n * @return {Object}\n * @api public\n */\nfunction parse(xml, options = {}) {\n\n    options.filter = options.filter || (() => true);\n\n    function nextChild() {\n        return tag() || content() || comment() || cdata();\n    }\n\n    function nextRootChild() {\n        match(/\\s*/);\n        return tag(true) || comment() || doctype() || processingInstruction(false);\n    }\n\n    function document() {\n        const decl = declaration();\n        const children = [];\n        let documentRootNode;\n        let child = nextRootChild();\n\n        while (child) {\n            if (child.node.type === 'Element') {\n                if (documentRootNode) {\n                    throw new Error('Found multiple root nodes');\n                }\n                documentRootNode = child.node;\n            }\n\n            if (!child.excluded) {\n                children.push(child.node);\n            }\n\n            child = nextRootChild();\n        }\n\n        if (!documentRootNode) {\n            throw new Error('Failed to parse XML');\n        }\n\n        return {\n            declaration: decl ? decl.node : null,\n            root: documentRootNode,\n            children\n        };\n    }\n\n    function declaration() {\n        return processingInstruction(true);\n    }\n\n    function processingInstruction(matchDeclaration) {\n        const m = matchDeclaration ? match(/^<\\?(xml)\\s*/) : match(/^<\\?([\\w-:.]+)\\s*/);\n        if (!m) return;\n\n        // tag\n        const node = {\n            name: m[1],\n            type: 'ProcessingInstruction',\n            attributes: {}\n        };\n\n        // attributes\n        while (!(eos() || is('?>'))) {\n            const attr = attribute();\n            if (!attr) return node;\n            node.attributes[attr.name] = attr.value;\n        }\n\n        match(/\\?>/);\n\n        return {\n            excluded: matchDeclaration ? false : options.filter(node) === false,\n            node\n        };\n    }\n\n    function tag(matchRoot) {\n        const m = match(/^<([\\w-:.]+)\\s*/);\n        if (!m) return;\n\n        // name\n        const node = {\n            type: 'Element',\n            name: m[1],\n            attributes: {},\n            children: []\n        };\n\n        // attributes\n        while (!(eos() || is('>') || is('?>') || is('/>'))) {\n            const attr = attribute();\n            if (!attr) return node;\n            node.attributes[attr.name] = attr.value;\n        }\n\n        const excluded = matchRoot ? false : options.filter(node) === false;\n\n        // self closing tag\n        if (match(/^\\s*\\/>/)) {\n            node.children = null;\n            return {\n                excluded,\n                node\n            };\n        }\n\n        match(/\\??>/);\n\n        if (!excluded) {\n            // children\n            let child = nextChild();\n            while (child) {\n                if (!child.excluded) {\n                    node.children.push(child.node);\n                }\n                child = nextChild();\n            }\n        }\n\n        // closing\n        match(/^<\\/[\\w-:.]+>/);\n\n        return {\n            excluded,\n            node\n        };\n    }\n\n    function doctype() {\n        const m = match(/^<!DOCTYPE\\s+[^>]*>/);\n        if (m) {\n            const node = {\n                type: 'DocumentType',\n                content: m[0]\n            };\n            return {\n                excluded: options.filter(node) === false,\n                node\n            };\n        }\n    }\n\n    function cdata() {\n        if (xml.startsWith('<![CDATA[')) {\n            const endPositionStart = xml.indexOf(']]>');\n            if (endPositionStart > -1) {\n                const endPositionFinish  = endPositionStart + 3;\n                const node = {\n                    type: 'CDATA',\n                    content: xml.substring(0, endPositionFinish)\n                };\n                xml = xml.slice(endPositionFinish);\n                return {\n                    excluded: options.filter(node) === false,\n                    node\n                };\n            }\n        }\n    }\n\n    function comment() {\n        const m = match(/^<!--[\\s\\S]*?-->/);\n        if (m) {\n            const node = {\n                type: 'Comment',\n                content: m[0]\n            };\n            return {\n                excluded: options.filter(node) === false,\n                node\n            };\n        }\n    }\n\n    function content() {\n        const m = match(/^([^<]+)/);\n        if (m) {\n            const node = {\n                type: 'Text',\n                content: m[1]\n            };\n            return {\n                excluded: options.filter(node) === false,\n                node\n            };\n        }\n    }\n\n    function attribute() {\n        const m = match(/([\\w-:.]+)\\s*=\\s*(\"[^\"]*\"|'[^']*'|\\w+)\\s*/);\n        if (!m) return;\n        return {name: m[1], value: strip(m[2])}\n    }\n\n    /**\n     * Strip quotes from `val`.\n     */\n    function strip(val) {\n        return val.replace(/^['\"]|['\"]$/g, '');\n    }\n\n    /**\n     * Match `re` and advance the string.\n     */\n    function match(re) {\n        const m = xml.match(re);\n        if (!m) return;\n        xml = xml.slice(m[0].length);\n        return m;\n    }\n\n    /**\n     * End-of-source.\n     */\n    function eos() {\n        return 0 === xml.length;\n    }\n\n    /**\n     * Check for `prefix`.\n     */\n    function is(prefix) {\n        return 0 === xml.indexOf(prefix);\n    }\n\n    xml = xml.trim();\n\n    return document();\n}\n\nmodule.exports = parse;\n"]},"metadata":{},"sourceType":"script"}
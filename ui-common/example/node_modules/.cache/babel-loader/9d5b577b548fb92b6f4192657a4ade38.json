{"ast":null,"code":"var own = {}.hasOwnProperty;\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n */\n\n/**\n * Stringify one point, a position (start and end points), or a node’s\n * positional information.\n *\n * @param {Node|Position|Point} [value]\n * @returns {string}\n */\n\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return '';\n  } // Node.\n\n\n  if (own.call(value, 'position') || own.call(value, 'type')) {\n    // @ts-ignore looks like a node.\n    return position(value.position);\n  } // Position.\n\n\n  if (own.call(value, 'start') || own.call(value, 'end')) {\n    // @ts-ignore looks like a position.\n    return position(value);\n  } // Point.\n\n\n  if (own.call(value, 'line') || own.call(value, 'column')) {\n    // @ts-ignore looks like a point.\n    return point(value);\n  } // ?\n\n\n  return '';\n}\n/**\n * @param {Point} point\n * @returns {string}\n */\n\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column);\n}\n/**\n * @param {Position} pos\n * @returns {string}\n */\n\n\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end);\n}\n/**\n * @param {number} value\n * @returns {number}\n */\n\n\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1;\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/unist-util-stringify-position/index.js"],"names":["own","hasOwnProperty","stringifyPosition","value","call","position","point","index","line","column","pos","start","end"],"mappings":"AAAA,IAAIA,GAAG,GAAG,GAAGC,cAAb;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,iBAAT,CAA2BC,KAA3B,EAAkC;AACvC;AACA,MAAI,CAACA,KAAD,IAAU,OAAOA,KAAP,KAAiB,QAA/B,EAAyC;AACvC,WAAO,EAAP;AACD,GAJsC,CAMvC;;;AACA,MAAIH,GAAG,CAACI,IAAJ,CAASD,KAAT,EAAgB,UAAhB,KAA+BH,GAAG,CAACI,IAAJ,CAASD,KAAT,EAAgB,MAAhB,CAAnC,EAA4D;AAC1D;AACA,WAAOE,QAAQ,CAACF,KAAK,CAACE,QAAP,CAAf;AACD,GAVsC,CAYvC;;;AACA,MAAIL,GAAG,CAACI,IAAJ,CAASD,KAAT,EAAgB,OAAhB,KAA4BH,GAAG,CAACI,IAAJ,CAASD,KAAT,EAAgB,KAAhB,CAAhC,EAAwD;AACtD;AACA,WAAOE,QAAQ,CAACF,KAAD,CAAf;AACD,GAhBsC,CAkBvC;;;AACA,MAAIH,GAAG,CAACI,IAAJ,CAASD,KAAT,EAAgB,MAAhB,KAA2BH,GAAG,CAACI,IAAJ,CAASD,KAAT,EAAgB,QAAhB,CAA/B,EAA0D;AACxD;AACA,WAAOG,KAAK,CAACH,KAAD,CAAZ;AACD,GAtBsC,CAwBvC;;;AACA,SAAO,EAAP;AACD;AAED;AACA;AACA;AACA;;AACA,SAASG,KAAT,CAAeA,KAAf,EAAsB;AACpB,SAAOC,KAAK,CAACD,KAAK,IAAIA,KAAK,CAACE,IAAhB,CAAL,GAA6B,GAA7B,GAAmCD,KAAK,CAACD,KAAK,IAAIA,KAAK,CAACG,MAAhB,CAA/C;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASJ,QAAT,CAAkBK,GAAlB,EAAuB;AACrB,SAAOJ,KAAK,CAACI,GAAG,IAAIA,GAAG,CAACC,KAAZ,CAAL,GAA0B,GAA1B,GAAgCL,KAAK,CAACI,GAAG,IAAIA,GAAG,CAACE,GAAZ,CAA5C;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASL,KAAT,CAAeJ,KAAf,EAAsB;AACpB,SAAOA,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAA1B,GAAqCA,KAArC,GAA6C,CAApD;AACD","sourcesContent":["var own = {}.hasOwnProperty\n\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n */\n\n/**\n * Stringify one point, a position (start and end points), or a node’s\n * positional information.\n *\n * @param {Node|Position|Point} [value]\n * @returns {string}\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if (own.call(value, 'position') || own.call(value, 'type')) {\n    // @ts-ignore looks like a node.\n    return position(value.position)\n  }\n\n  // Position.\n  if (own.call(value, 'start') || own.call(value, 'end')) {\n    // @ts-ignore looks like a position.\n    return position(value)\n  }\n\n  // Point.\n  if (own.call(value, 'line') || own.call(value, 'column')) {\n    // @ts-ignore looks like a point.\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"'use strict'; //Const\n\nconst NOAH_ARK_CAPACITY = 3; //List of formatting elements\n\nclass FormattingElementList {\n  constructor(treeAdapter) {\n    this.length = 0;\n    this.entries = [];\n    this.treeAdapter = treeAdapter;\n    this.bookmark = null;\n  } //Noah Ark's condition\n  //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n  //lightweight heuristics without thorough attributes check.\n\n\n  _getNoahArkConditionCandidates(newElement) {\n    const candidates = [];\n\n    if (this.length >= NOAH_ARK_CAPACITY) {\n      const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n      const neTagName = this.treeAdapter.getTagName(newElement);\n      const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n\n      for (let i = this.length - 1; i >= 0; i--) {\n        const entry = this.entries[i];\n\n        if (entry.type === FormattingElementList.MARKER_ENTRY) {\n          break;\n        }\n\n        const element = entry.element;\n        const elementAttrs = this.treeAdapter.getAttrList(element);\n        const isCandidate = this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI && elementAttrs.length === neAttrsLength;\n\n        if (isCandidate) {\n          candidates.push({\n            idx: i,\n            attrs: elementAttrs\n          });\n        }\n      }\n    }\n\n    return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n  }\n\n  _ensureNoahArkCondition(newElement) {\n    const candidates = this._getNoahArkConditionCandidates(newElement);\n\n    let cLength = candidates.length;\n\n    if (cLength) {\n      const neAttrs = this.treeAdapter.getAttrList(newElement);\n      const neAttrsLength = neAttrs.length;\n      const neAttrsMap = Object.create(null); //NOTE: build attrs map for the new element so we can perform fast lookups\n\n      for (let i = 0; i < neAttrsLength; i++) {\n        const neAttr = neAttrs[i];\n        neAttrsMap[neAttr.name] = neAttr.value;\n      }\n\n      for (let i = 0; i < neAttrsLength; i++) {\n        for (let j = 0; j < cLength; j++) {\n          const cAttr = candidates[j].attrs[i];\n\n          if (neAttrsMap[cAttr.name] !== cAttr.value) {\n            candidates.splice(j, 1);\n            cLength--;\n          }\n\n          if (candidates.length < NOAH_ARK_CAPACITY) {\n            return;\n          }\n        }\n      } //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n\n\n      for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {\n        this.entries.splice(candidates[i].idx, 1);\n        this.length--;\n      }\n    }\n  } //Mutations\n\n\n  insertMarker() {\n    this.entries.push({\n      type: FormattingElementList.MARKER_ENTRY\n    });\n    this.length++;\n  }\n\n  pushElement(element, token) {\n    this._ensureNoahArkCondition(element);\n\n    this.entries.push({\n      type: FormattingElementList.ELEMENT_ENTRY,\n      element: element,\n      token: token\n    });\n    this.length++;\n  }\n\n  insertElementAfterBookmark(element, token) {\n    let bookmarkIdx = this.length - 1;\n\n    for (; bookmarkIdx >= 0; bookmarkIdx--) {\n      if (this.entries[bookmarkIdx] === this.bookmark) {\n        break;\n      }\n    }\n\n    this.entries.splice(bookmarkIdx + 1, 0, {\n      type: FormattingElementList.ELEMENT_ENTRY,\n      element: element,\n      token: token\n    });\n    this.length++;\n  }\n\n  removeEntry(entry) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      if (this.entries[i] === entry) {\n        this.entries.splice(i, 1);\n        this.length--;\n        break;\n      }\n    }\n  }\n\n  clearToLastMarker() {\n    while (this.length) {\n      const entry = this.entries.pop();\n      this.length--;\n\n      if (entry.type === FormattingElementList.MARKER_ENTRY) {\n        break;\n      }\n    }\n  } //Search\n\n\n  getElementEntryInScopeWithTagName(tagName) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      const entry = this.entries[i];\n\n      if (entry.type === FormattingElementList.MARKER_ENTRY) {\n        return null;\n      }\n\n      if (this.treeAdapter.getTagName(entry.element) === tagName) {\n        return entry;\n      }\n    }\n\n    return null;\n  }\n\n  getElementEntry(element) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      const entry = this.entries[i];\n\n      if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n        return entry;\n      }\n    }\n\n    return null;\n  }\n\n} //Entry types\n\n\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\nmodule.exports = FormattingElementList;","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/parse5/lib/parser/formatting-element-list.js"],"names":["NOAH_ARK_CAPACITY","FormattingElementList","constructor","treeAdapter","length","entries","bookmark","_getNoahArkConditionCandidates","newElement","candidates","neAttrsLength","getAttrList","neTagName","getTagName","neNamespaceURI","getNamespaceURI","i","entry","type","MARKER_ENTRY","element","elementAttrs","isCandidate","push","idx","attrs","_ensureNoahArkCondition","cLength","neAttrs","neAttrsMap","Object","create","neAttr","name","value","j","cAttr","splice","insertMarker","pushElement","token","ELEMENT_ENTRY","insertElementAfterBookmark","bookmarkIdx","removeEntry","clearToLastMarker","pop","getElementEntryInScopeWithTagName","tagName","getElementEntry","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n//Const\nconst NOAH_ARK_CAPACITY = 3;\n\n//List of formatting elements\nclass FormattingElementList {\n    constructor(treeAdapter) {\n        this.length = 0;\n        this.entries = [];\n        this.treeAdapter = treeAdapter;\n        this.bookmark = null;\n    }\n\n    //Noah Ark's condition\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n    //lightweight heuristics without thorough attributes check.\n    _getNoahArkConditionCandidates(newElement) {\n        const candidates = [];\n\n        if (this.length >= NOAH_ARK_CAPACITY) {\n            const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n            const neTagName = this.treeAdapter.getTagName(newElement);\n            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n\n            for (let i = this.length - 1; i >= 0; i--) {\n                const entry = this.entries[i];\n\n                if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                    break;\n                }\n\n                const element = entry.element;\n                const elementAttrs = this.treeAdapter.getAttrList(element);\n\n                const isCandidate =\n                    this.treeAdapter.getTagName(element) === neTagName &&\n                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&\n                    elementAttrs.length === neAttrsLength;\n\n                if (isCandidate) {\n                    candidates.push({ idx: i, attrs: elementAttrs });\n                }\n            }\n        }\n\n        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n    }\n\n    _ensureNoahArkCondition(newElement) {\n        const candidates = this._getNoahArkConditionCandidates(newElement);\n        let cLength = candidates.length;\n\n        if (cLength) {\n            const neAttrs = this.treeAdapter.getAttrList(newElement);\n            const neAttrsLength = neAttrs.length;\n            const neAttrsMap = Object.create(null);\n\n            //NOTE: build attrs map for the new element so we can perform fast lookups\n            for (let i = 0; i < neAttrsLength; i++) {\n                const neAttr = neAttrs[i];\n\n                neAttrsMap[neAttr.name] = neAttr.value;\n            }\n\n            for (let i = 0; i < neAttrsLength; i++) {\n                for (let j = 0; j < cLength; j++) {\n                    const cAttr = candidates[j].attrs[i];\n\n                    if (neAttrsMap[cAttr.name] !== cAttr.value) {\n                        candidates.splice(j, 1);\n                        cLength--;\n                    }\n\n                    if (candidates.length < NOAH_ARK_CAPACITY) {\n                        return;\n                    }\n                }\n            }\n\n            //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n            for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {\n                this.entries.splice(candidates[i].idx, 1);\n                this.length--;\n            }\n        }\n    }\n\n    //Mutations\n    insertMarker() {\n        this.entries.push({ type: FormattingElementList.MARKER_ENTRY });\n        this.length++;\n    }\n\n    pushElement(element, token) {\n        this._ensureNoahArkCondition(element);\n\n        this.entries.push({\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    insertElementAfterBookmark(element, token) {\n        let bookmarkIdx = this.length - 1;\n\n        for (; bookmarkIdx >= 0; bookmarkIdx--) {\n            if (this.entries[bookmarkIdx] === this.bookmark) {\n                break;\n            }\n        }\n\n        this.entries.splice(bookmarkIdx + 1, 0, {\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    removeEntry(entry) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            if (this.entries[i] === entry) {\n                this.entries.splice(i, 1);\n                this.length--;\n                break;\n            }\n        }\n    }\n\n    clearToLastMarker() {\n        while (this.length) {\n            const entry = this.entries.pop();\n\n            this.length--;\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                break;\n            }\n        }\n    }\n\n    //Search\n    getElementEntryInScopeWithTagName(tagName) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                return null;\n            }\n\n            if (this.treeAdapter.getTagName(entry.element) === tagName) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n\n    getElementEntry(element) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n}\n\n//Entry types\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\n\nmodule.exports = FormattingElementList;\n"]},"metadata":{},"sourceType":"script"}
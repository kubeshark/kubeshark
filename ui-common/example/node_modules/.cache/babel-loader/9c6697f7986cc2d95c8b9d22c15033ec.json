{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar field_descriptor_1 = require(\"./field-descriptor\");\n\nvar protobuf_field_1 = require(\"./protobuf-field\");\n\nvar wire_type_1 = require(\"./wire-type\");\n\nfunction base64ToBin(dataBase64) {\n  return Buffer.from(dataBase64, 'base64');\n}\n\nfunction protobufUnframe(data) {\n  var is_compressed = data[0];\n\n  if (is_compressed) {\n    throw new Error(\"Compressed protobuf frames are not supported\");\n  }\n\n  var size = data.readUInt32BE(1);\n  var unframedData = data.slice(5);\n\n  if (size !== unframedData.length) {\n    console.error(\"More than one message in protobuf payload is not supported, taking first\");\n    unframedData.slice(0, size);\n  }\n\n  return unframedData;\n}\n\nvar ProtobufDecoder =\n/** @class */\nfunction () {\n  function ProtobufDecoder(dataBase64, isFramed) {\n    var data = base64ToBin(dataBase64);\n\n    if (isFramed) {\n      data = protobufUnframe(data);\n    }\n\n    this.data = data;\n    this.offset = 0;\n    this.strings = [];\n  }\n\n  ProtobufDecoder.prototype.decode = function () {\n    return this.parseMessage(0, this.data.length);\n  };\n\n  ProtobufDecoder.prototype.parseMessage = function (offset, end) {\n    var fields = [];\n\n    while (offset < end) {\n      var _a = this.parseFieldTag(offset, end),\n          newOffset = _a[0],\n          wireType = _a[1],\n          fieldNumber = _a[2];\n\n      offset = newOffset;\n\n      if (wireType == wire_type_1.default.TYPE_VARINT) {\n        var _b = this.parseVarint(offset, end),\n            num = _b[0],\n            newOffset_1 = _b[1];\n\n        offset = newOffset_1;\n        var field = new protobuf_field_1.default(fieldNumber, field_descriptor_1.default.TYPE_INT32, [num]);\n        fields.push(field);\n      } else if (wireType === wire_type_1.default.TYPE_FIXED32) {\n        var _c = this.parseFixed(offset, end, 4),\n            newOffset_2 = _c[0],\n            val = _c[1],\n            isFloat = _c[2];\n\n        offset = newOffset_2;\n        var ftype = isFloat ? field_descriptor_1.default.TYPE_FLOAT : field_descriptor_1.default.TYPE_FIXED32;\n        var field = new protobuf_field_1.default(fieldNumber, ftype, [val]);\n        fields.push(field);\n      } else if (wireType === wire_type_1.default.TYPE_FIXED64) {\n        var _d = this.parseFixed(offset, end, 8),\n            newOffset_3 = _d[0],\n            val = _d[1],\n            isFloat = _d[2];\n\n        offset = newOffset_3;\n        var ftype = isFloat ? field_descriptor_1.default.TYPE_DOUBLE : field_descriptor_1.default.TYPE_FIXED64;\n        var field = new protobuf_field_1.default(fieldNumber, ftype, [val]);\n        fields.push(field);\n      } else if (wireType === wire_type_1.default.TYPE_LENGTH_DELIMITED) {\n        var _e = this.parseVarint(offset, end),\n            fieldLen = _e[0],\n            newOffset_4 = _e[1];\n\n        offset = newOffset_4;\n\n        try {\n          var buf = this.data.slice(offset, offset + fieldLen);\n\n          if (fieldLen > 2 && (this.data[offset] < 32 || this.data[offset + 1] < 32)) {\n            throw new Error(\"Likely not a string: \" + buf.toString('hex'));\n          }\n\n          var val = buf.toString('utf8'); // eslint-disable-next-line no-control-regex\n\n          if (val.search(/[\\u0000-\\u0019]/) !== -1) {\n            throw new Error(\"Likely not a string: \" + buf.toString('hex'));\n          }\n\n          var field = new protobuf_field_1.default(fieldNumber, field_descriptor_1.default.TYPE_STRING, [val]);\n          fields.push(field);\n        } catch (error) {\n          // TODO: Use specific error class\n          var submsg = this.parseMessage(offset, offset + fieldLen);\n          var field = new protobuf_field_1.default(fieldNumber, field_descriptor_1.default.TYPE_MESSAGE, submsg.values);\n          fields.push(field);\n        }\n\n        offset = offset + fieldLen;\n      } else {\n        throw new Error(\"Unsupported wire type: \" + wireType);\n      }\n    }\n\n    if (offset !== end) {\n      throw new Error('Decoding process quick before completion');\n    }\n\n    return new protobuf_field_1.default(0, field_descriptor_1.default.TYPE_MESSAGE, fields);\n  };\n\n  ProtobufDecoder.prototype.parseFieldTag = function (start, end) {\n    var wireType = this.data.readUInt8(start) & 0x7;\n\n    var _a = this.parseVarint(start, end),\n        varint = _a[0],\n        offset = _a[1];\n\n    var fieldNumber = varint >> 3;\n    return [offset, wireType, fieldNumber];\n  };\n\n  ProtobufDecoder.prototype.parseVarint = function (start, end) {\n    var bytesArr = [];\n    var pos = 0;\n    var isDone = false;\n\n    while (start + pos < end) {\n      var oneByte = this.data.readUInt8(start + pos);\n      bytesArr.push(oneByte & 0x7F);\n      pos++;\n\n      if ((oneByte & 0x80) === 0x00) {\n        isDone = true;\n        break;\n      }\n    }\n\n    if (!isDone) {\n      throw new Error(\"Failed to parse protobuf tag\");\n    }\n\n    var index = bytesArr.length - 1;\n    var val = 0;\n\n    while (index >= 0) {\n      val = (val << 7) + bytesArr[index];\n      index--;\n    }\n\n    return [val, start + pos];\n  };\n\n  ProtobufDecoder.prototype.parseFixed = function (offset, end, size) {\n    // TODO: detect signed types\n    var num;\n    var isFloat = true;\n\n    if (size == 4) {\n      try {\n        num = this.data.readFloatBE(offset);\n      } catch (error) {\n        num = this.data.readUInt32BE(offset);\n        isFloat = true;\n      }\n    } else if (size == 8) {\n      try {\n        num = this.data.readDoubleBE(offset);\n      } catch (error) {\n        num = this.data.readBigUInt64BE(offset);\n        isFloat = true;\n      }\n    }\n\n    offset += size;\n    return [offset, num, isFloat];\n  };\n\n  return ProtobufDecoder;\n}();\n\nexports.default = ProtobufDecoder;","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/protobuf-decoder/lib/protobuf-decoder.js"],"names":["Object","defineProperty","exports","value","field_descriptor_1","require","protobuf_field_1","wire_type_1","base64ToBin","dataBase64","Buffer","from","protobufUnframe","data","is_compressed","Error","size","readUInt32BE","unframedData","slice","length","console","error","ProtobufDecoder","isFramed","offset","strings","prototype","decode","parseMessage","end","fields","_a","parseFieldTag","newOffset","wireType","fieldNumber","default","TYPE_VARINT","_b","parseVarint","num","newOffset_1","field","TYPE_INT32","push","TYPE_FIXED32","_c","parseFixed","newOffset_2","val","isFloat","ftype","TYPE_FLOAT","TYPE_FIXED64","_d","newOffset_3","TYPE_DOUBLE","TYPE_LENGTH_DELIMITED","_e","fieldLen","newOffset_4","buf","toString","search","TYPE_STRING","submsg","TYPE_MESSAGE","values","start","readUInt8","varint","bytesArr","pos","isDone","oneByte","index","readFloatBE","readDoubleBE","readBigUInt64BE"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar field_descriptor_1 = require(\"./field-descriptor\");\nvar protobuf_field_1 = require(\"./protobuf-field\");\nvar wire_type_1 = require(\"./wire-type\");\nfunction base64ToBin(dataBase64) {\n    return Buffer.from(dataBase64, 'base64');\n}\nfunction protobufUnframe(data) {\n    var is_compressed = data[0];\n    if (is_compressed) {\n        throw new Error(\"Compressed protobuf frames are not supported\");\n    }\n    var size = data.readUInt32BE(1);\n    var unframedData = data.slice(5);\n    if (size !== unframedData.length) {\n        console.error(\"More than one message in protobuf payload is not supported, taking first\");\n        unframedData.slice(0, size);\n    }\n    return unframedData;\n}\nvar ProtobufDecoder = /** @class */ (function () {\n    function ProtobufDecoder(dataBase64, isFramed) {\n        var data = base64ToBin(dataBase64);\n        if (isFramed) {\n            data = protobufUnframe(data);\n        }\n        this.data = data;\n        this.offset = 0;\n        this.strings = [];\n    }\n    ProtobufDecoder.prototype.decode = function () {\n        return this.parseMessage(0, this.data.length);\n    };\n    ProtobufDecoder.prototype.parseMessage = function (offset, end) {\n        var fields = [];\n        while (offset < end) {\n            var _a = this.parseFieldTag(offset, end), newOffset = _a[0], wireType = _a[1], fieldNumber = _a[2];\n            offset = newOffset;\n            if (wireType == wire_type_1.default.TYPE_VARINT) {\n                var _b = this.parseVarint(offset, end), num = _b[0], newOffset_1 = _b[1];\n                offset = newOffset_1;\n                var field = new protobuf_field_1.default(fieldNumber, field_descriptor_1.default.TYPE_INT32, [num]);\n                fields.push(field);\n            }\n            else if (wireType === wire_type_1.default.TYPE_FIXED32) {\n                var _c = this.parseFixed(offset, end, 4), newOffset_2 = _c[0], val = _c[1], isFloat = _c[2];\n                offset = newOffset_2;\n                var ftype = isFloat ? field_descriptor_1.default.TYPE_FLOAT : field_descriptor_1.default.TYPE_FIXED32;\n                var field = new protobuf_field_1.default(fieldNumber, ftype, [val]);\n                fields.push(field);\n            }\n            else if (wireType === wire_type_1.default.TYPE_FIXED64) {\n                var _d = this.parseFixed(offset, end, 8), newOffset_3 = _d[0], val = _d[1], isFloat = _d[2];\n                offset = newOffset_3;\n                var ftype = isFloat ? field_descriptor_1.default.TYPE_DOUBLE : field_descriptor_1.default.TYPE_FIXED64;\n                var field = new protobuf_field_1.default(fieldNumber, ftype, [val]);\n                fields.push(field);\n            }\n            else if (wireType === wire_type_1.default.TYPE_LENGTH_DELIMITED) {\n                var _e = this.parseVarint(offset, end), fieldLen = _e[0], newOffset_4 = _e[1];\n                offset = newOffset_4;\n                try {\n                    var buf = this.data.slice(offset, offset + fieldLen);\n                    if ((fieldLen > 2) && (this.data[offset] < 32 || this.data[offset + 1] < 32)) {\n                        throw new Error(\"Likely not a string: \" + buf.toString('hex'));\n                    }\n                    var val = buf.toString('utf8');\n                    // eslint-disable-next-line no-control-regex\n                    if (val.search(/[\\u0000-\\u0019]/) !== -1) {\n                        throw new Error(\"Likely not a string: \" + buf.toString('hex'));\n                    }\n                    var field = new protobuf_field_1.default(fieldNumber, field_descriptor_1.default.TYPE_STRING, [val]);\n                    fields.push(field);\n                }\n                catch (error) { // TODO: Use specific error class\n                    var submsg = this.parseMessage(offset, offset + fieldLen);\n                    var field = new protobuf_field_1.default(fieldNumber, field_descriptor_1.default.TYPE_MESSAGE, submsg.values);\n                    fields.push(field);\n                }\n                offset = offset + fieldLen;\n            }\n            else {\n                throw new Error(\"Unsupported wire type: \" + wireType);\n            }\n        }\n        if (offset !== end) {\n            throw new Error('Decoding process quick before completion');\n        }\n        return new protobuf_field_1.default(0, field_descriptor_1.default.TYPE_MESSAGE, fields);\n    };\n    ProtobufDecoder.prototype.parseFieldTag = function (start, end) {\n        var wireType = this.data.readUInt8(start) & 0x7;\n        var _a = this.parseVarint(start, end), varint = _a[0], offset = _a[1];\n        var fieldNumber = varint >> 3;\n        return [offset, wireType, fieldNumber];\n    };\n    ProtobufDecoder.prototype.parseVarint = function (start, end) {\n        var bytesArr = [];\n        var pos = 0;\n        var isDone = false;\n        while (start + pos < end) {\n            var oneByte = this.data.readUInt8(start + pos);\n            bytesArr.push(oneByte & 0x7F);\n            pos++;\n            if ((oneByte & 0x80) === 0x00) {\n                isDone = true;\n                break;\n            }\n        }\n        if (!isDone) {\n            throw new Error(\"Failed to parse protobuf tag\");\n        }\n        var index = bytesArr.length - 1;\n        var val = 0;\n        while (index >= 0) {\n            val = (val << 7) + bytesArr[index];\n            index--;\n        }\n        return [val, start + pos];\n    };\n    ProtobufDecoder.prototype.parseFixed = function (offset, end, size) {\n        // TODO: detect signed types\n        var num;\n        var isFloat = true;\n        if (size == 4) {\n            try {\n                num = this.data.readFloatBE(offset);\n            }\n            catch (error) {\n                num = this.data.readUInt32BE(offset);\n                isFloat = true;\n            }\n        }\n        else if (size == 8) {\n            try {\n                num = this.data.readDoubleBE(offset);\n            }\n            catch (error) {\n                num = this.data.readBigUInt64BE(offset);\n                isFloat = true;\n            }\n        }\n        offset += size;\n        return [offset, num, isFloat];\n    };\n    return ProtobufDecoder;\n}());\nexports.default = ProtobufDecoder;\n"]},"metadata":{},"sourceType":"script"}
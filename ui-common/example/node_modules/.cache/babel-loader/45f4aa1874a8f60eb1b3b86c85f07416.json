{"ast":null,"code":"'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n  if (typeof Array.isArray === 'function') {\n    return Array.isArray(arr);\n  }\n\n  return toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n  if (!obj || toStr.call(obj) !== '[object Object]') {\n    return false;\n  }\n\n  var hasOwnConstructor = hasOwn.call(obj, 'constructor');\n  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf'); // Not own constructor property must be Object\n\n  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n    return false;\n  } // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n\n\n  var key;\n\n  for (key in obj) {\n    /**/\n  }\n\n  return typeof key === 'undefined' || hasOwn.call(obj, key);\n}; // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\n\n\nvar setProperty = function setProperty(target, options) {\n  if (defineProperty && options.name === '__proto__') {\n    defineProperty(target, options.name, {\n      enumerable: true,\n      configurable: true,\n      value: options.newValue,\n      writable: true\n    });\n  } else {\n    target[options.name] = options.newValue;\n  }\n}; // Return undefined instead of __proto__ if '__proto__' is not an own property\n\n\nvar getProperty = function getProperty(obj, name) {\n  if (name === '__proto__') {\n    if (!hasOwn.call(obj, name)) {\n      return void 0;\n    } else if (gOPD) {\n      // In early versions of node, obj['__proto__'] is buggy when obj has\n      // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n      return gOPD(obj, name).value;\n    }\n  }\n\n  return obj[name];\n};\n\nmodule.exports = function extend() {\n  var options, name, src, copy, copyIsArray, clone;\n  var target = arguments[0];\n  var i = 1;\n  var length = arguments.length;\n  var deep = false; // Handle a deep copy situation\n\n  if (typeof target === 'boolean') {\n    deep = target;\n    target = arguments[1] || {}; // skip the boolean and the target\n\n    i = 2;\n  }\n\n  if (target == null || typeof target !== 'object' && typeof target !== 'function') {\n    target = {};\n  }\n\n  for (; i < length; ++i) {\n    options = arguments[i]; // Only deal with non-null/undefined values\n\n    if (options != null) {\n      // Extend the base object\n      for (name in options) {\n        src = getProperty(target, name);\n        copy = getProperty(options, name); // Prevent never-ending loop\n\n        if (target !== copy) {\n          // Recurse if we're merging plain objects or arrays\n          if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && isArray(src) ? src : [];\n            } else {\n              clone = src && isPlainObject(src) ? src : {};\n            } // Never move original objects, clone them\n\n\n            setProperty(target, {\n              name: name,\n              newValue: extend(deep, clone, copy)\n            }); // Don't bring in undefined values\n          } else if (typeof copy !== 'undefined') {\n            setProperty(target, {\n              name: name,\n              newValue: copy\n            });\n          }\n        }\n      }\n    }\n  } // Return the modified object\n\n\n  return target;\n};","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/extend/index.js"],"names":["hasOwn","Object","prototype","hasOwnProperty","toStr","toString","defineProperty","gOPD","getOwnPropertyDescriptor","isArray","arr","Array","call","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","constructor","key","setProperty","target","options","name","enumerable","configurable","value","newValue","writable","getProperty","module","exports","extend","src","copy","copyIsArray","clone","arguments","i","length","deep"],"mappings":"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","sourcesContent":["'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n"]},"metadata":{},"sourceType":"script"}
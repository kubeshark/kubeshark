{"ast":null,"code":"'use strict';\n\nmodule.exports = xquery;\nxquery.displayName = 'xquery';\nxquery.aliases = [];\n\nfunction xquery(Prism) {\n  ;\n\n  (function (Prism) {\n    Prism.languages.xquery = Prism.languages.extend('markup', {\n      'xquery-comment': {\n        pattern: /\\(:[\\s\\S]*?:\\)/,\n        greedy: true,\n        alias: 'comment'\n      },\n      string: {\n        pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n        greedy: true\n      },\n      extension: {\n        pattern: /\\(#.+?#\\)/,\n        alias: 'symbol'\n      },\n      variable: /\\$[-\\w:]+/,\n      axis: {\n        pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      'keyword-operator': {\n        pattern: /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      keyword: {\n        pattern: /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      function: /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n      'xquery-element': {\n        pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'tag'\n      },\n      'xquery-attribute': {\n        pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'attr-name'\n      },\n      builtin: {\n        pattern: /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      number: /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n      operator: [/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/, {\n        pattern: /(\\s)-(?=\\s)/,\n        lookbehind: true\n      }],\n      punctuation: /[[\\](){},;:/]/\n    });\n    Prism.languages.xquery.tag.pattern = /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/;\n    Prism.languages.xquery['tag'].inside['attr-value'].pattern = /=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/;\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^=\"|\"$/;\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n      // Allow for two levels of nesting\n      pattern: /\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}/,\n      inside: Prism.languages.xquery,\n      alias: 'language-xquery'\n    }; // The following will handle plain text inside tags\n\n    var stringifyToken = function (token) {\n      if (typeof token === 'string') {\n        return token;\n      }\n\n      if (typeof token.content === 'string') {\n        return token.content;\n      }\n\n      return token.content.map(stringifyToken).join('');\n    };\n\n    var walkTokens = function (tokens) {\n      var openedTags = [];\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        var notTagNorBrace = false;\n\n        if (typeof token !== 'string') {\n          if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n                // Pop matching opening tag\n                openedTags.pop();\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {// Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                });\n              }\n            }\n          } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{' && ( // Ignore `{{`\n          !tokens[i + 1] || tokens[i + 1].type !== 'punctuation' || tokens[i + 1].content !== '{') && (!tokens[i - 1] || tokens[i - 1].type !== 'plain-text' || tokens[i - 1].content !== '{')) {\n            // Here we might have entered an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces++;\n          } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n            // Here we might have left an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces--;\n          } else if (token.type !== 'comment') {\n            notTagNorBrace = true;\n          }\n        }\n\n        if (notTagNorBrace || typeof token === 'string') {\n          if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n            // Here we are inside a tag, and not inside an XQuery expression.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token); // And merge text with adjacent text\n\n            if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n              plainText += stringifyToken(tokens[i + 1]);\n              tokens.splice(i + 1, 1);\n            }\n\n            if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText;\n              tokens.splice(i - 1, 1);\n              i--;\n            }\n\n            if (/^\\s+$/.test(plainText)) {\n              tokens[i] = plainText;\n            } else {\n              tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n            }\n          }\n        }\n\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content);\n        }\n      }\n    };\n\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'xquery') {\n        return;\n      }\n\n      walkTokens(env.tokens);\n    });\n  })(Prism);\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/refractor/lang/xquery.js"],"names":["module","exports","xquery","displayName","aliases","Prism","languages","extend","pattern","greedy","alias","string","extension","variable","axis","lookbehind","keyword","function","builtin","number","operator","punctuation","tag","inside","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","test","Token","hooks","add","env","language"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = xquery\nxquery.displayName = 'xquery'\nxquery.aliases = []\nfunction xquery(Prism) {\n  ;(function (Prism) {\n    Prism.languages.xquery = Prism.languages.extend('markup', {\n      'xquery-comment': {\n        pattern: /\\(:[\\s\\S]*?:\\)/,\n        greedy: true,\n        alias: 'comment'\n      },\n      string: {\n        pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n        greedy: true\n      },\n      extension: {\n        pattern: /\\(#.+?#\\)/,\n        alias: 'symbol'\n      },\n      variable: /\\$[-\\w:]+/,\n      axis: {\n        pattern:\n          /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      'keyword-operator': {\n        pattern:\n          /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      keyword: {\n        pattern:\n          /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      function: /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n      'xquery-element': {\n        pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'tag'\n      },\n      'xquery-attribute': {\n        pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'attr-name'\n      },\n      builtin: {\n        pattern:\n          /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      number: /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n      operator: [\n        /[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/,\n        {\n          pattern: /(\\s)-(?=\\s)/,\n          lookbehind: true\n        }\n      ],\n      punctuation: /[[\\](){},;:/]/\n    })\n    Prism.languages.xquery.tag.pattern =\n      /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/\n    Prism.languages.xquery['tag'].inside['attr-value'].pattern =\n      /=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] =\n      /^=\"|\"$/\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n      // Allow for two levels of nesting\n      pattern: /\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}/,\n      inside: Prism.languages.xquery,\n      alias: 'language-xquery'\n    } // The following will handle plain text inside tags\n    var stringifyToken = function (token) {\n      if (typeof token === 'string') {\n        return token\n      }\n      if (typeof token.content === 'string') {\n        return token.content\n      }\n      return token.content.map(stringifyToken).join('')\n    }\n    var walkTokens = function (tokens) {\n      var openedTags = []\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n        var notTagNorBrace = false\n        if (typeof token !== 'string') {\n          if (\n            token.type === 'tag' &&\n            token.content[0] &&\n            token.content[0].type === 'tag'\n          ) {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (\n                openedTags.length > 0 &&\n                openedTags[openedTags.length - 1].tagName ===\n                  stringifyToken(token.content[0].content[1])\n              ) {\n                // Pop matching opening tag\n                openedTags.pop()\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {\n                // Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                })\n              }\n            }\n          } else if (\n            openedTags.length > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '{' && // Ignore `{{`\n            (!tokens[i + 1] ||\n              tokens[i + 1].type !== 'punctuation' ||\n              tokens[i + 1].content !== '{') &&\n            (!tokens[i - 1] ||\n              tokens[i - 1].type !== 'plain-text' ||\n              tokens[i - 1].content !== '{')\n          ) {\n            // Here we might have entered an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces++\n          } else if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '}'\n          ) {\n            // Here we might have left an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces--\n          } else if (token.type !== 'comment') {\n            notTagNorBrace = true\n          }\n        }\n        if (notTagNorBrace || typeof token === 'string') {\n          if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces === 0\n          ) {\n            // Here we are inside a tag, and not inside an XQuery expression.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token) // And merge text with adjacent text\n            if (\n              i < tokens.length - 1 &&\n              (typeof tokens[i + 1] === 'string' ||\n                tokens[i + 1].type === 'plain-text')\n            ) {\n              plainText += stringifyToken(tokens[i + 1])\n              tokens.splice(i + 1, 1)\n            }\n            if (\n              i > 0 &&\n              (typeof tokens[i - 1] === 'string' ||\n                tokens[i - 1].type === 'plain-text')\n            ) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText\n              tokens.splice(i - 1, 1)\n              i--\n            }\n            if (/^\\s+$/.test(plainText)) {\n              tokens[i] = plainText\n            } else {\n              tokens[i] = new Prism.Token(\n                'plain-text',\n                plainText,\n                null,\n                plainText\n              )\n            }\n          }\n        }\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content)\n        }\n      }\n    }\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'xquery') {\n        return\n      }\n      walkTokens(env.tokens)\n    })\n  })(Prism)\n}\n"]},"metadata":{},"sourceType":"script"}
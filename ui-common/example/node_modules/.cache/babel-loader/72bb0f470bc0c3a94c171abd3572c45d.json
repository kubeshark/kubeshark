{"ast":null,"code":"var rx_escapable = /[\\\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\nvar gap,\n    indent,\n    meta = {\n  // table of character substitutions\n  '\\b': '\\\\b',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\f': '\\\\f',\n  '\\r': '\\\\r',\n  '\"': '\\\\\"',\n  '\\\\': '\\\\\\\\'\n},\n    rep;\n\nfunction quote(string) {\n  // If the string contains no control characters, no quote characters, and no\n  // backslash characters, then we can safely slap some quotes around it.\n  // Otherwise we must also replace the offending characters with safe escape\n  // sequences.\n  rx_escapable.lastIndex = 0;\n  return rx_escapable.test(string) ? '\"' + string.replace(rx_escapable, function (a) {\n    var c = meta[a];\n    return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n  }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder, limit) {\n  // Produce a string from holder[key].\n  var i,\n      // The loop counter.\n  k,\n      // The member key.\n  v,\n      // The member value.\n  length,\n      mind = gap,\n      partial,\n      value = holder[key]; // If the value has a toJSON method, call it to obtain a replacement value.\n\n  if (value && typeof value === 'object' && typeof value.toJSON === 'function') {\n    value = value.toJSON(key);\n  } // If we were called with a replacer function, then call the replacer to\n  // obtain a replacement value.\n\n\n  if (typeof rep === 'function') {\n    value = rep.call(holder, key, value);\n  } // What happens next depends on the value's type.\n\n\n  switch (typeof value) {\n    case 'string':\n      return quote(value);\n\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null';\n\n    case 'boolean':\n    case 'null':\n      // If the value is a boolean or null, convert it to a string. Note:\n      // typeof null does not produce 'null'. The case is included here in\n      // the remote chance that this gets fixed someday.\n      return String(value);\n    // If the type is 'object', we might be dealing with an object or an array or\n    // null.\n\n    case 'object':\n      // Due to a specification blunder in ECMAScript, typeof null is 'object',\n      // so watch out for that case.\n      if (!value) {\n        return 'null';\n      } // Make an array to hold the partial results of stringifying this object value.\n\n\n      gap += indent;\n      partial = []; // Is the value an array?\n\n      if (Object.prototype.toString.apply(value) === '[object Array]') {\n        // The value is an array. Stringify every element. Use null as a placeholder\n        // for non-JSON values.\n        length = value.length;\n\n        for (i = 0; i < length; i += 1) {\n          partial[i] = str(i, value, limit) || 'null';\n        } // Join all of the elements together, separated with commas, and wrap them in\n        // brackets.\n\n\n        v = partial.length === 0 ? '[]' : gap ? gap.length + partial.join(', ').length + 4 > limit ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' : '[ ' + partial.join(', ') + ' ]' : '[' + partial.join(',') + ']';\n        gap = mind;\n        return v;\n      } // If the replacer is an array, use it to select the members to be stringified.\n\n\n      if (rep && typeof rep === 'object') {\n        length = rep.length;\n\n        for (i = 0; i < length; i += 1) {\n          if (typeof rep[i] === 'string') {\n            k = rep[i];\n            v = str(k, value, limit);\n\n            if (v) {\n              partial.push(quote(k) + (gap ? ': ' : ':') + v);\n            }\n          }\n        }\n      } else {\n        // Otherwise, iterate through all of the keys in the object.\n        for (k in value) {\n          if (Object.prototype.hasOwnProperty.call(value, k)) {\n            v = str(k, value, limit);\n\n            if (v) {\n              partial.push(quote(k) + (gap ? ': ' : ':') + v);\n            }\n          }\n        }\n      } // Join all of the member texts together, separated with commas,\n      // and wrap them in braces.\n\n\n      v = partial.length === 0 ? '{}' : gap ? gap.length + partial.join(', ').length + 4 > limit ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' : '{ ' + partial.join(', ') + ' }' : '{' + partial.join(',') + '}';\n      gap = mind;\n      return v;\n  }\n}\n\nfunction beautify(value, replacer, space, limit) {\n  // The stringify method takes a value and an optional replacer, and an optional\n  // space parameter, and returns a JSON text. The replacer can be a function\n  // that can replace values, or an array of strings that will select the keys.\n  // A default replacer method can be provided. Use of the space parameter can\n  // produce text that is more easily readable.\n  var i;\n  gap = '';\n  indent = '';\n  if (!limit) limit = 0;\n  if (typeof limit !== \"number\") throw new Error(\"beaufifier: limit must be a number\"); // If the space parameter is a number, make an indent string containing that\n  // many spaces.\n\n  if (typeof space === 'number') {\n    for (i = 0; i < space; i += 1) {\n      indent += ' ';\n    } // If the space parameter is a string, it will be used as the indent string.\n\n  } else if (typeof space === 'string') {\n    indent = space;\n  } // If there is a replacer, it must be a function or an array.\n  // Otherwise, throw an error.\n\n\n  rep = replacer;\n\n  if (replacer && typeof replacer !== 'function' && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n    throw new Error('beautifier: wrong replacer parameter');\n  } // Make a fake root object containing our value under the key of ''.\n  // Return the result of stringifying the value.\n\n\n  return str('', {\n    '': value\n  }, limit);\n}\n\nmodule.exports = beautify;","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/json-beautify/index.js"],"names":["rx_escapable","gap","indent","meta","rep","quote","string","lastIndex","test","replace","a","c","charCodeAt","toString","slice","str","key","holder","limit","i","k","v","length","mind","partial","value","toJSON","call","isFinite","String","Object","prototype","apply","join","push","hasOwnProperty","beautify","replacer","space","Error","module","exports"],"mappings":"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","sourcesContent":["\nvar rx_escapable = /[\\\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\nvar gap,\n    indent,\n    meta = { // table of character substitutions\n      '\\b': '\\\\b',\n      '\\t': '\\\\t',\n      '\\n': '\\\\n',\n      '\\f': '\\\\f',\n      '\\r': '\\\\r',\n      '\"': '\\\\\"',\n      '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n    rx_escapable.lastIndex = 0;\n    return rx_escapable.test(string)\n        ? '\"' + string.replace(rx_escapable, function (a) {\n            var c = meta[a];\n            return typeof c === 'string'\n                ? c\n                : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        }) + '\"'\n        : '\"' + string + '\"';\n}\n\n\nfunction str(key, holder, limit) {\n\n// Produce a string from holder[key].\n\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n\n// What happens next depends on the value's type.\n\n    switch (typeof value) {\n    case 'string':\n        return quote(value);\n\n    case 'number':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n        return isFinite(value)\n            ? String(value)\n            : 'null';\n\n    case 'boolean':\n    case 'null':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce 'null'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n        return String(value);\n\n// If the type is 'object', we might be dealing with an object or an array or\n// null.\n\n    case 'object':\n\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\n// so watch out for that case.\n\n        if (!value) {\n            return 'null';\n        }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n        gap += indent;\n        partial = [];\n\n// Is the value an array?\n\n        if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n            length = value.length;\n            for (i = 0; i < length; i += 1) {\n                partial[i] = str(i, value, limit) || 'null';\n            }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n            v = partial.length === 0\n                ? '[]'\n                : gap\n                    ? (\n                      gap.length + partial.join(', ').length + 4 > limit ?\n                      '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                      '[ ' + partial.join(', ') + ' ]'\n                    )\n                    : '[' + partial.join(',') + ']';\n            gap = mind;\n            return v;\n        }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n        if (rep && typeof rep === 'object') {\n            length = rep.length;\n            for (i = 0; i < length; i += 1) {\n                if (typeof rep[i] === 'string') {\n                    k = rep[i];\n                    v = str(k, value, limit);\n                    if (v) {\n                        partial.push(quote(k) + (\n                            gap\n                                ? ': '\n                                : ':'\n                        ) + v);\n                    }\n                }\n            }\n        } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = str(k, value, limit);\n                    if (v) {\n                        partial.push(quote(k) + (\n                            gap\n                                ? ': '\n                                : ':'\n                        ) + v);\n                    }\n                }\n            }\n        }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n        v = partial.length === 0\n            ? '{}'\n            : gap\n                ? (\n                  gap.length + partial.join(', ').length + 4 > limit ?\n                  '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n                  '{ ' + partial.join(', ') + ' }'\n                )\n                : '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\n\nfunction beautify (value, replacer, space, limit) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n  var i;\n  gap = '';\n  indent = '';\n\n  if (!limit) limit = 0;\n\n  if (typeof limit !== \"number\")\n    throw new Error(\"beaufifier: limit must be a number\");\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n  if (typeof space === 'number') {\n      for (i = 0; i < space; i += 1) {\n          indent += ' ';\n      }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n  } else if (typeof space === 'string') {\n      indent = space;\n  }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n  rep = replacer;\n  if (replacer && typeof replacer !== 'function' &&\n          (typeof replacer !== 'object' ||\n          typeof replacer.length !== 'number')) {\n      throw new Error('beautifier: wrong replacer parameter');\n  }\n\n// Make a fake root object containing our value under the key of ''.\n// Return the result of stringifying the value.\n\n  return str('', {'': value}, limit);\n}\n\nmodule.exports = beautify;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\nvar search = /[#.]/g;\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @param selector A simple CSS selector.\n *   Can contain a tag-name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param [defaultTagName='div'] Tag name to use if `selector` does not specify one.\n */\n\nexport const parseSelector =\n/**\n * @type {(\n *  <Selector extends string, DefaultTagName extends string = 'div'>(selector?: Selector, defaultTagName?: DefaultTagName) => Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}\n * )}\n */\n\n/**\n * @param {string} [selector]\n * @param {string} [defaultTagName='div']\n * @returns {Element}\n */\nfunction (selector) {\n  let defaultTagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'div';\n  var value = selector || '';\n  /** @type {Properties} */\n\n  var props = {};\n  var start = 0;\n  /** @type {string} */\n\n  var subvalue;\n  /** @type {string} */\n\n  var previous;\n  /** @type {RegExpMatchArray} */\n\n  var match;\n\n  while (start < value.length) {\n    search.lastIndex = start;\n    match = search.exec(value);\n    subvalue = value.slice(start, match ? match.index : value.length);\n\n    if (subvalue) {\n      if (!previous) {\n        defaultTagName = subvalue;\n      } else if (previous === '#') {\n        props.id = subvalue;\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue);\n      } else {\n        props.className = [subvalue];\n      }\n\n      start += subvalue.length;\n    }\n\n    if (match) {\n      previous = match[0];\n      start++;\n    }\n  }\n\n  return {\n    type: 'element',\n    tagName: defaultTagName,\n    properties: props,\n    children: []\n  };\n};","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/hast-util-from-parse5/node_modules/hast-util-parse-selector/index.js"],"names":["search","parseSelector","selector","defaultTagName","value","props","start","subvalue","previous","match","length","lastIndex","exec","slice","index","id","Array","isArray","className","push","type","tagName","properties","children"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,IAAIA,MAAM,GAAG,OAAb;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAa;AACxB;AACF;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACI,UAAUC,QAAV,EAA4C;AAAA,MAAxBC,cAAwB,uEAAP,KAAO;AAC1C,MAAIC,KAAK,GAAGF,QAAQ,IAAI,EAAxB;AACA;;AACA,MAAIG,KAAK,GAAG,EAAZ;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA;;AACA,MAAIC,QAAJ;AACA;;AACA,MAAIC,QAAJ;AACA;;AACA,MAAIC,KAAJ;;AAEA,SAAOH,KAAK,GAAGF,KAAK,CAACM,MAArB,EAA6B;AAC3BV,IAAAA,MAAM,CAACW,SAAP,GAAmBL,KAAnB;AACAG,IAAAA,KAAK,GAAGT,MAAM,CAACY,IAAP,CAAYR,KAAZ,CAAR;AACAG,IAAAA,QAAQ,GAAGH,KAAK,CAACS,KAAN,CAAYP,KAAZ,EAAmBG,KAAK,GAAGA,KAAK,CAACK,KAAT,GAAiBV,KAAK,CAACM,MAA/C,CAAX;;AAEA,QAAIH,QAAJ,EAAc;AACZ,UAAI,CAACC,QAAL,EAAe;AACbL,QAAAA,cAAc,GAAGI,QAAjB;AACD,OAFD,MAEO,IAAIC,QAAQ,KAAK,GAAjB,EAAsB;AAC3BH,QAAAA,KAAK,CAACU,EAAN,GAAWR,QAAX;AACD,OAFM,MAEA,IAAIS,KAAK,CAACC,OAAN,CAAcZ,KAAK,CAACa,SAApB,CAAJ,EAAoC;AACzCb,QAAAA,KAAK,CAACa,SAAN,CAAgBC,IAAhB,CAAqBZ,QAArB;AACD,OAFM,MAEA;AACLF,QAAAA,KAAK,CAACa,SAAN,GAAkB,CAACX,QAAD,CAAlB;AACD;;AAEDD,MAAAA,KAAK,IAAIC,QAAQ,CAACG,MAAlB;AACD;;AAED,QAAID,KAAJ,EAAW;AACTD,MAAAA,QAAQ,GAAGC,KAAK,CAAC,CAAD,CAAhB;AACAH,MAAAA,KAAK;AACN;AACF;;AAED,SAAO;AACLc,IAAAA,IAAI,EAAE,SADD;AAELC,IAAAA,OAAO,EAAElB,cAFJ;AAGLmB,IAAAA,UAAU,EAAEjB,KAHP;AAILkB,IAAAA,QAAQ,EAAE;AAJL,GAAP;AAMD,CAvDE","sourcesContent":["/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\n\nvar search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @param selector A simple CSS selector.\n *   Can contain a tag-name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param [defaultTagName='div'] Tag name to use if `selector` does not specify one.\n */\nexport const parseSelector =\n  /**\n   * @type {(\n   *  <Selector extends string, DefaultTagName extends string = 'div'>(selector?: Selector, defaultTagName?: DefaultTagName) => Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}\n   * )}\n   */\n  (\n    /**\n     * @param {string} [selector]\n     * @param {string} [defaultTagName='div']\n     * @returns {Element}\n     */\n    function (selector, defaultTagName = 'div') {\n      var value = selector || ''\n      /** @type {Properties} */\n      var props = {}\n      var start = 0\n      /** @type {string} */\n      var subvalue\n      /** @type {string} */\n      var previous\n      /** @type {RegExpMatchArray} */\n      var match\n\n      while (start < value.length) {\n        search.lastIndex = start\n        match = search.exec(value)\n        subvalue = value.slice(start, match ? match.index : value.length)\n\n        if (subvalue) {\n          if (!previous) {\n            defaultTagName = subvalue\n          } else if (previous === '#') {\n            props.id = subvalue\n          } else if (Array.isArray(props.className)) {\n            props.className.push(subvalue)\n          } else {\n            props.className = [subvalue]\n          }\n\n          start += subvalue.length\n        }\n\n        if (match) {\n          previous = match[0]\n          start++\n        }\n      }\n\n      return {\n        type: 'element',\n        tagName: defaultTagName,\n        properties: props,\n        children: []\n      }\n    }\n  )\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"'use strict';\n\nconst Mixin = require('../../utils/mixin');\n\nconst Tokenizer = require('../../tokenizer');\n\nconst PositionTrackingPreprocessorMixin = require('../position-tracking/preprocessor-mixin');\n\nclass LocationInfoTokenizerMixin extends Mixin {\n  constructor(tokenizer) {\n    super(tokenizer);\n    this.tokenizer = tokenizer;\n    this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);\n    this.currentAttrLocation = null;\n    this.ctLoc = null;\n  }\n\n  _getCurrentLocation() {\n    return {\n      startLine: this.posTracker.line,\n      startCol: this.posTracker.col,\n      startOffset: this.posTracker.offset,\n      endLine: -1,\n      endCol: -1,\n      endOffset: -1\n    };\n  }\n\n  _attachCurrentAttrLocationInfo() {\n    this.currentAttrLocation.endLine = this.posTracker.line;\n    this.currentAttrLocation.endCol = this.posTracker.col;\n    this.currentAttrLocation.endOffset = this.posTracker.offset;\n    const currentToken = this.tokenizer.currentToken;\n    const currentAttr = this.tokenizer.currentAttr;\n\n    if (!currentToken.location.attrs) {\n      currentToken.location.attrs = Object.create(null);\n    }\n\n    currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;\n  }\n\n  _getOverriddenMethods(mxn, orig) {\n    const methods = {\n      _createStartTagToken() {\n        orig._createStartTagToken.call(this);\n\n        this.currentToken.location = mxn.ctLoc;\n      },\n\n      _createEndTagToken() {\n        orig._createEndTagToken.call(this);\n\n        this.currentToken.location = mxn.ctLoc;\n      },\n\n      _createCommentToken() {\n        orig._createCommentToken.call(this);\n\n        this.currentToken.location = mxn.ctLoc;\n      },\n\n      _createDoctypeToken(initialName) {\n        orig._createDoctypeToken.call(this, initialName);\n\n        this.currentToken.location = mxn.ctLoc;\n      },\n\n      _createCharacterToken(type, ch) {\n        orig._createCharacterToken.call(this, type, ch);\n\n        this.currentCharacterToken.location = mxn.ctLoc;\n      },\n\n      _createEOFToken() {\n        orig._createEOFToken.call(this);\n\n        this.currentToken.location = mxn._getCurrentLocation();\n      },\n\n      _createAttr(attrNameFirstCh) {\n        orig._createAttr.call(this, attrNameFirstCh);\n\n        mxn.currentAttrLocation = mxn._getCurrentLocation();\n      },\n\n      _leaveAttrName(toState) {\n        orig._leaveAttrName.call(this, toState);\n\n        mxn._attachCurrentAttrLocationInfo();\n      },\n\n      _leaveAttrValue(toState) {\n        orig._leaveAttrValue.call(this, toState);\n\n        mxn._attachCurrentAttrLocationInfo();\n      },\n\n      _emitCurrentToken() {\n        const ctLoc = this.currentToken.location; //NOTE: if we have pending character token make it's end location equal to the\n        //current token's start location.\n\n        if (this.currentCharacterToken) {\n          this.currentCharacterToken.location.endLine = ctLoc.startLine;\n          this.currentCharacterToken.location.endCol = ctLoc.startCol;\n          this.currentCharacterToken.location.endOffset = ctLoc.startOffset;\n        }\n\n        if (this.currentToken.type === Tokenizer.EOF_TOKEN) {\n          ctLoc.endLine = ctLoc.startLine;\n          ctLoc.endCol = ctLoc.startCol;\n          ctLoc.endOffset = ctLoc.startOffset;\n        } else {\n          ctLoc.endLine = mxn.posTracker.line;\n          ctLoc.endCol = mxn.posTracker.col + 1;\n          ctLoc.endOffset = mxn.posTracker.offset + 1;\n        }\n\n        orig._emitCurrentToken.call(this);\n      },\n\n      _emitCurrentCharacterToken() {\n        const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location; //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\n        //then set it's location at the current preprocessor position.\n        //We don't need to increment preprocessor position, since character token\n        //emission is always forced by the start of the next character token here.\n        //So, we already have advanced position.\n\n        if (ctLoc && ctLoc.endOffset === -1) {\n          ctLoc.endLine = mxn.posTracker.line;\n          ctLoc.endCol = mxn.posTracker.col;\n          ctLoc.endOffset = mxn.posTracker.offset;\n        }\n\n        orig._emitCurrentCharacterToken.call(this);\n      }\n\n    }; //NOTE: patch initial states for each mode to obtain token start position\n\n    Object.keys(Tokenizer.MODE).forEach(modeName => {\n      const state = Tokenizer.MODE[modeName];\n\n      methods[state] = function (cp) {\n        mxn.ctLoc = mxn._getCurrentLocation();\n        orig[state].call(this, cp);\n      };\n    });\n    return methods;\n  }\n\n}\n\nmodule.exports = LocationInfoTokenizerMixin;","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js"],"names":["Mixin","require","Tokenizer","PositionTrackingPreprocessorMixin","LocationInfoTokenizerMixin","constructor","tokenizer","posTracker","install","preprocessor","currentAttrLocation","ctLoc","_getCurrentLocation","startLine","line","startCol","col","startOffset","offset","endLine","endCol","endOffset","_attachCurrentAttrLocationInfo","currentToken","currentAttr","location","attrs","Object","create","name","_getOverriddenMethods","mxn","orig","methods","_createStartTagToken","call","_createEndTagToken","_createCommentToken","_createDoctypeToken","initialName","_createCharacterToken","type","ch","currentCharacterToken","_createEOFToken","_createAttr","attrNameFirstCh","_leaveAttrName","toState","_leaveAttrValue","_emitCurrentToken","EOF_TOKEN","_emitCurrentCharacterToken","keys","MODE","forEach","modeName","state","cp","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Mixin = require('../../utils/mixin');\nconst Tokenizer = require('../../tokenizer');\nconst PositionTrackingPreprocessorMixin = require('../position-tracking/preprocessor-mixin');\n\nclass LocationInfoTokenizerMixin extends Mixin {\n    constructor(tokenizer) {\n        super(tokenizer);\n\n        this.tokenizer = tokenizer;\n        this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);\n        this.currentAttrLocation = null;\n        this.ctLoc = null;\n    }\n\n    _getCurrentLocation() {\n        return {\n            startLine: this.posTracker.line,\n            startCol: this.posTracker.col,\n            startOffset: this.posTracker.offset,\n            endLine: -1,\n            endCol: -1,\n            endOffset: -1\n        };\n    }\n\n    _attachCurrentAttrLocationInfo() {\n        this.currentAttrLocation.endLine = this.posTracker.line;\n        this.currentAttrLocation.endCol = this.posTracker.col;\n        this.currentAttrLocation.endOffset = this.posTracker.offset;\n\n        const currentToken = this.tokenizer.currentToken;\n        const currentAttr = this.tokenizer.currentAttr;\n\n        if (!currentToken.location.attrs) {\n            currentToken.location.attrs = Object.create(null);\n        }\n\n        currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        const methods = {\n            _createStartTagToken() {\n                orig._createStartTagToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createEndTagToken() {\n                orig._createEndTagToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createCommentToken() {\n                orig._createCommentToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createDoctypeToken(initialName) {\n                orig._createDoctypeToken.call(this, initialName);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createCharacterToken(type, ch) {\n                orig._createCharacterToken.call(this, type, ch);\n                this.currentCharacterToken.location = mxn.ctLoc;\n            },\n\n            _createEOFToken() {\n                orig._createEOFToken.call(this);\n                this.currentToken.location = mxn._getCurrentLocation();\n            },\n\n            _createAttr(attrNameFirstCh) {\n                orig._createAttr.call(this, attrNameFirstCh);\n                mxn.currentAttrLocation = mxn._getCurrentLocation();\n            },\n\n            _leaveAttrName(toState) {\n                orig._leaveAttrName.call(this, toState);\n                mxn._attachCurrentAttrLocationInfo();\n            },\n\n            _leaveAttrValue(toState) {\n                orig._leaveAttrValue.call(this, toState);\n                mxn._attachCurrentAttrLocationInfo();\n            },\n\n            _emitCurrentToken() {\n                const ctLoc = this.currentToken.location;\n\n                //NOTE: if we have pending character token make it's end location equal to the\n                //current token's start location.\n                if (this.currentCharacterToken) {\n                    this.currentCharacterToken.location.endLine = ctLoc.startLine;\n                    this.currentCharacterToken.location.endCol = ctLoc.startCol;\n                    this.currentCharacterToken.location.endOffset = ctLoc.startOffset;\n                }\n\n                if (this.currentToken.type === Tokenizer.EOF_TOKEN) {\n                    ctLoc.endLine = ctLoc.startLine;\n                    ctLoc.endCol = ctLoc.startCol;\n                    ctLoc.endOffset = ctLoc.startOffset;\n                } else {\n                    ctLoc.endLine = mxn.posTracker.line;\n                    ctLoc.endCol = mxn.posTracker.col + 1;\n                    ctLoc.endOffset = mxn.posTracker.offset + 1;\n                }\n\n                orig._emitCurrentToken.call(this);\n            },\n\n            _emitCurrentCharacterToken() {\n                const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;\n\n                //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\n                //then set it's location at the current preprocessor position.\n                //We don't need to increment preprocessor position, since character token\n                //emission is always forced by the start of the next character token here.\n                //So, we already have advanced position.\n                if (ctLoc && ctLoc.endOffset === -1) {\n                    ctLoc.endLine = mxn.posTracker.line;\n                    ctLoc.endCol = mxn.posTracker.col;\n                    ctLoc.endOffset = mxn.posTracker.offset;\n                }\n\n                orig._emitCurrentCharacterToken.call(this);\n            }\n        };\n\n        //NOTE: patch initial states for each mode to obtain token start position\n        Object.keys(Tokenizer.MODE).forEach(modeName => {\n            const state = Tokenizer.MODE[modeName];\n\n            methods[state] = function(cp) {\n                mxn.ctLoc = mxn._getCurrentLocation();\n                orig[state].call(this, cp);\n            };\n        });\n\n        return methods;\n    }\n}\n\nmodule.exports = LocationInfoTokenizerMixin;\n"]},"metadata":{},"sourceType":"script"}
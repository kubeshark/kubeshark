{"ast":null,"code":"/**\n * @typedef {import('hast').Text} Text\n * @typedef {import('highlight.js').HighlightResult} HighlightResult\n * @typedef {import('highlight.js').HLJSOptions} HighlightOptions\n * @typedef {import('highlight.js').LanguageFn} HighlightSyntax\n * @typedef {import('highlight.js').Emitter} HighlightEmitter\n *\n * @typedef {{type: 'element', tagName: 'span', properties: {className: Array<string>}, children: Array<Span|Text>}} Span\n * @typedef {{type: 'root', data: {language: string|null, relevance: number}, children: Array<Span|Text>}} Root\n *\n * @typedef {Object} ExtraOptions\n * @property {Array<string>} [subset]\n *   List of allowed languages, defaults to all registered languages.\n *\n * @typedef {Object} Options\n *   Configuration.\n * @property {string} [prefix='hljs-']\n *   Class prefix.\n *\n * @typedef {Options & ExtraOptions} AutoOptions\n */\nimport high from 'highlight.js/lib/core';\nimport { fault } from 'fault';\nconst own = {}.hasOwnProperty;\nconst defaultPrefix = 'hljs-';\n/**\n * Highlight `value` (code) as `language` (name).\n *\n * @param {string} language\n *   Programming language name.\n * @param {string} value\n *   Code to highlight.\n * @param {Options} [options={}]\n *   Configuration.\n * @returns {Root}\n *   A hast `Root` node.\n */\n\nfunction highlight(language, value) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let prefix = options.prefix;\n\n  if (typeof language !== 'string') {\n    throw fault('Expected `string` for name, got `%s`', language);\n  }\n\n  if (!high.getLanguage(language)) {\n    throw fault('Unknown language: `%s` is not registered', language);\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value);\n  }\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix;\n  }\n\n  high.configure({\n    __emitter: HastEmitter,\n    classPrefix: prefix\n  });\n  const result =\n  /** @type {HighlightResult & {_emitter: HastEmitter}} */\n  high.highlight(value, {\n    language,\n    ignoreIllegals: true\n  });\n  high.configure({}); // `highlight.js` seems to use this (currently) for broken grammars, so let’s\n  // keep it in there just to be sure.\n\n  /* c8 ignore next 3 */\n\n  if (result.errorRaised) {\n    throw result.errorRaised;\n  } // @ts-expect-error: `language` is always defined in `highlight`.\n\n\n  result._emitter.root.data.language = result.language;\n  result._emitter.root.data.relevance = result.relevance;\n  return result._emitter.root;\n}\n/**\n * Highlight `value` (code) and guess its programming language.\n *\n * @param {string} value\n *   Code to highlight.\n * @param {AutoOptions} [options={}]\n *   Configuration.\n * @returns {Root}\n *   A hast `Root` node.\n */\n\n\nfunction highlightAuto(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const subset = options.subset || high.listLanguages();\n  let prefix = options.prefix;\n  let index = -1;\n  /** @type {Root} */\n\n  let result = {\n    type: 'root',\n    data: {\n      language: null,\n      relevance: 0\n    },\n    children: []\n  };\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix;\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value);\n  }\n\n  while (++index < subset.length) {\n    const name = subset[index];\n    if (!high.getLanguage(name)) continue;\n    const current = highlight(name, value, options);\n    if (current.data.relevance > result.data.relevance) result = current;\n  }\n\n  return result;\n}\n/**\n * Register a language.\n *\n * @param {string} language\n *   Programming language name.\n * @param {HighlightSyntax} syntax\n *   `highlight.js` language syntax.\n * @returns {void}\n */\n\n\nfunction registerLanguage(language, syntax) {\n  high.registerLanguage(language, syntax);\n}\n/**\n * Register aliases for already registered languages.\n *\n * @param {string|Record<string, string|Array<string>>} language\n *   Programming language name or a map of `language`s to `alias`es or `list`s\n * @param {string|Array<string>} [alias]\n *   New aliases for the programming language.\n * @returns {void}\n */\n\n\nconst registerAlias =\n/**\n * @type {(\n *   ((language: string, alias: string|Array<string>) => void) &\n *   ((aliases: Record<string, string|Array<string>>) => void)\n * )}\n */\n\n/**\n * @param {string|Record<string, string|Array<string>>} language\n * @param {string|Array<string>} [alias]\n * @returns {void}\n */\nfunction (language, alias) {\n  if (typeof language === 'string') {\n    // @ts-expect-error: should be a string in this overload.\n    high.registerAliases(alias, {\n      languageName: language\n    });\n  } else {\n    /** @type {string} */\n    let key;\n\n    for (key in language) {\n      if (own.call(language, key)) {\n        high.registerAliases(language[key], {\n          languageName: key\n        });\n      }\n    }\n  }\n};\n/**\n * Check whether an `alias` or `language` is registered.\n *\n * @param {string} aliasOrLanguage\n *   Name of a registered language or alias.\n * @returns {boolean}\n *   Whether `aliasOrlanguage` is registered.\n */\n\n\nfunction registered(aliasOrLanguage) {\n  return Boolean(high.getLanguage(aliasOrLanguage));\n}\n/**\n * List registered languages.\n *\n * @returns {Array<string>}\n *   Names of registered language.\n */\n\n\nfunction listLanguages() {\n  return high.listLanguages();\n}\n/** @type {HighlightEmitter} */\n\n\nclass HastEmitter {\n  /**\n   * @param {HighlightOptions} options\n   */\n  constructor(options) {\n    /** @type {HighlightOptions} */\n    this.options = options;\n    /** @type {Root} */\n\n    this.root = {\n      type: 'root',\n      data: {\n        language: null,\n        relevance: 0\n      },\n      children: []\n    };\n    /** @type {[Root, ...Span[]]} */\n\n    this.stack = [this.root];\n  }\n  /**\n   * @param {string} value\n   */\n\n\n  addText(value) {\n    if (value === '') return;\n    const current = this.stack[this.stack.length - 1];\n    const tail = current.children[current.children.length - 1];\n\n    if (tail && tail.type === 'text') {\n      tail.value += value;\n    } else {\n      current.children.push({\n        type: 'text',\n        value\n      });\n    }\n  }\n  /**\n   * @param {string} value\n   * @param {string} name\n   */\n\n\n  addKeyword(value, name) {\n    this.openNode(name);\n    this.addText(value);\n    this.closeNode();\n  }\n  /**\n   * @param {HastEmitter} other\n   * @param {string} name\n   */\n\n\n  addSublanguage(other, name) {\n    const current = this.stack[this.stack.length - 1];\n    const results = other.root.children;\n\n    if (name) {\n      current.children.push({\n        type: 'element',\n        tagName: 'span',\n        properties: {\n          className: [name]\n        },\n        children: results\n      });\n    } else {\n      current.children.push(...results);\n    }\n  }\n  /**\n   * @param {string} name\n   */\n\n\n  openNode(name) {\n    const className = name.split('.').map(d => this.options.classPrefix + d);\n    const current = this.stack[this.stack.length - 1];\n    /** @type {Span} */\n\n    const child = {\n      type: 'element',\n      tagName: 'span',\n      properties: {\n        className\n      },\n      children: []\n    };\n    current.children.push(child);\n    this.stack.push(child);\n  }\n  /**\n   */\n\n\n  closeNode() {\n    this.stack.pop();\n  }\n  /**\n   */\n\n\n  closeAllNodes() {}\n  /**\n   */\n\n\n  finalize() {}\n  /**\n   */\n\n\n  toHTML() {\n    return '';\n  }\n\n}\n\nexport const lowlight = {\n  highlight,\n  highlightAuto,\n  registerLanguage,\n  registered,\n  listLanguages,\n  registerAlias\n};","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/lowlight/lib/core.js"],"names":["high","fault","own","hasOwnProperty","defaultPrefix","highlight","language","value","options","prefix","getLanguage","undefined","configure","__emitter","HastEmitter","classPrefix","result","ignoreIllegals","errorRaised","_emitter","root","data","relevance","highlightAuto","subset","listLanguages","index","type","children","length","name","current","registerLanguage","syntax","registerAlias","alias","registerAliases","languageName","key","call","registered","aliasOrLanguage","Boolean","constructor","stack","addText","tail","push","addKeyword","openNode","closeNode","addSublanguage","other","results","tagName","properties","className","split","map","d","child","pop","closeAllNodes","finalize","toHTML","lowlight"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('hast').Text} Text\n * @typedef {import('highlight.js').HighlightResult} HighlightResult\n * @typedef {import('highlight.js').HLJSOptions} HighlightOptions\n * @typedef {import('highlight.js').LanguageFn} HighlightSyntax\n * @typedef {import('highlight.js').Emitter} HighlightEmitter\n *\n * @typedef {{type: 'element', tagName: 'span', properties: {className: Array<string>}, children: Array<Span|Text>}} Span\n * @typedef {{type: 'root', data: {language: string|null, relevance: number}, children: Array<Span|Text>}} Root\n *\n * @typedef {Object} ExtraOptions\n * @property {Array<string>} [subset]\n *   List of allowed languages, defaults to all registered languages.\n *\n * @typedef {Object} Options\n *   Configuration.\n * @property {string} [prefix='hljs-']\n *   Class prefix.\n *\n * @typedef {Options & ExtraOptions} AutoOptions\n */\n\nimport high from 'highlight.js/lib/core'\nimport {fault} from 'fault'\n\nconst own = {}.hasOwnProperty\n\nconst defaultPrefix = 'hljs-'\n\n/**\n * Highlight `value` (code) as `language` (name).\n *\n * @param {string} language\n *   Programming language name.\n * @param {string} value\n *   Code to highlight.\n * @param {Options} [options={}]\n *   Configuration.\n * @returns {Root}\n *   A hast `Root` node.\n */\nfunction highlight(language, value, options = {}) {\n  let prefix = options.prefix\n\n  if (typeof language !== 'string') {\n    throw fault('Expected `string` for name, got `%s`', language)\n  }\n\n  if (!high.getLanguage(language)) {\n    throw fault('Unknown language: `%s` is not registered', language)\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value)\n  }\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix\n  }\n\n  high.configure({__emitter: HastEmitter, classPrefix: prefix})\n\n  const result = /** @type {HighlightResult & {_emitter: HastEmitter}} */ (\n    high.highlight(value, {language, ignoreIllegals: true})\n  )\n\n  high.configure({})\n\n  // `highlight.js` seems to use this (currently) for broken grammars, so let’s\n  // keep it in there just to be sure.\n  /* c8 ignore next 3 */\n  if (result.errorRaised) {\n    throw result.errorRaised\n  }\n\n  // @ts-expect-error: `language` is always defined in `highlight`.\n  result._emitter.root.data.language = result.language\n  result._emitter.root.data.relevance = result.relevance\n\n  return result._emitter.root\n}\n\n/**\n * Highlight `value` (code) and guess its programming language.\n *\n * @param {string} value\n *   Code to highlight.\n * @param {AutoOptions} [options={}]\n *   Configuration.\n * @returns {Root}\n *   A hast `Root` node.\n */\nfunction highlightAuto(value, options = {}) {\n  const subset = options.subset || high.listLanguages()\n  let prefix = options.prefix\n  let index = -1\n  /** @type {Root} */\n  let result = {\n    type: 'root',\n    data: {language: null, relevance: 0},\n    children: []\n  }\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value)\n  }\n\n  while (++index < subset.length) {\n    const name = subset[index]\n\n    if (!high.getLanguage(name)) continue\n\n    const current = highlight(name, value, options)\n\n    if (current.data.relevance > result.data.relevance) result = current\n  }\n\n  return result\n}\n\n/**\n * Register a language.\n *\n * @param {string} language\n *   Programming language name.\n * @param {HighlightSyntax} syntax\n *   `highlight.js` language syntax.\n * @returns {void}\n */\nfunction registerLanguage(language, syntax) {\n  high.registerLanguage(language, syntax)\n}\n\n/**\n * Register aliases for already registered languages.\n *\n * @param {string|Record<string, string|Array<string>>} language\n *   Programming language name or a map of `language`s to `alias`es or `list`s\n * @param {string|Array<string>} [alias]\n *   New aliases for the programming language.\n * @returns {void}\n */\nconst registerAlias =\n  /**\n   * @type {(\n   *   ((language: string, alias: string|Array<string>) => void) &\n   *   ((aliases: Record<string, string|Array<string>>) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {string|Record<string, string|Array<string>>} language\n     * @param {string|Array<string>} [alias]\n     * @returns {void}\n     */\n    function (language, alias) {\n      if (typeof language === 'string') {\n        // @ts-expect-error: should be a string in this overload.\n        high.registerAliases(alias, {languageName: language})\n      } else {\n        /** @type {string} */\n        let key\n\n        for (key in language) {\n          if (own.call(language, key)) {\n            high.registerAliases(language[key], {languageName: key})\n          }\n        }\n      }\n    }\n  )\n\n/**\n * Check whether an `alias` or `language` is registered.\n *\n * @param {string} aliasOrLanguage\n *   Name of a registered language or alias.\n * @returns {boolean}\n *   Whether `aliasOrlanguage` is registered.\n */\nfunction registered(aliasOrLanguage) {\n  return Boolean(high.getLanguage(aliasOrLanguage))\n}\n\n/**\n * List registered languages.\n *\n * @returns {Array<string>}\n *   Names of registered language.\n */\nfunction listLanguages() {\n  return high.listLanguages()\n}\n\n/** @type {HighlightEmitter} */\nclass HastEmitter {\n  /**\n   * @param {HighlightOptions} options\n   */\n  constructor(options) {\n    /** @type {HighlightOptions} */\n    this.options = options\n    /** @type {Root} */\n    this.root = {\n      type: 'root',\n      data: {language: null, relevance: 0},\n      children: []\n    }\n    /** @type {[Root, ...Span[]]} */\n    this.stack = [this.root]\n  }\n\n  /**\n   * @param {string} value\n   */\n  addText(value) {\n    if (value === '') return\n\n    const current = this.stack[this.stack.length - 1]\n    const tail = current.children[current.children.length - 1]\n\n    if (tail && tail.type === 'text') {\n      tail.value += value\n    } else {\n      current.children.push({type: 'text', value})\n    }\n  }\n\n  /**\n   * @param {string} value\n   * @param {string} name\n   */\n  addKeyword(value, name) {\n    this.openNode(name)\n    this.addText(value)\n    this.closeNode()\n  }\n\n  /**\n   * @param {HastEmitter} other\n   * @param {string} name\n   */\n  addSublanguage(other, name) {\n    const current = this.stack[this.stack.length - 1]\n    const results = other.root.children\n\n    if (name) {\n      current.children.push({\n        type: 'element',\n        tagName: 'span',\n        properties: {className: [name]},\n        children: results\n      })\n    } else {\n      current.children.push(...results)\n    }\n  }\n\n  /**\n   * @param {string} name\n   */\n  openNode(name) {\n    const className = name.split('.').map((d) => this.options.classPrefix + d)\n    const current = this.stack[this.stack.length - 1]\n    /** @type {Span} */\n    const child = {\n      type: 'element',\n      tagName: 'span',\n      properties: {className},\n      children: []\n    }\n\n    current.children.push(child)\n    this.stack.push(child)\n  }\n\n  /**\n   */\n  closeNode() {\n    this.stack.pop()\n  }\n\n  /**\n   */\n  closeAllNodes() {}\n\n  /**\n   */\n  finalize() {}\n\n  /**\n   */\n  toHTML() {\n    return ''\n  }\n}\n\nexport const lowlight = {\n  highlight,\n  highlightAuto,\n  registerLanguage,\n  registered,\n  listLanguages,\n  registerAlias\n}\n"]},"metadata":{},"sourceType":"module"}
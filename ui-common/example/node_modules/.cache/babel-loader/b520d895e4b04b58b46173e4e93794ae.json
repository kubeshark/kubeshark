{"ast":null,"code":"'use strict';\n\nmodule.exports = scss;\nscss.displayName = 'scss';\nscss.aliases = [];\n\nfunction scss(Prism) {\n  Prism.languages.scss = Prism.languages.extend('css', {\n    comment: {\n      pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n      lookbehind: true\n    },\n    atrule: {\n      pattern: /@[\\w-](?:\\([^()]+\\)|[^()\\s]|\\s+(?!\\s))*?(?=\\s+[{;])/,\n      inside: {\n        rule: /@[\\w-]+/ // See rest below\n\n      }\n    },\n    // url, compassified\n    url: /(?:[-a-z]+-)?url(?=\\()/i,\n    // CSS selector regex is not appropriate for Sass\n    // since there can be lot more things (var, @ directive, nesting..)\n    // a selector must start at the end of a property or after a brace (end of other rules or nesting)\n    // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n    // the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n    // can \"pass\" as a selector- e.g: proper#{$erty})\n    // this one was hard to do, so please be careful if you edit this one :)\n    selector: {\n      // Initial look-ahead is used to prevent matching of blank selectors\n      pattern: /(?=\\S)[^@;{}()]?(?:[^@;{}()\\s]|\\s+(?!\\s)|#\\{\\$[-\\w]+\\})+(?=\\s*\\{(?:\\}|\\s|[^}][^:{}]*[:{][^}]))/,\n      inside: {\n        parent: {\n          pattern: /&/,\n          alias: 'important'\n        },\n        placeholder: /%[-\\w]+/,\n        variable: /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n      }\n    },\n    property: {\n      pattern: /(?:[-\\w]|\\$[-\\w]|#\\{\\$[-\\w]+\\})+(?=\\s*:)/,\n      inside: {\n        variable: /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n      }\n    }\n  });\n  Prism.languages.insertBefore('scss', 'atrule', {\n    keyword: [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\\b/i, {\n      pattern: /( )(?:from|through)(?= )/,\n      lookbehind: true\n    }]\n  });\n  Prism.languages.insertBefore('scss', 'important', {\n    // var and interpolated vars\n    variable: /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n  });\n  Prism.languages.insertBefore('scss', 'function', {\n    'module-modifier': {\n      pattern: /\\b(?:as|hide|show|with)\\b/i,\n      alias: 'keyword'\n    },\n    placeholder: {\n      pattern: /%[-\\w]+/,\n      alias: 'selector'\n    },\n    statement: {\n      pattern: /\\B!(?:default|optional)\\b/i,\n      alias: 'keyword'\n    },\n    boolean: /\\b(?:false|true)\\b/,\n    null: {\n      pattern: /\\bnull\\b/,\n      alias: 'keyword'\n    },\n    operator: {\n      pattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|not|or)(?=\\s)/,\n      lookbehind: true\n    }\n  });\n  Prism.languages.scss['atrule'].inside.rest = Prism.languages.scss;\n}","map":{"version":3,"sources":["/Users/leon/lib-test/liraz-test/node_modules/refractor/lang/scss.js"],"names":["module","exports","scss","displayName","aliases","Prism","languages","extend","comment","pattern","lookbehind","atrule","inside","rule","url","selector","parent","alias","placeholder","variable","property","insertBefore","keyword","statement","boolean","null","operator","rest"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,IAAjB;AACAA,IAAI,CAACC,WAAL,GAAmB,MAAnB;AACAD,IAAI,CAACE,OAAL,GAAe,EAAf;;AACA,SAASF,IAAT,CAAcG,KAAd,EAAqB;AACnBA,EAAAA,KAAK,CAACC,SAAN,CAAgBJ,IAAhB,GAAuBG,KAAK,CAACC,SAAN,CAAgBC,MAAhB,CAAuB,KAAvB,EAA8B;AACnDC,IAAAA,OAAO,EAAE;AACPC,MAAAA,OAAO,EAAE,sCADF;AAEPC,MAAAA,UAAU,EAAE;AAFL,KAD0C;AAKnDC,IAAAA,MAAM,EAAE;AACNF,MAAAA,OAAO,EAAE,qDADH;AAENG,MAAAA,MAAM,EAAE;AACNC,QAAAA,IAAI,EAAE,SADA,CACU;;AADV;AAFF,KAL2C;AAWnD;AACAC,IAAAA,GAAG,EAAE,yBAZ8C;AAanD;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,IAAAA,QAAQ,EAAE;AACR;AACAN,MAAAA,OAAO,EACL,gGAHM;AAIRG,MAAAA,MAAM,EAAE;AACNI,QAAAA,MAAM,EAAE;AACNP,UAAAA,OAAO,EAAE,GADH;AAENQ,UAAAA,KAAK,EAAE;AAFD,SADF;AAKNC,QAAAA,WAAW,EAAE,SALP;AAMNC,QAAAA,QAAQ,EAAE;AANJ;AAJA,KApByC;AAiCnDC,IAAAA,QAAQ,EAAE;AACRX,MAAAA,OAAO,EAAE,0CADD;AAERG,MAAAA,MAAM,EAAE;AACNO,QAAAA,QAAQ,EAAE;AADJ;AAFA;AAjCyC,GAA9B,CAAvB;AAwCAd,EAAAA,KAAK,CAACC,SAAN,CAAgBe,YAAhB,CAA6B,MAA7B,EAAqC,QAArC,EAA+C;AAC7CC,IAAAA,OAAO,EAAE,CACP,mHADO,EAEP;AACEb,MAAAA,OAAO,EAAE,0BADX;AAEEC,MAAAA,UAAU,EAAE;AAFd,KAFO;AADoC,GAA/C;AASAL,EAAAA,KAAK,CAACC,SAAN,CAAgBe,YAAhB,CAA6B,MAA7B,EAAqC,WAArC,EAAkD;AAChD;AACAF,IAAAA,QAAQ,EAAE;AAFsC,GAAlD;AAIAd,EAAAA,KAAK,CAACC,SAAN,CAAgBe,YAAhB,CAA6B,MAA7B,EAAqC,UAArC,EAAiD;AAC/C,uBAAmB;AACjBZ,MAAAA,OAAO,EAAE,4BADQ;AAEjBQ,MAAAA,KAAK,EAAE;AAFU,KAD4B;AAK/CC,IAAAA,WAAW,EAAE;AACXT,MAAAA,OAAO,EAAE,SADE;AAEXQ,MAAAA,KAAK,EAAE;AAFI,KALkC;AAS/CM,IAAAA,SAAS,EAAE;AACTd,MAAAA,OAAO,EAAE,4BADA;AAETQ,MAAAA,KAAK,EAAE;AAFE,KAToC;AAa/CO,IAAAA,OAAO,EAAE,oBAbsC;AAc/CC,IAAAA,IAAI,EAAE;AACJhB,MAAAA,OAAO,EAAE,UADL;AAEJQ,MAAAA,KAAK,EAAE;AAFH,KAdyC;AAkB/CS,IAAAA,QAAQ,EAAE;AACRjB,MAAAA,OAAO,EAAE,iDADD;AAERC,MAAAA,UAAU,EAAE;AAFJ;AAlBqC,GAAjD;AAuBAL,EAAAA,KAAK,CAACC,SAAN,CAAgBJ,IAAhB,CAAqB,QAArB,EAA+BU,MAA/B,CAAsCe,IAAtC,GAA6CtB,KAAK,CAACC,SAAN,CAAgBJ,IAA7D;AACD","sourcesContent":["'use strict'\n\nmodule.exports = scss\nscss.displayName = 'scss'\nscss.aliases = []\nfunction scss(Prism) {\n  Prism.languages.scss = Prism.languages.extend('css', {\n    comment: {\n      pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n      lookbehind: true\n    },\n    atrule: {\n      pattern: /@[\\w-](?:\\([^()]+\\)|[^()\\s]|\\s+(?!\\s))*?(?=\\s+[{;])/,\n      inside: {\n        rule: /@[\\w-]+/ // See rest below\n      }\n    },\n    // url, compassified\n    url: /(?:[-a-z]+-)?url(?=\\()/i,\n    // CSS selector regex is not appropriate for Sass\n    // since there can be lot more things (var, @ directive, nesting..)\n    // a selector must start at the end of a property or after a brace (end of other rules or nesting)\n    // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n    // the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n    // can \"pass\" as a selector- e.g: proper#{$erty})\n    // this one was hard to do, so please be careful if you edit this one :)\n    selector: {\n      // Initial look-ahead is used to prevent matching of blank selectors\n      pattern:\n        /(?=\\S)[^@;{}()]?(?:[^@;{}()\\s]|\\s+(?!\\s)|#\\{\\$[-\\w]+\\})+(?=\\s*\\{(?:\\}|\\s|[^}][^:{}]*[:{][^}]))/,\n      inside: {\n        parent: {\n          pattern: /&/,\n          alias: 'important'\n        },\n        placeholder: /%[-\\w]+/,\n        variable: /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n      }\n    },\n    property: {\n      pattern: /(?:[-\\w]|\\$[-\\w]|#\\{\\$[-\\w]+\\})+(?=\\s*:)/,\n      inside: {\n        variable: /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n      }\n    }\n  })\n  Prism.languages.insertBefore('scss', 'atrule', {\n    keyword: [\n      /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\\b/i,\n      {\n        pattern: /( )(?:from|through)(?= )/,\n        lookbehind: true\n      }\n    ]\n  })\n  Prism.languages.insertBefore('scss', 'important', {\n    // var and interpolated vars\n    variable: /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n  })\n  Prism.languages.insertBefore('scss', 'function', {\n    'module-modifier': {\n      pattern: /\\b(?:as|hide|show|with)\\b/i,\n      alias: 'keyword'\n    },\n    placeholder: {\n      pattern: /%[-\\w]+/,\n      alias: 'selector'\n    },\n    statement: {\n      pattern: /\\B!(?:default|optional)\\b/i,\n      alias: 'keyword'\n    },\n    boolean: /\\b(?:false|true)\\b/,\n    null: {\n      pattern: /\\bnull\\b/,\n      alias: 'keyword'\n    },\n    operator: {\n      pattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|not|or)(?=\\s)/,\n      lookbehind: true\n    }\n  })\n  Prism.languages.scss['atrule'].inside.rest = Prism.languages.scss\n}\n"]},"metadata":{},"sourceType":"script"}
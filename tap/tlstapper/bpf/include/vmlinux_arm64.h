#if defined(bpf_target_arm64)

#ifndef __VMLINUX_H__
#define __VMLINUX_H__

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)
#endif

typedef signed char __s8;

typedef unsigned char __u8;

typedef short int __s16;

typedef short unsigned int __u16;

typedef int __s32;

typedef unsigned int __u32;

typedef long long int __s64;

typedef long long unsigned int __u64;

typedef __s8 s8;

typedef __u8 u8;

typedef __s16 s16;

typedef __u16 u16;

typedef __s32 s32;

typedef __u32 u32;

typedef __s64 s64;

typedef __u64 u64;

enum {
	false = 0,
	true = 1,
};

typedef long int __kernel_long_t;

typedef long unsigned int __kernel_ulong_t;

typedef int __kernel_pid_t;

typedef unsigned int __kernel_uid32_t;

typedef unsigned int __kernel_gid32_t;

typedef __kernel_ulong_t __kernel_size_t;

typedef __kernel_long_t __kernel_ssize_t;

typedef long long int __kernel_loff_t;

typedef long long int __kernel_time64_t;

typedef __kernel_long_t __kernel_clock_t;

typedef int __kernel_timer_t;

typedef int __kernel_clockid_t;

typedef __u32 __le32;

typedef unsigned int __poll_t;

typedef u32 __kernel_dev_t;

typedef __kernel_dev_t dev_t;

typedef short unsigned int umode_t;

typedef __kernel_pid_t pid_t;

typedef __kernel_clockid_t clockid_t;

typedef _Bool bool;

typedef __kernel_uid32_t uid_t;

typedef __kernel_gid32_t gid_t;

typedef __kernel_loff_t loff_t;

typedef __kernel_size_t size_t;

typedef __kernel_ssize_t ssize_t;

typedef unsigned int uint;

typedef s32 int32_t;

typedef u32 uint32_t;

typedef u64 sector_t;

typedef u64 blkcnt_t;

typedef unsigned int gfp_t;

typedef unsigned int fmode_t;

typedef u64 phys_addr_t;

typedef phys_addr_t resource_size_t;

typedef long unsigned int irq_hw_number_t;

typedef struct {
	int counter;
} atomic_t;

typedef struct {
	s64 counter;
} atomic64_t;

struct list_head {
	struct list_head *next;
	struct list_head *prev;
};

struct hlist_node;

struct hlist_head {
	struct hlist_node *first;
};

struct hlist_node {
	struct hlist_node *next;
	struct hlist_node **pprev;
};

struct callback_head {
	struct callback_head *next;
	void (*func)(struct callback_head *);
};

struct kernel_symbol {
	int value_offset;
	int name_offset;
	int namespace_offset;
};

struct jump_entry {
	s32 code;
	s32 target;
	long int key;
};

struct static_key_mod;

struct static_key {
	atomic_t enabled;
	union {
		long unsigned int type;
		struct jump_entry *entries;
		struct static_key_mod *next;
	};
};

typedef int (*initcall_t)();

typedef int initcall_entry_t;

struct lock_class_key {};

struct fs_context;

struct fs_parameter_spec;

struct dentry;

struct super_block;

struct module;

struct file_system_type {
	const char *name;
	int fs_flags;
	int (*init_fs_context)(struct fs_context *);
	const struct fs_parameter_spec *parameters;
	struct dentry * (*mount)(struct file_system_type *, int, const char *, void *);
	void (*kill_sb)(struct super_block *);
	struct module *owner;
	struct file_system_type *next;
	struct hlist_head fs_supers;
	struct lock_class_key s_lock_key;
	struct lock_class_key s_umount_key;
	struct lock_class_key s_vfs_rename_key;
	struct lock_class_key s_writers_key[3];
	struct lock_class_key i_lock_key;
	struct lock_class_key i_mutex_key;
	struct lock_class_key i_mutex_dir_key;
};

struct obs_kernel_param {
	const char *str;
	int (*setup_func)(char *);
	int early;
};

typedef bool pstate_check_t(long unsigned int);

struct static_key_true {
	struct static_key key;
};

struct static_key_false {
	struct static_key key;
};

typedef atomic64_t atomic_long_t;

struct qspinlock {
	union {
		atomic_t val;
		struct {
			u8 locked;
			u8 pending;
		};
		struct {
			u16 locked_pending;
			u16 tail;
		};
	};
};

typedef struct qspinlock arch_spinlock_t;

struct qrwlock {
	union {
		atomic_t cnts;
		struct {
			u8 wlocked;
			u8 __lstate[3];
		};
	};
	arch_spinlock_t wait_lock;
};

typedef struct qrwlock arch_rwlock_t;

struct lockdep_map {};

struct raw_spinlock {
	arch_spinlock_t raw_lock;
};

typedef struct raw_spinlock raw_spinlock_t;

struct spinlock {
	union {
		struct raw_spinlock rlock;
	};
};

typedef struct spinlock spinlock_t;

typedef struct {
	arch_rwlock_t raw_lock;
} rwlock_t;

struct ratelimit_state {
	raw_spinlock_t lock;
	int interval;
	int burst;
	int printed;
	int missed;
	long unsigned int begin;
	long unsigned int flags;
};

struct _ddebug {
	const char *modname;
	const char *function;
	const char *filename;
	const char *format;
	unsigned int lineno: 18;
	unsigned int flags: 8;
	union {
		struct static_key_true dd_key_true;
		struct static_key_false dd_key_false;
	} key;
};

typedef void *fl_owner_t;

struct file;

struct kiocb;

struct iov_iter;

struct dir_context;

struct poll_table_struct;

struct vm_area_struct;

struct inode;

struct file_lock;

struct page;

struct pipe_inode_info;

struct seq_file;

struct file_operations {
	struct module *owner;
	loff_t (*llseek)(struct file *, loff_t, int);
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	ssize_t (*read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter)(struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *, bool);
	int (*iterate)(struct file *, struct dir_context *);
	int (*iterate_shared)(struct file *, struct dir_context *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct file *, struct vm_area_struct *);
	long unsigned int mmap_supported_flags;
	int (*open)(struct inode *, struct file *);
	int (*flush)(struct file *, fl_owner_t);
	int (*release)(struct inode *, struct file *);
	int (*fsync)(struct file *, loff_t, loff_t, int);
	int (*fasync)(int, struct file *, int);
	int (*lock)(struct file *, int, struct file_lock *);
	ssize_t (*sendpage)(struct file *, struct page *, int, size_t, loff_t *, int);
	long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*check_flags)(int);
	int (*setfl)(struct file *, long unsigned int);
	int (*flock)(struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long int, struct file_lock **, void **);
	long int (*fallocate)(struct file *, int, loff_t, loff_t);
	void (*show_fdinfo)(struct seq_file *, struct file *);
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *, loff_t, struct file *, loff_t, loff_t, unsigned int);
	int (*fadvise)(struct file *, loff_t, loff_t, int);
};

struct static_call_key {
	void *func;
};

struct notifier_block;

struct atomic_notifier_head {
	spinlock_t lock;
	struct notifier_block *head;
};

enum system_states {
	SYSTEM_BOOTING = 0,
	SYSTEM_SCHEDULING = 1,
	SYSTEM_RUNNING = 2,
	SYSTEM_HALT = 3,
	SYSTEM_POWER_OFF = 4,
	SYSTEM_RESTART = 5,
	SYSTEM_SUSPEND = 6,
};

struct taint_flag {
	char c_true;
	char c_false;
	bool module;
};

enum ftrace_dump_mode {
	DUMP_NONE = 0,
	DUMP_ALL = 1,
	DUMP_ORIG = 2,
};

typedef __s64 time64_t;

struct __kernel_timespec {
	__kernel_time64_t tv_sec;
	long long int tv_nsec;
};

struct timezone {
	int tz_minuteswest;
	int tz_dsttime;
};

struct timespec64 {
	time64_t tv_sec;
	long int tv_nsec;
};

struct bug_entry {
	int bug_addr_disp;
	int file_disp;
	short unsigned int line;
	short unsigned int flags;
};

enum ftr_type {
	FTR_EXACT = 0,
	FTR_LOWER_SAFE = 1,
	FTR_HIGHER_SAFE = 2,
	FTR_HIGHER_OR_ZERO_SAFE = 3,
};

struct arm64_ftr_bits {
	bool sign;
	bool visible;
	bool strict;
	enum ftr_type type;
	u8 shift;
	u8 width;
	s64 safe_val;
};

struct arm64_ftr_override {
	u64 val;
	u64 mask;
};

struct arm64_ftr_reg {
	const char *name;
	u64 strict_mask;
	u64 user_mask;
	u64 sys_val;
	u64 user_val;
	struct arm64_ftr_override *override;
	const struct arm64_ftr_bits *ftr_bits;
};

struct cpumask {
	long unsigned int bits[4];
};

typedef struct cpumask cpumask_t;

typedef struct cpumask cpumask_var_t[1];

struct llist_node;

struct llist_head {
	struct llist_node *first;
};

struct llist_node {
	struct llist_node *next;
};

struct __call_single_node {
	struct llist_node llist;
	union {
		unsigned int u_flags;
		atomic_t a_flags;
	};
	u16 src;
	u16 dst;
};

typedef void (*smp_call_func_t)(void *);

struct __call_single_data {
	struct __call_single_node node;
	smp_call_func_t func;
	void *info;
};

enum timespec_type {
	TT_NONE = 0,
	TT_NATIVE = 1,
	TT_COMPAT = 2,
};

typedef s32 old_time32_t;

struct old_timespec32 {
	old_time32_t tv_sec;
	s32 tv_nsec;
};

struct pollfd {
	int fd;
	short int events;
	short int revents;
};

struct restart_block {
	long unsigned int arch_data;
	long int (*fn)(struct restart_block *);
	union {
		struct {
			u32 *uaddr;
			u32 val;
			u32 flags;
			u32 bitset;
			u64 time;
			u32 *uaddr2;
		} futex;
		struct {
			clockid_t clockid;
			enum timespec_type type;
			union {
				struct __kernel_timespec *rmtp;
				struct old_timespec32 *compat_rmtp;
			};
			u64 expires;
		} nanosleep;
		struct {
			struct pollfd *ufds;
			int nfds;
			int has_timeout;
			long unsigned int tv_sec;
			long unsigned int tv_nsec;
		} poll;
	};
};

struct thread_info {
	long unsigned int flags;
	u64 ttbr0;
	union {
		u64 preempt_count;
		struct {
			u32 count;
			u32 need_resched;
		} preempt;
	};
};

struct refcount_struct {
	atomic_t refs;
};

typedef struct refcount_struct refcount_t;

struct load_weight {
	long unsigned int weight;
	u32 inv_weight;
};

struct rb_node {
	long unsigned int __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
};

struct sched_statistics {
	u64 wait_start;
	u64 wait_max;
	u64 wait_count;
	u64 wait_sum;
	u64 iowait_count;
	u64 iowait_sum;
	u64 sleep_start;
	u64 sleep_max;
	s64 sum_sleep_runtime;
	u64 block_start;
	u64 block_max;
	u64 exec_max;
	u64 slice_max;
	u64 nr_migrations_cold;
	u64 nr_failed_migrations_affine;
	u64 nr_failed_migrations_running;
	u64 nr_failed_migrations_hot;
	u64 nr_forced_migrations;
	u64 nr_wakeups;
	u64 nr_wakeups_sync;
	u64 nr_wakeups_migrate;
	u64 nr_wakeups_local;
	u64 nr_wakeups_remote;
	u64 nr_wakeups_affine;
	u64 nr_wakeups_affine_attempts;
	u64 nr_wakeups_passive;
	u64 nr_wakeups_idle;
};

struct util_est {
	unsigned int enqueued;
	unsigned int ewma;
};

struct sched_avg {
	u64 last_update_time;
	u64 load_sum;
	u64 runnable_sum;
	u32 util_sum;
	u32 period_contrib;
	long unsigned int load_avg;
	long unsigned int runnable_avg;
	long unsigned int util_avg;
	struct util_est util_est;
};

struct cfs_rq;

struct sched_entity {
	struct load_weight load;
	struct rb_node run_node;
	struct list_head group_node;
	unsigned int on_rq;
	u64 exec_start;
	u64 sum_exec_runtime;
	u64 vruntime;
	u64 prev_sum_exec_runtime;
	u64 nr_migrations;
	struct sched_statistics statistics;
	int depth;
	struct sched_entity *parent;
	struct cfs_rq *cfs_rq;
	struct cfs_rq *my_q;
	long unsigned int runnable_weight;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg;
};

struct sched_rt_entity {
	struct list_head run_list;
	long unsigned int timeout;
	long unsigned int watchdog_stamp;
	unsigned int time_slice;
	short unsigned int on_rq;
	short unsigned int on_list;
	struct sched_rt_entity *back;
};

typedef s64 ktime_t;

struct timerqueue_node {
	struct rb_node node;
	ktime_t expires;
};

enum hrtimer_restart {
	HRTIMER_NORESTART = 0,
	HRTIMER_RESTART = 1,
};

struct hrtimer_clock_base;

struct hrtimer {
	struct timerqueue_node node;
	ktime_t _softexpires;
	enum hrtimer_restart (*function)(struct hrtimer *);
	struct hrtimer_clock_base *base;
	u8 state;
	u8 is_rel;
	u8 is_soft;
	u8 is_hard;
};

struct sched_dl_entity {
	struct rb_node rb_node;
	u64 dl_runtime;
	u64 dl_deadline;
	u64 dl_period;
	u64 dl_bw;
	u64 dl_density;
	s64 runtime;
	u64 deadline;
	unsigned int flags;
	unsigned int dl_throttled: 1;
	unsigned int dl_yielded: 1;
	unsigned int dl_non_contending: 1;
	unsigned int dl_overrun: 1;
	struct hrtimer dl_timer;
	struct hrtimer inactive_timer;
	struct sched_dl_entity *pi_se;
};

struct uclamp_se {
	unsigned int value: 11;
	unsigned int bucket_id: 3;
	unsigned int active: 1;
	unsigned int user_defined: 1;
};

union rcu_special {
	struct {
		u8 blocked;
		u8 need_qs;
		u8 exp_hint;
		u8 need_mb;
	} b;
	u32 s;
};

struct sched_info {
	long unsigned int pcount;
	long long unsigned int run_delay;
	long long unsigned int last_arrival;
	long long unsigned int last_queued;
};

struct plist_node {
	int prio;
	struct list_head prio_list;
	struct list_head node_list;
};

struct vmacache {
	u64 seqnum;
	struct vm_area_struct *vmas[4];
};

struct task_rss_stat {
	int events;
	int count[4];
};

struct prev_cputime {
	u64 utime;
	u64 stime;
	raw_spinlock_t lock;
};

struct rb_root {
	struct rb_node *rb_node;
};

struct rb_root_cached {
	struct rb_root rb_root;
	struct rb_node *rb_leftmost;
};

struct timerqueue_head {
	struct rb_root_cached rb_root;
};

struct posix_cputimer_base {
	u64 nextevt;
	struct timerqueue_head tqhead;
};

struct posix_cputimers {
	struct posix_cputimer_base bases[3];
	unsigned int timers_active;
	unsigned int expiry_active;
};

struct sem_undo_list;

struct sysv_sem {
	struct sem_undo_list *undo_list;
};

struct sysv_shm {
	struct list_head shm_clist;
};

typedef struct {
	long unsigned int sig[1];
} sigset_t;

struct sigpending {
	struct list_head list;
	sigset_t signal;
};

typedef struct {
	uid_t val;
} kuid_t;

struct seccomp_filter;

struct seccomp {
	int mode;
	atomic_t filter_count;
	struct seccomp_filter *filter;
};

struct syscall_user_dispatch {};

struct wake_q_node {
	struct wake_q_node *next;
};

struct task_io_accounting {
	u64 rchar;
	u64 wchar;
	u64 syscr;
	u64 syscw;
	u64 read_bytes;
	u64 write_bytes;
	u64 cancelled_write_bytes;
};

typedef struct {
	long unsigned int bits[1];
} nodemask_t;

struct seqcount {
	unsigned int sequence;
};

typedef struct seqcount seqcount_t;

struct seqcount_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_spinlock seqcount_spinlock_t;

struct optimistic_spin_queue {
	atomic_t tail;
};

struct mutex {
	atomic_long_t owner;
	spinlock_t wait_lock;
	struct optimistic_spin_queue osq;
	struct list_head wait_list;
};

struct tlbflush_unmap_batch {};

struct page_frag {
	struct page *page;
	__u32 offset;
	__u32 size;
};

struct kmap_ctrl {};

struct cpu_context {
	long unsigned int x19;
	long unsigned int x20;
	long unsigned int x21;
	long unsigned int x22;
	long unsigned int x23;
	long unsigned int x24;
	long unsigned int x25;
	long unsigned int x26;
	long unsigned int x27;
	long unsigned int x28;
	long unsigned int fp;
	long unsigned int sp;
	long unsigned int pc;
};

struct user_fpsimd_state {
	__int128 unsigned vregs[32];
	__u32 fpsr;
	__u32 fpcr;
	__u32 __reserved[2];
};

struct perf_event;

struct debug_info {
	int suspended_step;
	int bps_disabled;
	int wps_disabled;
	struct perf_event *hbp_break[16];
	struct perf_event *hbp_watch[16];
};

struct ptrauth_key {
	long unsigned int lo;
	long unsigned int hi;
};

struct ptrauth_keys_user {
	struct ptrauth_key apia;
	struct ptrauth_key apib;
	struct ptrauth_key apda;
	struct ptrauth_key apdb;
	struct ptrauth_key apga;
};

struct ptrauth_keys_kernel {
	struct ptrauth_key apia;
};

struct thread_struct {
	struct cpu_context cpu_context;
	long: 64;
	struct {
		long unsigned int tp_value;
		long unsigned int tp2_value;
		struct user_fpsimd_state fpsimd_state;
	} uw;
	unsigned int fpsimd_cpu;
	void *sve_state;
	unsigned int sve_vl;
	unsigned int sve_vl_onexec;
	long unsigned int fault_address;
	long unsigned int fault_code;
	struct debug_info debug;
	struct ptrauth_keys_user keys_user;
	struct ptrauth_keys_kernel keys_kernel;
	u64 gcr_user_excl;
	u64 sctlr_user;
	long: 64;
};

struct sched_class;

struct task_group;

struct mm_struct;

struct pid;

struct completion;

struct cred;

struct key;

struct nameidata;

struct fs_struct;

struct files_struct;

struct io_uring_task;

struct nsproxy;

struct signal_struct;

struct sighand_struct;

struct audit_context;

struct rt_mutex_waiter;

struct bio_list;

struct blk_plug;

struct reclaim_state;

struct backing_dev_info;

struct io_context;

struct capture_control;

struct kernel_siginfo;

typedef struct kernel_siginfo kernel_siginfo_t;

struct css_set;

struct robust_list_head;

struct compat_robust_list_head;

struct futex_pi_state;

struct perf_event_context;

struct mempolicy;

struct numa_group;

struct rseq;

struct task_delay_info;

struct ftrace_ret_stack;

struct mem_cgroup;

struct request_queue;

struct uprobe_task;

struct vm_struct;

struct bpf_local_storage;

struct task_struct {
	struct thread_info thread_info;
	volatile long int state;
	void *stack;
	refcount_t usage;
	unsigned int flags;
	unsigned int ptrace;
	int on_cpu;
	struct __call_single_node wake_entry;
	unsigned int cpu;
	unsigned int wakee_flips;
	long unsigned int wakee_flip_decay_ts;
	struct task_struct *last_wakee;
	int recent_used_cpu;
	int wake_cpu;
	int on_rq;
	int prio;
	int static_prio;
	int normal_prio;
	unsigned int rt_priority;
	const struct sched_class *sched_class;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sched_entity se;
	struct sched_rt_entity rt;
	struct task_group *sched_task_group;
	struct sched_dl_entity dl;
	struct uclamp_se uclamp_req[2];
	struct uclamp_se uclamp[2];
	struct hlist_head preempt_notifiers;
	unsigned int btrace_seq;
	unsigned int policy;
	int nr_cpus_allowed;
	const cpumask_t *cpus_ptr;
	cpumask_t cpus_mask;
	void *migration_pending;
	short unsigned int migration_disabled;
	short unsigned int migration_flags;
	int trc_reader_nesting;
	int trc_ipi_to_cpu;
	union rcu_special trc_reader_special;
	bool trc_reader_checked;
	struct list_head trc_holdout_list;
	struct sched_info sched_info;
	struct list_head tasks;
	struct plist_node pushable_tasks;
	struct rb_node pushable_dl_tasks;
	struct mm_struct *mm;
	struct mm_struct *active_mm;
	struct vmacache vmacache;
	struct task_rss_stat rss_stat;
	int exit_state;
	int exit_code;
	int exit_signal;
	int pdeath_signal;
	long unsigned int jobctl;
	unsigned int personality;
	unsigned int sched_reset_on_fork: 1;
	unsigned int sched_contributes_to_load: 1;
	unsigned int sched_migrated: 1;
	unsigned int sched_psi_wake_requeue: 1;
	int: 28;
	unsigned int sched_remote_wakeup: 1;
	unsigned int in_execve: 1;
	unsigned int in_iowait: 1;
	unsigned int in_user_fault: 1;
	unsigned int no_cgroup_migration: 1;
	unsigned int frozen: 1;
	unsigned int use_memdelay: 1;
	unsigned int in_memstall: 1;
	long unsigned int atomic_flags;
	struct restart_block restart_block;
	pid_t pid;
	pid_t tgid;
	long unsigned int stack_canary;
	struct task_struct *real_parent;
	struct task_struct *parent;
	struct list_head children;
	struct list_head sibling;
	struct task_struct *group_leader;
	struct list_head ptraced;
	struct list_head ptrace_entry;
	struct pid *thread_pid;
	struct hlist_node pid_links[4];
	struct list_head thread_group;
	struct list_head thread_node;
	struct completion *vfork_done;
	int *set_child_tid;
	int *clear_child_tid;
	void *pf_io_worker;
	u64 utime;
	u64 stime;
	u64 gtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	u64 start_time;
	u64 start_boottime;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	struct posix_cputimers posix_cputimers;
	const struct cred *ptracer_cred;
	const struct cred *real_cred;
	const struct cred *cred;
	struct key *cached_requested_key;
	char comm[16];
	struct nameidata *nameidata;
	struct sysv_sem sysvsem;
	struct sysv_shm sysvshm;
	long unsigned int last_switch_count;
	long unsigned int last_switch_time;
	struct fs_struct *fs;
	struct files_struct *files;
	struct io_uring_task *io_uring;
	struct nsproxy *nsproxy;
	struct signal_struct *signal;
	struct sighand_struct *sighand;
	sigset_t blocked;
	sigset_t real_blocked;
	sigset_t saved_sigmask;
	struct sigpending pending;
	long unsigned int sas_ss_sp;
	size_t sas_ss_size;
	unsigned int sas_ss_flags;
	struct callback_head *task_works;
	struct audit_context *audit_context;
	kuid_t loginuid;
	unsigned int sessionid;
	struct seccomp seccomp;
	struct syscall_user_dispatch syscall_dispatch;
	u64 parent_exec_id;
	u64 self_exec_id;
	spinlock_t alloc_lock;
	raw_spinlock_t pi_lock;
	struct wake_q_node wake_q;
	struct rb_root_cached pi_waiters;
	struct task_struct *pi_top_task;
	struct rt_mutex_waiter *pi_blocked_on;
	void *journal_info;
	struct bio_list *bio_list;
	struct blk_plug *plug;
	struct reclaim_state *reclaim_state;
	struct backing_dev_info *backing_dev_info;
	struct io_context *io_context;
	struct capture_control *capture_control;
	long unsigned int ptrace_message;
	kernel_siginfo_t *last_siginfo;
	struct task_io_accounting ioac;
	unsigned int psi_flags;
	u64 acct_rss_mem1;
	u64 acct_vm_mem1;
	u64 acct_timexpd;
	nodemask_t mems_allowed;
	seqcount_spinlock_t mems_allowed_seq;
	int cpuset_mem_spread_rotor;
	int cpuset_slab_spread_rotor;
	struct css_set *cgroups;
	struct list_head cg_list;
	struct robust_list_head *robust_list;
	struct compat_robust_list_head *compat_robust_list;
	struct list_head pi_state_list;
	struct futex_pi_state *pi_state_cache;
	struct mutex futex_exit_mutex;
	unsigned int futex_state;
	struct perf_event_context *perf_event_ctxp[2];
	struct mutex perf_event_mutex;
	struct list_head perf_event_list;
	struct mempolicy *mempolicy;
	short int il_prev;
	short int pref_node_fork;
	int numa_scan_seq;
	unsigned int numa_scan_period;
	unsigned int numa_scan_period_max;
	int numa_preferred_nid;
	long unsigned int numa_migrate_retry;
	u64 node_stamp;
	u64 last_task_numa_placement;
	u64 last_sum_exec_runtime;
	struct callback_head numa_work;
	struct numa_group *numa_group;
	long unsigned int *numa_faults;
	long unsigned int total_numa_faults;
	long unsigned int numa_faults_locality[3];
	long unsigned int numa_pages_migrated;
	struct rseq *rseq;
	u32 rseq_sig;
	long unsigned int rseq_event_mask;
	struct tlbflush_unmap_batch tlb_ubc;
	union {
		refcount_t rcu_users;
		struct callback_head rcu;
	};
	struct pipe_inode_info *splice_pipe;
	struct page_frag task_frag;
	struct task_delay_info *delays;
	int nr_dirtied;
	int nr_dirtied_pause;
	long unsigned int dirty_paused_when;
	u64 timer_slack_ns;
	u64 default_timer_slack_ns;
	int curr_ret_stack;
	int curr_ret_depth;
	struct ftrace_ret_stack *ret_stack;
	long long unsigned int ftrace_timestamp;
	atomic_t trace_overrun;
	atomic_t tracing_graph_pause;
	long unsigned int trace;
	long unsigned int trace_recursion;
	struct mem_cgroup *memcg_in_oom;
	gfp_t memcg_oom_gfp_mask;
	int memcg_oom_order;
	unsigned int memcg_nr_pages_over_high;
	struct mem_cgroup *active_memcg;
	struct request_queue *throttle_queue;
	struct uprobe_task *utask;
	unsigned int sequential_io;
	unsigned int sequential_io_avg;
	struct kmap_ctrl kmap_ctrl;
	int pagefault_disabled;
	struct task_struct *oom_reaper_list;
	struct vm_struct *stack_vm_area;
	refcount_t stack_refcount;
	void *security;
	struct bpf_local_storage *bpf_storage;
	struct llist_head kretprobe_instances;
	struct thread_struct thread;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct secondary_data {
	void *stack;
	struct task_struct *task;
	long int status;
};

enum arch_timer_erratum_match_type {
	ate_match_dt = 0,
	ate_match_local_cap_id = 1,
	ate_match_acpi_oem_info = 2,
};

struct clock_event_device;

struct arch_timer_erratum_workaround {
	enum arch_timer_erratum_match_type match_type;
	const void *id;
	const char *desc;
	u32 (*read_cntp_tval_el0)();
	u32 (*read_cntv_tval_el0)();
	u64 (*read_cntpct_el0)();
	u64 (*read_cntvct_el0)();
	int (*set_next_event_phys)(long unsigned int, struct clock_event_device *);
	int (*set_next_event_virt)(long unsigned int, struct clock_event_device *);
	bool disable_compat_vdso;
};

enum clock_event_state {
	CLOCK_EVT_STATE_DETACHED = 0,
	CLOCK_EVT_STATE_SHUTDOWN = 1,
	CLOCK_EVT_STATE_PERIODIC = 2,
	CLOCK_EVT_STATE_ONESHOT = 3,
	CLOCK_EVT_STATE_ONESHOT_STOPPED = 4,
};

struct clock_event_device {
	void (*event_handler)(struct clock_event_device *);
	int (*set_next_event)(long unsigned int, struct clock_event_device *);
	int (*set_next_ktime)(ktime_t, struct clock_event_device *);
	ktime_t next_event;
	u64 max_delta_ns;
	u64 min_delta_ns;
	u32 mult;
	u32 shift;
	enum clock_event_state state_use_accessors;
	unsigned int features;
	long unsigned int retries;
	int (*set_state_periodic)(struct clock_event_device *);
	int (*set_state_oneshot)(struct clock_event_device *);
	int (*set_state_oneshot_stopped)(struct clock_event_device *);
	int (*set_state_shutdown)(struct clock_event_device *);
	int (*tick_resume)(struct clock_event_device *);
	void (*broadcast)(const struct cpumask *);
	void (*suspend)(struct clock_event_device *);
	void (*resume)(struct clock_event_device *);
	long unsigned int min_delta_ticks;
	long unsigned int max_delta_ticks;
	const char *name;
	int rating;
	int irq;
	int bound_on;
	const struct cpumask *cpumask;
	struct list_head list;
	struct module *owner;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef s32 compat_long_t;

typedef u32 compat_uptr_t;

struct user_pt_regs {
	__u64 regs[31];
	__u64 sp;
	__u64 pc;
	__u64 pstate;
};

struct pt_regs {
	union {
		struct user_pt_regs user_regs;
		struct {
			u64 regs[31];
			u64 sp;
			u64 pc;
			u64 pstate;
		};
	};
	u64 orig_x0;
	s32 syscallno;
	u32 unused2;
	u64 sdei_ttbr1;
	u64 pmr_save;
	u64 stackframe[2];
	u64 lockdep_hardirqs;
	u64 exit_rcu;
};

struct arch_hw_breakpoint_ctrl {
	u32 __reserved: 19;
	u32 len: 8;
	u32 type: 2;
	u32 privilege: 2;
	u32 enabled: 1;
};

struct arch_hw_breakpoint {
	u64 address;
	u64 trigger;
	struct arch_hw_breakpoint_ctrl ctrl;
};

typedef u64 pteval_t;

typedef u64 pmdval_t;

typedef u64 pudval_t;

typedef u64 pgdval_t;

typedef struct {
	pteval_t pte;
} pte_t;

typedef struct {
	pmdval_t pmd;
} pmd_t;

typedef struct {
	pudval_t pud;
} pud_t;

typedef struct {
	pgdval_t pgd;
} pgd_t;

typedef struct {
	pteval_t pgprot;
} pgprot_t;

enum module_state {
	MODULE_STATE_LIVE = 0,
	MODULE_STATE_COMING = 1,
	MODULE_STATE_GOING = 2,
	MODULE_STATE_UNFORMED = 3,
};

struct kref {
	refcount_t refcount;
};

struct kset;

struct kobj_type;

struct kernfs_node;

struct kobject {
	const char *name;
	struct list_head entry;
	struct kobject *parent;
	struct kset *kset;
	struct kobj_type *ktype;
	struct kernfs_node *sd;
	struct kref kref;
	unsigned int state_initialized: 1;
	unsigned int state_in_sysfs: 1;
	unsigned int state_add_uevent_sent: 1;
	unsigned int state_remove_uevent_sent: 1;
	unsigned int uevent_suppress: 1;
};

struct module_param_attrs;

struct module_kobject {
	struct kobject kobj;
	struct module *mod;
	struct kobject *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
};

struct latch_tree_node {
	struct rb_node node[2];
};

struct mod_tree_node {
	struct module *mod;
	struct latch_tree_node node;
};

struct module_layout {
	void *base;
	unsigned int size;
	unsigned int text_size;
	unsigned int ro_size;
	unsigned int ro_after_init_size;
	struct mod_tree_node mtn;
};

struct mod_plt_sec {
	int plt_shndx;
	int plt_num_entries;
	int plt_max_entries;
};

struct plt_entry;

struct mod_arch_specific {
	struct mod_plt_sec core;
	struct mod_plt_sec init;
	struct plt_entry *ftrace_trampolines;
};

struct elf64_sym;

typedef struct elf64_sym Elf64_Sym;

struct mod_kallsyms {
	Elf64_Sym *symtab;
	unsigned int num_symtab;
	char *strtab;
	char *typetab;
};

typedef const int tracepoint_ptr_t;

struct module_attribute;

struct kernel_param;

struct exception_table_entry;

struct module_sect_attrs;

struct module_notes_attrs;

struct srcu_struct;

struct bpf_raw_event_map;

struct trace_event_call;

struct trace_eval_map;

struct error_injection_entry;

struct module {
	enum module_state state;
	struct list_head list;
	char name[56];
	struct module_kobject mkobj;
	struct module_attribute *modinfo_attrs;
	const char *version;
	const char *srcversion;
	struct kobject *holders_dir;
	const struct kernel_symbol *syms;
	const s32 *crcs;
	unsigned int num_syms;
	struct mutex param_lock;
	struct kernel_param *kp;
	unsigned int num_kp;
	unsigned int num_gpl_syms;
	const struct kernel_symbol *gpl_syms;
	const s32 *gpl_crcs;
	bool using_gplonly_symbols;
	bool sig_ok;
	bool async_probe_requested;
	unsigned int num_exentries;
	struct exception_table_entry *extable;
	int (*init)();
	struct module_layout core_layout;
	struct module_layout init_layout;
	struct mod_arch_specific arch;
	long unsigned int taints;
	unsigned int num_bugs;
	struct list_head bug_list;
	struct bug_entry *bug_table;
	struct mod_kallsyms *kallsyms;
	struct mod_kallsyms core_kallsyms;
	struct module_sect_attrs *sect_attrs;
	struct module_notes_attrs *notes_attrs;
	char *args;
	void *percpu;
	unsigned int percpu_size;
	void *noinstr_text_start;
	unsigned int noinstr_text_size;
	unsigned int num_tracepoints;
	tracepoint_ptr_t *tracepoints_ptrs;
	unsigned int num_srcu_structs;
	struct srcu_struct **srcu_struct_ptrs;
	unsigned int num_bpf_raw_events;
	struct bpf_raw_event_map *bpf_raw_events;
	unsigned int btf_data_size;
	void *btf_data;
	struct jump_entry *jump_entries;
	unsigned int num_jump_entries;
	unsigned int num_trace_bprintk_fmt;
	const char **trace_bprintk_fmt_start;
	struct trace_event_call **trace_events;
	unsigned int num_trace_events;
	struct trace_eval_map **trace_evals;
	unsigned int num_trace_evals;
	unsigned int num_ftrace_callsites;
	long unsigned int *ftrace_callsites;
	void *kprobes_text_start;
	unsigned int kprobes_text_size;
	long unsigned int *kprobe_blacklist;
	unsigned int num_kprobe_blacklist;
	struct list_head source_list;
	struct list_head target_list;
	void (*exit)();
	atomic_t refcnt;
	struct error_injection_entry *ei_funcs;
	unsigned int num_ei_funcs;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum pcpu_fc {
	PCPU_FC_AUTO = 0,
	PCPU_FC_EMBED = 1,
	PCPU_FC_PAGE = 2,
	PCPU_FC_NR = 3,
};

enum arm64_hyp_spectre_vector {
	HYP_VECTOR_DIRECT = 0,
	HYP_VECTOR_SPECTRE_DIRECT = 1,
	HYP_VECTOR_INDIRECT = 2,
	HYP_VECTOR_SPECTRE_INDIRECT = 3,
};

typedef void (*bp_hardening_cb_t)();

struct bp_hardening_data {
	enum arm64_hyp_spectre_vector slot;
	bp_hardening_cb_t fn;
};

enum perf_event_state {
	PERF_EVENT_STATE_DEAD = 4294967292,
	PERF_EVENT_STATE_EXIT = 4294967293,
	PERF_EVENT_STATE_ERROR = 4294967294,
	PERF_EVENT_STATE_OFF = 4294967295,
	PERF_EVENT_STATE_INACTIVE = 0,
	PERF_EVENT_STATE_ACTIVE = 1,
};

typedef struct {
	atomic_long_t a;
} local_t;

typedef struct {
	local_t a;
} local64_t;

struct perf_event_attr {
	__u32 type;
	__u32 size;
	__u64 config;
	union {
		__u64 sample_period;
		__u64 sample_freq;
	};
	__u64 sample_type;
	__u64 read_format;
	__u64 disabled: 1;
	__u64 inherit: 1;
	__u64 pinned: 1;
	__u64 exclusive: 1;
	__u64 exclude_user: 1;
	__u64 exclude_kernel: 1;
	__u64 exclude_hv: 1;
	__u64 exclude_idle: 1;
	__u64 mmap: 1;
	__u64 comm: 1;
	__u64 freq: 1;
	__u64 inherit_stat: 1;
	__u64 enable_on_exec: 1;
	__u64 task: 1;
	__u64 watermark: 1;
	__u64 precise_ip: 2;
	__u64 mmap_data: 1;
	__u64 sample_id_all: 1;
	__u64 exclude_host: 1;
	__u64 exclude_guest: 1;
	__u64 exclude_callchain_kernel: 1;
	__u64 exclude_callchain_user: 1;
	__u64 mmap2: 1;
	__u64 comm_exec: 1;
	__u64 use_clockid: 1;
	__u64 context_switch: 1;
	__u64 write_backward: 1;
	__u64 namespaces: 1;
	__u64 ksymbol: 1;
	__u64 bpf_event: 1;
	__u64 aux_output: 1;
	__u64 cgroup: 1;
	__u64 text_poke: 1;
	__u64 build_id: 1;
	__u64 inherit_thread: 1;
	__u64 remove_on_exec: 1;
	__u64 sigtrap: 1;
	__u64 __reserved_1: 26;
	union {
		__u32 wakeup_events;
		__u32 wakeup_watermark;
	};
	__u32 bp_type;
	union {
		__u64 bp_addr;
		__u64 kprobe_func;
		__u64 uprobe_path;
		__u64 config1;
	};
	union {
		__u64 bp_len;
		__u64 kprobe_addr;
		__u64 probe_offset;
		__u64 config2;
	};
	__u64 branch_sample_type;
	__u64 sample_regs_user;
	__u32 sample_stack_user;
	__s32 clockid;
	__u64 sample_regs_intr;
	__u32 aux_watermark;
	__u16 sample_max_stack;
	__u16 __reserved_2;
	__u32 aux_sample_size;
	__u32 __reserved_3;
	__u64 sig_data;
};

struct hw_perf_event_extra {
	u64 config;
	unsigned int reg;
	int alloc;
	int idx;
};

struct hw_perf_event {
	union {
		struct {
			u64 config;
			u64 last_tag;
			long unsigned int config_base;
			long unsigned int event_base;
			int event_base_rdpmc;
			int idx;
			int last_cpu;
			int flags;
			struct hw_perf_event_extra extra_reg;
			struct hw_perf_event_extra branch_reg;
		};
		struct {
			struct hrtimer hrtimer;
		};
		struct {
			struct list_head tp_list;
		};
		struct {
			u64 pwr_acc;
			u64 ptsc;
		};
		struct {
			struct arch_hw_breakpoint info;
			struct list_head bp_list;
		};
		struct {
			u8 iommu_bank;
			u8 iommu_cntr;
			u16 padding;
			u64 conf;
			u64 conf1;
		};
	};
	struct task_struct *target;
	void *addr_filters;
	long unsigned int addr_filters_gen;
	int state;
	local64_t prev_count;
	u64 sample_period;
	union {
		struct {
			u64 last_period;
			local64_t period_left;
		};
		struct {
			u64 saved_metric;
			u64 saved_slots;
		};
	};
	u64 interrupts_seq;
	u64 interrupts;
	u64 freq_time_stamp;
	u64 freq_count_stamp;
};

struct wait_queue_head {
	spinlock_t lock;
	struct list_head head;
};

typedef struct wait_queue_head wait_queue_head_t;

struct irq_work {
	struct __call_single_node node;
	void (*func)(struct irq_work *);
};

struct perf_addr_filters_head {
	struct list_head list;
	raw_spinlock_t lock;
	unsigned int nr_file_filters;
};

struct perf_sample_data;

typedef void (*perf_overflow_handler_t)(struct perf_event *, struct perf_sample_data *, struct pt_regs *);

struct ftrace_ops;

struct ftrace_regs;

typedef void (*ftrace_func_t)(long unsigned int, long unsigned int, struct ftrace_ops *, struct ftrace_regs *);

struct ftrace_hash;

struct ftrace_ops_hash {
	struct ftrace_hash *notrace_hash;
	struct ftrace_hash *filter_hash;
	struct mutex regex_lock;
};

struct ftrace_ops {
	ftrace_func_t func;
	struct ftrace_ops *next;
	long unsigned int flags;
	void *private;
	ftrace_func_t saved_func;
	struct ftrace_ops_hash local_hash;
	struct ftrace_ops_hash *func_hash;
	struct ftrace_ops_hash old_hash;
	long unsigned int trampoline;
	long unsigned int trampoline_size;
	struct list_head list;
};

struct pmu;

struct perf_buffer;

struct fasync_struct;

struct perf_addr_filter_range;

struct pid_namespace;

struct bpf_prog;

struct event_filter;

struct perf_cgroup;

struct perf_event {
	struct list_head event_entry;
	struct list_head sibling_list;
	struct list_head active_list;
	struct rb_node group_node;
	u64 group_index;
	struct list_head migrate_entry;
	struct hlist_node hlist_entry;
	struct list_head active_entry;
	int nr_siblings;
	int event_caps;
	int group_caps;
	struct perf_event *group_leader;
	struct pmu *pmu;
	void *pmu_private;
	enum perf_event_state state;
	unsigned int attach_state;
	local64_t count;
	atomic64_t child_count;
	u64 total_time_enabled;
	u64 total_time_running;
	u64 tstamp;
	struct perf_event_attr attr;
	u16 header_size;
	u16 id_header_size;
	u16 read_size;
	struct hw_perf_event hw;
	struct perf_event_context *ctx;
	atomic_long_t refcount;
	atomic64_t child_total_time_enabled;
	atomic64_t child_total_time_running;
	struct mutex child_mutex;
	struct list_head child_list;
	struct perf_event *parent;
	int oncpu;
	int cpu;
	struct list_head owner_entry;
	struct task_struct *owner;
	struct mutex mmap_mutex;
	atomic_t mmap_count;
	struct perf_buffer *rb;
	struct list_head rb_entry;
	long unsigned int rcu_batches;
	int rcu_pending;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
	int pending_wakeup;
	int pending_kill;
	int pending_disable;
	long unsigned int pending_addr;
	struct irq_work pending;
	atomic_t event_limit;
	struct perf_addr_filters_head addr_filters;
	struct perf_addr_filter_range *addr_filter_ranges;
	long unsigned int addr_filters_gen;
	struct perf_event *aux_event;
	void (*destroy)(struct perf_event *);
	struct callback_head callback_head;
	struct pid_namespace *ns;
	u64 id;
	u64 (*clock)();
	perf_overflow_handler_t overflow_handler;
	void *overflow_handler_context;
	perf_overflow_handler_t orig_overflow_handler;
	struct bpf_prog *prog;
	struct trace_event_call *tp_event;
	struct event_filter *filter;
	struct ftrace_ops ftrace_ops;
	struct perf_cgroup *cgrp;
	void *security;
	struct list_head sb_list;
};

struct wait_queue_entry;

typedef int (*wait_queue_func_t)(struct wait_queue_entry *, unsigned int, int, void *);

struct wait_queue_entry {
	unsigned int flags;
	void *private;
	wait_queue_func_t func;
	struct list_head entry;
};

typedef struct wait_queue_entry wait_queue_entry_t;

enum refcount_saturation_type {
	REFCOUNT_ADD_NOT_ZERO_OVF = 0,
	REFCOUNT_ADD_OVF = 1,
	REFCOUNT_ADD_UAF = 2,
	REFCOUNT_SUB_UAF = 3,
	REFCOUNT_DEC_LEAK = 4,
};

enum pid_type {
	PIDTYPE_PID = 0,
	PIDTYPE_TGID = 1,
	PIDTYPE_PGID = 2,
	PIDTYPE_SID = 3,
	PIDTYPE_MAX = 4,
};

struct upid {
	int nr;
	struct pid_namespace *ns;
};

struct xarray {
	spinlock_t xa_lock;
	gfp_t xa_flags;
	void *xa_head;
};

struct idr {
	struct xarray idr_rt;
	unsigned int idr_base;
	unsigned int idr_next;
};

struct proc_ns_operations;

struct ns_common {
	atomic_long_t stashed;
	const struct proc_ns_operations *ops;
	unsigned int inum;
	refcount_t count;
};

struct kmem_cache;

struct fs_pin;

struct user_namespace;

struct ucounts;

struct pid_namespace {
	struct idr idr;
	struct callback_head rcu;
	unsigned int pid_allocated;
	struct task_struct *child_reaper;
	struct kmem_cache *pid_cachep;
	unsigned int level;
	struct pid_namespace *parent;
	struct fs_pin *bacct;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	int reboot;
	struct ns_common ns;
};

struct pid {
	refcount_t count;
	unsigned int level;
	spinlock_t lock;
	struct hlist_head tasks[4];
	struct hlist_head inodes;
	wait_queue_head_t wait_pidfd;
	struct callback_head rcu;
	struct upid numbers[1];
};

struct uid_gid_extent {
	u32 first;
	u32 lower_first;
	u32 count;
};

struct uid_gid_map {
	u32 nr_extents;
	union {
		struct uid_gid_extent extent[5];
		struct {
			struct uid_gid_extent *forward;
			struct uid_gid_extent *reverse;
		};
	};
};

typedef struct {
	gid_t val;
} kgid_t;

struct rw_semaphore {
	atomic_long_t count;
	atomic_long_t owner;
	struct optimistic_spin_queue osq;
	raw_spinlock_t wait_lock;
	struct list_head wait_list;
};

struct work_struct;

typedef void (*work_func_t)(struct work_struct *);

struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
};

struct ctl_table;

struct ctl_table_root;

struct ctl_table_set;

struct ctl_dir;

struct ctl_node;

struct ctl_table_header {
	union {
		struct {
			struct ctl_table *ctl_table;
			int used;
			int count;
			int nreg;
		};
		struct callback_head rcu;
	};
	struct completion *unregistering;
	struct ctl_table *ctl_table_arg;
	struct ctl_table_root *root;
	struct ctl_table_set *set;
	struct ctl_dir *parent;
	struct ctl_node *node;
	struct hlist_head inodes;
};

struct ctl_dir {
	struct ctl_table_header header;
	struct rb_root root;
};

struct ctl_table_set {
	int (*is_seen)(struct ctl_table_set *);
	struct ctl_dir dir;
};

struct user_namespace {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	struct uid_gid_map projid_map;
	struct user_namespace *parent;
	int level;
	kuid_t owner;
	kgid_t group;
	struct ns_common ns;
	long unsigned int flags;
	bool parent_could_setfcap;
	struct list_head keyring_name_list;
	struct key *user_keyring_register;
	struct rw_semaphore keyring_sem;
	struct key *persistent_keyring_register;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	struct ucounts *ucounts;
	int ucount_max[12];
};

struct timer_list {
	struct hlist_node entry;
	long unsigned int expires;
	void (*function)(struct timer_list *);
	u32 flags;
};

struct workqueue_struct;

struct delayed_work {
	struct work_struct work;
	struct timer_list timer;
	struct workqueue_struct *wq;
	int cpu;
};

struct rcu_work {
	struct work_struct work;
	struct callback_head rcu;
	struct workqueue_struct *wq;
};

typedef struct page *pgtable_t;

struct address_space;

struct dev_pagemap;

struct page {
	long unsigned int flags;
	union {
		struct {
			struct list_head lru;
			struct address_space *mapping;
			long unsigned int index;
			long unsigned int private;
		};
		struct {
			long unsigned int dma_addr[2];
		};
		struct {
			union {
				struct list_head slab_list;
				struct {
					struct page *next;
					int pages;
					int pobjects;
				};
			};
			struct kmem_cache *slab_cache;
			void *freelist;
			union {
				void *s_mem;
				long unsigned int counters;
				struct {
					unsigned int inuse: 16;
					unsigned int objects: 15;
					unsigned int frozen: 1;
				};
			};
		};
		struct {
			long unsigned int compound_head;
			unsigned char compound_dtor;
			unsigned char compound_order;
			atomic_t compound_mapcount;
			unsigned int compound_nr;
		};
		struct {
			long unsigned int _compound_pad_1;
			atomic_t hpage_pinned_refcount;
			struct list_head deferred_list;
		};
		struct {
			long unsigned int _pt_pad_1;
			pgtable_t pmd_huge_pte;
			long unsigned int _pt_pad_2;
			union {
				struct mm_struct *pt_mm;
				atomic_t pt_frag_refcount;
			};
			spinlock_t ptl;
		};
		struct {
			struct dev_pagemap *pgmap;
			void *zone_device_data;
		};
		struct callback_head callback_head;
	};
	union {
		atomic_t _mapcount;
		unsigned int page_type;
		unsigned int active;
		int units;
	};
	atomic_t _refcount;
	long unsigned int memcg_data;
};

struct seqcount_raw_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_raw_spinlock seqcount_raw_spinlock_t;

typedef struct {
	seqcount_spinlock_t seqcount;
	spinlock_t lock;
} seqlock_t;

struct hrtimer_cpu_base;

struct hrtimer_clock_base {
	struct hrtimer_cpu_base *cpu_base;
	unsigned int index;
	clockid_t clockid;
	seqcount_raw_spinlock_t seq;
	struct hrtimer *running;
	struct timerqueue_head active;
	ktime_t (*get_time)();
	ktime_t offset;
};

struct hrtimer_cpu_base {
	raw_spinlock_t lock;
	unsigned int cpu;
	unsigned int active_bases;
	unsigned int clock_was_set_seq;
	unsigned int hres_active: 1;
	unsigned int in_hrtirq: 1;
	unsigned int hang_detected: 1;
	unsigned int softirq_activated: 1;
	unsigned int nr_events;
	short unsigned int nr_retries;
	short unsigned int nr_hangs;
	unsigned int max_hang_time;
	ktime_t expires_next;
	struct hrtimer *next_timer;
	ktime_t softirq_expires_next;
	struct hrtimer *softirq_next_timer;
	struct hrtimer_clock_base clock_base[8];
};

struct tick_device;

enum node_states {
	N_POSSIBLE = 0,
	N_ONLINE = 1,
	N_NORMAL_MEMORY = 2,
	N_HIGH_MEMORY = 2,
	N_MEMORY = 3,
	N_CPU = 4,
	N_GENERIC_INITIATOR = 5,
	NR_NODE_STATES = 6,
};

struct rlimit {
	__kernel_ulong_t rlim_cur;
	__kernel_ulong_t rlim_max;
};

struct task_cputime {
	u64 stime;
	u64 utime;
	long long unsigned int sum_exec_runtime;
};

typedef void __signalfn_t(int);

typedef __signalfn_t *__sighandler_t;

typedef void __restorefn_t();

typedef __restorefn_t *__sigrestore_t;

union sigval {
	int sival_int;
	void *sival_ptr;
};

typedef union sigval sigval_t;

union __sifields {
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
	} _kill;
	struct {
		__kernel_timer_t _tid;
		int _overrun;
		sigval_t _sigval;
		int _sys_private;
	} _timer;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		sigval_t _sigval;
	} _rt;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		int _status;
		__kernel_clock_t _utime;
		__kernel_clock_t _stime;
	} _sigchld;
	struct {
		void *_addr;
		union {
			int _trapno;
			short int _addr_lsb;
			struct {
				char _dummy_bnd[8];
				void *_lower;
				void *_upper;
			} _addr_bnd;
			struct {
				char _dummy_pkey[8];
				__u32 _pkey;
			} _addr_pkey;
			struct {
				long unsigned int _data;
				__u32 _type;
			} _perf;
		};
	} _sigfault;
	struct {
		long int _band;
		int _fd;
	} _sigpoll;
	struct {
		void *_call_addr;
		int _syscall;
		unsigned int _arch;
	} _sigsys;
};

struct kernel_siginfo {
	struct {
		int si_signo;
		int si_errno;
		int si_code;
		union __sifields _sifields;
	};
};

struct user_struct {
	refcount_t __count;
	atomic_t processes;
	atomic_t sigpending;
	atomic_long_t epoll_watches;
	long unsigned int mq_bytes;
	long unsigned int locked_shm;
	long unsigned int unix_inflight;
	atomic_long_t pipe_bufs;
	struct hlist_node uidhash_node;
	kuid_t uid;
	atomic_long_t locked_vm;
	atomic_t nr_watches;
	struct ratelimit_state ratelimit;
};

struct sigaction {
	__sighandler_t sa_handler;
	long unsigned int sa_flags;
	__sigrestore_t sa_restorer;
	sigset_t sa_mask;
};

struct k_sigaction {
	struct sigaction sa;
};

struct userfaultfd_ctx;

struct vm_userfaultfd_ctx {
	struct userfaultfd_ctx *ctx;
};

struct anon_vma;

struct vm_operations_struct;

struct vm_area_struct {
	long unsigned int vm_start;
	long unsigned int vm_end;
	struct vm_area_struct *vm_next;
	struct vm_area_struct *vm_prev;
	struct rb_node vm_rb;
	long unsigned int rb_subtree_gap;
	struct mm_struct *vm_mm;
	pgprot_t vm_page_prot;
	long unsigned int vm_flags;
	struct {
		struct rb_node rb;
		long unsigned int rb_subtree_last;
	} shared;
	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;
	const struct vm_operations_struct *vm_ops;
	long unsigned int vm_pgoff;
	struct file *vm_file;
	struct file *vm_prfile;
	void *vm_private_data;
	atomic_long_t swap_readahead_info;
	struct mempolicy *vm_policy;
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
};

struct mm_rss_stat {
	atomic_long_t count[4];
};

struct cpu_itimer {
	u64 expires;
	u64 incr;
};

struct task_cputime_atomic {
	atomic64_t utime;
	atomic64_t stime;
	atomic64_t sum_exec_runtime;
};

struct thread_group_cputimer {
	struct task_cputime_atomic cputime_atomic;
};

struct pacct_struct {
	int ac_flag;
	long int ac_exitcode;
	long unsigned int ac_mem;
	u64 ac_utime;
	u64 ac_stime;
	long unsigned int ac_minflt;
	long unsigned int ac_majflt;
};

struct tty_struct;

struct autogroup;

struct taskstats;

struct tty_audit_buf;

struct signal_struct {
	refcount_t sigcnt;
	atomic_t live;
	int nr_threads;
	struct list_head thread_head;
	wait_queue_head_t wait_chldexit;
	struct task_struct *curr_target;
	struct sigpending shared_pending;
	struct hlist_head multiprocess;
	int group_exit_code;
	int notify_count;
	struct task_struct *group_exit_task;
	int group_stop_count;
	unsigned int flags;
	unsigned int is_child_subreaper: 1;
	unsigned int has_child_subreaper: 1;
	int posix_timer_id;
	struct list_head posix_timers;
	struct hrtimer real_timer;
	ktime_t it_real_incr;
	struct cpu_itimer it[2];
	struct thread_group_cputimer cputimer;
	struct posix_cputimers posix_cputimers;
	struct pid *pids[4];
	struct pid *tty_old_pgrp;
	int leader;
	struct tty_struct *tty;
	struct autogroup *autogroup;
	seqlock_t stats_lock;
	u64 utime;
	u64 stime;
	u64 cutime;
	u64 cstime;
	u64 gtime;
	u64 cgtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	long unsigned int cnvcsw;
	long unsigned int cnivcsw;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	long unsigned int cmin_flt;
	long unsigned int cmaj_flt;
	long unsigned int inblock;
	long unsigned int oublock;
	long unsigned int cinblock;
	long unsigned int coublock;
	long unsigned int maxrss;
	long unsigned int cmaxrss;
	struct task_io_accounting ioac;
	long long unsigned int sum_sched_runtime;
	struct rlimit rlim[16];
	struct pacct_struct pacct;
	struct taskstats *stats;
	unsigned int audit_tty;
	struct tty_audit_buf *tty_audit_buf;
	bool oom_flag_origin;
	short int oom_score_adj;
	short int oom_score_adj_min;
	struct mm_struct *oom_mm;
	struct mutex cred_guard_mutex;
	struct rw_semaphore exec_update_lock;
};

struct rseq {
	__u32 cpu_id_start;
	__u32 cpu_id;
	union {
		__u64 ptr64;
		__u64 ptr;
	} rseq_cs;
	__u32 flags;
	long: 32;
	long: 64;
};

struct root_domain;

struct rq;

struct rq_flags;

struct sched_class {
	int uclamp_enabled;
	void (*enqueue_task)(struct rq *, struct task_struct *, int);
	void (*dequeue_task)(struct rq *, struct task_struct *, int);
	void (*yield_task)(struct rq *);
	bool (*yield_to_task)(struct rq *, struct task_struct *);
	void (*check_preempt_curr)(struct rq *, struct task_struct *, int);
	struct task_struct * (*pick_next_task)(struct rq *);
	void (*put_prev_task)(struct rq *, struct task_struct *);
	void (*set_next_task)(struct rq *, struct task_struct *, bool);
	int (*balance)(struct rq *, struct task_struct *, struct rq_flags *);
	int (*select_task_rq)(struct task_struct *, int, int);
	void (*migrate_task_rq)(struct task_struct *, int);
	void (*task_woken)(struct rq *, struct task_struct *);
	void (*set_cpus_allowed)(struct task_struct *, const struct cpumask *, u32);
	void (*rq_online)(struct rq *);
	void (*rq_offline)(struct rq *);
	struct rq * (*find_lock_rq)(struct task_struct *, struct rq *);
	void (*task_tick)(struct rq *, struct task_struct *, int);
	void (*task_fork)(struct task_struct *);
	void (*task_dead)(struct task_struct *);
	void (*switched_from)(struct rq *, struct task_struct *);
	void (*switched_to)(struct rq *, struct task_struct *);
	void (*prio_changed)(struct rq *, struct task_struct *, int);
	unsigned int (*get_rr_interval)(struct rq *, struct task_struct *);
	void (*update_curr)(struct rq *);
	void (*task_change_group)(struct task_struct *, int);
};

typedef struct {
	atomic64_t id;
	void *sigpage;
	refcount_t pinned;
	void *vdso;
	long unsigned int flags;
} mm_context_t;

struct xol_area;

struct uprobes_state {
	struct xol_area *xol_area;
};

struct linux_binfmt;

struct core_state;

struct kioctx_table;

struct mmu_notifier_subscriptions;

struct mm_struct {
	struct {
		struct vm_area_struct *mmap;
		struct rb_root mm_rb;
		u64 vmacache_seqnum;
		long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
		long unsigned int mmap_base;
		long unsigned int mmap_legacy_base;
		long unsigned int task_size;
		long unsigned int highest_vm_end;
		pgd_t *pgd;
		atomic_t membarrier_state;
		atomic_t mm_users;
		atomic_t mm_count;
		atomic_t has_pinned;
		atomic_long_t pgtables_bytes;
		int map_count;
		spinlock_t page_table_lock;
		struct rw_semaphore mmap_lock;
		struct list_head mmlist;
		long unsigned int hiwater_rss;
		long unsigned int hiwater_vm;
		long unsigned int total_vm;
		long unsigned int locked_vm;
		atomic64_t pinned_vm;
		long unsigned int data_vm;
		long unsigned int exec_vm;
		long unsigned int stack_vm;
		long unsigned int def_flags;
		seqcount_t write_protect_seq;
		spinlock_t arg_lock;
		long unsigned int start_code;
		long unsigned int end_code;
		long unsigned int start_data;
		long unsigned int end_data;
		long unsigned int start_brk;
		long unsigned int brk;
		long unsigned int start_stack;
		long unsigned int arg_start;
		long unsigned int arg_end;
		long unsigned int env_start;
		long unsigned int env_end;
		long unsigned int saved_auxv[46];
		struct mm_rss_stat rss_stat;
		struct linux_binfmt *binfmt;
		mm_context_t context;
		long unsigned int flags;
		struct core_state *core_state;
		spinlock_t ioctx_lock;
		struct kioctx_table *ioctx_table;
		struct task_struct *owner;
		struct user_namespace *user_ns;
		struct file *exe_file;
		struct mmu_notifier_subscriptions *notifier_subscriptions;
		long unsigned int numa_next_scan;
		long unsigned int numa_scan_offset;
		int numa_scan_seq;
		atomic_t tlb_flush_pending;
		struct uprobes_state uprobes_state;
		atomic_long_t hugetlb_usage;
		struct work_struct async_put_work;
		u32 pasid;
	};
	long unsigned int cpu_bitmap[0];
};

struct swait_queue_head {
	raw_spinlock_t lock;
	struct list_head task_list;
};

struct completion {
	unsigned int done;
	struct swait_queue_head wait;
};

struct kernel_cap_struct {
	__u32 cap[2];
};

typedef struct kernel_cap_struct kernel_cap_t;

struct group_info;

struct cred {
	atomic_t usage;
	kuid_t uid;
	kgid_t gid;
	kuid_t suid;
	kgid_t sgid;
	kuid_t euid;
	kgid_t egid;
	kuid_t fsuid;
	kgid_t fsgid;
	unsigned int securebits;
	kernel_cap_t cap_inheritable;
	kernel_cap_t cap_permitted;
	kernel_cap_t cap_effective;
	kernel_cap_t cap_bset;
	kernel_cap_t cap_ambient;
	unsigned char jit_keyring;
	struct key *session_keyring;
	struct key *process_keyring;
	struct key *thread_keyring;
	struct key *request_key_auth;
	void *security;
	struct user_struct *user;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct group_info *group_info;
	union {
		int non_rcu;
		struct callback_head rcu;
	};
};

typedef int32_t key_serial_t;

typedef uint32_t key_perm_t;

struct key_type;

struct key_tag;

struct keyring_index_key {
	long unsigned int hash;
	union {
		struct {
			u16 desc_len;
			char desc[6];
		};
		long unsigned int x;
	};
	struct key_type *type;
	struct key_tag *domain_tag;
	const char *description;
};

union key_payload {
	void *rcu_data0;
	void *data[4];
};

struct assoc_array_ptr;

struct assoc_array {
	struct assoc_array_ptr *root;
	long unsigned int nr_leaves_on_tree;
};

struct watch_list;

struct key_user;

struct key_restriction;

struct key {
	refcount_t usage;
	key_serial_t serial;
	union {
		struct list_head graveyard_link;
		struct rb_node serial_node;
	};
	struct watch_list *watchers;
	struct rw_semaphore sem;
	struct key_user *user;
	void *security;
	union {
		time64_t expiry;
		time64_t revoked_at;
	};
	time64_t last_used_at;
	kuid_t uid;
	kgid_t gid;
	key_perm_t perm;
	short unsigned int quotalen;
	short unsigned int datalen;
	short int state;
	long unsigned int flags;
	union {
		struct keyring_index_key index_key;
		struct {
			long unsigned int hash;
			long unsigned int len_desc;
			struct key_type *type;
			struct key_tag *domain_tag;
			char *description;
		};
	};
	union {
		union key_payload payload;
		struct {
			struct list_head name_link;
			struct assoc_array keys;
		};
	};
	struct key_restriction *restrict_link;
};

struct uts_namespace;

struct ipc_namespace;

struct mnt_namespace;

struct net;

struct time_namespace;

struct cgroup_namespace;

struct nsproxy {
	atomic_t count;
	struct uts_namespace *uts_ns;
	struct ipc_namespace *ipc_ns;
	struct mnt_namespace *mnt_ns;
	struct pid_namespace *pid_ns_for_children;
	struct net *net_ns;
	struct time_namespace *time_ns;
	struct time_namespace *time_ns_for_children;
	struct cgroup_namespace *cgroup_ns;
};

struct sighand_struct {
	spinlock_t siglock;
	refcount_t count;
	wait_queue_head_t signalfd_wqh;
	struct k_sigaction action[64];
};

struct bio;

struct bio_list {
	struct bio *head;
	struct bio *tail;
};

struct blk_plug {
	struct list_head mq_list;
	struct list_head cb_list;
	short unsigned int rq_count;
	bool multiple_queues;
	bool nowait;
};

struct reclaim_state {
	long unsigned int reclaimed_slab;
};

struct percpu_counter {
	raw_spinlock_t lock;
	s64 count;
	struct list_head list;
	s32 *counters;
};

struct fprop_local_percpu {
	struct percpu_counter events;
	unsigned int period;
	raw_spinlock_t lock;
};

enum wb_reason {
	WB_REASON_BACKGROUND = 0,
	WB_REASON_VMSCAN = 1,
	WB_REASON_SYNC = 2,
	WB_REASON_PERIODIC = 3,
	WB_REASON_LAPTOP_TIMER = 4,
	WB_REASON_FS_FREE_SPACE = 5,
	WB_REASON_FORKER_THREAD = 6,
	WB_REASON_FOREIGN_FLUSH = 7,
	WB_REASON_MAX = 8,
};

struct percpu_ref_data;

struct percpu_ref {
	long unsigned int percpu_count_ptr;
	struct percpu_ref_data *data;
};

struct cgroup_subsys_state;

struct bdi_writeback {
	struct backing_dev_info *bdi;
	long unsigned int state;
	long unsigned int last_old_flush;
	struct list_head b_dirty;
	struct list_head b_io;
	struct list_head b_more_io;
	struct list_head b_dirty_time;
	spinlock_t list_lock;
	struct percpu_counter stat[4];
	long unsigned int congested;
	long unsigned int bw_time_stamp;
	long unsigned int dirtied_stamp;
	long unsigned int written_stamp;
	long unsigned int write_bandwidth;
	long unsigned int avg_write_bandwidth;
	long unsigned int dirty_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	struct fprop_local_percpu completions;
	int dirty_exceeded;
	enum wb_reason start_all_reason;
	spinlock_t work_lock;
	struct list_head work_list;
	struct delayed_work dwork;
	long unsigned int dirty_sleep;
	struct list_head bdi_node;
	struct percpu_ref refcnt;
	struct fprop_local_percpu memcg_completions;
	struct cgroup_subsys_state *memcg_css;
	struct cgroup_subsys_state *blkcg_css;
	struct list_head memcg_node;
	struct list_head blkcg_node;
	union {
		struct work_struct release_work;
		struct callback_head rcu;
	};
};

struct device;

struct backing_dev_info {
	u64 id;
	struct rb_node rb_node;
	struct list_head bdi_list;
	long unsigned int ra_pages;
	long unsigned int io_pages;
	struct kref refcnt;
	unsigned int capabilities;
	unsigned int min_ratio;
	unsigned int max_ratio;
	unsigned int max_prop_frac;
	atomic_long_t tot_write_bandwidth;
	struct bdi_writeback wb;
	struct list_head wb_list;
	struct xarray cgwb_tree;
	struct mutex cgwb_release_mutex;
	struct rw_semaphore wb_switch_rwsem;
	wait_queue_head_t wb_waitq;
	struct device *dev;
	char dev_name[64];
	struct device *owner;
	struct timer_list laptop_mode_wb_timer;
	struct dentry *debug_dir;
};

struct io_cq;

struct io_context {
	atomic_long_t refcount;
	atomic_t active_ref;
	atomic_t nr_tasks;
	spinlock_t lock;
	short unsigned int ioprio;
	struct xarray icq_tree;
	struct io_cq *icq_hint;
	struct hlist_head icq_list;
	struct work_struct release_work;
};

struct cgroup;

struct css_set {
	struct cgroup_subsys_state *subsys[14];
	refcount_t refcount;
	struct css_set *dom_cset;
	struct cgroup *dfl_cgrp;
	int nr_tasks;
	struct list_head tasks;
	struct list_head mg_tasks;
	struct list_head dying_tasks;
	struct list_head task_iters;
	struct list_head e_cset_node[14];
	struct list_head threaded_csets;
	struct list_head threaded_csets_node;
	struct hlist_node hlist;
	struct list_head cgrp_links;
	struct list_head mg_preload_node;
	struct list_head mg_node;
	struct cgroup *mg_src_cgrp;
	struct cgroup *mg_dst_cgrp;
	struct css_set *mg_dst_cset;
	bool dead;
	struct callback_head callback_head;
};

struct compat_robust_list {
	compat_uptr_t next;
};

struct compat_robust_list_head {
	struct compat_robust_list list;
	compat_long_t futex_offset;
	compat_uptr_t list_op_pending;
};

struct perf_event_groups {
	struct rb_root tree;
	u64 index;
};

struct perf_event_context {
	struct pmu *pmu;
	raw_spinlock_t lock;
	struct mutex mutex;
	struct list_head active_ctx_list;
	struct perf_event_groups pinned_groups;
	struct perf_event_groups flexible_groups;
	struct list_head event_list;
	struct list_head pinned_active;
	struct list_head flexible_active;
	int nr_events;
	int nr_active;
	int is_active;
	int nr_stat;
	int nr_freq;
	int rotate_disable;
	int rotate_necessary;
	refcount_t refcount;
	struct task_struct *task;
	u64 time;
	u64 timestamp;
	u64 timeoffset;
	struct perf_event_context *parent_ctx;
	u64 parent_gen;
	u64 generation;
	int pin_count;
	int nr_cgroups;
	void *task_ctx_data;
	struct callback_head callback_head;
};

struct mempolicy {
	atomic_t refcnt;
	short unsigned int mode;
	short unsigned int flags;
	union {
		short int preferred_node;
		nodemask_t nodes;
	} v;
	union {
		nodemask_t cpuset_mems_allowed;
		nodemask_t user_nodemask;
	} w;
};

struct task_delay_info {
	raw_spinlock_t lock;
	unsigned int flags;
	u64 blkio_start;
	u64 blkio_delay;
	u64 swapin_delay;
	u32 blkio_count;
	u32 swapin_count;
	u64 freepages_start;
	u64 freepages_delay;
	u64 thrashing_start;
	u64 thrashing_delay;
	u32 freepages_count;
	u32 thrashing_count;
};

struct ftrace_ret_stack {
	long unsigned int ret;
	long unsigned int func;
	long long unsigned int calltime;
	long long unsigned int subtime;
	long unsigned int fp;
};

struct cgroup_subsys;

struct cgroup_subsys_state {
	struct cgroup *cgroup;
	struct cgroup_subsys *ss;
	struct percpu_ref refcnt;
	struct list_head sibling;
	struct list_head children;
	struct list_head rstat_css_node;
	int id;
	unsigned int flags;
	u64 serial_nr;
	atomic_t online_cnt;
	struct work_struct destroy_work;
	struct rcu_work destroy_rwork;
	struct cgroup_subsys_state *parent;
};

struct mem_cgroup_id {
	int id;
	refcount_t ref;
};

struct page_counter {
	atomic_long_t usage;
	long unsigned int min;
	long unsigned int low;
	long unsigned int high;
	long unsigned int max;
	long unsigned int emin;
	atomic_long_t min_usage;
	atomic_long_t children_min_usage;
	long unsigned int elow;
	atomic_long_t low_usage;
	atomic_long_t children_low_usage;
	long unsigned int watermark;
	long unsigned int failcnt;
	struct page_counter *parent;
};

struct vmpressure {
	long unsigned int scanned;
	long unsigned int reclaimed;
	long unsigned int tree_scanned;
	long unsigned int tree_reclaimed;
	spinlock_t sr_lock;
	struct list_head events;
	struct mutex events_lock;
	struct work_struct work;
};

struct cgroup_file {
	struct kernfs_node *kn;
	long unsigned int notified_at;
	struct timer_list notify_timer;
};

struct mem_cgroup_threshold_ary;

struct mem_cgroup_thresholds {
	struct mem_cgroup_threshold_ary *primary;
	struct mem_cgroup_threshold_ary *spare;
};

struct memcg_padding {
	char x[0];
};

struct memcg_vmstats {
	long int state[42];
	long unsigned int events[97];
	long int state_pending[42];
	long unsigned int events_pending[97];
};

enum memcg_kmem_state {
	KMEM_NONE = 0,
	KMEM_ALLOCATED = 1,
	KMEM_ONLINE = 2,
};

struct fprop_global {
	struct percpu_counter events;
	unsigned int period;
	seqcount_t sequence;
};

struct wb_domain {
	spinlock_t lock;
	struct fprop_global completions;
	struct timer_list period_timer;
	long unsigned int period_time;
	long unsigned int dirty_limit_tstamp;
	long unsigned int dirty_limit;
};

struct wb_completion {
	atomic_t cnt;
	wait_queue_head_t *waitq;
};

struct memcg_cgwb_frn {
	u64 bdi_id;
	int memcg_id;
	u64 at;
	struct wb_completion done;
};

struct deferred_split {
	spinlock_t split_queue_lock;
	struct list_head split_queue;
	long unsigned int split_queue_len;
};

struct obj_cgroup;

struct memcg_vmstats_percpu;

struct mem_cgroup_per_node;

struct mem_cgroup {
	struct cgroup_subsys_state css;
	struct mem_cgroup_id id;
	struct page_counter memory;
	union {
		struct page_counter swap;
		struct page_counter memsw;
	};
	struct page_counter kmem;
	struct page_counter tcpmem;
	struct work_struct high_work;
	long unsigned int soft_limit;
	struct vmpressure vmpressure;
	bool oom_group;
	bool oom_lock;
	int under_oom;
	int swappiness;
	int oom_kill_disable;
	struct cgroup_file events_file;
	struct cgroup_file events_local_file;
	struct cgroup_file swap_events_file;
	struct mutex thresholds_lock;
	struct mem_cgroup_thresholds thresholds;
	struct mem_cgroup_thresholds memsw_thresholds;
	struct list_head oom_notify;
	long unsigned int move_charge_at_immigrate;
	spinlock_t move_lock;
	long unsigned int move_lock_flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct memcg_padding _pad1_;
	struct memcg_vmstats vmstats;
	atomic_long_t memory_events[8];
	atomic_long_t memory_events_local[8];
	long unsigned int socket_pressure;
	bool tcpmem_active;
	int tcpmem_pressure;
	int kmemcg_id;
	enum memcg_kmem_state kmem_state;
	struct obj_cgroup *objcg;
	struct list_head objcg_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct memcg_padding _pad2_;
	atomic_t moving_account;
	struct task_struct *move_lock_task;
	struct memcg_vmstats_percpu *vmstats_percpu;
	struct list_head cgwb_list;
	struct wb_domain cgwb_domain;
	struct memcg_cgwb_frn cgwb_frn[4];
	struct list_head event_list;
	spinlock_t event_list_lock;
	struct deferred_split deferred_split_queue;
	struct mem_cgroup_per_node *nodeinfo[0];
	long: 64;
};

struct blk_integrity_profile;

struct blk_integrity {
	const struct blk_integrity_profile *profile;
	unsigned char flags;
	unsigned char tuple_size;
	unsigned char interval_exp;
	unsigned char tag_size;
};

enum rpm_status {
	RPM_ACTIVE = 0,
	RPM_RESUMING = 1,
	RPM_SUSPENDED = 2,
	RPM_SUSPENDING = 3,
};

struct blk_rq_stat {
	u64 mean;
	u64 min;
	u64 max;
	u32 nr_samples;
	u64 batch;
};

enum blk_bounce {
	BLK_BOUNCE_NONE = 0,
	BLK_BOUNCE_HIGH = 1,
};

enum blk_zoned_model {
	BLK_ZONED_NONE = 0,
	BLK_ZONED_HA = 1,
	BLK_ZONED_HM = 2,
};

struct queue_limits {
	enum blk_bounce bounce;
	long unsigned int seg_boundary_mask;
	long unsigned int virt_boundary_mask;
	unsigned int max_hw_sectors;
	unsigned int max_dev_sectors;
	unsigned int chunk_sectors;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	unsigned int physical_block_size;
	unsigned int logical_block_size;
	unsigned int alignment_offset;
	unsigned int io_min;
	unsigned int io_opt;
	unsigned int max_discard_sectors;
	unsigned int max_hw_discard_sectors;
	unsigned int max_write_same_sectors;
	unsigned int max_write_zeroes_sectors;
	unsigned int max_zone_append_sectors;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	unsigned int zone_write_granularity;
	short unsigned int max_segments;
	short unsigned int max_integrity_segments;
	short unsigned int max_discard_segments;
	unsigned char misaligned;
	unsigned char discard_misaligned;
	unsigned char raid_partial_stripes_expensive;
	enum blk_zoned_model zoned;
};

struct bsg_ops;

struct bsg_class_device {
	struct device *class_dev;
	int minor;
	struct request_queue *queue;
	const struct bsg_ops *ops;
};

typedef void *mempool_alloc_t(gfp_t, void *);

typedef void mempool_free_t(void *, void *);

struct mempool_s {
	spinlock_t lock;
	int min_nr;
	int curr_nr;
	void **elements;
	void *pool_data;
	mempool_alloc_t *alloc;
	mempool_free_t *free;
	wait_queue_head_t wait;
};

typedef struct mempool_s mempool_t;

struct bio_set {
	struct kmem_cache *bio_slab;
	unsigned int front_pad;
	mempool_t bio_pool;
	mempool_t bvec_pool;
	mempool_t bio_integrity_pool;
	mempool_t bvec_integrity_pool;
	unsigned int back_pad;
	spinlock_t rescue_lock;
	struct bio_list rescue_list;
	struct work_struct rescue_work;
	struct workqueue_struct *rescue_workqueue;
};

struct request;

struct elevator_queue;

struct blk_queue_stats;

struct rq_qos;

struct blk_mq_ops;

struct blk_mq_ctx;

struct blk_mq_hw_ctx;

struct blk_keyslot_manager;

struct blk_stat_callback;

struct blkcg_gq;

struct blk_trace;

struct blk_flush_queue;

struct throtl_data;

struct blk_mq_tag_set;

struct request_queue {
	struct request *last_merge;
	struct elevator_queue *elevator;
	struct percpu_ref q_usage_counter;
	struct blk_queue_stats *stats;
	struct rq_qos *rq_qos;
	const struct blk_mq_ops *mq_ops;
	struct blk_mq_ctx *queue_ctx;
	unsigned int queue_depth;
	struct blk_mq_hw_ctx **queue_hw_ctx;
	unsigned int nr_hw_queues;
	struct backing_dev_info *backing_dev_info;
	void *queuedata;
	long unsigned int queue_flags;
	atomic_t pm_only;
	int id;
	spinlock_t queue_lock;
	struct kobject kobj;
	struct kobject *mq_kobj;
	struct blk_integrity integrity;
	struct device *dev;
	enum rpm_status rpm_status;
	long unsigned int nr_requests;
	unsigned int dma_pad_mask;
	unsigned int dma_alignment;
	struct blk_keyslot_manager *ksm;
	unsigned int rq_timeout;
	int poll_nsec;
	struct blk_stat_callback *poll_cb;
	struct blk_rq_stat poll_stat[16];
	struct timer_list timeout;
	struct work_struct timeout_work;
	atomic_t nr_active_requests_shared_sbitmap;
	struct list_head icq_list;
	long unsigned int blkcg_pols[1];
	struct blkcg_gq *root_blkg;
	struct list_head blkg_list;
	struct queue_limits limits;
	unsigned int required_elevator_features;
	unsigned int nr_zones;
	long unsigned int *conv_zones_bitmap;
	long unsigned int *seq_zones_wlock;
	unsigned int max_open_zones;
	unsigned int max_active_zones;
	unsigned int sg_timeout;
	unsigned int sg_reserved_size;
	int node;
	struct mutex debugfs_mutex;
	struct blk_trace *blk_trace;
	struct blk_flush_queue *fq;
	struct list_head requeue_list;
	spinlock_t requeue_lock;
	struct delayed_work requeue_work;
	struct mutex sysfs_lock;
	struct mutex sysfs_dir_lock;
	struct list_head unused_hctx_list;
	spinlock_t unused_hctx_lock;
	int mq_freeze_depth;
	struct bsg_class_device bsg_dev;
	struct throtl_data *td;
	struct callback_head callback_head;
	wait_queue_head_t mq_freeze_wq;
	struct mutex mq_freeze_lock;
	struct blk_mq_tag_set *tag_set;
	struct list_head tag_set_list;
	struct bio_set bio_split;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct dentry *rqos_debugfs_dir;
	bool mq_sysfs_init_done;
	size_t cmd_size;
	u64 write_hints[5];
};

enum uprobe_task_state {
	UTASK_RUNNING = 0,
	UTASK_SSTEP = 1,
	UTASK_SSTEP_ACK = 2,
	UTASK_SSTEP_TRAPPED = 3,
};

struct arch_uprobe_task {};

struct uprobe;

struct return_instance;

struct uprobe_task {
	enum uprobe_task_state state;
	union {
		struct {
			struct arch_uprobe_task autask;
			long unsigned int vaddr;
		};
		struct {
			struct callback_head dup_xol_work;
			long unsigned int dup_xol_addr;
		};
	};
	struct uprobe *active_uprobe;
	long unsigned int xol_vaddr;
	struct return_instance *return_instances;
	unsigned int depth;
};

struct vm_struct {
	struct vm_struct *next;
	void *addr;
	long unsigned int size;
	long unsigned int flags;
	struct page **pages;
	unsigned int nr_pages;
	phys_addr_t phys_addr;
	const void *caller;
};

union thread_union {
	struct task_struct task;
	long unsigned int stack[2048];
};

struct kstat {
	u32 result_mask;
	umode_t mode;
	unsigned int nlink;
	uint32_t blksize;
	u64 attributes;
	u64 attributes_mask;
	u64 ino;
	dev_t dev;
	dev_t rdev;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	struct timespec64 btime;
	u64 blocks;
	u64 mnt_id;
};

typedef u32 probe_opcode_t;

typedef void probes_handler_t(u32, long int, struct pt_regs *);

struct arch_probe_insn {
	probe_opcode_t *insn;
	pstate_check_t *pstate_cc;
	probes_handler_t *handler;
	long unsigned int restore;
};

typedef u32 kprobe_opcode_t;

struct arch_specific_insn {
	struct arch_probe_insn api;
};

struct return_instance {
	struct uprobe *uprobe;
	long unsigned int func;
	long unsigned int stack;
	long unsigned int orig_ret_vaddr;
	bool chained;
	struct return_instance *next;
};

typedef u32 errseq_t;

struct address_space_operations;

struct address_space {
	struct inode *host;
	struct xarray i_pages;
	gfp_t gfp_mask;
	atomic_t i_mmap_writable;
	struct rb_root_cached i_mmap;
	struct rw_semaphore i_mmap_rwsem;
	long unsigned int nrpages;
	long unsigned int writeback_index;
	const struct address_space_operations *a_ops;
	long unsigned int flags;
	errseq_t wb_err;
	spinlock_t private_lock;
	struct list_head private_list;
	void *private_data;
};

struct vmem_altmap {
	long unsigned int base_pfn;
	const long unsigned int end_pfn;
	const long unsigned int reserve;
	long unsigned int free;
	long unsigned int align;
	long unsigned int alloc;
};

enum memory_type {
	MEMORY_DEVICE_PRIVATE = 1,
	MEMORY_DEVICE_FS_DAX = 2,
	MEMORY_DEVICE_GENERIC = 3,
	MEMORY_DEVICE_PCI_P2PDMA = 4,
};

struct range {
	u64 start;
	u64 end;
};

struct dev_pagemap_ops;

struct dev_pagemap {
	struct vmem_altmap altmap;
	struct percpu_ref *ref;
	struct percpu_ref internal_ref;
	struct completion done;
	enum memory_type type;
	unsigned int flags;
	const struct dev_pagemap_ops *ops;
	void *owner;
	int nr_range;
	union {
		struct range range;
		struct range ranges[0];
	};
};

struct vfsmount;

struct path {
	struct vfsmount *mnt;
	struct dentry *dentry;
};

enum rw_hint {
	WRITE_LIFE_NOT_SET = 0,
	WRITE_LIFE_NONE = 1,
	WRITE_LIFE_SHORT = 2,
	WRITE_LIFE_MEDIUM = 3,
	WRITE_LIFE_LONG = 4,
	WRITE_LIFE_EXTREME = 5,
};

struct fown_struct {
	rwlock_t lock;
	struct pid *pid;
	enum pid_type pid_type;
	kuid_t uid;
	kuid_t euid;
	int signum;
};

struct file_ra_state {
	long unsigned int start;
	unsigned int size;
	unsigned int async_size;
	unsigned int ra_pages;
	unsigned int mmap_miss;
	loff_t prev_pos;
};

struct file {
	union {
		struct llist_node fu_llist;
		struct callback_head fu_rcuhead;
	} f_u;
	struct path f_path;
	struct inode *f_inode;
	const struct file_operations *f_op;
	spinlock_t f_lock;
	enum rw_hint f_write_hint;
	atomic_long_t f_count;
	unsigned int f_flags;
	fmode_t f_mode;
	struct mutex f_pos_lock;
	loff_t f_pos;
	struct fown_struct f_owner;
	const struct cred *f_cred;
	struct file_ra_state f_ra;
	u64 f_version;
	void *f_security;
	void *private_data;
	struct hlist_head *f_ep;
	struct address_space *f_mapping;
	errseq_t f_wb_err;
	errseq_t f_sb_err;
};

struct anon_vma {
	struct anon_vma *root;
	struct rw_semaphore rwsem;
	atomic_t refcount;
	unsigned int degree;
	struct anon_vma *parent;
	struct rb_root_cached rb_root;
};

typedef unsigned int vm_fault_t;

enum page_entry_size {
	PE_SIZE_PTE = 0,
	PE_SIZE_PMD = 1,
	PE_SIZE_PUD = 2,
};

struct vm_fault;

struct vm_operations_struct {
	void (*open)(struct vm_area_struct *);
	void (*close)(struct vm_area_struct *);
	int (*may_split)(struct vm_area_struct *, long unsigned int);
	int (*mremap)(struct vm_area_struct *);
	int (*mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int);
	vm_fault_t (*fault)(struct vm_fault *);
	vm_fault_t (*huge_fault)(struct vm_fault *, enum page_entry_size);
	vm_fault_t (*map_pages)(struct vm_fault *, long unsigned int, long unsigned int);
	long unsigned int (*pagesize)(struct vm_area_struct *);
	vm_fault_t (*page_mkwrite)(struct vm_fault *);
	vm_fault_t (*pfn_mkwrite)(struct vm_fault *);
	int (*access)(struct vm_area_struct *, long unsigned int, void *, int, int);
	const char * (*name)(struct vm_area_struct *);
	int (*set_policy)(struct vm_area_struct *, struct mempolicy *);
	struct mempolicy * (*get_policy)(struct vm_area_struct *, long unsigned int);
	struct page * (*find_special_page)(struct vm_area_struct *, long unsigned int);
};

struct core_thread {
	struct task_struct *task;
	struct core_thread *next;
};

struct core_state {
	atomic_t nr_threads;
	struct core_thread dumper;
	struct completion startup;
};

struct linux_binprm;

struct coredump_params;

struct linux_binfmt {
	struct list_head lh;
	struct module *module;
	int (*load_binary)(struct linux_binprm *);
	int (*load_shlib)(struct file *);
	int (*core_dump)(struct coredump_params *);
	long unsigned int min_coredump;
};

enum fault_flag {
	FAULT_FLAG_WRITE = 1,
	FAULT_FLAG_MKWRITE = 2,
	FAULT_FLAG_ALLOW_RETRY = 4,
	FAULT_FLAG_RETRY_NOWAIT = 8,
	FAULT_FLAG_KILLABLE = 16,
	FAULT_FLAG_TRIED = 32,
	FAULT_FLAG_USER = 64,
	FAULT_FLAG_REMOTE = 128,
	FAULT_FLAG_INSTRUCTION = 256,
	FAULT_FLAG_INTERRUPTIBLE = 512,
};

struct vm_fault {
	const struct {
		struct vm_area_struct *vma;
		gfp_t gfp_mask;
		long unsigned int pgoff;
		long unsigned int address;
	};
	enum fault_flag flags;
	pmd_t *pmd;
	pud_t *pud;
	pte_t orig_pte;
	struct page *cow_page;
	struct page *page;
	pte_t *pte;
	spinlock_t *ptl;
	pgtable_t prealloc_pte;
};

struct free_area {
	struct list_head free_list[6];
	long unsigned int nr_free;
};

struct zone_padding {
	char x[0];
};

enum node_stat_item {
	NR_LRU_BASE = 0,
	NR_INACTIVE_ANON = 0,
	NR_ACTIVE_ANON = 1,
	NR_INACTIVE_FILE = 2,
	NR_ACTIVE_FILE = 3,
	NR_UNEVICTABLE = 4,
	NR_SLAB_RECLAIMABLE_B = 5,
	NR_SLAB_UNRECLAIMABLE_B = 6,
	NR_ISOLATED_ANON = 7,
	NR_ISOLATED_FILE = 8,
	WORKINGSET_NODES = 9,
	WORKINGSET_REFAULT_BASE = 10,
	WORKINGSET_REFAULT_ANON = 10,
	WORKINGSET_REFAULT_FILE = 11,
	WORKINGSET_ACTIVATE_BASE = 12,
	WORKINGSET_ACTIVATE_ANON = 12,
	WORKINGSET_ACTIVATE_FILE = 13,
	WORKINGSET_RESTORE_BASE = 14,
	WORKINGSET_RESTORE_ANON = 14,
	WORKINGSET_RESTORE_FILE = 15,
	WORKINGSET_NODERECLAIM = 16,
	NR_ANON_MAPPED = 17,
	NR_FILE_MAPPED = 18,
	NR_FILE_PAGES = 19,
	NR_FILE_DIRTY = 20,
	NR_WRITEBACK = 21,
	NR_WRITEBACK_TEMP = 22,
	NR_SHMEM = 23,
	NR_SHMEM_THPS = 24,
	NR_SHMEM_PMDMAPPED = 25,
	NR_FILE_THPS = 26,
	NR_FILE_PMDMAPPED = 27,
	NR_ANON_THPS = 28,
	NR_VMSCAN_WRITE = 29,
	NR_VMSCAN_IMMEDIATE = 30,
	NR_DIRTIED = 31,
	NR_WRITTEN = 32,
	NR_KERNEL_MISC_RECLAIMABLE = 33,
	NR_FOLL_PIN_ACQUIRED = 34,
	NR_FOLL_PIN_RELEASED = 35,
	NR_KERNEL_STACK_KB = 36,
	NR_PAGETABLE = 37,
	NR_SWAPCACHE = 38,
	NR_VM_NODE_STAT_ITEMS = 39,
};

enum lru_list {
	LRU_INACTIVE_ANON = 0,
	LRU_ACTIVE_ANON = 1,
	LRU_INACTIVE_FILE = 2,
	LRU_ACTIVE_FILE = 3,
	LRU_UNEVICTABLE = 4,
	NR_LRU_LISTS = 5,
};

struct pglist_data;

struct lruvec {
	struct list_head lists[5];
	spinlock_t lru_lock;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	atomic_long_t nonresident_age;
	long unsigned int refaults[2];
	long unsigned int flags;
	struct pglist_data *pgdat;
};

struct per_cpu_pageset;

struct zone {
	long unsigned int _watermark[3];
	long unsigned int watermark_boost;
	long unsigned int nr_reserved_highatomic;
	long int lowmem_reserve[5];
	int node;
	struct pglist_data *zone_pgdat;
	struct per_cpu_pageset *pageset;
	int pageset_high;
	int pageset_batch;
	long unsigned int zone_start_pfn;
	atomic_long_t managed_pages;
	long unsigned int spanned_pages;
	long unsigned int present_pages;
	long unsigned int cma_pages;
	const char *name;
	long unsigned int nr_isolate_pageblock;
	seqlock_t span_seqlock;
	int initialized;
	long: 32;
	long: 64;
	struct zone_padding _pad1_;
	struct free_area free_area[13];
	long unsigned int flags;
	spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad2_;
	long unsigned int percpu_drift_mark;
	long unsigned int compact_cached_free_pfn;
	long unsigned int compact_cached_migrate_pfn[2];
	long unsigned int compact_init_migrate_pfn;
	long unsigned int compact_init_free_pfn;
	unsigned int compact_considered;
	unsigned int compact_defer_shift;
	int compact_order_failed;
	bool compact_blockskip_flush;
	bool contiguous;
	short: 16;
	struct zone_padding _pad3_;
	atomic_long_t vm_stat[11];
	atomic_long_t vm_numa_stat[6];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct zoneref {
	struct zone *zone;
	int zone_idx;
};

struct zonelist {
	struct zoneref _zonerefs[321];
};

enum zone_type {
	ZONE_DMA = 0,
	ZONE_DMA32 = 1,
	ZONE_NORMAL = 2,
	ZONE_MOVABLE = 3,
	ZONE_DEVICE = 4,
	__MAX_NR_ZONES = 5,
};

struct per_cpu_nodestat;

struct pglist_data {
	struct zone node_zones[5];
	struct zonelist node_zonelists[2];
	int nr_zones;
	spinlock_t node_size_lock;
	long unsigned int node_start_pfn;
	long unsigned int node_present_pages;
	long unsigned int node_spanned_pages;
	int node_id;
	wait_queue_head_t kswapd_wait;
	wait_queue_head_t pfmemalloc_wait;
	struct task_struct *kswapd;
	int kswapd_order;
	enum zone_type kswapd_highest_zoneidx;
	int kswapd_failures;
	int kcompactd_max_order;
	enum zone_type kcompactd_highest_zoneidx;
	wait_queue_head_t kcompactd_wait;
	struct task_struct *kcompactd;
	long unsigned int totalreserve_pages;
	long unsigned int min_unmapped_pages;
	long unsigned int min_slab_pages;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad1_;
	struct deferred_split deferred_split_queue;
	struct lruvec __lruvec;
	long unsigned int flags;
	long: 64;
	struct zone_padding _pad2_;
	struct per_cpu_nodestat *per_cpu_nodestats;
	atomic_long_t vm_stat[39];
};

typedef unsigned int isolate_mode_t;

struct per_cpu_pages {
	int count;
	int high;
	int batch;
	struct list_head lists[3];
};

struct per_cpu_pageset {
	struct per_cpu_pages pcp;
	s8 expire;
	u16 vm_numa_stat_diff[6];
	s8 stat_threshold;
	s8 vm_stat_diff[11];
};

struct per_cpu_nodestat {
	s8 stat_threshold;
	s8 vm_node_stat_diff[39];
};

typedef struct pglist_data pg_data_t;

struct rcu_segcblist {
	struct callback_head *head;
	struct callback_head **tails[4];
	long unsigned int gp_seq[4];
	long int len;
	long int seglen[4];
	u8 flags;
};

struct srcu_node;

struct srcu_data {
	long unsigned int srcu_lock_count[2];
	long unsigned int srcu_unlock_count[2];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t lock;
	struct rcu_segcblist srcu_cblist;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	bool srcu_cblist_invoking;
	struct timer_list delay_work;
	struct work_struct work;
	struct callback_head srcu_barrier_head;
	struct srcu_node *mynode;
	long unsigned int grpmask;
	int cpu;
	struct srcu_struct *ssp;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct srcu_node {
	spinlock_t lock;
	long unsigned int srcu_have_cbs[4];
	long unsigned int srcu_data_have_cbs[4];
	long unsigned int srcu_gp_seq_needed_exp;
	struct srcu_node *srcu_parent;
	int grplo;
	int grphi;
};

struct srcu_struct {
	struct srcu_node node[17];
	struct srcu_node *level[3];
	struct mutex srcu_cb_mutex;
	spinlock_t lock;
	struct mutex srcu_gp_mutex;
	unsigned int srcu_idx;
	long unsigned int srcu_gp_seq;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	long unsigned int srcu_last_gp_end;
	struct srcu_data *sda;
	long unsigned int srcu_barrier_seq;
	struct mutex srcu_barrier_mutex;
	struct completion srcu_barrier_completion;
	atomic_t srcu_barrier_cpu_cnt;
	struct delayed_work work;
};

typedef int (*notifier_fn_t)(struct notifier_block *, long unsigned int, void *);

struct notifier_block {
	notifier_fn_t notifier_call;
	struct notifier_block *next;
	int priority;
};

struct blocking_notifier_head {
	struct rw_semaphore rwsem;
	struct notifier_block *head;
};

struct cpu_topology {
	int thread_id;
	int core_id;
	int package_id;
	int llc_id;
	cpumask_t thread_sibling;
	cpumask_t core_sibling;
	cpumask_t llc_sibling;
};

struct mem_section_usage {
	long unsigned int subsection_map[1];
	long unsigned int pageblock_flags[0];
};

struct mem_section {
	long unsigned int section_mem_map;
	struct mem_section_usage *usage;
};

typedef int proc_handler(struct ctl_table *, int, void *, size_t *, loff_t *);

struct ctl_table_poll;

struct ctl_table {
	const char *procname;
	void *data;
	int maxlen;
	umode_t mode;
	struct ctl_table *child;
	proc_handler *proc_handler;
	struct ctl_table_poll *poll;
	void *extra1;
	void *extra2;
};

struct ctl_table_poll {
	atomic_t event;
	wait_queue_head_t wait;
};

struct ctl_node {
	struct rb_node node;
	struct ctl_table_header *header;
};

struct ctl_table_root {
	struct ctl_table_set default_set;
	struct ctl_table_set * (*lookup)(struct ctl_table_root *);
	void (*set_ownership)(struct ctl_table_header *, struct ctl_table *, kuid_t *, kgid_t *);
	int (*permissions)(struct ctl_table_header *, struct ctl_table *);
};

typedef __u64 Elf64_Addr;

typedef __u16 Elf64_Half;

typedef __u32 Elf64_Word;

typedef __u64 Elf64_Xword;

typedef __s64 Elf64_Sxword;

typedef struct {
	Elf64_Sxword d_tag;
	union {
		Elf64_Xword d_val;
		Elf64_Addr d_ptr;
	} d_un;
} Elf64_Dyn;

struct elf64_sym {
	Elf64_Word st_name;
	unsigned char st_info;
	unsigned char st_other;
	Elf64_Half st_shndx;
	Elf64_Addr st_value;
	Elf64_Xword st_size;
};

struct hlist_bl_node;

struct hlist_bl_head {
	struct hlist_bl_node *first;
};

struct hlist_bl_node {
	struct hlist_bl_node *next;
	struct hlist_bl_node **pprev;
};

struct lockref {
	union {
		__u64 lock_count;
		struct {
			spinlock_t lock;
			int count;
		};
	};
};

struct qstr {
	union {
		struct {
			u32 hash;
			u32 len;
		};
		u64 hash_len;
	};
	const unsigned char *name;
};

struct dentry_stat_t {
	long int nr_dentry;
	long int nr_unused;
	long int age_limit;
	long int want_pages;
	long int nr_negative;
	long int dummy;
};

struct dentry_operations;

struct dentry {
	unsigned int d_flags;
	seqcount_spinlock_t d_seq;
	struct hlist_bl_node d_hash;
	struct dentry *d_parent;
	struct qstr d_name;
	struct inode *d_inode;
	unsigned char d_iname[32];
	struct lockref d_lockref;
	const struct dentry_operations *d_op;
	struct super_block *d_sb;
	long unsigned int d_time;
	void *d_fsdata;
	union {
		struct list_head d_lru;
		wait_queue_head_t *d_wait;
	};
	struct list_head d_child;
	struct list_head d_subdirs;
	union {
		struct hlist_node d_alias;
		struct hlist_bl_node d_in_lookup_hash;
		struct callback_head d_rcu;
	} d_u;
};

struct posix_acl;

struct inode_operations;

struct file_lock_context;

struct cdev;

struct fsnotify_mark_connector;

struct fscrypt_info;

struct fsverity_info;

struct inode {
	umode_t i_mode;
	short unsigned int i_opflags;
	kuid_t i_uid;
	kgid_t i_gid;
	unsigned int i_flags;
	struct posix_acl *i_acl;
	struct posix_acl *i_default_acl;
	const struct inode_operations *i_op;
	struct super_block *i_sb;
	struct address_space *i_mapping;
	void *i_security;
	long unsigned int i_ino;
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t i_rdev;
	loff_t i_size;
	struct timespec64 i_atime;
	struct timespec64 i_mtime;
	struct timespec64 i_ctime;
	spinlock_t i_lock;
	short unsigned int i_bytes;
	u8 i_blkbits;
	u8 i_write_hint;
	blkcnt_t i_blocks;
	long unsigned int i_state;
	struct rw_semaphore i_rwsem;
	long unsigned int dirtied_when;
	long unsigned int dirtied_time_when;
	struct hlist_node i_hash;
	struct list_head i_io_list;
	struct bdi_writeback *i_wb;
	int i_wb_frn_winner;
	u16 i_wb_frn_avg_time;
	u16 i_wb_frn_history;
	struct list_head i_lru;
	struct list_head i_sb_list;
	struct list_head i_wb_list;
	union {
		struct hlist_head i_dentry;
		struct callback_head i_rcu;
	};
	atomic64_t i_version;
	atomic64_t i_sequence;
	atomic_t i_count;
	atomic_t i_dio_count;
	atomic_t i_writecount;
	atomic_t i_readcount;
	union {
		const struct file_operations *i_fop;
		void (*free_inode)(struct inode *);
	};
	struct file_lock_context *i_flctx;
	struct address_space i_data;
	struct list_head i_devices;
	union {
		struct pipe_inode_info *i_pipe;
		struct cdev *i_cdev;
		char *i_link;
		unsigned int i_dir_seq;
	};
	__u32 i_generation;
	__u32 i_fsnotify_mask;
	struct fsnotify_mark_connector *i_fsnotify_marks;
	struct fscrypt_info *i_crypt_info;
	struct fsverity_info *i_verity_info;
	void *i_private;
};

struct dentry_operations {
	int (*d_revalidate)(struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	int (*d_init)(struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char * (*d_dname)(struct dentry *, char *, int);
	struct vfsmount * (*d_automount)(struct path *);
	int (*d_manage)(const struct path *, bool);
	struct dentry * (*d_real)(struct dentry *, const struct inode *);
	long: 64;
	long: 64;
	long: 64;
};

struct mtd_info;

typedef long long int qsize_t;

struct quota_format_type;

struct mem_dqinfo {
	struct quota_format_type *dqi_format;
	int dqi_fmt_id;
	struct list_head dqi_dirty_list;
	long unsigned int dqi_flags;
	unsigned int dqi_bgrace;
	unsigned int dqi_igrace;
	qsize_t dqi_max_spc_limit;
	qsize_t dqi_max_ino_limit;
	void *dqi_priv;
};

struct quota_format_ops;

struct quota_info {
	unsigned int flags;
	struct rw_semaphore dqio_sem;
	struct inode *files[3];
	struct mem_dqinfo info[3];
	const struct quota_format_ops *ops[3];
};

struct rcu_sync {
	int gp_state;
	int gp_count;
	wait_queue_head_t gp_wait;
	struct callback_head cb_head;
};

struct rcuwait {
	struct task_struct *task;
};

struct percpu_rw_semaphore {
	struct rcu_sync rss;
	unsigned int *read_count;
	struct rcuwait writer;
	wait_queue_head_t waiters;
	atomic_t block;
};

struct sb_writers {
	int frozen;
	wait_queue_head_t wait_unfrozen;
	struct percpu_rw_semaphore rw_sem[3];
};

typedef struct {
	__u8 b[16];
} uuid_t;

struct shrink_control;

struct shrinker {
	long unsigned int (*count_objects)(struct shrinker *, struct shrink_control *);
	long unsigned int (*scan_objects)(struct shrinker *, struct shrink_control *);
	long int batch;
	int seeks;
	unsigned int flags;
	struct list_head list;
	int id;
	atomic_long_t *nr_deferred;
};

struct list_lru_node;

struct list_lru {
	struct list_lru_node *node;
	struct list_head list;
	int shrinker_id;
	bool memcg_aware;
};

struct super_operations;

struct dquot_operations;

struct quotactl_ops;

struct export_operations;

struct xattr_handler;

struct fscrypt_operations;

struct fsverity_operations;

struct unicode_map;

struct block_device;

struct super_block {
	struct list_head s_list;
	dev_t s_dev;
	unsigned char s_blocksize_bits;
	long unsigned int s_blocksize;
	loff_t s_maxbytes;
	struct file_system_type *s_type;
	const struct super_operations *s_op;
	const struct dquot_operations *dq_op;
	const struct quotactl_ops *s_qcop;
	const struct export_operations *s_export_op;
	long unsigned int s_flags;
	long unsigned int s_iflags;
	long unsigned int s_magic;
	struct dentry *s_root;
	struct rw_semaphore s_umount;
	int s_count;
	atomic_t s_active;
	void *s_security;
	const struct xattr_handler **s_xattr;
	const struct fscrypt_operations *s_cop;
	struct key *s_master_keys;
	const struct fsverity_operations *s_vop;
	struct unicode_map *s_encoding;
	__u16 s_encoding_flags;
	struct hlist_bl_head s_roots;
	struct list_head s_mounts;
	struct block_device *s_bdev;
	struct backing_dev_info *s_bdi;
	struct mtd_info *s_mtd;
	struct hlist_node s_instances;
	unsigned int s_quota_types;
	struct quota_info s_dquot;
	struct sb_writers s_writers;
	void *s_fs_info;
	u32 s_time_gran;
	time64_t s_time_min;
	time64_t s_time_max;
	__u32 s_fsnotify_mask;
	struct fsnotify_mark_connector *s_fsnotify_marks;
	char s_id[32];
	uuid_t s_uuid;
	unsigned int s_max_links;
	fmode_t s_mode;
	struct mutex s_vfs_rename_mutex;
	const char *s_subtype;
	const struct dentry_operations *s_d_op;
	int cleancache_poolid;
	struct shrinker s_shrink;
	atomic_long_t s_remove_count;
	atomic_long_t s_fsnotify_inode_refs;
	int s_readonly_remount;
	errseq_t s_wb_err;
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;
	struct user_namespace *s_user_ns;
	struct list_lru s_dentry_lru;
	struct list_lru s_inode_lru;
	struct callback_head rcu;
	struct work_struct destroy_work;
	struct mutex s_sync_lock;
	int s_stack_depth;
	int: 32;
	spinlock_t s_inode_list_lock;
	struct list_head s_inodes;
	spinlock_t s_inode_wblist_lock;
	struct list_head s_inodes_wb;
	long: 64;
	long: 64;
};

struct vfsmount {
	struct dentry *mnt_root;
	struct super_block *mnt_sb;
	int mnt_flags;
	struct user_namespace *mnt_userns;
};

struct shrink_control {
	gfp_t gfp_mask;
	int nid;
	long unsigned int nr_to_scan;
	long unsigned int nr_scanned;
	struct mem_cgroup *memcg;
};

struct list_lru_one {
	struct list_head list;
	long int nr_items;
};

struct list_lru_memcg {
	struct callback_head rcu;
	struct list_lru_one *lru[0];
};

struct list_lru_node {
	spinlock_t lock;
	struct list_lru_one lru;
	struct list_lru_memcg *memcg_lrus;
	long int nr_items;
	long: 64;
	long: 64;
};

enum migrate_mode {
	MIGRATE_ASYNC = 0,
	MIGRATE_SYNC_LIGHT = 1,
	MIGRATE_SYNC = 2,
	MIGRATE_SYNC_NO_COPY = 3,
};

struct exception_table_entry {
	int insn;
	int fixup;
};

struct cgroup_base_stat {
	struct task_cputime cputime;
};

struct psi_group_cpu;

struct psi_group {
	struct mutex avgs_lock;
	struct psi_group_cpu *pcpu;
	u64 avg_total[6];
	u64 avg_last_update;
	u64 avg_next_update;
	struct delayed_work avgs_work;
	u64 total[12];
	long unsigned int avg[18];
	struct task_struct *poll_task;
	struct timer_list poll_timer;
	wait_queue_head_t poll_wait;
	atomic_t poll_wakeup;
	struct mutex trigger_lock;
	struct list_head triggers;
	u32 nr_triggers[6];
	u32 poll_states;
	u64 poll_min_period;
	u64 polling_total[6];
	u64 polling_next_update;
	u64 polling_until;
};

struct bpf_prog_array;

struct cgroup_bpf {
	struct bpf_prog_array *effective[39];
	struct list_head progs[39];
	u32 flags[39];
	struct list_head storages;
	struct bpf_prog_array *inactive;
	struct percpu_ref refcnt;
	struct work_struct release_work;
};

struct cgroup_freezer_state {
	bool freeze;
	int e_freeze;
	int nr_frozen_descendants;
	int nr_frozen_tasks;
};

struct cgroup_root;

struct cgroup_rstat_cpu;

struct cgroup {
	struct cgroup_subsys_state self;
	long unsigned int flags;
	int level;
	int max_depth;
	int nr_descendants;
	int nr_dying_descendants;
	int max_descendants;
	int nr_populated_csets;
	int nr_populated_domain_children;
	int nr_populated_threaded_children;
	int nr_threaded_children;
	struct kernfs_node *kn;
	struct cgroup_file procs_file;
	struct cgroup_file events_file;
	u16 subtree_control;
	u16 subtree_ss_mask;
	u16 old_subtree_control;
	u16 old_subtree_ss_mask;
	struct cgroup_subsys_state *subsys[14];
	struct cgroup_root *root;
	struct list_head cset_links;
	struct list_head e_csets[14];
	struct cgroup *dom_cgrp;
	struct cgroup *old_dom_cgrp;
	struct cgroup_rstat_cpu *rstat_cpu;
	struct list_head rstat_css_list;
	struct cgroup_base_stat last_bstat;
	struct cgroup_base_stat bstat;
	struct prev_cputime prev_cputime;
	struct list_head pidlists;
	struct mutex pidlist_mutex;
	wait_queue_head_t offline_waitq;
	struct work_struct release_agent_work;
	struct psi_group psi;
	struct cgroup_bpf bpf;
	atomic_t congestion_count;
	struct cgroup_freezer_state freezer;
	u64 ancestor_ids[0];
};

struct key_tag {
	struct callback_head rcu;
	refcount_t usage;
	bool removed;
};

typedef int (*request_key_actor_t)(struct key *, void *);

struct key_preparsed_payload;

struct key_match_data;

struct kernel_pkey_params;

struct kernel_pkey_query;

struct key_type {
	const char *name;
	size_t def_datalen;
	unsigned int flags;
	int (*vet_description)(const char *);
	int (*preparse)(struct key_preparsed_payload *);
	void (*free_preparse)(struct key_preparsed_payload *);
	int (*instantiate)(struct key *, struct key_preparsed_payload *);
	int (*update)(struct key *, struct key_preparsed_payload *);
	int (*match_preparse)(struct key_match_data *);
	void (*match_free)(struct key_match_data *);
	void (*revoke)(struct key *);
	void (*destroy)(struct key *);
	void (*describe)(const struct key *, struct seq_file *);
	long int (*read)(const struct key *, char *, size_t);
	request_key_actor_t request_key;
	struct key_restriction * (*lookup_restriction)(const char *);
	int (*asym_query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*asym_eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*asym_verify_signature)(struct kernel_pkey_params *, const void *, const void *);
	struct list_head link;
	struct lock_class_key lock_class;
};

typedef int (*key_restrict_link_func_t)(struct key *, const struct key_type *, const union key_payload *, struct key *);

struct key_restriction {
	key_restrict_link_func_t check;
	struct key *key;
	struct key_type *keytype;
};

struct group_info {
	atomic_t usage;
	int ngroups;
	kgid_t gid[0];
};

struct ucounts {
	struct hlist_node node;
	struct user_namespace *ns;
	kuid_t uid;
	int count;
	atomic_t ucount[12];
};

struct taskstats {
	__u16 version;
	__u32 ac_exitcode;
	__u8 ac_flag;
	__u8 ac_nice;
	__u64 cpu_count;
	__u64 cpu_delay_total;
	__u64 blkio_count;
	__u64 blkio_delay_total;
	__u64 swapin_count;
	__u64 swapin_delay_total;
	__u64 cpu_run_real_total;
	__u64 cpu_run_virtual_total;
	char ac_comm[32];
	__u8 ac_sched;
	__u8 ac_pad[3];
	int: 32;
	__u32 ac_uid;
	__u32 ac_gid;
	__u32 ac_pid;
	__u32 ac_ppid;
	__u32 ac_btime;
	__u64 ac_etime;
	__u64 ac_utime;
	__u64 ac_stime;
	__u64 ac_minflt;
	__u64 ac_majflt;
	__u64 coremem;
	__u64 virtmem;
	__u64 hiwater_rss;
	__u64 hiwater_vm;
	__u64 read_char;
	__u64 write_char;
	__u64 read_syscalls;
	__u64 write_syscalls;
	__u64 read_bytes;
	__u64 write_bytes;
	__u64 cancelled_write_bytes;
	__u64 nvcsw;
	__u64 nivcsw;
	__u64 ac_utimescaled;
	__u64 ac_stimescaled;
	__u64 cpu_scaled_run_real_total;
	__u64 freepages_count;
	__u64 freepages_delay_total;
	__u64 thrashing_count;
	__u64 thrashing_delay_total;
	__u64 ac_btime64;
};

struct delayed_call {
	void (*fn)(void *);
	void *arg;
};

typedef struct {
	__u8 b[16];
} guid_t;

struct io_cq {
	struct request_queue *q;
	struct io_context *ioc;
	union {
		struct list_head q_node;
		struct kmem_cache *__rcu_icq_cache;
	};
	union {
		struct hlist_node ioc_node;
		struct callback_head __rcu_head;
	};
	unsigned int flags;
};

struct files_stat_struct {
	long unsigned int nr_files;
	long unsigned int nr_free_files;
	long unsigned int max_files;
};

struct inodes_stat_t {
	long int nr_inodes;
	long int nr_unused;
	long int dummy[5];
};

struct wait_page_queue;

struct kiocb {
	struct file *ki_filp;
	loff_t ki_pos;
	void (*ki_complete)(struct kiocb *, long int, long int);
	void *private;
	int ki_flags;
	u16 ki_hint;
	u16 ki_ioprio;
	union {
		unsigned int ki_cookie;
		struct wait_page_queue *ki_waitq;
	};
};

struct iattr {
	unsigned int ia_valid;
	umode_t ia_mode;
	kuid_t ia_uid;
	kgid_t ia_gid;
	loff_t ia_size;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct file *ia_file;
};

typedef __kernel_uid32_t projid_t;

typedef struct {
	projid_t val;
} kprojid_t;

enum quota_type {
	USRQUOTA = 0,
	GRPQUOTA = 1,
	PRJQUOTA = 2,
};

struct kqid {
	union {
		kuid_t uid;
		kgid_t gid;
		kprojid_t projid;
	};
	enum quota_type type;
};

struct mem_dqblk {
	qsize_t dqb_bhardlimit;
	qsize_t dqb_bsoftlimit;
	qsize_t dqb_curspace;
	qsize_t dqb_rsvspace;
	qsize_t dqb_ihardlimit;
	qsize_t dqb_isoftlimit;
	qsize_t dqb_curinodes;
	time64_t dqb_btime;
	time64_t dqb_itime;
};

struct dquot {
	struct hlist_node dq_hash;
	struct list_head dq_inuse;
	struct list_head dq_free;
	struct list_head dq_dirty;
	struct mutex dq_lock;
	spinlock_t dq_dqb_lock;
	atomic_t dq_count;
	struct super_block *dq_sb;
	struct kqid dq_id;
	loff_t dq_off;
	long unsigned int dq_flags;
	struct mem_dqblk dq_dqb;
};

struct quota_format_type {
	int qf_fmt_id;
	const struct quota_format_ops *qf_ops;
	struct module *qf_owner;
	struct quota_format_type *qf_next;
};

struct dqstats {
	long unsigned int stat[8];
	struct percpu_counter counter[8];
};

struct quota_format_ops {
	int (*check_quota_file)(struct super_block *, int);
	int (*read_file_info)(struct super_block *, int);
	int (*write_file_info)(struct super_block *, int);
	int (*free_file_info)(struct super_block *, int);
	int (*read_dqblk)(struct dquot *);
	int (*commit_dqblk)(struct dquot *);
	int (*release_dqblk)(struct dquot *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct dquot_operations {
	int (*write_dquot)(struct dquot *);
	struct dquot * (*alloc_dquot)(struct super_block *, int);
	void (*destroy_dquot)(struct dquot *);
	int (*acquire_dquot)(struct dquot *);
	int (*release_dquot)(struct dquot *);
	int (*mark_dirty)(struct dquot *);
	int (*write_info)(struct super_block *, int);
	qsize_t * (*get_reserved_space)(struct inode *);
	int (*get_projid)(struct inode *, kprojid_t *);
	int (*get_inode_usage)(struct inode *, qsize_t *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct qc_dqblk {
	int d_fieldmask;
	u64 d_spc_hardlimit;
	u64 d_spc_softlimit;
	u64 d_ino_hardlimit;
	u64 d_ino_softlimit;
	u64 d_space;
	u64 d_ino_count;
	s64 d_ino_timer;
	s64 d_spc_timer;
	int d_ino_warns;
	int d_spc_warns;
	u64 d_rt_spc_hardlimit;
	u64 d_rt_spc_softlimit;
	u64 d_rt_space;
	s64 d_rt_spc_timer;
	int d_rt_spc_warns;
};

struct qc_type_state {
	unsigned int flags;
	unsigned int spc_timelimit;
	unsigned int ino_timelimit;
	unsigned int rt_spc_timelimit;
	unsigned int spc_warnlimit;
	unsigned int ino_warnlimit;
	unsigned int rt_spc_warnlimit;
	long long unsigned int ino;
	blkcnt_t blocks;
	blkcnt_t nextents;
};

struct qc_state {
	unsigned int s_incoredqs;
	struct qc_type_state s_state[3];
};

struct qc_info {
	int i_fieldmask;
	unsigned int i_flags;
	unsigned int i_spc_timelimit;
	unsigned int i_ino_timelimit;
	unsigned int i_rt_spc_timelimit;
	unsigned int i_spc_warnlimit;
	unsigned int i_ino_warnlimit;
	unsigned int i_rt_spc_warnlimit;
};

struct quotactl_ops {
	int (*quota_on)(struct super_block *, int, int, const struct path *);
	int (*quota_off)(struct super_block *, int);
	int (*quota_enable)(struct super_block *, unsigned int);
	int (*quota_disable)(struct super_block *, unsigned int);
	int (*quota_sync)(struct super_block *, int);
	int (*set_info)(struct super_block *, int, struct qc_info *);
	int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *);
	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_state)(struct super_block *, struct qc_state *);
	int (*rm_xquota)(struct super_block *, unsigned int);
};

struct wait_page_queue {
	struct page *page;
	int bit_nr;
	wait_queue_entry_t wait;
};

struct writeback_control;

struct readahead_control;

struct swap_info_struct;

struct address_space_operations {
	int (*writepage)(struct page *, struct writeback_control *);
	int (*readpage)(struct file *, struct page *);
	int (*writepages)(struct address_space *, struct writeback_control *);
	int (*set_page_dirty)(struct page *);
	int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int);
	void (*readahead)(struct readahead_control *);
	int (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page **, void **);
	int (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page *, void *);
	sector_t (*bmap)(struct address_space *, sector_t);
	void (*invalidatepage)(struct page *, unsigned int, unsigned int);
	int (*releasepage)(struct page *, gfp_t);
	void (*freepage)(struct page *);
	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *);
	int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode);
	bool (*isolate_page)(struct page *, isolate_mode_t);
	void (*putback_page)(struct page *);
	int (*launder_page)(struct page *);
	int (*is_partially_uptodate)(struct page *, long unsigned int, long unsigned int);
	void (*is_dirty_writeback)(struct page *, bool *, bool *);
	int (*error_remove_page)(struct address_space *, struct page *);
	int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);
	void (*swap_deactivate)(struct file *);
};

enum writeback_sync_modes {
	WB_SYNC_NONE = 0,
	WB_SYNC_ALL = 1,
};

struct writeback_control {
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	enum writeback_sync_modes sync_mode;
	unsigned int for_kupdate: 1;
	unsigned int for_background: 1;
	unsigned int tagged_writepages: 1;
	unsigned int for_reclaim: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_sync: 1;
	unsigned int no_cgroup_owner: 1;
	unsigned int punt_to_cgroup: 1;
	struct bdi_writeback *wb;
	struct inode *inode;
	int wb_id;
	int wb_lcand_id;
	int wb_tcand_id;
	size_t wb_bytes;
	size_t wb_lcand_bytes;
	size_t wb_tcand_bytes;
};

struct readahead_control {
	struct file *file;
	struct address_space *mapping;
	struct file_ra_state *ra;
	long unsigned int _index;
	unsigned int _nr_pages;
	unsigned int _batch_count;
};

struct iovec;

struct kvec;

struct bio_vec;

struct iov_iter {
	unsigned int type;
	size_t iov_offset;
	size_t count;
	union {
		const struct iovec *iov;
		const struct kvec *kvec;
		const struct bio_vec *bvec;
		struct xarray *xarray;
		struct pipe_inode_info *pipe;
	};
	union {
		long unsigned int nr_segs;
		struct {
			unsigned int head;
			unsigned int start_head;
		};
		loff_t xarray_start;
	};
};

struct swap_cluster_info {
	spinlock_t lock;
	unsigned int data: 24;
	unsigned int flags: 8;
};

struct swap_cluster_list {
	struct swap_cluster_info head;
	struct swap_cluster_info tail;
};

struct percpu_cluster;

struct swap_info_struct {
	long unsigned int flags;
	short int prio;
	struct plist_node list;
	signed char type;
	unsigned int max;
	unsigned char *swap_map;
	struct swap_cluster_info *cluster_info;
	struct swap_cluster_list free_clusters;
	unsigned int lowest_bit;
	unsigned int highest_bit;
	unsigned int pages;
	unsigned int inuse_pages;
	unsigned int cluster_next;
	unsigned int cluster_nr;
	unsigned int *cluster_next_cpu;
	struct percpu_cluster *percpu_cluster;
	struct rb_root swap_extent_root;
	struct block_device *bdev;
	struct file *swap_file;
	unsigned int old_block_size;
	long unsigned int *frontswap_map;
	atomic_t frontswap_pages;
	spinlock_t lock;
	spinlock_t cont_lock;
	struct work_struct discard_work;
	struct swap_cluster_list discard_clusters;
	struct plist_node avail_lists[0];
};

struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
};

struct fiemap_extent_info;

struct fileattr;

struct inode_operations {
	struct dentry * (*lookup)(struct inode *, struct dentry *, unsigned int);
	const char * (*get_link)(struct dentry *, struct inode *, struct delayed_call *);
	int (*permission)(struct user_namespace *, struct inode *, int);
	struct posix_acl * (*get_acl)(struct inode *, int);
	int (*readlink)(struct dentry *, char *, int);
	int (*create)(struct user_namespace *, struct inode *, struct dentry *, umode_t, bool);
	int (*link)(struct dentry *, struct inode *, struct dentry *);
	int (*unlink)(struct inode *, struct dentry *);
	int (*symlink)(struct user_namespace *, struct inode *, struct dentry *, const char *);
	int (*mkdir)(struct user_namespace *, struct inode *, struct dentry *, umode_t);
	int (*rmdir)(struct inode *, struct dentry *);
	int (*mknod)(struct user_namespace *, struct inode *, struct dentry *, umode_t, dev_t);
	int (*rename)(struct user_namespace *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);
	int (*setattr)(struct user_namespace *, struct dentry *, struct iattr *);
	int (*getattr)(struct user_namespace *, const struct path *, struct kstat *, u32, unsigned int);
	ssize_t (*listxattr)(struct dentry *, char *, size_t);
	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);
	int (*update_time)(struct inode *, struct timespec64 *, int);
	int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t);
	int (*tmpfile)(struct user_namespace *, struct inode *, struct dentry *, umode_t);
	int (*set_acl)(struct user_namespace *, struct inode *, struct posix_acl *, int);
	int (*fileattr_set)(struct user_namespace *, struct dentry *, struct fileattr *);
	int (*fileattr_get)(struct dentry *, struct fileattr *);
	long: 64;
};

struct file_lock_context {
	spinlock_t flc_lock;
	struct list_head flc_flock;
	struct list_head flc_posix;
	struct list_head flc_lease;
};

struct file_lock_operations {
	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
	void (*fl_release_private)(struct file_lock *);
};

struct nlm_lockowner;

struct nfs_lock_info {
	u32 state;
	struct nlm_lockowner *owner;
	struct list_head list;
};

struct nfs4_lock_state;

struct nfs4_lock_info {
	struct nfs4_lock_state *owner;
};

struct lock_manager_operations;

struct file_lock {
	struct file_lock *fl_blocker;
	struct list_head fl_list;
	struct hlist_node fl_link;
	struct list_head fl_blocked_requests;
	struct list_head fl_blocked_member;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	unsigned int fl_pid;
	int fl_link_cpu;
	wait_queue_head_t fl_wait;
	struct file *fl_file;
	loff_t fl_start;
	loff_t fl_end;
	struct fasync_struct *fl_fasync;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	const struct file_lock_operations *fl_ops;
	const struct lock_manager_operations *fl_lmops;
	union {
		struct nfs_lock_info nfs_fl;
		struct nfs4_lock_info nfs4_fl;
		struct {
			struct list_head link;
			int state;
			unsigned int debug_id;
		} afs;
	} fl_u;
};

struct lock_manager_operations {
	fl_owner_t (*lm_get_owner)(fl_owner_t);
	void (*lm_put_owner)(fl_owner_t);
	void (*lm_notify)(struct file_lock *);
	int (*lm_grant)(struct file_lock *, int);
	bool (*lm_break)(struct file_lock *);
	int (*lm_change)(struct file_lock *, int, struct list_head *);
	void (*lm_setup)(struct file_lock *, void **);
	bool (*lm_breaker_owns_lease)(struct file_lock *);
};

struct fasync_struct {
	rwlock_t fa_lock;
	int magic;
	int fa_fd;
	struct fasync_struct *fa_next;
	struct file *fa_file;
	struct callback_head fa_rcu;
};

struct kstatfs;

struct super_operations {
	struct inode * (*alloc_inode)(struct super_block *);
	void (*destroy_inode)(struct inode *);
	void (*free_inode)(struct inode *);
	void (*dirty_inode)(struct inode *, int);
	int (*write_inode)(struct inode *, struct writeback_control *);
	int (*drop_inode)(struct inode *);
	void (*evict_inode)(struct inode *);
	void (*put_super)(struct super_block *);
	int (*sync_fs)(struct super_block *, int);
	int (*freeze_super)(struct super_block *);
	int (*freeze_fs)(struct super_block *);
	int (*thaw_super)(struct super_block *);
	int (*unfreeze_fs)(struct super_block *);
	int (*statfs)(struct dentry *, struct kstatfs *);
	int (*remount_fs)(struct super_block *, int *, char *);
	void (*umount_begin)(struct super_block *);
	int (*show_options)(struct seq_file *, struct dentry *);
	int (*show_devname)(struct seq_file *, struct dentry *);
	int (*show_path)(struct seq_file *, struct dentry *);
	int (*show_stats)(struct seq_file *, struct dentry *);
	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
	struct dquot ** (*get_dquots)(struct inode *);
	int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t);
	long int (*nr_cached_objects)(struct super_block *, struct shrink_control *);
	long int (*free_cached_objects)(struct super_block *, struct shrink_control *);
	struct file * (*real_loop)(struct file *);
};

struct iomap;

struct fid;

struct export_operations {
	int (*encode_fh)(struct inode *, __u32 *, int *, struct inode *);
	struct dentry * (*fh_to_dentry)(struct super_block *, struct fid *, int, int);
	struct dentry * (*fh_to_parent)(struct super_block *, struct fid *, int, int);
	int (*get_name)(struct dentry *, char *, struct dentry *);
	struct dentry * (*get_parent)(struct dentry *);
	int (*commit_metadata)(struct inode *);
	int (*get_uuid)(struct super_block *, u8 *, u32 *, u64 *);
	int (*map_blocks)(struct inode *, loff_t, u64, struct iomap *, bool, u32 *);
	int (*commit_blocks)(struct inode *, struct iomap *, int, struct iattr *);
	u64 (*fetch_iversion)(struct inode *);
	long unsigned int flags;
};

struct xattr_handler {
	const char *name;
	const char *prefix;
	int flags;
	bool (*list)(struct dentry *);
	int (*get)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, void *, size_t);
	int (*set)(const struct xattr_handler *, struct user_namespace *, struct dentry *, struct inode *, const char *, const void *, size_t, int);
};

union fscrypt_policy;

struct fscrypt_operations {
	unsigned int flags;
	const char *key_prefix;
	int (*get_context)(struct inode *, void *, size_t);
	int (*set_context)(struct inode *, const void *, size_t, void *);
	const union fscrypt_policy * (*get_dummy_policy)(struct super_block *);
	bool (*empty_dir)(struct inode *);
	unsigned int max_namelen;
	bool (*has_stable_inodes)(struct super_block *);
	void (*get_ino_and_lblk_bits)(struct super_block *, int *, int *);
	int (*get_num_devices)(struct super_block *);
	void (*get_devices)(struct super_block *, struct request_queue **);
};

struct fsverity_operations {
	int (*begin_enable_verity)(struct file *);
	int (*end_enable_verity)(struct file *, const void *, size_t, u64);
	int (*get_verity_descriptor)(struct inode *, void *, size_t);
	struct page * (*read_merkle_tree_page)(struct inode *, long unsigned int, long unsigned int);
	int (*write_merkle_tree_block)(struct inode *, const void *, u64, int);
};

enum dl_dev_state {
	DL_DEV_NO_DRIVER = 0,
	DL_DEV_PROBING = 1,
	DL_DEV_DRIVER_BOUND = 2,
	DL_DEV_UNBINDING = 3,
};

struct dev_links_info {
	struct list_head suppliers;
	struct list_head consumers;
	struct list_head defer_sync;
	enum dl_dev_state status;
};

struct pm_message {
	int event;
};

typedef struct pm_message pm_message_t;

enum rpm_request {
	RPM_REQ_NONE = 0,
	RPM_REQ_IDLE = 1,
	RPM_REQ_SUSPEND = 2,
	RPM_REQ_AUTOSUSPEND = 3,
	RPM_REQ_RESUME = 4,
};

struct wakeup_source;

struct wake_irq;

struct pm_subsys_data;

struct dev_pm_qos;

struct dev_pm_info {
	pm_message_t power_state;
	unsigned int can_wakeup: 1;
	unsigned int async_suspend: 1;
	bool in_dpm_list: 1;
	bool is_prepared: 1;
	bool is_suspended: 1;
	bool is_noirq_suspended: 1;
	bool is_late_suspended: 1;
	bool no_pm: 1;
	bool early_init: 1;
	bool direct_complete: 1;
	u32 driver_flags;
	spinlock_t lock;
	struct list_head entry;
	struct completion completion;
	struct wakeup_source *wakeup;
	bool wakeup_path: 1;
	bool syscore: 1;
	bool no_pm_callbacks: 1;
	unsigned int must_resume: 1;
	unsigned int may_skip_resume: 1;
	struct hrtimer suspend_timer;
	u64 timer_expires;
	struct work_struct work;
	wait_queue_head_t wait_queue;
	struct wake_irq *wakeirq;
	atomic_t usage_count;
	atomic_t child_count;
	unsigned int disable_depth: 3;
	unsigned int idle_notification: 1;
	unsigned int request_pending: 1;
	unsigned int deferred_resume: 1;
	unsigned int needs_force_resume: 1;
	unsigned int runtime_auto: 1;
	bool ignore_children: 1;
	unsigned int no_callbacks: 1;
	unsigned int irq_safe: 1;
	unsigned int use_autosuspend: 1;
	unsigned int timer_autosuspends: 1;
	unsigned int memalloc_noio: 1;
	unsigned int links_count;
	enum rpm_request request;
	enum rpm_status runtime_status;
	int runtime_error;
	int autosuspend_delay;
	u64 last_busy;
	u64 active_time;
	u64 suspended_time;
	u64 accounting_timestamp;
	struct pm_subsys_data *subsys_data;
	void (*set_latency_tolerance)(struct device *, s32);
	struct dev_pm_qos *qos;
};

struct dev_archdata {};

struct device_private;

struct device_type;

struct bus_type;

struct device_driver;

struct dev_pm_domain;

struct em_perf_domain;

struct irq_domain;

struct dev_pin_info;

struct dma_map_ops;

struct bus_dma_region;

struct device_dma_parameters;

struct dma_coherent_mem;

struct cma;

struct device_node;

struct fwnode_handle;

struct class;

struct attribute_group;

struct iommu_group;

struct dev_iommu;

struct device {
	struct kobject kobj;
	struct device *parent;
	struct device_private *p;
	const char *init_name;
	const struct device_type *type;
	struct bus_type *bus;
	struct device_driver *driver;
	void *platform_data;
	void *driver_data;
	struct mutex mutex;
	struct dev_links_info links;
	struct dev_pm_info power;
	struct dev_pm_domain *pm_domain;
	struct em_perf_domain *em_pd;
	struct irq_domain *msi_domain;
	struct dev_pin_info *pins;
	raw_spinlock_t msi_lock;
	struct list_head msi_list;
	const struct dma_map_ops *dma_ops;
	u64 *dma_mask;
	u64 coherent_dma_mask;
	u64 bus_dma_limit;
	const struct bus_dma_region *dma_range_map;
	struct device_dma_parameters *dma_parms;
	struct list_head dma_pools;
	struct dma_coherent_mem *dma_mem;
	struct cma *cma_area;
	struct dev_archdata archdata;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	int numa_node;
	dev_t devt;
	u32 id;
	spinlock_t devres_lock;
	struct list_head devres_head;
	struct class *class;
	const struct attribute_group **groups;
	void (*release)(struct device *);
	struct iommu_group *iommu_group;
	struct dev_iommu *iommu;
	bool offline_disabled: 1;
	bool offline: 1;
	bool of_node_reused: 1;
	bool state_synced: 1;
	bool can_match: 1;
	bool dma_coherent: 1;
};

struct disk_stats;

struct gendisk;

struct partition_meta_info;

struct block_device {
	sector_t bd_start_sect;
	struct disk_stats *bd_stats;
	long unsigned int bd_stamp;
	bool bd_read_only;
	dev_t bd_dev;
	int bd_openers;
	struct inode *bd_inode;
	struct super_block *bd_super;
	struct mutex bd_mutex;
	void *bd_claiming;
	struct device bd_device;
	void *bd_holder;
	int bd_holders;
	bool bd_write_holder;
	struct list_head bd_holder_disks;
	struct kobject *bd_holder_dir;
	u8 bd_partno;
	unsigned int bd_part_count;
	spinlock_t bd_size_lock;
	struct gendisk *bd_disk;
	struct backing_dev_info *bd_bdi;
	int bd_fsfreeze_count;
	struct mutex bd_fsfreeze_mutex;
	struct super_block *bd_fsfreeze_sb;
	struct partition_meta_info *bd_meta_info;
};

typedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64, unsigned int);

struct dir_context {
	filldir_t actor;
	loff_t pos;
};

typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);

struct poll_table_struct {
	poll_queue_proc _qproc;
	__poll_t _key;
};

struct seq_operations;

struct seq_file {
	char *buf;
	size_t size;
	size_t from;
	size_t count;
	size_t pad_until;
	loff_t index;
	loff_t read_pos;
	struct mutex lock;
	const struct seq_operations *op;
	int poll_event;
	const struct file *file;
	void *private;
};

struct fc_log;

struct p_log {
	const char *prefix;
	struct fc_log *log;
};

enum fs_context_purpose {
	FS_CONTEXT_FOR_MOUNT = 0,
	FS_CONTEXT_FOR_SUBMOUNT = 1,
	FS_CONTEXT_FOR_RECONFIGURE = 2,
};

enum fs_context_phase {
	FS_CONTEXT_CREATE_PARAMS = 0,
	FS_CONTEXT_CREATING = 1,
	FS_CONTEXT_AWAITING_MOUNT = 2,
	FS_CONTEXT_AWAITING_RECONF = 3,
	FS_CONTEXT_RECONF_PARAMS = 4,
	FS_CONTEXT_RECONFIGURING = 5,
	FS_CONTEXT_FAILED = 6,
};

struct fs_context_operations;

struct fs_context {
	const struct fs_context_operations *ops;
	struct mutex uapi_mutex;
	struct file_system_type *fs_type;
	void *fs_private;
	void *sget_key;
	struct dentry *root;
	struct user_namespace *user_ns;
	struct net *net_ns;
	const struct cred *cred;
	struct p_log log;
	const char *source;
	void *security;
	void *s_fs_info;
	unsigned int sb_flags;
	unsigned int sb_flags_mask;
	unsigned int s_iflags;
	unsigned int lsm_flags;
	enum fs_context_purpose purpose: 8;
	enum fs_context_phase phase: 8;
	bool need_free: 1;
	bool global: 1;
	bool oldapi: 1;
};

struct fs_parameter;

struct fs_parse_result;

typedef int fs_param_type(struct p_log *, const struct fs_parameter_spec *, struct fs_parameter *, struct fs_parse_result *);

struct fs_parameter_spec {
	const char *name;
	fs_param_type *type;
	u8 opt;
	short unsigned int flags;
	const void *data;
};

struct audit_names;

struct filename {
	const char *name;
	const char *uptr;
	int refcnt;
	struct audit_names *aname;
	const char iname[0];
};

typedef u8 blk_status_t;

struct bvec_iter {
	sector_t bi_sector;
	unsigned int bi_size;
	unsigned int bi_idx;
	unsigned int bi_bvec_done;
};

typedef void bio_end_io_t(struct bio *);

struct bio_issue {
	u64 value;
};

struct bio_vec {
	struct page *bv_page;
	unsigned int bv_len;
	unsigned int bv_offset;
};

struct bio_crypt_ctx;

struct bio_integrity_payload;

struct bio {
	struct bio *bi_next;
	struct block_device *bi_bdev;
	unsigned int bi_opf;
	short unsigned int bi_flags;
	short unsigned int bi_ioprio;
	short unsigned int bi_write_hint;
	blk_status_t bi_status;
	atomic_t __bi_remaining;
	struct bvec_iter bi_iter;
	bio_end_io_t *bi_end_io;
	void *bi_private;
	struct blkcg_gq *bi_blkg;
	struct bio_issue bi_issue;
	u64 bi_iocost_cost;
	struct bio_crypt_ctx *bi_crypt_context;
	union {
		struct bio_integrity_payload *bi_integrity;
	};
	short unsigned int bi_vcnt;
	short unsigned int bi_max_vecs;
	atomic_t __bi_cnt;
	struct bio_vec *bi_io_vec;
	struct bio_set *bi_pool;
	struct bio_vec bi_inline_vecs[0];
};

struct kernfs_root;

struct kernfs_elem_dir {
	long unsigned int subdirs;
	struct rb_root children;
	struct kernfs_root *root;
};

struct kernfs_syscall_ops;

struct kernfs_root {
	struct kernfs_node *kn;
	unsigned int flags;
	struct idr ino_idr;
	u32 last_id_lowbits;
	u32 id_highbits;
	struct kernfs_syscall_ops *syscall_ops;
	struct list_head supers;
	wait_queue_head_t deactivate_waitq;
};

struct kernfs_elem_symlink {
	struct kernfs_node *target_kn;
};

struct kernfs_ops;

struct kernfs_open_node;

struct kernfs_elem_attr {
	const struct kernfs_ops *ops;
	struct kernfs_open_node *open;
	loff_t size;
	struct kernfs_node *notify_next;
};

struct kernfs_iattrs;

struct kernfs_node {
	atomic_t count;
	atomic_t active;
	struct kernfs_node *parent;
	const char *name;
	struct rb_node rb;
	const void *ns;
	unsigned int hash;
	union {
		struct kernfs_elem_dir dir;
		struct kernfs_elem_symlink symlink;
		struct kernfs_elem_attr attr;
	};
	void *priv;
	u64 id;
	short unsigned int flags;
	umode_t mode;
	struct kernfs_iattrs *iattr;
};

struct kernfs_open_file;

struct kernfs_ops {
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	ssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);
	size_t atomic_write_len;
	bool prealloc;
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
	int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);
};

struct kernfs_syscall_ops {
	int (*show_options)(struct seq_file *, struct kernfs_root *);
	int (*mkdir)(struct kernfs_node *, const char *, umode_t);
	int (*rmdir)(struct kernfs_node *);
	int (*rename)(struct kernfs_node *, struct kernfs_node *, const char *);
	int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *);
};

struct kernfs_open_file {
	struct kernfs_node *kn;
	struct file *file;
	struct seq_file *seq_file;
	void *priv;
	struct mutex mutex;
	struct mutex prealloc_mutex;
	int event;
	struct list_head list;
	char *prealloc_buf;
	size_t atomic_write_len;
	bool mmapped: 1;
	bool released: 1;
	const struct vm_operations_struct *vm_ops;
};

enum kobj_ns_type {
	KOBJ_NS_TYPE_NONE = 0,
	KOBJ_NS_TYPE_NET = 1,
	KOBJ_NS_TYPES = 2,
};

struct sock;

struct kobj_ns_type_operations {
	enum kobj_ns_type type;
	bool (*current_may_mount)();
	void * (*grab_current_ns)();
	const void * (*netlink_ns)(struct sock *);
	const void * (*initial_ns)();
	void (*drop_ns)(void *);
};

struct attribute {
	const char *name;
	umode_t mode;
};

struct bin_attribute;

struct attribute_group {
	const char *name;
	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
	umode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int);
	struct attribute **attrs;
	struct bin_attribute **bin_attrs;
};

struct bin_attribute {
	struct attribute attr;
	size_t size;
	void *private;
	struct address_space *mapping;
	ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *);
};

struct sysfs_ops {
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};

struct kset_uevent_ops;

struct kset {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject kobj;
	const struct kset_uevent_ops *uevent_ops;
};

struct kobj_type {
	void (*release)(struct kobject *);
	const struct sysfs_ops *sysfs_ops;
	struct attribute **default_attrs;
	const struct attribute_group **default_groups;
	const struct kobj_ns_type_operations * (*child_ns_type)(struct kobject *);
	const void * (*namespace)(struct kobject *);
	void (*get_ownership)(struct kobject *, kuid_t *, kgid_t *);
};

struct kobj_uevent_env {
	char *argv[3];
	char *envp[64];
	int envp_idx;
	char buf[2048];
	int buflen;
};

struct kset_uevent_ops {
	int (* const filter)(struct kset *, struct kobject *);
	const char * (* const name)(struct kset *, struct kobject *);
	int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *);
};

struct kobj_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
	ssize_t (*store)(struct kobject *, struct kobj_attribute *, const char *, size_t);
};

struct kernel_param_ops {
	unsigned int flags;
	int (*set)(const char *, const struct kernel_param *);
	int (*get)(char *, const struct kernel_param *);
	void (*free)(void *);
};

struct kparam_string;

struct kparam_array;

struct kernel_param {
	const char *name;
	struct module *mod;
	const struct kernel_param_ops *ops;
	const u16 perm;
	s8 level;
	u8 flags;
	union {
		void *arg;
		const struct kparam_string *str;
		const struct kparam_array *arr;
	};
};

struct kparam_string {
	unsigned int maxlen;
	char *string;
};

struct kparam_array {
	unsigned int max;
	unsigned int elemsize;
	unsigned int *num;
	const struct kernel_param_ops *ops;
	void *elem;
};

struct error_injection_entry {
	long unsigned int addr;
	int etype;
};

struct tracepoint_func {
	void *func;
	void *data;
	int prio;
};

struct tracepoint {
	const char *name;
	struct static_key key;
	struct static_call_key *static_call_key;
	void *static_call_tramp;
	void *iterator;
	int (*regfunc)();
	void (*unregfunc)();
	struct tracepoint_func *funcs;
};

struct bpf_raw_event_map {
	struct tracepoint *tp;
	void *bpf_func;
	u32 num_args;
	u32 writable_size;
	long: 64;
};

struct plt_entry {
	__le32 adrp;
	__le32 add;
	__le32 br;
};

struct module_attribute {
	struct attribute attr;
	ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *);
	ssize_t (*store)(struct module_attribute *, struct module_kobject *, const char *, size_t);
	void (*setup)(struct module *, const char *);
	int (*test)(struct module *);
	void (*free)(struct module *);
};

struct trace_event_functions;

struct trace_event {
	struct hlist_node node;
	struct list_head list;
	int type;
	struct trace_event_functions *funcs;
};

struct trace_event_class;

struct trace_event_call {
	struct list_head list;
	struct trace_event_class *class;
	union {
		char *name;
		struct tracepoint *tp;
	};
	struct trace_event event;
	char *print_fmt;
	struct event_filter *filter;
	void *mod;
	void *data;
	int flags;
	int perf_refcount;
	struct hlist_head *perf_events;
	struct bpf_prog_array *prog_array;
	int (*perf_perm)(struct trace_event_call *, struct perf_event *);
};

struct trace_eval_map {
	const char *system;
	const char *eval_string;
	long unsigned int eval_value;
};

struct linux_binprm {
	struct vm_area_struct *vma;
	long unsigned int vma_pages;
	struct mm_struct *mm;
	long unsigned int p;
	long unsigned int argmin;
	unsigned int have_execfd: 1;
	unsigned int execfd_creds: 1;
	unsigned int secureexec: 1;
	unsigned int point_of_no_return: 1;
	struct file *executable;
	struct file *interpreter;
	struct file *file;
	struct cred *cred;
	int unsafe;
	unsigned int per_clear;
	int argc;
	int envc;
	const char *filename;
	const char *interp;
	const char *fdpath;
	unsigned int interp_flags;
	int execfd;
	long unsigned int loader;
	long unsigned int exec;
	struct rlimit rlim_stack;
	char buf[256];
};

struct coredump_params {
	const kernel_siginfo_t *siginfo;
	struct pt_regs *regs;
	struct file *file;
	long unsigned int limit;
	long unsigned int mm_flags;
	loff_t written;
	loff_t pos;
	loff_t to_skip;
};

struct sd_flag_debug {
	unsigned int meta_flags;
	char *name;
};

struct em_perf_state {
	long unsigned int frequency;
	long unsigned int power;
	long unsigned int cost;
};

struct em_perf_domain {
	struct em_perf_state *table;
	int nr_perf_states;
	int milliwatts;
	long unsigned int cpus[0];
};

struct resource {
	resource_size_t start;
	resource_size_t end;
	const char *name;
	long unsigned int flags;
	long unsigned int desc;
	struct resource *parent;
	struct resource *sibling;
	struct resource *child;
};

struct dev_pm_ops {
	int (*prepare)(struct device *);
	void (*complete)(struct device *);
	int (*suspend)(struct device *);
	int (*resume)(struct device *);
	int (*freeze)(struct device *);
	int (*thaw)(struct device *);
	int (*poweroff)(struct device *);
	int (*restore)(struct device *);
	int (*suspend_late)(struct device *);
	int (*resume_early)(struct device *);
	int (*freeze_late)(struct device *);
	int (*thaw_early)(struct device *);
	int (*poweroff_late)(struct device *);
	int (*restore_early)(struct device *);
	int (*suspend_noirq)(struct device *);
	int (*resume_noirq)(struct device *);
	int (*freeze_noirq)(struct device *);
	int (*thaw_noirq)(struct device *);
	int (*poweroff_noirq)(struct device *);
	int (*restore_noirq)(struct device *);
	int (*runtime_suspend)(struct device *);
	int (*runtime_resume)(struct device *);
	int (*runtime_idle)(struct device *);
};

struct pm_domain_data;

struct pm_subsys_data {
	spinlock_t lock;
	unsigned int refcount;
	unsigned int clock_op_might_sleep;
	struct mutex clock_mutex;
	struct list_head clock_list;
	struct pm_domain_data *domain_data;
};

struct wakeup_source {
	const char *name;
	int id;
	struct list_head entry;
	spinlock_t lock;
	struct wake_irq *wakeirq;
	struct timer_list timer;
	long unsigned int timer_expires;
	ktime_t total_time;
	ktime_t max_time;
	ktime_t last_time;
	ktime_t start_prevent_time;
	ktime_t prevent_sleep_time;
	long unsigned int event_count;
	long unsigned int active_count;
	long unsigned int relax_count;
	long unsigned int expire_count;
	long unsigned int wakeup_count;
	struct device *dev;
	bool active: 1;
	bool autosleep_enabled: 1;
};

struct dev_pm_domain {
	struct dev_pm_ops ops;
	int (*start)(struct device *);
	void (*detach)(struct device *, bool);
	int (*activate)(struct device *);
	void (*sync)(struct device *);
	void (*dismiss)(struct device *);
};

struct iommu_ops;

struct subsys_private;

struct bus_type {
	const char *name;
	const char *dev_name;
	struct device *dev_root;
	const struct attribute_group **bus_groups;
	const struct attribute_group **dev_groups;
	const struct attribute_group **drv_groups;
	int (*match)(struct device *, struct device_driver *);
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*online)(struct device *);
	int (*offline)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	int (*num_vf)(struct device *);
	int (*dma_configure)(struct device *);
	const struct dev_pm_ops *pm;
	const struct iommu_ops *iommu_ops;
	struct subsys_private *p;
	struct lock_class_key lock_key;
	bool need_parent_lock;
};

enum probe_type {
	PROBE_DEFAULT_STRATEGY = 0,
	PROBE_PREFER_ASYNCHRONOUS = 1,
	PROBE_FORCE_SYNCHRONOUS = 2,
};

struct of_device_id;

struct acpi_device_id;

struct driver_private;

struct device_driver {
	const char *name;
	struct bus_type *bus;
	struct module *owner;
	const char *mod_name;
	bool suppress_bind_attrs;
	enum probe_type probe_type;
	const struct of_device_id *of_match_table;
	const struct acpi_device_id *acpi_match_table;
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	const struct dev_pm_ops *pm;
	void (*coredump)(struct device *);
	struct driver_private *p;
};

enum iommu_cap {
	IOMMU_CAP_CACHE_COHERENCY = 0,
	IOMMU_CAP_INTR_REMAP = 1,
	IOMMU_CAP_NOEXEC = 2,
};

typedef u64 dma_addr_t;

enum iommu_dev_features {
	IOMMU_DEV_FEAT_AUX = 0,
	IOMMU_DEV_FEAT_SVA = 1,
	IOMMU_DEV_FEAT_IOPF = 2,
};

struct iommu_domain;

struct iommu_iotlb_gather;

struct iommu_device;

struct iommu_resv_region;

struct of_phandle_args;

struct iommu_sva;

struct iommu_fault_event;

struct iommu_page_response;

struct iommu_cache_invalidate_info;

struct iommu_gpasid_bind_data;

struct iommu_ops {
	bool (*capable)(enum iommu_cap);
	struct iommu_domain * (*domain_alloc)(unsigned int);
	void (*domain_free)(struct iommu_domain *);
	int (*attach_dev)(struct iommu_domain *, struct device *);
	void (*detach_dev)(struct iommu_domain *, struct device *);
	int (*map)(struct iommu_domain *, long unsigned int, phys_addr_t, size_t, int, gfp_t);
	size_t (*unmap)(struct iommu_domain *, long unsigned int, size_t, struct iommu_iotlb_gather *);
	void (*flush_iotlb_all)(struct iommu_domain *);
	void (*iotlb_sync_map)(struct iommu_domain *, long unsigned int, size_t);
	void (*iotlb_sync)(struct iommu_domain *, struct iommu_iotlb_gather *);
	phys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t);
	struct iommu_device * (*probe_device)(struct device *);
	void (*release_device)(struct device *);
	void (*probe_finalize)(struct device *);
	struct iommu_group * (*device_group)(struct device *);
	int (*enable_nesting)(struct iommu_domain *);
	int (*set_pgtable_quirks)(struct iommu_domain *, long unsigned int);
	void (*get_resv_regions)(struct device *, struct list_head *);
	void (*put_resv_regions)(struct device *, struct list_head *);
	void (*apply_resv_region)(struct device *, struct iommu_domain *, struct iommu_resv_region *);
	int (*of_xlate)(struct device *, struct of_phandle_args *);
	bool (*is_attach_deferred)(struct iommu_domain *, struct device *);
	bool (*dev_has_feat)(struct device *, enum iommu_dev_features);
	bool (*dev_feat_enabled)(struct device *, enum iommu_dev_features);
	int (*dev_enable_feat)(struct device *, enum iommu_dev_features);
	int (*dev_disable_feat)(struct device *, enum iommu_dev_features);
	int (*aux_attach_dev)(struct iommu_domain *, struct device *);
	void (*aux_detach_dev)(struct iommu_domain *, struct device *);
	int (*aux_get_pasid)(struct iommu_domain *, struct device *);
	struct iommu_sva * (*sva_bind)(struct device *, struct mm_struct *, void *);
	void (*sva_unbind)(struct iommu_sva *);
	u32 (*sva_get_pasid)(struct iommu_sva *);
	int (*page_response)(struct device *, struct iommu_fault_event *, struct iommu_page_response *);
	int (*cache_invalidate)(struct iommu_domain *, struct device *, struct iommu_cache_invalidate_info *);
	int (*sva_bind_gpasid)(struct iommu_domain *, struct device *, struct iommu_gpasid_bind_data *);
	int (*sva_unbind_gpasid)(struct device *, u32);
	int (*def_domain_type)(struct device *);
	long unsigned int pgsize_bitmap;
	struct module *owner;
};

struct device_type {
	const char *name;
	const struct attribute_group **groups;
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *);
	void (*release)(struct device *);
	const struct dev_pm_ops *pm;
};

struct class {
	const char *name;
	struct module *owner;
	const struct attribute_group **class_groups;
	const struct attribute_group **dev_groups;
	struct kobject *dev_kobj;
	int (*dev_uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *);
	void (*class_release)(struct class *);
	void (*dev_release)(struct device *);
	int (*shutdown_pre)(struct device *);
	const struct kobj_ns_type_operations *ns_type;
	const void * (*namespace)(struct device *);
	void (*get_ownership)(struct device *, kuid_t *, kgid_t *);
	const struct dev_pm_ops *pm;
	struct subsys_private *p;
};

struct of_device_id {
	char name[32];
	char type[32];
	char compatible[128];
	const void *data;
};

typedef long unsigned int kernel_ulong_t;

struct acpi_device_id {
	__u8 id[9];
	kernel_ulong_t driver_data;
	__u32 cls;
	__u32 cls_msk;
};

struct device_dma_parameters {
	unsigned int max_segment_size;
	unsigned int min_align_mask;
	long unsigned int segment_boundary_mask;
};

enum irq_domain_bus_token {
	DOMAIN_BUS_ANY = 0,
	DOMAIN_BUS_WIRED = 1,
	DOMAIN_BUS_GENERIC_MSI = 2,
	DOMAIN_BUS_PCI_MSI = 3,
	DOMAIN_BUS_PLATFORM_MSI = 4,
	DOMAIN_BUS_NEXUS = 5,
	DOMAIN_BUS_IPI = 6,
	DOMAIN_BUS_FSL_MC_MSI = 7,
	DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
	DOMAIN_BUS_WAKEUP = 9,
	DOMAIN_BUS_VMD_MSI = 10,
};

struct irq_domain_ops;

struct irq_domain_chip_generic;

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;
	unsigned int mapcount;
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
	struct irq_domain *parent;
	irq_hw_number_t hwirq_max;
	unsigned int revmap_direct_max_irq;
	unsigned int revmap_size;
	struct xarray revmap_tree;
	struct mutex revmap_tree_mutex;
	unsigned int linear_revmap[0];
};

enum dma_data_direction {
	DMA_BIDIRECTIONAL = 0,
	DMA_TO_DEVICE = 1,
	DMA_FROM_DEVICE = 2,
	DMA_NONE = 3,
};

struct sg_table;

struct scatterlist;

struct dma_map_ops {
	void * (*alloc)(struct device *, size_t, dma_addr_t *, gfp_t, long unsigned int);
	void (*free)(struct device *, size_t, void *, dma_addr_t, long unsigned int);
	struct page * (*alloc_pages)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
	void (*free_pages)(struct device *, size_t, struct page *, dma_addr_t, enum dma_data_direction);
	struct sg_table * (*alloc_noncontiguous)(struct device *, size_t, enum dma_data_direction, gfp_t, long unsigned int);
	void (*free_noncontiguous)(struct device *, size_t, struct sg_table *, enum dma_data_direction);
	int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t, size_t, long unsigned int);
	int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t, size_t, long unsigned int);
	dma_addr_t (*map_page)(struct device *, struct page *, long unsigned int, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_page)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	int (*map_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	void (*unmap_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	dma_addr_t (*map_resource)(struct device *, phys_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_resource)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*sync_single_for_cpu)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_single_for_device)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*sync_sg_for_device)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*cache_sync)(struct device *, void *, size_t, enum dma_data_direction);
	int (*dma_supported)(struct device *, u64);
	u64 (*get_required_mask)(struct device *);
	size_t (*max_mapping_size)(struct device *);
	long unsigned int (*get_merge_boundary)(struct device *);
};

struct bus_dma_region {
	phys_addr_t cpu_start;
	dma_addr_t dma_start;
	u64 size;
	u64 offset;
};

typedef u32 phandle;

struct fwnode_operations;

struct fwnode_handle {
	struct fwnode_handle *secondary;
	const struct fwnode_operations *ops;
	struct device *dev;
	struct list_head suppliers;
	struct list_head consumers;
	u8 flags;
};

struct property;

struct device_node {
	const char *name;
	phandle phandle;
	const char *full_name;
	struct fwnode_handle fwnode;
	struct property *properties;
	struct property *deadprops;
	struct device_node *parent;
	struct device_node *child;
	struct device_node *sibling;
	struct kobject kobj;
	long unsigned int _flags;
	void *data;
};

struct node {
	struct device dev;
	struct list_head access_list;
	struct work_struct node_work;
	struct list_head cache_attrs;
	struct device *cache_dev;
};

enum cpuhp_state {
	CPUHP_INVALID = 4294967295,
	CPUHP_OFFLINE = 0,
	CPUHP_CREATE_THREADS = 1,
	CPUHP_PERF_PREPARE = 2,
	CPUHP_PERF_X86_PREPARE = 3,
	CPUHP_PERF_X86_AMD_UNCORE_PREP = 4,
	CPUHP_PERF_POWER = 5,
	CPUHP_PERF_SUPERH = 6,
	CPUHP_X86_HPET_DEAD = 7,
	CPUHP_X86_APB_DEAD = 8,
	CPUHP_X86_MCE_DEAD = 9,
	CPUHP_VIRT_NET_DEAD = 10,
	CPUHP_SLUB_DEAD = 11,
	CPUHP_DEBUG_OBJ_DEAD = 12,
	CPUHP_MM_WRITEBACK_DEAD = 13,
	CPUHP_MM_VMSTAT_DEAD = 14,
	CPUHP_SOFTIRQ_DEAD = 15,
	CPUHP_NET_MVNETA_DEAD = 16,
	CPUHP_CPUIDLE_DEAD = 17,
	CPUHP_ARM64_FPSIMD_DEAD = 18,
	CPUHP_ARM_OMAP_WAKE_DEAD = 19,
	CPUHP_IRQ_POLL_DEAD = 20,
	CPUHP_BLOCK_SOFTIRQ_DEAD = 21,
	CPUHP_ACPI_CPUDRV_DEAD = 22,
	CPUHP_S390_PFAULT_DEAD = 23,
	CPUHP_BLK_MQ_DEAD = 24,
	CPUHP_FS_BUFF_DEAD = 25,
	CPUHP_PRINTK_DEAD = 26,
	CPUHP_MM_MEMCQ_DEAD = 27,
	CPUHP_PERCPU_CNT_DEAD = 28,
	CPUHP_RADIX_DEAD = 29,
	CPUHP_PAGE_ALLOC_DEAD = 30,
	CPUHP_NET_DEV_DEAD = 31,
	CPUHP_PCI_XGENE_DEAD = 32,
	CPUHP_IOMMU_IOVA_DEAD = 33,
	CPUHP_LUSTRE_CFS_DEAD = 34,
	CPUHP_AP_ARM_CACHE_B15_RAC_DEAD = 35,
	CPUHP_PADATA_DEAD = 36,
	CPUHP_WORKQUEUE_PREP = 37,
	CPUHP_POWER_NUMA_PREPARE = 38,
	CPUHP_HRTIMERS_PREPARE = 39,
	CPUHP_PROFILE_PREPARE = 40,
	CPUHP_X2APIC_PREPARE = 41,
	CPUHP_SMPCFD_PREPARE = 42,
	CPUHP_RELAY_PREPARE = 43,
	CPUHP_SLAB_PREPARE = 44,
	CPUHP_MD_RAID5_PREPARE = 45,
	CPUHP_RCUTREE_PREP = 46,
	CPUHP_CPUIDLE_COUPLED_PREPARE = 47,
	CPUHP_POWERPC_PMAC_PREPARE = 48,
	CPUHP_POWERPC_MMU_CTX_PREPARE = 49,
	CPUHP_XEN_PREPARE = 50,
	CPUHP_XEN_EVTCHN_PREPARE = 51,
	CPUHP_ARM_SHMOBILE_SCU_PREPARE = 52,
	CPUHP_SH_SH3X_PREPARE = 53,
	CPUHP_NET_FLOW_PREPARE = 54,
	CPUHP_TOPOLOGY_PREPARE = 55,
	CPUHP_NET_IUCV_PREPARE = 56,
	CPUHP_ARM_BL_PREPARE = 57,
	CPUHP_TRACE_RB_PREPARE = 58,
	CPUHP_MM_ZS_PREPARE = 59,
	CPUHP_MM_ZSWP_MEM_PREPARE = 60,
	CPUHP_MM_ZSWP_POOL_PREPARE = 61,
	CPUHP_KVM_PPC_BOOK3S_PREPARE = 62,
	CPUHP_ZCOMP_PREPARE = 63,
	CPUHP_TIMERS_PREPARE = 64,
	CPUHP_MIPS_SOC_PREPARE = 65,
	CPUHP_BP_PREPARE_DYN = 66,
	CPUHP_BP_PREPARE_DYN_END = 86,
	CPUHP_BRINGUP_CPU = 87,
	CPUHP_AP_IDLE_DEAD = 88,
	CPUHP_AP_OFFLINE = 89,
	CPUHP_AP_SCHED_STARTING = 90,
	CPUHP_AP_RCUTREE_DYING = 91,
	CPUHP_AP_CPU_PM_STARTING = 92,
	CPUHP_AP_IRQ_GIC_STARTING = 93,
	CPUHP_AP_IRQ_HIP04_STARTING = 94,
	CPUHP_AP_IRQ_APPLE_AIC_STARTING = 95,
	CPUHP_AP_IRQ_ARMADA_XP_STARTING = 96,
	CPUHP_AP_IRQ_BCM2836_STARTING = 97,
	CPUHP_AP_IRQ_MIPS_GIC_STARTING = 98,
	CPUHP_AP_IRQ_RISCV_STARTING = 99,
	CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING = 100,
	CPUHP_AP_ARM_MVEBU_COHERENCY = 101,
	CPUHP_AP_MICROCODE_LOADER = 102,
	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING = 103,
	CPUHP_AP_PERF_X86_STARTING = 104,
	CPUHP_AP_PERF_X86_AMD_IBS_STARTING = 105,
	CPUHP_AP_PERF_X86_CQM_STARTING = 106,
	CPUHP_AP_PERF_X86_CSTATE_STARTING = 107,
	CPUHP_AP_PERF_XTENSA_STARTING = 108,
	CPUHP_AP_MIPS_OP_LOONGSON3_STARTING = 109,
	CPUHP_AP_ARM_SDEI_STARTING = 110,
	CPUHP_AP_ARM_VFP_STARTING = 111,
	CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING = 112,
	CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING = 113,
	CPUHP_AP_PERF_ARM_ACPI_STARTING = 114,
	CPUHP_AP_PERF_ARM_STARTING = 115,
	CPUHP_AP_ARM_L2X0_STARTING = 116,
	CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING = 117,
	CPUHP_AP_ARM_ARCH_TIMER_STARTING = 118,
	CPUHP_AP_ARM_GLOBAL_TIMER_STARTING = 119,
	CPUHP_AP_JCORE_TIMER_STARTING = 120,
	CPUHP_AP_ARM_TWD_STARTING = 121,
	CPUHP_AP_QCOM_TIMER_STARTING = 122,
	CPUHP_AP_TEGRA_TIMER_STARTING = 123,
	CPUHP_AP_ARMADA_TIMER_STARTING = 124,
	CPUHP_AP_MARCO_TIMER_STARTING = 125,
	CPUHP_AP_MIPS_GIC_TIMER_STARTING = 126,
	CPUHP_AP_ARC_TIMER_STARTING = 127,
	CPUHP_AP_RISCV_TIMER_STARTING = 128,
	CPUHP_AP_CLINT_TIMER_STARTING = 129,
	CPUHP_AP_CSKY_TIMER_STARTING = 130,
	CPUHP_AP_TI_GP_TIMER_STARTING = 131,
	CPUHP_AP_HYPERV_TIMER_STARTING = 132,
	CPUHP_AP_KVM_STARTING = 133,
	CPUHP_AP_KVM_ARM_VGIC_INIT_STARTING = 134,
	CPUHP_AP_KVM_ARM_VGIC_STARTING = 135,
	CPUHP_AP_KVM_ARM_TIMER_STARTING = 136,
	CPUHP_AP_DUMMY_TIMER_STARTING = 137,
	CPUHP_AP_ARM_XEN_STARTING = 138,
	CPUHP_AP_ARM_CORESIGHT_STARTING = 139,
	CPUHP_AP_ARM_CORESIGHT_CTI_STARTING = 140,
	CPUHP_AP_ARM64_ISNDEP_STARTING = 141,
	CPUHP_AP_SMPCFD_DYING = 142,
	CPUHP_AP_X86_TBOOT_DYING = 143,
	CPUHP_AP_ARM_CACHE_B15_RAC_DYING = 144,
	CPUHP_AP_ONLINE = 145,
	CPUHP_TEARDOWN_CPU = 146,
	CPUHP_AP_ONLINE_IDLE = 147,
	CPUHP_AP_SCHED_WAIT_EMPTY = 148,
	CPUHP_AP_SMPBOOT_THREADS = 149,
	CPUHP_AP_X86_VDSO_VMA_ONLINE = 150,
	CPUHP_AP_IRQ_AFFINITY_ONLINE = 151,
	CPUHP_AP_BLK_MQ_ONLINE = 152,
	CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS = 153,
	CPUHP_AP_X86_INTEL_EPB_ONLINE = 154,
	CPUHP_AP_PERF_ONLINE = 155,
	CPUHP_AP_PERF_X86_ONLINE = 156,
	CPUHP_AP_PERF_X86_UNCORE_ONLINE = 157,
	CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE = 158,
	CPUHP_AP_PERF_X86_AMD_POWER_ONLINE = 159,
	CPUHP_AP_PERF_X86_RAPL_ONLINE = 160,
	CPUHP_AP_PERF_X86_CQM_ONLINE = 161,
	CPUHP_AP_PERF_X86_CSTATE_ONLINE = 162,
	CPUHP_AP_PERF_X86_IDXD_ONLINE = 163,
	CPUHP_AP_PERF_S390_CF_ONLINE = 164,
	CPUHP_AP_PERF_S390_CFD_ONLINE = 165,
	CPUHP_AP_PERF_S390_SF_ONLINE = 166,
	CPUHP_AP_PERF_ARM_CCI_ONLINE = 167,
	CPUHP_AP_PERF_ARM_CCN_ONLINE = 168,
	CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE = 169,
	CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE = 170,
	CPUHP_AP_PERF_ARM_HISI_L3_ONLINE = 171,
	CPUHP_AP_PERF_ARM_HISI_PA_ONLINE = 172,
	CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE = 173,
	CPUHP_AP_PERF_ARM_L2X0_ONLINE = 174,
	CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE = 175,
	CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE = 176,
	CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE = 177,
	CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE = 178,
	CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE = 179,
	CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE = 180,
	CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE = 181,
	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE = 182,
	CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE = 183,
	CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE = 184,
	CPUHP_AP_PERF_CSKY_ONLINE = 185,
	CPUHP_AP_WATCHDOG_ONLINE = 186,
	CPUHP_AP_WORKQUEUE_ONLINE = 187,
	CPUHP_AP_RCUTREE_ONLINE = 188,
	CPUHP_AP_BASE_CACHEINFO_ONLINE = 189,
	CPUHP_AP_ONLINE_DYN = 190,
	CPUHP_AP_ONLINE_DYN_END = 220,
	CPUHP_AP_X86_HPET_ONLINE = 221,
	CPUHP_AP_X86_KVM_CLK_ONLINE = 222,
	CPUHP_AP_DTPM_CPU_ONLINE = 223,
	CPUHP_AP_ACTIVE = 224,
	CPUHP_ONLINE = 225,
};

typedef void percpu_ref_func_t(struct percpu_ref *);

struct percpu_ref_data {
	atomic_long_t count;
	percpu_ref_func_t *release;
	percpu_ref_func_t *confirm_switch;
	bool force_atomic: 1;
	bool allow_reinit: 1;
	struct callback_head rcu;
	struct percpu_ref *ref;
};

struct dev_pagemap_ops {
	void (*page_free)(struct page *);
	void (*kill)(struct dev_pagemap *);
	void (*cleanup)(struct dev_pagemap *);
	vm_fault_t (*migrate_to_ram)(struct vm_fault *);
};

typedef void compound_page_dtor(struct page *);

enum vm_event_item {
	PGPGIN = 0,
	PGPGOUT = 1,
	PSWPIN = 2,
	PSWPOUT = 3,
	PGALLOC_DMA = 4,
	PGALLOC_DMA32 = 5,
	PGALLOC_NORMAL = 6,
	PGALLOC_MOVABLE = 7,
	ALLOCSTALL_DMA = 8,
	ALLOCSTALL_DMA32 = 9,
	ALLOCSTALL_NORMAL = 10,
	ALLOCSTALL_MOVABLE = 11,
	PGSCAN_SKIP_DMA = 12,
	PGSCAN_SKIP_DMA32 = 13,
	PGSCAN_SKIP_NORMAL = 14,
	PGSCAN_SKIP_MOVABLE = 15,
	PGFREE = 16,
	PGACTIVATE = 17,
	PGDEACTIVATE = 18,
	PGLAZYFREE = 19,
	PGFAULT = 20,
	PGMAJFAULT = 21,
	PGLAZYFREED = 22,
	PGREFILL = 23,
	PGREUSE = 24,
	PGSTEAL_KSWAPD = 25,
	PGSTEAL_DIRECT = 26,
	PGSCAN_KSWAPD = 27,
	PGSCAN_DIRECT = 28,
	PGSCAN_DIRECT_THROTTLE = 29,
	PGSCAN_ANON = 30,
	PGSCAN_FILE = 31,
	PGSTEAL_ANON = 32,
	PGSTEAL_FILE = 33,
	PGSCAN_ZONE_RECLAIM_FAILED = 34,
	PGINODESTEAL = 35,
	SLABS_SCANNED = 36,
	KSWAPD_INODESTEAL = 37,
	KSWAPD_LOW_WMARK_HIT_QUICKLY = 38,
	KSWAPD_HIGH_WMARK_HIT_QUICKLY = 39,
	PAGEOUTRUN = 40,
	PGROTATED = 41,
	DROP_PAGECACHE = 42,
	DROP_SLAB = 43,
	OOM_KILL = 44,
	NUMA_PTE_UPDATES = 45,
	NUMA_HUGE_PTE_UPDATES = 46,
	NUMA_HINT_FAULTS = 47,
	NUMA_HINT_FAULTS_LOCAL = 48,
	NUMA_PAGE_MIGRATE = 49,
	PGMIGRATE_SUCCESS = 50,
	PGMIGRATE_FAIL = 51,
	THP_MIGRATION_SUCCESS = 52,
	THP_MIGRATION_FAIL = 53,
	THP_MIGRATION_SPLIT = 54,
	COMPACTMIGRATE_SCANNED = 55,
	COMPACTFREE_SCANNED = 56,
	COMPACTISOLATED = 57,
	COMPACTSTALL = 58,
	COMPACTFAIL = 59,
	COMPACTSUCCESS = 60,
	KCOMPACTD_WAKE = 61,
	KCOMPACTD_MIGRATE_SCANNED = 62,
	KCOMPACTD_FREE_SCANNED = 63,
	HTLB_BUDDY_PGALLOC = 64,
	HTLB_BUDDY_PGALLOC_FAIL = 65,
	CMA_ALLOC_SUCCESS = 66,
	CMA_ALLOC_FAIL = 67,
	UNEVICTABLE_PGCULLED = 68,
	UNEVICTABLE_PGSCANNED = 69,
	UNEVICTABLE_PGRESCUED = 70,
	UNEVICTABLE_PGMLOCKED = 71,
	UNEVICTABLE_PGMUNLOCKED = 72,
	UNEVICTABLE_PGCLEARED = 73,
	UNEVICTABLE_PGSTRANDED = 74,
	THP_FAULT_ALLOC = 75,
	THP_FAULT_FALLBACK = 76,
	THP_FAULT_FALLBACK_CHARGE = 77,
	THP_COLLAPSE_ALLOC = 78,
	THP_COLLAPSE_ALLOC_FAILED = 79,
	THP_FILE_ALLOC = 80,
	THP_FILE_FALLBACK = 81,
	THP_FILE_FALLBACK_CHARGE = 82,
	THP_FILE_MAPPED = 83,
	THP_SPLIT_PAGE = 84,
	THP_SPLIT_PAGE_FAILED = 85,
	THP_DEFERRED_SPLIT_PAGE = 86,
	THP_SPLIT_PMD = 87,
	THP_ZERO_PAGE_ALLOC = 88,
	THP_ZERO_PAGE_ALLOC_FAILED = 89,
	THP_SWPOUT = 90,
	THP_SWPOUT_FALLBACK = 91,
	BALLOON_INFLATE = 92,
	BALLOON_DEFLATE = 93,
	BALLOON_MIGRATE = 94,
	SWAP_RA = 95,
	SWAP_RA_HIT = 96,
	NR_VM_EVENT_ITEMS = 97,
};

struct vm_event_state {
	long unsigned int event[97];
};

struct seq_operations {
	void * (*start)(struct seq_file *, loff_t *);
	void (*stop)(struct seq_file *, void *);
	void * (*next)(struct seq_file *, void *, loff_t *);
	int (*show)(struct seq_file *, void *);
};

struct ring_buffer_event {
	u32 type_len: 5;
	u32 time_delta: 27;
	u32 array[0];
};

struct seq_buf {
	char *buffer;
	size_t size;
	size_t len;
	loff_t readpos;
};

struct trace_seq {
	char buffer[4096];
	struct seq_buf seq;
	int full;
};

typedef struct {
	unsigned int __softirq_pending;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
} irq_cpustat_t;

struct irq_desc;

typedef void (*irq_flow_handler_t)(struct irq_desc *);

struct msi_desc;

struct irq_common_data {
	unsigned int state_use_accessors;
	unsigned int node;
	void *handler_data;
	struct msi_desc *msi_desc;
	cpumask_var_t affinity;
	cpumask_var_t effective_affinity;
	unsigned int ipi_offset;
};

struct irq_chip;

struct irq_data {
	u32 mask;
	unsigned int irq;
	long unsigned int hwirq;
	struct irq_common_data *common;
	struct irq_chip *chip;
	struct irq_domain *domain;
	struct irq_data *parent_data;
	void *chip_data;
};

struct irqaction;

struct irq_affinity_notify;

struct proc_dir_entry;

struct irq_desc {
	struct irq_common_data irq_common_data;
	struct irq_data irq_data;
	unsigned int *kstat_irqs;
	irq_flow_handler_t handle_irq;
	struct irqaction *action;
	unsigned int status_use_accessors;
	unsigned int core_internal_state__do_not_mess_with_it;
	unsigned int depth;
	unsigned int wake_depth;
	unsigned int tot_count;
	unsigned int irq_count;
	long unsigned int last_unhandled;
	unsigned int irqs_unhandled;
	atomic_t threads_handled;
	int threads_handled_last;
	raw_spinlock_t lock;
	struct cpumask *percpu_enabled;
	const struct cpumask *percpu_affinity;
	const struct cpumask *affinity_hint;
	struct irq_affinity_notify *affinity_notify;
	long unsigned int threads_oneshot;
	atomic_t threads_active;
	wait_queue_head_t wait_for_threads;
	unsigned int nr_actions;
	unsigned int no_suspend_depth;
	unsigned int cond_suspend_depth;
	unsigned int force_resume_depth;
	struct proc_dir_entry *dir;
	struct callback_head rcu;
	struct kobject kobj;
	struct mutex request_mutex;
	int parent_irq;
	struct module *owner;
	const char *name;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum irqreturn {
	IRQ_NONE = 0,
	IRQ_HANDLED = 1,
	IRQ_WAKE_THREAD = 2,
};

typedef enum irqreturn irqreturn_t;

struct fwnode_reference_args;

struct fwnode_endpoint;

struct fwnode_operations {
	struct fwnode_handle * (*get)(struct fwnode_handle *);
	void (*put)(struct fwnode_handle *);
	bool (*device_is_available)(const struct fwnode_handle *);
	const void * (*device_get_match_data)(const struct fwnode_handle *, const struct device *);
	bool (*property_present)(const struct fwnode_handle *, const char *);
	int (*property_read_int_array)(const struct fwnode_handle *, const char *, unsigned int, void *, size_t);
	int (*property_read_string_array)(const struct fwnode_handle *, const char *, const char **, size_t);
	const char * (*get_name)(const struct fwnode_handle *);
	const char * (*get_name_prefix)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_parent)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_next_child_node)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*get_named_child_node)(const struct fwnode_handle *, const char *);
	int (*get_reference_args)(const struct fwnode_handle *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args *);
	struct fwnode_handle * (*graph_get_next_endpoint)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_remote_endpoint)(const struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_port_parent)(struct fwnode_handle *);
	int (*graph_parse_endpoint)(const struct fwnode_handle *, struct fwnode_endpoint *);
	int (*add_links)(struct fwnode_handle *);
};

struct fwnode_endpoint {
	unsigned int port;
	unsigned int id;
	const struct fwnode_handle *local_fwnode;
};

struct fwnode_reference_args {
	struct fwnode_handle *fwnode;
	unsigned int nargs;
	u64 args[8];
};

enum kmalloc_cache_type {
	KMALLOC_NORMAL = 0,
	KMALLOC_RECLAIM = 1,
	KMALLOC_DMA = 2,
	NR_KMALLOC_TYPES = 3,
};

enum irqchip_irq_state {
	IRQCHIP_STATE_PENDING = 0,
	IRQCHIP_STATE_ACTIVE = 1,
	IRQCHIP_STATE_MASKED = 2,
	IRQCHIP_STATE_LINE_LEVEL = 3,
};

struct msi_msg;

struct irq_chip {
	struct device *parent_device;
	const char *name;
	unsigned int (*irq_startup)(struct irq_data *);
	void (*irq_shutdown)(struct irq_data *);
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_ack)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
	void (*irq_mask_ack)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_eoi)(struct irq_data *);
	int (*irq_set_affinity)(struct irq_data *, const struct cpumask *, bool);
	int (*irq_retrigger)(struct irq_data *);
	int (*irq_set_type)(struct irq_data *, unsigned int);
	int (*irq_set_wake)(struct irq_data *, unsigned int);
	void (*irq_bus_lock)(struct irq_data *);
	void (*irq_bus_sync_unlock)(struct irq_data *);
	void (*irq_cpu_online)(struct irq_data *);
	void (*irq_cpu_offline)(struct irq_data *);
	void (*irq_suspend)(struct irq_data *);
	void (*irq_resume)(struct irq_data *);
	void (*irq_pm_shutdown)(struct irq_data *);
	void (*irq_calc_mask)(struct irq_data *);
	void (*irq_print_chip)(struct irq_data *, struct seq_file *);
	int (*irq_request_resources)(struct irq_data *);
	void (*irq_release_resources)(struct irq_data *);
	void (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *);
	void (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *);
	int (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool *);
	int (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool);
	int (*irq_set_vcpu_affinity)(struct irq_data *, void *);
	void (*ipi_send_single)(struct irq_data *, unsigned int);
	void (*ipi_send_mask)(struct irq_data *, const struct cpumask *);
	int (*irq_nmi_setup)(struct irq_data *);
	void (*irq_nmi_teardown)(struct irq_data *);
	long unsigned int flags;
};

typedef irqreturn_t (*irq_handler_t)(int, void *);

struct irqaction {
	irq_handler_t handler;
	void *dev_id;
	void *percpu_dev_id;
	struct irqaction *next;
	irq_handler_t thread_fn;
	struct task_struct *thread;
	struct irqaction *secondary;
	unsigned int irq;
	unsigned int flags;
	long unsigned int thread_flags;
	long unsigned int thread_mask;
	const char *name;
	struct proc_dir_entry *dir;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct irq_affinity_notify {
	unsigned int irq;
	struct kref kref;
	struct work_struct work;
	void (*notify)(struct irq_affinity_notify *, const cpumask_t *);
	void (*release)(struct kref *);
};

struct irq_chip_regs {
	long unsigned int enable;
	long unsigned int disable;
	long unsigned int mask;
	long unsigned int ack;
	long unsigned int eoi;
	long unsigned int type;
	long unsigned int polarity;
};

struct irq_chip_type {
	struct irq_chip chip;
	struct irq_chip_regs regs;
	irq_flow_handler_t handler;
	u32 type;
	u32 mask_cache_priv;
	u32 *mask_cache;
};

struct irq_chip_generic {
	raw_spinlock_t lock;
	void *reg_base;
	u32 (*reg_readl)(void *);
	void (*reg_writel)(u32, void *);
	void (*suspend)(struct irq_chip_generic *);
	void (*resume)(struct irq_chip_generic *);
	unsigned int irq_base;
	unsigned int irq_cnt;
	u32 mask_cache;
	u32 type_cache;
	u32 polarity_cache;
	u32 wake_enabled;
	u32 wake_active;
	unsigned int num_ct;
	void *private;
	long unsigned int installed;
	long unsigned int unused;
	struct irq_domain *domain;
	struct list_head list;
	struct irq_chip_type chip_types[0];
};

enum irq_gc_flags {
	IRQ_GC_INIT_MASK_CACHE = 1,
	IRQ_GC_INIT_NESTED_LOCK = 2,
	IRQ_GC_MASK_CACHE_PER_TYPE = 4,
	IRQ_GC_NO_MASK = 8,
	IRQ_GC_BE_IO = 16,
};

struct irq_domain_chip_generic {
	unsigned int irqs_per_chip;
	unsigned int num_chips;
	unsigned int irq_flags_to_clear;
	unsigned int irq_flags_to_set;
	enum irq_gc_flags gc_flags;
	struct irq_chip_generic *gc[0];
};

struct nmi_ctx {
	u64 hcr;
	unsigned int cnt;
};

enum perf_sw_ids {
	PERF_COUNT_SW_CPU_CLOCK = 0,
	PERF_COUNT_SW_TASK_CLOCK = 1,
	PERF_COUNT_SW_PAGE_FAULTS = 2,
	PERF_COUNT_SW_CONTEXT_SWITCHES = 3,
	PERF_COUNT_SW_CPU_MIGRATIONS = 4,
	PERF_COUNT_SW_PAGE_FAULTS_MIN = 5,
	PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,
	PERF_COUNT_SW_ALIGNMENT_FAULTS = 7,
	PERF_COUNT_SW_EMULATION_FAULTS = 8,
	PERF_COUNT_SW_DUMMY = 9,
	PERF_COUNT_SW_BPF_OUTPUT = 10,
	PERF_COUNT_SW_CGROUP_SWITCHES = 11,
	PERF_COUNT_SW_MAX = 12,
};

union perf_mem_data_src {
	__u64 val;
	struct {
		__u64 mem_op: 5;
		__u64 mem_lvl: 14;
		__u64 mem_snoop: 5;
		__u64 mem_lock: 2;
		__u64 mem_dtlb: 7;
		__u64 mem_lvl_num: 4;
		__u64 mem_remote: 1;
		__u64 mem_snoopx: 2;
		__u64 mem_blk: 3;
		__u64 mem_rsvd: 21;
	};
};

struct perf_branch_entry {
	__u64 from;
	__u64 to;
	__u64 mispred: 1;
	__u64 predicted: 1;
	__u64 in_tx: 1;
	__u64 abort: 1;
	__u64 cycles: 16;
	__u64 type: 4;
	__u64 reserved: 40;
};

union perf_sample_weight {
	__u64 full;
	struct {
		__u32 var1_dw;
		__u16 var2_w;
		__u16 var3_w;
	};
};

struct perf_guest_info_callbacks {
	int (*is_in_guest)();
	int (*is_user_mode)();
	long unsigned int (*get_guest_ip)();
	void (*handle_intel_pt_intr)();
};

struct new_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
	char domainname[65];
};

struct uts_namespace {
	struct new_utsname name;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
};

struct cgroup_namespace {
	struct ns_common ns;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct css_set *root_cset;
};

struct nsset {
	unsigned int flags;
	struct nsproxy *nsproxy;
	struct fs_struct *fs;
	const struct cred *cred;
};

struct proc_ns_operations {
	const char *name;
	const char *real_ns_name;
	int type;
	struct ns_common * (*get)(struct task_struct *);
	void (*put)(struct ns_common *);
	int (*install)(struct nsset *, struct ns_common *);
	struct user_namespace * (*owner)(struct ns_common *);
	struct ns_common * (*get_parent)(struct ns_common *);
};

struct iovec {
	void *iov_base;
	__kernel_size_t iov_len;
};

struct kvec {
	void *iov_base;
	size_t iov_len;
};

struct ftrace_regs {
	struct pt_regs regs;
};

enum ftrace_tracing_type_t {
	FTRACE_TYPE_ENTER = 0,
	FTRACE_TYPE_RETURN = 1,
};

enum ftrace_bug_type {
	FTRACE_BUG_UNKNOWN = 0,
	FTRACE_BUG_INIT = 1,
	FTRACE_BUG_NOP = 2,
	FTRACE_BUG_CALL = 3,
	FTRACE_BUG_UPDATE = 4,
};

struct ftrace_graph_ent {
	long unsigned int func;
	int depth;
} __attribute__((packed));

struct ftrace_graph_ret {
	long unsigned int func;
	int depth;
	unsigned int overrun;
	long long unsigned int calltime;
	long long unsigned int rettime;
};

typedef void (*trace_func_graph_ret_t)(struct ftrace_graph_ret *);

typedef int (*trace_func_graph_ent_t)(struct ftrace_graph_ent *);

struct perf_regs {
	__u64 abi;
	struct pt_regs *regs;
};

struct kernel_cpustat {
	u64 cpustat[10];
};

struct kernel_stat {
	long unsigned int irqs_sum;
	unsigned int softirqs[10];
};

struct u64_stats_sync {};

struct bpf_insn {
	__u8 code;
	__u8 dst_reg: 4;
	__u8 src_reg: 4;
	__s16 off;
	__s32 imm;
};

struct bpf_cgroup_storage_key {
	__u64 cgroup_inode_id;
	__u32 attach_type;
};

enum bpf_map_type {
	BPF_MAP_TYPE_UNSPEC = 0,
	BPF_MAP_TYPE_HASH = 1,
	BPF_MAP_TYPE_ARRAY = 2,
	BPF_MAP_TYPE_PROG_ARRAY = 3,
	BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
	BPF_MAP_TYPE_PERCPU_HASH = 5,
	BPF_MAP_TYPE_PERCPU_ARRAY = 6,
	BPF_MAP_TYPE_STACK_TRACE = 7,
	BPF_MAP_TYPE_CGROUP_ARRAY = 8,
	BPF_MAP_TYPE_LRU_HASH = 9,
	BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
	BPF_MAP_TYPE_LPM_TRIE = 11,
	BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
	BPF_MAP_TYPE_HASH_OF_MAPS = 13,
	BPF_MAP_TYPE_DEVMAP = 14,
	BPF_MAP_TYPE_SOCKMAP = 15,
	BPF_MAP_TYPE_CPUMAP = 16,
	BPF_MAP_TYPE_XSKMAP = 17,
	BPF_MAP_TYPE_SOCKHASH = 18,
	BPF_MAP_TYPE_CGROUP_STORAGE = 19,
	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
	BPF_MAP_TYPE_QUEUE = 22,
	BPF_MAP_TYPE_STACK = 23,
	BPF_MAP_TYPE_SK_STORAGE = 24,
	BPF_MAP_TYPE_DEVMAP_HASH = 25,
	BPF_MAP_TYPE_STRUCT_OPS = 26,
	BPF_MAP_TYPE_RINGBUF = 27,
	BPF_MAP_TYPE_INODE_STORAGE = 28,
	BPF_MAP_TYPE_TASK_STORAGE = 29,
};

enum bpf_prog_type {
	BPF_PROG_TYPE_UNSPEC = 0,
	BPF_PROG_TYPE_SOCKET_FILTER = 1,
	BPF_PROG_TYPE_KPROBE = 2,
	BPF_PROG_TYPE_SCHED_CLS = 3,
	BPF_PROG_TYPE_SCHED_ACT = 4,
	BPF_PROG_TYPE_TRACEPOINT = 5,
	BPF_PROG_TYPE_XDP = 6,
	BPF_PROG_TYPE_PERF_EVENT = 7,
	BPF_PROG_TYPE_CGROUP_SKB = 8,
	BPF_PROG_TYPE_CGROUP_SOCK = 9,
	BPF_PROG_TYPE_LWT_IN = 10,
	BPF_PROG_TYPE_LWT_OUT = 11,
	BPF_PROG_TYPE_LWT_XMIT = 12,
	BPF_PROG_TYPE_SOCK_OPS = 13,
	BPF_PROG_TYPE_SK_SKB = 14,
	BPF_PROG_TYPE_CGROUP_DEVICE = 15,
	BPF_PROG_TYPE_SK_MSG = 16,
	BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
	BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
	BPF_PROG_TYPE_LIRC_MODE2 = 20,
	BPF_PROG_TYPE_SK_REUSEPORT = 21,
	BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
	BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
	BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
	BPF_PROG_TYPE_TRACING = 26,
	BPF_PROG_TYPE_STRUCT_OPS = 27,
	BPF_PROG_TYPE_EXT = 28,
	BPF_PROG_TYPE_LSM = 29,
	BPF_PROG_TYPE_SK_LOOKUP = 30,
};

enum bpf_attach_type {
	BPF_CGROUP_INET_INGRESS = 0,
	BPF_CGROUP_INET_EGRESS = 1,
	BPF_CGROUP_INET_SOCK_CREATE = 2,
	BPF_CGROUP_SOCK_OPS = 3,
	BPF_SK_SKB_STREAM_PARSER = 4,
	BPF_SK_SKB_STREAM_VERDICT = 5,
	BPF_CGROUP_DEVICE = 6,
	BPF_SK_MSG_VERDICT = 7,
	BPF_CGROUP_INET4_BIND = 8,
	BPF_CGROUP_INET6_BIND = 9,
	BPF_CGROUP_INET4_CONNECT = 10,
	BPF_CGROUP_INET6_CONNECT = 11,
	BPF_CGROUP_INET4_POST_BIND = 12,
	BPF_CGROUP_INET6_POST_BIND = 13,
	BPF_CGROUP_UDP4_SENDMSG = 14,
	BPF_CGROUP_UDP6_SENDMSG = 15,
	BPF_LIRC_MODE2 = 16,
	BPF_FLOW_DISSECTOR = 17,
	BPF_CGROUP_SYSCTL = 18,
	BPF_CGROUP_UDP4_RECVMSG = 19,
	BPF_CGROUP_UDP6_RECVMSG = 20,
	BPF_CGROUP_GETSOCKOPT = 21,
	BPF_CGROUP_SETSOCKOPT = 22,
	BPF_TRACE_RAW_TP = 23,
	BPF_TRACE_FENTRY = 24,
	BPF_TRACE_FEXIT = 25,
	BPF_MODIFY_RETURN = 26,
	BPF_LSM_MAC = 27,
	BPF_TRACE_ITER = 28,
	BPF_CGROUP_INET4_GETPEERNAME = 29,
	BPF_CGROUP_INET6_GETPEERNAME = 30,
	BPF_CGROUP_INET4_GETSOCKNAME = 31,
	BPF_CGROUP_INET6_GETSOCKNAME = 32,
	BPF_XDP_DEVMAP = 33,
	BPF_CGROUP_INET_SOCK_RELEASE = 34,
	BPF_XDP_CPUMAP = 35,
	BPF_SK_LOOKUP = 36,
	BPF_XDP = 37,
	BPF_SK_SKB_VERDICT = 38,
	__MAX_BPF_ATTACH_TYPE = 39,
};

union bpf_attr {
	struct {
		__u32 map_type;
		__u32 key_size;
		__u32 value_size;
		__u32 max_entries;
		__u32 map_flags;
		__u32 inner_map_fd;
		__u32 numa_node;
		char map_name[16];
		__u32 map_ifindex;
		__u32 btf_fd;
		__u32 btf_key_type_id;
		__u32 btf_value_type_id;
		__u32 btf_vmlinux_value_type_id;
	};
	struct {
		__u32 map_fd;
		__u64 key;
		union {
			__u64 value;
			__u64 next_key;
		};
		__u64 flags;
	};
	struct {
		__u64 in_batch;
		__u64 out_batch;
		__u64 keys;
		__u64 values;
		__u32 count;
		__u32 map_fd;
		__u64 elem_flags;
		__u64 flags;
	} batch;
	struct {
		__u32 prog_type;
		__u32 insn_cnt;
		__u64 insns;
		__u64 license;
		__u32 log_level;
		__u32 log_size;
		__u64 log_buf;
		__u32 kern_version;
		__u32 prog_flags;
		char prog_name[16];
		__u32 prog_ifindex;
		__u32 expected_attach_type;
		__u32 prog_btf_fd;
		__u32 func_info_rec_size;
		__u64 func_info;
		__u32 func_info_cnt;
		__u32 line_info_rec_size;
		__u64 line_info;
		__u32 line_info_cnt;
		__u32 attach_btf_id;
		union {
			__u32 attach_prog_fd;
			__u32 attach_btf_obj_fd;
		};
	};
	struct {
		__u64 pathname;
		__u32 bpf_fd;
		__u32 file_flags;
	};
	struct {
		__u32 target_fd;
		__u32 attach_bpf_fd;
		__u32 attach_type;
		__u32 attach_flags;
		__u32 replace_bpf_fd;
	};
	struct {
		__u32 prog_fd;
		__u32 retval;
		__u32 data_size_in;
		__u32 data_size_out;
		__u64 data_in;
		__u64 data_out;
		__u32 repeat;
		__u32 duration;
		__u32 ctx_size_in;
		__u32 ctx_size_out;
		__u64 ctx_in;
		__u64 ctx_out;
		__u32 flags;
		__u32 cpu;
	} test;
	struct {
		union {
			__u32 start_id;
			__u32 prog_id;
			__u32 map_id;
			__u32 btf_id;
			__u32 link_id;
		};
		__u32 next_id;
		__u32 open_flags;
	};
	struct {
		__u32 bpf_fd;
		__u32 info_len;
		__u64 info;
	} info;
	struct {
		__u32 target_fd;
		__u32 attach_type;
		__u32 query_flags;
		__u32 attach_flags;
		__u64 prog_ids;
		__u32 prog_cnt;
	} query;
	struct {
		__u64 name;
		__u32 prog_fd;
	} raw_tracepoint;
	struct {
		__u64 btf;
		__u64 btf_log_buf;
		__u32 btf_size;
		__u32 btf_log_size;
		__u32 btf_log_level;
	};
	struct {
		__u32 pid;
		__u32 fd;
		__u32 flags;
		__u32 buf_len;
		__u64 buf;
		__u32 prog_id;
		__u32 fd_type;
		__u64 probe_offset;
		__u64 probe_addr;
	} task_fd_query;
	struct {
		__u32 prog_fd;
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_type;
		__u32 flags;
		union {
			__u32 target_btf_id;
			struct {
				__u64 iter_info;
				__u32 iter_info_len;
			};
		};
	} link_create;
	struct {
		__u32 link_fd;
		__u32 new_prog_fd;
		__u32 flags;
		__u32 old_prog_fd;
	} link_update;
	struct {
		__u32 link_fd;
	} link_detach;
	struct {
		__u32 type;
	} enable_stats;
	struct {
		__u32 link_fd;
		__u32 flags;
	} iter_create;
	struct {
		__u32 prog_fd;
		__u32 map_fd;
		__u32 flags;
	} prog_bind_map;
};

enum bpf_func_id {
	BPF_FUNC_unspec = 0,
	BPF_FUNC_map_lookup_elem = 1,
	BPF_FUNC_map_update_elem = 2,
	BPF_FUNC_map_delete_elem = 3,
	BPF_FUNC_probe_read = 4,
	BPF_FUNC_ktime_get_ns = 5,
	BPF_FUNC_trace_printk = 6,
	BPF_FUNC_get_prandom_u32 = 7,
	BPF_FUNC_get_smp_processor_id = 8,
	BPF_FUNC_skb_store_bytes = 9,
	BPF_FUNC_l3_csum_replace = 10,
	BPF_FUNC_l4_csum_replace = 11,
	BPF_FUNC_tail_call = 12,
	BPF_FUNC_clone_redirect = 13,
	BPF_FUNC_get_current_pid_tgid = 14,
	BPF_FUNC_get_current_uid_gid = 15,
	BPF_FUNC_get_current_comm = 16,
	BPF_FUNC_get_cgroup_classid = 17,
	BPF_FUNC_skb_vlan_push = 18,
	BPF_FUNC_skb_vlan_pop = 19,
	BPF_FUNC_skb_get_tunnel_key = 20,
	BPF_FUNC_skb_set_tunnel_key = 21,
	BPF_FUNC_perf_event_read = 22,
	BPF_FUNC_redirect = 23,
	BPF_FUNC_get_route_realm = 24,
	BPF_FUNC_perf_event_output = 25,
	BPF_FUNC_skb_load_bytes = 26,
	BPF_FUNC_get_stackid = 27,
	BPF_FUNC_csum_diff = 28,
	BPF_FUNC_skb_get_tunnel_opt = 29,
	BPF_FUNC_skb_set_tunnel_opt = 30,
	BPF_FUNC_skb_change_proto = 31,
	BPF_FUNC_skb_change_type = 32,
	BPF_FUNC_skb_under_cgroup = 33,
	BPF_FUNC_get_hash_recalc = 34,
	BPF_FUNC_get_current_task = 35,
	BPF_FUNC_probe_write_user = 36,
	BPF_FUNC_current_task_under_cgroup = 37,
	BPF_FUNC_skb_change_tail = 38,
	BPF_FUNC_skb_pull_data = 39,
	BPF_FUNC_csum_update = 40,
	BPF_FUNC_set_hash_invalid = 41,
	BPF_FUNC_get_numa_node_id = 42,
	BPF_FUNC_skb_change_head = 43,
	BPF_FUNC_xdp_adjust_head = 44,
	BPF_FUNC_probe_read_str = 45,
	BPF_FUNC_get_socket_cookie = 46,
	BPF_FUNC_get_socket_uid = 47,
	BPF_FUNC_set_hash = 48,
	BPF_FUNC_setsockopt = 49,
	BPF_FUNC_skb_adjust_room = 50,
	BPF_FUNC_redirect_map = 51,
	BPF_FUNC_sk_redirect_map = 52,
	BPF_FUNC_sock_map_update = 53,
	BPF_FUNC_xdp_adjust_meta = 54,
	BPF_FUNC_perf_event_read_value = 55,
	BPF_FUNC_perf_prog_read_value = 56,
	BPF_FUNC_getsockopt = 57,
	BPF_FUNC_override_return = 58,
	BPF_FUNC_sock_ops_cb_flags_set = 59,
	BPF_FUNC_msg_redirect_map = 60,
	BPF_FUNC_msg_apply_bytes = 61,
	BPF_FUNC_msg_cork_bytes = 62,
	BPF_FUNC_msg_pull_data = 63,
	BPF_FUNC_bind = 64,
	BPF_FUNC_xdp_adjust_tail = 65,
	BPF_FUNC_skb_get_xfrm_state = 66,
	BPF_FUNC_get_stack = 67,
	BPF_FUNC_skb_load_bytes_relative = 68,
	BPF_FUNC_fib_lookup = 69,
	BPF_FUNC_sock_hash_update = 70,
	BPF_FUNC_msg_redirect_hash = 71,
	BPF_FUNC_sk_redirect_hash = 72,
	BPF_FUNC_lwt_push_encap = 73,
	BPF_FUNC_lwt_seg6_store_bytes = 74,
	BPF_FUNC_lwt_seg6_adjust_srh = 75,
	BPF_FUNC_lwt_seg6_action = 76,
	BPF_FUNC_rc_repeat = 77,
	BPF_FUNC_rc_keydown = 78,
	BPF_FUNC_skb_cgroup_id = 79,
	BPF_FUNC_get_current_cgroup_id = 80,
	BPF_FUNC_get_local_storage = 81,
	BPF_FUNC_sk_select_reuseport = 82,
	BPF_FUNC_skb_ancestor_cgroup_id = 83,
	BPF_FUNC_sk_lookup_tcp = 84,
	BPF_FUNC_sk_lookup_udp = 85,
	BPF_FUNC_sk_release = 86,
	BPF_FUNC_map_push_elem = 87,
	BPF_FUNC_map_pop_elem = 88,
	BPF_FUNC_map_peek_elem = 89,
	BPF_FUNC_msg_push_data = 90,
	BPF_FUNC_msg_pop_data = 91,
	BPF_FUNC_rc_pointer_rel = 92,
	BPF_FUNC_spin_lock = 93,
	BPF_FUNC_spin_unlock = 94,
	BPF_FUNC_sk_fullsock = 95,
	BPF_FUNC_tcp_sock = 96,
	BPF_FUNC_skb_ecn_set_ce = 97,
	BPF_FUNC_get_listener_sock = 98,
	BPF_FUNC_skc_lookup_tcp = 99,
	BPF_FUNC_tcp_check_syncookie = 100,
	BPF_FUNC_sysctl_get_name = 101,
	BPF_FUNC_sysctl_get_current_value = 102,
	BPF_FUNC_sysctl_get_new_value = 103,
	BPF_FUNC_sysctl_set_new_value = 104,
	BPF_FUNC_strtol = 105,
	BPF_FUNC_strtoul = 106,
	BPF_FUNC_sk_storage_get = 107,
	BPF_FUNC_sk_storage_delete = 108,
	BPF_FUNC_send_signal = 109,
	BPF_FUNC_tcp_gen_syncookie = 110,
	BPF_FUNC_skb_output = 111,
	BPF_FUNC_probe_read_user = 112,
	BPF_FUNC_probe_read_kernel = 113,
	BPF_FUNC_probe_read_user_str = 114,
	BPF_FUNC_probe_read_kernel_str = 115,
	BPF_FUNC_tcp_send_ack = 116,
	BPF_FUNC_send_signal_thread = 117,
	BPF_FUNC_jiffies64 = 118,
	BPF_FUNC_read_branch_records = 119,
	BPF_FUNC_get_ns_current_pid_tgid = 120,
	BPF_FUNC_xdp_output = 121,
	BPF_FUNC_get_netns_cookie = 122,
	BPF_FUNC_get_current_ancestor_cgroup_id = 123,
	BPF_FUNC_sk_assign = 124,
	BPF_FUNC_ktime_get_boot_ns = 125,
	BPF_FUNC_seq_printf = 126,
	BPF_FUNC_seq_write = 127,
	BPF_FUNC_sk_cgroup_id = 128,
	BPF_FUNC_sk_ancestor_cgroup_id = 129,
	BPF_FUNC_ringbuf_output = 130,
	BPF_FUNC_ringbuf_reserve = 131,
	BPF_FUNC_ringbuf_submit = 132,
	BPF_FUNC_ringbuf_discard = 133,
	BPF_FUNC_ringbuf_query = 134,
	BPF_FUNC_csum_level = 135,
	BPF_FUNC_skc_to_tcp6_sock = 136,
	BPF_FUNC_skc_to_tcp_sock = 137,
	BPF_FUNC_skc_to_tcp_timewait_sock = 138,
	BPF_FUNC_skc_to_tcp_request_sock = 139,
	BPF_FUNC_skc_to_udp6_sock = 140,
	BPF_FUNC_get_task_stack = 141,
	BPF_FUNC_load_hdr_opt = 142,
	BPF_FUNC_store_hdr_opt = 143,
	BPF_FUNC_reserve_hdr_opt = 144,
	BPF_FUNC_inode_storage_get = 145,
	BPF_FUNC_inode_storage_delete = 146,
	BPF_FUNC_d_path = 147,
	BPF_FUNC_copy_from_user = 148,
	BPF_FUNC_snprintf_btf = 149,
	BPF_FUNC_seq_printf_btf = 150,
	BPF_FUNC_skb_cgroup_classid = 151,
	BPF_FUNC_redirect_neigh = 152,
	BPF_FUNC_per_cpu_ptr = 153,
	BPF_FUNC_this_cpu_ptr = 154,
	BPF_FUNC_redirect_peer = 155,
	BPF_FUNC_task_storage_get = 156,
	BPF_FUNC_task_storage_delete = 157,
	BPF_FUNC_get_current_task_btf = 158,
	BPF_FUNC_bprm_opts_set = 159,
	BPF_FUNC_ktime_get_coarse_ns = 160,
	BPF_FUNC_ima_inode_hash = 161,
	BPF_FUNC_sock_from_file = 162,
	BPF_FUNC_check_mtu = 163,
	BPF_FUNC_for_each_map_elem = 164,
	BPF_FUNC_snprintf = 165,
	__BPF_FUNC_MAX_ID = 166,
};

struct bpf_func_info {
	__u32 insn_off;
	__u32 type_id;
};

struct bpf_line_info {
	__u32 insn_off;
	__u32 file_name_off;
	__u32 line_off;
	__u32 line_col;
};

struct bpf_iter_aux_info;

typedef int (*bpf_iter_init_seq_priv_t)(void *, struct bpf_iter_aux_info *);

struct bpf_map;

struct bpf_iter_aux_info {
	struct bpf_map *map;
};

typedef void (*bpf_iter_fini_seq_priv_t)(void *);

struct bpf_iter_seq_info {
	const struct seq_operations *seq_ops;
	bpf_iter_init_seq_priv_t init_seq_private;
	bpf_iter_fini_seq_priv_t fini_seq_private;
	u32 seq_priv_size;
};

struct btf;

struct btf_type;

struct bpf_prog_aux;

struct bpf_local_storage_map;

struct bpf_verifier_env;

struct bpf_func_state;

struct bpf_map_ops {
	int (*map_alloc_check)(union bpf_attr *);
	struct bpf_map * (*map_alloc)(union bpf_attr *);
	void (*map_release)(struct bpf_map *, struct file *);
	void (*map_free)(struct bpf_map *);
	int (*map_get_next_key)(struct bpf_map *, void *, void *);
	void (*map_release_uref)(struct bpf_map *);
	void * (*map_lookup_elem_sys_only)(struct bpf_map *, void *);
	int (*map_lookup_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_lookup_and_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_update_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	void * (*map_lookup_elem)(struct bpf_map *, void *);
	int (*map_update_elem)(struct bpf_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_map *, void *);
	int (*map_push_elem)(struct bpf_map *, void *, u64);
	int (*map_pop_elem)(struct bpf_map *, void *);
	int (*map_peek_elem)(struct bpf_map *, void *);
	void * (*map_fd_get_ptr)(struct bpf_map *, struct file *, int);
	void (*map_fd_put_ptr)(void *);
	int (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *);
	u32 (*map_fd_sys_lookup_elem)(void *);
	void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *);
	int (*map_check_btf)(const struct bpf_map *, const struct btf *, const struct btf_type *, const struct btf_type *);
	int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_run)(struct bpf_map *, u32, struct bpf_prog *, struct bpf_prog *);
	int (*map_direct_value_addr)(const struct bpf_map *, u64 *, u32);
	int (*map_direct_value_meta)(const struct bpf_map *, u64, u32 *);
	int (*map_mmap)(struct bpf_map *, struct vm_area_struct *);
	__poll_t (*map_poll)(struct bpf_map *, struct file *, struct poll_table_struct *);
	int (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);
	void (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);
	struct bpf_local_storage ** (*map_owner_storage_ptr)(void *);
	int (*map_redirect)(struct bpf_map *, u32, u64);
	bool (*map_meta_equal)(const struct bpf_map *, const struct bpf_map *);
	int (*map_set_for_each_callback_args)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *);
	int (*map_for_each_callback)(struct bpf_map *, void *, void *, u64);
	const char * const map_btf_name;
	int *map_btf_id;
	const struct bpf_iter_seq_info *iter_seq_info;
};

struct bpf_map {
	const struct bpf_map_ops *ops;
	struct bpf_map *inner_map_meta;
	void *security;
	enum bpf_map_type map_type;
	u32 key_size;
	u32 value_size;
	u32 max_entries;
	u32 map_flags;
	int spin_lock_off;
	u32 id;
	int numa_node;
	u32 btf_key_type_id;
	u32 btf_value_type_id;
	struct btf *btf;
	struct mem_cgroup *memcg;
	char name[16];
	u32 btf_vmlinux_value_type_id;
	bool bypass_spec_v1;
	bool frozen;
	long: 16;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t refcnt;
	atomic64_t usercnt;
	struct work_struct work;
	struct mutex freeze_mutex;
	atomic64_t writecnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct btf_header {
	__u16 magic;
	__u8 version;
	__u8 flags;
	__u32 hdr_len;
	__u32 type_off;
	__u32 type_len;
	__u32 str_off;
	__u32 str_len;
};

struct btf {
	void *data;
	struct btf_type **types;
	u32 *resolved_ids;
	u32 *resolved_sizes;
	const char *strings;
	void *nohdr_data;
	struct btf_header hdr;
	u32 nr_types;
	u32 types_size;
	u32 data_size;
	refcount_t refcnt;
	u32 id;
	struct callback_head rcu;
	struct btf *base_btf;
	u32 start_id;
	u32 start_str_off;
	char name[56];
	bool kernel_btf;
};

struct btf_type {
	__u32 name_off;
	__u32 info;
	union {
		__u32 size;
		__u32 type;
	};
};

struct bpf_ksym {
	long unsigned int start;
	long unsigned int end;
	char name[128];
	struct list_head lnode;
	struct latch_tree_node tnode;
	bool prog;
};

struct bpf_ctx_arg_aux;

struct bpf_trampoline;

struct bpf_jit_poke_descriptor;

struct bpf_kfunc_desc_tab;

struct bpf_prog_ops;

struct btf_mod_pair;

struct bpf_prog_offload;

struct bpf_func_info_aux;

struct bpf_prog_aux {
	atomic64_t refcnt;
	u32 used_map_cnt;
	u32 used_btf_cnt;
	u32 max_ctx_offset;
	u32 max_pkt_offset;
	u32 max_tp_access;
	u32 stack_depth;
	u32 id;
	u32 func_cnt;
	u32 func_idx;
	u32 attach_btf_id;
	u32 ctx_arg_info_size;
	u32 max_rdonly_access;
	u32 max_rdwr_access;
	struct btf *attach_btf;
	const struct bpf_ctx_arg_aux *ctx_arg_info;
	struct mutex dst_mutex;
	struct bpf_prog *dst_prog;
	struct bpf_trampoline *dst_trampoline;
	enum bpf_prog_type saved_dst_prog_type;
	enum bpf_attach_type saved_dst_attach_type;
	bool verifier_zext;
	bool offload_requested;
	bool attach_btf_trace;
	bool func_proto_unreliable;
	bool sleepable;
	bool tail_call_reachable;
	struct hlist_node tramp_hlist;
	const struct btf_type *attach_func_proto;
	const char *attach_func_name;
	struct bpf_prog **func;
	void *jit_data;
	struct bpf_jit_poke_descriptor *poke_tab;
	struct bpf_kfunc_desc_tab *kfunc_tab;
	u32 size_poke_tab;
	struct bpf_ksym ksym;
	const struct bpf_prog_ops *ops;
	struct bpf_map **used_maps;
	struct mutex used_maps_mutex;
	struct btf_mod_pair *used_btfs;
	struct bpf_prog *prog;
	struct user_struct *user;
	u64 load_time;
	struct bpf_map *cgroup_storage[2];
	char name[16];
	void *security;
	struct bpf_prog_offload *offload;
	struct btf *btf;
	struct bpf_func_info *func_info;
	struct bpf_func_info_aux *func_info_aux;
	struct bpf_line_info *linfo;
	void **jited_linfo;
	u32 func_info_cnt;
	u32 nr_linfo;
	u32 linfo_idx;
	u32 num_exentries;
	struct exception_table_entry *extable;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
};

struct sock_filter {
	__u16 code;
	__u8 jt;
	__u8 jf;
	__u32 k;
};

struct bpf_prog_stats;

struct sock_fprog_kern;

struct bpf_prog {
	u16 pages;
	u16 jited: 1;
	u16 jit_requested: 1;
	u16 gpl_compatible: 1;
	u16 cb_access: 1;
	u16 dst_needed: 1;
	u16 blinded: 1;
	u16 is_func: 1;
	u16 kprobe_override: 1;
	u16 has_callchain_buf: 1;
	u16 enforce_expected_attach_type: 1;
	u16 call_get_stack: 1;
	enum bpf_prog_type type;
	enum bpf_attach_type expected_attach_type;
	u32 len;
	u32 jited_len;
	u8 tag[8];
	struct bpf_prog_stats *stats;
	int *active;
	unsigned int (*bpf_func)(const void *, const struct bpf_insn *);
	struct bpf_prog_aux *aux;
	struct sock_fprog_kern *orig_prog;
	struct sock_filter insns[0];
	struct bpf_insn insnsi[0];
};

enum bpf_arg_type {
	ARG_DONTCARE = 0,
	ARG_CONST_MAP_PTR = 1,
	ARG_PTR_TO_MAP_KEY = 2,
	ARG_PTR_TO_MAP_VALUE = 3,
	ARG_PTR_TO_UNINIT_MAP_VALUE = 4,
	ARG_PTR_TO_MAP_VALUE_OR_NULL = 5,
	ARG_PTR_TO_MEM = 6,
	ARG_PTR_TO_MEM_OR_NULL = 7,
	ARG_PTR_TO_UNINIT_MEM = 8,
	ARG_CONST_SIZE = 9,
	ARG_CONST_SIZE_OR_ZERO = 10,
	ARG_PTR_TO_CTX = 11,
	ARG_PTR_TO_CTX_OR_NULL = 12,
	ARG_ANYTHING = 13,
	ARG_PTR_TO_SPIN_LOCK = 14,
	ARG_PTR_TO_SOCK_COMMON = 15,
	ARG_PTR_TO_INT = 16,
	ARG_PTR_TO_LONG = 17,
	ARG_PTR_TO_SOCKET = 18,
	ARG_PTR_TO_SOCKET_OR_NULL = 19,
	ARG_PTR_TO_BTF_ID = 20,
	ARG_PTR_TO_ALLOC_MEM = 21,
	ARG_PTR_TO_ALLOC_MEM_OR_NULL = 22,
	ARG_CONST_ALLOC_SIZE_OR_ZERO = 23,
	ARG_PTR_TO_BTF_ID_SOCK_COMMON = 24,
	ARG_PTR_TO_PERCPU_BTF_ID = 25,
	ARG_PTR_TO_FUNC = 26,
	ARG_PTR_TO_STACK_OR_NULL = 27,
	ARG_PTR_TO_CONST_STR = 28,
	__BPF_ARG_TYPE_MAX = 29,
};

enum bpf_return_type {
	RET_INTEGER = 0,
	RET_VOID = 1,
	RET_PTR_TO_MAP_VALUE = 2,
	RET_PTR_TO_MAP_VALUE_OR_NULL = 3,
	RET_PTR_TO_SOCKET_OR_NULL = 4,
	RET_PTR_TO_TCP_SOCK_OR_NULL = 5,
	RET_PTR_TO_SOCK_COMMON_OR_NULL = 6,
	RET_PTR_TO_ALLOC_MEM_OR_NULL = 7,
	RET_PTR_TO_BTF_ID_OR_NULL = 8,
	RET_PTR_TO_MEM_OR_BTF_ID_OR_NULL = 9,
	RET_PTR_TO_MEM_OR_BTF_ID = 10,
	RET_PTR_TO_BTF_ID = 11,
};

struct bpf_func_proto {
	u64 (*func)(u64, u64, u64, u64, u64);
	bool gpl_only;
	bool pkt_access;
	enum bpf_return_type ret_type;
	union {
		struct {
			enum bpf_arg_type arg1_type;
			enum bpf_arg_type arg2_type;
			enum bpf_arg_type arg3_type;
			enum bpf_arg_type arg4_type;
			enum bpf_arg_type arg5_type;
		};
		enum bpf_arg_type arg_type[5];
	};
	union {
		struct {
			u32 *arg1_btf_id;
			u32 *arg2_btf_id;
			u32 *arg3_btf_id;
			u32 *arg4_btf_id;
			u32 *arg5_btf_id;
		};
		u32 *arg_btf_id[5];
	};
	int *ret_btf_id;
	bool (*allowed)(const struct bpf_prog *);
};

enum bpf_access_type {
	BPF_READ = 1,
	BPF_WRITE = 2,
};

enum bpf_reg_type {
	NOT_INIT = 0,
	SCALAR_VALUE = 1,
	PTR_TO_CTX = 2,
	CONST_PTR_TO_MAP = 3,
	PTR_TO_MAP_VALUE = 4,
	PTR_TO_MAP_VALUE_OR_NULL = 5,
	PTR_TO_STACK = 6,
	PTR_TO_PACKET_META = 7,
	PTR_TO_PACKET = 8,
	PTR_TO_PACKET_END = 9,
	PTR_TO_FLOW_KEYS = 10,
	PTR_TO_SOCKET = 11,
	PTR_TO_SOCKET_OR_NULL = 12,
	PTR_TO_SOCK_COMMON = 13,
	PTR_TO_SOCK_COMMON_OR_NULL = 14,
	PTR_TO_TCP_SOCK = 15,
	PTR_TO_TCP_SOCK_OR_NULL = 16,
	PTR_TO_TP_BUFFER = 17,
	PTR_TO_XDP_SOCK = 18,
	PTR_TO_BTF_ID = 19,
	PTR_TO_BTF_ID_OR_NULL = 20,
	PTR_TO_MEM = 21,
	PTR_TO_MEM_OR_NULL = 22,
	PTR_TO_RDONLY_BUF = 23,
	PTR_TO_RDONLY_BUF_OR_NULL = 24,
	PTR_TO_RDWR_BUF = 25,
	PTR_TO_RDWR_BUF_OR_NULL = 26,
	PTR_TO_PERCPU_BTF_ID = 27,
	PTR_TO_FUNC = 28,
	PTR_TO_MAP_KEY = 29,
	__BPF_REG_TYPE_MAX = 30,
};

struct bpf_verifier_log;

struct bpf_insn_access_aux {
	enum bpf_reg_type reg_type;
	union {
		int ctx_field_size;
		struct {
			struct btf *btf;
			u32 btf_id;
		};
	};
	struct bpf_verifier_log *log;
};

struct bpf_prog_ops {
	int (*test_run)(struct bpf_prog *, const union bpf_attr *, union bpf_attr *);
};

struct bpf_verifier_ops {
	const struct bpf_func_proto * (*get_func_proto)(enum bpf_func_id, const struct bpf_prog *);
	bool (*is_valid_access)(int, int, enum bpf_access_type, const struct bpf_prog *, struct bpf_insn_access_aux *);
	int (*gen_prologue)(struct bpf_insn *, bool, const struct bpf_prog *);
	int (*gen_ld_abs)(const struct bpf_insn *, struct bpf_insn *);
	u32 (*convert_ctx_access)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);
	int (*btf_struct_access)(struct bpf_verifier_log *, const struct btf *, const struct btf_type *, int, int, enum bpf_access_type, u32 *);
	bool (*check_kfunc_call)(u32);
};

struct net_device;

struct bpf_offload_dev;

struct bpf_prog_offload {
	struct bpf_prog *prog;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	void *dev_priv;
	struct list_head offloads;
	bool dev_state;
	bool opt_failed;
	void *jited_image;
	u32 jited_len;
};

struct btf_func_model {
	u8 ret_size;
	u8 nr_args;
	u8 arg_size[12];
};

struct bpf_tramp_image {
	void *image;
	struct bpf_ksym ksym;
	struct percpu_ref pcref;
	void *ip_after_call;
	void *ip_epilogue;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
};

struct bpf_trampoline {
	struct hlist_node hlist;
	struct mutex mutex;
	refcount_t refcnt;
	u64 key;
	struct {
		struct btf_func_model model;
		void *addr;
		bool ftrace_managed;
	} func;
	struct bpf_prog *extension_prog;
	struct hlist_head progs_hlist[3];
	int progs_cnt[3];
	struct bpf_tramp_image *cur_image;
	u64 selector;
	struct module *mod;
};

struct bpf_func_info_aux {
	u16 linkage;
	bool unreliable;
};

struct bpf_jit_poke_descriptor {
	void *tailcall_target;
	void *tailcall_bypass;
	void *bypass_addr;
	void *aux;
	union {
		struct {
			struct bpf_map *map;
			u32 key;
		} tail_call;
	};
	bool tailcall_target_stable;
	u8 adj_off;
	u16 reason;
	u32 insn_idx;
};

struct bpf_ctx_arg_aux {
	u32 offset;
	enum bpf_reg_type reg_type;
	u32 btf_id;
};

struct btf_mod_pair {
	struct btf *btf;
	struct module *module;
};

struct bpf_cgroup_storage;

struct bpf_prog_array_item {
	struct bpf_prog *prog;
	struct bpf_cgroup_storage *cgroup_storage[2];
};

struct bpf_storage_buffer;

struct bpf_cgroup_storage_map;

struct bpf_cgroup_storage {
	union {
		struct bpf_storage_buffer *buf;
		void *percpu_buf;
	};
	struct bpf_cgroup_storage_map *map;
	struct bpf_cgroup_storage_key key;
	struct list_head list_map;
	struct list_head list_cg;
	struct rb_node node;
	struct callback_head rcu;
};

struct bpf_prog_array {
	struct callback_head rcu;
	struct bpf_prog_array_item items[0];
};

struct bpf_cgroup_storage_info {
	struct task_struct *task;
	struct bpf_cgroup_storage *storage[2];
};

struct bpf_storage_buffer {
	struct callback_head rcu;
	char data[0];
};

struct psi_group_cpu {
	seqcount_t seq;
	unsigned int tasks[5];
	u32 state_mask;
	u32 times[7];
	u64 state_start;
	u32 times_prev[14];
	long: 64;
};

struct cgroup_taskset;

struct cftype;

struct cgroup_subsys {
	struct cgroup_subsys_state * (*css_alloc)(struct cgroup_subsys_state *);
	int (*css_online)(struct cgroup_subsys_state *);
	void (*css_offline)(struct cgroup_subsys_state *);
	void (*css_released)(struct cgroup_subsys_state *);
	void (*css_free)(struct cgroup_subsys_state *);
	void (*css_reset)(struct cgroup_subsys_state *);
	void (*css_rstat_flush)(struct cgroup_subsys_state *, int);
	int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*can_attach)(struct cgroup_taskset *);
	void (*cancel_attach)(struct cgroup_taskset *);
	void (*attach)(struct cgroup_taskset *);
	void (*post_attach)();
	int (*can_fork)(struct task_struct *, struct css_set *);
	void (*cancel_fork)(struct task_struct *, struct css_set *);
	void (*fork)(struct task_struct *);
	void (*exit)(struct task_struct *);
	void (*release)(struct task_struct *);
	void (*bind)(struct cgroup_subsys_state *);
	bool early_init: 1;
	bool implicit_on_dfl: 1;
	bool threaded: 1;
	int id;
	const char *name;
	const char *legacy_name;
	struct cgroup_root *root;
	struct idr css_idr;
	struct list_head cfts;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	unsigned int depends_on;
};

struct cgroup_rstat_cpu {
	struct u64_stats_sync bsync;
	struct cgroup_base_stat bstat;
	struct cgroup_base_stat last_bstat;
	struct cgroup *updated_children;
	struct cgroup *updated_next;
};

struct cgroup_root {
	struct kernfs_root *kf_root;
	unsigned int subsys_mask;
	int hierarchy_id;
	struct cgroup cgrp;
	u64 cgrp_ancestor_id_storage;
	atomic_t nr_cgrps;
	struct list_head root_list;
	unsigned int flags;
	char release_agent_path[4096];
	char name[64];
};

struct cftype {
	char name[64];
	long unsigned int private;
	size_t max_write_len;
	unsigned int flags;
	unsigned int file_offset;
	struct cgroup_subsys *ss;
	struct list_head node;
	struct kernfs_ops *kf_ops;
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *);
	s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64);
	int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64);
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
};

struct perf_callchain_entry {
	__u64 nr;
	__u64 ip[0];
};

typedef long unsigned int (*perf_copy_f)(void *, const void *, long unsigned int, long unsigned int);

struct perf_raw_frag {
	union {
		struct perf_raw_frag *next;
		long unsigned int pad;
	};
	perf_copy_f copy;
	void *data;
	u32 size;
} __attribute__((packed));

struct perf_raw_record {
	struct perf_raw_frag frag;
	u32 size;
};

struct perf_branch_stack {
	__u64 nr;
	__u64 hw_idx;
	struct perf_branch_entry entries[0];
};

struct perf_cpu_context;

struct perf_output_handle;

struct pmu {
	struct list_head entry;
	struct module *module;
	struct device *dev;
	const struct attribute_group **attr_groups;
	const struct attribute_group **attr_update;
	const char *name;
	int type;
	int capabilities;
	int *pmu_disable_count;
	struct perf_cpu_context *pmu_cpu_context;
	atomic_t exclusive_cnt;
	int task_ctx_nr;
	int hrtimer_interval_ms;
	unsigned int nr_addr_filters;
	void (*pmu_enable)(struct pmu *);
	void (*pmu_disable)(struct pmu *);
	int (*event_init)(struct perf_event *);
	void (*event_mapped)(struct perf_event *, struct mm_struct *);
	void (*event_unmapped)(struct perf_event *, struct mm_struct *);
	int (*add)(struct perf_event *, int);
	void (*del)(struct perf_event *, int);
	void (*start)(struct perf_event *, int);
	void (*stop)(struct perf_event *, int);
	void (*read)(struct perf_event *);
	void (*start_txn)(struct pmu *, unsigned int);
	int (*commit_txn)(struct pmu *);
	void (*cancel_txn)(struct pmu *);
	int (*event_idx)(struct perf_event *);
	void (*sched_task)(struct perf_event_context *, bool);
	struct kmem_cache *task_ctx_cache;
	void (*swap_task_ctx)(struct perf_event_context *, struct perf_event_context *);
	void * (*setup_aux)(struct perf_event *, void **, int, bool);
	void (*free_aux)(void *);
	long int (*snapshot_aux)(struct perf_event *, struct perf_output_handle *, long unsigned int);
	int (*addr_filters_validate)(struct list_head *);
	void (*addr_filters_sync)(struct perf_event *);
	int (*aux_output_match)(struct perf_event *);
	int (*filter_match)(struct perf_event *);
	int (*check_period)(struct perf_event *, u64);
};

struct perf_cpu_context {
	struct perf_event_context ctx;
	struct perf_event_context *task_ctx;
	int active_oncpu;
	int exclusive;
	raw_spinlock_t hrtimer_lock;
	struct hrtimer hrtimer;
	ktime_t hrtimer_interval;
	unsigned int hrtimer_active;
	struct perf_cgroup *cgrp;
	struct list_head cgrp_cpuctx_entry;
	struct list_head sched_cb_entry;
	int sched_cb_usage;
	int online;
	int heap_size;
	struct perf_event **heap;
	struct perf_event *heap_default[2];
};

struct perf_output_handle {
	struct perf_event *event;
	struct perf_buffer *rb;
	long unsigned int wakeup;
	long unsigned int size;
	u64 aux_flags;
	union {
		void *addr;
		long unsigned int head;
	};
	int page;
};

struct perf_addr_filter_range {
	long unsigned int start;
	long unsigned int size;
};

struct perf_sample_data {
	u64 addr;
	struct perf_raw_record *raw;
	struct perf_branch_stack *br_stack;
	u64 period;
	union perf_sample_weight weight;
	u64 txn;
	union perf_mem_data_src data_src;
	u64 type;
	u64 ip;
	struct {
		u32 pid;
		u32 tid;
	} tid_entry;
	u64 time;
	u64 id;
	u64 stream_id;
	struct {
		u32 cpu;
		u32 reserved;
	} cpu_entry;
	struct perf_callchain_entry *callchain;
	u64 aux_size;
	struct perf_regs regs_user;
	struct perf_regs regs_intr;
	u64 stack_user_size;
	u64 phys_addr;
	u64 cgroup;
	u64 data_page_size;
	u64 code_page_size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct perf_cgroup_info;

struct perf_cgroup {
	struct cgroup_subsys_state css;
	struct perf_cgroup_info *info;
};

struct perf_cgroup_info {
	u64 time;
	u64 timestamp;
	u64 timeoffset;
	int active;
};

struct trace_entry {
	short unsigned int type;
	unsigned char flags;
	unsigned char preempt_count;
	int pid;
};

struct trace_array;

struct tracer;

struct array_buffer;

struct ring_buffer_iter;

struct trace_iterator {
	struct trace_array *tr;
	struct tracer *trace;
	struct array_buffer *array_buffer;
	void *private;
	int cpu_file;
	struct mutex mutex;
	struct ring_buffer_iter **buffer_iter;
	long unsigned int iter_flags;
	void *temp;
	unsigned int temp_size;
	char *fmt;
	unsigned int fmt_size;
	struct trace_seq tmp_seq;
	cpumask_var_t started;
	bool snapshot;
	struct trace_seq seq;
	struct trace_entry *ent;
	long unsigned int lost_events;
	int leftover;
	int ent_size;
	int cpu;
	u64 ts;
	loff_t pos;
	long int idx;
};

enum print_line_t {
	TRACE_TYPE_PARTIAL_LINE = 0,
	TRACE_TYPE_HANDLED = 1,
	TRACE_TYPE_UNHANDLED = 2,
	TRACE_TYPE_NO_CONSUME = 3,
};

typedef enum print_line_t (*trace_print_func)(struct trace_iterator *, int, struct trace_event *);

struct trace_event_functions {
	trace_print_func trace;
	trace_print_func raw;
	trace_print_func hex;
	trace_print_func binary;
};

enum trace_reg {
	TRACE_REG_REGISTER = 0,
	TRACE_REG_UNREGISTER = 1,
	TRACE_REG_PERF_REGISTER = 2,
	TRACE_REG_PERF_UNREGISTER = 3,
	TRACE_REG_PERF_OPEN = 4,
	TRACE_REG_PERF_CLOSE = 5,
	TRACE_REG_PERF_ADD = 6,
	TRACE_REG_PERF_DEL = 7,
};

struct trace_event_fields {
	const char *type;
	union {
		struct {
			const char *name;
			const int size;
			const int align;
			const int is_signed;
			const int filter_type;
		};
		int (*define_fields)(struct trace_event_call *);
	};
};

struct trace_event_class {
	const char *system;
	void *probe;
	void *perf_probe;
	int (*reg)(struct trace_event_call *, enum trace_reg, void *);
	struct trace_event_fields *fields_array;
	struct list_head * (*get_fields)(struct trace_event_call *);
	struct list_head fields;
	int (*raw_init)(struct trace_event_call *);
};

struct trace_buffer;

struct trace_event_file;

struct trace_event_buffer {
	struct trace_buffer *buffer;
	struct ring_buffer_event *event;
	struct trace_event_file *trace_file;
	void *entry;
	unsigned int trace_ctx;
	struct pt_regs *regs;
};

struct trace_subsystem_dir;

struct trace_event_file {
	struct list_head list;
	struct trace_event_call *event_call;
	struct event_filter *filter;
	struct dentry *dir;
	struct trace_array *tr;
	struct trace_subsystem_dir *system;
	struct list_head triggers;
	long unsigned int flags;
	atomic_t sm_ref;
	atomic_t tm_ref;
};

enum {
	TRACE_EVENT_FL_FILTERED_BIT = 0,
	TRACE_EVENT_FL_CAP_ANY_BIT = 1,
	TRACE_EVENT_FL_NO_SET_FILTER_BIT = 2,
	TRACE_EVENT_FL_IGNORE_ENABLE_BIT = 3,
	TRACE_EVENT_FL_TRACEPOINT_BIT = 4,
	TRACE_EVENT_FL_KPROBE_BIT = 5,
	TRACE_EVENT_FL_UPROBE_BIT = 6,
};

enum {
	TRACE_EVENT_FL_FILTERED = 1,
	TRACE_EVENT_FL_CAP_ANY = 2,
	TRACE_EVENT_FL_NO_SET_FILTER = 4,
	TRACE_EVENT_FL_IGNORE_ENABLE = 8,
	TRACE_EVENT_FL_TRACEPOINT = 16,
	TRACE_EVENT_FL_KPROBE = 32,
	TRACE_EVENT_FL_UPROBE = 64,
};

enum {
	EVENT_FILE_FL_ENABLED_BIT = 0,
	EVENT_FILE_FL_RECORDED_CMD_BIT = 1,
	EVENT_FILE_FL_RECORDED_TGID_BIT = 2,
	EVENT_FILE_FL_FILTERED_BIT = 3,
	EVENT_FILE_FL_NO_SET_FILTER_BIT = 4,
	EVENT_FILE_FL_SOFT_MODE_BIT = 5,
	EVENT_FILE_FL_SOFT_DISABLED_BIT = 6,
	EVENT_FILE_FL_TRIGGER_MODE_BIT = 7,
	EVENT_FILE_FL_TRIGGER_COND_BIT = 8,
	EVENT_FILE_FL_PID_FILTER_BIT = 9,
	EVENT_FILE_FL_WAS_ENABLED_BIT = 10,
};

enum {
	EVENT_FILE_FL_ENABLED = 1,
	EVENT_FILE_FL_RECORDED_CMD = 2,
	EVENT_FILE_FL_RECORDED_TGID = 4,
	EVENT_FILE_FL_FILTERED = 8,
	EVENT_FILE_FL_NO_SET_FILTER = 16,
	EVENT_FILE_FL_SOFT_MODE = 32,
	EVENT_FILE_FL_SOFT_DISABLED = 64,
	EVENT_FILE_FL_TRIGGER_MODE = 128,
	EVENT_FILE_FL_TRIGGER_COND = 256,
	EVENT_FILE_FL_PID_FILTER = 512,
	EVENT_FILE_FL_WAS_ENABLED = 1024,
};

enum {
	FILTER_OTHER = 0,
	FILTER_STATIC_STRING = 1,
	FILTER_DYN_STRING = 2,
	FILTER_PTR_STRING = 3,
	FILTER_TRACE_FN = 4,
	FILTER_COMM = 5,
	FILTER_CPU = 6,
};

enum memblock_flags {
	MEMBLOCK_NONE = 0,
	MEMBLOCK_HOTPLUG = 1,
	MEMBLOCK_MIRROR = 2,
	MEMBLOCK_NOMAP = 4,
};

struct memblock_region {
	phys_addr_t base;
	phys_addr_t size;
	enum memblock_flags flags;
	int nid;
};

struct memblock_type {
	long unsigned int cnt;
	long unsigned int max;
	phys_addr_t total_size;
	struct memblock_region *regions;
	char *name;
};

struct memblock {
	bool bottom_up;
	phys_addr_t current_limit;
	struct memblock_type memory;
	struct memblock_type reserved;
};

struct property {
	char *name;
	int length;
	void *value;
	struct property *next;
	long unsigned int _flags;
	struct bin_attribute attr;
};

struct irq_fwspec {
	struct fwnode_handle *fwnode;
	int param_count;
	u32 param[16];
};

struct irq_domain_ops {
	int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token);
	int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token);
	int (*map)(struct irq_domain *, unsigned int, irq_hw_number_t);
	void (*unmap)(struct irq_domain *, unsigned int);
	int (*xlate)(struct irq_domain *, struct device_node *, const u32 *, unsigned int, long unsigned int *, unsigned int *);
	int (*alloc)(struct irq_domain *, unsigned int, unsigned int, void *);
	void (*free)(struct irq_domain *, unsigned int, unsigned int);
	int (*activate)(struct irq_domain *, struct irq_data *, bool);
	void (*deactivate)(struct irq_domain *, struct irq_data *);
	int (*translate)(struct irq_domain *, struct irq_fwspec *, long unsigned int *, unsigned int *);
};

struct acpi_table_header {
	char signature[4];
	u32 length;
	u8 revision;
	u8 checksum;
	char oem_id[6];
	char oem_table_id[8];
	u32 oem_revision;
	char asl_compiler_id[4];
	u32 asl_compiler_revision;
};

struct acpi_generic_address {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

struct acpi_table_fadt {
	struct acpi_table_header header;
	u32 facs;
	u32 dsdt;
	u8 model;
	u8 preferred_profile;
	u16 sci_interrupt;
	u32 smi_command;
	u8 acpi_enable;
	u8 acpi_disable;
	u8 s4_bios_request;
	u8 pstate_control;
	u32 pm1a_event_block;
	u32 pm1b_event_block;
	u32 pm1a_control_block;
	u32 pm1b_control_block;
	u32 pm2_control_block;
	u32 pm_timer_block;
	u32 gpe0_block;
	u32 gpe1_block;
	u8 pm1_event_length;
	u8 pm1_control_length;
	u8 pm2_control_length;
	u8 pm_timer_length;
	u8 gpe0_block_length;
	u8 gpe1_block_length;
	u8 gpe1_base;
	u8 cst_control;
	u16 c2_latency;
	u16 c3_latency;
	u16 flush_size;
	u16 flush_stride;
	u8 duty_offset;
	u8 duty_width;
	u8 day_alarm;
	u8 month_alarm;
	u8 century;
	u16 boot_flags;
	u8 reserved;
	u32 flags;
	struct acpi_generic_address reset_register;
	u8 reset_value;
	u16 arm_boot_flags;
	u8 minor_revision;
	u64 Xfacs;
	u64 Xdsdt;
	struct acpi_generic_address xpm1a_event_block;
	struct acpi_generic_address xpm1b_event_block;
	struct acpi_generic_address xpm1a_control_block;
	struct acpi_generic_address xpm1b_control_block;
	struct acpi_generic_address xpm2_control_block;
	struct acpi_generic_address xpm_timer_block;
	struct acpi_generic_address xgpe0_block;
	struct acpi_generic_address xgpe1_block;
	struct acpi_generic_address sleep_control;
	struct acpi_generic_address sleep_status;
	u64 hypervisor_id;
} __attribute__((packed));

enum reboot_mode {
	REBOOT_UNDEFINED = 4294967295,
	REBOOT_COLD = 0,
	REBOOT_WARM = 1,
	REBOOT_HARD = 2,
	REBOOT_SOFT = 3,
	REBOOT_GPIO = 4,
};

enum reboot_type {
	BOOT_TRIPLE = 116,
	BOOT_KBD = 107,
	BOOT_BIOS = 98,
	BOOT_ACPI = 97,
	BOOT_EFI = 101,
	BOOT_CF9_FORCE = 112,
	BOOT_CF9_SAFE = 113,
};

struct screen_info {
	__u8 orig_x;
	__u8 orig_y;
	__u16 ext_mem_k;
	__u16 orig_video_page;
	__u8 orig_video_mode;
	__u8 orig_video_cols;
	__u8 flags;
	__u8 unused2;
	__u16 orig_video_ega_bx;
	__u16 unused3;
	__u8 orig_video_lines;
	__u8 orig_video_isVGA;
	__u16 orig_video_points;
	__u16 lfb_width;
	__u16 lfb_height;
	__u16 lfb_depth;
	__u32 lfb_base;
	__u32 lfb_size;
	__u16 cl_magic;
	__u16 cl_offset;
	__u16 lfb_linelength;
	__u8 red_size;
	__u8 red_pos;
	__u8 green_size;
	__u8 green_pos;
	__u8 blue_size;
	__u8 blue_pos;
	__u8 rsvd_size;
	__u8 rsvd_pos;
	__u16 vesapm_seg;
	__u16 vesapm_off;
	__u16 pages;
	__u16 vesa_attributes;
	__u32 capabilities;
	__u32 ext_lfb_base;
	__u8 _reserved[2];
} __attribute__((packed));

typedef long unsigned int efi_status_t;

typedef u8 efi_bool_t;

typedef u16 efi_char16_t;

typedef guid_t efi_guid_t;

typedef struct {
	u64 signature;
	u32 revision;
	u32 headersize;
	u32 crc32;
	u32 reserved;
} efi_table_hdr_t;

typedef struct {
	u32 type;
	u32 pad;
	u64 phys_addr;
	u64 virt_addr;
	u64 num_pages;
	u64 attribute;
} efi_memory_desc_t;

typedef struct {
	efi_guid_t guid;
	u32 headersize;
	u32 flags;
	u32 imagesize;
} efi_capsule_header_t;

typedef struct {
	u16 year;
	u8 month;
	u8 day;
	u8 hour;
	u8 minute;
	u8 second;
	u8 pad1;
	u32 nanosecond;
	s16 timezone;
	u8 daylight;
	u8 pad2;
} efi_time_t;

typedef struct {
	u32 resolution;
	u32 accuracy;
	u8 sets_to_zero;
} efi_time_cap_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 get_time;
	u32 set_time;
	u32 get_wakeup_time;
	u32 set_wakeup_time;
	u32 set_virtual_address_map;
	u32 convert_pointer;
	u32 get_variable;
	u32 get_next_variable;
	u32 set_variable;
	u32 get_next_high_mono_count;
	u32 reset_system;
	u32 update_capsule;
	u32 query_capsule_caps;
	u32 query_variable_info;
} efi_runtime_services_32_t;

typedef efi_status_t efi_get_time_t(efi_time_t *, efi_time_cap_t *);

typedef efi_status_t efi_set_time_t(efi_time_t *);

typedef efi_status_t efi_get_wakeup_time_t(efi_bool_t *, efi_bool_t *, efi_time_t *);

typedef efi_status_t efi_set_wakeup_time_t(efi_bool_t, efi_time_t *);

typedef efi_status_t efi_get_variable_t(efi_char16_t *, efi_guid_t *, u32 *, long unsigned int *, void *);

typedef efi_status_t efi_get_next_variable_t(long unsigned int *, efi_char16_t *, efi_guid_t *);

typedef efi_status_t efi_set_variable_t(efi_char16_t *, efi_guid_t *, u32, long unsigned int, void *);

typedef efi_status_t efi_get_next_high_mono_count_t(u32 *);

typedef void efi_reset_system_t(int, efi_status_t, long unsigned int, efi_char16_t *);

typedef efi_status_t efi_set_virtual_address_map_t(long unsigned int, long unsigned int, u32, efi_memory_desc_t *);

typedef efi_status_t efi_query_variable_info_t(u32, u64 *, u64 *, u64 *);

typedef efi_status_t efi_update_capsule_t(efi_capsule_header_t **, long unsigned int, long unsigned int);

typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **, long unsigned int, u64 *, int *);

typedef union {
	struct {
		efi_table_hdr_t hdr;
		efi_get_time_t *get_time;
		efi_set_time_t *set_time;
		efi_get_wakeup_time_t *get_wakeup_time;
		efi_set_wakeup_time_t *set_wakeup_time;
		efi_set_virtual_address_map_t *set_virtual_address_map;
		void *convert_pointer;
		efi_get_variable_t *get_variable;
		efi_get_next_variable_t *get_next_variable;
		efi_set_variable_t *set_variable;
		efi_get_next_high_mono_count_t *get_next_high_mono_count;
		efi_reset_system_t *reset_system;
		efi_update_capsule_t *update_capsule;
		efi_query_capsule_caps_t *query_capsule_caps;
		efi_query_variable_info_t *query_variable_info;
	};
	efi_runtime_services_32_t mixed_mode;
} efi_runtime_services_t;

struct efi_memory_map {
	phys_addr_t phys_map;
	void *map;
	void *map_end;
	int nr_map;
	long unsigned int desc_version;
	long unsigned int desc_size;
	long unsigned int flags;
};

struct efi {
	const efi_runtime_services_t *runtime;
	unsigned int runtime_version;
	unsigned int runtime_supported_mask;
	long unsigned int acpi;
	long unsigned int acpi20;
	long unsigned int smbios;
	long unsigned int smbios3;
	long unsigned int esrt;
	long unsigned int tpm_log;
	long unsigned int tpm_final_log;
	long unsigned int mokvar_table;
	efi_get_time_t *get_time;
	efi_set_time_t *set_time;
	efi_get_wakeup_time_t *get_wakeup_time;
	efi_set_wakeup_time_t *set_wakeup_time;
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_info_t *query_variable_info;
	efi_query_variable_info_t *query_variable_info_nonblocking;
	efi_update_capsule_t *update_capsule;
	efi_query_capsule_caps_t *query_capsule_caps;
	efi_get_next_high_mono_count_t *get_next_high_mono_count;
	efi_reset_system_t *reset_system;
	struct efi_memory_map memmap;
	long unsigned int flags;
};

enum efi_rts_ids {
	EFI_NONE = 0,
	EFI_GET_TIME = 1,
	EFI_SET_TIME = 2,
	EFI_GET_WAKEUP_TIME = 3,
	EFI_SET_WAKEUP_TIME = 4,
	EFI_GET_VARIABLE = 5,
	EFI_GET_NEXT_VARIABLE = 6,
	EFI_SET_VARIABLE = 7,
	EFI_QUERY_VARIABLE_INFO = 8,
	EFI_GET_NEXT_HIGH_MONO_COUNT = 9,
	EFI_RESET_SYSTEM = 10,
	EFI_UPDATE_CAPSULE = 11,
	EFI_QUERY_CAPSULE_CAPS = 12,
};

struct efi_runtime_work {
	void *arg1;
	void *arg2;
	void *arg3;
	void *arg4;
	void *arg5;
	efi_status_t status;
	struct work_struct work;
	enum efi_rts_ids efi_rts_id;
	struct completion efi_rts_comp;
};

struct psci_operations {
	u32 (*get_version)();
	int (*cpu_suspend)(u32, long unsigned int);
	int (*cpu_off)(u32);
	int (*cpu_on)(long unsigned int, long unsigned int);
	int (*migrate)(long unsigned int);
	int (*affinity_info)(long unsigned int, long unsigned int);
	int (*migrate_info_type)();
};

struct mpidr_hash {
	u64 mask;
	u32 shift_aff[4];
	u32 bits;
};

enum acpi_irq_model_id {
	ACPI_IRQ_MODEL_PIC = 0,
	ACPI_IRQ_MODEL_IOAPIC = 1,
	ACPI_IRQ_MODEL_IOSAPIC = 2,
	ACPI_IRQ_MODEL_PLATFORM = 3,
	ACPI_IRQ_MODEL_GIC = 4,
	ACPI_IRQ_MODEL_COUNT = 5,
};

struct xbc_node {
	u16 next;
	u16 child;
	u16 parent;
	u16 data;
};

enum con_scroll {
	SM_UP = 0,
	SM_DOWN = 1,
};

enum vc_intensity {
	VCI_HALF_BRIGHT = 0,
	VCI_NORMAL = 1,
	VCI_BOLD = 2,
	VCI_MASK = 3,
};

struct vc_data;

struct console_font;

struct consw {
	struct module *owner;
	const char * (*con_startup)();
	void (*con_init)(struct vc_data *, int);
	void (*con_deinit)(struct vc_data *);
	void (*con_clear)(struct vc_data *, int, int, int, int);
	void (*con_putc)(struct vc_data *, int, int, int);
	void (*con_putcs)(struct vc_data *, const short unsigned int *, int, int, int);
	void (*con_cursor)(struct vc_data *, int);
	bool (*con_scroll)(struct vc_data *, unsigned int, unsigned int, enum con_scroll, unsigned int);
	int (*con_switch)(struct vc_data *);
	int (*con_blank)(struct vc_data *, int, int);
	int (*con_font_set)(struct vc_data *, struct console_font *, unsigned int);
	int (*con_font_get)(struct vc_data *, struct console_font *);
	int (*con_font_default)(struct vc_data *, struct console_font *, char *);
	int (*con_resize)(struct vc_data *, unsigned int, unsigned int, unsigned int);
	void (*con_set_palette)(struct vc_data *, const unsigned char *);
	void (*con_scrolldelta)(struct vc_data *, int);
	int (*con_set_origin)(struct vc_data *);
	void (*con_save_screen)(struct vc_data *);
	u8 (*con_build_attr)(struct vc_data *, u8, enum vc_intensity, bool, bool, bool, bool);
	void (*con_invert_region)(struct vc_data *, u16 *, int);
	u16 * (*con_screen_pos)(const struct vc_data *, int);
	long unsigned int (*con_getxy)(struct vc_data *, long unsigned int, int *, int *);
	void (*con_flush_scrollback)(struct vc_data *);
	int (*con_debug_enter)(struct vc_data *);
	int (*con_debug_leave)(struct vc_data *);
};

struct tty_buffer {
	union {
		struct tty_buffer *next;
		struct llist_node free;
	};
	int used;
	int size;
	int commit;
	int read;
	int flags;
	long unsigned int data[0];
};

struct tty_bufhead {
	struct tty_buffer *head;
	struct work_struct work;
	struct mutex lock;
	atomic_t priority;
	struct tty_buffer sentinel;
	struct llist_head free;
	atomic_t mem_used;
	int mem_limit;
	struct tty_buffer *tail;
};

struct tty_port_operations;

struct tty_port_client_operations;

struct tty_port {
	struct tty_bufhead buf;
	struct tty_struct *tty;
	struct tty_struct *itty;
	const struct tty_port_operations *ops;
	const struct tty_port_client_operations *client_ops;
	spinlock_t lock;
	int blocked_open;
	int count;
	wait_queue_head_t open_wait;
	wait_queue_head_t delta_msr_wait;
	long unsigned int flags;
	long unsigned int iflags;
	unsigned char console: 1;
	struct mutex mutex;
	struct mutex buf_mutex;
	unsigned char *xmit_buf;
	unsigned int close_delay;
	unsigned int closing_wait;
	int drain_delay;
	struct kref kref;
	void *client_data;
};

struct vc_state {
	unsigned int x;
	unsigned int y;
	unsigned char color;
	unsigned char Gx_charset[2];
	unsigned int charset: 1;
	enum vc_intensity intensity;
	bool italic;
	bool underline;
	bool blink;
	bool reverse;
};

struct console_font {
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_mode {
	char mode;
	char waitv;
	short int relsig;
	short int acqsig;
	short int frsig;
};

struct uni_pagedir;

struct uni_screen;

struct vc_data {
	struct tty_port port;
	struct vc_state state;
	struct vc_state saved_state;
	short unsigned int vc_num;
	unsigned int vc_cols;
	unsigned int vc_rows;
	unsigned int vc_size_row;
	unsigned int vc_scan_lines;
	unsigned int vc_cell_height;
	long unsigned int vc_origin;
	long unsigned int vc_scr_end;
	long unsigned int vc_visible_origin;
	unsigned int vc_top;
	unsigned int vc_bottom;
	const struct consw *vc_sw;
	short unsigned int *vc_screenbuf;
	unsigned int vc_screenbuf_size;
	unsigned char vc_mode;
	unsigned char vc_attr;
	unsigned char vc_def_color;
	unsigned char vc_ulcolor;
	unsigned char vc_itcolor;
	unsigned char vc_halfcolor;
	unsigned int vc_cursor_type;
	short unsigned int vc_complement_mask;
	short unsigned int vc_s_complement_mask;
	long unsigned int vc_pos;
	short unsigned int vc_hi_font_mask;
	struct console_font vc_font;
	short unsigned int vc_video_erase_char;
	unsigned int vc_state;
	unsigned int vc_npar;
	unsigned int vc_par[16];
	struct vt_mode vt_mode;
	struct pid *vt_pid;
	int vt_newvt;
	wait_queue_head_t paste_wait;
	unsigned int vc_disp_ctrl: 1;
	unsigned int vc_toggle_meta: 1;
	unsigned int vc_decscnm: 1;
	unsigned int vc_decom: 1;
	unsigned int vc_decawm: 1;
	unsigned int vc_deccm: 1;
	unsigned int vc_decim: 1;
	unsigned int vc_priv: 3;
	unsigned int vc_need_wrap: 1;
	unsigned int vc_can_do_color: 1;
	unsigned int vc_report_mouse: 2;
	unsigned char vc_utf: 1;
	unsigned char vc_utf_count;
	int vc_utf_char;
	long unsigned int vc_tab_stop[4];
	unsigned char vc_palette[48];
	short unsigned int *vc_translate;
	unsigned int vc_resize_user;
	unsigned int vc_bell_pitch;
	unsigned int vc_bell_duration;
	short unsigned int vc_cur_blink_ms;
	struct vc_data **vc_display_fg;
	struct uni_pagedir *vc_uni_pagedir;
	struct uni_pagedir **vc_uni_pagedir_loc;
	struct uni_screen *vc_uni_screen;
};

struct tty_driver;

struct console {
	char name[16];
	void (*write)(struct console *, const char *, unsigned int);
	int (*read)(struct console *, char *, unsigned int);
	struct tty_driver * (*device)(struct console *, int *);
	void (*unblank)();
	int (*setup)(struct console *, char *);
	int (*exit)(struct console *);
	int (*match)(struct console *, char *, int, char *);
	short int flags;
	short int index;
	int cflag;
	uint ispeed;
	uint ospeed;
	void *data;
	struct console *next;
};

struct kprobe;

struct prev_kprobe {
	struct kprobe *kp;
	unsigned int status;
};

typedef int (*kprobe_pre_handler_t)(struct kprobe *, struct pt_regs *);

typedef void (*kprobe_post_handler_t)(struct kprobe *, struct pt_regs *, long unsigned int);

typedef int (*kprobe_fault_handler_t)(struct kprobe *, struct pt_regs *, int);

struct kprobe {
	struct hlist_node hlist;
	struct list_head list;
	long unsigned int nmissed;
	kprobe_opcode_t *addr;
	const char *symbol_name;
	unsigned int offset;
	kprobe_pre_handler_t pre_handler;
	kprobe_post_handler_t post_handler;
	kprobe_fault_handler_t fault_handler;
	kprobe_opcode_t opcode;
	struct arch_specific_insn ainsn;
	u32 flags;
};

struct kprobe_ctlblk {
	unsigned int kprobe_status;
	long unsigned int saved_irqflag;
	struct prev_kprobe prev_kprobe;
};

struct kretprobe_blackpoint {
	const char *name;
	void *addr;
};

struct kprobe_insn_cache {
	struct mutex mutex;
	void * (*alloc)();
	void (*free)(void *);
	const char *sym;
	struct list_head pages;
	size_t insn_size;
	int nr_garbage;
};

enum wb_stat_item {
	WB_RECLAIMABLE = 0,
	WB_WRITEBACK = 1,
	WB_DIRTIED = 2,
	WB_WRITTEN = 3,
	NR_WB_STAT_ITEMS = 4,
};

struct block_device_operations;

struct timer_rand_state;

struct disk_events;

struct cdrom_device_info;

struct badblocks;

struct gendisk {
	int major;
	int first_minor;
	int minors;
	char disk_name[32];
	short unsigned int events;
	short unsigned int event_flags;
	struct xarray part_tbl;
	struct block_device *part0;
	const struct block_device_operations *fops;
	struct request_queue *queue;
	void *private_data;
	int flags;
	long unsigned int state;
	struct kobject *slave_dir;
	struct timer_rand_state *random;
	atomic_t sync_io;
	struct disk_events *ev;
	struct kobject integrity_kobj;
	struct cdrom_device_info *cdi;
	int node_id;
	struct badblocks *bb;
	struct lockdep_map lockdep_map;
};

struct partition_meta_info {
	char uuid[37];
	u8 volname[64];
};

struct bio_integrity_payload {
	struct bio *bip_bio;
	struct bvec_iter bip_iter;
	short unsigned int bip_vcnt;
	short unsigned int bip_max_vcnt;
	short unsigned int bip_flags;
	struct bvec_iter bio_iter;
	struct work_struct bip_work;
	struct bio_vec *bip_vec;
	struct bio_vec bip_inline_vecs[0];
};

struct blkg_iostat {
	u64 bytes[3];
	u64 ios[3];
};

struct blkg_iostat_set {
	struct u64_stats_sync sync;
	struct blkg_iostat cur;
	struct blkg_iostat last;
};

struct blkcg;

struct blkg_policy_data;

struct blkcg_gq {
	struct request_queue *q;
	struct list_head q_node;
	struct hlist_node blkcg_node;
	struct blkcg *blkcg;
	struct blkcg_gq *parent;
	struct percpu_ref refcnt;
	bool online;
	struct blkg_iostat_set *iostat_cpu;
	struct blkg_iostat_set iostat;
	struct blkg_policy_data *pd[5];
	spinlock_t async_bio_lock;
	struct bio_list async_bios;
	struct work_struct async_bio_work;
	atomic_t use_delay;
	atomic64_t delay_nsec;
	atomic64_t delay_start;
	u64 last_delay;
	int last_use;
	struct callback_head callback_head;
};

typedef unsigned int blk_qc_t;

struct blk_integrity_iter;

typedef blk_status_t integrity_processing_fn(struct blk_integrity_iter *);

typedef void integrity_prepare_fn(struct request *);

typedef void integrity_complete_fn(struct request *, unsigned int);

struct blk_integrity_profile {
	integrity_processing_fn *generate_fn;
	integrity_processing_fn *verify_fn;
	integrity_prepare_fn *prepare_fn;
	integrity_complete_fn *complete_fn;
	const char *name;
};

struct blk_zone;

typedef int (*report_zones_cb)(struct blk_zone *, unsigned int, void *);

struct hd_geometry;

struct pr_ops;

struct block_device_operations {
	blk_qc_t (*submit_bio)(struct bio *);
	int (*open)(struct block_device *, fmode_t);
	void (*release)(struct gendisk *, fmode_t);
	int (*rw_page)(struct block_device *, sector_t, struct page *, unsigned int);
	int (*ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	unsigned int (*check_events)(struct gendisk *, unsigned int);
	void (*unlock_native_capacity)(struct gendisk *);
	int (*getgeo)(struct block_device *, struct hd_geometry *);
	int (*set_read_only)(struct block_device *, bool);
	void (*swap_slot_free_notify)(struct block_device *, long unsigned int);
	int (*report_zones)(struct gendisk *, sector_t, unsigned int, report_zones_cb, void *);
	char * (*devnode)(struct gendisk *, umode_t *);
	struct module *owner;
	const struct pr_ops *pr_ops;
};

enum kgdb_bptype {
	BP_BREAKPOINT = 0,
	BP_HARDWARE_BREAKPOINT = 1,
	BP_WRITE_WATCHPOINT = 2,
	BP_READ_WATCHPOINT = 3,
	BP_ACCESS_WATCHPOINT = 4,
	BP_POKE_BREAKPOINT = 5,
};

struct dbg_reg_def_t {
	char *name;
	int size;
	int offset;
};

struct kgdb_arch {
	unsigned char gdb_bpt_instr[4];
	long unsigned int flags;
	int (*set_breakpoint)(long unsigned int, char *);
	int (*remove_breakpoint)(long unsigned int, char *);
	int (*set_hw_breakpoint)(long unsigned int, int, enum kgdb_bptype);
	int (*remove_hw_breakpoint)(long unsigned int, int, enum kgdb_bptype);
	void (*disable_hw_break)(struct pt_regs *);
	void (*remove_all_hw_break)();
	void (*correct_hw_break)();
	void (*enable_nmi)(bool);
};

struct kgdb_io {
	const char *name;
	int (*read_char)();
	void (*write_char)(u8);
	void (*flush)();
	int (*init)();
	void (*deinit)();
	void (*pre_exception)();
	void (*post_exception)();
	struct console *cons;
};

struct sg_io_v4 {
	__s32 guard;
	__u32 protocol;
	__u32 subprotocol;
	__u32 request_len;
	__u64 request;
	__u64 request_tag;
	__u32 request_attr;
	__u32 request_priority;
	__u32 request_extra;
	__u32 max_response_len;
	__u64 response;
	__u32 dout_iovec_count;
	__u32 dout_xfer_len;
	__u32 din_iovec_count;
	__u32 din_xfer_len;
	__u64 dout_xferp;
	__u64 din_xferp;
	__u32 timeout;
	__u32 flags;
	__u64 usr_ptr;
	__u32 spare_in;
	__u32 driver_status;
	__u32 transport_status;
	__u32 device_status;
	__u32 retry_delay;
	__u32 info;
	__u32 duration;
	__u32 response_len;
	__s32 din_resid;
	__s32 dout_resid;
	__u64 generated_tag;
	__u32 spare_out;
	__u32 padding;
};

struct bsg_ops {
	int (*check_proto)(struct sg_io_v4 *);
	int (*fill_hdr)(struct request *, struct sg_io_v4 *, fmode_t);
	int (*complete_rq)(struct request *, struct sg_io_v4 *);
	void (*free_rq)(struct request *);
};

typedef __u32 req_flags_t;

typedef void rq_end_io_fn(struct request *, blk_status_t);

enum mq_rq_state {
	MQ_RQ_IDLE = 0,
	MQ_RQ_IN_FLIGHT = 1,
	MQ_RQ_COMPLETE = 2,
};

struct blk_ksm_keyslot;

struct request {
	struct request_queue *q;
	struct blk_mq_ctx *mq_ctx;
	struct blk_mq_hw_ctx *mq_hctx;
	unsigned int cmd_flags;
	req_flags_t rq_flags;
	int tag;
	int internal_tag;
	unsigned int __data_len;
	sector_t __sector;
	struct bio *bio;
	struct bio *biotail;
	struct list_head queuelist;
	union {
		struct hlist_node hash;
		struct llist_node ipi_list;
	};
	union {
		struct rb_node rb_node;
		struct bio_vec special_vec;
		void *completion_data;
		int error_count;
	};
	union {
		struct {
			struct io_cq *icq;
			void *priv[2];
		} elv;
		struct {
			unsigned int seq;
			struct list_head list;
			rq_end_io_fn *saved_end_io;
		} flush;
	};
	struct gendisk *rq_disk;
	struct block_device *part;
	u64 alloc_time_ns;
	u64 start_time_ns;
	u64 io_start_time_ns;
	short unsigned int wbt_flags;
	short unsigned int stats_sectors;
	short unsigned int nr_phys_segments;
	short unsigned int nr_integrity_segments;
	struct bio_crypt_ctx *crypt_ctx;
	struct blk_ksm_keyslot *crypt_keyslot;
	short unsigned int write_hint;
	short unsigned int ioprio;
	enum mq_rq_state state;
	refcount_t ref;
	unsigned int timeout;
	long unsigned int deadline;
	union {
		struct __call_single_data csd;
		u64 fifo_time;
	};
	rq_end_io_fn *end_io;
	void *end_io_data;
};

struct blk_zone {
	__u64 start;
	__u64 len;
	__u64 wp;
	__u8 type;
	__u8 cond;
	__u8 non_seq;
	__u8 reset;
	__u8 resv[4];
	__u64 capacity;
	__u8 reserved[24];
};

enum elv_merge {
	ELEVATOR_NO_MERGE = 0,
	ELEVATOR_FRONT_MERGE = 1,
	ELEVATOR_BACK_MERGE = 2,
	ELEVATOR_DISCARD_MERGE = 3,
};

struct elevator_type;

struct blk_mq_alloc_data;

struct elevator_mq_ops {
	int (*init_sched)(struct request_queue *, struct elevator_type *);
	void (*exit_sched)(struct elevator_queue *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*depth_updated)(struct blk_mq_hw_ctx *);
	bool (*allow_merge)(struct request_queue *, struct request *, struct bio *);
	bool (*bio_merge)(struct request_queue *, struct bio *, unsigned int);
	int (*request_merge)(struct request_queue *, struct request **, struct bio *);
	void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);
	void (*requests_merged)(struct request_queue *, struct request *, struct request *);
	void (*limit_depth)(unsigned int, struct blk_mq_alloc_data *);
	void (*prepare_request)(struct request *);
	void (*finish_request)(struct request *);
	void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, bool);
	struct request * (*dispatch_request)(struct blk_mq_hw_ctx *);
	bool (*has_work)(struct blk_mq_hw_ctx *);
	void (*completed_request)(struct request *, u64);
	void (*requeue_request)(struct request *);
	struct request * (*former_request)(struct request_queue *, struct request *);
	struct request * (*next_request)(struct request_queue *, struct request *);
	void (*init_icq)(struct io_cq *);
	void (*exit_icq)(struct io_cq *);
};

struct elv_fs_entry;

struct blk_mq_debugfs_attr;

struct elevator_type {
	struct kmem_cache *icq_cache;
	struct elevator_mq_ops ops;
	size_t icq_size;
	size_t icq_align;
	struct elv_fs_entry *elevator_attrs;
	const char *elevator_name;
	const char *elevator_alias;
	const unsigned int elevator_features;
	struct module *elevator_owner;
	const struct blk_mq_debugfs_attr *queue_debugfs_attrs;
	const struct blk_mq_debugfs_attr *hctx_debugfs_attrs;
	char icq_cache_name[22];
	struct list_head list;
};

struct elevator_queue {
	struct elevator_type *type;
	void *elevator_data;
	struct kobject kobj;
	struct mutex sysfs_lock;
	unsigned int registered: 1;
	struct hlist_head hash[64];
};

struct elv_fs_entry {
	struct attribute attr;
	ssize_t (*show)(struct elevator_queue *, char *);
	ssize_t (*store)(struct elevator_queue *, const char *, size_t);
};

struct blk_mq_debugfs_attr {
	const char *name;
	umode_t mode;
	int (*show)(void *, struct seq_file *);
	ssize_t (*write)(void *, const char *, size_t, loff_t *);
	const struct seq_operations *seq_ops;
};

enum blk_eh_timer_return {
	BLK_EH_DONE = 0,
	BLK_EH_RESET_TIMER = 1,
};

struct blk_mq_queue_data;

struct blk_mq_ops {
	blk_status_t (*queue_rq)(struct blk_mq_hw_ctx *, const struct blk_mq_queue_data *);
	void (*commit_rqs)(struct blk_mq_hw_ctx *);
	int (*get_budget)(struct request_queue *);
	void (*put_budget)(struct request_queue *, int);
	void (*set_rq_budget_token)(struct request *, int);
	int (*get_rq_budget_token)(struct request *);
	enum blk_eh_timer_return (*timeout)(struct request *, bool);
	int (*poll)(struct blk_mq_hw_ctx *);
	void (*complete)(struct request *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, void *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	int (*init_request)(struct blk_mq_tag_set *, struct request *, unsigned int, unsigned int);
	void (*exit_request)(struct blk_mq_tag_set *, struct request *, unsigned int);
	void (*initialize_rq_fn)(struct request *);
	void (*cleanup_rq)(struct request *);
	bool (*busy)(struct request_queue *);
	int (*map_queues)(struct blk_mq_tag_set *);
	void (*show_rq)(struct seq_file *, struct request *);
};

struct blk_integrity_iter {
	void *prot_buf;
	void *data_buf;
	sector_t seed;
	unsigned int data_size;
	short unsigned int interval;
	const char *disk_name;
};

enum pr_type {
	PR_WRITE_EXCLUSIVE = 1,
	PR_EXCLUSIVE_ACCESS = 2,
	PR_WRITE_EXCLUSIVE_REG_ONLY = 3,
	PR_EXCLUSIVE_ACCESS_REG_ONLY = 4,
	PR_WRITE_EXCLUSIVE_ALL_REGS = 5,
	PR_EXCLUSIVE_ACCESS_ALL_REGS = 6,
};

struct pr_ops {
	int (*pr_register)(struct block_device *, u64, u64, u32);
	int (*pr_reserve)(struct block_device *, u64, enum pr_type, u32);
	int (*pr_release)(struct block_device *, u64, enum pr_type);
	int (*pr_preempt)(struct block_device *, u64, u64, enum pr_type, bool);
	int (*pr_clear)(struct block_device *, u64);
};

enum blkg_iostat_type {
	BLKG_IOSTAT_READ = 0,
	BLKG_IOSTAT_WRITE = 1,
	BLKG_IOSTAT_DISCARD = 2,
	BLKG_IOSTAT_NR = 3,
};

struct blkcg_policy_data;

struct blkcg {
	struct cgroup_subsys_state css;
	spinlock_t lock;
	refcount_t online_pin;
	struct xarray blkg_tree;
	struct blkcg_gq *blkg_hint;
	struct hlist_head blkg_list;
	struct blkcg_policy_data *cpd[5];
	struct list_head all_blkcgs_node;
	struct list_head cgwb_list;
};

struct blkcg_policy_data {
	struct blkcg *blkcg;
	int plid;
};

struct blkg_policy_data {
	struct blkcg_gq *blkg;
	int plid;
};

enum memcg_stat_item {
	MEMCG_SWAP = 39,
	MEMCG_SOCK = 40,
	MEMCG_PERCPU_B = 41,
	MEMCG_NR_STAT = 42,
};

enum memcg_memory_event {
	MEMCG_LOW = 0,
	MEMCG_HIGH = 1,
	MEMCG_MAX = 2,
	MEMCG_OOM = 3,
	MEMCG_OOM_KILL = 4,
	MEMCG_SWAP_HIGH = 5,
	MEMCG_SWAP_MAX = 6,
	MEMCG_SWAP_FAIL = 7,
	MEMCG_NR_MEMORY_EVENTS = 8,
};

enum mem_cgroup_events_target {
	MEM_CGROUP_TARGET_THRESH = 0,
	MEM_CGROUP_TARGET_SOFTLIMIT = 1,
	MEM_CGROUP_NTARGETS = 2,
};

struct memcg_vmstats_percpu {
	long int state[42];
	long unsigned int events[97];
	long int state_prev[42];
	long unsigned int events_prev[97];
	long unsigned int nr_page_events;
	long unsigned int targets[2];
};

struct mem_cgroup_reclaim_iter {
	struct mem_cgroup *position;
	unsigned int generation;
};

struct lruvec_stat {
	long int count[39];
};

struct batched_lruvec_stat {
	s32 count[39];
};

struct shrinker_info {
	struct callback_head rcu;
	atomic_long_t *nr_deferred;
	long unsigned int *map;
};

struct mem_cgroup_per_node {
	struct lruvec lruvec;
	struct lruvec_stat *lruvec_stat_local;
	struct batched_lruvec_stat *lruvec_stat_cpu;
	atomic_long_t lruvec_stat[39];
	long unsigned int lru_zone_size[25];
	struct mem_cgroup_reclaim_iter iter;
	struct shrinker_info *shrinker_info;
	struct rb_node tree_node;
	long unsigned int usage_in_excess;
	bool on_tree;
	struct mem_cgroup *memcg;
};

struct eventfd_ctx;

struct mem_cgroup_threshold {
	struct eventfd_ctx *eventfd;
	long unsigned int threshold;
};

struct mem_cgroup_threshold_ary {
	int current_threshold;
	unsigned int size;
	struct mem_cgroup_threshold entries[0];
};

struct obj_cgroup {
	struct percpu_ref refcnt;
	struct mem_cgroup *memcg;
	atomic_t nr_charged_bytes;
	union {
		struct list_head list;
		struct callback_head rcu;
	};
};

struct percpu_cluster {
	struct swap_cluster_info index;
	unsigned int next;
};

enum fs_value_type {
	fs_value_is_undefined = 0,
	fs_value_is_flag = 1,
	fs_value_is_string = 2,
	fs_value_is_blob = 3,
	fs_value_is_filename = 4,
	fs_value_is_file = 5,
};

struct fs_parameter {
	const char *key;
	enum fs_value_type type: 8;
	union {
		char *string;
		void *blob;
		struct filename *name;
		struct file *file;
	};
	size_t size;
	int dirfd;
};

struct fc_log {
	refcount_t usage;
	u8 head;
	u8 tail;
	u8 need_free;
	struct module *owner;
	char *buffer[8];
};

struct fs_context_operations {
	void (*free)(struct fs_context *);
	int (*dup)(struct fs_context *, struct fs_context *);
	int (*parse_param)(struct fs_context *, struct fs_parameter *);
	int (*parse_monolithic)(struct fs_context *, void *);
	int (*get_tree)(struct fs_context *);
	int (*reconfigure)(struct fs_context *);
};

struct fs_parse_result {
	bool negated;
	union {
		bool boolean;
		int int_32;
		unsigned int uint_32;
		u64 uint_64;
	};
};

struct trace_event_raw_initcall_level {
	struct trace_entry ent;
	u32 __data_loc_level;
	char __data[0];
};

struct trace_event_raw_initcall_start {
	struct trace_entry ent;
	initcall_t func;
	char __data[0];
};

struct trace_event_raw_initcall_finish {
	struct trace_entry ent;
	initcall_t func;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_initcall_level {
	u32 level;
};

struct trace_event_data_offsets_initcall_start {};

struct trace_event_data_offsets_initcall_finish {};

typedef void (*btf_trace_initcall_level)(void *, const char *);

typedef void (*btf_trace_initcall_start)(void *, initcall_t);

typedef void (*btf_trace_initcall_finish)(void *, initcall_t, int);

struct blacklist_entry {
	struct list_head next;
	char *buf;
};

typedef __u32 Elf32_Word;

struct elf32_note {
	Elf32_Word n_namesz;
	Elf32_Word n_descsz;
	Elf32_Word n_type;
};

struct file_system_type___2;

struct atomic_notifier_head___2;

enum {
	UNAME26 = 131072,
	ADDR_NO_RANDOMIZE = 262144,
	FDPIC_FUNCPTRS = 524288,
	MMAP_PAGE_ZERO = 1048576,
	ADDR_COMPAT_LAYOUT = 2097152,
	READ_IMPLIES_EXEC = 4194304,
	ADDR_LIMIT_32BIT = 8388608,
	SHORT_INODE = 16777216,
	WHOLE_SECONDS = 33554432,
	STICKY_TIMEOUTS = 67108864,
	ADDR_LIMIT_3GB = 134217728,
};

enum hrtimer_base_type {
	HRTIMER_BASE_MONOTONIC = 0,
	HRTIMER_BASE_REALTIME = 1,
	HRTIMER_BASE_BOOTTIME = 2,
	HRTIMER_BASE_TAI = 3,
	HRTIMER_BASE_MONOTONIC_SOFT = 4,
	HRTIMER_BASE_REALTIME_SOFT = 5,
	HRTIMER_BASE_BOOTTIME_SOFT = 6,
	HRTIMER_BASE_TAI_SOFT = 7,
	HRTIMER_MAX_CLOCK_BASES = 8,
};

enum {
	MM_FILEPAGES = 0,
	MM_ANONPAGES = 1,
	MM_SWAPENTS = 2,
	MM_SHMEMPAGES = 3,
	NR_MM_COUNTERS = 4,
};

enum rseq_cs_flags_bit {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,
};

enum uclamp_id {
	UCLAMP_MIN = 0,
	UCLAMP_MAX = 1,
	UCLAMP_CNT = 2,
};

enum perf_event_task_context {
	perf_invalid_context = 4294967295,
	perf_hw_context = 0,
	perf_sw_context = 1,
	perf_nr_task_contexts = 2,
};

enum rseq_event_mask_bits {
	RSEQ_EVENT_PREEMPT_BIT = 0,
	RSEQ_EVENT_SIGNAL_BIT = 1,
	RSEQ_EVENT_MIGRATE_BIT = 2,
};

struct rw_semaphore___2;

enum {
	PROC_ROOT_INO = 1,
	PROC_IPC_INIT_INO = 4026531839,
	PROC_UTS_INIT_INO = 4026531838,
	PROC_USER_INIT_INO = 4026531837,
	PROC_PID_INIT_INO = 4026531836,
	PROC_CGROUP_INIT_INO = 4026531835,
	PROC_TIME_INIT_INO = 4026531834,
};

typedef __u16 __le16;

typedef __u16 __be16;

typedef __u32 __be32;

typedef __u64 __be64;

typedef __u32 __wsum;

typedef u64 uint64_t;

typedef unsigned int slab_flags_t;

typedef struct __call_single_data call_single_data_t;

struct rhash_head {
	struct rhash_head *next;
};

struct rhashtable;

struct rhashtable_compare_arg {
	struct rhashtable *ht;
	const void *key;
};

typedef u32 (*rht_hashfn_t)(const void *, u32, u32);

typedef u32 (*rht_obj_hashfn_t)(const void *, u32, u32);

typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *, const void *);

struct rhashtable_params {
	u16 nelem_hint;
	u16 key_len;
	u16 key_offset;
	u16 head_offset;
	unsigned int max_size;
	u16 min_size;
	bool automatic_shrinking;
	rht_hashfn_t hashfn;
	rht_obj_hashfn_t obj_hashfn;
	rht_obj_cmpfn_t obj_cmpfn;
};

struct bucket_table;

struct rhashtable {
	struct bucket_table *tbl;
	unsigned int key_len;
	unsigned int max_elems;
	struct rhashtable_params p;
	bool rhlist;
	struct work_struct run_work;
	struct mutex mutex;
	spinlock_t lock;
	atomic_t nelems;
};

struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_spinlock_t seq;
	int umask;
	int in_exec;
	struct path root;
	struct path pwd;
};

struct pipe_buffer;

struct watch_queue;

struct pipe_inode_info {
	struct mutex mutex;
	wait_queue_head_t rd_wait;
	wait_queue_head_t wr_wait;
	unsigned int head;
	unsigned int tail;
	unsigned int max_usage;
	unsigned int ring_size;
	bool note_loss;
	unsigned int nr_accounted;
	unsigned int readers;
	unsigned int writers;
	unsigned int files;
	unsigned int r_counter;
	unsigned int w_counter;
	unsigned int poll_usage;
	struct page *tmp_page;
	struct fasync_struct *fasync_readers;
	struct fasync_struct *fasync_writers;
	struct pipe_buffer *bufs;
	struct user_struct *user;
	struct watch_queue *watch_queue;
};

struct raw_notifier_head {
	struct notifier_block *head;
};

struct ld_semaphore {
	atomic_long_t count;
	raw_spinlock_t wait_lock;
	unsigned int wait_readers;
	struct list_head read_wait;
	struct list_head write_wait;
};

typedef unsigned int tcflag_t;

typedef unsigned char cc_t;

typedef unsigned int speed_t;

struct ktermios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct winsize {
	short unsigned int ws_row;
	short unsigned int ws_col;
	short unsigned int ws_xpixel;
	short unsigned int ws_ypixel;
};

struct tty_operations;

struct tty_ldisc;

struct tty_struct {
	int magic;
	struct kref kref;
	struct device *dev;
	struct tty_driver *driver;
	const struct tty_operations *ops;
	int index;
	struct ld_semaphore ldisc_sem;
	struct tty_ldisc *ldisc;
	struct mutex atomic_write_lock;
	struct mutex legacy_mutex;
	struct mutex throttle_mutex;
	struct rw_semaphore termios_rwsem;
	struct mutex winsize_mutex;
	spinlock_t ctrl_lock;
	spinlock_t flow_lock;
	struct ktermios termios;
	struct ktermios termios_locked;
	char name[64];
	struct pid *pgrp;
	struct pid *session;
	long unsigned int flags;
	int count;
	struct winsize winsize;
	long unsigned int stopped: 1;
	long unsigned int flow_stopped: 1;
	int: 30;
	long unsigned int unused: 62;
	int hw_stopped;
	long unsigned int ctrl_status: 8;
	long unsigned int packet: 1;
	int: 23;
	long unsigned int unused_ctrl: 55;
	unsigned int receive_room;
	int flow_change;
	struct tty_struct *link;
	struct fasync_struct *fasync;
	wait_queue_head_t write_wait;
	wait_queue_head_t read_wait;
	struct work_struct hangup_work;
	void *disc_data;
	void *driver_data;
	spinlock_t files_lock;
	struct list_head tty_files;
	int closing;
	unsigned char *write_buf;
	int write_cnt;
	struct work_struct SAK_work;
	struct tty_port *port;
};

typedef struct {
	size_t written;
	size_t count;
	union {
		char *buf;
		void *data;
	} arg;
	int error;
} read_descriptor_t;

struct posix_acl_entry {
	short int e_tag;
	short unsigned int e_perm;
	union {
		kuid_t e_uid;
		kgid_t e_gid;
	};
};

struct posix_acl {
	refcount_t a_refcount;
	struct callback_head a_rcu;
	unsigned int a_count;
	struct posix_acl_entry a_entries[0];
};

struct ida {
	struct xarray xa;
};

typedef __u64 __addrpair;

typedef __u32 __portpair;

typedef struct {
	struct net *net;
} possible_net_t;

struct in6_addr {
	union {
		__u8 u6_addr8[16];
		__be16 u6_addr16[8];
		__be32 u6_addr32[4];
	} in6_u;
};

struct hlist_nulls_node {
	struct hlist_nulls_node *next;
	struct hlist_nulls_node **pprev;
};

struct proto;

struct inet_timewait_death_row;

struct sock_common {
	union {
		__addrpair skc_addrpair;
		struct {
			__be32 skc_daddr;
			__be32 skc_rcv_saddr;
		};
	};
	union {
		unsigned int skc_hash;
		__u16 skc_u16hashes[2];
	};
	union {
		__portpair skc_portpair;
		struct {
			__be16 skc_dport;
			__u16 skc_num;
		};
	};
	short unsigned int skc_family;
	volatile unsigned char skc_state;
	unsigned char skc_reuse: 4;
	unsigned char skc_reuseport: 1;
	unsigned char skc_ipv6only: 1;
	unsigned char skc_net_refcnt: 1;
	int skc_bound_dev_if;
	union {
		struct hlist_node skc_bind_node;
		struct hlist_node skc_portaddr_node;
	};
	struct proto *skc_prot;
	possible_net_t skc_net;
	struct in6_addr skc_v6_daddr;
	struct in6_addr skc_v6_rcv_saddr;
	atomic64_t skc_cookie;
	union {
		long unsigned int skc_flags;
		struct sock *skc_listener;
		struct inet_timewait_death_row *skc_tw_dr;
	};
	int skc_dontcopy_begin[0];
	union {
		struct hlist_node skc_node;
		struct hlist_nulls_node skc_nulls_node;
	};
	short unsigned int skc_tx_queue_mapping;
	short unsigned int skc_rx_queue_mapping;
	union {
		int skc_incoming_cpu;
		u32 skc_rcv_wnd;
		u32 skc_tw_rcv_nxt;
	};
	refcount_t skc_refcnt;
	int skc_dontcopy_end[0];
	union {
		u32 skc_rxhash;
		u32 skc_window_clamp;
		u32 skc_tw_snd_nxt;
	};
};

typedef struct {
	spinlock_t slock;
	int owned;
	wait_queue_head_t wq;
} socket_lock_t;

struct sk_buff;

struct sk_buff_head {
	struct sk_buff *next;
	struct sk_buff *prev;
	__u32 qlen;
	spinlock_t lock;
};

typedef u64 netdev_features_t;

struct sock_cgroup_data {
	union {
		struct {
			u8 is_data: 1;
			u8 no_refcnt: 1;
			u8 unused: 6;
			u8 padding;
			u16 prioidx;
			u32 classid;
		};
		u64 val;
	};
};

struct sk_filter;

struct socket_wq;

struct xfrm_policy;

struct dst_entry;

struct socket;

struct sock_reuseport;

struct sock {
	struct sock_common __sk_common;
	socket_lock_t sk_lock;
	atomic_t sk_drops;
	int sk_rcvlowat;
	struct sk_buff_head sk_error_queue;
	struct sk_buff *sk_rx_skb_cache;
	struct sk_buff_head sk_receive_queue;
	struct {
		atomic_t rmem_alloc;
		int len;
		struct sk_buff *head;
		struct sk_buff *tail;
	} sk_backlog;
	int sk_forward_alloc;
	unsigned int sk_ll_usec;
	unsigned int sk_napi_id;
	int sk_rcvbuf;
	struct sk_filter *sk_filter;
	union {
		struct socket_wq *sk_wq;
		struct socket_wq *sk_wq_raw;
	};
	struct xfrm_policy *sk_policy[2];
	struct dst_entry *sk_rx_dst;
	int sk_rx_dst_ifindex;
	u32 sk_rx_dst_cookie;
	struct dst_entry *sk_dst_cache;
	atomic_t sk_omem_alloc;
	int sk_sndbuf;
	int sk_wmem_queued;
	refcount_t sk_wmem_alloc;
	long unsigned int sk_tsq_flags;
	union {
		struct sk_buff *sk_send_head;
		struct rb_root tcp_rtx_queue;
	};
	struct sk_buff *sk_tx_skb_cache;
	struct sk_buff_head sk_write_queue;
	__s32 sk_peek_off;
	int sk_write_pending;
	__u32 sk_dst_pending_confirm;
	u32 sk_pacing_status;
	long int sk_sndtimeo;
	struct timer_list sk_timer;
	__u32 sk_priority;
	__u32 sk_mark;
	long unsigned int sk_pacing_rate;
	long unsigned int sk_max_pacing_rate;
	struct page_frag sk_frag;
	netdev_features_t sk_route_caps;
	netdev_features_t sk_route_nocaps;
	netdev_features_t sk_route_forced_caps;
	int sk_gso_type;
	unsigned int sk_gso_max_size;
	gfp_t sk_allocation;
	__u32 sk_txhash;
	u8 sk_padding: 1;
	u8 sk_kern_sock: 1;
	u8 sk_no_check_tx: 1;
	u8 sk_no_check_rx: 1;
	u8 sk_userlocks: 4;
	u8 sk_pacing_shift;
	u16 sk_type;
	u16 sk_protocol;
	u16 sk_gso_max_segs;
	long unsigned int sk_lingertime;
	struct proto *sk_prot_creator;
	rwlock_t sk_callback_lock;
	int sk_err;
	int sk_err_soft;
	u32 sk_ack_backlog;
	u32 sk_max_ack_backlog;
	kuid_t sk_uid;
	u8 sk_prefer_busy_poll;
	u16 sk_busy_poll_budget;
	spinlock_t sk_peer_lock;
	struct pid *sk_peer_pid;
	const struct cred *sk_peer_cred;
	long int sk_rcvtimeo;
	ktime_t sk_stamp;
	u16 sk_tsflags;
	u8 sk_shutdown;
	u32 sk_tskey;
	atomic_t sk_zckey;
	u8 sk_clockid;
	u8 sk_txtime_deadline_mode: 1;
	u8 sk_txtime_report_errors: 1;
	u8 sk_txtime_unused: 6;
	struct socket *sk_socket;
	void *sk_user_data;
	void *sk_security;
	struct sock_cgroup_data sk_cgrp_data;
	struct mem_cgroup *sk_memcg;
	void (*sk_state_change)(struct sock *);
	void (*sk_data_ready)(struct sock *);
	void (*sk_write_space)(struct sock *);
	void (*sk_error_report)(struct sock *);
	int (*sk_backlog_rcv)(struct sock *, struct sk_buff *);
	struct sk_buff * (*sk_validate_xmit_skb)(struct sock *, struct net_device *, struct sk_buff *);
	void (*sk_destruct)(struct sock *);
	struct sock_reuseport *sk_reuseport_cb;
	struct bpf_local_storage *sk_bpf_storage;
	struct callback_head sk_rcu;
};

typedef short unsigned int __kernel_sa_family_t;

struct __kernel_sockaddr_storage {
	union {
		struct {
			__kernel_sa_family_t ss_family;
			char __data[126];
		};
		void *__align;
	};
};

typedef __kernel_sa_family_t sa_family_t;

struct sockaddr {
	sa_family_t sa_family;
	char sa_data[14];
};

struct msghdr {
	void *msg_name;
	int msg_namelen;
	struct iov_iter msg_iter;
	union {
		void *msg_control;
		void *msg_control_user;
	};
	bool msg_control_is_user: 1;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
	struct kiocb *msg_iocb;
};

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
} sync_serial_settings;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
	unsigned int slot_map;
} te1_settings;

typedef struct {
	short unsigned int encoding;
	short unsigned int parity;
} raw_hdlc_proto;

typedef struct {
	unsigned int t391;
	unsigned int t392;
	unsigned int n391;
	unsigned int n392;
	unsigned int n393;
	short unsigned int lmi;
	short unsigned int dce;
} fr_proto;

typedef struct {
	unsigned int dlci;
} fr_proto_pvc;

typedef struct {
	unsigned int dlci;
	char master[16];
} fr_proto_pvc_info;

typedef struct {
	unsigned int interval;
	unsigned int timeout;
} cisco_proto;

typedef struct {
	short unsigned int dce;
	unsigned int modulo;
	unsigned int window;
	unsigned int t1;
	unsigned int t2;
	unsigned int n2;
} x25_hdlc_proto;

struct ifmap {
	long unsigned int mem_start;
	long unsigned int mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct if_settings {
	unsigned int type;
	unsigned int size;
	union {
		raw_hdlc_proto *raw_hdlc;
		cisco_proto *cisco;
		fr_proto *fr;
		fr_proto_pvc *fr_pvc;
		fr_proto_pvc_info *fr_pvc_info;
		x25_hdlc_proto *x25;
		sync_serial_settings *sync;
		te1_settings *te1;
	} ifs_ifsu;
};

struct ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		int ifru_ivalue;
		int ifru_mtu;
		struct ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		void *ifru_data;
		struct if_settings ifru_settings;
	} ifr_ifru;
};

struct serial_icounter_struct;

struct serial_struct;

struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *, struct file *, int);
	int (*install)(struct tty_driver *, struct tty_struct *);
	void (*remove)(struct tty_driver *, struct tty_struct *);
	int (*open)(struct tty_struct *, struct file *);
	void (*close)(struct tty_struct *, struct file *);
	void (*shutdown)(struct tty_struct *);
	void (*cleanup)(struct tty_struct *);
	int (*write)(struct tty_struct *, const unsigned char *, int);
	int (*put_char)(struct tty_struct *, unsigned char);
	void (*flush_chars)(struct tty_struct *);
	int (*write_room)(struct tty_struct *);
	int (*chars_in_buffer)(struct tty_struct *);
	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, struct ktermios *);
	void (*throttle)(struct tty_struct *);
	void (*unthrottle)(struct tty_struct *);
	void (*stop)(struct tty_struct *);
	void (*start)(struct tty_struct *);
	void (*hangup)(struct tty_struct *);
	int (*break_ctl)(struct tty_struct *, int);
	void (*flush_buffer)(struct tty_struct *);
	void (*set_ldisc)(struct tty_struct *);
	void (*wait_until_sent)(struct tty_struct *, int);
	void (*send_xchar)(struct tty_struct *, char);
	int (*tiocmget)(struct tty_struct *);
	int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);
	int (*resize)(struct tty_struct *, struct winsize *);
	int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *);
	int (*get_serial)(struct tty_struct *, struct serial_struct *);
	int (*set_serial)(struct tty_struct *, struct serial_struct *);
	void (*show_fdinfo)(struct tty_struct *, struct seq_file *);
	int (*poll_init)(struct tty_driver *, int, char *);
	int (*poll_get_char)(struct tty_driver *, int);
	void (*poll_put_char)(struct tty_driver *, int, char);
	int (*proc_show)(struct seq_file *, void *);
};

struct tty_driver {
	int magic;
	struct kref kref;
	struct cdev **cdevs;
	struct module *owner;
	const char *driver_name;
	const char *name;
	int name_base;
	int major;
	int minor_start;
	unsigned int num;
	short int type;
	short int subtype;
	struct ktermios init_termios;
	long unsigned int flags;
	struct proc_dir_entry *proc_entry;
	struct tty_driver *other;
	struct tty_struct **ttys;
	struct tty_port **ports;
	struct ktermios **termios;
	void *driver_state;
	const struct tty_operations *ops;
	struct list_head tty_drivers;
};

struct tty_ldisc_ops {
	char *name;
	int num;
	int flags;
	int (*open)(struct tty_struct *);
	void (*close)(struct tty_struct *);
	void (*flush_buffer)(struct tty_struct *);
	ssize_t (*read)(struct tty_struct *, struct file *, unsigned char *, size_t, void **, long unsigned int);
	ssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t);
	int (*ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, struct ktermios *);
	__poll_t (*poll)(struct tty_struct *, struct file *, struct poll_table_struct *);
	int (*hangup)(struct tty_struct *);
	void (*receive_buf)(struct tty_struct *, const unsigned char *, char *, int);
	void (*write_wakeup)(struct tty_struct *);
	void (*dcd_change)(struct tty_struct *, unsigned int);
	int (*receive_buf2)(struct tty_struct *, const unsigned char *, char *, int);
	struct module *owner;
	int refcount;
};

struct tty_ldisc {
	struct tty_ldisc_ops *ops;
	struct tty_struct *tty;
};

struct tty_port_operations {
	int (*carrier_raised)(struct tty_port *);
	void (*dtr_rts)(struct tty_port *, int);
	void (*shutdown)(struct tty_port *);
	int (*activate)(struct tty_port *, struct tty_struct *);
	void (*destruct)(struct tty_port *);
};

struct tty_port_client_operations {
	int (*receive_buf)(struct tty_port *, const unsigned char *, const unsigned char *, size_t);
	void (*write_wakeup)(struct tty_port *);
};

struct prot_inuse;

struct netns_core {
	struct ctl_table_header *sysctl_hdr;
	int sysctl_somaxconn;
	int *sock_inuse;
	struct prot_inuse *prot_inuse;
};

struct ipstats_mib;

struct tcp_mib;

struct linux_mib;

struct udp_mib;

struct linux_xfrm_mib;

struct linux_tls_mib;

struct mptcp_mib;

struct icmp_mib;

struct icmpmsg_mib;

struct icmpv6_mib;

struct icmpv6msg_mib;

struct netns_mib {
	struct ipstats_mib *ip_statistics;
	struct ipstats_mib *ipv6_statistics;
	struct tcp_mib *tcp_statistics;
	struct linux_mib *net_statistics;
	struct udp_mib *udp_statistics;
	struct udp_mib *udp_stats_in6;
	struct linux_xfrm_mib *xfrm_statistics;
	struct linux_tls_mib *tls_statistics;
	struct mptcp_mib *mptcp_statistics;
	struct udp_mib *udplite_statistics;
	struct udp_mib *udplite_stats_in6;
	struct icmp_mib *icmp_statistics;
	struct icmpmsg_mib *icmpmsg_statistics;
	struct icmpv6_mib *icmpv6_statistics;
	struct icmpv6msg_mib *icmpv6msg_statistics;
	struct proc_dir_entry *proc_net_devsnmp6;
};

struct netns_packet {
	struct mutex sklist_lock;
	struct hlist_head sklist;
};

struct netns_unix {
	int sysctl_max_dgram_qlen;
	struct ctl_table_header *ctl;
};

struct netns_nexthop {
	struct rb_root rb_root;
	struct hlist_head *devhash;
	unsigned int seq;
	u32 last_id_allocated;
	struct blocking_notifier_head notifier_chain;
};

struct inet_hashinfo;

struct inet_timewait_death_row {
	atomic_t tw_count;
	char tw_pad[60];
	struct inet_hashinfo *hashinfo;
	int sysctl_max_tw_buckets;
};

struct local_ports {
	seqlock_t lock;
	int range[2];
	bool warned;
};

struct ping_group_range {
	seqlock_t lock;
	kgid_t range[2];
};

typedef struct {
	u64 key[2];
} siphash_key_t;

struct ipv4_devconf;

struct ip_ra_chain;

struct fib_rules_ops;

struct fib_table;

struct inet_peer_base;

struct fqdir;

struct tcp_congestion_ops;

struct tcp_fastopen_context;

struct fib_notifier_ops;

struct netns_ipv4 {
	struct inet_timewait_death_row tcp_death_row;
	struct ctl_table_header *forw_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *ipv4_hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *xfrm4_hdr;
	struct ipv4_devconf *devconf_all;
	struct ipv4_devconf *devconf_dflt;
	struct ip_ra_chain *ra_chain;
	struct mutex ra_mutex;
	struct fib_rules_ops *rules_ops;
	struct fib_table *fib_main;
	struct fib_table *fib_default;
	unsigned int fib_rules_require_fldissect;
	bool fib_has_custom_rules;
	bool fib_has_custom_local_routes;
	bool fib_offload_disabled;
	atomic_t fib_num_tclassid_users;
	struct hlist_head *fib_table_hash;
	struct sock *fibnl;
	struct sock **icmp_sk;
	struct sock *mc_autojoin_sk;
	struct inet_peer_base *peers;
	struct sock **tcp_sk;
	struct fqdir *fqdir;
	u8 sysctl_icmp_echo_ignore_all;
	u8 sysctl_icmp_echo_enable_probe;
	u8 sysctl_icmp_echo_ignore_broadcasts;
	u8 sysctl_icmp_ignore_bogus_error_responses;
	u8 sysctl_icmp_errors_use_inbound_ifaddr;
	int sysctl_icmp_ratelimit;
	int sysctl_icmp_ratemask;
	struct local_ports ip_local_ports;
	u8 sysctl_tcp_ecn;
	u8 sysctl_tcp_ecn_fallback;
	u8 sysctl_ip_default_ttl;
	u8 sysctl_ip_no_pmtu_disc;
	u8 sysctl_ip_fwd_use_pmtu;
	u8 sysctl_ip_fwd_update_priority;
	u8 sysctl_ip_nonlocal_bind;
	u8 sysctl_ip_autobind_reuse;
	u8 sysctl_ip_dynaddr;
	u8 sysctl_ip_early_demux;
	u8 sysctl_raw_l3mdev_accept;
	u8 sysctl_tcp_early_demux;
	u8 sysctl_udp_early_demux;
	u8 sysctl_nexthop_compat_mode;
	u8 sysctl_fwmark_reflect;
	u8 sysctl_tcp_fwmark_accept;
	u8 sysctl_tcp_l3mdev_accept;
	u8 sysctl_tcp_mtu_probing;
	int sysctl_tcp_mtu_probe_floor;
	int sysctl_tcp_base_mss;
	int sysctl_tcp_min_snd_mss;
	int sysctl_tcp_probe_threshold;
	u32 sysctl_tcp_probe_interval;
	int sysctl_tcp_keepalive_time;
	int sysctl_tcp_keepalive_intvl;
	u8 sysctl_tcp_keepalive_probes;
	u8 sysctl_tcp_syn_retries;
	u8 sysctl_tcp_synack_retries;
	u8 sysctl_tcp_syncookies;
	int sysctl_tcp_reordering;
	u8 sysctl_tcp_retries1;
	u8 sysctl_tcp_retries2;
	u8 sysctl_tcp_orphan_retries;
	u8 sysctl_tcp_tw_reuse;
	int sysctl_tcp_fin_timeout;
	unsigned int sysctl_tcp_notsent_lowat;
	u8 sysctl_tcp_sack;
	u8 sysctl_tcp_window_scaling;
	u8 sysctl_tcp_timestamps;
	u8 sysctl_tcp_early_retrans;
	u8 sysctl_tcp_recovery;
	u8 sysctl_tcp_thin_linear_timeouts;
	u8 sysctl_tcp_slow_start_after_idle;
	u8 sysctl_tcp_retrans_collapse;
	u8 sysctl_tcp_stdurg;
	u8 sysctl_tcp_rfc1337;
	u8 sysctl_tcp_abort_on_overflow;
	u8 sysctl_tcp_fack;
	int sysctl_tcp_max_reordering;
	int sysctl_tcp_adv_win_scale;
	u8 sysctl_tcp_dsack;
	u8 sysctl_tcp_app_win;
	u8 sysctl_tcp_frto;
	u8 sysctl_tcp_nometrics_save;
	u8 sysctl_tcp_no_ssthresh_metrics_save;
	u8 sysctl_tcp_moderate_rcvbuf;
	u8 sysctl_tcp_tso_win_divisor;
	u8 sysctl_tcp_workaround_signed_windows;
	int sysctl_tcp_limit_output_bytes;
	int sysctl_tcp_challenge_ack_limit;
	int sysctl_tcp_min_rtt_wlen;
	u8 sysctl_tcp_min_tso_segs;
	u8 sysctl_tcp_autocorking;
	u8 sysctl_tcp_reflect_tos;
	u8 sysctl_tcp_comp_sack_nr;
	int sysctl_tcp_invalid_ratelimit;
	int sysctl_tcp_pacing_ss_ratio;
	int sysctl_tcp_pacing_ca_ratio;
	int sysctl_tcp_wmem[3];
	int sysctl_tcp_rmem[3];
	long unsigned int sysctl_tcp_comp_sack_delay_ns;
	long unsigned int sysctl_tcp_comp_sack_slack_ns;
	int sysctl_max_syn_backlog;
	int sysctl_tcp_fastopen;
	const struct tcp_congestion_ops *tcp_congestion_control;
	struct tcp_fastopen_context *tcp_fastopen_ctx;
	spinlock_t tcp_fastopen_ctx_lock;
	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
	atomic_t tfo_active_disable_times;
	long unsigned int tfo_active_disable_stamp;
	int sysctl_udp_wmem_min;
	int sysctl_udp_rmem_min;
	u8 sysctl_fib_notify_on_flag_change;
	u8 sysctl_udp_l3mdev_accept;
	u8 sysctl_igmp_llm_reports;
	int sysctl_igmp_max_memberships;
	int sysctl_igmp_max_msf;
	int sysctl_igmp_qrv;
	struct ping_group_range ping_group_range;
	atomic_t dev_addr_genid;
	long unsigned int *sysctl_local_reserved_ports;
	int sysctl_ip_prot_sock;
	struct list_head mr_tables;
	struct fib_rules_ops *mr_rules_ops;
	u8 sysctl_fib_multipath_use_neigh;
	u8 sysctl_fib_multipath_hash_policy;
	struct fib_notifier_ops *notifier_ops;
	unsigned int fib_seq;
	struct fib_notifier_ops *ipmr_notifier_ops;
	unsigned int ipmr_seq;
	atomic_t rt_genid;
	siphash_key_t ip_id_key;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct neighbour;

struct dst_ops {
	short unsigned int family;
	unsigned int gc_thresh;
	int (*gc)(struct dst_ops *);
	struct dst_entry * (*check)(struct dst_entry *, __u32);
	unsigned int (*default_advmss)(const struct dst_entry *);
	unsigned int (*mtu)(const struct dst_entry *);
	u32 * (*cow_metrics)(struct dst_entry *, long unsigned int);
	void (*destroy)(struct dst_entry *);
	void (*ifdown)(struct dst_entry *, struct net_device *, int);
	struct dst_entry * (*negative_advice)(struct dst_entry *);
	void (*link_failure)(struct sk_buff *);
	void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32, bool);
	void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *);
	int (*local_out)(struct net *, struct sock *, struct sk_buff *);
	struct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff *, const void *);
	void (*confirm_neigh)(const struct dst_entry *, const void *);
	struct kmem_cache *kmem_cachep;
	struct percpu_counter pcpuc_entries;
	long: 64;
	long: 64;
	long: 64;
};

struct netns_sysctl_ipv6 {
	struct ctl_table_header *hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *icmp_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *xfrm6_hdr;
	int flush_delay;
	int ip6_rt_max_size;
	int ip6_rt_gc_min_interval;
	int ip6_rt_gc_timeout;
	int ip6_rt_gc_interval;
	int ip6_rt_gc_elasticity;
	int ip6_rt_mtu_expires;
	int ip6_rt_min_advmss;
	u8 bindv6only;
	u8 multipath_hash_policy;
	u8 flowlabel_consistency;
	u8 auto_flowlabels;
	int icmpv6_time;
	u8 icmpv6_echo_ignore_all;
	u8 icmpv6_echo_ignore_multicast;
	u8 icmpv6_echo_ignore_anycast;
	long unsigned int icmpv6_ratemask[4];
	long unsigned int *icmpv6_ratemask_ptr;
	u8 anycast_src_echo_reply;
	u8 ip_nonlocal_bind;
	u8 fwmark_reflect;
	u8 flowlabel_state_ranges;
	int idgen_retries;
	int idgen_delay;
	int flowlabel_reflect;
	int max_dst_opts_cnt;
	int max_hbh_opts_cnt;
	int max_dst_opts_len;
	int max_hbh_opts_len;
	int seg6_flowlabel;
	bool skip_notify_on_dev_down;
	u8 fib_notify_on_flag_change;
};

struct ipv6_devconf;

struct fib6_info;

struct rt6_info;

struct rt6_statistics;

struct fib6_table;

struct seg6_pernet_data;

struct netns_ipv6 {
	struct dst_ops ip6_dst_ops;
	struct netns_sysctl_ipv6 sysctl;
	struct ipv6_devconf *devconf_all;
	struct ipv6_devconf *devconf_dflt;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	struct fib6_info *fib6_null_entry;
	struct rt6_info *ip6_null_entry;
	struct rt6_statistics *rt6_stats;
	struct timer_list ip6_fib_timer;
	struct hlist_head *fib_table_hash;
	struct fib6_table *fib6_main_tbl;
	struct list_head fib6_walkers;
	rwlock_t fib6_walker_lock;
	spinlock_t fib6_gc_lock;
	unsigned int ip6_rt_gc_expire;
	long unsigned int ip6_rt_last_gc;
	unsigned int fib6_rules_require_fldissect;
	bool fib6_has_custom_rules;
	unsigned int fib6_routes_require_src;
	struct rt6_info *ip6_prohibit_entry;
	struct rt6_info *ip6_blk_hole_entry;
	struct fib6_table *fib6_local_tbl;
	struct fib_rules_ops *fib6_rules_ops;
	struct sock **icmp_sk;
	struct sock *ndisc_sk;
	struct sock *tcp_sk;
	struct sock *igmp_sk;
	struct sock *mc_autojoin_sk;
	struct list_head mr6_tables;
	struct fib_rules_ops *mr6_rules_ops;
	atomic_t dev_addr_genid;
	atomic_t fib6_sernum;
	struct seg6_pernet_data *seg6_data;
	struct fib_notifier_ops *notifier_ops;
	struct fib_notifier_ops *ip6mr_notifier_ops;
	unsigned int ipmr_seq;
	struct {
		struct hlist_head head;
		spinlock_t lock;
		u32 seq;
	} ip6addrlbl_table;
	long: 64;
	long: 64;
	long: 64;
};

struct netns_sysctl_lowpan {
	struct ctl_table_header *frags_hdr;
};

struct netns_ieee802154_lowpan {
	struct netns_sysctl_lowpan sysctl;
	struct fqdir *fqdir;
};

struct sctp_mib;

struct netns_sctp {
	struct sctp_mib *sctp_statistics;
	struct proc_dir_entry *proc_net_sctp;
	struct ctl_table_header *sysctl_header;
	struct sock *ctl_sock;
	struct sock *udp4_sock;
	struct sock *udp6_sock;
	int udp_port;
	int encap_port;
	struct list_head local_addr_list;
	struct list_head addr_waitq;
	struct timer_list addr_wq_timer;
	struct list_head auto_asconf_splist;
	spinlock_t addr_wq_lock;
	spinlock_t local_addr_lock;
	unsigned int rto_initial;
	unsigned int rto_min;
	unsigned int rto_max;
	int rto_alpha;
	int rto_beta;
	int max_burst;
	int cookie_preserve_enable;
	char *sctp_hmac_alg;
	unsigned int valid_cookie_life;
	unsigned int sack_timeout;
	unsigned int hb_interval;
	int max_retrans_association;
	int max_retrans_path;
	int max_retrans_init;
	int pf_retrans;
	int ps_retrans;
	int pf_enable;
	int pf_expose;
	int sndbuf_policy;
	int rcvbuf_policy;
	int default_auto_asconf;
	int addip_enable;
	int addip_noauth;
	int prsctp_enable;
	int reconf_enable;
	int auth_enable;
	int intl_enable;
	int ecn_enable;
	int scope_policy;
	int rwnd_upd_shift;
	long unsigned int max_autoclose;
};

struct nf_queue_handler;

struct nf_logger;

struct nf_hook_entries;

struct netns_nf {
	struct proc_dir_entry *proc_netfilter;
	const struct nf_queue_handler *queue_handler;
	const struct nf_logger *nf_loggers[13];
	struct ctl_table_header *nf_log_dir_header;
	struct nf_hook_entries *hooks_ipv4[5];
	struct nf_hook_entries *hooks_ipv6[5];
	struct nf_hook_entries *hooks_arp[3];
	struct nf_hook_entries *hooks_bridge[5];
	struct nf_hook_entries *hooks_decnet[7];
	unsigned int defrag_ipv4_users;
	unsigned int defrag_ipv6_users;
};

struct netns_xt {
	bool notrack_deprecated_warning;
	bool clusterip_deprecated_warning;
};

struct nf_generic_net {
	unsigned int timeout;
};

struct nf_tcp_net {
	unsigned int timeouts[14];
	u8 tcp_loose;
	u8 tcp_be_liberal;
	u8 tcp_max_retrans;
};

struct nf_udp_net {
	unsigned int timeouts[2];
};

struct nf_icmp_net {
	unsigned int timeout;
};

struct nf_dccp_net {
	u8 dccp_loose;
	unsigned int dccp_timeout[10];
};

struct nf_sctp_net {
	unsigned int timeouts[10];
};

struct nf_gre_net {
	struct list_head keymap_list;
	unsigned int timeouts[2];
};

struct nf_ip_net {
	struct nf_generic_net generic;
	struct nf_tcp_net tcp;
	struct nf_udp_net udp;
	struct nf_icmp_net icmp;
	struct nf_icmp_net icmpv6;
	struct nf_dccp_net dccp;
	struct nf_sctp_net sctp;
	struct nf_gre_net gre;
};

struct ct_pcpu;

struct ip_conntrack_stat;

struct nf_ct_event_notifier;

struct nf_exp_event_notifier;

struct netns_ct {
	bool ecache_dwork_pending;
	u8 sysctl_log_invalid;
	u8 sysctl_events;
	u8 sysctl_acct;
	u8 sysctl_auto_assign_helper;
	u8 sysctl_tstamp;
	u8 sysctl_checksum;
	struct ct_pcpu *pcpu_lists;
	struct ip_conntrack_stat *stat;
	struct nf_ct_event_notifier *nf_conntrack_event_cb;
	struct nf_exp_event_notifier *nf_expect_event_cb;
	struct nf_ip_net nf_ct_proto;
	unsigned int labels_used;
};

struct netns_nftables {
	u8 gencursor;
};

struct netns_bpf {
	struct bpf_prog_array *run_array[2];
	struct bpf_prog *progs[2];
	struct list_head links[2];
};

struct xfrm_policy_hash {
	struct hlist_head *table;
	unsigned int hmask;
	u8 dbits4;
	u8 sbits4;
	u8 dbits6;
	u8 sbits6;
};

struct xfrm_policy_hthresh {
	struct work_struct work;
	seqlock_t lock;
	u8 lbits4;
	u8 rbits4;
	u8 lbits6;
	u8 rbits6;
};

struct netns_xfrm {
	struct list_head state_all;
	struct hlist_head *state_bydst;
	struct hlist_head *state_bysrc;
	struct hlist_head *state_byspi;
	unsigned int state_hmask;
	unsigned int state_num;
	struct work_struct state_hash_work;
	struct list_head policy_all;
	struct hlist_head *policy_byidx;
	unsigned int policy_idx_hmask;
	struct hlist_head policy_inexact[3];
	struct xfrm_policy_hash policy_bydst[3];
	unsigned int policy_count[6];
	struct work_struct policy_hash_work;
	struct xfrm_policy_hthresh policy_hthresh;
	struct list_head inexact_bins;
	struct sock *nlsk;
	struct sock *nlsk_stash;
	u32 sysctl_aevent_etime;
	u32 sysctl_aevent_rseqth;
	int sysctl_larval_drop;
	u32 sysctl_acq_expires;
	struct ctl_table_header *sysctl_hdr;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dst_ops xfrm4_dst_ops;
	struct dst_ops xfrm6_dst_ops;
	spinlock_t xfrm_state_lock;
	seqcount_spinlock_t xfrm_state_hash_generation;
	seqcount_spinlock_t xfrm_policy_hash_generation;
	spinlock_t xfrm_policy_lock;
	struct mutex xfrm_cfg_mutex;
	long: 64;
	long: 64;
};

struct netns_ipvs;

struct mpls_route;

struct netns_mpls {
	int ip_ttl_propagate;
	int default_ttl;
	size_t platform_labels;
	struct mpls_route **platform_label;
	struct ctl_table_header *ctl;
};

struct can_dev_rcv_lists;

struct can_pkg_stats;

struct can_rcv_lists_stats;

struct netns_can {
	struct proc_dir_entry *proc_dir;
	struct proc_dir_entry *pde_stats;
	struct proc_dir_entry *pde_reset_stats;
	struct proc_dir_entry *pde_rcvlist_all;
	struct proc_dir_entry *pde_rcvlist_fil;
	struct proc_dir_entry *pde_rcvlist_inv;
	struct proc_dir_entry *pde_rcvlist_sff;
	struct proc_dir_entry *pde_rcvlist_eff;
	struct proc_dir_entry *pde_rcvlist_err;
	struct proc_dir_entry *bcmproc_dir;
	struct can_dev_rcv_lists *rx_alldev_list;
	spinlock_t rcvlists_lock;
	struct timer_list stattimer;
	struct can_pkg_stats *pkg_stats;
	struct can_rcv_lists_stats *rcv_lists_stats;
	struct hlist_head cgw_list;
};

struct netns_xdp {
	struct mutex lock;
	struct hlist_head list;
};

struct smc_stats;

struct smc_stats_rsn;

struct netns_smc {
	struct smc_stats *smc_stats;
	struct mutex mutex_fback_rsn;
	struct smc_stats_rsn *fback_rsn;
};

struct uevent_sock;

struct net_generic;

struct net {
	refcount_t passive;
	spinlock_t rules_mod_lock;
	unsigned int dev_unreg_count;
	unsigned int dev_base_seq;
	int ifindex;
	spinlock_t nsid_lock;
	atomic_t fnhe_genid;
	struct list_head list;
	struct list_head exit_list;
	struct llist_node cleanup_list;
	struct key_tag *key_domain;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct idr netns_ids;
	struct ns_common ns;
	struct list_head dev_base_head;
	struct proc_dir_entry *proc_net;
	struct proc_dir_entry *proc_net_stat;
	struct ctl_table_set sysctls;
	struct sock *rtnl;
	struct sock *genl_sock;
	struct uevent_sock *uevent_sock;
	struct hlist_head *dev_name_head;
	struct hlist_head *dev_index_head;
	struct raw_notifier_head netdev_chain;
	u32 hash_mix;
	struct net_device *loopback_dev;
	struct list_head rules_ops;
	struct netns_core core;
	struct netns_mib mib;
	struct netns_packet packet;
	struct netns_unix unx;
	struct netns_nexthop nexthop;
	struct netns_ipv4 ipv4;
	struct netns_ipv6 ipv6;
	struct netns_ieee802154_lowpan ieee802154_lowpan;
	struct netns_sctp sctp;
	struct netns_nf nf;
	struct netns_xt xt;
	struct netns_ct ct;
	struct netns_nftables nft;
	struct sk_buff_head wext_nlevents;
	struct net_generic *gen;
	struct netns_bpf bpf;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct netns_xfrm xfrm;
	u64 net_cookie;
	struct netns_ipvs *ipvs;
	struct netns_mpls mpls;
	struct netns_can can;
	struct netns_xdp xdp;
	struct sock *crypto_nlsk;
	struct sock *diag_nlsk;
	struct netns_smc smc;
	long: 64;
};

typedef struct {
	local64_t v;
} u64_stats_t;

struct bpf_offloaded_map;

struct bpf_map_dev_ops {
	int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *);
	int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *);
	int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_offloaded_map *, void *);
};

struct bpf_offloaded_map {
	struct bpf_map map;
	struct net_device *netdev;
	const struct bpf_map_dev_ops *dev_ops;
	void *dev_priv;
	struct list_head offloads;
	long: 64;
	long: 64;
	long: 64;
};

struct net_device_stats {
	long unsigned int rx_packets;
	long unsigned int tx_packets;
	long unsigned int rx_bytes;
	long unsigned int tx_bytes;
	long unsigned int rx_errors;
	long unsigned int tx_errors;
	long unsigned int rx_dropped;
	long unsigned int tx_dropped;
	long unsigned int multicast;
	long unsigned int collisions;
	long unsigned int rx_length_errors;
	long unsigned int rx_over_errors;
	long unsigned int rx_crc_errors;
	long unsigned int rx_frame_errors;
	long unsigned int rx_fifo_errors;
	long unsigned int rx_missed_errors;
	long unsigned int tx_aborted_errors;
	long unsigned int tx_carrier_errors;
	long unsigned int tx_fifo_errors;
	long unsigned int tx_heartbeat_errors;
	long unsigned int tx_window_errors;
	long unsigned int rx_compressed;
	long unsigned int tx_compressed;
};

struct netdev_hw_addr_list {
	struct list_head list;
	int count;
};

struct tipc_bearer;

struct dn_dev;

struct mpls_dev;

enum rx_handler_result {
	RX_HANDLER_CONSUMED = 0,
	RX_HANDLER_ANOTHER = 1,
	RX_HANDLER_EXACT = 2,
	RX_HANDLER_PASS = 3,
};

typedef enum rx_handler_result rx_handler_result_t;

typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

enum netdev_ml_priv_type {
	ML_PRIV_NONE = 0,
	ML_PRIV_CAN = 1,
};

struct pcpu_dstats;

struct garp_port;

struct mrp_port;

struct netdev_tc_txq {
	u16 count;
	u16 offset;
};

struct macsec_ops;

struct udp_tunnel_nic;

struct bpf_xdp_link;

struct bpf_xdp_entity {
	struct bpf_prog *prog;
	struct bpf_xdp_link *link;
};

struct netdev_name_node;

struct dev_ifalias;

struct net_device_ops;

struct iw_handler_def;

struct iw_public_data;

struct ethtool_ops;

struct l3mdev_ops;

struct ndisc_ops;

struct xfrmdev_ops;

struct tlsdev_ops;

struct header_ops;

struct vlan_info;

struct dsa_port;

struct in_device;

struct inet6_dev;

struct wireless_dev;

struct wpan_dev;

struct netdev_rx_queue;

struct mini_Qdisc;

struct netdev_queue;

struct cpu_rmap;

struct Qdisc;

struct xdp_dev_bulk_queue;

struct xps_dev_maps;

struct netpoll_info;

struct pcpu_lstats;

struct pcpu_sw_netstats;

struct rtnl_link_ops;

struct dcbnl_rtnl_ops;

struct netprio_map;

struct phy_device;

struct sfp_bus;

struct udp_tunnel_nic_info;

struct net_device {
	char name[16];
	struct netdev_name_node *name_node;
	struct dev_ifalias *ifalias;
	long unsigned int mem_end;
	long unsigned int mem_start;
	long unsigned int base_addr;
	long unsigned int state;
	struct list_head dev_list;
	struct list_head napi_list;
	struct list_head unreg_list;
	struct list_head close_list;
	struct list_head ptype_all;
	struct list_head ptype_specific;
	struct {
		struct list_head upper;
		struct list_head lower;
	} adj_list;
	unsigned int flags;
	unsigned int priv_flags;
	const struct net_device_ops *netdev_ops;
	int ifindex;
	short unsigned int gflags;
	short unsigned int hard_header_len;
	unsigned int mtu;
	short unsigned int needed_headroom;
	short unsigned int needed_tailroom;
	netdev_features_t features;
	netdev_features_t hw_features;
	netdev_features_t wanted_features;
	netdev_features_t vlan_features;
	netdev_features_t hw_enc_features;
	netdev_features_t mpls_features;
	netdev_features_t gso_partial_features;
	unsigned int min_mtu;
	unsigned int max_mtu;
	short unsigned int type;
	unsigned char min_header_len;
	unsigned char name_assign_type;
	int group;
	struct net_device_stats stats;
	atomic_long_t rx_dropped;
	atomic_long_t tx_dropped;
	atomic_long_t rx_nohandler;
	atomic_t carrier_up_count;
	atomic_t carrier_down_count;
	const struct iw_handler_def *wireless_handlers;
	struct iw_public_data *wireless_data;
	const struct ethtool_ops *ethtool_ops;
	const struct l3mdev_ops *l3mdev_ops;
	const struct ndisc_ops *ndisc_ops;
	const struct xfrmdev_ops *xfrmdev_ops;
	const struct tlsdev_ops *tlsdev_ops;
	const struct header_ops *header_ops;
	unsigned char operstate;
	unsigned char link_mode;
	unsigned char if_port;
	unsigned char dma;
	unsigned char perm_addr[32];
	unsigned char addr_assign_type;
	unsigned char addr_len;
	unsigned char upper_level;
	unsigned char lower_level;
	short unsigned int neigh_priv_len;
	short unsigned int dev_id;
	short unsigned int dev_port;
	short unsigned int padded;
	spinlock_t addr_list_lock;
	int irq;
	struct netdev_hw_addr_list uc;
	struct netdev_hw_addr_list mc;
	struct netdev_hw_addr_list dev_addrs;
	struct kset *queues_kset;
	unsigned int promiscuity;
	unsigned int allmulti;
	bool uc_promisc;
	struct vlan_info *vlan_info;
	struct dsa_port *dsa_ptr;
	struct tipc_bearer *tipc_ptr;
	void *atalk_ptr;
	struct in_device *ip_ptr;
	struct dn_dev *dn_ptr;
	struct inet6_dev *ip6_ptr;
	void *ax25_ptr;
	struct wireless_dev *ieee80211_ptr;
	struct wpan_dev *ieee802154_ptr;
	struct mpls_dev *mpls_ptr;
	unsigned char *dev_addr;
	struct netdev_rx_queue *_rx;
	unsigned int num_rx_queues;
	unsigned int real_num_rx_queues;
	struct bpf_prog *xdp_prog;
	long unsigned int gro_flush_timeout;
	int napi_defer_hard_irqs;
	rx_handler_func_t *rx_handler;
	void *rx_handler_data;
	struct mini_Qdisc *miniq_ingress;
	struct netdev_queue *ingress_queue;
	struct nf_hook_entries *nf_hooks_ingress;
	unsigned char broadcast[32];
	struct cpu_rmap *rx_cpu_rmap;
	struct hlist_node index_hlist;
	struct netdev_queue *_tx;
	unsigned int num_tx_queues;
	unsigned int real_num_tx_queues;
	struct Qdisc *qdisc;
	unsigned int tx_queue_len;
	spinlock_t tx_global_lock;
	struct xdp_dev_bulk_queue *xdp_bulkq;
	struct xps_dev_maps *xps_maps[2];
	struct mini_Qdisc *miniq_egress;
	struct hlist_head qdisc_hash[16];
	struct timer_list watchdog_timer;
	int watchdog_timeo;
	u32 proto_down_reason;
	struct list_head todo_list;
	int *pcpu_refcnt;
	struct list_head link_watch_list;
	enum {
		NETREG_UNINITIALIZED = 0,
		NETREG_REGISTERED = 1,
		NETREG_UNREGISTERING = 2,
		NETREG_UNREGISTERED = 3,
		NETREG_RELEASED = 4,
		NETREG_DUMMY = 5,
	} reg_state: 8;
	bool dismantle;
	enum {
		RTNL_LINK_INITIALIZED = 0,
		RTNL_LINK_INITIALIZING = 1,
	} rtnl_link_state: 16;
	bool needs_free_netdev;
	void (*priv_destructor)(struct net_device *);
	struct netpoll_info *npinfo;
	possible_net_t nd_net;
	void *ml_priv;
	enum netdev_ml_priv_type ml_priv_type;
	union {
		struct pcpu_lstats *lstats;
		struct pcpu_sw_netstats *tstats;
		struct pcpu_dstats *dstats;
	};
	struct garp_port *garp_port;
	struct mrp_port *mrp_port;
	struct device dev;
	const struct attribute_group *sysfs_groups[4];
	const struct attribute_group *sysfs_rx_queue_group;
	const struct rtnl_link_ops *rtnl_link_ops;
	unsigned int gso_max_size;
	u16 gso_max_segs;
	const struct dcbnl_rtnl_ops *dcbnl_ops;
	s16 num_tc;
	struct netdev_tc_txq tc_to_txq[16];
	u8 prio_tc_map[16];
	unsigned int fcoe_ddp_xid;
	struct netprio_map *priomap;
	struct phy_device *phydev;
	struct sfp_bus *sfp_bus;
	struct lock_class_key *qdisc_tx_busylock;
	struct lock_class_key *qdisc_running_key;
	bool proto_down;
	unsigned int wol_enabled: 1;
	unsigned int threaded: 1;
	struct list_head net_notifier_list;
	const struct macsec_ops *macsec_ops;
	const struct udp_tunnel_nic_info *udp_tunnel_nic_info;
	struct udp_tunnel_nic *udp_tunnel_nic;
	struct bpf_xdp_entity xdp_state[3];
	long: 64;
	long: 64;
};

struct bpf_dispatcher_prog {
	struct bpf_prog *prog;
	refcount_t users;
};

struct bpf_dispatcher {
	struct mutex mutex;
	void *func;
	struct bpf_dispatcher_prog progs[48];
	int num_progs;
	void *image;
	u32 image_off;
	struct bpf_ksym ksym;
};

typedef unsigned int sk_buff_data_t;

struct skb_ext;

struct sk_buff {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
			union {
				struct net_device *dev;
				long unsigned int dev_scratch;
			};
		};
		struct rb_node rbnode;
		struct list_head list;
	};
	union {
		struct sock *sk;
		int ip_defrag_offset;
	};
	union {
		ktime_t tstamp;
		u64 skb_mstamp_ns;
	};
	char cb[48];
	union {
		struct {
			long unsigned int _skb_refdst;
			void (*destructor)(struct sk_buff *);
		};
		struct list_head tcp_tsorted_anchor;
		long unsigned int _sk_redir;
	};
	long unsigned int _nfct;
	unsigned int len;
	unsigned int data_len;
	__u16 mac_len;
	__u16 hdr_len;
	__u16 queue_mapping;
	__u8 __cloned_offset[0];
	__u8 cloned: 1;
	__u8 nohdr: 1;
	__u8 fclone: 2;
	__u8 peeked: 1;
	__u8 head_frag: 1;
	__u8 pfmemalloc: 1;
	__u8 active_extensions;
	__u32 headers_start[0];
	__u8 __pkt_type_offset[0];
	__u8 pkt_type: 3;
	__u8 ignore_df: 1;
	__u8 nf_trace: 1;
	__u8 ip_summed: 2;
	__u8 ooo_okay: 1;
	__u8 l4_hash: 1;
	__u8 sw_hash: 1;
	__u8 wifi_acked_valid: 1;
	__u8 wifi_acked: 1;
	__u8 no_fcs: 1;
	__u8 encapsulation: 1;
	__u8 encap_hdr_csum: 1;
	__u8 csum_valid: 1;
	__u8 __pkt_vlan_present_offset[0];
	__u8 vlan_present: 1;
	__u8 csum_complete_sw: 1;
	__u8 csum_level: 2;
	__u8 csum_not_inet: 1;
	__u8 dst_pending_confirm: 1;
	__u8 ndisc_nodetype: 2;
	__u8 ipvs_property: 1;
	__u8 inner_protocol_type: 1;
	__u8 remcsum_offload: 1;
	__u8 offload_fwd_mark: 1;
	__u8 offload_l3_fwd_mark: 1;
	__u8 tc_skip_classify: 1;
	__u8 tc_at_ingress: 1;
	__u8 redirected: 1;
	__u8 from_ingress: 1;
	__u8 decrypted: 1;
	__u16 tc_index;
	union {
		__wsum csum;
		struct {
			__u16 csum_start;
			__u16 csum_offset;
		};
	};
	__u32 priority;
	int skb_iif;
	__u32 hash;
	__be16 vlan_proto;
	__u16 vlan_tci;
	union {
		unsigned int napi_id;
		unsigned int sender_cpu;
	};
	__u32 secmark;
	union {
		__u32 mark;
		__u32 reserved_tailroom;
	};
	union {
		__be16 inner_protocol;
		__u8 inner_ipproto;
	};
	__u16 inner_transport_header;
	__u16 inner_network_header;
	__u16 inner_mac_header;
	__be16 protocol;
	__u16 transport_header;
	__u16 network_header;
	__u16 mac_header;
	__u32 headers_end[0];
	sk_buff_data_t tail;
	sk_buff_data_t end;
	unsigned char *head;
	unsigned char *data;
	unsigned int truesize;
	refcount_t users;
	struct skb_ext *extensions;
};

struct scatterlist {
	long unsigned int page_link;
	unsigned int offset;
	unsigned int length;
	dma_addr_t dma_address;
	unsigned int dma_length;
};

typedef int suspend_state_t;

enum suspend_stat_step {
	SUSPEND_FREEZE = 1,
	SUSPEND_PREPARE = 2,
	SUSPEND_SUSPEND = 3,
	SUSPEND_SUSPEND_LATE = 4,
	SUSPEND_SUSPEND_NOIRQ = 5,
	SUSPEND_RESUME_NOIRQ = 6,
	SUSPEND_RESUME_EARLY = 7,
	SUSPEND_RESUME = 8,
};

struct suspend_stats {
	int success;
	int fail;
	int failed_freeze;
	int failed_prepare;
	int failed_suspend;
	int failed_suspend_late;
	int failed_suspend_noirq;
	int failed_resume;
	int failed_resume_early;
	int failed_resume_noirq;
	int last_failed_dev;
	char failed_devs[80];
	int last_failed_errno;
	int errno[2];
	int last_failed_step;
	enum suspend_stat_step failed_steps[2];
};

enum s2idle_states {
	S2IDLE_STATE_NONE = 0,
	S2IDLE_STATE_ENTER = 1,
	S2IDLE_STATE_WAKE = 2,
};

enum {
	Root_NFS = 255,
	Root_CIFS = 254,
	Root_RAM0 = 1048576,
	Root_RAM1 = 1048577,
	Root_FD0 = 2097152,
	Root_HDA1 = 3145729,
	Root_HDA2 = 3145730,
	Root_SDA1 = 8388609,
	Root_SDA2 = 8388610,
	Root_HDC1 = 23068673,
	Root_SR0 = 11534336,
};

struct xdr_buf {
	struct kvec head[1];
	struct kvec tail[1];
	struct bio_vec *bvec;
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int flags;
	unsigned int buflen;
	unsigned int len;
};

struct rpc_rqst;

struct xdr_stream {
	__be32 *p;
	struct xdr_buf *buf;
	__be32 *end;
	struct kvec *iov;
	struct kvec scratch;
	struct page **page_ptr;
	unsigned int nwords;
	struct rpc_rqst *rqst;
};

struct rpc_xprt;

struct rpc_task;

struct rpc_cred;

struct rpc_rqst {
	struct rpc_xprt *rq_xprt;
	struct xdr_buf rq_snd_buf;
	struct xdr_buf rq_rcv_buf;
	struct rpc_task *rq_task;
	struct rpc_cred *rq_cred;
	__be32 rq_xid;
	int rq_cong;
	u32 rq_seqno;
	int rq_enc_pages_num;
	struct page **rq_enc_pages;
	void (*rq_release_snd_buf)(struct rpc_rqst *);
	union {
		struct list_head rq_list;
		struct rb_node rq_recv;
	};
	struct list_head rq_xmit;
	struct list_head rq_xmit2;
	void *rq_buffer;
	size_t rq_callsize;
	void *rq_rbuffer;
	size_t rq_rcvsize;
	size_t rq_xmit_bytes_sent;
	size_t rq_reply_bytes_recvd;
	struct xdr_buf rq_private_buf;
	long unsigned int rq_majortimeo;
	long unsigned int rq_minortimeo;
	long unsigned int rq_timeout;
	ktime_t rq_rtt;
	unsigned int rq_retries;
	unsigned int rq_connect_cookie;
	atomic_t rq_pin;
	u32 rq_bytes_sent;
	ktime_t rq_xtime;
	int rq_ntrans;
	struct list_head rq_bc_list;
	long unsigned int rq_bc_pa_state;
	struct list_head rq_bc_pa_list;
};

typedef void (*kxdreproc_t)(struct rpc_rqst *, struct xdr_stream *, const void *);

typedef int (*kxdrdproc_t)(struct rpc_rqst *, struct xdr_stream *, void *);

struct rpc_procinfo;

struct rpc_message {
	const struct rpc_procinfo *rpc_proc;
	void *rpc_argp;
	void *rpc_resp;
	const struct cred *rpc_cred;
};

struct rpc_procinfo {
	u32 p_proc;
	kxdreproc_t p_encode;
	kxdrdproc_t p_decode;
	unsigned int p_arglen;
	unsigned int p_replen;
	unsigned int p_timer;
	u32 p_statidx;
	const char *p_name;
};

struct rpc_wait {
	struct list_head list;
	struct list_head links;
	struct list_head timer_list;
};

struct rpc_wait_queue;

struct rpc_call_ops;

struct rpc_clnt;

struct rpc_task {
	atomic_t tk_count;
	int tk_status;
	struct list_head tk_task;
	void (*tk_callback)(struct rpc_task *);
	void (*tk_action)(struct rpc_task *);
	long unsigned int tk_timeout;
	long unsigned int tk_runstate;
	struct rpc_wait_queue *tk_waitqueue;
	union {
		struct work_struct tk_work;
		struct rpc_wait tk_wait;
	} u;
	int tk_rpc_status;
	struct rpc_message tk_msg;
	void *tk_calldata;
	const struct rpc_call_ops *tk_ops;
	struct rpc_clnt *tk_client;
	struct rpc_xprt *tk_xprt;
	struct rpc_cred *tk_op_cred;
	struct rpc_rqst *tk_rqstp;
	struct workqueue_struct *tk_workqueue;
	ktime_t tk_start;
	pid_t tk_owner;
	short unsigned int tk_flags;
	short unsigned int tk_timeouts;
	short unsigned int tk_pid;
	unsigned char tk_priority: 2;
	unsigned char tk_garb_retry: 2;
	unsigned char tk_cred_retry: 2;
	unsigned char tk_rebind_retry: 2;
};

struct rpc_timer {
	struct list_head list;
	long unsigned int expires;
	struct delayed_work dwork;
};

struct rpc_wait_queue {
	spinlock_t lock;
	struct list_head tasks[4];
	unsigned char maxpriority;
	unsigned char priority;
	unsigned char nr;
	short unsigned int qlen;
	struct rpc_timer timer_list;
	const char *name;
};

struct rpc_call_ops {
	void (*rpc_call_prepare)(struct rpc_task *, void *);
	void (*rpc_call_done)(struct rpc_task *, void *);
	void (*rpc_count_stats)(struct rpc_task *, void *);
	void (*rpc_release)(void *);
};

struct rpc_iostats;

struct rpc_pipe_dir_head {
	struct list_head pdh_entries;
	struct dentry *pdh_dentry;
};

struct rpc_rtt {
	long unsigned int timeo;
	long unsigned int srtt[5];
	long unsigned int sdrtt[5];
	int ntimeouts[5];
};

struct rpc_timeout {
	long unsigned int to_initval;
	long unsigned int to_maxval;
	long unsigned int to_increment;
	unsigned int to_retries;
	unsigned char to_exponential;
};

struct rpc_xprt_switch;

struct rpc_xprt_iter_ops;

struct rpc_xprt_iter {
	struct rpc_xprt_switch *xpi_xpswitch;
	struct rpc_xprt *xpi_cursor;
	const struct rpc_xprt_iter_ops *xpi_ops;
};

struct rpc_auth;

struct rpc_stat;

struct rpc_program;

struct rpc_clnt {
	atomic_t cl_count;
	unsigned int cl_clid;
	struct list_head cl_clients;
	struct list_head cl_tasks;
	spinlock_t cl_lock;
	struct rpc_xprt *cl_xprt;
	const struct rpc_procinfo *cl_procinfo;
	u32 cl_prog;
	u32 cl_vers;
	u32 cl_maxproc;
	struct rpc_auth *cl_auth;
	struct rpc_stat *cl_stats;
	struct rpc_iostats *cl_metrics;
	unsigned int cl_softrtry: 1;
	unsigned int cl_softerr: 1;
	unsigned int cl_discrtry: 1;
	unsigned int cl_noretranstimeo: 1;
	unsigned int cl_autobind: 1;
	unsigned int cl_chatty: 1;
	struct rpc_rtt *cl_rtt;
	const struct rpc_timeout *cl_timeout;
	atomic_t cl_swapper;
	int cl_nodelen;
	char cl_nodename[65];
	struct rpc_pipe_dir_head cl_pipedir_objects;
	struct rpc_clnt *cl_parent;
	struct rpc_rtt cl_rtt_default;
	struct rpc_timeout cl_timeout_default;
	const struct rpc_program *cl_program;
	const char *cl_principal;
	struct dentry *cl_debugfs;
	union {
		struct rpc_xprt_iter cl_xpi;
		struct work_struct cl_work;
	};
	const struct cred *cl_cred;
};

struct svc_xprt;

struct svc_serv;

struct rpc_xprt_ops;

struct rpc_xprt {
	struct kref kref;
	const struct rpc_xprt_ops *ops;
	const struct rpc_timeout *timeout;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	int prot;
	long unsigned int cong;
	long unsigned int cwnd;
	size_t max_payload;
	struct rpc_wait_queue binding;
	struct rpc_wait_queue sending;
	struct rpc_wait_queue pending;
	struct rpc_wait_queue backlog;
	struct list_head free;
	unsigned int max_reqs;
	unsigned int min_reqs;
	unsigned int num_reqs;
	long unsigned int state;
	unsigned char resvport: 1;
	unsigned char reuseport: 1;
	atomic_t swapper;
	unsigned int bind_index;
	struct list_head xprt_switch;
	long unsigned int bind_timeout;
	long unsigned int reestablish_timeout;
	unsigned int connect_cookie;
	struct work_struct task_cleanup;
	struct timer_list timer;
	long unsigned int last_used;
	long unsigned int idle_timeout;
	long unsigned int connect_timeout;
	long unsigned int max_reconnect_timeout;
	atomic_long_t queuelen;
	spinlock_t transport_lock;
	spinlock_t reserve_lock;
	spinlock_t queue_lock;
	u32 xid;
	struct rpc_task *snd_task;
	struct list_head xmit_queue;
	atomic_long_t xmit_queuelen;
	struct svc_xprt *bc_xprt;
	struct svc_serv *bc_serv;
	unsigned int bc_alloc_max;
	unsigned int bc_alloc_count;
	atomic_t bc_slot_count;
	spinlock_t bc_pa_lock;
	struct list_head bc_pa_list;
	struct rb_root recv_queue;
	struct {
		long unsigned int bind_count;
		long unsigned int connect_count;
		long unsigned int connect_start;
		long unsigned int connect_time;
		long unsigned int sends;
		long unsigned int recvs;
		long unsigned int bad_xids;
		long unsigned int max_slots;
		long long unsigned int req_u;
		long long unsigned int bklog_u;
		long long unsigned int sending_u;
		long long unsigned int pending_u;
	} stat;
	struct net *xprt_net;
	const char *servername;
	const char *address_strings[6];
	struct dentry *debugfs;
	atomic_t inject_disconnect;
	struct callback_head rcu;
};

struct rpc_credops;

struct rpc_cred {
	struct hlist_node cr_hash;
	struct list_head cr_lru;
	struct callback_head cr_rcu;
	struct rpc_auth *cr_auth;
	const struct rpc_credops *cr_ops;
	long unsigned int cr_expire;
	long unsigned int cr_flags;
	refcount_t cr_count;
	const struct cred *cr_cred;
};

typedef u32 rpc_authflavor_t;

struct flow_dissector {
	unsigned int used_keys;
	short unsigned int offset[28];
};

struct flowi_tunnel {
	__be64 tun_id;
};

struct flowi_common {
	int flowic_oif;
	int flowic_iif;
	__u32 flowic_mark;
	__u8 flowic_tos;
	__u8 flowic_scope;
	__u8 flowic_proto;
	__u8 flowic_flags;
	__u32 flowic_secid;
	kuid_t flowic_uid;
	struct flowi_tunnel flowic_tun_key;
	__u32 flowic_multipath_hash;
};

union flowi_uli {
	struct {
		__be16 dport;
		__be16 sport;
	} ports;
	struct {
		__u8 type;
		__u8 code;
	} icmpt;
	struct {
		__le16 dport;
		__le16 sport;
	} dnports;
	__be32 gre_key;
	struct {
		__u8 type;
	} mht;
};

struct flowi4 {
	struct flowi_common __fl_common;
	__be32 saddr;
	__be32 daddr;
	union flowi_uli uli;
};

struct flowi6 {
	struct flowi_common __fl_common;
	struct in6_addr daddr;
	struct in6_addr saddr;
	__be32 flowlabel;
	union flowi_uli uli;
	__u32 mp_hash;
};

struct flowidn {
	struct flowi_common __fl_common;
	__le16 daddr;
	__le16 saddr;
	union flowi_uli uli;
};

struct flowi {
	union {
		struct flowi_common __fl_common;
		struct flowi4 ip4;
		struct flowi6 ip6;
		struct flowidn dn;
	} u;
};

struct ipstats_mib {
	u64 mibs[37];
	struct u64_stats_sync syncp;
};

struct icmp_mib {
	long unsigned int mibs[28];
};

struct icmpmsg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6_mib {
	long unsigned int mibs[6];
};

struct icmpv6_mib_device {
	atomic_long_t mibs[6];
};

struct icmpv6msg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6msg_mib_device {
	atomic_long_t mibs[512];
};

struct tcp_mib {
	long unsigned int mibs[16];
};

struct udp_mib {
	long unsigned int mibs[10];
};

struct linux_mib {
	long unsigned int mibs[124];
};

struct linux_xfrm_mib {
	long unsigned int mibs[29];
};

struct linux_tls_mib {
	long unsigned int mibs[11];
};

struct inet_frags;

struct fqdir {
	long int high_thresh;
	long int low_thresh;
	int timeout;
	int max_dist;
	struct inet_frags *f;
	struct net *net;
	bool dead;
	long: 56;
	long: 64;
	long: 64;
	struct rhashtable rhashtable;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t mem;
	struct work_struct destroy_work;
	struct llist_node free_list;
	long: 64;
	long: 64;
};

struct inet_frag_queue;

struct inet_frags {
	unsigned int qsize;
	void (*constructor)(struct inet_frag_queue *, const void *);
	void (*destructor)(struct inet_frag_queue *);
	void (*frag_expire)(struct timer_list *);
	struct kmem_cache *frags_cachep;
	const char *frags_cache_name;
	struct rhashtable_params rhash_params;
	refcount_t refcnt;
	struct completion completion;
};

struct frag_v4_compare_key {
	__be32 saddr;
	__be32 daddr;
	u32 user;
	u32 vif;
	__be16 id;
	u16 protocol;
};

struct frag_v6_compare_key {
	struct in6_addr saddr;
	struct in6_addr daddr;
	u32 user;
	__be32 id;
	u32 iif;
};

struct inet_frag_queue {
	struct rhash_head node;
	union {
		struct frag_v4_compare_key v4;
		struct frag_v6_compare_key v6;
	} key;
	struct timer_list timer;
	spinlock_t lock;
	refcount_t refcnt;
	struct rb_root rb_fragments;
	struct sk_buff *fragments_tail;
	struct sk_buff *last_run_head;
	ktime_t stamp;
	int len;
	int meat;
	__u8 flags;
	u16 max_size;
	struct fqdir *fqdir;
	struct callback_head rcu;
};

struct fib_rule;

struct fib_lookup_arg;

struct fib_rule_hdr;

struct nlattr;

struct netlink_ext_ack;

struct nla_policy;

struct fib_rules_ops {
	int family;
	struct list_head list;
	int rule_size;
	int addr_size;
	int unresolved_rules;
	int nr_goto_rules;
	unsigned int fib_rules_seq;
	int (*action)(struct fib_rule *, struct flowi *, int, struct fib_lookup_arg *);
	bool (*suppress)(struct fib_rule *, int, struct fib_lookup_arg *);
	int (*match)(struct fib_rule *, struct flowi *, int);
	int (*configure)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *, struct nlattr **, struct netlink_ext_ack *);
	int (*delete)(struct fib_rule *);
	int (*compare)(struct fib_rule *, struct fib_rule_hdr *, struct nlattr **);
	int (*fill)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *);
	size_t (*nlmsg_payload)(struct fib_rule *);
	void (*flush_cache)(struct fib_rules_ops *);
	int nlgroup;
	const struct nla_policy *policy;
	struct list_head rules_list;
	struct module *owner;
	struct net *fro_net;
	struct callback_head rcu;
};

enum tcp_ca_event {
	CA_EVENT_TX_START = 0,
	CA_EVENT_CWND_RESTART = 1,
	CA_EVENT_COMPLETE_CWR = 2,
	CA_EVENT_LOSS = 3,
	CA_EVENT_ECN_NO_CE = 4,
	CA_EVENT_ECN_IS_CE = 5,
};

struct ack_sample;

struct rate_sample;

union tcp_cc_info;

struct tcp_congestion_ops {
	u32 (*ssthresh)(struct sock *);
	void (*cong_avoid)(struct sock *, u32, u32);
	void (*set_state)(struct sock *, u8);
	void (*cwnd_event)(struct sock *, enum tcp_ca_event);
	void (*in_ack_event)(struct sock *, u32);
	void (*pkts_acked)(struct sock *, const struct ack_sample *);
	u32 (*min_tso_segs)(struct sock *);
	void (*cong_control)(struct sock *, const struct rate_sample *);
	u32 (*undo_cwnd)(struct sock *);
	u32 (*sndbuf_expand)(struct sock *);
	size_t (*get_info)(struct sock *, u32, int *, union tcp_cc_info *);
	char name[16];
	struct module *owner;
	struct list_head list;
	u32 key;
	u32 flags;
	void (*init)(struct sock *);
	void (*release)(struct sock *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct fib_notifier_ops {
	int family;
	struct list_head list;
	unsigned int (*fib_seq_read)(struct net *);
	int (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *);
	struct module *owner;
	struct callback_head rcu;
};

struct xfrm_state;

struct lwtunnel_state;

struct dst_entry {
	struct net_device *dev;
	struct dst_ops *ops;
	long unsigned int _metrics;
	long unsigned int expires;
	struct xfrm_state *xfrm;
	int (*input)(struct sk_buff *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	short unsigned int flags;
	short int obsolete;
	short unsigned int header_len;
	short unsigned int trailer_len;
	atomic_t __refcnt;
	int __use;
	long unsigned int lastuse;
	struct lwtunnel_state *lwtstate;
	struct callback_head callback_head;
	short int error;
	short int __pad;
	__u32 tclassid;
};

struct hh_cache {
	unsigned int hh_len;
	seqlock_t hh_lock;
	long unsigned int hh_data[16];
};

struct neigh_table;

struct neigh_parms;

struct neigh_ops;

struct neighbour {
	struct neighbour *next;
	struct neigh_table *tbl;
	struct neigh_parms *parms;
	long unsigned int confirmed;
	long unsigned int updated;
	rwlock_t lock;
	refcount_t refcnt;
	unsigned int arp_queue_len_bytes;
	struct sk_buff_head arp_queue;
	struct timer_list timer;
	long unsigned int used;
	atomic_t probes;
	__u8 flags;
	__u8 nud_state;
	__u8 type;
	__u8 dead;
	u8 protocol;
	seqlock_t ha_lock;
	int: 32;
	unsigned char ha[32];
	struct hh_cache hh;
	int (*output)(struct neighbour *, struct sk_buff *);
	const struct neigh_ops *ops;
	struct list_head gc_list;
	struct callback_head rcu;
	struct net_device *dev;
	u8 primary_key[0];
};

struct ipv6_stable_secret {
	bool initialized;
	struct in6_addr secret;
};

struct ipv6_devconf {
	__s32 forwarding;
	__s32 hop_limit;
	__s32 mtu6;
	__s32 accept_ra;
	__s32 accept_redirects;
	__s32 autoconf;
	__s32 dad_transmits;
	__s32 rtr_solicits;
	__s32 rtr_solicit_interval;
	__s32 rtr_solicit_max_interval;
	__s32 rtr_solicit_delay;
	__s32 force_mld_version;
	__s32 mldv1_unsolicited_report_interval;
	__s32 mldv2_unsolicited_report_interval;
	__s32 use_tempaddr;
	__s32 temp_valid_lft;
	__s32 temp_prefered_lft;
	__s32 regen_max_retry;
	__s32 max_desync_factor;
	__s32 max_addresses;
	__s32 accept_ra_defrtr;
	__u32 ra_defrtr_metric;
	__s32 accept_ra_min_hop_limit;
	__s32 accept_ra_pinfo;
	__s32 ignore_routes_with_linkdown;
	__s32 accept_ra_rtr_pref;
	__s32 rtr_probe_interval;
	__s32 accept_ra_rt_info_min_plen;
	__s32 accept_ra_rt_info_max_plen;
	__s32 proxy_ndp;
	__s32 accept_source_route;
	__s32 accept_ra_from_local;
	__s32 mc_forwarding;
	__s32 disable_ipv6;
	__s32 drop_unicast_in_l2_multicast;
	__s32 accept_dad;
	__s32 force_tllao;
	__s32 ndisc_notify;
	__s32 suppress_frag_ndisc;
	__s32 accept_ra_mtu;
	__s32 drop_unsolicited_na;
	struct ipv6_stable_secret stable_secret;
	__s32 use_oif_addrs_only;
	__s32 keep_addr_on_down;
	__s32 seg6_enabled;
	__s32 seg6_require_hmac;
	__u32 enhanced_dad;
	__u32 addr_gen_mode;
	__s32 disable_policy;
	__s32 ndisc_tclass;
	__s32 rpl_seg_enabled;
	struct ctl_table_header *sysctl_header;
};

struct nf_queue_entry;

struct nf_queue_handler {
	int (*outfn)(struct nf_queue_entry *, unsigned int);
	void (*nf_hook_drop)(struct net *);
};

enum nf_log_type {
	NF_LOG_TYPE_LOG = 0,
	NF_LOG_TYPE_ULOG = 1,
	NF_LOG_TYPE_MAX = 2,
};

typedef u8 u_int8_t;

struct nf_loginfo;

typedef void nf_logfn(struct net *, u_int8_t, unsigned int, const struct sk_buff *, const struct net_device *, const struct net_device *, const struct nf_loginfo *, const char *);

struct nf_logger {
	char *name;
	enum nf_log_type type;
	nf_logfn *logfn;
	struct module *me;
};

struct hlist_nulls_head {
	struct hlist_nulls_node *first;
};

struct ip_conntrack_stat {
	unsigned int found;
	unsigned int invalid;
	unsigned int insert;
	unsigned int insert_failed;
	unsigned int clash_resolve;
	unsigned int drop;
	unsigned int early_drop;
	unsigned int error;
	unsigned int expect_new;
	unsigned int expect_create;
	unsigned int expect_delete;
	unsigned int search_restart;
};

struct ct_pcpu {
	spinlock_t lock;
	struct hlist_nulls_head unconfirmed;
	struct hlist_nulls_head dying;
};

typedef struct {
	union {
		void *kernel;
		void *user;
	};
	bool is_kernel: 1;
} sockptr_t;

typedef enum {
	SS_FREE = 0,
	SS_UNCONNECTED = 1,
	SS_CONNECTING = 2,
	SS_CONNECTED = 3,
	SS_DISCONNECTING = 4,
} socket_state;

struct socket_wq {
	wait_queue_head_t wait;
	struct fasync_struct *fasync_list;
	long unsigned int flags;
	struct callback_head rcu;
	long: 64;
};

struct proto_ops;

struct socket {
	socket_state state;
	short int type;
	long unsigned int flags;
	struct file *file;
	struct sock *sk;
	const struct proto_ops *ops;
	long: 64;
	long: 64;
	long: 64;
	struct socket_wq wq;
};

typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *, unsigned int, size_t);

struct proto_ops {
	int family;
	struct module *owner;
	int (*release)(struct socket *);
	int (*bind)(struct socket *, struct sockaddr *, int);
	int (*connect)(struct socket *, struct sockaddr *, int, int);
	int (*socketpair)(struct socket *, struct socket *);
	int (*accept)(struct socket *, struct socket *, int, bool);
	int (*getname)(struct socket *, struct sockaddr *, int);
	__poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *);
	int (*ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*gettstamp)(struct socket *, void *, bool, bool);
	int (*listen)(struct socket *, int);
	int (*shutdown)(struct socket *, int);
	int (*setsockopt)(struct socket *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct socket *, int, int, char *, int *);
	void (*show_fdinfo)(struct seq_file *, struct socket *);
	int (*sendmsg)(struct socket *, struct msghdr *, size_t);
	int (*recvmsg)(struct socket *, struct msghdr *, size_t, int);
	int (*mmap)(struct file *, struct socket *, struct vm_area_struct *);
	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
	ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*set_peek_off)(struct sock *, int);
	int (*peek_len)(struct socket *);
	int (*read_sock)(struct sock *, read_descriptor_t *, sk_read_actor_t);
	int (*sendpage_locked)(struct sock *, struct page *, int, size_t, int);
	int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t);
	int (*set_rcvlowat)(struct sock *, int);
};

struct pipe_buf_operations;

struct pipe_buffer {
	struct page *page;
	unsigned int offset;
	unsigned int len;
	const struct pipe_buf_operations *ops;
	unsigned int flags;
	long unsigned int private;
};

struct pipe_buf_operations {
	int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);
	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};

struct skb_ext {
	refcount_t refcnt;
	u8 offset[4];
	u8 chunks;
	long: 56;
	char data[0];
};

struct skb_checksum_ops {
	__wsum (*update)(const void *, int, __wsum);
	__wsum (*combine)(__wsum, __wsum, int, int);
};

struct pernet_operations {
	struct list_head list;
	int (*init)(struct net *);
	void (*pre_exit)(struct net *);
	void (*exit)(struct net *);
	void (*exit_batch)(struct list_head *);
	unsigned int *id;
	size_t size;
};

struct auth_cred {
	const struct cred *cred;
	const char *principal;
};

struct rpc_cred_cache;

struct rpc_authops;

struct rpc_auth {
	unsigned int au_cslack;
	unsigned int au_rslack;
	unsigned int au_verfsize;
	unsigned int au_ralign;
	long unsigned int au_flags;
	const struct rpc_authops *au_ops;
	rpc_authflavor_t au_flavor;
	refcount_t au_count;
	struct rpc_cred_cache *au_credcache;
};

struct rpc_credops {
	const char *cr_name;
	int (*cr_init)(struct rpc_auth *, struct rpc_cred *);
	void (*crdestroy)(struct rpc_cred *);
	int (*crmatch)(struct auth_cred *, struct rpc_cred *, int);
	int (*crmarshal)(struct rpc_task *, struct xdr_stream *);
	int (*crrefresh)(struct rpc_task *);
	int (*crvalidate)(struct rpc_task *, struct xdr_stream *);
	int (*crwrap_req)(struct rpc_task *, struct xdr_stream *);
	int (*crunwrap_resp)(struct rpc_task *, struct xdr_stream *);
	int (*crkey_timeout)(struct rpc_cred *);
	char * (*crstringify_acceptor)(struct rpc_cred *);
	bool (*crneed_reencode)(struct rpc_task *);
};

struct rpc_auth_create_args;

struct rpcsec_gss_info;

struct rpc_authops {
	struct module *owner;
	rpc_authflavor_t au_flavor;
	char *au_name;
	struct rpc_auth * (*create)(const struct rpc_auth_create_args *, struct rpc_clnt *);
	void (*destroy)(struct rpc_auth *);
	int (*hash_cred)(struct auth_cred *, unsigned int);
	struct rpc_cred * (*lookup_cred)(struct rpc_auth *, struct auth_cred *, int);
	struct rpc_cred * (*crcreate)(struct rpc_auth *, struct auth_cred *, int, gfp_t);
	rpc_authflavor_t (*info2flavor)(struct rpcsec_gss_info *);
	int (*flavor2info)(rpc_authflavor_t, struct rpcsec_gss_info *);
	int (*key_timeout)(struct rpc_auth *, struct rpc_cred *);
};

struct rpc_auth_create_args {
	rpc_authflavor_t pseudoflavor;
	const char *target_name;
};

struct rpcsec_gss_oid {
	unsigned int len;
	u8 data[32];
};

struct rpcsec_gss_info {
	struct rpcsec_gss_oid oid;
	u32 qop;
	u32 service;
};

struct rpc_xprt_ops {
	void (*set_buffer_size)(struct rpc_xprt *, size_t, size_t);
	int (*reserve_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*release_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*alloc_slot)(struct rpc_xprt *, struct rpc_task *);
	void (*free_slot)(struct rpc_xprt *, struct rpc_rqst *);
	void (*rpcbind)(struct rpc_task *);
	void (*set_port)(struct rpc_xprt *, short unsigned int);
	void (*connect)(struct rpc_xprt *, struct rpc_task *);
	int (*buf_alloc)(struct rpc_task *);
	void (*buf_free)(struct rpc_task *);
	void (*prepare_request)(struct rpc_rqst *);
	int (*send_request)(struct rpc_rqst *);
	void (*wait_for_reply_request)(struct rpc_task *);
	void (*timer)(struct rpc_xprt *, struct rpc_task *);
	void (*release_request)(struct rpc_task *);
	void (*close)(struct rpc_xprt *);
	void (*destroy)(struct rpc_xprt *);
	void (*set_connect_timeout)(struct rpc_xprt *, long unsigned int, long unsigned int);
	void (*print_stats)(struct rpc_xprt *, struct seq_file *);
	int (*enable_swap)(struct rpc_xprt *);
	void (*disable_swap)(struct rpc_xprt *);
	void (*inject_disconnect)(struct rpc_xprt *);
	int (*bc_setup)(struct rpc_xprt *, unsigned int);
	size_t (*bc_maxpayload)(struct rpc_xprt *);
	unsigned int (*bc_num_slots)(struct rpc_xprt *);
	void (*bc_free_rqst)(struct rpc_rqst *);
	void (*bc_destroy)(struct rpc_xprt *, unsigned int);
};

struct rpc_xprt_switch {
	spinlock_t xps_lock;
	struct kref xps_kref;
	unsigned int xps_nxprts;
	unsigned int xps_nactive;
	atomic_long_t xps_queuelen;
	struct list_head xps_xprt_list;
	struct net *xps_net;
	const struct rpc_xprt_iter_ops *xps_iter_ops;
	struct callback_head xps_rcu;
};

struct rpc_stat {
	const struct rpc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int netreconn;
	unsigned int rpccnt;
	unsigned int rpcretrans;
	unsigned int rpcauthrefresh;
	unsigned int rpcgarbage;
};

struct rpc_version;

struct rpc_program {
	const char *name;
	u32 number;
	unsigned int nrvers;
	const struct rpc_version **version;
	struct rpc_stat *stats;
	const char *pipe_dir_name;
};

struct ipv6_params {
	__s32 disable_ipv6;
	__s32 autoconf;
};

struct dql {
	unsigned int num_queued;
	unsigned int adj_limit;
	unsigned int last_obj_cnt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int limit;
	unsigned int num_completed;
	unsigned int prev_ovlimit;
	unsigned int prev_num_queued;
	unsigned int prev_last_obj_cnt;
	unsigned int lowest_slack;
	long unsigned int slack_start_time;
	unsigned int max_limit;
	unsigned int min_limit;
	unsigned int slack_hold_time;
	long: 32;
	long: 64;
	long: 64;
};

struct ieee_ets {
	__u8 willing;
	__u8 ets_cap;
	__u8 cbs;
	__u8 tc_tx_bw[8];
	__u8 tc_rx_bw[8];
	__u8 tc_tsa[8];
	__u8 prio_tc[8];
	__u8 tc_reco_bw[8];
	__u8 tc_reco_tsa[8];
	__u8 reco_prio_tc[8];
};

struct ieee_maxrate {
	__u64 tc_maxrate[8];
};

struct ieee_qcn {
	__u8 rpg_enable[8];
	__u32 rppp_max_rps[8];
	__u32 rpg_time_reset[8];
	__u32 rpg_byte_reset[8];
	__u32 rpg_threshold[8];
	__u32 rpg_max_rate[8];
	__u32 rpg_ai_rate[8];
	__u32 rpg_hai_rate[8];
	__u32 rpg_gd[8];
	__u32 rpg_min_dec_fac[8];
	__u32 rpg_min_rate[8];
	__u32 cndd_state_machine[8];
};

struct ieee_qcn_stats {
	__u64 rppp_rp_centiseconds[8];
	__u32 rppp_created_rps[8];
};

struct ieee_pfc {
	__u8 pfc_cap;
	__u8 pfc_en;
	__u8 mbc;
	__u16 delay;
	__u64 requests[8];
	__u64 indications[8];
};

struct dcbnl_buffer {
	__u8 prio2buffer[8];
	__u32 buffer_size[8];
	__u32 total_size;
};

struct cee_pg {
	__u8 willing;
	__u8 error;
	__u8 pg_en;
	__u8 tcs_supported;
	__u8 pg_bw[8];
	__u8 prio_pg[8];
};

struct cee_pfc {
	__u8 willing;
	__u8 error;
	__u8 pfc_en;
	__u8 tcs_supported;
};

struct dcb_app {
	__u8 selector;
	__u8 priority;
	__u16 protocol;
};

struct dcb_peer_app_info {
	__u8 willing;
	__u8 error;
};

struct dcbnl_rtnl_ops {
	int (*ieee_getets)(struct net_device *, struct ieee_ets *);
	int (*ieee_setets)(struct net_device *, struct ieee_ets *);
	int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *);
	int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *);
	int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *);
	int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *);
	int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *);
	int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *);
	int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *);
	int (*ieee_getapp)(struct net_device *, struct dcb_app *);
	int (*ieee_setapp)(struct net_device *, struct dcb_app *);
	int (*ieee_delapp)(struct net_device *, struct dcb_app *);
	int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *);
	int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *);
	u8 (*getstate)(struct net_device *);
	u8 (*setstate)(struct net_device *, u8);
	void (*getpermhwaddr)(struct net_device *, u8 *);
	void (*setpgtccfgtx)(struct net_device *, int, u8, u8, u8, u8);
	void (*setpgbwgcfgtx)(struct net_device *, int, u8);
	void (*setpgtccfgrx)(struct net_device *, int, u8, u8, u8, u8);
	void (*setpgbwgcfgrx)(struct net_device *, int, u8);
	void (*getpgtccfgtx)(struct net_device *, int, u8 *, u8 *, u8 *, u8 *);
	void (*getpgbwgcfgtx)(struct net_device *, int, u8 *);
	void (*getpgtccfgrx)(struct net_device *, int, u8 *, u8 *, u8 *, u8 *);
	void (*getpgbwgcfgrx)(struct net_device *, int, u8 *);
	void (*setpfccfg)(struct net_device *, int, u8);
	void (*getpfccfg)(struct net_device *, int, u8 *);
	u8 (*setall)(struct net_device *);
	u8 (*getcap)(struct net_device *, int, u8 *);
	int (*getnumtcs)(struct net_device *, int, u8 *);
	int (*setnumtcs)(struct net_device *, int, u8);
	u8 (*getpfcstate)(struct net_device *);
	void (*setpfcstate)(struct net_device *, u8);
	void (*getbcncfg)(struct net_device *, int, u32 *);
	void (*setbcncfg)(struct net_device *, int, u32);
	void (*getbcnrp)(struct net_device *, int, u8 *);
	void (*setbcnrp)(struct net_device *, int, u8);
	int (*setapp)(struct net_device *, u8, u16, u8);
	int (*getapp)(struct net_device *, u8, u16);
	u8 (*getfeatcfg)(struct net_device *, int, u8 *);
	u8 (*setfeatcfg)(struct net_device *, int, u8);
	u8 (*getdcbx)(struct net_device *);
	u8 (*setdcbx)(struct net_device *, u8);
	int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *);
	int (*peer_getapptable)(struct net_device *, struct dcb_app *);
	int (*cee_peer_getpg)(struct net_device *, struct cee_pg *);
	int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *);
	int (*dcbnl_getbuffer)(struct net_device *, struct dcbnl_buffer *);
	int (*dcbnl_setbuffer)(struct net_device *, struct dcbnl_buffer *);
};

struct netprio_map {
	struct callback_head rcu;
	u32 priomap_len;
	u32 priomap[0];
};

struct xdp_mem_info {
	u32 type;
	u32 id;
};

struct xdp_rxq_info {
	struct net_device *dev;
	u32 queue_index;
	u32 reg_state;
	struct xdp_mem_info mem;
	unsigned int napi_id;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_frame {
	void *data;
	u16 len;
	u16 headroom;
	u32 metasize: 8;
	u32 frame_sz: 24;
	struct xdp_mem_info mem;
	struct net_device *dev_rx;
};

struct nlmsghdr {
	__u32 nlmsg_len;
	__u16 nlmsg_type;
	__u16 nlmsg_flags;
	__u32 nlmsg_seq;
	__u32 nlmsg_pid;
};

struct nlattr {
	__u16 nla_len;
	__u16 nla_type;
};

struct netlink_ext_ack {
	const char *_msg;
	const struct nlattr *bad_attr;
	const struct nla_policy *policy;
	u8 cookie[20];
	u8 cookie_len;
};

struct netlink_range_validation;

struct netlink_range_validation_signed;

struct nla_policy {
	u8 type;
	u8 validation_type;
	u16 len;
	union {
		const u32 bitfield32_valid;
		const u32 mask;
		const char *reject_message;
		const struct nla_policy *nested_policy;
		struct netlink_range_validation *range;
		struct netlink_range_validation_signed *range_signed;
		struct {
			s16 min;
			s16 max;
		};
		int (*validate)(const struct nlattr *, struct netlink_ext_ack *);
		u16 strict_start_type;
	};
};

struct netlink_callback {
	struct sk_buff *skb;
	const struct nlmsghdr *nlh;
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	struct netlink_ext_ack *extack;
	u16 family;
	u16 answer_flags;
	u32 min_dump_alloc;
	unsigned int prev_seq;
	unsigned int seq;
	bool strict_check;
	union {
		u8 ctx[48];
		long int args[6];
	};
};

struct ndmsg {
	__u8 ndm_family;
	__u8 ndm_pad1;
	__u16 ndm_pad2;
	__s32 ndm_ifindex;
	__u16 ndm_state;
	__u8 ndm_flags;
	__u8 ndm_type;
};

struct rtnl_link_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
	__u64 collisions;
	__u64 rx_length_errors;
	__u64 rx_over_errors;
	__u64 rx_crc_errors;
	__u64 rx_frame_errors;
	__u64 rx_fifo_errors;
	__u64 rx_missed_errors;
	__u64 tx_aborted_errors;
	__u64 tx_carrier_errors;
	__u64 tx_fifo_errors;
	__u64 tx_heartbeat_errors;
	__u64 tx_window_errors;
	__u64 rx_compressed;
	__u64 tx_compressed;
	__u64 rx_nohandler;
};

struct ifla_vf_guid {
	__u32 vf;
	__u64 guid;
};

struct ifla_vf_stats {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 broadcast;
	__u64 multicast;
	__u64 rx_dropped;
	__u64 tx_dropped;
};

struct ifla_vf_info {
	__u32 vf;
	__u8 mac[32];
	__u32 vlan;
	__u32 qos;
	__u32 spoofchk;
	__u32 linkstate;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
	__u32 rss_query_en;
	__u32 trusted;
	__be16 vlan_proto;
};

struct tc_stats {
	__u64 bytes;
	__u32 packets;
	__u32 drops;
	__u32 overlimits;
	__u32 bps;
	__u32 pps;
	__u32 qlen;
	__u32 backlog;
};

struct tc_sizespec {
	unsigned char cell_log;
	unsigned char size_log;
	short int cell_align;
	int overhead;
	unsigned int linklayer;
	unsigned int mpu;
	unsigned int mtu;
	unsigned int tsize;
};

enum netdev_tx {
	__NETDEV_TX_MIN = 2147483648,
	NETDEV_TX_OK = 0,
	NETDEV_TX_BUSY = 16,
};

typedef enum netdev_tx netdev_tx_t;

struct header_ops {
	int (*create)(struct sk_buff *, struct net_device *, short unsigned int, const void *, const void *, unsigned int);
	int (*parse)(const struct sk_buff *, unsigned char *);
	int (*cache)(const struct neighbour *, struct hh_cache *, __be16);
	void (*cache_update)(struct hh_cache *, const struct net_device *, const unsigned char *);
	bool (*validate)(const char *, unsigned int);
	__be16 (*parse_protocol)(const struct sk_buff *);
};

struct gro_list {
	struct list_head list;
	int count;
};

struct napi_struct {
	struct list_head poll_list;
	long unsigned int state;
	int weight;
	int defer_hard_irqs_count;
	long unsigned int gro_bitmask;
	int (*poll)(struct napi_struct *, int);
	int poll_owner;
	struct net_device *dev;
	struct gro_list gro_hash[8];
	struct sk_buff *skb;
	struct list_head rx_list;
	int rx_count;
	struct hrtimer timer;
	struct list_head dev_list;
	struct hlist_node napi_hash_node;
	unsigned int napi_id;
	struct task_struct *thread;
};

struct xsk_buff_pool;

struct netdev_queue {
	struct net_device *dev;
	struct Qdisc *qdisc;
	struct Qdisc *qdisc_sleeping;
	struct kobject kobj;
	int numa_node;
	long unsigned int tx_maxrate;
	long unsigned int trans_timeout;
	struct net_device *sb_dev;
	struct xsk_buff_pool *pool;
	spinlock_t _xmit_lock;
	int xmit_lock_owner;
	long unsigned int trans_start;
	long unsigned int state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dql dql;
};

struct qdisc_skb_head {
	struct sk_buff *head;
	struct sk_buff *tail;
	__u32 qlen;
	spinlock_t lock;
};

struct gnet_stats_basic_packed {
	__u64 bytes;
	__u64 packets;
};

struct gnet_stats_queue {
	__u32 qlen;
	__u32 backlog;
	__u32 drops;
	__u32 requeues;
	__u32 overlimits;
};

struct Qdisc_ops;

struct qdisc_size_table;

struct net_rate_estimator;

struct gnet_stats_basic_cpu;

struct Qdisc {
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	unsigned int flags;
	u32 limit;
	const struct Qdisc_ops *ops;
	struct qdisc_size_table *stab;
	struct hlist_node hash;
	u32 handle;
	u32 parent;
	struct netdev_queue *dev_queue;
	struct net_rate_estimator *rate_est;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	int pad;
	refcount_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head gso_skb;
	struct qdisc_skb_head q;
	struct gnet_stats_basic_packed bstats;
	seqcount_t running;
	struct gnet_stats_queue qstats;
	long unsigned int state;
	struct Qdisc *next_sched;
	struct sk_buff_head skb_bad_txq;
	spinlock_t busylock;
	spinlock_t seqlock;
	bool empty;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long int privdata[0];
};

struct rps_map {
	unsigned int len;
	struct callback_head rcu;
	u16 cpus[0];
};

struct rps_dev_flow {
	u16 cpu;
	u16 filter;
	unsigned int last_qtail;
};

struct rps_dev_flow_table {
	unsigned int mask;
	struct callback_head rcu;
	struct rps_dev_flow flows[0];
};

struct rps_sock_flow_table {
	u32 mask;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 ents[0];
};

struct netdev_rx_queue {
	struct rps_map *rps_map;
	struct rps_dev_flow_table *rps_flow_table;
	struct kobject kobj;
	struct net_device *dev;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	struct xsk_buff_pool *pool;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xps_map {
	unsigned int len;
	unsigned int alloc_len;
	struct callback_head rcu;
	u16 queues[0];
};

struct xps_dev_maps {
	struct callback_head rcu;
	unsigned int nr_ids;
	s16 num_tc;
	struct xps_map *attr_map[0];
};

struct netdev_fcoe_hbainfo {
	char manufacturer[64];
	char serial_number[64];
	char hardware_version[64];
	char driver_version[64];
	char optionrom_version[64];
	char firmware_version[64];
	char model[256];
	char model_description[256];
};

struct netdev_phys_item_id {
	unsigned char id[32];
	unsigned char id_len;
};

enum net_device_path_type {
	DEV_PATH_ETHERNET = 0,
	DEV_PATH_VLAN = 1,
	DEV_PATH_BRIDGE = 2,
	DEV_PATH_PPPOE = 3,
	DEV_PATH_DSA = 4,
};

struct net_device_path {
	enum net_device_path_type type;
	const struct net_device *dev;
	union {
		struct {
			u16 id;
			__be16 proto;
			u8 h_dest[6];
		} encap;
		struct {
			enum {
				DEV_PATH_BR_VLAN_KEEP = 0,
				DEV_PATH_BR_VLAN_TAG = 1,
				DEV_PATH_BR_VLAN_UNTAG = 2,
				DEV_PATH_BR_VLAN_UNTAG_HW = 3,
			} vlan_mode;
			u16 vlan_id;
			__be16 vlan_proto;
		} bridge;
		struct {
			int port;
			u16 proto;
		} dsa;
	};
};

struct net_device_path_ctx {
	const struct net_device *dev;
	const u8 *daddr;
	int num_vlans;
	struct {
		u16 id;
		__be16 proto;
	} vlan[2];
};

enum tc_setup_type {
	TC_SETUP_QDISC_MQPRIO = 0,
	TC_SETUP_CLSU32 = 1,
	TC_SETUP_CLSFLOWER = 2,
	TC_SETUP_CLSMATCHALL = 3,
	TC_SETUP_CLSBPF = 4,
	TC_SETUP_BLOCK = 5,
	TC_SETUP_QDISC_CBS = 6,
	TC_SETUP_QDISC_RED = 7,
	TC_SETUP_QDISC_PRIO = 8,
	TC_SETUP_QDISC_MQ = 9,
	TC_SETUP_QDISC_ETF = 10,
	TC_SETUP_ROOT_QDISC = 11,
	TC_SETUP_QDISC_GRED = 12,
	TC_SETUP_QDISC_TAPRIO = 13,
	TC_SETUP_FT = 14,
	TC_SETUP_QDISC_ETS = 15,
	TC_SETUP_QDISC_TBF = 16,
	TC_SETUP_QDISC_FIFO = 17,
	TC_SETUP_QDISC_HTB = 18,
};

enum bpf_netdev_command {
	XDP_SETUP_PROG = 0,
	XDP_SETUP_PROG_HW = 1,
	BPF_OFFLOAD_MAP_ALLOC = 2,
	BPF_OFFLOAD_MAP_FREE = 3,
	XDP_SETUP_XSK_POOL = 4,
};

struct netdev_bpf {
	enum bpf_netdev_command command;
	union {
		struct {
			u32 flags;
			struct bpf_prog *prog;
			struct netlink_ext_ack *extack;
		};
		struct {
			struct bpf_offloaded_map *offmap;
		};
		struct {
			struct xsk_buff_pool *pool;
			u16 queue_id;
		} xsk;
	};
};

struct xfrmdev_ops {
	int (*xdo_dev_state_add)(struct xfrm_state *);
	void (*xdo_dev_state_delete)(struct xfrm_state *);
	void (*xdo_dev_state_free)(struct xfrm_state *);
	bool (*xdo_dev_offload_ok)(struct sk_buff *, struct xfrm_state *);
	void (*xdo_dev_state_advance_esn)(struct xfrm_state *);
};

struct dev_ifalias {
	struct callback_head rcuhead;
	char ifalias[0];
};

struct netdev_name_node {
	struct hlist_node hlist;
	struct list_head list;
	struct net_device *dev;
	const char *name;
};

struct devlink_port;

struct ip_tunnel_parm;

struct net_device_ops {
	int (*ndo_init)(struct net_device *);
	void (*ndo_uninit)(struct net_device *);
	int (*ndo_open)(struct net_device *);
	int (*ndo_stop)(struct net_device *);
	netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *);
	netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t);
	u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *);
	void (*ndo_change_rx_flags)(struct net_device *, int);
	void (*ndo_set_rx_mode)(struct net_device *);
	int (*ndo_set_mac_address)(struct net_device *, void *);
	int (*ndo_validate_addr)(struct net_device *);
	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_set_config)(struct net_device *, struct ifmap *);
	int (*ndo_change_mtu)(struct net_device *, int);
	int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *);
	void (*ndo_tx_timeout)(struct net_device *, unsigned int);
	void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *);
	bool (*ndo_has_offload_stats)(const struct net_device *, int);
	int (*ndo_get_offload_stats)(int, const struct net_device *, void *);
	struct net_device_stats * (*ndo_get_stats)(struct net_device *);
	int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16, u16);
	int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16, u16);
	void (*ndo_poll_controller)(struct net_device *);
	int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *);
	void (*ndo_netpoll_cleanup)(struct net_device *);
	int (*ndo_set_vf_mac)(struct net_device *, int, u8 *);
	int (*ndo_set_vf_vlan)(struct net_device *, int, u16, u8, __be16);
	int (*ndo_set_vf_rate)(struct net_device *, int, int, int);
	int (*ndo_set_vf_spoofchk)(struct net_device *, int, bool);
	int (*ndo_set_vf_trust)(struct net_device *, int, bool);
	int (*ndo_get_vf_config)(struct net_device *, int, struct ifla_vf_info *);
	int (*ndo_set_vf_link_state)(struct net_device *, int, int);
	int (*ndo_get_vf_stats)(struct net_device *, int, struct ifla_vf_stats *);
	int (*ndo_set_vf_port)(struct net_device *, int, struct nlattr **);
	int (*ndo_get_vf_port)(struct net_device *, int, struct sk_buff *);
	int (*ndo_get_vf_guid)(struct net_device *, int, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*ndo_set_vf_guid)(struct net_device *, int, u64, int);
	int (*ndo_set_vf_rss_query_en)(struct net_device *, int, bool);
	int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type, void *);
	int (*ndo_fcoe_enable)(struct net_device *);
	int (*ndo_fcoe_disable)(struct net_device *);
	int (*ndo_fcoe_ddp_setup)(struct net_device *, u16, struct scatterlist *, unsigned int);
	int (*ndo_fcoe_ddp_done)(struct net_device *, u16);
	int (*ndo_fcoe_ddp_target)(struct net_device *, u16, struct scatterlist *, unsigned int);
	int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *);
	int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int);
	int (*ndo_rx_flow_steer)(struct net_device *, const struct sk_buff *, u16, u32);
	int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_del_slave)(struct net_device *, struct net_device *);
	struct net_device * (*ndo_get_xmit_slave)(struct net_device *, struct sk_buff *, bool);
	struct net_device * (*ndo_sk_get_lower_dev)(struct net_device *, struct sock *);
	netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t);
	int (*ndo_set_features)(struct net_device *, netdev_features_t);
	int (*ndo_neigh_construct)(struct net_device *, struct neighbour *);
	void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *);
	int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16, struct netlink_ext_ack *);
	int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16);
	int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *);
	int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);
	int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16, struct netlink_ext_ack *);
	int (*ndo_bridge_getlink)(struct sk_buff *, u32, u32, struct net_device *, u32, int);
	int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16);
	int (*ndo_change_carrier)(struct net_device *, bool);
	int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t);
	void * (*ndo_dfwd_add_station)(struct net_device *, struct net_device *);
	void (*ndo_dfwd_del_station)(struct net_device *, void *);
	int (*ndo_set_tx_maxrate)(struct net_device *, int, u32);
	int (*ndo_get_iflink)(const struct net_device *);
	int (*ndo_change_proto_down)(struct net_device *, bool);
	int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *);
	void (*ndo_set_rx_headroom)(struct net_device *, int);
	int (*ndo_bpf)(struct net_device *, struct netdev_bpf *);
	int (*ndo_xdp_xmit)(struct net_device *, int, struct xdp_frame **, u32);
	int (*ndo_xsk_wakeup)(struct net_device *, u32, u32);
	struct devlink_port * (*ndo_get_devlink_port)(struct net_device *);
	int (*ndo_tunnel_ctl)(struct net_device *, struct ip_tunnel_parm *, int);
	struct net_device * (*ndo_get_peer_dev)(struct net_device *);
	int (*ndo_fill_forward_path)(struct net_device_path_ctx *, struct net_device_path *);
};

struct neigh_parms {
	possible_net_t net;
	struct net_device *dev;
	struct list_head list;
	int (*neigh_setup)(struct neighbour *);
	struct neigh_table *tbl;
	void *sysctl_table;
	int dead;
	refcount_t refcnt;
	struct callback_head callback_head;
	int reachable_time;
	int data[13];
	long unsigned int data_state[1];
};

struct pcpu_lstats {
	u64_stats_t packets;
	u64_stats_t bytes;
	struct u64_stats_sync syncp;
};

struct pcpu_sw_netstats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 tx_packets;
	u64 tx_bytes;
	struct u64_stats_sync syncp;
};

struct iw_request_info;

union iwreq_data;

typedef int (*iw_handler)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *);

struct iw_priv_args;

struct iw_statistics;

struct iw_handler_def {
	const iw_handler *standard;
	__u16 num_standard;
	__u16 num_private;
	__u16 num_private_args;
	const iw_handler *private;
	const struct iw_priv_args *private_args;
	struct iw_statistics * (*get_wireless_stats)(struct net_device *);
};

enum ethtool_phys_id_state {
	ETHTOOL_ID_INACTIVE = 0,
	ETHTOOL_ID_ACTIVE = 1,
	ETHTOOL_ID_ON = 2,
	ETHTOOL_ID_OFF = 3,
};

struct ethtool_drvinfo;

struct ethtool_regs;

struct ethtool_wolinfo;

struct ethtool_link_ext_state_info;

struct ethtool_eeprom;

struct ethtool_coalesce;

struct ethtool_ringparam;

struct ethtool_pause_stats;

struct ethtool_pauseparam;

struct ethtool_test;

struct ethtool_stats;

struct ethtool_rxnfc;

struct ethtool_flash;

struct ethtool_channels;

struct ethtool_dump;

struct ethtool_ts_info;

struct ethtool_modinfo;

struct ethtool_eee;

struct ethtool_tunable;

struct ethtool_link_ksettings;

struct ethtool_fec_stats;

struct ethtool_fecparam;

struct ethtool_module_eeprom;

struct ethtool_eth_phy_stats;

struct ethtool_eth_mac_stats;

struct ethtool_eth_ctrl_stats;

struct ethtool_rmon_stats;

struct ethtool_rmon_hist_range;

struct ethtool_ops {
	u32 cap_link_lanes_supported: 1;
	u32 supported_coalesce_params;
	void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
	int (*get_regs_len)(struct net_device *);
	void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
	void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
	int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
	u32 (*get_msglevel)(struct net_device *);
	void (*set_msglevel)(struct net_device *, u32);
	int (*nway_reset)(struct net_device *);
	u32 (*get_link)(struct net_device *);
	int (*get_link_ext_state)(struct net_device *, struct ethtool_link_ext_state_info *);
	int (*get_eeprom_len)(struct net_device *);
	int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *);
	int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *);
	void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *);
	int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *);
	void (*get_pause_stats)(struct net_device *, struct ethtool_pause_stats *);
	void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
	void (*get_strings)(struct net_device *, u32, u8 *);
	int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);
	void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*begin)(struct net_device *);
	void (*complete)(struct net_device *);
	u32 (*get_priv_flags)(struct net_device *);
	int (*set_priv_flags)(struct net_device *, u32);
	int (*get_sset_count)(struct net_device *, int);
	int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
	int (*flash_device)(struct net_device *, struct ethtool_flash *);
	int (*reset)(struct net_device *, u32 *);
	u32 (*get_rxfh_key_size)(struct net_device *);
	u32 (*get_rxfh_indir_size)(struct net_device *);
	int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *);
	int (*set_rxfh)(struct net_device *, const u32 *, const u8 *, const u8);
	int (*get_rxfh_context)(struct net_device *, u32 *, u8 *, u8 *, u32);
	int (*set_rxfh_context)(struct net_device *, const u32 *, const u8 *, const u8, u32 *, bool);
	void (*get_channels)(struct net_device *, struct ethtool_channels *);
	int (*set_channels)(struct net_device *, struct ethtool_channels *);
	int (*get_dump_flag)(struct net_device *, struct ethtool_dump *);
	int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *);
	int (*set_dump)(struct net_device *, struct ethtool_dump *);
	int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);
	int (*get_module_info)(struct net_device *, struct ethtool_modinfo *);
	int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_eee)(struct net_device *, struct ethtool_eee *);
	int (*set_eee)(struct net_device *, struct ethtool_eee *);
	int (*get_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*set_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *);
	int (*set_link_ksettings)(struct net_device *, const struct ethtool_link_ksettings *);
	void (*get_fec_stats)(struct net_device *, struct ethtool_fec_stats *);
	int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *);
	int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *);
	void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*get_phy_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_phy_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_module_eeprom_by_page)(struct net_device *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);
	void (*get_eth_phy_stats)(struct net_device *, struct ethtool_eth_phy_stats *);
	void (*get_eth_mac_stats)(struct net_device *, struct ethtool_eth_mac_stats *);
	void (*get_eth_ctrl_stats)(struct net_device *, struct ethtool_eth_ctrl_stats *);
	void (*get_rmon_stats)(struct net_device *, struct ethtool_rmon_stats *, const struct ethtool_rmon_hist_range **);
};

struct l3mdev_ops {
	u32 (*l3mdev_fib_table)(const struct net_device *);
	struct sk_buff * (*l3mdev_l3_rcv)(struct net_device *, struct sk_buff *, u16);
	struct sk_buff * (*l3mdev_l3_out)(struct net_device *, struct sock *, struct sk_buff *, u16);
	struct dst_entry * (*l3mdev_link_scope_lookup)(const struct net_device *, struct flowi6 *);
};

struct nd_opt_hdr;

struct ndisc_options;

struct prefix_info;

struct ndisc_ops {
	int (*is_useropt)(u8);
	int (*parse_options)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *);
	void (*update)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *);
	int (*opt_addr_space)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **);
	void (*fill_addr_option)(const struct net_device *, struct sk_buff *, u8, const u8 *);
	void (*prefix_rcv_add_addr)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool);
};

enum tls_offload_ctx_dir {
	TLS_OFFLOAD_CTX_DIR_RX = 0,
	TLS_OFFLOAD_CTX_DIR_TX = 1,
};

struct tls_crypto_info;

struct tls_context;

struct tlsdev_ops {
	int (*tls_dev_add)(struct net_device *, struct sock *, enum tls_offload_ctx_dir, struct tls_crypto_info *, u32);
	void (*tls_dev_del)(struct net_device *, struct tls_context *, enum tls_offload_ctx_dir);
	int (*tls_dev_resync)(struct net_device *, struct sock *, u32, u8 *, enum tls_offload_ctx_dir);
};

struct ipv6_devstat {
	struct proc_dir_entry *proc_dir_entry;
	struct ipstats_mib *ipv6;
	struct icmpv6_mib_device *icmpv6dev;
	struct icmpv6msg_mib_device *icmpv6msgdev;
};

struct ifmcaddr6;

struct ifacaddr6;

struct inet6_dev {
	struct net_device *dev;
	struct list_head addr_list;
	struct ifmcaddr6 *mc_list;
	struct ifmcaddr6 *mc_tomb;
	unsigned char mc_qrv;
	unsigned char mc_gq_running;
	unsigned char mc_ifc_count;
	unsigned char mc_dad_count;
	long unsigned int mc_v1_seen;
	long unsigned int mc_qi;
	long unsigned int mc_qri;
	long unsigned int mc_maxdelay;
	struct delayed_work mc_gq_work;
	struct delayed_work mc_ifc_work;
	struct delayed_work mc_dad_work;
	struct delayed_work mc_query_work;
	struct delayed_work mc_report_work;
	struct sk_buff_head mc_query_queue;
	struct sk_buff_head mc_report_queue;
	spinlock_t mc_query_lock;
	spinlock_t mc_report_lock;
	struct mutex mc_lock;
	struct ifacaddr6 *ac_list;
	rwlock_t lock;
	refcount_t refcnt;
	__u32 if_flags;
	int dead;
	u32 desync_factor;
	struct list_head tempaddr_list;
	struct in6_addr token;
	struct neigh_parms *nd_parms;
	struct ipv6_devconf cnf;
	struct ipv6_devstat stats;
	struct timer_list rs_timer;
	__s32 rs_interval;
	__u8 rs_probes;
	long unsigned int tstamp;
	struct callback_head rcu;
};

struct tcf_proto;

struct tcf_block;

struct mini_Qdisc {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	struct callback_head rcu;
};

struct rtnl_link_ops {
	struct list_head list;
	const char *kind;
	size_t priv_size;
	void (*setup)(struct net_device *);
	bool netns_refund;
	unsigned int maxtype;
	const struct nla_policy *policy;
	int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	void (*dellink)(struct net_device *, struct list_head *);
	size_t (*get_size)(const struct net_device *);
	int (*fill_info)(struct sk_buff *, const struct net_device *);
	size_t (*get_xstats_size)(const struct net_device *);
	int (*fill_xstats)(struct sk_buff *, const struct net_device *);
	unsigned int (*get_num_tx_queues)();
	unsigned int (*get_num_rx_queues)();
	unsigned int slave_maxtype;
	const struct nla_policy *slave_policy;
	int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	size_t (*get_slave_size)(const struct net_device *, const struct net_device *);
	int (*fill_slave_info)(struct sk_buff *, const struct net_device *, const struct net_device *);
	struct net * (*get_link_net)(const struct net_device *);
	size_t (*get_linkxstats_size)(const struct net_device *, int);
	int (*fill_linkxstats)(struct sk_buff *, const struct net_device *, int *, int);
};

struct udp_tunnel_nic_table_info {
	unsigned int n_entries;
	unsigned int tunnel_types;
};

struct udp_tunnel_info;

struct udp_tunnel_nic_shared;

struct udp_tunnel_nic_info {
	int (*set_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*unset_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*sync_table)(struct net_device *, unsigned int);
	struct udp_tunnel_nic_shared *shared;
	unsigned int flags;
	struct udp_tunnel_nic_table_info tables[4];
};

struct sd_flow_limit {
	u64 count;
	unsigned int num_buckets;
	unsigned int history_head;
	u16 history[128];
	u8 buckets[0];
};

struct softnet_data {
	struct list_head poll_list;
	struct sk_buff_head process_queue;
	unsigned int processed;
	unsigned int time_squeeze;
	unsigned int received_rps;
	struct softnet_data *rps_ipi_list;
	struct sd_flow_limit *flow_limit;
	struct Qdisc *output_queue;
	struct Qdisc **output_queue_tailp;
	struct sk_buff *completion_queue;
	struct sk_buff_head xfrm_backlog;
	struct {
		u16 recursion;
		u8 more;
	} xmit;
	int: 32;
	unsigned int input_queue_head;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t csd;
	struct softnet_data *rps_ipi_next;
	unsigned int cpu;
	unsigned int input_queue_tail;
	unsigned int dropped;
	struct sk_buff_head input_pkt_queue;
	struct napi_struct backlog;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	RTAX_UNSPEC = 0,
	RTAX_LOCK = 1,
	RTAX_MTU = 2,
	RTAX_WINDOW = 3,
	RTAX_RTT = 4,
	RTAX_RTTVAR = 5,
	RTAX_SSTHRESH = 6,
	RTAX_CWND = 7,
	RTAX_ADVMSS = 8,
	RTAX_REORDERING = 9,
	RTAX_HOPLIMIT = 10,
	RTAX_INITCWND = 11,
	RTAX_FEATURES = 12,
	RTAX_RTO_MIN = 13,
	RTAX_INITRWND = 14,
	RTAX_QUICKACK = 15,
	RTAX_CC_ALGO = 16,
	RTAX_FASTOPEN_NO_COOKIE = 17,
	__RTAX_MAX = 18,
};

struct tcmsg {
	unsigned char tcm_family;
	unsigned char tcm__pad1;
	short unsigned int tcm__pad2;
	int tcm_ifindex;
	__u32 tcm_handle;
	__u32 tcm_parent;
	__u32 tcm_info;
};

struct gnet_stats_basic_cpu {
	struct gnet_stats_basic_packed bstats;
	struct u64_stats_sync syncp;
};

struct gnet_dump {
	spinlock_t *lock;
	struct sk_buff *skb;
	struct nlattr *tail;
	int compat_tc_stats;
	int compat_xstats;
	int padattr;
	void *xstats;
	int xstats_len;
	struct tc_stats tc_stats;
};

struct netlink_range_validation {
	u64 min;
	u64 max;
};

struct netlink_range_validation_signed {
	s64 min;
	s64 max;
};

struct nl_info {
	struct nlmsghdr *nlh;
	struct net *nl_net;
	u32 portid;
	u8 skip_notify: 1;
	u8 skip_notify_kernel: 1;
};

enum flow_action_hw_stats_bit {
	FLOW_ACTION_HW_STATS_IMMEDIATE_BIT = 0,
	FLOW_ACTION_HW_STATS_DELAYED_BIT = 1,
	FLOW_ACTION_HW_STATS_DISABLED_BIT = 2,
	FLOW_ACTION_HW_STATS_NUM_BITS = 3,
};

struct flow_block {
	struct list_head cb_list;
};

typedef int flow_setup_cb_t(enum tc_setup_type, void *, void *);

struct qdisc_size_table {
	struct callback_head rcu;
	struct list_head list;
	struct tc_sizespec szopts;
	int refcnt;
	u16 data[0];
};

struct Qdisc_class_ops;

struct Qdisc_ops {
	struct Qdisc_ops *next;
	const struct Qdisc_class_ops *cl_ops;
	char id[16];
	int priv_size;
	unsigned int static_flags;
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	struct sk_buff * (*peek)(struct Qdisc *);
	int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*reset)(struct Qdisc *);
	void (*destroy)(struct Qdisc *);
	int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*attach)(struct Qdisc *);
	int (*change_tx_queue_len)(struct Qdisc *, unsigned int);
	void (*change_real_num_tx)(struct Qdisc *, unsigned int);
	int (*dump)(struct Qdisc *, struct sk_buff *);
	int (*dump_stats)(struct Qdisc *, struct gnet_dump *);
	void (*ingress_block_set)(struct Qdisc *, u32);
	void (*egress_block_set)(struct Qdisc *, u32);
	u32 (*ingress_block_get)(struct Qdisc *);
	u32 (*egress_block_get)(struct Qdisc *);
	struct module *owner;
};

struct qdisc_walker;

struct Qdisc_class_ops {
	unsigned int flags;
	struct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);
	int (*graft)(struct Qdisc *, long unsigned int, struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *);
	struct Qdisc * (*leaf)(struct Qdisc *, long unsigned int);
	void (*qlen_notify)(struct Qdisc *, long unsigned int);
	long unsigned int (*find)(struct Qdisc *, u32);
	int (*change)(struct Qdisc *, u32, u32, struct nlattr **, long unsigned int *, struct netlink_ext_ack *);
	int (*delete)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	void (*walk)(struct Qdisc *, struct qdisc_walker *);
	struct tcf_block * (*tcf_block)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	long unsigned int (*bind_tcf)(struct Qdisc *, long unsigned int, u32);
	void (*unbind_tcf)(struct Qdisc *, long unsigned int);
	int (*dump)(struct Qdisc *, long unsigned int, struct sk_buff *, struct tcmsg *);
	int (*dump_stats)(struct Qdisc *, long unsigned int, struct gnet_dump *);
};

struct tcf_chain;

struct tcf_block {
	struct mutex lock;
	struct list_head chain_list;
	u32 index;
	u32 classid;
	refcount_t refcnt;
	struct net *net;
	struct Qdisc *q;
	struct rw_semaphore cb_lock;
	struct flow_block flow_block;
	struct list_head owner_list;
	bool keep_dst;
	atomic_t offloadcnt;
	unsigned int nooffloaddevcnt;
	unsigned int lockeddevcnt;
	struct {
		struct tcf_chain *chain;
		struct list_head filter_chain_list;
	} chain0;
	struct callback_head rcu;
	struct hlist_head proto_destroy_ht[128];
	struct mutex proto_destroy_lock;
};

struct tcf_result;

struct tcf_proto_ops;

struct tcf_proto {
	struct tcf_proto *next;
	void *root;
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	__be16 protocol;
	u32 prio;
	void *data;
	const struct tcf_proto_ops *ops;
	struct tcf_chain *chain;
	spinlock_t lock;
	bool deleting;
	refcount_t refcnt;
	struct callback_head rcu;
	struct hlist_node destroy_ht_node;
};

struct tcf_result {
	union {
		struct {
			long unsigned int class;
			u32 classid;
		};
		const struct tcf_proto *goto_tp;
		struct {
			bool ingress;
			struct gnet_stats_queue *qstats;
		};
	};
};

struct tcf_walker;

struct tcf_proto_ops {
	struct list_head head;
	char kind[16];
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	int (*init)(struct tcf_proto *);
	void (*destroy)(struct tcf_proto *, bool, struct netlink_ext_ack *);
	void * (*get)(struct tcf_proto *, u32);
	void (*put)(struct tcf_proto *, void *);
	int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, long unsigned int, u32, struct nlattr **, void **, bool, bool, struct netlink_ext_ack *);
	int (*delete)(struct tcf_proto *, void *, bool *, bool, struct netlink_ext_ack *);
	bool (*delete_empty)(struct tcf_proto *);
	void (*walk)(struct tcf_proto *, struct tcf_walker *, bool);
	int (*reoffload)(struct tcf_proto *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);
	void (*hw_add)(struct tcf_proto *, void *);
	void (*hw_del)(struct tcf_proto *, void *);
	void (*bind_class)(void *, u32, long unsigned int, void *, long unsigned int);
	void * (*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *);
	void (*tmplt_destroy)(void *);
	int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*terse_dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*tmplt_dump)(struct sk_buff *, struct net *, void *);
	struct module *owner;
	int flags;
};

struct tcf_chain {
	struct mutex filter_chain_lock;
	struct tcf_proto *filter_chain;
	struct list_head list;
	struct tcf_block *block;
	u32 index;
	unsigned int refcnt;
	unsigned int action_refcnt;
	bool explicitly_created;
	bool flushing;
	const struct tcf_proto_ops *tmplt_ops;
	void *tmplt_priv;
	struct callback_head rcu;
};

struct sock_fprog_kern {
	u16 len;
	struct sock_filter *filter;
};

struct bpf_prog_stats {
	u64 cnt;
	u64 nsecs;
	u64 misses;
	struct u64_stats_sync syncp;
	long: 64;
};

struct sk_filter {
	refcount_t refcnt;
	struct callback_head rcu;
	struct bpf_prog *prog;
};

struct bpf_nh_params {
	u32 nh_family;
	union {
		u32 ipv4_nh;
		struct in6_addr ipv6_nh;
	};
};

struct bpf_redirect_info {
	u32 flags;
	u32 tgt_index;
	void *tgt_value;
	u32 map_id;
	enum bpf_map_type map_type;
	u32 kern_flags;
	struct bpf_nh_params nh;
};

enum {
	NEIGH_VAR_MCAST_PROBES = 0,
	NEIGH_VAR_UCAST_PROBES = 1,
	NEIGH_VAR_APP_PROBES = 2,
	NEIGH_VAR_MCAST_REPROBES = 3,
	NEIGH_VAR_RETRANS_TIME = 4,
	NEIGH_VAR_BASE_REACHABLE_TIME = 5,
	NEIGH_VAR_DELAY_PROBE_TIME = 6,
	NEIGH_VAR_GC_STALETIME = 7,
	NEIGH_VAR_QUEUE_LEN_BYTES = 8,
	NEIGH_VAR_PROXY_QLEN = 9,
	NEIGH_VAR_ANYCAST_DELAY = 10,
	NEIGH_VAR_PROXY_DELAY = 11,
	NEIGH_VAR_LOCKTIME = 12,
	NEIGH_VAR_QUEUE_LEN = 13,
	NEIGH_VAR_RETRANS_TIME_MS = 14,
	NEIGH_VAR_BASE_REACHABLE_TIME_MS = 15,
	NEIGH_VAR_GC_INTERVAL = 16,
	NEIGH_VAR_GC_THRESH1 = 17,
	NEIGH_VAR_GC_THRESH2 = 18,
	NEIGH_VAR_GC_THRESH3 = 19,
	NEIGH_VAR_MAX = 20,
};

struct pneigh_entry;

struct neigh_statistics;

struct neigh_hash_table;

struct neigh_table {
	int family;
	unsigned int entry_size;
	unsigned int key_len;
	__be16 protocol;
	__u32 (*hash)(const void *, const struct net_device *, __u32 *);
	bool (*key_eq)(const struct neighbour *, const void *);
	int (*constructor)(struct neighbour *);
	int (*pconstructor)(struct pneigh_entry *);
	void (*pdestructor)(struct pneigh_entry *);
	void (*proxy_redo)(struct sk_buff *);
	int (*is_multicast)(const void *);
	bool (*allow_add)(const struct net_device *, struct netlink_ext_ack *);
	char *id;
	struct neigh_parms parms;
	struct list_head parms_list;
	int gc_interval;
	int gc_thresh1;
	int gc_thresh2;
	int gc_thresh3;
	long unsigned int last_flush;
	struct delayed_work gc_work;
	struct timer_list proxy_timer;
	struct sk_buff_head proxy_queue;
	atomic_t entries;
	atomic_t gc_entries;
	struct list_head gc_list;
	rwlock_t lock;
	long unsigned int last_rand;
	struct neigh_statistics *stats;
	struct neigh_hash_table *nht;
	struct pneigh_entry **phash_buckets;
};

struct neigh_statistics {
	long unsigned int allocs;
	long unsigned int destroys;
	long unsigned int hash_grows;
	long unsigned int res_failed;
	long unsigned int lookups;
	long unsigned int hits;
	long unsigned int rcv_probes_mcast;
	long unsigned int rcv_probes_ucast;
	long unsigned int periodic_gc_runs;
	long unsigned int forced_gc_runs;
	long unsigned int unres_discards;
	long unsigned int table_fulls;
};

struct neigh_ops {
	int family;
	void (*solicit)(struct neighbour *, struct sk_buff *);
	void (*error_report)(struct neighbour *, struct sk_buff *);
	int (*output)(struct neighbour *, struct sk_buff *);
	int (*connected_output)(struct neighbour *, struct sk_buff *);
};

struct pneigh_entry {
	struct pneigh_entry *next;
	possible_net_t net;
	struct net_device *dev;
	u8 flags;
	u8 protocol;
	u8 key[0];
};

struct neigh_hash_table {
	struct neighbour **hash_buckets;
	unsigned int hash_shift;
	__u32 hash_rnd[4];
	struct callback_head rcu;
};

struct dst_metrics {
	u32 metrics[17];
	refcount_t refcnt;
};

enum {
	TCP_ESTABLISHED = 1,
	TCP_SYN_SENT = 2,
	TCP_SYN_RECV = 3,
	TCP_FIN_WAIT1 = 4,
	TCP_FIN_WAIT2 = 5,
	TCP_TIME_WAIT = 6,
	TCP_CLOSE = 7,
	TCP_CLOSE_WAIT = 8,
	TCP_LAST_ACK = 9,
	TCP_LISTEN = 10,
	TCP_CLOSING = 11,
	TCP_NEW_SYN_RECV = 12,
	TCP_MAX_STATES = 13,
};

struct fib_rule_hdr {
	__u8 family;
	__u8 dst_len;
	__u8 src_len;
	__u8 tos;
	__u8 table;
	__u8 res1;
	__u8 res2;
	__u8 action;
	__u32 flags;
};

struct fib_rule_port_range {
	__u16 start;
	__u16 end;
};

struct fib_kuid_range {
	kuid_t start;
	kuid_t end;
};

struct fib_rule {
	struct list_head list;
	int iifindex;
	int oifindex;
	u32 mark;
	u32 mark_mask;
	u32 flags;
	u32 table;
	u8 action;
	u8 l3mdev;
	u8 proto;
	u8 ip_proto;
	u32 target;
	__be64 tun_id;
	struct fib_rule *ctarget;
	struct net *fr_net;
	refcount_t refcnt;
	u32 pref;
	int suppress_ifgroup;
	int suppress_prefixlen;
	char iifname[16];
	char oifname[16];
	struct fib_kuid_range uid_range;
	struct fib_rule_port_range sport_range;
	struct fib_rule_port_range dport_range;
	struct callback_head rcu;
};

struct fib_lookup_arg {
	void *lookup_ptr;
	const void *lookup_data;
	void *result;
	struct fib_rule *rule;
	u32 table;
	int flags;
};

struct smc_hashinfo;

struct sk_psock;

struct request_sock_ops;

struct timewait_sock_ops;

struct udp_table;

struct raw_hashinfo;

struct proto {
	void (*close)(struct sock *, long int);
	int (*pre_connect)(struct sock *, struct sockaddr *, int);
	int (*connect)(struct sock *, struct sockaddr *, int);
	int (*disconnect)(struct sock *, int);
	struct sock * (*accept)(struct sock *, int, int *, bool);
	int (*ioctl)(struct sock *, int, long unsigned int);
	int (*init)(struct sock *);
	void (*destroy)(struct sock *);
	void (*shutdown)(struct sock *, int);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*keepalive)(struct sock *, int);
	int (*compat_ioctl)(struct sock *, unsigned int, long unsigned int);
	int (*sendmsg)(struct sock *, struct msghdr *, size_t);
	int (*recvmsg)(struct sock *, struct msghdr *, size_t, int, int, int *);
	int (*sendpage)(struct sock *, struct page *, int, size_t, int);
	int (*bind)(struct sock *, struct sockaddr *, int);
	int (*bind_add)(struct sock *, struct sockaddr *, int);
	int (*backlog_rcv)(struct sock *, struct sk_buff *);
	bool (*bpf_bypass_getsockopt)(int, int);
	void (*release_cb)(struct sock *);
	int (*hash)(struct sock *);
	void (*unhash)(struct sock *);
	void (*rehash)(struct sock *);
	int (*get_port)(struct sock *, short unsigned int);
	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
	unsigned int inuse_idx;
	bool (*stream_memory_free)(const struct sock *, int);
	bool (*stream_memory_read)(const struct sock *);
	void (*enter_memory_pressure)(struct sock *);
	void (*leave_memory_pressure)(struct sock *);
	atomic_long_t *memory_allocated;
	struct percpu_counter *sockets_allocated;
	long unsigned int *memory_pressure;
	long int *sysctl_mem;
	int *sysctl_wmem;
	int *sysctl_rmem;
	u32 sysctl_wmem_offset;
	u32 sysctl_rmem_offset;
	int max_header;
	bool no_autobind;
	struct kmem_cache *slab;
	unsigned int obj_size;
	slab_flags_t slab_flags;
	unsigned int useroffset;
	unsigned int usersize;
	unsigned int *orphan_count;
	struct request_sock_ops *rsk_prot;
	struct timewait_sock_ops *twsk_prot;
	union {
		struct inet_hashinfo *hashinfo;
		struct udp_table *udp_table;
		struct raw_hashinfo *raw_hash;
		struct smc_hashinfo *smc_hash;
	} h;
	struct module *owner;
	char name[32];
	struct list_head node;
	int (*diag_destroy)(struct sock *, int);
};

struct request_sock;

struct request_sock_ops {
	int family;
	unsigned int obj_size;
	struct kmem_cache *slab;
	char *slab_name;
	int (*rtx_syn_ack)(const struct sock *, struct request_sock *);
	void (*send_ack)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*send_reset)(const struct sock *, struct sk_buff *);
	void (*destructor)(struct request_sock *);
	void (*syn_ack_timeout)(const struct request_sock *);
};

struct timewait_sock_ops {
	struct kmem_cache *twsk_slab;
	char *twsk_slab_name;
	unsigned int twsk_obj_size;
	int (*twsk_unique)(struct sock *, struct sock *, void *);
	void (*twsk_destructor)(struct sock *);
};

struct saved_syn;

struct request_sock {
	struct sock_common __req_common;
	struct request_sock *dl_next;
	u16 mss;
	u8 num_retrans;
	u8 syncookie: 1;
	u8 num_timeout: 7;
	u32 ts_recent;
	struct timer_list rsk_timer;
	const struct request_sock_ops *rsk_ops;
	struct sock *sk;
	struct saved_syn *saved_syn;
	u32 secid;
	u32 peer_secid;
};

struct saved_syn {
	u32 mac_hdrlen;
	u32 network_hdrlen;
	u32 tcp_hdrlen;
	u8 data[0];
};

enum tsq_enum {
	TSQ_THROTTLED = 0,
	TSQ_QUEUED = 1,
	TCP_TSQ_DEFERRED = 2,
	TCP_WRITE_TIMER_DEFERRED = 3,
	TCP_DELACK_TIMER_DEFERRED = 4,
	TCP_MTU_REDUCED_DEFERRED = 5,
};

struct static_key_false_deferred {
	struct static_key_false key;
	long unsigned int timeout;
	struct delayed_work work;
};

struct ip6_sf_list {
	struct ip6_sf_list *sf_next;
	struct in6_addr sf_addr;
	long unsigned int sf_count[2];
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
	struct callback_head rcu;
};

struct ifmcaddr6 {
	struct in6_addr mca_addr;
	struct inet6_dev *idev;
	struct ifmcaddr6 *next;
	struct ip6_sf_list *mca_sources;
	struct ip6_sf_list *mca_tomb;
	unsigned int mca_sfmode;
	unsigned char mca_crcount;
	long unsigned int mca_sfcount[2];
	struct delayed_work mca_work;
	unsigned int mca_flags;
	int mca_users;
	refcount_t mca_refcnt;
	long unsigned int mca_cstamp;
	long unsigned int mca_tstamp;
	struct callback_head rcu;
};

struct ifacaddr6 {
	struct in6_addr aca_addr;
	struct fib6_info *aca_rt;
	struct ifacaddr6 *aca_next;
	struct hlist_node aca_addr_lst;
	int aca_users;
	refcount_t aca_refcnt;
	long unsigned int aca_cstamp;
	long unsigned int aca_tstamp;
	struct callback_head rcu;
};

struct fib6_result;

struct fib6_nh;

struct fib6_config;

struct ipv6_stub {
	int (*ipv6_sock_mc_join)(struct sock *, int, const struct in6_addr *);
	int (*ipv6_sock_mc_drop)(struct sock *, int, const struct in6_addr *);
	struct dst_entry * (*ipv6_dst_lookup_flow)(struct net *, const struct sock *, struct flowi6 *, const struct in6_addr *);
	int (*ipv6_route_input)(struct sk_buff *);
	struct fib6_table * (*fib6_get_table)(struct net *, u32);
	int (*fib6_lookup)(struct net *, int, struct flowi6 *, struct fib6_result *, int);
	int (*fib6_table_lookup)(struct net *, struct fib6_table *, int, struct flowi6 *, struct fib6_result *, int);
	void (*fib6_select_path)(const struct net *, struct fib6_result *, struct flowi6 *, int, bool, const struct sk_buff *, int);
	u32 (*ip6_mtu_from_fib6)(const struct fib6_result *, const struct in6_addr *, const struct in6_addr *);
	int (*fib6_nh_init)(struct net *, struct fib6_nh *, struct fib6_config *, gfp_t, struct netlink_ext_ack *);
	void (*fib6_nh_release)(struct fib6_nh *);
	void (*fib6_nh_release_dsts)(struct fib6_nh *);
	void (*fib6_update_sernum)(struct net *, struct fib6_info *);
	int (*ip6_del_rt)(struct net *, struct fib6_info *, bool);
	void (*fib6_rt_update)(struct net *, struct fib6_info *, struct nl_info *);
	void (*udpv6_encap_enable)();
	void (*ndisc_send_na)(struct net_device *, const struct in6_addr *, const struct in6_addr *, bool, bool, bool, bool);
	void (*xfrm6_local_rxpmtu)(struct sk_buff *, u32);
	int (*xfrm6_udp_encap_rcv)(struct sock *, struct sk_buff *);
	int (*xfrm6_rcv_encap)(struct sk_buff *, int, __be32, int);
	struct neigh_table *nd_tbl;
	int (*ipv6_fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	struct net_device * (*ipv6_dev_find)(struct net *, const struct in6_addr *, struct net_device *);
};

struct fib6_result {
	struct fib6_nh *nh;
	struct fib6_info *f6i;
	u32 fib6_flags;
	u8 fib6_type;
	struct rt6_info *rt6;
};

struct ipv6_bpf_stub {
	int (*inet6_bind)(struct sock *, struct sockaddr *, int, u32);
	struct sock * (*udp6_lib_lookup)(struct net *, const struct in6_addr *, __be16, const struct in6_addr *, __be16, int, int, struct udp_table *, struct sk_buff *);
};

enum {
	__ND_OPT_PREFIX_INFO_END = 0,
	ND_OPT_SOURCE_LL_ADDR = 1,
	ND_OPT_TARGET_LL_ADDR = 2,
	ND_OPT_PREFIX_INFO = 3,
	ND_OPT_REDIRECT_HDR = 4,
	ND_OPT_MTU = 5,
	ND_OPT_NONCE = 14,
	__ND_OPT_ARRAY_MAX = 15,
	ND_OPT_ROUTE_INFO = 24,
	ND_OPT_RDNSS = 25,
	ND_OPT_DNSSL = 31,
	ND_OPT_6CO = 34,
	ND_OPT_CAPTIVE_PORTAL = 37,
	ND_OPT_PREF64 = 38,
	__ND_OPT_MAX = 39,
};

struct nd_opt_hdr {
	__u8 nd_opt_type;
	__u8 nd_opt_len;
};

struct ndisc_options {
	struct nd_opt_hdr *nd_opt_array[15];
	struct nd_opt_hdr *nd_opts_ri;
	struct nd_opt_hdr *nd_opts_ri_end;
	struct nd_opt_hdr *nd_useropts;
	struct nd_opt_hdr *nd_useropts_end;
	struct nd_opt_hdr *nd_802154_opt_array[3];
};

struct prefix_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	__u8 reserved: 6;
	__u8 autoconf: 1;
	__u8 onlink: 1;
	__be32 valid;
	__be32 prefered;
	__be32 reserved2;
	struct in6_addr prefix;
};

struct ip6_ra_chain {
	struct ip6_ra_chain *next;
	struct sock *sk;
	int sel;
	void (*destructor)(struct sock *);
};

struct rpc_xprt_iter_ops {
	void (*xpi_rewind)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_xprt)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_next)(struct rpc_xprt_iter *);
};

struct rpc_version {
	u32 number;
	unsigned int nrprocs;
	const struct rpc_procinfo *procs;
	unsigned int *counts;
};

struct nfs_fh {
	short unsigned int size;
	unsigned char data[128];
};

enum nfs3_stable_how {
	NFS_UNSTABLE = 0,
	NFS_DATA_SYNC = 1,
	NFS_FILE_SYNC = 2,
	NFS_INVALID_STABLE_HOW = 4294967295,
};

struct nfs4_label {
	uint32_t lfs;
	uint32_t pi;
	u32 len;
	char *label;
};

typedef struct {
	char data[8];
} nfs4_verifier;

struct nfs4_stateid_struct {
	union {
		char data[16];
		struct {
			__be32 seqid;
			char other[12];
		};
	};
	enum {
		NFS4_INVALID_STATEID_TYPE = 0,
		NFS4_SPECIAL_STATEID_TYPE = 1,
		NFS4_OPEN_STATEID_TYPE = 2,
		NFS4_LOCK_STATEID_TYPE = 3,
		NFS4_DELEGATION_STATEID_TYPE = 4,
		NFS4_LAYOUT_STATEID_TYPE = 5,
		NFS4_PNFS_DS_STATEID_TYPE = 6,
		NFS4_REVOKED_STATEID_TYPE = 7,
	} type;
};

typedef struct nfs4_stateid_struct nfs4_stateid;

enum nfs_opnum4 {
	OP_ACCESS = 3,
	OP_CLOSE = 4,
	OP_COMMIT = 5,
	OP_CREATE = 6,
	OP_DELEGPURGE = 7,
	OP_DELEGRETURN = 8,
	OP_GETATTR = 9,
	OP_GETFH = 10,
	OP_LINK = 11,
	OP_LOCK = 12,
	OP_LOCKT = 13,
	OP_LOCKU = 14,
	OP_LOOKUP = 15,
	OP_LOOKUPP = 16,
	OP_NVERIFY = 17,
	OP_OPEN = 18,
	OP_OPENATTR = 19,
	OP_OPEN_CONFIRM = 20,
	OP_OPEN_DOWNGRADE = 21,
	OP_PUTFH = 22,
	OP_PUTPUBFH = 23,
	OP_PUTROOTFH = 24,
	OP_READ = 25,
	OP_READDIR = 26,
	OP_READLINK = 27,
	OP_REMOVE = 28,
	OP_RENAME = 29,
	OP_RENEW = 30,
	OP_RESTOREFH = 31,
	OP_SAVEFH = 32,
	OP_SECINFO = 33,
	OP_SETATTR = 34,
	OP_SETCLIENTID = 35,
	OP_SETCLIENTID_CONFIRM = 36,
	OP_VERIFY = 37,
	OP_WRITE = 38,
	OP_RELEASE_LOCKOWNER = 39,
	OP_BACKCHANNEL_CTL = 40,
	OP_BIND_CONN_TO_SESSION = 41,
	OP_EXCHANGE_ID = 42,
	OP_CREATE_SESSION = 43,
	OP_DESTROY_SESSION = 44,
	OP_FREE_STATEID = 45,
	OP_GET_DIR_DELEGATION = 46,
	OP_GETDEVICEINFO = 47,
	OP_GETDEVICELIST = 48,
	OP_LAYOUTCOMMIT = 49,
	OP_LAYOUTGET = 50,
	OP_LAYOUTRETURN = 51,
	OP_SECINFO_NO_NAME = 52,
	OP_SEQUENCE = 53,
	OP_SET_SSV = 54,
	OP_TEST_STATEID = 55,
	OP_WANT_DELEGATION = 56,
	OP_DESTROY_CLIENTID = 57,
	OP_RECLAIM_COMPLETE = 58,
	OP_ALLOCATE = 59,
	OP_COPY = 60,
	OP_COPY_NOTIFY = 61,
	OP_DEALLOCATE = 62,
	OP_IO_ADVISE = 63,
	OP_LAYOUTERROR = 64,
	OP_LAYOUTSTATS = 65,
	OP_OFFLOAD_CANCEL = 66,
	OP_OFFLOAD_STATUS = 67,
	OP_READ_PLUS = 68,
	OP_SEEK = 69,
	OP_WRITE_SAME = 70,
	OP_CLONE = 71,
	OP_GETXATTR = 72,
	OP_SETXATTR = 73,
	OP_LISTXATTRS = 74,
	OP_REMOVEXATTR = 75,
	OP_ILLEGAL = 10044,
};

enum nfs4_change_attr_type {
	NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR = 0,
	NFS4_CHANGE_TYPE_IS_VERSION_COUNTER = 1,
	NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS = 2,
	NFS4_CHANGE_TYPE_IS_TIME_METADATA = 3,
	NFS4_CHANGE_TYPE_IS_UNDEFINED = 4,
};

struct nfs4_string {
	unsigned int len;
	char *data;
};

struct nfs_fsid {
	uint64_t major;
	uint64_t minor;
};

struct nfs4_threshold {
	__u32 bm;
	__u32 l_type;
	__u64 rd_sz;
	__u64 wr_sz;
	__u64 rd_io_sz;
	__u64 wr_io_sz;
};

struct nfs_fattr {
	unsigned int valid;
	umode_t mode;
	__u32 nlink;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	__u64 size;
	union {
		struct {
			__u32 blocksize;
			__u32 blocks;
		} nfs2;
		struct {
			__u64 used;
		} nfs3;
	} du;
	struct nfs_fsid fsid;
	__u64 fileid;
	__u64 mounted_on_fileid;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	__u64 change_attr;
	__u64 pre_change_attr;
	__u64 pre_size;
	struct timespec64 pre_mtime;
	struct timespec64 pre_ctime;
	long unsigned int time_start;
	long unsigned int gencount;
	struct nfs4_string *owner_name;
	struct nfs4_string *group_name;
	struct nfs4_threshold *mdsthreshold;
	struct nfs4_label *label;
};

struct nfs_fsinfo {
	struct nfs_fattr *fattr;
	__u32 rtmax;
	__u32 rtpref;
	__u32 rtmult;
	__u32 wtmax;
	__u32 wtpref;
	__u32 wtmult;
	__u32 dtpref;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	__u32 lease_time;
	__u32 nlayouttypes;
	__u32 layouttype[8];
	__u32 blksize;
	__u32 clone_blksize;
	enum nfs4_change_attr_type change_attr_type;
	__u32 xattr_support;
};

struct nfs_fsstat {
	struct nfs_fattr *fattr;
	__u64 tbytes;
	__u64 fbytes;
	__u64 abytes;
	__u64 tfiles;
	__u64 ffiles;
	__u64 afiles;
};

struct nfs_pathconf {
	struct nfs_fattr *fattr;
	__u32 max_link;
	__u32 max_namelen;
};

struct nfs4_change_info {
	u32 atomic;
	u64 before;
	u64 after;
};

struct nfs4_slot;

struct nfs4_sequence_args {
	struct nfs4_slot *sa_slot;
	u8 sa_cache_this: 1;
	u8 sa_privileged: 1;
};

struct nfs4_sequence_res {
	struct nfs4_slot *sr_slot;
	long unsigned int sr_timestamp;
	int sr_status;
	u32 sr_status_flags;
	u32 sr_highest_slotid;
	u32 sr_target_highest_slotid;
};

struct nfs_open_context;

struct nfs_lock_context {
	refcount_t count;
	struct list_head list;
	struct nfs_open_context *open_context;
	fl_owner_t lockowner;
	atomic_t io_count;
	struct callback_head callback_head;
};

struct nfs4_state;

struct nfs_open_context {
	struct nfs_lock_context lock_context;
	fl_owner_t flock_owner;
	struct dentry *dentry;
	const struct cred *cred;
	struct rpc_cred *ll_cred;
	struct nfs4_state *state;
	fmode_t mode;
	long unsigned int flags;
	int error;
	struct list_head list;
	struct nfs4_threshold *mdsthreshold;
	struct callback_head callback_head;
};

struct nlm_host;

struct nfs_iostats;

struct nfs_auth_info {
	unsigned int flavor_len;
	rpc_authflavor_t flavors[12];
};

struct nfs_fscache_key;

struct fscache_cookie;

struct pnfs_layoutdriver_type;

struct nfs_client;

struct nfs_server {
	struct nfs_client *nfs_client;
	struct list_head client_link;
	struct list_head master_link;
	struct rpc_clnt *client;
	struct rpc_clnt *client_acl;
	struct nlm_host *nlm_host;
	struct nfs_iostats *io_stats;
	atomic_long_t writeback;
	unsigned int flags;
	unsigned int fattr_valid;
	unsigned int caps;
	unsigned int rsize;
	unsigned int rpages;
	unsigned int wsize;
	unsigned int wpages;
	unsigned int wtmult;
	unsigned int dtsize;
	short unsigned int port;
	unsigned int bsize;
	unsigned int gxasize;
	unsigned int sxasize;
	unsigned int lxasize;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namelen;
	unsigned int options;
	unsigned int clone_blksize;
	enum nfs4_change_attr_type change_attr_type;
	struct nfs_fsid fsid;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	long unsigned int mount_time;
	struct super_block *super;
	dev_t s_dev;
	struct nfs_auth_info auth_info;
	struct nfs_fscache_key *fscache_key;
	struct fscache_cookie *fscache;
	u32 pnfs_blksize;
	u32 attr_bitmask[3];
	u32 attr_bitmask_nl[3];
	u32 exclcreat_bitmask[3];
	u32 cache_consistency_bitmask[3];
	u32 acl_bitmask;
	u32 fh_expire_type;
	struct pnfs_layoutdriver_type *pnfs_curr_ld;
	struct rpc_wait_queue roc_rpcwaitq;
	void *pnfs_ld_data;
	struct rb_root state_owners;
	struct ida openowner_id;
	struct ida lockowner_id;
	struct list_head state_owners_lru;
	struct list_head layouts;
	struct list_head delegations;
	struct list_head ss_copies;
	long unsigned int mig_gen;
	long unsigned int mig_status;
	void (*destroy)(struct nfs_server *);
	atomic_t active;
	struct __kernel_sockaddr_storage mountd_address;
	size_t mountd_addrlen;
	u32 mountd_version;
	short unsigned int mountd_port;
	short unsigned int mountd_protocol;
	struct rpc_wait_queue uoc_rpcwaitq;
	unsigned int read_hdrsize;
	const struct cred *cred;
	bool has_sec_mnt_opts;
};

struct nfs_subversion;

struct idmap;

struct nfs4_slot_table;

struct nfs4_session;

struct nfs_rpc_ops;

struct nfs4_minor_version_ops;

struct nfs41_server_owner;

struct nfs41_server_scope;

struct nfs41_impl_id;

struct nfs_client {
	refcount_t cl_count;
	atomic_t cl_mds_count;
	int cl_cons_state;
	long unsigned int cl_res_state;
	long unsigned int cl_flags;
	struct __kernel_sockaddr_storage cl_addr;
	size_t cl_addrlen;
	char *cl_hostname;
	char *cl_acceptor;
	struct list_head cl_share_link;
	struct list_head cl_superblocks;
	struct rpc_clnt *cl_rpcclient;
	const struct nfs_rpc_ops *rpc_ops;
	int cl_proto;
	struct nfs_subversion *cl_nfs_mod;
	u32 cl_minorversion;
	unsigned int cl_nconnect;
	const char *cl_principal;
	struct list_head cl_ds_clients;
	u64 cl_clientid;
	nfs4_verifier cl_confirm;
	long unsigned int cl_state;
	spinlock_t cl_lock;
	long unsigned int cl_lease_time;
	long unsigned int cl_last_renewal;
	struct delayed_work cl_renewd;
	struct rpc_wait_queue cl_rpcwaitq;
	struct idmap *cl_idmap;
	const char *cl_owner_id;
	u32 cl_cb_ident;
	const struct nfs4_minor_version_ops *cl_mvops;
	long unsigned int cl_mig_gen;
	struct nfs4_slot_table *cl_slot_tbl;
	u32 cl_seqid;
	u32 cl_exchange_flags;
	struct nfs4_session *cl_session;
	bool cl_preserve_clid;
	struct nfs41_server_owner *cl_serverowner;
	struct nfs41_server_scope *cl_serverscope;
	struct nfs41_impl_id *cl_implid;
	long unsigned int cl_sp4_flags;
	wait_queue_head_t cl_lock_waitq;
	char cl_ipaddr[48];
	struct fscache_cookie *fscache;
	struct net *cl_net;
	struct list_head pending_cb_stateids;
};

struct pnfs_layout_segment;

struct nfs_write_verifier {
	char data[8];
};

struct nfs_writeverf {
	struct nfs_write_verifier verifier;
	enum nfs3_stable_how committed;
};

struct nfs_pgio_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct nfs_open_context *context;
	struct nfs_lock_context *lock_context;
	nfs4_stateid stateid;
	__u64 offset;
	__u32 count;
	unsigned int pgbase;
	struct page **pages;
	union {
		unsigned int replen;
		struct {
			const u32 *bitmask;
			u32 bitmask_store[3];
			enum nfs3_stable_how stable;
		};
	};
};

struct nfs_pgio_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	__u64 count;
	__u32 op_status;
	union {
		struct {
			unsigned int replen;
			int eof;
		};
		struct {
			struct nfs_writeverf *verf;
			const struct nfs_server *server;
		};
	};
};

struct nfs_commitargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	__u64 offset;
	__u32 count;
	const u32 *bitmask;
};

struct nfs_commitres {
	struct nfs4_sequence_res seq_res;
	__u32 op_status;
	struct nfs_fattr *fattr;
	struct nfs_writeverf *verf;
	const struct nfs_server *server;
};

struct nfs_removeargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	struct qstr name;
};

struct nfs_removeres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs_fattr *dir_attr;
	struct nfs4_change_info cinfo;
};

struct nfs_renameargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *old_dir;
	const struct nfs_fh *new_dir;
	const struct qstr *old_name;
	const struct qstr *new_name;
};

struct nfs_renameres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs4_change_info old_cinfo;
	struct nfs_fattr *old_fattr;
	struct nfs4_change_info new_cinfo;
	struct nfs_fattr *new_fattr;
};

struct nfs_entry {
	__u64 ino;
	__u64 cookie;
	__u64 prev_cookie;
	const char *name;
	unsigned int len;
	int eof;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	struct nfs4_label *label;
	unsigned char d_type;
	struct nfs_server *server;
};

struct nfs_readdir_arg {
	struct dentry *dentry;
	const struct cred *cred;
	__be32 *verf;
	u64 cookie;
	struct page **pages;
	unsigned int page_len;
	bool plus;
};

struct nfs_readdir_res {
	__be32 *verf;
};

struct nfstime4 {
	u64 seconds;
	u32 nseconds;
};

struct pnfs_commit_ops;

struct pnfs_ds_commit_info {
	struct list_head commits;
	unsigned int nwritten;
	unsigned int ncommitting;
	const struct pnfs_commit_ops *ops;
};

struct nfs41_server_owner {
	uint64_t minor_id;
	uint32_t major_id_sz;
	char major_id[1024];
};

struct nfs41_server_scope {
	uint32_t server_scope_sz;
	char server_scope[1024];
};

struct nfs41_impl_id {
	char domain[1025];
	char name[1025];
	struct nfstime4 date;
};

struct nfs_page_array {
	struct page **pagevec;
	unsigned int npages;
	struct page *page_array[8];
};

struct nfs_page;

struct nfs_rw_ops;

struct nfs_io_completion;

struct nfs_direct_req;

struct nfs_pgio_completion_ops;

struct nfs_pgio_header {
	struct inode *inode;
	const struct cred *cred;
	struct list_head pages;
	struct nfs_page *req;
	struct nfs_writeverf verf;
	fmode_t rw_mode;
	struct pnfs_layout_segment *lseg;
	loff_t io_start;
	const struct rpc_call_ops *mds_ops;
	void (*release)(struct nfs_pgio_header *);
	const struct nfs_pgio_completion_ops *completion_ops;
	const struct nfs_rw_ops *rw_ops;
	struct nfs_io_completion *io_completion;
	struct nfs_direct_req *dreq;
	int pnfs_error;
	int error;
	unsigned int good_bytes;
	long unsigned int flags;
	struct rpc_task task;
	struct nfs_fattr fattr;
	struct nfs_pgio_args args;
	struct nfs_pgio_res res;
	long unsigned int timestamp;
	int (*pgio_done_cb)(struct rpc_task *, struct nfs_pgio_header *);
	__u64 mds_offset;
	struct nfs_page_array page_array;
	struct nfs_client *ds_clp;
	u32 ds_commit_idx;
	u32 pgio_mirror_idx;
};

struct nfs_pgio_completion_ops {
	void (*error_cleanup)(struct list_head *, int);
	void (*init_hdr)(struct nfs_pgio_header *);
	void (*completion)(struct nfs_pgio_header *);
	void (*reschedule_io)(struct nfs_pgio_header *);
};

struct nfs_mds_commit_info {
	atomic_t rpcs_out;
	atomic_long_t ncommit;
	struct list_head list;
};

struct nfs_commit_data;

struct nfs_commit_info;

struct nfs_commit_completion_ops {
	void (*completion)(struct nfs_commit_data *);
	void (*resched_write)(struct nfs_commit_info *, struct nfs_page *);
};

struct nfs_commit_data {
	struct rpc_task task;
	struct inode *inode;
	const struct cred *cred;
	struct nfs_fattr fattr;
	struct nfs_writeverf verf;
	struct list_head pages;
	struct list_head list;
	struct nfs_direct_req *dreq;
	struct nfs_commitargs args;
	struct nfs_commitres res;
	struct nfs_open_context *context;
	struct pnfs_layout_segment *lseg;
	struct nfs_client *ds_clp;
	int ds_commit_index;
	loff_t lwb;
	const struct rpc_call_ops *mds_ops;
	const struct nfs_commit_completion_ops *completion_ops;
	int (*commit_done_cb)(struct rpc_task *, struct nfs_commit_data *);
	long unsigned int flags;
};

struct nfs_commit_info {
	struct inode *inode;
	struct nfs_mds_commit_info *mds;
	struct pnfs_ds_commit_info *ds;
	struct nfs_direct_req *dreq;
	const struct nfs_commit_completion_ops *completion_ops;
};

struct nfs_unlinkdata {
	struct nfs_removeargs args;
	struct nfs_removeres res;
	struct dentry *dentry;
	wait_queue_head_t wq;
	const struct cred *cred;
	struct nfs_fattr dir_attr;
	long int timeout;
};

struct nfs_renamedata {
	struct nfs_renameargs args;
	struct nfs_renameres res;
	const struct cred *cred;
	struct inode *old_dir;
	struct dentry *old_dentry;
	struct nfs_fattr old_fattr;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct nfs_fattr new_fattr;
	void (*complete)(struct rpc_task *, struct nfs_renamedata *);
	long int timeout;
	bool cancelled;
};

struct nlmclnt_operations;

struct nfs_client_initdata;

struct nfs_access_entry;

struct nfs_rpc_ops {
	u32 version;
	const struct dentry_operations *dentry_ops;
	const struct inode_operations *dir_inode_ops;
	const struct inode_operations *file_inode_ops;
	const struct file_operations *file_ops;
	const struct nlmclnt_operations *nlmclnt_ops;
	int (*getroot)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*submount)(struct fs_context *, struct nfs_server *);
	int (*try_get_tree)(struct fs_context *);
	int (*getattr)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, struct nfs4_label *, struct inode *);
	int (*setattr)(struct dentry *, struct nfs_fattr *, struct iattr *);
	int (*lookup)(struct inode *, struct dentry *, struct nfs_fh *, struct nfs_fattr *, struct nfs4_label *);
	int (*lookupp)(struct inode *, struct nfs_fh *, struct nfs_fattr *, struct nfs4_label *);
	int (*access)(struct inode *, struct nfs_access_entry *);
	int (*readlink)(struct inode *, struct page *, unsigned int, unsigned int);
	int (*create)(struct inode *, struct dentry *, struct iattr *, int);
	int (*remove)(struct inode *, struct dentry *);
	void (*unlink_setup)(struct rpc_message *, struct dentry *, struct inode *);
	void (*unlink_rpc_prepare)(struct rpc_task *, struct nfs_unlinkdata *);
	int (*unlink_done)(struct rpc_task *, struct inode *);
	void (*rename_setup)(struct rpc_message *, struct dentry *, struct dentry *);
	void (*rename_rpc_prepare)(struct rpc_task *, struct nfs_renamedata *);
	int (*rename_done)(struct rpc_task *, struct inode *, struct inode *);
	int (*link)(struct inode *, struct inode *, const struct qstr *);
	int (*symlink)(struct inode *, struct dentry *, struct page *, unsigned int, struct iattr *);
	int (*mkdir)(struct inode *, struct dentry *, struct iattr *);
	int (*rmdir)(struct inode *, const struct qstr *);
	int (*readdir)(struct nfs_readdir_arg *, struct nfs_readdir_res *);
	int (*mknod)(struct inode *, struct dentry *, struct iattr *, dev_t);
	int (*statfs)(struct nfs_server *, struct nfs_fh *, struct nfs_fsstat *);
	int (*fsinfo)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*pathconf)(struct nfs_server *, struct nfs_fh *, struct nfs_pathconf *);
	int (*set_capabilities)(struct nfs_server *, struct nfs_fh *);
	int (*decode_dirent)(struct xdr_stream *, struct nfs_entry *, bool);
	int (*pgio_rpc_prepare)(struct rpc_task *, struct nfs_pgio_header *);
	void (*read_setup)(struct nfs_pgio_header *, struct rpc_message *);
	int (*read_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*write_setup)(struct nfs_pgio_header *, struct rpc_message *, struct rpc_clnt **);
	int (*write_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*commit_setup)(struct nfs_commit_data *, struct rpc_message *, struct rpc_clnt **);
	void (*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
	int (*commit_done)(struct rpc_task *, struct nfs_commit_data *);
	int (*lock)(struct file *, int, struct file_lock *);
	int (*lock_check_bounds)(const struct file_lock *);
	void (*clear_acl_cache)(struct inode *);
	void (*close_context)(struct nfs_open_context *, int);
	struct inode * (*open_context)(struct inode *, struct nfs_open_context *, int, struct iattr *, int *);
	int (*have_delegation)(struct inode *, fmode_t);
	struct nfs_client * (*alloc_client)(const struct nfs_client_initdata *);
	struct nfs_client * (*init_client)(struct nfs_client *, const struct nfs_client_initdata *);
	void (*free_client)(struct nfs_client *);
	struct nfs_server * (*create_server)(struct fs_context *);
	struct nfs_server * (*clone_server)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, rpc_authflavor_t);
};

struct nfs_access_entry {
	struct rb_node rb_node;
	struct list_head lru;
	const struct cred *cred;
	__u32 mask;
	struct callback_head callback_head;
};

struct nfs_seqid;

struct nfs_seqid_counter;

struct nfs4_state_recovery_ops;

struct nfs4_state_maintenance_ops;

struct nfs4_mig_recovery_ops;

struct nfs4_minor_version_ops {
	u32 minor_version;
	unsigned int init_caps;
	int (*init_client)(struct nfs_client *);
	void (*shutdown_client)(struct nfs_client *);
	bool (*match_stateid)(const nfs4_stateid *, const nfs4_stateid *);
	int (*find_root_sec)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	void (*free_lock_state)(struct nfs_server *, struct nfs4_lock_state *);
	int (*test_and_free_expired)(struct nfs_server *, nfs4_stateid *, const struct cred *);
	struct nfs_seqid * (*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);
	void (*session_trunk)(struct rpc_clnt *, struct rpc_xprt *, void *);
	const struct rpc_call_ops *call_sync_ops;
	const struct nfs4_state_recovery_ops *reboot_recovery_ops;
	const struct nfs4_state_recovery_ops *nograce_recovery_ops;
	const struct nfs4_state_maintenance_ops *state_renewal_ops;
	const struct nfs4_mig_recovery_ops *mig_recovery_ops;
};

enum perf_branch_sample_type_shift {
	PERF_SAMPLE_BRANCH_USER_SHIFT = 0,
	PERF_SAMPLE_BRANCH_KERNEL_SHIFT = 1,
	PERF_SAMPLE_BRANCH_HV_SHIFT = 2,
	PERF_SAMPLE_BRANCH_ANY_SHIFT = 3,
	PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT = 4,
	PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 5,
	PERF_SAMPLE_BRANCH_IND_CALL_SHIFT = 6,
	PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT = 7,
	PERF_SAMPLE_BRANCH_IN_TX_SHIFT = 8,
	PERF_SAMPLE_BRANCH_NO_TX_SHIFT = 9,
	PERF_SAMPLE_BRANCH_COND_SHIFT = 10,
	PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 11,
	PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT = 12,
	PERF_SAMPLE_BRANCH_CALL_SHIFT = 13,
	PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT = 14,
	PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT = 15,
	PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT = 16,
	PERF_SAMPLE_BRANCH_HW_INDEX_SHIFT = 17,
	PERF_SAMPLE_BRANCH_MAX_SHIFT = 18,
};

struct uuidcmp {
	const char *uuid;
	int len;
};

struct subprocess_info {
	struct work_struct work;
	struct completion *complete;
	const char *path;
	char **argv;
	char **envp;
	int wait;
	int retval;
	int (*init)(struct subprocess_info *, struct cred *);
	void (*cleanup)(struct subprocess_info *);
	void *data;
};

struct __va_list {
	void *__stack;
	void *__gr_top;
	void *__vr_top;
	int __gr_offs;
	int __vr_offs;
};

typedef struct __va_list __gnuc_va_list;

typedef __gnuc_va_list va_list;

typedef u64 async_cookie_t;

typedef void (*async_func_t)(void *, async_cookie_t);

struct async_domain {
	struct list_head pending;
	unsigned int registered: 1;
};

enum umh_disable_depth {
	UMH_ENABLED = 0,
	UMH_FREEZING = 1,
	UMH_DISABLED = 2,
};

typedef __u64 Elf64_Off;

struct elf64_hdr {
	unsigned char e_ident[16];
	Elf64_Half e_type;
	Elf64_Half e_machine;
	Elf64_Word e_version;
	Elf64_Addr e_entry;
	Elf64_Off e_phoff;
	Elf64_Off e_shoff;
	Elf64_Word e_flags;
	Elf64_Half e_ehsize;
	Elf64_Half e_phentsize;
	Elf64_Half e_phnum;
	Elf64_Half e_shentsize;
	Elf64_Half e_shnum;
	Elf64_Half e_shstrndx;
};

typedef struct elf64_hdr Elf64_Ehdr;

struct elf64_shdr {
	Elf64_Word sh_name;
	Elf64_Word sh_type;
	Elf64_Xword sh_flags;
	Elf64_Addr sh_addr;
	Elf64_Off sh_offset;
	Elf64_Xword sh_size;
	Elf64_Word sh_link;
	Elf64_Word sh_info;
	Elf64_Xword sh_addralign;
	Elf64_Xword sh_entsize;
};

typedef struct elf64_shdr Elf64_Shdr;

struct hash {
	int ino;
	int minor;
	int major;
	umode_t mode;
	struct hash *next;
	char name[4098];
};

struct dir_entry {
	struct list_head list;
	char *name;
	time64_t mtime;
};

enum state {
	Start = 0,
	Collect = 1,
	GotHeader = 2,
	SkipIt = 3,
	GotName = 4,
	CopyFile = 5,
	GotSymlink = 6,
	Reset = 7,
};

typedef int (*decompress_fn)(unsigned char *, long int, long int (*)(void *, long unsigned int), long int (*)(void *, long unsigned int), unsigned char *, long int *, void (*)(char *));

typedef u32 note_buf_t[106];

struct kimage_arch {
	void *dtb;
	phys_addr_t dtb_mem;
	phys_addr_t kern_reloc;
};

typedef int kexec_probe_t(const char *, long unsigned int);

struct kimage;

typedef void *kexec_load_t(struct kimage *, char *, long unsigned int, char *, long unsigned int, char *, long unsigned int);

typedef int kexec_cleanup_t(void *);

typedef int kexec_verify_sig_t(const char *, long unsigned int);

struct kexec_file_ops {
	kexec_probe_t *probe;
	kexec_load_t *load;
	kexec_cleanup_t *cleanup;
	kexec_verify_sig_t *verify_sig;
};

typedef long unsigned int kimage_entry_t;

struct kexec_segment {
	union {
		void *buf;
		void *kbuf;
	};
	size_t bufsz;
	long unsigned int mem;
	size_t memsz;
};

struct purgatory_info {
	const Elf64_Ehdr *ehdr;
	Elf64_Shdr *sechdrs;
	void *purgatory_buf;
};

struct kimage {
	kimage_entry_t head;
	kimage_entry_t *entry;
	kimage_entry_t *last_entry;
	long unsigned int start;
	struct page *control_code_page;
	struct page *swap_page;
	void *vmcoreinfo_data_copy;
	long unsigned int nr_segments;
	struct kexec_segment segment[16];
	struct list_head control_pages;
	struct list_head dest_pages;
	struct list_head unusable_pages;
	long unsigned int control_page;
	unsigned int type: 1;
	unsigned int preserve_context: 1;
	unsigned int file_mode: 1;
	struct kimage_arch arch;
	void *kernel_buf;
	long unsigned int kernel_buf_len;
	void *initrd_buf;
	long unsigned int initrd_buf_len;
	char *cmdline_buf;
	long unsigned int cmdline_buf_len;
	const struct kexec_file_ops *fops;
	void *image_loader_data;
	struct purgatory_info purgatory_info;
	void *ima_buffer;
	phys_addr_t ima_buffer_addr;
	size_t ima_buffer_size;
	void *elf_headers;
	long unsigned int elf_headers_sz;
	long unsigned int elf_load_addr;
};

enum audit_ntp_type {
	AUDIT_NTP_OFFSET = 0,
	AUDIT_NTP_FREQ = 1,
	AUDIT_NTP_STATUS = 2,
	AUDIT_NTP_TAI = 3,
	AUDIT_NTP_TICK = 4,
	AUDIT_NTP_ADJUST = 5,
	AUDIT_NTP_NVALS = 6,
};

typedef long int (*syscall_fn_t)(const struct pt_regs *);

typedef long unsigned int uintptr_t;

struct step_hook {
	struct list_head node;
	int (*fn)(struct pt_regs *, unsigned int);
};

struct break_hook {
	struct list_head node;
	int (*fn)(struct pt_regs *, unsigned int);
	u16 imm;
	u16 mask;
};

enum dbg_active_el {
	DBG_ACTIVE_EL0 = 0,
	DBG_ACTIVE_EL1 = 1,
};

enum migratetype {
	MIGRATE_UNMOVABLE = 0,
	MIGRATE_MOVABLE = 1,
	MIGRATE_RECLAIMABLE = 2,
	MIGRATE_PCPTYPES = 3,
	MIGRATE_HIGHATOMIC = 3,
	MIGRATE_CMA = 4,
	MIGRATE_ISOLATE = 5,
	MIGRATE_TYPES = 6,
};

enum numa_stat_item {
	NUMA_HIT = 0,
	NUMA_MISS = 1,
	NUMA_FOREIGN = 2,
	NUMA_INTERLEAVE_HIT = 3,
	NUMA_LOCAL = 4,
	NUMA_OTHER = 5,
	NR_VM_NUMA_STAT_ITEMS = 6,
};

enum zone_stat_item {
	NR_FREE_PAGES = 0,
	NR_ZONE_LRU_BASE = 1,
	NR_ZONE_INACTIVE_ANON = 1,
	NR_ZONE_ACTIVE_ANON = 2,
	NR_ZONE_INACTIVE_FILE = 3,
	NR_ZONE_ACTIVE_FILE = 4,
	NR_ZONE_UNEVICTABLE = 5,
	NR_ZONE_WRITE_PENDING = 6,
	NR_MLOCK = 7,
	NR_BOUNCE = 8,
	NR_ZSPAGES = 9,
	NR_FREE_CMA_PAGES = 10,
	NR_VM_ZONE_STAT_ITEMS = 11,
};

enum zone_watermarks {
	WMARK_MIN = 0,
	WMARK_LOW = 1,
	WMARK_HIGH = 2,
	NR_WMARK = 3,
};

enum {
	ZONELIST_FALLBACK = 0,
	ZONELIST_NOFALLBACK = 1,
	MAX_ZONELISTS = 2,
};

enum cpu_idle_type {
	CPU_IDLE = 0,
	CPU_NOT_IDLE = 1,
	CPU_NEWLY_IDLE = 2,
	CPU_MAX_IDLE_TYPES = 3,
};

enum {
	__SD_BALANCE_NEWIDLE = 0,
	__SD_BALANCE_EXEC = 1,
	__SD_BALANCE_FORK = 2,
	__SD_BALANCE_WAKE = 3,
	__SD_WAKE_AFFINE = 4,
	__SD_ASYM_CPUCAPACITY = 5,
	__SD_SHARE_CPUCAPACITY = 6,
	__SD_SHARE_PKG_RESOURCES = 7,
	__SD_SERIALIZE = 8,
	__SD_ASYM_PACKING = 9,
	__SD_PREFER_SIBLING = 10,
	__SD_OVERLAP = 11,
	__SD_NUMA = 12,
	__SD_FLAG_CNT = 13,
};

enum {
	DQF_ROOT_SQUASH_B = 0,
	DQF_SYS_FILE_B = 16,
	DQF_PRIVATE = 17,
};

enum {
	DQST_LOOKUPS = 0,
	DQST_DROPS = 1,
	DQST_READS = 2,
	DQST_WRITES = 3,
	DQST_CACHE_HITS = 4,
	DQST_ALLOC_DQUOTS = 5,
	DQST_FREE_DQUOTS = 6,
	DQST_SYNCS = 7,
	_DQST_DQSTAT_LAST = 8,
};

enum {
	SB_UNFROZEN = 0,
	SB_FREEZE_WRITE = 1,
	SB_FREEZE_PAGEFAULT = 2,
	SB_FREEZE_FS = 3,
	SB_FREEZE_COMPLETE = 4,
};

enum compound_dtor_id {
	NULL_COMPOUND_DTOR = 0,
	COMPOUND_PAGE_DTOR = 1,
	HUGETLB_PAGE_DTOR = 2,
	TRANSHUGE_PAGE_DTOR = 3,
	NR_COMPOUND_DTORS = 4,
};

enum {
	HI_SOFTIRQ = 0,
	TIMER_SOFTIRQ = 1,
	NET_TX_SOFTIRQ = 2,
	NET_RX_SOFTIRQ = 3,
	BLOCK_SOFTIRQ = 4,
	IRQ_POLL_SOFTIRQ = 5,
	TASKLET_SOFTIRQ = 6,
	SCHED_SOFTIRQ = 7,
	HRTIMER_SOFTIRQ = 8,
	RCU_SOFTIRQ = 9,
	NR_SOFTIRQS = 10,
};

enum {
	TSK_TRACE_FL_TRACE_BIT = 0,
	TSK_TRACE_FL_GRAPH_BIT = 1,
};

struct midr_range {
	u32 model;
	u32 rv_min;
	u32 rv_max;
};

struct arm64_midr_revidr {
	u32 midr_rv;
	u32 revidr_mask;
};

struct arm64_cpu_capabilities {
	const char *desc;
	u16 capability;
	u16 type;
	bool (*matches)(const struct arm64_cpu_capabilities *, int);
	void (*cpu_enable)(const struct arm64_cpu_capabilities *);
	union {
		struct {
			struct midr_range midr_range;
			const struct arm64_midr_revidr * const fixed_revs;
		};
		const struct midr_range *midr_range_list;
		struct {
			u32 sys_reg;
			u8 field_pos;
			u8 min_field_value;
			u8 hwcap_type;
			bool sign;
			long unsigned int hwcap;
		};
	};
	const struct arm64_cpu_capabilities *match_list;
};

enum cpu_pm_event {
	CPU_PM_ENTER = 0,
	CPU_PM_ENTER_FAILED = 1,
	CPU_PM_EXIT = 2,
	CPU_CLUSTER_PM_ENTER = 3,
	CPU_CLUSTER_PM_ENTER_FAILED = 4,
	CPU_CLUSTER_PM_EXIT = 5,
};

struct fpsimd_last_state_struct {
	struct user_fpsimd_state *st;
	void *sve_state;
	unsigned int sve_vl;
};

enum ctx_state {
	CONTEXT_DISABLED = 4294967295,
	CONTEXT_KERNEL = 0,
	CONTEXT_USER = 1,
	CONTEXT_GUEST = 2,
};

struct plist_head {
	struct list_head node_list;
};

enum pm_qos_type {
	PM_QOS_UNITIALIZED = 0,
	PM_QOS_MAX = 1,
	PM_QOS_MIN = 2,
};

struct pm_qos_constraints {
	struct plist_head list;
	s32 target_value;
	s32 default_value;
	s32 no_constraint_value;
	enum pm_qos_type type;
	struct blocking_notifier_head *notifiers;
};

struct freq_constraints {
	struct pm_qos_constraints min_freq;
	struct blocking_notifier_head min_freq_notifiers;
	struct pm_qos_constraints max_freq;
	struct blocking_notifier_head max_freq_notifiers;
};

struct pm_qos_flags {
	struct list_head list;
	s32 effective_flags;
};

struct dev_pm_qos_request;

struct dev_pm_qos {
	struct pm_qos_constraints resume_latency;
	struct pm_qos_constraints latency_tolerance;
	struct freq_constraints freq;
	struct pm_qos_flags flags;
	struct dev_pm_qos_request *resume_latency_req;
	struct dev_pm_qos_request *latency_tolerance_req;
	struct dev_pm_qos_request *flags_req;
};

struct arch_elf_state {
	int flags;
};

struct pm_qos_flags_request {
	struct list_head node;
	s32 flags;
};

enum freq_qos_req_type {
	FREQ_QOS_MIN = 1,
	FREQ_QOS_MAX = 2,
};

struct freq_qos_request {
	enum freq_qos_req_type type;
	struct plist_node pnode;
	struct freq_constraints *qos;
};

enum dev_pm_qos_req_type {
	DEV_PM_QOS_RESUME_LATENCY = 1,
	DEV_PM_QOS_LATENCY_TOLERANCE = 2,
	DEV_PM_QOS_MIN_FREQUENCY = 3,
	DEV_PM_QOS_MAX_FREQUENCY = 4,
	DEV_PM_QOS_FLAGS = 5,
};

struct dev_pm_qos_request {
	enum dev_pm_qos_req_type type;
	union {
		struct plist_node pnode;
		struct pm_qos_flags_request flr;
		struct freq_qos_request freq;
	} data;
	struct device *dev;
};

enum cpufreq_table_sorting {
	CPUFREQ_TABLE_UNSORTED = 0,
	CPUFREQ_TABLE_SORTED_ASCENDING = 1,
	CPUFREQ_TABLE_SORTED_DESCENDING = 2,
};

struct cpufreq_cpuinfo {
	unsigned int max_freq;
	unsigned int min_freq;
	unsigned int transition_latency;
};

struct clk;

struct cpufreq_governor;

struct cpufreq_frequency_table;

struct cpufreq_stats;

struct thermal_cooling_device;

struct cpufreq_policy {
	cpumask_var_t cpus;
	cpumask_var_t related_cpus;
	cpumask_var_t real_cpus;
	unsigned int shared_type;
	unsigned int cpu;
	struct clk *clk;
	struct cpufreq_cpuinfo cpuinfo;
	unsigned int min;
	unsigned int max;
	unsigned int cur;
	unsigned int suspend_freq;
	unsigned int policy;
	unsigned int last_policy;
	struct cpufreq_governor *governor;
	void *governor_data;
	char last_governor[16];
	struct work_struct update;
	struct freq_constraints constraints;
	struct freq_qos_request *min_freq_req;
	struct freq_qos_request *max_freq_req;
	struct cpufreq_frequency_table *freq_table;
	enum cpufreq_table_sorting freq_table_sorted;
	struct list_head policy_list;
	struct kobject kobj;
	struct completion kobj_unregister;
	struct rw_semaphore rwsem;
	bool fast_switch_possible;
	bool fast_switch_enabled;
	bool strict_target;
	unsigned int transition_delay_us;
	bool dvfs_possible_from_any_cpu;
	unsigned int cached_target_freq;
	unsigned int cached_resolved_idx;
	bool transition_ongoing;
	spinlock_t transition_lock;
	wait_queue_head_t transition_wait;
	struct task_struct *transition_task;
	struct cpufreq_stats *stats;
	void *driver_data;
	struct thermal_cooling_device *cdev;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct cpufreq_governor {
	char name[16];
	int (*init)(struct cpufreq_policy *);
	void (*exit)(struct cpufreq_policy *);
	int (*start)(struct cpufreq_policy *);
	void (*stop)(struct cpufreq_policy *);
	void (*limits)(struct cpufreq_policy *);
	ssize_t (*show_setspeed)(struct cpufreq_policy *, char *);
	int (*store_setspeed)(struct cpufreq_policy *, unsigned int);
	struct list_head governor_list;
	struct module *owner;
	u8 flags;
};

struct cpufreq_frequency_table {
	unsigned int flags;
	unsigned int driver_data;
	unsigned int frequency;
};

struct freq_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpufreq_policy *, char *);
	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t);
};

enum stack_type {
	STACK_TYPE_UNKNOWN = 0,
	STACK_TYPE_TASK = 1,
	STACK_TYPE_IRQ = 2,
	STACK_TYPE_OVERFLOW = 3,
	STACK_TYPE_SDEI_NORMAL = 4,
	STACK_TYPE_SDEI_CRITICAL = 5,
	__NR_STACK_TYPES = 6,
};

struct stackframe {
	long unsigned int fp;
	long unsigned int pc;
	long unsigned int stacks_done[1];
	long unsigned int prev_fp;
	enum stack_type prev_type;
	int graph;
};

struct user_sve_header {
	__u32 size;
	__u32 max_size;
	__u16 vl;
	__u16 max_vl;
	__u16 flags;
	__u16 __reserved;
};

struct user_pac_mask {
	__u64 data_mask;
	__u64 insn_mask;
};

struct user_pac_address_keys {
	__int128 unsigned apiakey;
	__int128 unsigned apibkey;
	__int128 unsigned apdakey;
	__int128 unsigned apdbkey;
};

struct user_pac_generic_keys {
	__int128 unsigned apgakey;
};

typedef u32 compat_ulong_t;

enum perf_type_id {
	PERF_TYPE_HARDWARE = 0,
	PERF_TYPE_SOFTWARE = 1,
	PERF_TYPE_TRACEPOINT = 2,
	PERF_TYPE_HW_CACHE = 3,
	PERF_TYPE_RAW = 4,
	PERF_TYPE_BREAKPOINT = 5,
	PERF_TYPE_MAX = 6,
};

enum {
	TASKSTATS_CMD_UNSPEC = 0,
	TASKSTATS_CMD_GET = 1,
	TASKSTATS_CMD_NEW = 2,
	__TASKSTATS_CMD_MAX = 3,
};

enum ucount_type {
	UCOUNT_USER_NAMESPACES = 0,
	UCOUNT_PID_NAMESPACES = 1,
	UCOUNT_UTS_NAMESPACES = 2,
	UCOUNT_IPC_NAMESPACES = 3,
	UCOUNT_NET_NAMESPACES = 4,
	UCOUNT_MNT_NAMESPACES = 5,
	UCOUNT_CGROUP_NAMESPACES = 6,
	UCOUNT_TIME_NAMESPACES = 7,
	UCOUNT_INOTIFY_INSTANCES = 8,
	UCOUNT_INOTIFY_WATCHES = 9,
	UCOUNT_FANOTIFY_GROUPS = 10,
	UCOUNT_FANOTIFY_MARKS = 11,
	UCOUNT_COUNTS = 12,
};

enum cpu_usage_stat {
	CPUTIME_USER = 0,
	CPUTIME_NICE = 1,
	CPUTIME_SYSTEM = 2,
	CPUTIME_SOFTIRQ = 3,
	CPUTIME_IRQ = 4,
	CPUTIME_IDLE = 5,
	CPUTIME_IOWAIT = 6,
	CPUTIME_STEAL = 7,
	CPUTIME_GUEST = 8,
	CPUTIME_GUEST_NICE = 9,
	NR_STATS = 10,
};

enum bpf_cgroup_storage_type {
	BPF_CGROUP_STORAGE_SHARED = 0,
	BPF_CGROUP_STORAGE_PERCPU = 1,
	__BPF_CGROUP_STORAGE_MAX = 2,
};

enum bpf_tramp_prog_type {
	BPF_TRAMP_FENTRY = 0,
	BPF_TRAMP_FEXIT = 1,
	BPF_TRAMP_MODIFY_RETURN = 2,
	BPF_TRAMP_MAX = 3,
	BPF_TRAMP_REPLACE = 4,
};

enum psi_task_count {
	NR_IOWAIT = 0,
	NR_MEMSTALL = 1,
	NR_RUNNING = 2,
	NR_ONCPU = 3,
	NR_MEMSTALL_RUNNING = 4,
	NR_PSI_TASK_COUNTS = 5,
};

enum psi_states {
	PSI_IO_SOME = 0,
	PSI_IO_FULL = 1,
	PSI_MEM_SOME = 2,
	PSI_MEM_FULL = 3,
	PSI_CPU_SOME = 4,
	PSI_CPU_FULL = 5,
	PSI_NONIDLE = 6,
	NR_PSI_STATES = 7,
};

enum psi_aggregators {
	PSI_AVGS = 0,
	PSI_POLL = 1,
	NR_PSI_AGGREGATORS = 2,
};

enum cgroup_subsys_id {
	cpuset_cgrp_id = 0,
	cpu_cgrp_id = 1,
	cpuacct_cgrp_id = 2,
	io_cgrp_id = 3,
	memory_cgrp_id = 4,
	devices_cgrp_id = 5,
	freezer_cgrp_id = 6,
	net_cls_cgrp_id = 7,
	perf_event_cgrp_id = 8,
	net_prio_cgrp_id = 9,
	hugetlb_cgrp_id = 10,
	pids_cgrp_id = 11,
	rdma_cgrp_id = 12,
	misc_cgrp_id = 13,
	CGROUP_SUBSYS_COUNT = 14,
};

enum {
	HW_BREAKPOINT_LEN_1 = 1,
	HW_BREAKPOINT_LEN_2 = 2,
	HW_BREAKPOINT_LEN_3 = 3,
	HW_BREAKPOINT_LEN_4 = 4,
	HW_BREAKPOINT_LEN_5 = 5,
	HW_BREAKPOINT_LEN_6 = 6,
	HW_BREAKPOINT_LEN_7 = 7,
	HW_BREAKPOINT_LEN_8 = 8,
};

enum {
	HW_BREAKPOINT_EMPTY = 0,
	HW_BREAKPOINT_R = 1,
	HW_BREAKPOINT_W = 2,
	HW_BREAKPOINT_RW = 3,
	HW_BREAKPOINT_X = 4,
	HW_BREAKPOINT_INVALID = 7,
};

enum bp_type_idx {
	TYPE_INST = 0,
	TYPE_DATA = 1,
	TYPE_MAX = 2,
};

struct membuf {
	void *p;
	size_t left;
};

struct user_regset;

typedef int user_regset_active_fn(struct task_struct *, const struct user_regset *);

typedef int user_regset_get2_fn(struct task_struct *, const struct user_regset *, struct membuf);

typedef int user_regset_set_fn(struct task_struct *, const struct user_regset *, unsigned int, unsigned int, const void *, const void *);

typedef int user_regset_writeback_fn(struct task_struct *, const struct user_regset *, int);

struct user_regset {
	user_regset_get2_fn *regset_get;
	user_regset_set_fn *set;
	user_regset_active_fn *active;
	user_regset_writeback_fn *writeback;
	unsigned int n;
	unsigned int size;
	unsigned int align;
	unsigned int bias;
	unsigned int core_note_type;
};

struct user_regset_view {
	const char *name;
	const struct user_regset *regsets;
	unsigned int n;
	u32 e_flags;
	u16 e_machine;
	u8 ei_osabi;
};

struct stack_info {
	long unsigned int low;
	long unsigned int high;
	enum stack_type type;
};

struct trace_event_raw_sys_enter {
	struct trace_entry ent;
	long int id;
	long unsigned int args[6];
	char __data[0];
};

struct trace_event_raw_sys_exit {
	struct trace_entry ent;
	long int id;
	long int ret;
	char __data[0];
};

struct trace_event_data_offsets_sys_enter {};

struct trace_event_data_offsets_sys_exit {};

typedef void (*btf_trace_sys_enter)(void *, struct pt_regs *, long int);

typedef void (*btf_trace_sys_exit)(void *, struct pt_regs *, long int);

struct pt_regs_offset {
	const char *name;
	int offset;
};

enum aarch64_regset {
	REGSET_GPR = 0,
	REGSET_FPR = 1,
	REGSET_TLS = 2,
	REGSET_HW_BREAK = 3,
	REGSET_HW_WATCH = 4,
	REGSET_SYSTEM_CALL = 5,
	REGSET_SVE = 6,
	REGSET_PAC_MASK = 7,
	REGSET_PAC_ENABLED_KEYS = 8,
	REGSET_PACA_KEYS = 9,
	REGSET_PACG_KEYS = 10,
	REGSET_TAGGED_ADDR_CTRL = 11,
};

enum compat_regset {
	REGSET_COMPAT_GPR = 0,
	REGSET_COMPAT_VFP = 1,
};

enum ptrace_syscall_dir {
	PTRACE_SYSCALL_ENTER = 0,
	PTRACE_SYSCALL_EXIT = 1,
};

enum meminit_context {
	MEMINIT_EARLY = 0,
	MEMINIT_HOTPLUG = 1,
};

struct cpu {
	int node_id;
	int hotpluggable;
	struct device dev;
};

struct cpuinfo_arm64 {
	struct cpu cpu;
	struct kobject kobj;
	u32 reg_ctr;
	u32 reg_cntfrq;
	u32 reg_dczid;
	u32 reg_midr;
	u32 reg_revidr;
	u64 reg_id_aa64dfr0;
	u64 reg_id_aa64dfr1;
	u64 reg_id_aa64isar0;
	u64 reg_id_aa64isar1;
	u64 reg_id_aa64isar2;
	u64 reg_id_aa64mmfr0;
	u64 reg_id_aa64mmfr1;
	u64 reg_id_aa64mmfr2;
	u64 reg_id_aa64pfr0;
	u64 reg_id_aa64pfr1;
	u64 reg_id_aa64zfr0;
	u32 reg_id_dfr0;
	u32 reg_id_dfr1;
	u32 reg_id_isar0;
	u32 reg_id_isar1;
	u32 reg_id_isar2;
	u32 reg_id_isar3;
	u32 reg_id_isar4;
	u32 reg_id_isar5;
	u32 reg_id_isar6;
	u32 reg_id_mmfr0;
	u32 reg_id_mmfr1;
	u32 reg_id_mmfr2;
	u32 reg_id_mmfr3;
	u32 reg_id_mmfr4;
	u32 reg_id_mmfr5;
	u32 reg_id_pfr0;
	u32 reg_id_pfr1;
	u32 reg_id_pfr2;
	u32 reg_mvfr0;
	u32 reg_mvfr1;
	u32 reg_mvfr2;
	u64 reg_zcr;
};

struct cpu_operations {
	const char *name;
	int (*cpu_init)(unsigned int);
	int (*cpu_prepare)(unsigned int);
	int (*cpu_boot)(unsigned int);
	void (*cpu_postboot)();
	bool (*cpu_can_disable)(unsigned int);
	int (*cpu_disable)(unsigned int);
	void (*cpu_die)(unsigned int);
	int (*cpu_kill)(unsigned int);
	int (*cpu_init_idle)(unsigned int);
	int (*cpu_suspend)(long unsigned int);
};

struct shared_info;

struct start_info;

struct sigcontext {
	__u64 fault_address;
	__u64 regs[31];
	__u64 sp;
	__u64 pc;
	__u64 pstate;
	long: 64;
	__u8 __reserved[4096];
};

struct _aarch64_ctx {
	__u32 magic;
	__u32 size;
};

struct fpsimd_context {
	struct _aarch64_ctx head;
	__u32 fpsr;
	__u32 fpcr;
	__int128 unsigned vregs[32];
};

struct esr_context {
	struct _aarch64_ctx head;
	__u64 esr;
};

struct extra_context {
	struct _aarch64_ctx head;
	__u64 datap;
	__u32 size;
	__u32 __reserved[3];
};

struct sve_context {
	struct _aarch64_ctx head;
	__u16 vl;
	__u16 __reserved[3];
};

struct sigaltstack {
	void *ss_sp;
	int ss_flags;
	size_t ss_size;
};

typedef struct sigaltstack stack_t;

struct siginfo {
	union {
		struct {
			int si_signo;
			int si_errno;
			int si_code;
			union __sifields _sifields;
		};
		int _si_pad[32];
	};
};

struct ksignal {
	struct k_sigaction ka;
	kernel_siginfo_t info;
	int sig;
};

enum {
	EI_ETYPE_NONE = 0,
	EI_ETYPE_NULL = 1,
	EI_ETYPE_ERRNO = 2,
	EI_ETYPE_ERRNO_NULL = 3,
	EI_ETYPE_TRUE = 4,
};

struct syscall_metadata {
	const char *name;
	int syscall_nr;
	int nb_args;
	const char **types;
	const char **args;
	struct list_head enter_fields;
	struct trace_event_call *enter_event;
	struct trace_event_call *exit_event;
};

struct ucontext {
	long unsigned int uc_flags;
	struct ucontext *uc_link;
	stack_t uc_stack;
	sigset_t uc_sigmask;
	__u8 __unused[120];
	long: 64;
	struct sigcontext uc_mcontext;
};

struct rt_sigframe {
	struct siginfo info;
	struct ucontext uc;
};

struct frame_record {
	u64 fp;
	u64 lr;
};

struct rt_sigframe_user_layout {
	struct rt_sigframe *sigframe;
	struct frame_record *next_frame;
	long unsigned int size;
	long unsigned int limit;
	long unsigned int fpsimd_offset;
	long unsigned int esr_offset;
	long unsigned int sve_offset;
	long unsigned int extra_offset;
	long unsigned int end_offset;
};

struct user_ctxs {
	struct fpsimd_context *fpsimd;
	struct sve_context *sve;
};

enum {
	PER_LINUX = 0,
	PER_LINUX_32BIT = 8388608,
	PER_LINUX_FDPIC = 524288,
	PER_SVR4 = 68157441,
	PER_SVR3 = 83886082,
	PER_SCOSVR3 = 117440515,
	PER_OSR5 = 100663299,
	PER_WYSEV386 = 83886084,
	PER_ISCR4 = 67108869,
	PER_BSD = 6,
	PER_SUNOS = 67108870,
	PER_XENIX = 83886087,
	PER_LINUX32 = 8,
	PER_LINUX32_3GB = 134217736,
	PER_IRIX32 = 67108873,
	PER_IRIXN32 = 67108874,
	PER_IRIX64 = 67108875,
	PER_RISCOS = 12,
	PER_SOLARIS = 67108877,
	PER_UW7 = 68157454,
	PER_OSF4 = 15,
	PER_HPUX = 16,
	PER_MASK = 255,
};

typedef bool (*stack_trace_consume_fn)(void *, long unsigned int);

enum lockdep_ok {
	LOCKDEP_STILL_OK = 0,
	LOCKDEP_NOW_UNRELIABLE = 1,
};

enum bug_trap_type {
	BUG_TRAP_TYPE_NONE = 0,
	BUG_TRAP_TYPE_WARN = 1,
	BUG_TRAP_TYPE_BUG = 2,
};

enum siginfo_layout {
	SIL_KILL = 0,
	SIL_TIMER = 1,
	SIL_POLL = 2,
	SIL_FAULT = 3,
	SIL_FAULT_TRAPNO = 4,
	SIL_FAULT_MCEERR = 5,
	SIL_FAULT_BNDERR = 6,
	SIL_FAULT_PKUERR = 7,
	SIL_PERF_EVENT = 8,
	SIL_CHLD = 9,
	SIL_RT = 10,
	SIL_SYS = 11,
};

enum die_val {
	DIE_UNUSED = 0,
	DIE_OOPS = 1,
};

struct undef_hook {
	struct list_head node;
	u32 instr_mask;
	u32 instr_val;
	u64 pstate_mask;
	u64 pstate_val;
	int (*fn)(struct pt_regs *, u32);
};

struct sys64_hook {
	unsigned int esr_mask;
	unsigned int esr_val;
	void (*handler)(unsigned int, struct pt_regs *);
};

struct timens_offset {
	s64 sec;
	u64 nsec;
};

enum vm_fault_reason {
	VM_FAULT_OOM = 1,
	VM_FAULT_SIGBUS = 2,
	VM_FAULT_MAJOR = 4,
	VM_FAULT_WRITE = 8,
	VM_FAULT_HWPOISON = 16,
	VM_FAULT_HWPOISON_LARGE = 32,
	VM_FAULT_SIGSEGV = 64,
	VM_FAULT_NOPAGE = 256,
	VM_FAULT_LOCKED = 512,
	VM_FAULT_RETRY = 1024,
	VM_FAULT_FALLBACK = 2048,
	VM_FAULT_DONE_COW = 4096,
	VM_FAULT_NEEDDSYNC = 8192,
	VM_FAULT_HINDEX_MASK = 983040,
};

struct vm_special_mapping {
	const char *name;
	struct page **pages;
	vm_fault_t (*fault)(const struct vm_special_mapping *, struct vm_area_struct *, struct vm_fault *);
	int (*mremap)(const struct vm_special_mapping *, struct vm_area_struct *);
};

struct timens_offsets {
	struct timespec64 monotonic;
	struct timespec64 boottime;
};

struct time_namespace {
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
	struct timens_offsets offsets;
	struct page *vvar_page;
	bool frozen_offsets;
};

struct arch_vdso_data {};

struct vdso_timestamp {
	u64 sec;
	u64 nsec;
};

struct vdso_data {
	u32 seq;
	s32 clock_mode;
	u64 cycle_last;
	u64 mask;
	u32 mult;
	u32 shift;
	union {
		struct vdso_timestamp basetime[12];
		struct timens_offset offset[12];
	};
	s32 tz_minuteswest;
	s32 tz_dsttime;
	u32 hrtimer_res;
	u32 __unused;
	struct arch_vdso_data arch_data;
};

enum vdso_abi {
	VDSO_ABI_AA64 = 0,
	VDSO_ABI_AA32 = 1,
};

enum vvar_pages {
	VVAR_DATA_PAGE_OFFSET = 0,
	VVAR_TIMENS_PAGE_OFFSET = 1,
	VVAR_NR_PAGES = 2,
};

struct vdso_abi_info {
	const char *name;
	const char *vdso_code_start;
	const char *vdso_code_end;
	long unsigned int vdso_pages;
	struct vm_special_mapping *dm;
	struct vm_special_mapping *cm;
};

enum aarch32_map {
	AA32_MAP_VECTORS = 0,
	AA32_MAP_SIGPAGE = 1,
	AA32_MAP_VVAR = 2,
	AA32_MAP_VDSO = 3,
};

enum aarch64_map {
	AA64_MAP_VVAR = 0,
	AA64_MAP_VDSO = 1,
};

enum aarch64_insn_encoding_class {
	AARCH64_INSN_CLS_UNKNOWN = 0,
	AARCH64_INSN_CLS_DP_IMM = 1,
	AARCH64_INSN_CLS_DP_REG = 2,
	AARCH64_INSN_CLS_DP_FPSIMD = 3,
	AARCH64_INSN_CLS_LDST = 4,
	AARCH64_INSN_CLS_BR_SYS = 5,
};

enum aarch64_insn_hint_cr_op {
	AARCH64_INSN_HINT_NOP = 0,
	AARCH64_INSN_HINT_YIELD = 32,
	AARCH64_INSN_HINT_WFE = 64,
	AARCH64_INSN_HINT_WFI = 96,
	AARCH64_INSN_HINT_SEV = 128,
	AARCH64_INSN_HINT_SEVL = 160,
	AARCH64_INSN_HINT_XPACLRI = 224,
	AARCH64_INSN_HINT_PACIA_1716 = 256,
	AARCH64_INSN_HINT_PACIB_1716 = 320,
	AARCH64_INSN_HINT_AUTIA_1716 = 384,
	AARCH64_INSN_HINT_AUTIB_1716 = 448,
	AARCH64_INSN_HINT_PACIAZ = 768,
	AARCH64_INSN_HINT_PACIASP = 800,
	AARCH64_INSN_HINT_PACIBZ = 832,
	AARCH64_INSN_HINT_PACIBSP = 864,
	AARCH64_INSN_HINT_AUTIAZ = 896,
	AARCH64_INSN_HINT_AUTIASP = 928,
	AARCH64_INSN_HINT_AUTIBZ = 960,
	AARCH64_INSN_HINT_AUTIBSP = 992,
	AARCH64_INSN_HINT_ESB = 512,
	AARCH64_INSN_HINT_PSB = 544,
	AARCH64_INSN_HINT_TSB = 576,
	AARCH64_INSN_HINT_CSDB = 640,
	AARCH64_INSN_HINT_CLEARBHB = 704,
	AARCH64_INSN_HINT_BTI = 1024,
	AARCH64_INSN_HINT_BTIC = 1088,
	AARCH64_INSN_HINT_BTIJ = 1152,
	AARCH64_INSN_HINT_BTIJC = 1216,
};

enum aarch64_insn_imm_type {
	AARCH64_INSN_IMM_ADR = 0,
	AARCH64_INSN_IMM_26 = 1,
	AARCH64_INSN_IMM_19 = 2,
	AARCH64_INSN_IMM_16 = 3,
	AARCH64_INSN_IMM_14 = 4,
	AARCH64_INSN_IMM_12 = 5,
	AARCH64_INSN_IMM_9 = 6,
	AARCH64_INSN_IMM_7 = 7,
	AARCH64_INSN_IMM_6 = 8,
	AARCH64_INSN_IMM_S = 9,
	AARCH64_INSN_IMM_R = 10,
	AARCH64_INSN_IMM_N = 11,
	AARCH64_INSN_IMM_MAX = 12,
};

enum aarch64_insn_register_type {
	AARCH64_INSN_REGTYPE_RT = 0,
	AARCH64_INSN_REGTYPE_RN = 1,
	AARCH64_INSN_REGTYPE_RT2 = 2,
	AARCH64_INSN_REGTYPE_RM = 3,
	AARCH64_INSN_REGTYPE_RD = 4,
	AARCH64_INSN_REGTYPE_RA = 5,
	AARCH64_INSN_REGTYPE_RS = 6,
};

enum aarch64_insn_register {
	AARCH64_INSN_REG_0 = 0,
	AARCH64_INSN_REG_1 = 1,
	AARCH64_INSN_REG_2 = 2,
	AARCH64_INSN_REG_3 = 3,
	AARCH64_INSN_REG_4 = 4,
	AARCH64_INSN_REG_5 = 5,
	AARCH64_INSN_REG_6 = 6,
	AARCH64_INSN_REG_7 = 7,
	AARCH64_INSN_REG_8 = 8,
	AARCH64_INSN_REG_9 = 9,
	AARCH64_INSN_REG_10 = 10,
	AARCH64_INSN_REG_11 = 11,
	AARCH64_INSN_REG_12 = 12,
	AARCH64_INSN_REG_13 = 13,
	AARCH64_INSN_REG_14 = 14,
	AARCH64_INSN_REG_15 = 15,
	AARCH64_INSN_REG_16 = 16,
	AARCH64_INSN_REG_17 = 17,
	AARCH64_INSN_REG_18 = 18,
	AARCH64_INSN_REG_19 = 19,
	AARCH64_INSN_REG_20 = 20,
	AARCH64_INSN_REG_21 = 21,
	AARCH64_INSN_REG_22 = 22,
	AARCH64_INSN_REG_23 = 23,
	AARCH64_INSN_REG_24 = 24,
	AARCH64_INSN_REG_25 = 25,
	AARCH64_INSN_REG_26 = 26,
	AARCH64_INSN_REG_27 = 27,
	AARCH64_INSN_REG_28 = 28,
	AARCH64_INSN_REG_29 = 29,
	AARCH64_INSN_REG_FP = 29,
	AARCH64_INSN_REG_30 = 30,
	AARCH64_INSN_REG_LR = 30,
	AARCH64_INSN_REG_ZR = 31,
	AARCH64_INSN_REG_SP = 31,
};

enum aarch64_insn_variant {
	AARCH64_INSN_VARIANT_32BIT = 0,
	AARCH64_INSN_VARIANT_64BIT = 1,
};

enum aarch64_insn_condition {
	AARCH64_INSN_COND_EQ = 0,
	AARCH64_INSN_COND_NE = 1,
	AARCH64_INSN_COND_CS = 2,
	AARCH64_INSN_COND_CC = 3,
	AARCH64_INSN_COND_MI = 4,
	AARCH64_INSN_COND_PL = 5,
	AARCH64_INSN_COND_VS = 6,
	AARCH64_INSN_COND_VC = 7,
	AARCH64_INSN_COND_HI = 8,
	AARCH64_INSN_COND_LS = 9,
	AARCH64_INSN_COND_GE = 10,
	AARCH64_INSN_COND_LT = 11,
	AARCH64_INSN_COND_GT = 12,
	AARCH64_INSN_COND_LE = 13,
	AARCH64_INSN_COND_AL = 14,
};

enum aarch64_insn_branch_type {
	AARCH64_INSN_BRANCH_NOLINK = 0,
	AARCH64_INSN_BRANCH_LINK = 1,
	AARCH64_INSN_BRANCH_RETURN = 2,
	AARCH64_INSN_BRANCH_COMP_ZERO = 3,
	AARCH64_INSN_BRANCH_COMP_NONZERO = 4,
};

enum aarch64_insn_size_type {
	AARCH64_INSN_SIZE_8 = 0,
	AARCH64_INSN_SIZE_16 = 1,
	AARCH64_INSN_SIZE_32 = 2,
	AARCH64_INSN_SIZE_64 = 3,
};

enum aarch64_insn_ldst_type {
	AARCH64_INSN_LDST_LOAD_REG_OFFSET = 0,
	AARCH64_INSN_LDST_STORE_REG_OFFSET = 1,
	AARCH64_INSN_LDST_LOAD_PAIR_PRE_INDEX = 2,
	AARCH64_INSN_LDST_STORE_PAIR_PRE_INDEX = 3,
	AARCH64_INSN_LDST_LOAD_PAIR_POST_INDEX = 4,
	AARCH64_INSN_LDST_STORE_PAIR_POST_INDEX = 5,
	AARCH64_INSN_LDST_LOAD_EX = 6,
	AARCH64_INSN_LDST_STORE_EX = 7,
};

enum aarch64_insn_adsb_type {
	AARCH64_INSN_ADSB_ADD = 0,
	AARCH64_INSN_ADSB_SUB = 1,
	AARCH64_INSN_ADSB_ADD_SETFLAGS = 2,
	AARCH64_INSN_ADSB_SUB_SETFLAGS = 3,
};

enum aarch64_insn_movewide_type {
	AARCH64_INSN_MOVEWIDE_ZERO = 0,
	AARCH64_INSN_MOVEWIDE_KEEP = 1,
	AARCH64_INSN_MOVEWIDE_INVERSE = 2,
};

enum aarch64_insn_bitfield_type {
	AARCH64_INSN_BITFIELD_MOVE = 0,
	AARCH64_INSN_BITFIELD_MOVE_UNSIGNED = 1,
	AARCH64_INSN_BITFIELD_MOVE_SIGNED = 2,
};

enum aarch64_insn_data1_type {
	AARCH64_INSN_DATA1_REVERSE_16 = 0,
	AARCH64_INSN_DATA1_REVERSE_32 = 1,
	AARCH64_INSN_DATA1_REVERSE_64 = 2,
};

enum aarch64_insn_data2_type {
	AARCH64_INSN_DATA2_UDIV = 0,
	AARCH64_INSN_DATA2_SDIV = 1,
	AARCH64_INSN_DATA2_LSLV = 2,
	AARCH64_INSN_DATA2_LSRV = 3,
	AARCH64_INSN_DATA2_ASRV = 4,
	AARCH64_INSN_DATA2_RORV = 5,
};

enum aarch64_insn_data3_type {
	AARCH64_INSN_DATA3_MADD = 0,
	AARCH64_INSN_DATA3_MSUB = 1,
};

enum aarch64_insn_logic_type {
	AARCH64_INSN_LOGIC_AND = 0,
	AARCH64_INSN_LOGIC_BIC = 1,
	AARCH64_INSN_LOGIC_ORR = 2,
	AARCH64_INSN_LOGIC_ORN = 3,
	AARCH64_INSN_LOGIC_EOR = 4,
	AARCH64_INSN_LOGIC_EON = 5,
	AARCH64_INSN_LOGIC_AND_SETFLAGS = 6,
	AARCH64_INSN_LOGIC_BIC_SETFLAGS = 7,
};

enum aarch64_insn_prfm_type {
	AARCH64_INSN_PRFM_TYPE_PLD = 0,
	AARCH64_INSN_PRFM_TYPE_PLI = 1,
	AARCH64_INSN_PRFM_TYPE_PST = 2,
};

enum aarch64_insn_prfm_target {
	AARCH64_INSN_PRFM_TARGET_L1 = 0,
	AARCH64_INSN_PRFM_TARGET_L2 = 1,
	AARCH64_INSN_PRFM_TARGET_L3 = 2,
};

enum aarch64_insn_prfm_policy {
	AARCH64_INSN_PRFM_POLICY_KEEP = 0,
	AARCH64_INSN_PRFM_POLICY_STRM = 1,
};

enum aarch64_insn_adr_type {
	AARCH64_INSN_ADR_TYPE_ADRP = 0,
	AARCH64_INSN_ADR_TYPE_ADR = 1,
};

enum fixed_addresses {
	FIX_HOLE = 0,
	FIX_FDT_END = 1,
	FIX_FDT = 1024,
	FIX_EARLYCON_MEM_BASE = 1025,
	FIX_TEXT_POKE0 = 1026,
	FIX_APEI_GHES_IRQ = 1027,
	FIX_APEI_GHES_SEA = 1028,
	FIX_APEI_GHES_SDEI_NORMAL = 1029,
	FIX_APEI_GHES_SDEI_CRITICAL = 1030,
	FIX_ENTRY_TRAMP_TEXT3 = 1031,
	FIX_ENTRY_TRAMP_TEXT2 = 1032,
	FIX_ENTRY_TRAMP_TEXT1 = 1033,
	FIX_ENTRY_TRAMP_DATA = 1034,
	__end_of_permanent_fixed_addresses = 1035,
	FIX_BTMAP_END = 1035,
	FIX_BTMAP_BEGIN = 1482,
	FIX_PTE = 1483,
	FIX_PMD = 1484,
	FIX_PUD = 1485,
	FIX_PGD = 1486,
	__end_of_fixed_addresses = 1487,
};

struct aarch64_insn_patch {
	void **text_addrs;
	u32 *new_insns;
	int insn_cnt;
	atomic_t cpu_count;
};

struct return_address_data {
	unsigned int level;
	void *addr;
};

enum {
	CAP_HWCAP = 1,
	CAP_COMPAT_HWCAP = 2,
	CAP_COMPAT_HWCAP2 = 3,
};

enum mitigation_state {
	SPECTRE_UNAFFECTED = 0,
	SPECTRE_MITIGATED = 1,
	SPECTRE_VULNERABLE = 2,
};

enum pageflags {
	PG_locked = 0,
	PG_referenced = 1,
	PG_uptodate = 2,
	PG_dirty = 3,
	PG_lru = 4,
	PG_active = 5,
	PG_workingset = 6,
	PG_waiters = 7,
	PG_error = 8,
	PG_slab = 9,
	PG_owner_priv_1 = 10,
	PG_arch_1 = 11,
	PG_reserved = 12,
	PG_private = 13,
	PG_private_2 = 14,
	PG_writeback = 15,
	PG_head = 16,
	PG_mappedtodisk = 17,
	PG_reclaim = 18,
	PG_swapbacked = 19,
	PG_unevictable = 20,
	PG_mlocked = 21,
	PG_hwpoison = 22,
	PG_young = 23,
	PG_idle = 24,
	PG_arch_2 = 25,
	__NR_PAGEFLAGS = 26,
	PG_checked = 10,
	PG_swapcache = 10,
	PG_fscache = 14,
	PG_pinned = 10,
	PG_savepinned = 3,
	PG_foreign = 10,
	PG_xen_remapped = 10,
	PG_slob_free = 13,
	PG_double_map = 6,
	PG_has_hwpoisoned = 17,
	PG_isolated = 18,
	PG_reported = 2,
};

struct device_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device *, struct device_attribute *, char *);
	ssize_t (*store)(struct device *, struct device_attribute *, const char *, size_t);
};

struct psci_0_1_function_ids {
	u32 cpu_suspend;
	u32 cpu_on;
	u32 cpu_off;
	u32 migrate;
};

enum vgic_type {
	VGIC_V2 = 0,
	VGIC_V3 = 1,
};

struct vgic_global {
	enum vgic_type type;
	phys_addr_t vcpu_base;
	void *vcpu_base_va;
	void *vcpu_hyp_va;
	void *vctrl_base;
	void *vctrl_hyp;
	int nr_lr;
	unsigned int maint_irq;
	int max_gic_vcpus;
	bool can_emulate_gicv2;
	bool has_gicv4;
	bool has_gicv4_1;
	struct static_key_false gicv3_cpuif;
	u32 ich_vtr_el2;
};

enum kvm_mode {
	KVM_MODE_DEFAULT = 0,
	KVM_MODE_PROTECTED = 1,
};

enum vcpu_sysreg {
	__INVALID_SYSREG__ = 0,
	MPIDR_EL1 = 1,
	CSSELR_EL1 = 2,
	SCTLR_EL1 = 3,
	ACTLR_EL1 = 4,
	CPACR_EL1 = 5,
	ZCR_EL1 = 6,
	TTBR0_EL1 = 7,
	TTBR1_EL1 = 8,
	TCR_EL1 = 9,
	ESR_EL1 = 10,
	AFSR0_EL1 = 11,
	AFSR1_EL1 = 12,
	FAR_EL1 = 13,
	MAIR_EL1 = 14,
	VBAR_EL1 = 15,
	CONTEXTIDR_EL1 = 16,
	TPIDR_EL0 = 17,
	TPIDRRO_EL0 = 18,
	TPIDR_EL1 = 19,
	AMAIR_EL1 = 20,
	CNTKCTL_EL1 = 21,
	PAR_EL1 = 22,
	MDSCR_EL1 = 23,
	MDCCINT_EL1 = 24,
	DISR_EL1 = 25,
	PMCR_EL0 = 26,
	PMSELR_EL0 = 27,
	PMEVCNTR0_EL0 = 28,
	PMEVCNTR30_EL0 = 58,
	PMCCNTR_EL0 = 59,
	PMEVTYPER0_EL0 = 60,
	PMEVTYPER30_EL0 = 90,
	PMCCFILTR_EL0 = 91,
	PMCNTENSET_EL0 = 92,
	PMINTENSET_EL1 = 93,
	PMOVSSET_EL0 = 94,
	PMSWINC_EL0 = 95,
	PMUSERENR_EL0 = 96,
	APIAKEYLO_EL1 = 97,
	APIAKEYHI_EL1 = 98,
	APIBKEYLO_EL1 = 99,
	APIBKEYHI_EL1 = 100,
	APDAKEYLO_EL1 = 101,
	APDAKEYHI_EL1 = 102,
	APDBKEYLO_EL1 = 103,
	APDBKEYHI_EL1 = 104,
	APGAKEYLO_EL1 = 105,
	APGAKEYHI_EL1 = 106,
	ELR_EL1 = 107,
	SP_EL1 = 108,
	SPSR_EL1 = 109,
	CNTVOFF_EL2 = 110,
	CNTV_CVAL_EL0 = 111,
	CNTV_CTL_EL0 = 112,
	CNTP_CVAL_EL0 = 113,
	CNTP_CTL_EL0 = 114,
	DACR32_EL2 = 115,
	IFSR32_EL2 = 116,
	FPEXC32_EL2 = 117,
	DBGVCR32_EL2 = 118,
	NR_SYS_REGS = 119,
};

struct kvm_vcpu;

struct kvm_cpu_context {
	struct user_pt_regs regs;
	u64 spsr_abt;
	u64 spsr_und;
	u64 spsr_irq;
	u64 spsr_fiq;
	struct user_fpsimd_state fp_regs;
	u64 sys_regs[119];
	struct kvm_vcpu *__hyp_running_vcpu;
};

struct kvm_pmu_events {
	u32 events_host;
	u32 events_guest;
};

struct kvm_host_data {
	struct kvm_cpu_context host_ctxt;
	struct kvm_pmu_events pmu_events;
	long: 64;
};

struct kvm_host_psci_config {
	u32 version;
	struct psci_0_1_function_ids function_ids_0_1;
	bool psci_0_1_cpu_suspend_implemented;
	bool psci_0_1_cpu_on_implemented;
	bool psci_0_1_cpu_off_implemented;
	bool psci_0_1_migrate_implemented;
};

enum arm64_bp_harden_el1_vectors {
	EL1_VECTOR_BHB_LOOP = 0,
	EL1_VECTOR_BHB_FW = 1,
	EL1_VECTOR_BHB_CLEAR_INSN = 2,
	EL1_VECTOR_KPTI = 3,
};

struct __ftr_reg_entry {
	u32 sys_id;
	struct arm64_ftr_reg *reg;
};

typedef void kpti_remap_fn(int, int, phys_addr_t);

typedef void ttbr_replace_func(phys_addr_t);

struct alt_instr {
	s32 orig_offset;
	s32 alt_offset;
	u16 cpufeature;
	u8 orig_len;
	u8 alt_len;
};

typedef void (*alternative_cb_t)(struct alt_instr *, __le32 *, __le32 *, int);

struct alt_region {
	struct alt_instr *begin;
	struct alt_instr *end;
};

enum cache_type {
	CACHE_TYPE_NOCACHE = 0,
	CACHE_TYPE_INST = 1,
	CACHE_TYPE_DATA = 2,
	CACHE_TYPE_SEPARATE = 3,
	CACHE_TYPE_UNIFIED = 4,
};

struct cacheinfo {
	unsigned int id;
	enum cache_type type;
	unsigned int level;
	unsigned int coherency_line_size;
	unsigned int number_of_sets;
	unsigned int ways_of_associativity;
	unsigned int physical_line_partition;
	unsigned int size;
	cpumask_t shared_cpu_map;
	unsigned int attributes;
	void *fw_token;
	bool disable_sysfs;
	void *priv;
};

struct cpu_cacheinfo {
	struct cacheinfo *info_list;
	unsigned int num_levels;
	unsigned int num_leaves;
	bool cpu_map_populated;
};

typedef long unsigned int ulong;

struct preempt_notifier;

struct preempt_ops {
	void (*sched_in)(struct preempt_notifier *, int);
	void (*sched_out)(struct preempt_notifier *, struct task_struct *);
};

struct preempt_notifier {
	struct hlist_node link;
	struct preempt_ops *ops;
};

struct acpi_subtable_header {
	u8 type;
	u8 length;
};

struct acpi_hmat_structure {
	u16 type;
	u16 reserved;
	u32 length;
};

enum acpi_madt_type {
	ACPI_MADT_TYPE_LOCAL_APIC = 0,
	ACPI_MADT_TYPE_IO_APIC = 1,
	ACPI_MADT_TYPE_INTERRUPT_OVERRIDE = 2,
	ACPI_MADT_TYPE_NMI_SOURCE = 3,
	ACPI_MADT_TYPE_LOCAL_APIC_NMI = 4,
	ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE = 5,
	ACPI_MADT_TYPE_IO_SAPIC = 6,
	ACPI_MADT_TYPE_LOCAL_SAPIC = 7,
	ACPI_MADT_TYPE_INTERRUPT_SOURCE = 8,
	ACPI_MADT_TYPE_LOCAL_X2APIC = 9,
	ACPI_MADT_TYPE_LOCAL_X2APIC_NMI = 10,
	ACPI_MADT_TYPE_GENERIC_INTERRUPT = 11,
	ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR = 12,
	ACPI_MADT_TYPE_GENERIC_MSI_FRAME = 13,
	ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR = 14,
	ACPI_MADT_TYPE_GENERIC_TRANSLATOR = 15,
	ACPI_MADT_TYPE_MULTIPROC_WAKEUP = 16,
	ACPI_MADT_TYPE_RESERVED = 17,
};

struct acpi_madt_generic_interrupt {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 cpu_interface_number;
	u32 uid;
	u32 flags;
	u32 parking_version;
	u32 performance_interrupt;
	u64 parked_address;
	u64 base_address;
	u64 gicv_base_address;
	u64 gich_base_address;
	u32 vgic_interrupt;
	u64 gicr_base_address;
	u64 arm_mpidr;
	u8 efficiency_class;
	u8 reserved2[1];
	u16 spe_interrupt;
} __attribute__((packed));

enum {
	IRQ_TYPE_NONE = 0,
	IRQ_TYPE_EDGE_RISING = 1,
	IRQ_TYPE_EDGE_FALLING = 2,
	IRQ_TYPE_EDGE_BOTH = 3,
	IRQ_TYPE_LEVEL_HIGH = 4,
	IRQ_TYPE_LEVEL_LOW = 8,
	IRQ_TYPE_LEVEL_MASK = 12,
	IRQ_TYPE_SENSE_MASK = 15,
	IRQ_TYPE_DEFAULT = 15,
	IRQ_TYPE_PROBE = 16,
	IRQ_LEVEL = 256,
	IRQ_PER_CPU = 512,
	IRQ_NOPROBE = 1024,
	IRQ_NOREQUEST = 2048,
	IRQ_NOAUTOEN = 4096,
	IRQ_NO_BALANCING = 8192,
	IRQ_MOVE_PCNTXT = 16384,
	IRQ_NESTED_THREAD = 32768,
	IRQ_NOTHREAD = 65536,
	IRQ_PER_CPU_DEVID = 131072,
	IRQ_IS_POLLED = 262144,
	IRQ_DISABLE_UNLAZY = 524288,
	IRQ_HIDDEN = 1048576,
};

struct arch_msi_msg_addr_lo {
	u32 address_lo;
};

typedef struct arch_msi_msg_addr_lo arch_msi_msg_addr_lo_t;

struct arch_msi_msg_addr_hi {
	u32 address_hi;
};

typedef struct arch_msi_msg_addr_hi arch_msi_msg_addr_hi_t;

struct arch_msi_msg_data {
	u32 data;
};

typedef struct arch_msi_msg_data arch_msi_msg_data_t;

struct msi_msg {
	union {
		u32 address_lo;
		arch_msi_msg_addr_lo_t arch_addr_lo;
	};
	union {
		u32 address_hi;
		arch_msi_msg_addr_hi_t arch_addr_hi;
	};
	union {
		u32 data;
		arch_msi_msg_data_t arch_data;
	};
};

struct platform_msi_priv_data;

struct platform_msi_desc {
	struct platform_msi_priv_data *msi_priv_data;
	u16 msi_index;
};

struct fsl_mc_msi_desc {
	u16 msi_index;
};

struct ti_sci_inta_msi_desc {
	u16 dev_index;
};

struct irq_affinity_desc;

struct msi_desc {
	struct list_head list;
	unsigned int irq;
	unsigned int nvec_used;
	struct device *dev;
	struct msi_msg msg;
	struct irq_affinity_desc *affinity;
	const void *iommu_cookie;
	void (*write_msi_msg)(struct msi_desc *, void *);
	void *write_msi_msg_data;
	union {
		struct {
			u32 masked;
			struct {
				u8 is_msix: 1;
				u8 multiple: 3;
				u8 multi_cap: 3;
				u8 maskbit: 1;
				u8 is_64: 1;
				u8 is_virtual: 1;
				u16 entry_nr;
				unsigned int default_irq;
			} msi_attrib;
			union {
				u8 mask_pos;
				void *mask_base;
			};
		};
		struct platform_msi_desc platform;
		struct fsl_mc_msi_desc fsl_mc;
		struct ti_sci_inta_msi_desc inta;
	};
};

struct irq_affinity_desc {
	struct cpumask mask;
	unsigned int is_managed: 1;
};

union acpi_subtable_headers {
	struct acpi_subtable_header common;
	struct acpi_hmat_structure hmat;
};

enum mmu_notifier_event {
	MMU_NOTIFY_UNMAP = 0,
	MMU_NOTIFY_CLEAR = 1,
	MMU_NOTIFY_PROTECTION_VMA = 2,
	MMU_NOTIFY_PROTECTION_PAGE = 3,
	MMU_NOTIFY_SOFT_DIRTY = 4,
	MMU_NOTIFY_RELEASE = 5,
	MMU_NOTIFY_MIGRATE = 6,
};

struct mmu_notifier;

struct mmu_notifier_range;

struct mmu_notifier_ops {
	void (*release)(struct mmu_notifier *, struct mm_struct *);
	int (*clear_flush_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*clear_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*test_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int);
	void (*change_pte)(struct mmu_notifier *, struct mm_struct *, long unsigned int, pte_t);
	int (*invalidate_range_start)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range_end)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	struct mmu_notifier * (*alloc_notifier)(struct mm_struct *);
	void (*free_notifier)(struct mmu_notifier *);
};

struct mmu_notifier {
	struct hlist_node hlist;
	const struct mmu_notifier_ops *ops;
	struct mm_struct *mm;
	struct callback_head rcu;
	unsigned int users;
};

struct mmu_notifier_range {
	struct vm_area_struct *vma;
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	unsigned int flags;
	enum mmu_notifier_event event;
	void *migrate_pgmap_owner;
};

struct kvm_guest_debug_arch {
	__u64 dbg_bcr[16];
	__u64 dbg_bvr[16];
	__u64 dbg_wcr[16];
	__u64 dbg_wvr[16];
};

struct kvm_debug_exit_arch {
	__u32 hsr;
	__u64 far;
};

struct kvm_sync_regs {
	__u64 device_irq_level;
};

struct kvm_irq_level {
	union {
		__u32 irq;
		__s32 status;
	};
	__u32 level;
};

struct kvm_hyperv_exit {
	__u32 type;
	__u32 pad1;
	union {
		struct {
			__u32 msr;
			__u32 pad2;
			__u64 control;
			__u64 evt_page;
			__u64 msg_page;
		} synic;
		struct {
			__u64 input;
			__u64 result;
			__u64 params[2];
		} hcall;
		struct {
			__u32 msr;
			__u32 pad2;
			__u64 control;
			__u64 status;
			__u64 send_page;
			__u64 recv_page;
			__u64 pending_page;
		} syndbg;
	} u;
};

struct kvm_xen_exit {
	__u32 type;
	union {
		struct {
			__u32 longmode;
			__u32 cpl;
			__u64 input;
			__u64 result;
			__u64 params[6];
		} hcall;
	} u;
};

struct kvm_run {
	__u8 request_interrupt_window;
	__u8 immediate_exit;
	__u8 padding1[6];
	__u32 exit_reason;
	__u8 ready_for_interrupt_injection;
	__u8 if_flag;
	__u16 flags;
	__u64 cr8;
	__u64 apic_base;
	union {
		struct {
			__u64 hardware_exit_reason;
		} hw;
		struct {
			__u64 hardware_entry_failure_reason;
			__u32 cpu;
		} fail_entry;
		struct {
			__u32 exception;
			__u32 error_code;
		} ex;
		struct {
			__u8 direction;
			__u8 size;
			__u16 port;
			__u32 count;
			__u64 data_offset;
		} io;
		struct {
			struct kvm_debug_exit_arch arch;
		} debug;
		struct {
			__u64 phys_addr;
			__u8 data[8];
			__u32 len;
			__u8 is_write;
		} mmio;
		struct {
			__u64 nr;
			__u64 args[6];
			__u64 ret;
			__u32 longmode;
			__u32 pad;
		} hypercall;
		struct {
			__u64 rip;
			__u32 is_write;
			__u32 pad;
		} tpr_access;
		struct {
			__u8 icptcode;
			__u16 ipa;
			__u32 ipb;
		} s390_sieic;
		__u64 s390_reset_flags;
		struct {
			__u64 trans_exc_code;
			__u32 pgm_code;
		} s390_ucontrol;
		struct {
			__u32 dcrn;
			__u32 data;
			__u8 is_write;
		} dcr;
		struct {
			__u32 suberror;
			__u32 ndata;
			__u64 data[16];
		} internal;
		struct {
			__u64 gprs[32];
		} osi;
		struct {
			__u64 nr;
			__u64 ret;
			__u64 args[9];
		} papr_hcall;
		struct {
			__u16 subchannel_id;
			__u16 subchannel_nr;
			__u32 io_int_parm;
			__u32 io_int_word;
			__u32 ipb;
			__u8 dequeued;
		} s390_tsch;
		struct {
			__u32 epr;
		} epr;
		struct {
			__u32 type;
			__u64 flags;
		} system_event;
		struct {
			__u64 addr;
			__u8 ar;
			__u8 reserved;
			__u8 fc;
			__u8 sel1;
			__u16 sel2;
		} s390_stsi;
		struct {
			__u8 vector;
		} eoi;
		struct kvm_hyperv_exit hyperv;
		struct {
			__u64 esr_iss;
			__u64 fault_ipa;
		} arm_nisv;
		struct {
			__u8 error;
			__u8 pad[7];
			__u32 reason;
			__u32 index;
			__u64 data;
		} msr;
		struct kvm_xen_exit xen;
		char padding[256];
	};
	__u64 kvm_valid_regs;
	__u64 kvm_dirty_regs;
	union {
		struct kvm_sync_regs regs;
		char padding[2048];
	} s;
};

struct kvm_coalesced_mmio {
	__u64 phys_addr;
	__u32 len;
	union {
		__u32 pad;
		__u32 pio;
	};
	__u8 data[8];
};

struct kvm_coalesced_mmio_ring {
	__u32 first;
	__u32 last;
	struct kvm_coalesced_mmio coalesced_mmio[0];
};

struct kvm_device_attr {
	__u32 flags;
	__u32 group;
	__u64 attr;
	__u64 addr;
};

struct kvm_dirty_gfn {
	__u32 flags;
	__u32 slot;
	__u64 offset;
};

typedef u64 gpa_t;

typedef u64 gfn_t;

struct kvm_arch_memory_slot {};

struct kvm_memory_slot {
	gfn_t base_gfn;
	long unsigned int npages;
	long unsigned int *dirty_bitmap;
	struct kvm_arch_memory_slot arch;
	long unsigned int userspace_addr;
	u32 flags;
	short int id;
	u16 as_id;
};

struct kvm_mmu_memory_cache {
	int nobjs;
	gfp_t gfp_zero;
	struct kmem_cache *kmem_cache;
	void *objects[40];
};

struct kvm_io_device;

struct kvm_io_device_ops {
	int (*read)(struct kvm_vcpu *, struct kvm_io_device *, gpa_t, int, void *);
	int (*write)(struct kvm_vcpu *, struct kvm_io_device *, gpa_t, int, const void *);
	void (*destructor)(struct kvm_io_device *);
};

struct kvm_vcpu_stat {
	u64 halt_successful_poll;
	u64 halt_attempted_poll;
	u64 halt_poll_success_ns;
	u64 halt_poll_fail_ns;
	u64 halt_poll_invalid;
	u64 halt_wakeup;
	u64 hvc_exit_stat;
	u64 wfe_exit_stat;
	u64 wfi_exit_stat;
	u64 mmio_exit_user;
	u64 mmio_exit_kernel;
	u64 exits;
};

struct kvm_mmio_fragment {
	gpa_t gpa;
	void *data;
	unsigned int len;
};

struct kvm_vcpu_fault_info {
	u32 esr_el2;
	u64 far_el2;
	u64 hpfar_el2;
	u64 disr_el1;
};

struct vgic_v2_cpu_if {
	u32 vgic_hcr;
	u32 vgic_vmcr;
	u32 vgic_apr;
	u32 vgic_lr[64];
	unsigned int used_lrs;
};

struct its_vm;

struct its_vpe {
	struct page *vpt_page;
	struct its_vm *its_vm;
	atomic_t vlpi_count;
	int irq;
	irq_hw_number_t vpe_db_lpi;
	bool resident;
	bool ready;
	union {
		struct {
			int vpe_proxy_event;
			bool idai;
		};
		struct {
			struct fwnode_handle *fwnode;
			struct irq_domain *sgi_domain;
			struct {
				u8 priority;
				bool enabled;
				bool group;
			} sgi_config[16];
			atomic_t vmapp_count;
		};
	};
	raw_spinlock_t vpe_lock;
	u16 col_idx;
	u16 vpe_id;
	bool pending_last;
};

struct vgic_v3_cpu_if {
	u32 vgic_hcr;
	u32 vgic_vmcr;
	u32 vgic_sre;
	u32 vgic_ap0r[4];
	u32 vgic_ap1r[4];
	u64 vgic_lr[16];
	struct its_vpe its_vpe;
	unsigned int used_lrs;
};

enum vgic_irq_config {
	VGIC_CONFIG_EDGE = 0,
	VGIC_CONFIG_LEVEL = 1,
};

struct vgic_irq {
	raw_spinlock_t irq_lock;
	struct list_head lpi_list;
	struct list_head ap_list;
	struct kvm_vcpu *vcpu;
	struct kvm_vcpu *target_vcpu;
	u32 intid;
	bool line_level;
	bool pending_latch;
	bool active;
	bool enabled;
	bool hw;
	struct kref refcount;
	u32 hwintid;
	unsigned int host_irq;
	union {
		u8 targets;
		u32 mpidr;
	};
	u8 source;
	u8 active_source;
	u8 priority;
	u8 group;
	enum vgic_irq_config config;
	bool (*get_input_level)(int);
	void *owner;
};

enum iodev_type {
	IODEV_CPUIF = 0,
	IODEV_DIST = 1,
	IODEV_REDIST = 2,
	IODEV_ITS = 3,
};

struct kvm_io_device {
	const struct kvm_io_device_ops *ops;
};

struct vgic_its;

struct vgic_register_region;

struct vgic_io_device {
	gpa_t base_addr;
	union {
		struct kvm_vcpu *redist_vcpu;
		struct vgic_its *its;
	};
	const struct vgic_register_region *regions;
	enum iodev_type iodev_type;
	int nr_regions;
	struct kvm_io_device dev;
};

struct vgic_redist_region;

struct vgic_cpu {
	union {
		struct vgic_v2_cpu_if vgic_v2;
		struct vgic_v3_cpu_if vgic_v3;
	};
	struct vgic_irq private_irqs[32];
	raw_spinlock_t ap_list_lock;
	struct list_head ap_list_head;
	struct vgic_io_device rd_iodev;
	struct vgic_redist_region *rdreg;
	u32 rdreg_index;
	u64 pendbaser;
	bool lpis_enabled;
	u32 num_pri_bits;
	u32 num_id_bits;
};

struct arch_timer_context {
	struct kvm_vcpu *vcpu;
	struct kvm_irq_level irq;
	struct hrtimer hrtimer;
	bool loaded;
	u32 host_timer_irq;
	u32 host_timer_irq_flags;
};

struct arch_timer_cpu {
	struct arch_timer_context timers[2];
	struct hrtimer bg_timer;
	bool enabled;
};

struct kvm_pmc {
	u8 idx;
	struct perf_event *perf_event;
};

struct kvm_pmu {
	int irq_num;
	struct kvm_pmc pmc[32];
	long unsigned int chained[1];
	bool created;
	bool irq_level;
	struct irq_work overflow_work;
};

struct vcpu_reset_state {
	long unsigned int pc;
	long unsigned int r0;
	bool be;
	bool reset;
};

struct kvm_s2_mmu;

struct kvm_vcpu_arch {
	struct kvm_cpu_context ctxt;
	void *sve_state;
	unsigned int sve_max_vl;
	struct kvm_s2_mmu *hw_mmu;
	u64 hcr_el2;
	u32 mdcr_el2;
	struct kvm_vcpu_fault_info fault;
	u64 workaround_flags;
	u64 flags;
	struct kvm_guest_debug_arch *debug_ptr;
	struct kvm_guest_debug_arch vcpu_debug_state;
	struct kvm_guest_debug_arch external_debug_state;
	struct thread_info *host_thread_info;
	struct user_fpsimd_state *host_fpsimd_state;
	struct {
		struct kvm_guest_debug_arch regs;
		u64 pmscr_el1;
		u64 trfcr_el1;
	} host_debug_state;
	struct vgic_cpu vgic_cpu;
	struct arch_timer_cpu timer_cpu;
	struct kvm_pmu pmu;
	struct {
		u32 mdscr_el1;
	} guest_debug_preserved;
	bool power_off;
	bool pause;
	struct kvm_mmu_memory_cache mmu_page_cache;
	int target;
	long unsigned int features[1];
	bool has_run_once;
	u64 vsesr_el2;
	struct vcpu_reset_state reset_state;
	bool sysregs_loaded_on_cpu;
	struct {
		u64 last_steal;
		gpa_t base;
	} steal;
};

struct kvm_dirty_ring {
	u32 dirty_index;
	u32 reset_index;
	u32 size;
	u32 soft_limit;
	struct kvm_dirty_gfn *dirty_gfns;
	int index;
};

struct kvm;

struct kvm_vcpu {
	struct kvm *kvm;
	struct preempt_notifier preempt_notifier;
	int cpu;
	int vcpu_id;
	int vcpu_idx;
	int srcu_idx;
	int mode;
	u64 requests;
	long unsigned int guest_debug;
	int pre_pcpu;
	struct list_head blocked_vcpu_list;
	struct mutex mutex;
	struct kvm_run *run;
	struct rcuwait wait;
	struct pid *pid;
	int sigset_active;
	sigset_t sigset;
	struct kvm_vcpu_stat stat;
	unsigned int halt_poll_ns;
	bool valid_wakeup;
	int mmio_needed;
	int mmio_read_completed;
	int mmio_is_write;
	int mmio_cur_fragment;
	int mmio_nr_fragments;
	struct kvm_mmio_fragment mmio_fragments[2];
	struct {
		bool in_spin_loop;
		bool dy_eligible;
	} spin_loop;
	bool preempted;
	bool ready;
	struct kvm_vcpu_arch arch;
	struct kvm_dirty_ring dirty_ring;
};

struct its_vm {
	struct fwnode_handle *fwnode;
	struct irq_domain *domain;
	struct page *vprop_page;
	struct its_vpe **vpes;
	int nr_vpes;
	irq_hw_number_t db_lpi_base;
	long unsigned int *db_bitmap;
	int nr_db_lpis;
	u32 vlpi_count[16];
};

struct kvm_device;

struct vgic_its {
	gpa_t vgic_its_base;
	bool enabled;
	struct vgic_io_device iodev;
	struct kvm_device *dev;
	u64 baser_device_table;
	u64 baser_coll_table;
	struct mutex cmd_lock;
	u64 cbaser;
	u32 creadr;
	u32 cwriter;
	u32 abi_rev;
	struct mutex its_lock;
	struct list_head device_list;
	struct list_head collection_list;
};

struct vgic_register_region {
	unsigned int reg_offset;
	unsigned int len;
	unsigned int bits_per_irq;
	unsigned int access_flags;
	union {
		long unsigned int (*read)(struct kvm_vcpu *, gpa_t, unsigned int);
		long unsigned int (*its_read)(struct kvm *, struct vgic_its *, gpa_t, unsigned int);
	};
	union {
		void (*write)(struct kvm_vcpu *, gpa_t, unsigned int, long unsigned int);
		void (*its_write)(struct kvm *, struct vgic_its *, gpa_t, unsigned int, long unsigned int);
	};
	long unsigned int (*uaccess_read)(struct kvm_vcpu *, gpa_t, unsigned int);
	union {
		int (*uaccess_write)(struct kvm_vcpu *, gpa_t, unsigned int, long unsigned int);
		int (*uaccess_its_write)(struct kvm *, struct vgic_its *, gpa_t, unsigned int, long unsigned int);
	};
};

struct kvm_device_ops;

struct kvm_device {
	const struct kvm_device_ops *ops;
	struct kvm *kvm;
	void *private;
	struct list_head vm_node;
};

struct vgic_redist_region {
	u32 index;
	gpa_t base;
	u32 count;
	u32 free_index;
	struct list_head list;
};

struct vgic_state_iter;

struct vgic_dist {
	bool in_kernel;
	bool ready;
	bool initialized;
	u32 vgic_model;
	u32 implementation_rev;
	bool v2_groups_user_writable;
	bool msis_require_devid;
	int nr_spis;
	gpa_t vgic_dist_base;
	union {
		gpa_t vgic_cpu_base;
		struct list_head rd_regions;
	};
	bool enabled;
	bool nassgireq;
	struct vgic_irq *spis;
	struct vgic_io_device dist_iodev;
	bool has_its;
	u64 propbaser;
	raw_spinlock_t lpi_list_lock;
	struct list_head lpi_list_head;
	int lpi_list_count;
	struct list_head lpi_translation_cache;
	struct vgic_state_iter *iter;
	struct its_vm its_vm;
};

struct kvm_vmid {
	u64 vmid_gen;
	u32 vmid;
};

struct kvm_pgtable;

struct kvm_arch;

struct kvm_s2_mmu {
	struct kvm_vmid vmid;
	phys_addr_t pgd_phys;
	struct kvm_pgtable *pgt;
	int *last_vcpu_ran;
	struct kvm_arch *arch;
};

typedef u64 kvm_pte_t;

enum kvm_pgtable_stage2_flags {
	KVM_PGTABLE_S2_NOFWB = 1,
	KVM_PGTABLE_S2_IDMAP = 2,
};

struct kvm_pgtable_mm_ops;

struct kvm_pgtable {
	u32 ia_bits;
	u32 start_level;
	kvm_pte_t *pgd;
	struct kvm_pgtable_mm_ops *mm_ops;
	struct kvm_s2_mmu *mmu;
	enum kvm_pgtable_stage2_flags flags;
};

struct kvm_arch {
	struct kvm_s2_mmu mmu;
	u64 vtcr;
	int max_vcpus;
	struct vgic_dist vgic;
	u32 psci_version;
	bool return_nisv_io_abort_to_user;
	long unsigned int *pmu_filter;
	unsigned int pmuver;
	u8 pfr0_csv2;
	u8 pfr0_csv3;
};

struct kvm_vm_stat {
	ulong remote_tlb_flush;
};

struct kvm_io_range {
	gpa_t addr;
	int len;
	struct kvm_io_device *dev;
};

struct kvm_io_bus {
	int dev_count;
	int ioeventfd_count;
	struct kvm_io_range range[0];
};

enum kvm_bus {
	KVM_MMIO_BUS = 0,
	KVM_PIO_BUS = 1,
	KVM_VIRTIO_CCW_NOTIFY_BUS = 2,
	KVM_FAST_MMIO_BUS = 3,
	KVM_NR_BUSES = 4,
};

struct kvm_memslots;

struct kvm_irq_routing_table;

struct kvm_stat_data;

struct kvm {
	spinlock_t mmu_lock;
	struct mutex slots_lock;
	struct mm_struct *mm;
	struct kvm_memslots *memslots[1];
	struct kvm_vcpu *vcpus[512];
	atomic_t online_vcpus;
	int created_vcpus;
	int last_boosted_vcpu;
	struct list_head vm_list;
	struct mutex lock;
	struct kvm_io_bus *buses[4];
	struct {
		spinlock_t lock;
		struct list_head items;
		struct list_head resampler_list;
		struct mutex resampler_lock;
	} irqfds;
	struct list_head ioeventfds;
	struct kvm_vm_stat stat;
	struct kvm_arch arch;
	refcount_t users_count;
	struct kvm_coalesced_mmio_ring *coalesced_mmio_ring;
	spinlock_t ring_lock;
	struct list_head coalesced_zones;
	struct mutex irq_lock;
	struct kvm_irq_routing_table *irq_routing;
	struct hlist_head irq_ack_notifier_list;
	struct mmu_notifier mmu_notifier;
	long unsigned int mmu_notifier_seq;
	long int mmu_notifier_count;
	long unsigned int mmu_notifier_range_start;
	long unsigned int mmu_notifier_range_end;
	long int tlbs_dirty;
	struct list_head devices;
	u64 manual_dirty_log_protect;
	struct dentry *debugfs_dentry;
	struct kvm_stat_data **debugfs_stat_data;
	struct srcu_struct srcu;
	struct srcu_struct irq_srcu;
	pid_t userspace_pid;
	unsigned int max_halt_poll_ns;
	u32 dirty_ring_size;
};

struct kvm_irq_routing_table {
	int chip[988];
	u32 nr_rt_entries;
	struct hlist_head map[0];
};

struct kvm_memslots {
	u64 generation;
	short int id_to_index[32767];
	atomic_t lru_slot;
	int used_slots;
	struct kvm_memory_slot memslots[0];
};

struct kvm_stats_debugfs_item;

struct kvm_stat_data {
	struct kvm *kvm;
	struct kvm_stats_debugfs_item *dbgfs_item;
};

enum kvm_stat_kind {
	KVM_STAT_VM = 0,
	KVM_STAT_VCPU = 1,
};

struct kvm_stats_debugfs_item {
	const char *name;
	int offset;
	enum kvm_stat_kind kind;
	int mode;
};

struct kvm_device_ops {
	const char *name;
	int (*create)(struct kvm_device *, u32);
	void (*init)(struct kvm_device *);
	void (*destroy)(struct kvm_device *);
	void (*release)(struct kvm_device *);
	int (*set_attr)(struct kvm_device *, struct kvm_device_attr *);
	int (*get_attr)(struct kvm_device *, struct kvm_device_attr *);
	int (*has_attr)(struct kvm_device *, struct kvm_device_attr *);
	long int (*ioctl)(struct kvm_device *, unsigned int, long unsigned int);
	int (*mmap)(struct kvm_device *, struct vm_area_struct *);
};

struct kvm_pgtable_mm_ops {
	void * (*zalloc_page)(void *);
	void * (*zalloc_pages_exact)(size_t);
	void (*free_pages_exact)(void *, size_t);
	void (*get_page)(void *);
	void (*put_page)(void *);
	int (*page_count)(void *);
	void * (*phys_to_virt)(phys_addr_t);
	phys_addr_t (*virt_to_phys)(void *);
};

struct trace_event_raw_ipi_raise {
	struct trace_entry ent;
	u32 __data_loc_target_cpus;
	const char *reason;
	char __data[0];
};

struct trace_event_raw_ipi_handler {
	struct trace_entry ent;
	const char *reason;
	char __data[0];
};

struct trace_event_data_offsets_ipi_raise {
	u32 target_cpus;
};

struct trace_event_data_offsets_ipi_handler {};

typedef void (*btf_trace_ipi_raise)(void *, const struct cpumask *, const char *);

typedef void (*btf_trace_ipi_entry)(void *, const char *);

typedef void (*btf_trace_ipi_exit)(void *, const char *);

enum ipi_msg_type {
	IPI_RESCHEDULE = 0,
	IPI_CALL_FUNC = 1,
	IPI_CPU_STOP = 2,
	IPI_CPU_CRASH_STOP = 3,
	IPI_TIMER = 4,
	IPI_IRQ_WORK = 5,
	IPI_WAKEUP = 6,
	NR_IPI = 7,
};

typedef __u64 __le64;

enum scale_freq_source {
	SCALE_FREQ_SOURCE_CPUFREQ = 0,
	SCALE_FREQ_SOURCE_ARCH = 1,
};

struct scale_freq_data {
	enum scale_freq_source source;
	void (*set_freq_scale)();
};

typedef void *acpi_handle;

typedef u64 phys_cpuid_t;

struct thermal_cooling_device_ops;

struct thermal_cooling_device {
	int id;
	char *type;
	struct device device;
	struct device_node *np;
	void *devdata;
	void *stats;
	const struct thermal_cooling_device_ops *ops;
	bool updated;
	struct mutex lock;
	struct list_head thermal_instances;
	struct list_head node;
};

struct thermal_cooling_device_ops {
	int (*get_max_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*get_cur_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*set_cur_state)(struct thermal_cooling_device *, long unsigned int);
	int (*get_requested_power)(struct thermal_cooling_device *, u32 *);
	int (*state2power)(struct thermal_cooling_device *, long unsigned int, u32 *);
	int (*power2state)(struct thermal_cooling_device *, u32, long unsigned int *);
};

struct acpi_processor_cx {
	u8 valid;
	u8 type;
	u32 address;
	u8 entry_method;
	u8 index;
	u32 latency;
	u8 bm_sts_skip;
	char desc[32];
};

struct acpi_lpi_state {
	u32 min_residency;
	u32 wake_latency;
	u32 flags;
	u32 arch_flags;
	u32 res_cnt_freq;
	u32 enable_parent_state;
	u64 address;
	u8 index;
	u8 entry_method;
	char desc[32];
};

struct acpi_processor_power {
	int count;
	union {
		struct acpi_processor_cx states[8];
		struct acpi_lpi_state lpi_states[8];
	};
	int timer_broadcast_on_state;
};

struct acpi_psd_package {
	u64 num_entries;
	u64 revision;
	u64 domain;
	u64 coord_type;
	u64 num_processors;
};

struct acpi_pct_register {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 reserved;
	u64 address;
} __attribute__((packed));

struct acpi_processor_px {
	u64 core_frequency;
	u64 power;
	u64 transition_latency;
	u64 bus_master_latency;
	u64 control;
	u64 status;
};

struct acpi_processor_performance {
	unsigned int state;
	unsigned int platform_limit;
	struct acpi_pct_register control_register;
	struct acpi_pct_register status_register;
	short: 16;
	unsigned int state_count;
	int: 32;
	struct acpi_processor_px *states;
	struct acpi_psd_package domain_info;
	cpumask_var_t shared_cpu_map;
	unsigned int shared_type;
	int: 32;
} __attribute__((packed));

struct acpi_tsd_package {
	u64 num_entries;
	u64 revision;
	u64 domain;
	u64 coord_type;
	u64 num_processors;
};

struct acpi_processor_tx_tss {
	u64 freqpercentage;
	u64 power;
	u64 transition_latency;
	u64 control;
	u64 status;
};

struct acpi_processor_tx {
	u16 power;
	u16 performance;
};

struct acpi_processor;

struct acpi_processor_throttling {
	unsigned int state;
	unsigned int platform_limit;
	struct acpi_pct_register control_register;
	struct acpi_pct_register status_register;
	short: 16;
	unsigned int state_count;
	int: 32;
	struct acpi_processor_tx_tss *states_tss;
	struct acpi_tsd_package domain_info;
	cpumask_var_t shared_cpu_map;
	int (*acpi_processor_get_throttling)(struct acpi_processor *);
	int (*acpi_processor_set_throttling)(struct acpi_processor *, int, bool);
	u32 address;
	u8 duty_offset;
	u8 duty_width;
	u8 tsd_valid_flag;
	char: 8;
	unsigned int shared_type;
	struct acpi_processor_tx states[16];
	int: 32;
} __attribute__((packed));

struct acpi_processor_flags {
	u8 power: 1;
	u8 performance: 1;
	u8 throttling: 1;
	u8 limit: 1;
	u8 bm_control: 1;
	u8 bm_check: 1;
	u8 has_cst: 1;
	u8 has_lpi: 1;
	u8 power_setup_done: 1;
	u8 bm_rld_set: 1;
	u8 need_hotplug_init: 1;
};

struct acpi_processor_lx {
	int px;
	int tx;
};

struct acpi_processor_limit {
	struct acpi_processor_lx state;
	struct acpi_processor_lx thermal;
	struct acpi_processor_lx user;
};

struct acpi_processor {
	acpi_handle handle;
	u32 acpi_id;
	phys_cpuid_t phys_id;
	u32 id;
	u32 pblk;
	int performance_platform_limit;
	int throttling_platform_limit;
	struct acpi_processor_flags flags;
	struct acpi_processor_power power;
	struct acpi_processor_performance *performance;
	struct acpi_processor_throttling throttling;
	struct acpi_processor_limit limit;
	struct thermal_cooling_device *cdev;
	struct device *dev;
	struct freq_qos_request perflib_req;
	struct freq_qos_request thermal_req;
};

struct acpi_processor_errata {
	u8 smp;
	struct {
		u8 throttle: 1;
		u8 fdma: 1;
		u8 reserved: 6;
		u32 bmisx;
	} piix4;
};

struct cpuidle_driver;

struct cpc_reg {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

enum arm_smccc_conduit {
	SMCCC_CONDUIT_NONE = 0,
	SMCCC_CONDUIT_SMC = 1,
	SMCCC_CONDUIT_HVC = 2,
};

struct arm_smccc_res {
	long unsigned int a0;
	long unsigned int a1;
	long unsigned int a2;
	long unsigned int a3;
};

enum spectre_v4_policy {
	SPECTRE_V4_POLICY_MITIGATION_DYNAMIC = 0,
	SPECTRE_V4_POLICY_MITIGATION_ENABLED = 1,
	SPECTRE_V4_POLICY_MITIGATION_DISABLED = 2,
};

struct spectre_v4_param {
	const char *str;
	enum spectre_v4_policy policy;
};

enum bhb_mitigation_bits {
	BHB_LOOP = 0,
	BHB_FW = 1,
	BHB_HW = 2,
	BHB_INSN = 3,
};

struct ftr_set_desc {
	char name[20];
	struct arm64_ftr_override *override;
	struct {
		char name[10];
		u8 shift;
		bool (*filter)(u64);
	} fields[0];
};

typedef u32 compat_size_t;

struct compat_statfs64;

typedef s32 compat_clock_t;

typedef s32 compat_pid_t;

typedef s32 compat_timer_t;

typedef s32 compat_int_t;

typedef u64 compat_u64;

typedef u32 __compat_uid32_t;

typedef u32 compat_sigset_word;

struct compat_sigaltstack {
	compat_uptr_t ss_sp;
	int ss_flags;
	compat_size_t ss_size;
};

typedef struct compat_sigaltstack compat_stack_t;

typedef struct {
	compat_sigset_word sig[2];
} compat_sigset_t;

union compat_sigval {
	compat_int_t sival_int;
	compat_uptr_t sival_ptr;
};

typedef union compat_sigval compat_sigval_t;

struct compat_siginfo {
	int si_signo;
	int si_errno;
	int si_code;
	union {
		int _pad[29];
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
		} _kill;
		struct {
			compat_timer_t _tid;
			int _overrun;
			compat_sigval_t _sigval;
		} _timer;
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
			compat_sigval_t _sigval;
		} _rt;
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
			int _status;
			compat_clock_t _utime;
			compat_clock_t _stime;
		} _sigchld;
		struct {
			compat_uptr_t _addr;
			union {
				int _trapno;
				short int _addr_lsb;
				struct {
					char _dummy_bnd[4];
					compat_uptr_t _lower;
					compat_uptr_t _upper;
				} _addr_bnd;
				struct {
					char _dummy_pkey[4];
					u32 _pkey;
				} _addr_pkey;
				struct {
					compat_ulong_t _data;
					u32 _type;
				} _perf;
			};
		} _sigfault;
		struct {
			compat_long_t _band;
			int _fd;
		} _sigpoll;
		struct {
			compat_uptr_t _call_addr;
			int _syscall;
			unsigned int _arch;
		} _sigsys;
	} _sifields;
};

struct compat_sigcontext {
	compat_ulong_t trap_no;
	compat_ulong_t error_code;
	compat_ulong_t oldmask;
	compat_ulong_t arm_r0;
	compat_ulong_t arm_r1;
	compat_ulong_t arm_r2;
	compat_ulong_t arm_r3;
	compat_ulong_t arm_r4;
	compat_ulong_t arm_r5;
	compat_ulong_t arm_r6;
	compat_ulong_t arm_r7;
	compat_ulong_t arm_r8;
	compat_ulong_t arm_r9;
	compat_ulong_t arm_r10;
	compat_ulong_t arm_fp;
	compat_ulong_t arm_ip;
	compat_ulong_t arm_sp;
	compat_ulong_t arm_lr;
	compat_ulong_t arm_pc;
	compat_ulong_t arm_cpsr;
	compat_ulong_t fault_address;
};

struct compat_ucontext {
	compat_ulong_t uc_flags;
	compat_uptr_t uc_link;
	compat_stack_t uc_stack;
	struct compat_sigcontext uc_mcontext;
	compat_sigset_t uc_sigmask;
	int __unused[30];
	compat_ulong_t uc_regspace[128];
};

struct compat_sigframe {
	struct compat_ucontext uc;
	compat_ulong_t retcode[2];
};

struct compat_rt_sigframe {
	struct compat_siginfo info;
	struct compat_sigframe sig;
};

struct compat_user_vfp {
	compat_u64 fpregs[32];
	compat_ulong_t fpscr;
};

struct compat_user_vfp_exc {
	compat_ulong_t fpexc;
	compat_ulong_t fpinst;
	compat_ulong_t fpinst2;
};

struct compat_vfp_sigframe {
	compat_ulong_t magic;
	compat_ulong_t size;
	struct compat_user_vfp ufp;
	struct compat_user_vfp_exc ufp_exc;
};

struct compat_aux_sigframe {
	struct compat_vfp_sigframe vfp;
	long unsigned int end_magic;
};

union __fpsimd_vreg {
	__int128 unsigned raw;
	struct {
		u64 lo;
		u64 hi;
	};
};

struct dyn_arch_ftrace {};

struct dyn_ftrace {
	long unsigned int ip;
	long unsigned int flags;
	struct dyn_arch_ftrace arch;
};

enum {
	FTRACE_UPDATE_CALLS = 1,
	FTRACE_DISABLE_CALLS = 2,
	FTRACE_UPDATE_TRACE_FUNC = 4,
	FTRACE_START_FUNC_RET = 8,
	FTRACE_STOP_FUNC_RET = 16,
	FTRACE_MAY_SLEEP = 32,
};

struct elf64_rela {
	Elf64_Addr r_offset;
	Elf64_Xword r_info;
	Elf64_Sxword r_addend;
};

typedef struct elf64_rela Elf64_Rela;

enum aarch64_reloc_op {
	RELOC_OP_NONE = 0,
	RELOC_OP_ABS = 1,
	RELOC_OP_PREL = 2,
	RELOC_OP_PAGE = 3,
};

enum aarch64_insn_movw_imm_type {
	AARCH64_INSN_IMM_MOVNZ = 0,
	AARCH64_INSN_IMM_MOVKZ = 1,
};

enum perf_sample_regs_abi {
	PERF_SAMPLE_REGS_ABI_NONE = 0,
	PERF_SAMPLE_REGS_ABI_32 = 1,
	PERF_SAMPLE_REGS_ABI_64 = 2,
};

enum perf_event_arm_regs {
	PERF_REG_ARM64_X0 = 0,
	PERF_REG_ARM64_X1 = 1,
	PERF_REG_ARM64_X2 = 2,
	PERF_REG_ARM64_X3 = 3,
	PERF_REG_ARM64_X4 = 4,
	PERF_REG_ARM64_X5 = 5,
	PERF_REG_ARM64_X6 = 6,
	PERF_REG_ARM64_X7 = 7,
	PERF_REG_ARM64_X8 = 8,
	PERF_REG_ARM64_X9 = 9,
	PERF_REG_ARM64_X10 = 10,
	PERF_REG_ARM64_X11 = 11,
	PERF_REG_ARM64_X12 = 12,
	PERF_REG_ARM64_X13 = 13,
	PERF_REG_ARM64_X14 = 14,
	PERF_REG_ARM64_X15 = 15,
	PERF_REG_ARM64_X16 = 16,
	PERF_REG_ARM64_X17 = 17,
	PERF_REG_ARM64_X18 = 18,
	PERF_REG_ARM64_X19 = 19,
	PERF_REG_ARM64_X20 = 20,
	PERF_REG_ARM64_X21 = 21,
	PERF_REG_ARM64_X22 = 22,
	PERF_REG_ARM64_X23 = 23,
	PERF_REG_ARM64_X24 = 24,
	PERF_REG_ARM64_X25 = 25,
	PERF_REG_ARM64_X26 = 26,
	PERF_REG_ARM64_X27 = 27,
	PERF_REG_ARM64_X28 = 28,
	PERF_REG_ARM64_X29 = 29,
	PERF_REG_ARM64_LR = 30,
	PERF_REG_ARM64_SP = 31,
	PERF_REG_ARM64_PC = 32,
	PERF_REG_ARM64_MAX = 33,
};

struct perf_callchain_entry_ctx {
	struct perf_callchain_entry *entry;
	u32 max_stack;
	u32 nr;
	short int contexts;
	bool contexts_maxed;
};

struct frame_tail {
	struct frame_tail *fp;
	long unsigned int lr;
};

struct compat_frame_tail {
	compat_uptr_t fp;
	u32 sp;
	u32 lr;
};

struct platform_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct pdev_archdata {};

enum perf_hw_id {
	PERF_COUNT_HW_CPU_CYCLES = 0,
	PERF_COUNT_HW_INSTRUCTIONS = 1,
	PERF_COUNT_HW_CACHE_REFERENCES = 2,
	PERF_COUNT_HW_CACHE_MISSES = 3,
	PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,
	PERF_COUNT_HW_BRANCH_MISSES = 5,
	PERF_COUNT_HW_BUS_CYCLES = 6,
	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,
	PERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,
	PERF_COUNT_HW_REF_CPU_CYCLES = 9,
	PERF_COUNT_HW_MAX = 10,
};

enum perf_hw_cache_id {
	PERF_COUNT_HW_CACHE_L1D = 0,
	PERF_COUNT_HW_CACHE_L1I = 1,
	PERF_COUNT_HW_CACHE_LL = 2,
	PERF_COUNT_HW_CACHE_DTLB = 3,
	PERF_COUNT_HW_CACHE_ITLB = 4,
	PERF_COUNT_HW_CACHE_BPU = 5,
	PERF_COUNT_HW_CACHE_NODE = 6,
	PERF_COUNT_HW_CACHE_MAX = 7,
};

enum perf_hw_cache_op_id {
	PERF_COUNT_HW_CACHE_OP_READ = 0,
	PERF_COUNT_HW_CACHE_OP_WRITE = 1,
	PERF_COUNT_HW_CACHE_OP_PREFETCH = 2,
	PERF_COUNT_HW_CACHE_OP_MAX = 3,
};

enum perf_hw_cache_op_result_id {
	PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,
	PERF_COUNT_HW_CACHE_RESULT_MISS = 1,
	PERF_COUNT_HW_CACHE_RESULT_MAX = 2,
};

struct perf_event_mmap_page {
	__u32 version;
	__u32 compat_version;
	__u32 lock;
	__u32 index;
	__s64 offset;
	__u64 time_enabled;
	__u64 time_running;
	union {
		__u64 capabilities;
		struct {
			__u64 cap_bit0: 1;
			__u64 cap_bit0_is_deprecated: 1;
			__u64 cap_user_rdpmc: 1;
			__u64 cap_user_time: 1;
			__u64 cap_user_time_zero: 1;
			__u64 cap_user_time_short: 1;
			__u64 cap_____res: 58;
		};
	};
	__u16 pmc_width;
	__u16 time_shift;
	__u32 time_mult;
	__u64 time_offset;
	__u64 time_zero;
	__u32 size;
	__u32 __reserved_1;
	__u64 time_cycles;
	__u64 time_mask;
	__u8 __reserved[928];
	__u64 data_head;
	__u64 data_tail;
	__u64 data_offset;
	__u64 data_size;
	__u64 aux_head;
	__u64 aux_tail;
	__u64 aux_offset;
	__u64 aux_size;
};

struct perf_pmu_events_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str;
};

struct mfd_cell;

struct platform_device {
	const char *name;
	int id;
	bool id_auto;
	struct device dev;
	u64 platform_dma_mask;
	struct device_dma_parameters dma_parms;
	u32 num_resources;
	struct resource *resource;
	const struct platform_device_id *id_entry;
	char *driver_override;
	struct mfd_cell *mfd_cell;
	struct pdev_archdata archdata;
};

struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
};

struct arm_pmu;

struct pmu_hw_events {
	struct perf_event *events[32];
	long unsigned int used_mask[1];
	raw_spinlock_t pmu_lock;
	struct arm_pmu *percpu_pmu;
	int irq;
};

struct arm_pmu {
	struct pmu pmu;
	cpumask_t supported_cpus;
	char *name;
	int pmuver;
	irqreturn_t (*handle_irq)(struct arm_pmu *);
	void (*enable)(struct perf_event *);
	void (*disable)(struct perf_event *);
	int (*get_event_idx)(struct pmu_hw_events *, struct perf_event *);
	void (*clear_event_idx)(struct pmu_hw_events *, struct perf_event *);
	int (*set_event_filter)(struct hw_perf_event *, struct perf_event_attr *);
	u64 (*read_counter)(struct perf_event *);
	void (*write_counter)(struct perf_event *, u64);
	void (*start)(struct arm_pmu *);
	void (*stop)(struct arm_pmu *);
	void (*reset)(void *);
	int (*map_event)(struct perf_event *);
	int (*filter_match)(struct perf_event *);
	int num_events;
	bool secure_access;
	long unsigned int pmceid_bitmap[1];
	long unsigned int pmceid_ext_bitmap[1];
	struct platform_device *plat_device;
	struct pmu_hw_events *hw_events;
	struct hlist_node node;
	struct notifier_block cpu_pm_nb;
	const struct attribute_group *attr_groups[5];
	u64 reg_pmmir;
	long unsigned int acpi_cpuid;
};

enum armpmu_attr_groups {
	ARMPMU_ATTR_GROUP_COMMON = 0,
	ARMPMU_ATTR_GROUP_EVENTS = 1,
	ARMPMU_ATTR_GROUP_FORMATS = 2,
	ARMPMU_ATTR_GROUP_CAPS = 3,
	ARMPMU_NR_ATTR_GROUPS = 4,
};

struct clock_read_data {
	u64 epoch_ns;
	u64 epoch_cyc;
	u64 sched_clock_mask;
	u64 (*read_sched_clock)();
	u32 mult;
	u32 shift;
};

struct armv8pmu_probe_info {
	struct arm_pmu *pmu;
	bool present;
};

enum hw_breakpoint_ops {
	HW_BREAKPOINT_INSTALL = 0,
	HW_BREAKPOINT_UNINSTALL = 1,
	HW_BREAKPOINT_RESTORE = 2,
};

struct cpu_suspend_ctx {
	u64 ctx_regs[13];
	u64 sp;
};

struct sleep_stack_data {
	struct cpu_suspend_ctx system_regs;
	long unsigned int callee_saved_regs[12];
};

struct cpuidle_state_usage {
	long long unsigned int disable;
	long long unsigned int usage;
	u64 time_ns;
	long long unsigned int above;
	long long unsigned int below;
	long long unsigned int rejected;
	long long unsigned int s2idle_usage;
	long long unsigned int s2idle_time;
};

struct cpuidle_device;

struct cpuidle_driver___2;

struct cpuidle_state {
	char name[16];
	char desc[32];
	s64 exit_latency_ns;
	s64 target_residency_ns;
	unsigned int flags;
	unsigned int exit_latency;
	int power_usage;
	unsigned int target_residency;
	int (*enter)(struct cpuidle_device *, struct cpuidle_driver___2 *, int);
	int (*enter_dead)(struct cpuidle_device *, int);
	int (*enter_s2idle)(struct cpuidle_device *, struct cpuidle_driver___2 *, int);
};

struct cpuidle_state_kobj;

struct cpuidle_driver_kobj;

struct cpuidle_device_kobj;

struct cpuidle_device {
	unsigned int registered: 1;
	unsigned int enabled: 1;
	unsigned int poll_time_limit: 1;
	unsigned int cpu;
	ktime_t next_hrtimer;
	int last_state_idx;
	u64 last_residency_ns;
	u64 poll_limit_ns;
	u64 forced_idle_latency_limit_ns;
	struct cpuidle_state_usage states_usage[10];
	struct cpuidle_state_kobj *kobjs[10];
	struct cpuidle_driver_kobj *kobj_driver;
	struct cpuidle_device_kobj *kobj_dev;
	struct list_head device_list;
};

struct cpuidle_driver___2 {
	const char *name;
	struct module *owner;
	unsigned int bctimer: 1;
	struct cpuidle_state states[10];
	int state_count;
	int safe_state_index;
	struct cpumask *cpumask;
	const char *governor;
};

enum jump_label_type {
	JUMP_LABEL_NOP = 0,
	JUMP_LABEL_JMP = 1,
};

struct die_args {
	struct pt_regs *regs;
	const char *str;
	long int err;
	int trapnr;
	int signr;
};

enum kgdb_bpstate {
	BP_UNDEFINED = 0,
	BP_REMOVED = 1,
	BP_SET = 2,
	BP_ACTIVE = 3,
};

struct kgdb_bkpt {
	long unsigned int bpt_addr;
	unsigned char saved_instr[4];
	enum kgdb_bptype type;
	enum kgdb_bpstate state;
};

struct pci_device_id {
	__u32 vendor;
	__u32 device;
	__u32 subvendor;
	__u32 subdevice;
	__u32 class;
	__u32 class_mask;
	kernel_ulong_t driver_data;
};

struct resource_entry {
	struct list_head node;
	struct resource *res;
	resource_size_t offset;
	struct resource __res;
};

typedef u64 acpi_io_address;

typedef u32 acpi_object_type;

union acpi_object {
	acpi_object_type type;
	struct {
		acpi_object_type type;
		u64 value;
	} integer;
	struct {
		acpi_object_type type;
		u32 length;
		char *pointer;
	} string;
	struct {
		acpi_object_type type;
		u32 length;
		u8 *pointer;
	} buffer;
	struct {
		acpi_object_type type;
		u32 count;
		union acpi_object *elements;
	} package;
	struct {
		acpi_object_type type;
		acpi_object_type actual_type;
		acpi_handle handle;
	} reference;
	struct {
		acpi_object_type type;
		u32 proc_id;
		acpi_io_address pblk_address;
		u32 pblk_length;
	} processor;
	struct {
		acpi_object_type type;
		u32 system_level;
		u32 resource_order;
	} power_resource;
};

struct acpi_device;

struct acpi_hotplug_profile {
	struct kobject kobj;
	int (*scan_dependent)(struct acpi_device *);
	void (*notify_online)(struct acpi_device *);
	bool enabled: 1;
	bool demand_offline: 1;
};

struct acpi_device_status {
	u32 present: 1;
	u32 enabled: 1;
	u32 show_in_ui: 1;
	u32 functional: 1;
	u32 battery_present: 1;
	u32 reserved: 27;
};

struct acpi_device_flags {
	u32 dynamic_status: 1;
	u32 removable: 1;
	u32 ejectable: 1;
	u32 power_manageable: 1;
	u32 match_driver: 1;
	u32 initialized: 1;
	u32 visited: 1;
	u32 hotplug_notify: 1;
	u32 is_dock_station: 1;
	u32 of_compatible_ok: 1;
	u32 coherent_dma: 1;
	u32 cca_seen: 1;
	u32 enumeration_by_parent: 1;
	u32 reserved: 19;
};

typedef char acpi_bus_id[8];

struct acpi_pnp_type {
	u32 hardware_id: 1;
	u32 bus_address: 1;
	u32 platform_id: 1;
	u32 reserved: 29;
};

typedef u64 acpi_bus_address;

typedef char acpi_device_name[40];

typedef char acpi_device_class[20];

struct acpi_device_pnp {
	acpi_bus_id bus_id;
	int instance_no;
	struct acpi_pnp_type type;
	acpi_bus_address bus_address;
	char *unique_id;
	struct list_head ids;
	acpi_device_name device_name;
	acpi_device_class device_class;
	union acpi_object *str_obj;
};

struct acpi_device_power_flags {
	u32 explicit_get: 1;
	u32 power_resources: 1;
	u32 inrush_current: 1;
	u32 power_removed: 1;
	u32 ignore_parent: 1;
	u32 dsw_present: 1;
	u32 reserved: 26;
};

struct acpi_device_power_state {
	struct {
		u8 valid: 1;
		u8 explicit_set: 1;
		u8 reserved: 6;
	} flags;
	int power;
	int latency;
	struct list_head resources;
};

struct acpi_device_power {
	int state;
	struct acpi_device_power_flags flags;
	struct acpi_device_power_state states[5];
};

struct acpi_device_wakeup_flags {
	u8 valid: 1;
	u8 notifier_present: 1;
};

struct acpi_device_wakeup_context {
	void (*func)(struct acpi_device_wakeup_context *);
	struct device *dev;
};

struct acpi_device_wakeup {
	acpi_handle gpe_device;
	u64 gpe_number;
	u64 sleep_state;
	struct list_head resources;
	struct acpi_device_wakeup_flags flags;
	struct acpi_device_wakeup_context context;
	struct wakeup_source *ws;
	int prepare_count;
	int enable_count;
};

struct acpi_device_perf_flags {
	u8 reserved: 8;
};

struct acpi_device_perf_state;

struct acpi_device_perf {
	int state;
	struct acpi_device_perf_flags flags;
	int state_count;
	struct acpi_device_perf_state *states;
};

struct acpi_device_dir {
	struct proc_dir_entry *entry;
};

struct acpi_device_data {
	const union acpi_object *pointer;
	struct list_head properties;
	const union acpi_object *of_compatible;
	struct list_head subnodes;
};

struct acpi_scan_handler;

struct acpi_hotplug_context;

struct acpi_driver;

struct acpi_gpio_mapping;

struct acpi_device {
	int device_type;
	acpi_handle handle;
	struct fwnode_handle fwnode;
	struct acpi_device *parent;
	struct list_head children;
	struct list_head node;
	struct list_head wakeup_list;
	struct list_head del_list;
	struct acpi_device_status status;
	struct acpi_device_flags flags;
	struct acpi_device_pnp pnp;
	struct acpi_device_power power;
	struct acpi_device_wakeup wakeup;
	struct acpi_device_perf performance;
	struct acpi_device_dir dir;
	struct acpi_device_data data;
	struct acpi_scan_handler *handler;
	struct acpi_hotplug_context *hp;
	struct acpi_driver *driver;
	const struct acpi_gpio_mapping *driver_gpios;
	void *driver_data;
	struct device dev;
	unsigned int physical_node_count;
	unsigned int dep_unmet;
	struct list_head physical_node_list;
	struct mutex physical_node_lock;
	void (*remove)(struct acpi_device *);
};

struct acpi_scan_handler {
	const struct acpi_device_id *ids;
	struct list_head list_node;
	bool (*match)(const char *, const struct acpi_device_id **);
	int (*attach)(struct acpi_device *, const struct acpi_device_id *);
	void (*detach)(struct acpi_device *);
	void (*bind)(struct device *);
	void (*unbind)(struct device *);
	struct acpi_hotplug_profile hotplug;
};

struct acpi_hotplug_context {
	struct acpi_device *self;
	int (*notify)(struct acpi_device *, u32);
	void (*uevent)(struct acpi_device *, u32);
	void (*fixup)(struct acpi_device *);
};

typedef int (*acpi_op_add)(struct acpi_device *);

typedef int (*acpi_op_remove)(struct acpi_device *);

typedef void (*acpi_op_notify)(struct acpi_device *, u32);

struct acpi_device_ops {
	acpi_op_add add;
	acpi_op_remove remove;
	acpi_op_notify notify;
};

struct acpi_driver {
	char name[80];
	char class[80];
	const struct acpi_device_id *ids;
	unsigned int flags;
	struct acpi_device_ops ops;
	struct device_driver drv;
	struct module *owner;
};

struct acpi_device_perf_state {
	struct {
		u8 valid: 1;
		u8 reserved: 7;
	} flags;
	u8 power;
	u8 performance;
	int latency;
};

struct acpi_gpio_params;

struct acpi_gpio_mapping {
	const char *name;
	const struct acpi_gpio_params *data;
	unsigned int size;
	unsigned int quirks;
};

struct pci_bus;

struct acpi_pci_root {
	struct acpi_device *device;
	struct pci_bus *bus;
	u16 segment;
	struct resource secondary;
	u32 osc_support_set;
	u32 osc_control_set;
	phys_addr_t mcfg_addr;
};

typedef short unsigned int pci_bus_flags_t;

struct pci_dev;

struct pci_ops;

struct pci_bus {
	struct list_head node;
	struct pci_bus *parent;
	struct list_head children;
	struct list_head devices;
	struct pci_dev *self;
	struct list_head slots;
	struct resource *resource[4];
	struct list_head resources;
	struct resource busn_res;
	struct pci_ops *ops;
	void *sysdata;
	struct proc_dir_entry *procdir;
	unsigned char number;
	unsigned char primary;
	unsigned char max_bus_speed;
	unsigned char cur_bus_speed;
	int domain_nr;
	char name[48];
	short unsigned int bridge_ctl;
	pci_bus_flags_t bus_flags;
	struct device *bridge;
	struct device dev;
	struct bin_attribute *legacy_io;
	struct bin_attribute *legacy_mem;
	unsigned int is_added: 1;
};

struct acpi_gpio_params {
	unsigned int crs_entry_index;
	unsigned int line_index;
	bool active_low;
};

struct hotplug_slot;

struct pci_slot {
	struct pci_bus *bus;
	struct list_head list;
	struct hotplug_slot *hotplug;
	unsigned char number;
	struct kobject kobj;
};

enum {
	PCI_STD_RESOURCES = 0,
	PCI_STD_RESOURCE_END = 5,
	PCI_ROM_RESOURCE = 6,
	PCI_IOV_RESOURCES = 7,
	PCI_IOV_RESOURCE_END = 12,
	PCI_BRIDGE_RESOURCES = 13,
	PCI_BRIDGE_RESOURCE_END = 16,
	PCI_NUM_RESOURCES = 17,
	DEVICE_COUNT_RESOURCE = 17,
};

typedef int pci_power_t;

typedef unsigned int pci_channel_state_t;

typedef unsigned int pcie_reset_state_t;

typedef short unsigned int pci_dev_flags_t;

struct aer_stats;

struct rcec_ea;

struct pci_driver;

struct pcie_link_state;

struct pci_vpd;

struct pci_sriov;

struct pci_dev {
	struct list_head bus_list;
	struct pci_bus *bus;
	struct pci_bus *subordinate;
	void *sysdata;
	struct proc_dir_entry *procent;
	struct pci_slot *slot;
	unsigned int devfn;
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int subsystem_vendor;
	short unsigned int subsystem_device;
	unsigned int class;
	u8 revision;
	u8 hdr_type;
	u16 aer_cap;
	struct aer_stats *aer_stats;
	struct rcec_ea *rcec_ea;
	struct pci_dev *rcec;
	u8 pcie_cap;
	u8 msi_cap;
	u8 msix_cap;
	u8 pcie_mpss: 3;
	u8 rom_base_reg;
	u8 pin;
	u16 pcie_flags_reg;
	long unsigned int *dma_alias_mask;
	struct pci_driver *driver;
	u64 dma_mask;
	struct device_dma_parameters dma_parms;
	pci_power_t current_state;
	unsigned int imm_ready: 1;
	u8 pm_cap;
	unsigned int pme_support: 5;
	unsigned int pme_poll: 1;
	unsigned int d1_support: 1;
	unsigned int d2_support: 1;
	unsigned int no_d1d2: 1;
	unsigned int no_d3cold: 1;
	unsigned int bridge_d3: 1;
	unsigned int d3cold_allowed: 1;
	unsigned int mmio_always_on: 1;
	unsigned int wakeup_prepared: 1;
	unsigned int runtime_d3cold: 1;
	unsigned int skip_bus_pm: 1;
	unsigned int ignore_hotplug: 1;
	unsigned int hotplug_user_indicators: 1;
	unsigned int clear_retrain_link: 1;
	unsigned int d3hot_delay;
	unsigned int d3cold_delay;
	struct pcie_link_state *link_state;
	unsigned int ltr_path: 1;
	u16 l1ss;
	unsigned int eetlp_prefix_path: 1;
	pci_channel_state_t error_state;
	struct device dev;
	int cfg_size;
	unsigned int irq;
	struct resource resource[17];
	bool match_driver;
	unsigned int transparent: 1;
	unsigned int io_window: 1;
	unsigned int pref_window: 1;
	unsigned int pref_64_window: 1;
	unsigned int multifunction: 1;
	unsigned int is_busmaster: 1;
	unsigned int no_msi: 1;
	unsigned int no_64bit_msi: 1;
	unsigned int block_cfg_access: 1;
	unsigned int broken_parity_status: 1;
	unsigned int irq_reroute_variant: 2;
	unsigned int msi_enabled: 1;
	unsigned int msix_enabled: 1;
	unsigned int ari_enabled: 1;
	unsigned int ats_enabled: 1;
	unsigned int pasid_enabled: 1;
	unsigned int pri_enabled: 1;
	unsigned int is_managed: 1;
	unsigned int needs_freset: 1;
	unsigned int state_saved: 1;
	unsigned int is_physfn: 1;
	unsigned int is_virtfn: 1;
	unsigned int reset_fn: 1;
	unsigned int is_hotplug_bridge: 1;
	unsigned int shpc_managed: 1;
	unsigned int is_thunderbolt: 1;
	unsigned int untrusted: 1;
	unsigned int external_facing: 1;
	unsigned int broken_intx_masking: 1;
	unsigned int io_window_1k: 1;
	unsigned int irq_managed: 1;
	unsigned int non_compliant_bars: 1;
	unsigned int is_probed: 1;
	unsigned int link_active_reporting: 1;
	unsigned int no_vf_scan: 1;
	unsigned int no_command_memory: 1;
	pci_dev_flags_t dev_flags;
	atomic_t enable_cnt;
	u32 saved_config_space[16];
	struct hlist_head saved_cap_space;
	int rom_attr_enabled;
	struct bin_attribute *res_attr[17];
	struct bin_attribute *res_attr_wc[17];
	unsigned int broken_cmd_compl: 1;
	unsigned int ptm_root: 1;
	unsigned int ptm_enabled: 1;
	u8 ptm_granularity;
	const struct attribute_group **msi_irq_groups;
	struct pci_vpd *vpd;
	u16 dpc_cap;
	unsigned int dpc_rp_extensions: 1;
	u8 dpc_rp_log_size;
	union {
		struct pci_sriov *sriov;
		struct pci_dev *physfn;
	};
	u16 ats_cap;
	u8 ats_stu;
	u16 pri_cap;
	u32 pri_reqs_alloc;
	unsigned int pasid_required: 1;
	u16 pasid_cap;
	u16 pasid_features;
	u16 acs_cap;
	phys_addr_t rom;
	size_t romlen;
	char *driver_override;
	long unsigned int priv_flags;
};

struct pci_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct pci_error_handlers;

struct pci_driver {
	struct list_head node;
	const char *name;
	const struct pci_device_id *id_table;
	int (*probe)(struct pci_dev *, const struct pci_device_id *);
	void (*remove)(struct pci_dev *);
	int (*suspend)(struct pci_dev *, pm_message_t);
	int (*resume)(struct pci_dev *);
	void (*shutdown)(struct pci_dev *);
	int (*sriov_configure)(struct pci_dev *, int);
	int (*sriov_set_msix_vec_count)(struct pci_dev *, int);
	u32 (*sriov_get_vf_total_msix)(struct pci_dev *);
	const struct pci_error_handlers *err_handler;
	const struct attribute_group **groups;
	struct device_driver driver;
	struct pci_dynids dynids;
};

struct pci_host_bridge {
	struct device dev;
	struct pci_bus *bus;
	struct pci_ops *ops;
	struct pci_ops *child_ops;
	void *sysdata;
	int busnr;
	struct list_head windows;
	struct list_head dma_ranges;
	u8 (*swizzle_irq)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
	void (*release_fn)(struct pci_host_bridge *);
	void *release_data;
	unsigned int ignore_reset_delay: 1;
	unsigned int no_ext_tags: 1;
	unsigned int native_aer: 1;
	unsigned int native_pcie_hotplug: 1;
	unsigned int native_shpc_hotplug: 1;
	unsigned int native_pme: 1;
	unsigned int native_ltr: 1;
	unsigned int native_dpc: 1;
	unsigned int preserve_config: 1;
	unsigned int size_windows: 1;
	unsigned int msi_domain: 1;
	resource_size_t (*align_resource)(struct pci_dev *, const struct resource *, resource_size_t, resource_size_t, resource_size_t);
	long: 64;
	long: 64;
	long: 64;
	long unsigned int private[0];
};

struct pci_ops {
	int (*add_bus)(struct pci_bus *);
	void (*remove_bus)(struct pci_bus *);
	void * (*map_bus)(struct pci_bus *, unsigned int, int);
	int (*read)(struct pci_bus *, unsigned int, int, int, u32 *);
	int (*write)(struct pci_bus *, unsigned int, int, int, u32);
};

typedef unsigned int pci_ers_result_t;

struct pci_error_handlers {
	pci_ers_result_t (*error_detected)(struct pci_dev *, pci_channel_state_t);
	pci_ers_result_t (*mmio_enabled)(struct pci_dev *);
	pci_ers_result_t (*slot_reset)(struct pci_dev *);
	void (*reset_prepare)(struct pci_dev *);
	void (*reset_done)(struct pci_dev *);
	void (*resume)(struct pci_dev *);
};

enum pcie_bus_config_types {
	PCIE_BUS_TUNE_OFF = 0,
	PCIE_BUS_DEFAULT = 1,
	PCIE_BUS_SAFE = 2,
	PCIE_BUS_PERFORMANCE = 3,
	PCIE_BUS_PEER2PEER = 4,
};

struct acpi_pci_root_ops;

struct acpi_pci_root_info {
	struct acpi_pci_root *root;
	struct acpi_device *bridge;
	struct acpi_pci_root_ops *ops;
	struct list_head resources;
	char name[16];
};

struct acpi_pci_root_ops {
	struct pci_ops *pci_ops;
	int (*init_info)(struct acpi_pci_root_info *);
	void (*release_info)(struct acpi_pci_root_info *);
	int (*prepare_resources)(struct acpi_pci_root_info *);
};

struct pci_config_window;

struct pci_ecam_ops {
	unsigned int bus_shift;
	struct pci_ops pci_ops;
	int (*init)(struct pci_config_window *);
};

struct pci_config_window {
	struct resource res;
	struct resource busr;
	unsigned int bus_shift;
	void *priv;
	const struct pci_ecam_ops *ops;
	union {
		void *win;
		void **winp;
	};
	struct device *parent;
};

struct acpi_pci_generic_root_info {
	struct acpi_pci_root_info common;
	struct pci_config_window *cfg;
};

struct trace_event_raw_instruction_emulation {
	struct trace_entry ent;
	u32 __data_loc_instr;
	u64 addr;
	char __data[0];
};

struct trace_event_data_offsets_instruction_emulation {
	u32 instr;
};

typedef void (*btf_trace_instruction_emulation)(void *, const char *, u64);

enum insn_emulation_mode {
	INSN_UNDEF = 0,
	INSN_EMULATE = 1,
	INSN_HW = 2,
};

enum legacy_insn_status {
	INSN_DEPRECATED = 0,
	INSN_OBSOLETE = 1,
};

struct insn_emulation_ops {
	const char *name;
	enum legacy_insn_status status;
	struct undef_hook *hooks;
	int (*set_hw_mode)(bool);
};

struct insn_emulation {
	struct list_head node;
	struct insn_emulation_ops *ops;
	int current_mode;
	int min;
	int max;
};

typedef u64 acpi_size;

typedef u64 acpi_physical_address;

typedef u32 acpi_status;

struct acpi_table_bgrt {
	struct acpi_table_header header;
	u16 version;
	u8 status;
	u8 image_type;
	u64 image_address;
	u32 image_offset_x;
	u32 image_offset_y;
};

struct gpio_desc;

struct circ_buf {
	char *buf;
	int head;
	int tail;
};

struct serial_icounter_struct {
	int cts;
	int dsr;
	int rng;
	int dcd;
	int rx;
	int tx;
	int frame;
	int overrun;
	int parity;
	int brk;
	int buf_overrun;
	int reserved[9];
};

struct serial_struct {
	int type;
	int line;
	unsigned int port;
	int irq;
	int flags;
	int xmit_fifo_size;
	int custom_divisor;
	int baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char[1];
	int hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	long unsigned int iomap_base;
};

struct sysrq_key_op {
	void (* const handler)(int);
	const char * const help_msg;
	const char * const action_msg;
	const int enable_mask;
};

struct serial_rs485 {
	__u32 flags;
	__u32 delay_rts_before_send;
	__u32 delay_rts_after_send;
	__u32 padding[5];
};

struct serial_iso7816 {
	__u32 flags;
	__u32 tg;
	__u32 sc_fi;
	__u32 sc_di;
	__u32 clk;
	__u32 reserved[5];
};

struct uart_port;

struct uart_ops {
	unsigned int (*tx_empty)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*stop_tx)(struct uart_port *);
	void (*start_tx)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	void (*send_xchar)(struct uart_port *, char);
	void (*stop_rx)(struct uart_port *);
	void (*enable_ms)(struct uart_port *);
	void (*break_ctl)(struct uart_port *, int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*flush_buffer)(struct uart_port *);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	const char * (*type)(struct uart_port *);
	void (*release_port)(struct uart_port *);
	int (*request_port)(struct uart_port *);
	void (*config_port)(struct uart_port *, int);
	int (*verify_port)(struct uart_port *, struct serial_struct *);
	int (*ioctl)(struct uart_port *, unsigned int, long unsigned int);
	int (*poll_init)(struct uart_port *);
	void (*poll_put_char)(struct uart_port *, unsigned char);
	int (*poll_get_char)(struct uart_port *);
};

struct uart_icount {
	__u32 cts;
	__u32 dsr;
	__u32 rng;
	__u32 dcd;
	__u32 rx;
	__u32 tx;
	__u32 frame;
	__u32 overrun;
	__u32 parity;
	__u32 brk;
	__u32 buf_overrun;
};

typedef unsigned int upf_t;

typedef unsigned int upstat_t;

struct uart_state;

struct uart_port {
	spinlock_t lock;
	long unsigned int iobase;
	unsigned char *membase;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_divisor)(struct uart_port *, unsigned int, unsigned int *);
	void (*set_divisor)(struct uart_port *, unsigned int, unsigned int, unsigned int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
	int (*rs485_config)(struct uart_port *, struct serial_rs485 *);
	int (*iso7816_config)(struct uart_port *, struct serial_iso7816 *);
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	unsigned int fifosize;
	unsigned char x_char;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char quirks;
	unsigned int read_status_mask;
	unsigned int ignore_status_mask;
	struct uart_state *state;
	struct uart_icount icount;
	struct console *cons;
	upf_t flags;
	upstat_t status;
	int hw_stopped;
	unsigned int mctrl;
	unsigned int timeout;
	unsigned int type;
	const struct uart_ops *ops;
	unsigned int custom_divisor;
	unsigned int line;
	unsigned int minor;
	resource_size_t mapbase;
	resource_size_t mapsize;
	struct device *dev;
	long unsigned int sysrq;
	unsigned int sysrq_ch;
	unsigned char has_sysrq;
	unsigned char sysrq_seq;
	unsigned char hub6;
	unsigned char suspended;
	unsigned char console_reinit;
	const char *name;
	struct attribute_group *attr_group;
	const struct attribute_group **tty_groups;
	struct serial_rs485 rs485;
	struct gpio_desc *rs485_term_gpio;
	struct serial_iso7816 iso7816;
	void *private_data;
};

enum uart_pm_state {
	UART_PM_STATE_ON = 0,
	UART_PM_STATE_OFF = 3,
	UART_PM_STATE_UNDEFINED = 4,
};

struct uart_state {
	struct tty_port port;
	enum uart_pm_state pm_state;
	struct circ_buf xmit;
	atomic_t refcount;
	wait_queue_head_t remove_wait;
	struct uart_port *uart_port;
};

struct earlycon_device {
	struct console *con;
	struct uart_port port;
	char options[16];
	unsigned int baud;
};

struct earlycon_id {
	char name[15];
	char name_term;
	char compatible[128];
	int (*setup)(struct earlycon_device *, const char *);
};

enum acpi_srat_type {
	ACPI_SRAT_TYPE_CPU_AFFINITY = 0,
	ACPI_SRAT_TYPE_MEMORY_AFFINITY = 1,
	ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY = 2,
	ACPI_SRAT_TYPE_GICC_AFFINITY = 3,
	ACPI_SRAT_TYPE_GIC_ITS_AFFINITY = 4,
	ACPI_SRAT_TYPE_GENERIC_AFFINITY = 5,
	ACPI_SRAT_TYPE_RESERVED = 6,
};

struct acpi_srat_gicc_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u32 acpi_processor_uid;
	u32 flags;
	u32 clock_domain;
} __attribute__((packed));

struct parking_protocol_mailbox {
	__le32 cpu_id;
	__le32 reserved;
	__le64 entry_point;
};

struct cpu_mailbox_entry {
	struct parking_protocol_mailbox *mailbox;
	phys_addr_t mailbox_addr;
	u8 version;
	u8 gic_cpu_id;
};

enum {
	MEMREMAP_WB = 1,
	MEMREMAP_WT = 2,
	MEMREMAP_WC = 4,
	MEMREMAP_ENC = 8,
	MEMREMAP_DEC = 16,
};

struct pvclock_vcpu_stolen_time {
	__le32 revision;
	__le32 attributes;
	__le64 stolen_time;
	u8 padding[48];
};

struct pv_time_stolen_time_region {
	struct pvclock_vcpu_stolen_time *kaddr;
};

typedef __be64 fdt64_t;

enum kaslr_status {
	KASLR_ENABLED = 0,
	KASLR_DISABLED_CMDLINE = 1,
	KASLR_DISABLED_NO_SEED = 2,
	KASLR_DISABLED_FDT_REMAP = 3,
};

enum {
	IRQD_TRIGGER_MASK = 15,
	IRQD_SETAFFINITY_PENDING = 256,
	IRQD_ACTIVATED = 512,
	IRQD_NO_BALANCING = 1024,
	IRQD_PER_CPU = 2048,
	IRQD_AFFINITY_SET = 4096,
	IRQD_LEVEL = 8192,
	IRQD_WAKEUP_STATE = 16384,
	IRQD_MOVE_PCNTXT = 32768,
	IRQD_IRQ_DISABLED = 65536,
	IRQD_IRQ_MASKED = 131072,
	IRQD_IRQ_INPROGRESS = 262144,
	IRQD_WAKEUP_ARMED = 524288,
	IRQD_FORWARDED_TO_VCPU = 1048576,
	IRQD_AFFINITY_MANAGED = 2097152,
	IRQD_IRQ_STARTED = 4194304,
	IRQD_MANAGED_SHUTDOWN = 8388608,
	IRQD_SINGLE_TARGET = 16777216,
	IRQD_DEFAULT_TRIGGER_SET = 33554432,
	IRQD_CAN_RESERVE = 67108864,
	IRQD_MSI_NOMASK_QUIRK = 134217728,
	IRQD_HANDLE_ENFORCE_IRQCTX = 268435456,
	IRQD_AFFINITY_ON_ACTIVATE = 536870912,
	IRQD_IRQ_ENABLED_ON_SUSPEND = 1073741824,
};

typedef u8 uint8_t;

struct kexec_buf {
	struct kimage *image;
	void *buffer;
	long unsigned int bufsz;
	long unsigned int mem;
	long unsigned int memsz;
	long unsigned int buf_align;
	long unsigned int buf_min;
	long unsigned int buf_max;
	bool top_down;
};

struct crash_mem_range {
	u64 start;
	u64 end;
};

struct crash_mem {
	unsigned int max_nr_ranges;
	unsigned int nr_ranges;
	struct crash_mem_range ranges[0];
};

typedef __be32 fdt32_t;

struct fdt_header {
	fdt32_t magic;
	fdt32_t totalsize;
	fdt32_t off_dt_struct;
	fdt32_t off_dt_strings;
	fdt32_t off_mem_rsvmap;
	fdt32_t version;
	fdt32_t last_comp_version;
	fdt32_t boot_cpuid_phys;
	fdt32_t size_dt_strings;
	fdt32_t size_dt_struct;
};

enum key_being_used_for {
	VERIFYING_MODULE_SIGNATURE = 0,
	VERIFYING_FIRMWARE_SIGNATURE = 1,
	VERIFYING_KEXEC_PE_SIGNATURE = 2,
	VERIFYING_KEY_SIGNATURE = 3,
	VERIFYING_KEY_SELF_SIGNATURE = 4,
	VERIFYING_UNSPECIFIED_SIGNATURE = 5,
	NR__KEY_BEING_USED_FOR = 6,
};

struct arm64_image_header {
	__le32 code0;
	__le32 code1;
	__le64 text_offset;
	__le64 image_size;
	__le64 flags;
	__le64 res2;
	__le64 res3;
	__le64 res4;
	__le32 magic;
	__le32 res5;
};

struct kobject___2;

struct kobj_attribute___2;

typedef int sdei_event_callback(u32, struct pt_regs *, void *);

struct sdei_registered_event {
	struct pt_regs interrupted_regs;
	sdei_event_callback *callback;
	void *callback_arg;
	u32 event_num;
	u8 priority;
};

typedef struct {
	long unsigned int val;
} swp_entry_t;

struct freelist_node {
	atomic_t refs;
	struct freelist_node *next;
};

struct freelist_head {
	struct freelist_node *head;
};

struct kretprobe_instance;

typedef int (*kretprobe_handler_t)(struct kretprobe_instance *, struct pt_regs *);

struct kretprobe_holder;

struct kretprobe_instance {
	union {
		struct freelist_node freelist;
		struct callback_head rcu;
	};
	struct llist_node llist;
	struct kretprobe_holder *rph;
	kprobe_opcode_t *ret_addr;
	void *fp;
	char data[0];
};

struct kretprobe;

struct kretprobe_holder {
	struct kretprobe *rp;
	refcount_t ref;
};

struct kretprobe {
	struct kprobe kp;
	kretprobe_handler_t handler;
	kretprobe_handler_t entry_handler;
	int maxactive;
	int nmissed;
	size_t data_size;
	struct freelist_head freelist;
	struct kretprobe_holder *rph;
};

enum probe_insn {
	INSN_REJECTED = 0,
	INSN_GOOD_NO_SLOT = 1,
	INSN_GOOD = 2,
};

enum aarch64_insn_special_register {
	AARCH64_INSN_SPCLREG_SPSR_EL1 = 49664,
	AARCH64_INSN_SPCLREG_ELR_EL1 = 49665,
	AARCH64_INSN_SPCLREG_SP_EL0 = 49672,
	AARCH64_INSN_SPCLREG_SPSEL = 49680,
	AARCH64_INSN_SPCLREG_CURRENTEL = 49682,
	AARCH64_INSN_SPCLREG_DAIF = 55825,
	AARCH64_INSN_SPCLREG_NZCV = 55824,
	AARCH64_INSN_SPCLREG_FPCR = 55840,
	AARCH64_INSN_SPCLREG_DSPSR_EL0 = 55848,
	AARCH64_INSN_SPCLREG_DLR_EL0 = 55849,
	AARCH64_INSN_SPCLREG_SPSR_EL2 = 57856,
	AARCH64_INSN_SPCLREG_ELR_EL2 = 57857,
	AARCH64_INSN_SPCLREG_SP_EL1 = 57864,
	AARCH64_INSN_SPCLREG_SPSR_INQ = 57880,
	AARCH64_INSN_SPCLREG_SPSR_ABT = 57881,
	AARCH64_INSN_SPCLREG_SPSR_UND = 57882,
	AARCH64_INSN_SPCLREG_SPSR_FIQ = 57883,
	AARCH64_INSN_SPCLREG_SPSR_EL3 = 61952,
	AARCH64_INSN_SPCLREG_ELR_EL3 = 61953,
	AARCH64_INSN_SPCLREG_SP_EL2 = 61968,
};

struct arch_uprobe {
	union {
		u8 insn[4];
		u8 ixol[4];
	};
	struct arch_probe_insn api;
	bool simulate;
};

enum rp_check {
	RP_CHECK_CALL = 0,
	RP_CHECK_CHAIN_CALL = 1,
	RP_CHECK_RET = 2,
};

typedef s8 int8_t;

struct iommu_fault_param;

struct iopf_device_param;

struct iommu_fwspec;

struct dev_iommu {
	struct mutex lock;
	struct iommu_fault_param *fault_param;
	struct iopf_device_param *iopf_param;
	struct iommu_fwspec *fwspec;
	struct iommu_device *iommu_dev;
	void *priv;
};

struct sg_table {
	struct scatterlist *sgl;
	unsigned int nents;
	unsigned int orig_nents;
};

struct of_phandle_args {
	struct device_node *np;
	int args_count;
	uint32_t args[16];
};

struct iommu_fault_unrecoverable {
	__u32 reason;
	__u32 flags;
	__u32 pasid;
	__u32 perm;
	__u64 addr;
	__u64 fetch_addr;
};

struct iommu_fault_page_request {
	__u32 flags;
	__u32 pasid;
	__u32 grpid;
	__u32 perm;
	__u64 addr;
	__u64 private_data[2];
};

struct iommu_fault {
	__u32 type;
	__u32 padding;
	union {
		struct iommu_fault_unrecoverable event;
		struct iommu_fault_page_request prm;
		__u8 padding2[56];
	};
};

struct iommu_page_response {
	__u32 argsz;
	__u32 version;
	__u32 flags;
	__u32 pasid;
	__u32 grpid;
	__u32 code;
};

struct iommu_inv_addr_info {
	__u32 flags;
	__u32 archid;
	__u64 pasid;
	__u64 addr;
	__u64 granule_size;
	__u64 nb_granules;
};

struct iommu_inv_pasid_info {
	__u32 flags;
	__u32 archid;
	__u64 pasid;
};

struct iommu_cache_invalidate_info {
	__u32 argsz;
	__u32 version;
	__u8 cache;
	__u8 granularity;
	__u8 padding[6];
	union {
		struct iommu_inv_pasid_info pasid_info;
		struct iommu_inv_addr_info addr_info;
	} granu;
};

struct iommu_gpasid_bind_data_vtd {
	__u64 flags;
	__u32 pat;
	__u32 emt;
};

struct iommu_gpasid_bind_data {
	__u32 argsz;
	__u32 version;
	__u32 format;
	__u32 addr_width;
	__u64 flags;
	__u64 gpgd;
	__u64 hpasid;
	__u64 gpasid;
	__u8 padding[8];
	union {
		struct iommu_gpasid_bind_data_vtd vtd;
	} vendor;
};

typedef int (*iommu_fault_handler_t)(struct iommu_domain *, struct device *, long unsigned int, int, void *);

struct iommu_domain_geometry {
	dma_addr_t aperture_start;
	dma_addr_t aperture_end;
	bool force_aperture;
};

struct iommu_domain {
	unsigned int type;
	const struct iommu_ops *ops;
	long unsigned int pgsize_bitmap;
	iommu_fault_handler_t handler;
	void *handler_token;
	struct iommu_domain_geometry geometry;
	void *iova_cookie;
};

typedef int (*iommu_dev_fault_handler_t)(struct iommu_fault *, void *);

enum iommu_resv_type {
	IOMMU_RESV_DIRECT = 0,
	IOMMU_RESV_DIRECT_RELAXABLE = 1,
	IOMMU_RESV_RESERVED = 2,
	IOMMU_RESV_MSI = 3,
	IOMMU_RESV_SW_MSI = 4,
};

struct iommu_resv_region {
	struct list_head list;
	phys_addr_t start;
	size_t length;
	int prot;
	enum iommu_resv_type type;
};

struct iommu_iotlb_gather {
	long unsigned int start;
	long unsigned int end;
	size_t pgsize;
	struct page *freelist;
};

struct iommu_device {
	struct list_head list;
	const struct iommu_ops *ops;
	struct fwnode_handle *fwnode;
	struct device *dev;
};

struct iommu_sva {
	struct device *dev;
};

struct iommu_fault_event {
	struct iommu_fault fault;
	struct list_head list;
};

struct iommu_fault_param {
	iommu_dev_fault_handler_t handler;
	void *data;
	struct list_head faults;
	struct mutex lock;
};

struct iommu_fwspec {
	const struct iommu_ops *ops;
	struct fwnode_handle *iommu_fwnode;
	u32 flags;
	unsigned int num_ids;
	u32 ids[0];
};

enum xen_domain_type {
	XEN_NATIVE = 0,
	XEN_PV_DOMAIN = 1,
	XEN_HVM_DOMAIN = 2,
};

struct hvm_start_info {
	uint32_t magic;
	uint32_t version;
	uint32_t flags;
	uint32_t nr_modules;
	uint64_t modlist_paddr;
	uint64_t cmdline_paddr;
	uint64_t rsdp_paddr;
	uint64_t memmap_paddr;
	uint32_t memmap_entries;
	uint32_t reserved;
};

typedef uint64_t xen_pfn_t;

typedef uint64_t xen_ulong_t;

struct arch_vcpu_info {};

struct arch_shared_info {};

struct pvclock_vcpu_time_info {
	u32 version;
	u32 pad0;
	u64 tsc_timestamp;
	u64 system_time;
	u32 tsc_to_system_mul;
	s8 tsc_shift;
	u8 flags;
	u8 pad[2];
};

struct pvclock_wall_clock {
	u32 version;
	u32 sec;
	u32 nsec;
	u32 sec_hi;
};

struct vcpu_info {
	uint8_t evtchn_upcall_pending;
	uint8_t evtchn_upcall_mask;
	xen_ulong_t evtchn_pending_sel;
	struct arch_vcpu_info arch;
	struct pvclock_vcpu_time_info time;
};

struct shared_info___2 {
	struct vcpu_info vcpu_info[1];
	xen_ulong_t evtchn_pending[64];
	xen_ulong_t evtchn_mask[64];
	struct pvclock_wall_clock wc;
	uint32_t wc_sec_hi;
	struct arch_shared_info arch;
};

struct start_info___2 {
	char magic[32];
	long unsigned int nr_pages;
	long unsigned int shared_info;
	uint32_t flags;
	xen_pfn_t store_mfn;
	uint32_t store_evtchn;
	union {
		struct {
			xen_pfn_t mfn;
			uint32_t evtchn;
		} domU;
		struct {
			uint32_t info_off;
			uint32_t info_size;
		} dom0;
	} console;
	long unsigned int pt_base;
	long unsigned int nr_pt_frames;
	long unsigned int mfn_list;
	long unsigned int mod_start;
	long unsigned int mod_len;
	int8_t cmd_line[1024];
	long unsigned int first_p2m_pfn;
	long unsigned int nr_p2m_frames;
};

struct balloon_stats {
	long unsigned int current_pages;
	long unsigned int target_pages;
	long unsigned int target_unpopulated;
	long unsigned int balloon_low;
	long unsigned int balloon_high;
	long unsigned int total_pages;
	long unsigned int schedule_delay;
	long unsigned int max_schedule_delay;
	long unsigned int retry_count;
	long unsigned int max_retry_count;
};

enum swiotlb_force {
	SWIOTLB_NORMAL = 0,
	SWIOTLB_FORCE = 1,
	SWIOTLB_NO_FORCE = 2,
};

struct io_tlb_slot {
	phys_addr_t orig_addr;
	size_t alloc_size;
	unsigned int list;
};

struct io_tlb_mem {
	phys_addr_t start;
	phys_addr_t end;
	long unsigned int nslabs;
	long unsigned int used;
	unsigned int index;
	spinlock_t lock;
	struct dentry *debugfs;
	bool late_alloc;
	struct io_tlb_slot slots[0];
};

typedef struct {
	pgd_t pgd;
} p4d_t;

struct hstate {
	struct mutex resize_lock;
	int next_nid_to_alloc;
	int next_nid_to_free;
	unsigned int order;
	long unsigned int mask;
	long unsigned int max_huge_pages;
	long unsigned int nr_huge_pages;
	long unsigned int free_huge_pages;
	long unsigned int resv_huge_pages;
	long unsigned int surplus_huge_pages;
	long unsigned int nr_overcommit_huge_pages;
	struct list_head hugepage_activelist;
	struct list_head hugepage_freelists[64];
	unsigned int nr_huge_pages_node[64];
	unsigned int free_huge_pages_node[64];
	unsigned int surplus_huge_pages_node[64];
	struct cftype cgroup_files_dfl[7];
	struct cftype cgroup_files_legacy[9];
	char name[32];
};

struct fault_info {
	int (*fn)(long unsigned int, unsigned int, struct pt_regs *);
	int sig;
	int code;
	const char *name;
};

typedef u64 p4dval_t;

struct mhp_params {
	struct vmem_altmap *altmap;
	pgprot_t pgprot;
};

struct memory_notify {
	long unsigned int start_pfn;
	long unsigned int nr_pages;
	int status_change_nid_normal;
	int status_change_nid_high;
	int status_change_nid;
};

struct page_change_data {
	pgprot_t set_mask;
	pgprot_t clear_mask;
};

struct hugepage_subpool {
	spinlock_t lock;
	long int count;
	long int max_hpages;
	long int used_hpages;
	struct hstate *hstate;
	long int min_hpages;
	long int rsv_hpages;
};

struct hugetlbfs_sb_info {
	long int max_inodes;
	long int free_inodes;
	spinlock_t stat_lock;
	struct hstate *hstate;
	struct hugepage_subpool *spool;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

struct ptdump_range {
	long unsigned int start;
	long unsigned int end;
};

struct ptdump_state {
	void (*note_page)(struct ptdump_state *, long unsigned int, int, u64);
	void (*effective_prot)(struct ptdump_state *, int, u64);
	const struct ptdump_range *range;
};

struct addr_marker {
	long unsigned int start_address;
	char *name;
};

struct ptdump_info {
	struct mm_struct *mm;
	const struct addr_marker *markers;
	long unsigned int base_addr;
};

enum address_markers_idx {
	PAGE_OFFSET_NR = 0,
	PAGE_END_NR = 1,
};

struct pg_state {
	struct ptdump_state ptdump;
	struct seq_file *seq;
	const struct addr_marker *marker;
	long unsigned int start_address;
	int level;
	u64 current_prot;
	bool check_wx;
	long unsigned int wx_pages;
	long unsigned int uxn_pages;
};

struct prot_bits {
	u64 mask;
	u64 val;
	const char *set;
	const char *clear;
};

struct pg_level {
	const struct prot_bits *bits;
	const char *name;
	size_t num;
	u64 mask;
};

struct xa_node {
	unsigned char shift;
	unsigned char offset;
	unsigned char count;
	unsigned char nr_values;
	struct xa_node *parent;
	struct xarray *array;
	union {
		struct list_head private_list;
		struct callback_head callback_head;
	};
	void *slots[64];
	union {
		long unsigned int tags[3];
		long unsigned int marks[3];
	};
};

typedef void (*xa_update_node_t)(struct xa_node *);

struct xa_state {
	struct xarray *xa;
	long unsigned int xa_index;
	unsigned char xa_shift;
	unsigned char xa_sibs;
	unsigned char xa_offset;
	unsigned char xa_pad;
	struct xa_node *xa_node;
	struct xa_node *xa_alloc;
	xa_update_node_t xa_update;
};

typedef __kernel_long_t __kernel_off_t;

typedef __kernel_off_t off_t;

enum {
	BPF_REG_0 = 0,
	BPF_REG_1 = 1,
	BPF_REG_2 = 2,
	BPF_REG_3 = 3,
	BPF_REG_4 = 4,
	BPF_REG_5 = 5,
	BPF_REG_6 = 6,
	BPF_REG_7 = 7,
	BPF_REG_8 = 8,
	BPF_REG_9 = 9,
	BPF_REG_10 = 10,
	__MAX_BPF_REG = 11,
};

enum {
	DUMP_PREFIX_NONE = 0,
	DUMP_PREFIX_ADDRESS = 1,
	DUMP_PREFIX_OFFSET = 2,
};

struct bpf_binary_header {
	u32 pages;
	int: 32;
	u8 image[0];
};

struct jit_ctx {
	const struct bpf_prog *prog;
	int idx;
	int epilogue_offset;
	int *offset;
	int exentry_idx;
	__le32 *image;
	u32 stack_size;
};

struct arm64_jit_data {
	struct bpf_binary_header *header;
	u8 *image;
	struct jit_ctx ctx;
};

typedef long unsigned int hva_t;

typedef u64 hpa_t;

typedef u64 hfn_t;

typedef hfn_t kvm_pfn_t;

struct gfn_to_hva_cache {
	u64 generation;
	gpa_t gpa;
	long unsigned int hva;
	long unsigned int len;
	struct kvm_memory_slot *memslot;
};

struct gfn_to_pfn_cache {
	u64 generation;
	gfn_t gfn;
	kvm_pfn_t pfn;
	bool dirty;
};

enum kobject_action {
	KOBJ_ADD = 0,
	KOBJ_REMOVE = 1,
	KOBJ_CHANGE = 2,
	KOBJ_MOVE = 3,
	KOBJ_ONLINE = 4,
	KOBJ_OFFLINE = 5,
	KOBJ_BIND = 6,
	KOBJ_UNBIND = 7,
};

struct trace_print_flags {
	long unsigned int mask;
	const char *name;
};

struct kvm_regs {
	struct user_pt_regs regs;
	__u64 sp_el1;
	__u64 elr_el1;
	__u64 spsr[5];
	long: 64;
	struct user_fpsimd_state fp_regs;
};

struct kvm_sregs {};

struct kvm_fpu {};

struct kvm_userspace_memory_region {
	__u32 slot;
	__u32 flags;
	__u64 guest_phys_addr;
	__u64 memory_size;
	__u64 userspace_addr;
};

struct kvm_coalesced_mmio_zone {
	__u64 addr;
	__u32 size;
	union {
		__u32 pad;
		__u32 pio;
	};
};

struct kvm_translation {
	__u64 linear_address;
	__u64 physical_address;
	__u8 valid;
	__u8 writeable;
	__u8 usermode;
	__u8 pad[5];
};

struct kvm_dirty_log {
	__u32 slot;
	__u32 padding1;
	union {
		void *dirty_bitmap;
		__u64 padding2;
	};
};

struct kvm_clear_dirty_log {
	__u32 slot;
	__u32 num_pages;
	__u64 first_page;
	union {
		void *dirty_bitmap;
		__u64 padding2;
	};
};

struct kvm_signal_mask {
	__u32 len;
	__u8 sigset[0];
};

struct kvm_mp_state {
	__u32 mp_state;
};

struct kvm_guest_debug {
	__u32 control;
	__u32 pad;
	struct kvm_guest_debug_arch arch;
};

struct kvm_ioeventfd {
	__u64 datamatch;
	__u64 addr;
	__u32 len;
	__s32 fd;
	__u32 flags;
	__u8 pad[36];
};

struct kvm_enable_cap {
	__u32 cap;
	__u32 flags;
	__u64 args[4];
	__u8 pad[64];
};

struct kvm_irq_routing_irqchip {
	__u32 irqchip;
	__u32 pin;
};

struct kvm_irq_routing_msi {
	__u32 address_lo;
	__u32 address_hi;
	__u32 data;
	union {
		__u32 pad;
		__u32 devid;
	};
};

struct kvm_irq_routing_s390_adapter {
	__u64 ind_addr;
	__u64 summary_addr;
	__u64 ind_offset;
	__u32 summary_offset;
	__u32 adapter_id;
};

struct kvm_irq_routing_hv_sint {
	__u32 vcpu;
	__u32 sint;
};

struct kvm_irq_routing_entry {
	__u32 gsi;
	__u32 type;
	__u32 flags;
	__u32 pad;
	union {
		struct kvm_irq_routing_irqchip irqchip;
		struct kvm_irq_routing_msi msi;
		struct kvm_irq_routing_s390_adapter adapter;
		struct kvm_irq_routing_hv_sint hv_sint;
		__u32 pad[8];
	} u;
};

struct kvm_irq_routing {
	__u32 nr;
	__u32 flags;
	struct kvm_irq_routing_entry entries[0];
};

struct kvm_irqfd {
	__u32 fd;
	__u32 gsi;
	__u32 flags;
	__u32 resamplefd;
	__u8 pad[16];
};

struct kvm_msi {
	__u32 address_lo;
	__u32 address_hi;
	__u32 data;
	__u32 flags;
	__u32 devid;
	__u8 pad[12];
};

struct kvm_create_device {
	__u32 type;
	__u32 fd;
	__u32 flags;
};

enum kvm_device_type {
	KVM_DEV_TYPE_FSL_MPIC_20 = 1,
	KVM_DEV_TYPE_FSL_MPIC_42 = 2,
	KVM_DEV_TYPE_XICS = 3,
	KVM_DEV_TYPE_VFIO = 4,
	KVM_DEV_TYPE_ARM_VGIC_V2 = 5,
	KVM_DEV_TYPE_FLIC = 6,
	KVM_DEV_TYPE_ARM_VGIC_V3 = 7,
	KVM_DEV_TYPE_ARM_VGIC_ITS = 8,
	KVM_DEV_TYPE_XIVE = 9,
	KVM_DEV_TYPE_ARM_PV_TIME = 10,
	KVM_DEV_TYPE_MAX = 11,
};

struct kvm_gfn_range {
	struct kvm_memory_slot *slot;
	gfn_t start;
	gfn_t end;
	pte_t pte;
	bool may_block;
};

enum {
	OUTSIDE_GUEST_MODE = 0,
	IN_GUEST_MODE = 1,
	EXITING_GUEST_MODE = 2,
	READING_SHADOW_PAGE_TABLES = 3,
};

struct kvm_host_map {
	struct page *page;
	void *hva;
	kvm_pfn_t pfn;
	kvm_pfn_t gfn;
};

enum kvm_mr_change {
	KVM_MR_CREATE = 0,
	KVM_MR_DELETE = 1,
	KVM_MR_MOVE = 2,
	KVM_MR_FLAGS_ONLY = 3,
};

typedef int (*kvm_vm_thread_fn_t)(struct kvm *, uintptr_t);

struct miscdevice {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};

struct syscore_ops {
	struct list_head node;
	int (*suspend)();
	void (*resume)();
	void (*shutdown)();
};

struct trace_event_raw_kvm_userspace_exit {
	struct trace_entry ent;
	__u32 reason;
	int errno;
	char __data[0];
};

struct trace_event_raw_kvm_vcpu_wakeup {
	struct trace_entry ent;
	__u64 ns;
	bool waited;
	bool valid;
	char __data[0];
};

struct trace_event_raw_kvm_set_irq {
	struct trace_entry ent;
	unsigned int gsi;
	int level;
	int irq_source_id;
	char __data[0];
};

struct trace_event_raw_kvm_ack_irq {
	struct trace_entry ent;
	unsigned int irqchip;
	unsigned int pin;
	char __data[0];
};

struct trace_event_raw_kvm_mmio {
	struct trace_entry ent;
	u32 type;
	u32 len;
	u64 gpa;
	u64 val;
	char __data[0];
};

struct trace_event_raw_kvm_fpu {
	struct trace_entry ent;
	u32 load;
	char __data[0];
};

struct trace_event_raw_kvm_halt_poll_ns {
	struct trace_entry ent;
	bool grow;
	unsigned int vcpu_id;
	unsigned int new;
	unsigned int old;
	char __data[0];
};

struct trace_event_raw_kvm_dirty_ring_push {
	struct trace_entry ent;
	int index;
	u32 dirty_index;
	u32 reset_index;
	u32 slot;
	u64 offset;
	char __data[0];
};

struct trace_event_raw_kvm_dirty_ring_reset {
	struct trace_entry ent;
	int index;
	u32 dirty_index;
	u32 reset_index;
	char __data[0];
};

struct trace_event_raw_kvm_dirty_ring_exit {
	struct trace_entry ent;
	int vcpu_id;
	char __data[0];
};

struct trace_event_raw_kvm_unmap_hva_range {
	struct trace_entry ent;
	long unsigned int start;
	long unsigned int end;
	char __data[0];
};

struct trace_event_raw_kvm_set_spte_hva {
	struct trace_entry ent;
	long unsigned int hva;
	char __data[0];
};

struct trace_event_raw_kvm_age_hva {
	struct trace_entry ent;
	long unsigned int start;
	long unsigned int end;
	char __data[0];
};

struct trace_event_raw_kvm_test_age_hva {
	struct trace_entry ent;
	long unsigned int hva;
	char __data[0];
};

struct trace_event_data_offsets_kvm_userspace_exit {};

struct trace_event_data_offsets_kvm_vcpu_wakeup {};

struct trace_event_data_offsets_kvm_set_irq {};

struct trace_event_data_offsets_kvm_ack_irq {};

struct trace_event_data_offsets_kvm_mmio {};

struct trace_event_data_offsets_kvm_fpu {};

struct trace_event_data_offsets_kvm_halt_poll_ns {};

struct trace_event_data_offsets_kvm_dirty_ring_push {};

struct trace_event_data_offsets_kvm_dirty_ring_reset {};

struct trace_event_data_offsets_kvm_dirty_ring_exit {};

struct trace_event_data_offsets_kvm_unmap_hva_range {};

struct trace_event_data_offsets_kvm_set_spte_hva {};

struct trace_event_data_offsets_kvm_age_hva {};

struct trace_event_data_offsets_kvm_test_age_hva {};

typedef void (*btf_trace_kvm_userspace_exit)(void *, __u32, int);

typedef void (*btf_trace_kvm_vcpu_wakeup)(void *, __u64, bool, bool);

typedef void (*btf_trace_kvm_set_irq)(void *, unsigned int, int, int);

typedef void (*btf_trace_kvm_ack_irq)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_kvm_mmio)(void *, int, int, u64, void *);

typedef void (*btf_trace_kvm_fpu)(void *, int);

typedef void (*btf_trace_kvm_halt_poll_ns)(void *, bool, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_kvm_dirty_ring_push)(void *, struct kvm_dirty_ring *, u32, u64);

typedef void (*btf_trace_kvm_dirty_ring_reset)(void *, struct kvm_dirty_ring *);

typedef void (*btf_trace_kvm_dirty_ring_exit)(void *, struct kvm_vcpu *);

typedef void (*btf_trace_kvm_unmap_hva_range)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_kvm_set_spte_hva)(void *, long unsigned int);

typedef void (*btf_trace_kvm_age_hva)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_kvm_test_age_hva)(void *, long unsigned int);

typedef bool (*hva_handler_t)(struct kvm *, struct kvm_gfn_range *);

typedef void (*on_lock_fn_t)(struct kvm *, long unsigned int, long unsigned int);

struct kvm_hva_range {
	long unsigned int start;
	long unsigned int end;
	pte_t pte;
	hva_handler_t handler;
	on_lock_fn_t on_lock;
	bool flush_on_ret;
	bool may_block;
};

struct kvm_cpu_compat_check {
	void *opaque;
	int *ret;
};

struct kvm_vm_worker_thread_context {
	struct kvm *kvm;
	struct task_struct *parent;
	struct completion init_done;
	kvm_vm_thread_fn_t thread_fn;
	uintptr_t data;
	int err;
};

struct kvm_coalesced_mmio_dev {
	struct list_head list;
	struct kvm_io_device dev;
	struct kvm *kvm;
	struct kvm_coalesced_mmio_zone zone;
};

enum {
	WORK_STRUCT_PENDING_BIT = 0,
	WORK_STRUCT_DELAYED_BIT = 1,
	WORK_STRUCT_PWQ_BIT = 2,
	WORK_STRUCT_LINKED_BIT = 3,
	WORK_STRUCT_COLOR_SHIFT = 4,
	WORK_STRUCT_COLOR_BITS = 4,
	WORK_STRUCT_PENDING = 1,
	WORK_STRUCT_DELAYED = 2,
	WORK_STRUCT_PWQ = 4,
	WORK_STRUCT_LINKED = 8,
	WORK_STRUCT_STATIC = 0,
	WORK_NR_COLORS = 15,
	WORK_NO_COLOR = 15,
	WORK_CPU_UNBOUND = 256,
	WORK_STRUCT_FLAG_BITS = 8,
	WORK_OFFQ_FLAG_BASE = 4,
	__WORK_OFFQ_CANCELING = 4,
	WORK_OFFQ_CANCELING = 16,
	WORK_OFFQ_FLAG_BITS = 1,
	WORK_OFFQ_POOL_SHIFT = 5,
	WORK_OFFQ_LEFT = 59,
	WORK_OFFQ_POOL_BITS = 31,
	WORK_OFFQ_POOL_NONE = 2147483647,
	WORK_STRUCT_FLAG_MASK = 255,
	WORK_STRUCT_WQ_DATA_MASK = 4294967040,
	WORK_STRUCT_NO_POOL = 4294967264,
	WORK_BUSY_PENDING = 1,
	WORK_BUSY_RUNNING = 2,
	WORKER_DESC_LEN = 24,
};

struct irq_bypass_consumer;

struct irq_bypass_producer {
	struct list_head node;
	void *token;
	int irq;
	int (*add_consumer)(struct irq_bypass_producer *, struct irq_bypass_consumer *);
	void (*del_consumer)(struct irq_bypass_producer *, struct irq_bypass_consumer *);
	void (*stop)(struct irq_bypass_producer *);
	void (*start)(struct irq_bypass_producer *);
};

struct irq_bypass_consumer {
	struct list_head node;
	void *token;
	int (*add_producer)(struct irq_bypass_consumer *, struct irq_bypass_producer *);
	void (*del_producer)(struct irq_bypass_consumer *, struct irq_bypass_producer *);
	void (*stop)(struct irq_bypass_consumer *);
	void (*start)(struct irq_bypass_consumer *);
};

enum {
	kvm_ioeventfd_flag_nr_datamatch = 0,
	kvm_ioeventfd_flag_nr_pio = 1,
	kvm_ioeventfd_flag_nr_deassign = 2,
	kvm_ioeventfd_flag_nr_virtio_ccw_notify = 3,
	kvm_ioeventfd_flag_nr_fast_mmio = 4,
	kvm_ioeventfd_flag_nr_max = 5,
};

struct fd {
	struct file *file;
	unsigned int flags;
};

struct kvm_s390_adapter_int {
	u64 ind_addr;
	u64 summary_addr;
	u64 ind_offset;
	u32 summary_offset;
	u32 adapter_id;
};

struct kvm_hv_sint {
	u32 vcpu;
	u32 sint;
};

struct kvm_kernel_irq_routing_entry {
	u32 gsi;
	u32 type;
	int (*set)(struct kvm_kernel_irq_routing_entry *, struct kvm *, int, int, bool);
	union {
		struct {
			unsigned int irqchip;
			unsigned int pin;
		} irqchip;
		struct {
			u32 address_lo;
			u32 address_hi;
			u32 data;
			u32 flags;
			u32 devid;
		} msi;
		struct kvm_s390_adapter_int adapter;
		struct kvm_hv_sint hv_sint;
	};
	struct hlist_node link;
};

struct kvm_irq_ack_notifier {
	struct hlist_node link;
	unsigned int gsi;
	void (*irq_acked)(struct kvm_irq_ack_notifier *);
};

typedef struct poll_table_struct poll_table;

struct kvm_kernel_irqfd_resampler {
	struct kvm *kvm;
	struct list_head list;
	struct kvm_irq_ack_notifier notifier;
	struct list_head link;
};

struct kvm_kernel_irqfd {
	struct kvm *kvm;
	wait_queue_entry_t wait;
	struct kvm_kernel_irq_routing_entry irq_entry;
	seqcount_spinlock_t irq_entry_sc;
	int gsi;
	struct work_struct inject;
	struct kvm_kernel_irqfd_resampler *resampler;
	struct eventfd_ctx *resamplefd;
	struct list_head resampler_link;
	struct eventfd_ctx *eventfd;
	struct list_head list;
	poll_table pt;
	struct work_struct shutdown;
	struct irq_bypass_consumer consumer;
	struct irq_bypass_producer *producer;
};

struct _ioeventfd {
	struct list_head list;
	u64 addr;
	int length;
	struct eventfd_ctx *eventfd;
	u64 datamatch;
	struct kvm_io_device dev;
	u8 bus_idx;
	bool wildcard;
};

struct vfio_group;

struct kvm_vfio_group {
	struct list_head node;
	struct vfio_group *vfio_group;
};

struct kvm_vfio {
	struct list_head group_list;
	struct mutex lock;
	bool noncoherent;
};

struct kvm_vcpu_init {
	__u32 target;
	__u32 features[7];
};

struct kvm_vcpu_events {
	struct {
		__u8 serror_pending;
		__u8 serror_has_esr;
		__u8 ext_dabt_pending;
		__u8 pad[5];
		__u64 serror_esr;
	} exception;
	__u32 reserved[12];
};

struct kvm_reg_list {
	__u64 n;
	__u64 reg[0];
};

struct kvm_one_reg {
	__u64 id;
	__u64 addr;
};

struct kvm_arm_device_addr {
	__u64 id;
	__u64 addr;
};

struct kvm_nvhe_init_params {
	long unsigned int mair_el2;
	long unsigned int tcr_el2;
	long unsigned int tpidr_el2;
	long unsigned int stack_hyp_va;
	phys_addr_t pgd_pa;
	long unsigned int hcr_el2;
	long unsigned int vttbr;
	long unsigned int vtcr;
};

struct timer_map {
	struct arch_timer_context *direct_vtimer;
	struct arch_timer_context *direct_ptimer;
	struct arch_timer_context *emul_ptimer;
};

struct trace_event_raw_kvm_entry {
	struct trace_entry ent;
	long unsigned int vcpu_pc;
	char __data[0];
};

struct trace_event_raw_kvm_exit {
	struct trace_entry ent;
	int ret;
	unsigned int esr_ec;
	long unsigned int vcpu_pc;
	char __data[0];
};

struct trace_event_raw_kvm_guest_fault {
	struct trace_entry ent;
	long unsigned int vcpu_pc;
	long unsigned int hsr;
	long unsigned int hxfar;
	long long unsigned int ipa;
	char __data[0];
};

struct trace_event_raw_kvm_access_fault {
	struct trace_entry ent;
	long unsigned int ipa;
	char __data[0];
};

struct trace_event_raw_kvm_irq_line {
	struct trace_entry ent;
	unsigned int type;
	int vcpu_idx;
	int irq_num;
	int level;
	char __data[0];
};

struct trace_event_raw_kvm_mmio_emulate {
	struct trace_entry ent;
	long unsigned int vcpu_pc;
	long unsigned int instr;
	long unsigned int cpsr;
	char __data[0];
};

struct trace_event_raw_kvm_set_way_flush {
	struct trace_entry ent;
	long unsigned int vcpu_pc;
	bool cache;
	char __data[0];
};

struct trace_event_raw_kvm_toggle_cache {
	struct trace_entry ent;
	long unsigned int vcpu_pc;
	bool was;
	bool now;
	char __data[0];
};

struct trace_event_raw_kvm_timer_update_irq {
	struct trace_entry ent;
	long unsigned int vcpu_id;
	__u32 irq;
	int level;
	char __data[0];
};

struct trace_event_raw_kvm_get_timer_map {
	struct trace_entry ent;
	long unsigned int vcpu_id;
	int direct_vtimer;
	int direct_ptimer;
	int emul_ptimer;
	char __data[0];
};

struct trace_event_raw_kvm_timer_save_state {
	struct trace_entry ent;
	long unsigned int ctl;
	long long unsigned int cval;
	int timer_idx;
	char __data[0];
};

struct trace_event_raw_kvm_timer_restore_state {
	struct trace_entry ent;
	long unsigned int ctl;
	long long unsigned int cval;
	int timer_idx;
	char __data[0];
};

struct trace_event_raw_kvm_timer_hrtimer_expire {
	struct trace_entry ent;
	int timer_idx;
	char __data[0];
};

struct trace_event_raw_kvm_timer_emulate {
	struct trace_entry ent;
	int timer_idx;
	bool should_fire;
	char __data[0];
};

struct trace_event_data_offsets_kvm_entry {};

struct trace_event_data_offsets_kvm_exit {};

struct trace_event_data_offsets_kvm_guest_fault {};

struct trace_event_data_offsets_kvm_access_fault {};

struct trace_event_data_offsets_kvm_irq_line {};

struct trace_event_data_offsets_kvm_mmio_emulate {};

struct trace_event_data_offsets_kvm_set_way_flush {};

struct trace_event_data_offsets_kvm_toggle_cache {};

struct trace_event_data_offsets_kvm_timer_update_irq {};

struct trace_event_data_offsets_kvm_get_timer_map {};

struct trace_event_data_offsets_kvm_timer_save_state {};

struct trace_event_data_offsets_kvm_timer_restore_state {};

struct trace_event_data_offsets_kvm_timer_hrtimer_expire {};

struct trace_event_data_offsets_kvm_timer_emulate {};

typedef void (*btf_trace_kvm_entry)(void *, long unsigned int);

typedef void (*btf_trace_kvm_exit)(void *, int, unsigned int, long unsigned int);

typedef void (*btf_trace_kvm_guest_fault)(void *, long unsigned int, long unsigned int, long unsigned int, long long unsigned int);

typedef void (*btf_trace_kvm_access_fault)(void *, long unsigned int);

typedef void (*btf_trace_kvm_irq_line)(void *, unsigned int, int, int, int);

typedef void (*btf_trace_kvm_mmio_emulate)(void *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_kvm_set_way_flush)(void *, long unsigned int, bool);

typedef void (*btf_trace_kvm_toggle_cache)(void *, long unsigned int, bool, bool);

typedef void (*btf_trace_kvm_timer_update_irq)(void *, long unsigned int, __u32, int);

typedef void (*btf_trace_kvm_get_timer_map)(void *, long unsigned int, struct timer_map *);

typedef void (*btf_trace_kvm_timer_save_state)(void *, struct arch_timer_context *);

typedef void (*btf_trace_kvm_timer_restore_state)(void *, struct arch_timer_context *);

typedef void (*btf_trace_kvm_timer_hrtimer_expire)(void *, struct arch_timer_context *);

typedef void (*btf_trace_kvm_timer_emulate)(void *, struct arch_timer_context *, bool);

enum kvm_pgtable_prot {
	KVM_PGTABLE_PROT_X = 1,
	KVM_PGTABLE_PROT_W = 2,
	KVM_PGTABLE_PROT_R = 4,
	KVM_PGTABLE_PROT_DEVICE = 8,
};

enum kvm_arch_timers {
	TIMER_PTIMER = 0,
	TIMER_VTIMER = 1,
	NR_KVM_TIMERS = 2,
};

enum clocksource_ids {
	CSID_GENERIC = 0,
	CSID_ARM_ARCH_COUNTER = 1,
	CSID_MAX = 2,
};

struct system_time_snapshot {
	u64 cycles;
	ktime_t real;
	ktime_t raw;
	enum clocksource_ids cs_id;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
};

struct sys_reg_params {
	u8 Op0;
	u8 Op1;
	u8 CRn;
	u8 CRm;
	u8 Op2;
	u64 regval;
	bool is_write;
};

struct sys_reg_desc {
	const char *name;
	enum {
		AA32_ZEROHIGH = 0,
		AA32_LO = 1,
		AA32_HI = 2,
	} aarch32_map;
	u8 Op0;
	u8 Op1;
	u8 CRn;
	u8 CRm;
	u8 Op2;
	bool (*access)(struct kvm_vcpu *, struct sys_reg_params *, const struct sys_reg_desc *);
	void (*reset)(struct kvm_vcpu *, const struct sys_reg_desc *);
	int reg;
	u64 val;
	int (*__get_user)(struct kvm_vcpu *, const struct sys_reg_desc *, const struct kvm_one_reg *, void *);
	int (*set_user)(struct kvm_vcpu *, const struct sys_reg_desc *, const struct kvm_one_reg *, void *);
	unsigned int (*visibility)(const struct kvm_vcpu *, const struct sys_reg_desc *);
};

struct trace_event_raw_kvm_wfx_arm64 {
	struct trace_entry ent;
	long unsigned int vcpu_pc;
	bool is_wfe;
	char __data[0];
};

struct trace_event_raw_kvm_hvc_arm64 {
	struct trace_entry ent;
	long unsigned int vcpu_pc;
	long unsigned int r0;
	long unsigned int imm;
	char __data[0];
};

struct trace_event_raw_kvm_arm_setup_debug {
	struct trace_entry ent;
	struct kvm_vcpu *vcpu;
	__u32 guest_debug;
	char __data[0];
};

struct trace_event_raw_kvm_arm_clear_debug {
	struct trace_entry ent;
	__u32 guest_debug;
	char __data[0];
};

struct trace_event_raw_kvm_arm_set_dreg32 {
	struct trace_entry ent;
	const char *name;
	__u32 value;
	char __data[0];
};

struct trace_event_raw_kvm_arm_set_regset {
	struct trace_entry ent;
	const char *name;
	int len;
	u64 ctrls[16];
	u64 values[16];
	char __data[0];
};

struct trace_event_raw_trap_reg {
	struct trace_entry ent;
	const char *fn;
	int reg;
	bool is_write;
	u64 write_value;
	char __data[0];
};

struct trace_event_raw_kvm_handle_sys_reg {
	struct trace_entry ent;
	long unsigned int hsr;
	char __data[0];
};

struct trace_event_raw_kvm_sys_access {
	struct trace_entry ent;
	long unsigned int vcpu_pc;
	bool is_write;
	const char *name;
	u8 Op0;
	u8 Op1;
	u8 CRn;
	u8 CRm;
	u8 Op2;
	char __data[0];
};

struct trace_event_raw_kvm_set_guest_debug {
	struct trace_entry ent;
	struct kvm_vcpu *vcpu;
	__u32 guest_debug;
	char __data[0];
};

struct trace_event_data_offsets_kvm_wfx_arm64 {};

struct trace_event_data_offsets_kvm_hvc_arm64 {};

struct trace_event_data_offsets_kvm_arm_setup_debug {};

struct trace_event_data_offsets_kvm_arm_clear_debug {};

struct trace_event_data_offsets_kvm_arm_set_dreg32 {};

struct trace_event_data_offsets_kvm_arm_set_regset {};

struct trace_event_data_offsets_trap_reg {};

struct trace_event_data_offsets_kvm_handle_sys_reg {};

struct trace_event_data_offsets_kvm_sys_access {};

struct trace_event_data_offsets_kvm_set_guest_debug {};

typedef void (*btf_trace_kvm_wfx_arm64)(void *, long unsigned int, bool);

typedef void (*btf_trace_kvm_hvc_arm64)(void *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_kvm_arm_setup_debug)(void *, struct kvm_vcpu *, __u32);

typedef void (*btf_trace_kvm_arm_clear_debug)(void *, __u32);

typedef void (*btf_trace_kvm_arm_set_dreg32)(void *, const char *, __u32);

typedef void (*btf_trace_kvm_arm_set_regset)(void *, const char *, int, __u64 *, __u64 *);

typedef void (*btf_trace_trap_reg)(void *, const char *, int, bool, u64);

typedef void (*btf_trace_kvm_handle_sys_reg)(void *, long unsigned int);

typedef void (*btf_trace_kvm_sys_access)(void *, long unsigned int, struct sys_reg_params *, const struct sys_reg_desc *);

typedef void (*btf_trace_kvm_set_guest_debug)(void *, struct kvm_vcpu *, __u32);

typedef int (*exit_handle_fn)(struct kvm_vcpu *);

struct sve_state_reg_region {
	unsigned int koffset;
	unsigned int klen;
	unsigned int upad;
};

struct va_format {
	const char *fmt;
	va_list *va;
};

enum kvm_arch_timer_regs {
	TIMER_REG_CNT = 0,
	TIMER_REG_CVAL = 1,
	TIMER_REG_TVAL = 2,
	TIMER_REG_CTL = 3,
};

struct vgic_vmcr {
	u32 grpen0;
	u32 grpen1;
	u32 ackctl;
	u32 fiqen;
	u32 cbpr;
	u32 eoim;
	u32 abpr;
	u32 bpr;
	u32 pmr;
};

struct cyclecounter {
	u64 (*read)(const struct cyclecounter *);
	u64 mask;
	u32 mult;
	u32 shift;
};

struct timecounter {
	const struct cyclecounter *cc;
	u64 cycle_last;
	u64 nsec;
	u64 mask;
	u64 frac;
};

struct arch_timer_kvm_info {
	struct timecounter timecounter;
	int virtual_irq;
	int physical_irq;
};

enum hrtimer_mode {
	HRTIMER_MODE_ABS = 0,
	HRTIMER_MODE_REL = 1,
	HRTIMER_MODE_PINNED = 2,
	HRTIMER_MODE_SOFT = 4,
	HRTIMER_MODE_HARD = 8,
	HRTIMER_MODE_ABS_PINNED = 2,
	HRTIMER_MODE_REL_PINNED = 3,
	HRTIMER_MODE_ABS_SOFT = 4,
	HRTIMER_MODE_REL_SOFT = 5,
	HRTIMER_MODE_ABS_PINNED_SOFT = 6,
	HRTIMER_MODE_REL_PINNED_SOFT = 7,
	HRTIMER_MODE_ABS_HARD = 8,
	HRTIMER_MODE_REL_HARD = 9,
	HRTIMER_MODE_ABS_PINNED_HARD = 10,
	HRTIMER_MODE_REL_PINNED_HARD = 11,
};

struct trace_event_raw_vgic_update_irq_pending {
	struct trace_entry ent;
	long unsigned int vcpu_id;
	__u32 irq;
	bool level;
	char __data[0];
};

struct trace_event_data_offsets_vgic_update_irq_pending {};

typedef void (*btf_trace_vgic_update_irq_pending)(void *, long unsigned int, __u32, bool);

enum gic_type {
	GIC_V2 = 0,
	GIC_V3 = 1,
};

struct gic_kvm_info {
	enum gic_type type;
	struct resource vcpu;
	unsigned int maint_irq;
	struct resource vctrl;
	bool has_v4;
	bool has_v4_1;
};

struct its_vlpi_map {
	struct its_vm *vm;
	struct its_vpe *vpe;
	u32 vintid;
	u8 properties;
	bool db_enabled;
};

struct vgic_reg_attr {
	struct kvm_vcpu *vcpu;
	gpa_t addr;
};

struct its_device {
	struct list_head dev_list;
	struct list_head itt_head;
	u32 num_eventid_bits;
	gpa_t itt_addr;
	u32 device_id;
};

struct its_collection {
	struct list_head coll_list;
	u32 collection_id;
	u32 target_addr;
};

struct its_ite {
	struct list_head ite_list;
	struct vgic_irq *irq;
	struct its_collection *collection;
	u32 event_id;
};

struct vgic_translation_cache_entry {
	struct list_head entry;
	phys_addr_t db;
	u32 devid;
	u32 eventid;
	struct vgic_irq *irq;
};

struct vgic_its_abi {
	int cte_esz;
	int dte_esz;
	int ite_esz;
	int (*save_tables)(struct vgic_its *);
	int (*restore_tables)(struct vgic_its *);
	int (*commit)(struct vgic_its *);
};

typedef int (*entry_fn_t)(struct vgic_its *, u32, void *, void *);

struct vgic_state_iter {
	int nr_cpus;
	int nr_spis;
	int nr_lpis;
	int dist_id;
	int vcpu_id;
	int intid;
	int lpi_idx;
	u32 *lpi_array;
};

struct kvm_pmu_event_filter {
	__u16 base_event;
	__u16 nevents;
	__u8 action;
	__u8 pad[3];
};

struct tlb_inv_context {
	long unsigned int flags;
	u64 tcr;
	u64 sctlr;
};

enum exception_type {
	except_type_sync = 0,
	except_type_irq = 128,
	except_type_fiq = 256,
	except_type_serror = 384,
};

union hyp_spinlock {
	u32 __val;
	struct {
		u16 owner;
		u16 next;
	};
};

typedef union hyp_spinlock hyp_spinlock_t;

struct host_kvm {
	struct kvm_arch arch;
	struct kvm_pgtable pgt;
	struct kvm_pgtable_mm_ops mm_ops;
	hyp_spinlock_t lock;
};

struct tlb_inv_context___2 {
	u64 tcr;
};

struct hyp_pool;

typedef void (*hcall_t)(struct kvm_cpu_context *);

struct psci_boot_args {
	atomic_t lock;
	long unsigned int pc;
	long unsigned int r0;
};

struct hyp_pool___2;

struct hyp_page {
	unsigned int refcount;
	unsigned int order;
	struct hyp_pool___2 *pool;
	struct list_head node;
};

struct hyp_pool___2 {
	hyp_spinlock_t lock;
	struct list_head free_area[13];
	phys_addr_t range_start;
	phys_addr_t range_end;
	unsigned int max_order;
};

struct kvm_mem_range {
	u64 start;
	u64 end;
};

enum kvm_pgtable_walk_flags {
	KVM_PGTABLE_WALK_LEAF = 1,
	KVM_PGTABLE_WALK_TABLE_PRE = 2,
	KVM_PGTABLE_WALK_TABLE_POST = 4,
};

typedef int (*kvm_pgtable_visitor_fn_t)(u64, u64, u32, kvm_pte_t *, enum kvm_pgtable_walk_flags, void * const);

struct kvm_pgtable_walker {
	const kvm_pgtable_visitor_fn_t cb;
	void * const arg;
	const enum kvm_pgtable_walk_flags flags;
};

struct kvm_pgtable_walk_data {
	struct kvm_pgtable *pgt;
	struct kvm_pgtable_walker *walker;
	u64 addr;
	u64 end;
};

struct hyp_map_data {
	u64 phys;
	kvm_pte_t attr;
	struct kvm_pgtable_mm_ops *mm_ops;
};

struct stage2_map_data {
	u64 phys;
	kvm_pte_t attr;
	u8 owner_id;
	kvm_pte_t *anchor;
	kvm_pte_t *childp;
	struct kvm_s2_mmu *mmu;
	void *memcache;
	struct kvm_pgtable_mm_ops *mm_ops;
};

struct stage2_attr_data {
	kvm_pte_t attr_set;
	kvm_pte_t attr_clr;
	kvm_pte_t pte;
	u32 level;
};

typedef s16 int16_t;

typedef u16 uint16_t;

typedef struct {
	union {
		unsigned char *p;
		uint64_t q;
	};
} __guest_handle_uchar;

typedef struct {
	union {
		char *p;
		uint64_t q;
	};
} __guest_handle_char;

typedef struct {
	union {
		void *p;
		uint64_t q;
	};
} __guest_handle_void;

typedef struct {
	union {
		uint64_t *p;
		uint64_t q;
	};
} __guest_handle_uint64_t;

typedef struct {
	union {
		uint32_t *p;
		uint64_t q;
	};
} __guest_handle_uint32_t;

typedef uint16_t domid_t;

enum vdso_clock_mode {
	VDSO_CLOCKMODE_NONE = 0,
	VDSO_CLOCKMODE_ARCHTIMER = 1,
	VDSO_CLOCKMODE_ARCHTIMER_NOCOMPAT = 2,
	VDSO_CLOCKMODE_MAX = 3,
	VDSO_CLOCKMODE_TIMENS = 2147483647,
};

struct clocksource {
	u64 (*read)(struct clocksource *);
	u64 mask;
	u32 mult;
	u32 shift;
	u64 max_idle_ns;
	u32 maxadj;
	u32 uncertainty_margin;
	u64 max_cycles;
	const char *name;
	struct list_head list;
	int rating;
	enum clocksource_ids id;
	enum vdso_clock_mode vdso_clock_mode;
	long unsigned int flags;
	int (*enable)(struct clocksource *);
	void (*disable)(struct clocksource *);
	void (*suspend)(struct clocksource *);
	void (*resume)(struct clocksource *);
	void (*mark_unstable)(struct clocksource *);
	void (*tick_stable)(struct clocksource *);
	struct module *owner;
};

struct sched_shutdown {
	unsigned int reason;
};

struct xenpf_settime32 {
	uint32_t secs;
	uint32_t nsecs;
	uint64_t system_time;
};

struct xenpf_settime64 {
	uint64_t secs;
	uint32_t nsecs;
	uint32_t mbz;
	uint64_t system_time;
};

struct xenpf_add_memtype {
	xen_pfn_t mfn;
	uint64_t nr_mfns;
	uint32_t type;
	uint32_t handle;
	uint32_t reg;
};

struct xenpf_del_memtype {
	uint32_t handle;
	uint32_t reg;
};

struct xenpf_read_memtype {
	uint32_t reg;
	xen_pfn_t mfn;
	uint64_t nr_mfns;
	uint32_t type;
};

struct xenpf_microcode_update {
	__guest_handle_void data;
	uint32_t length;
};

struct xenpf_platform_quirk {
	uint32_t quirk_id;
};

struct xenpf_efi_time {
	uint16_t year;
	uint8_t month;
	uint8_t day;
	uint8_t hour;
	uint8_t min;
	uint8_t sec;
	uint32_t ns;
	int16_t tz;
	uint8_t daylight;
};

struct xenpf_efi_guid {
	uint32_t data1;
	uint16_t data2;
	uint16_t data3;
	uint8_t data4[8];
};

struct xenpf_efi_runtime_call {
	uint32_t function;
	uint32_t misc;
	xen_ulong_t status;
	union {
		struct {
			struct xenpf_efi_time time;
			uint32_t resolution;
			uint32_t accuracy;
		} get_time;
		struct xenpf_efi_time set_time;
		struct xenpf_efi_time get_wakeup_time;
		struct xenpf_efi_time set_wakeup_time;
		struct {
			__guest_handle_void name;
			xen_ulong_t size;
			__guest_handle_void data;
			struct xenpf_efi_guid vendor_guid;
		} get_variable;
		struct {
			__guest_handle_void name;
			xen_ulong_t size;
			__guest_handle_void data;
			struct xenpf_efi_guid vendor_guid;
		} set_variable;
		struct {
			xen_ulong_t size;
			__guest_handle_void name;
			struct xenpf_efi_guid vendor_guid;
		} get_next_variable_name;
		struct {
			uint32_t attr;
			uint64_t max_store_size;
			uint64_t remain_store_size;
			uint64_t max_size;
		} query_variable_info;
		struct {
			__guest_handle_void capsule_header_array;
			xen_ulong_t capsule_count;
			uint64_t max_capsule_size;
			uint32_t reset_type;
		} query_capsule_capabilities;
		struct {
			__guest_handle_void capsule_header_array;
			xen_ulong_t capsule_count;
			uint64_t sg_list;
		} update_capsule;
	} u;
};

union xenpf_efi_info {
	uint32_t version;
	struct {
		uint64_t addr;
		uint32_t nent;
	} cfg;
	struct {
		uint32_t revision;
		uint32_t bufsz;
		__guest_handle_void name;
	} vendor;
	struct {
		uint64_t addr;
		uint64_t size;
		uint64_t attr;
		uint32_t type;
	} mem;
};

struct xenpf_firmware_info {
	uint32_t type;
	uint32_t index;
	union {
		struct {
			uint8_t device;
			uint8_t version;
			uint16_t interface_support;
			uint16_t legacy_max_cylinder;
			uint8_t legacy_max_head;
			uint8_t legacy_sectors_per_track;
			__guest_handle_void edd_params;
		} disk_info;
		struct {
			uint8_t device;
			uint32_t mbr_signature;
		} disk_mbr_signature;
		struct {
			uint8_t capabilities;
			uint8_t edid_transfer_time;
			__guest_handle_uchar edid;
		} vbeddc_info;
		union xenpf_efi_info efi_info;
		uint8_t kbd_shift_flags;
	} u;
};

struct xenpf_enter_acpi_sleep {
	uint16_t val_a;
	uint16_t val_b;
	uint32_t sleep_state;
	uint32_t flags;
};

struct xenpf_change_freq {
	uint32_t flags;
	uint32_t cpu;
	uint64_t freq;
};

struct xenpf_getidletime {
	__guest_handle_uchar cpumap_bitmap;
	uint32_t cpumap_nr_cpus;
	__guest_handle_uint64_t idletime;
	uint64_t now;
};

struct xen_power_register {
	uint32_t space_id;
	uint32_t bit_width;
	uint32_t bit_offset;
	uint32_t access_size;
	uint64_t address;
};

struct xen_processor_csd {
	uint32_t domain;
	uint32_t coord_type;
	uint32_t num;
};

typedef struct {
	union {
		struct xen_processor_csd *p;
		uint64_t q;
	};
} __guest_handle_xen_processor_csd;

struct xen_processor_cx {
	struct xen_power_register reg;
	uint8_t type;
	uint32_t latency;
	uint32_t power;
	uint32_t dpcnt;
	__guest_handle_xen_processor_csd dp;
};

typedef struct {
	union {
		struct xen_processor_cx *p;
		uint64_t q;
	};
} __guest_handle_xen_processor_cx;

struct xen_processor_flags {
	uint32_t bm_control: 1;
	uint32_t bm_check: 1;
	uint32_t has_cst: 1;
	uint32_t power_setup_done: 1;
	uint32_t bm_rld_set: 1;
};

struct xen_processor_power {
	uint32_t count;
	struct xen_processor_flags flags;
	__guest_handle_xen_processor_cx states;
};

struct xen_pct_register {
	uint8_t descriptor;
	uint16_t length;
	uint8_t space_id;
	uint8_t bit_width;
	uint8_t bit_offset;
	uint8_t reserved;
	uint64_t address;
};

struct xen_processor_px {
	uint64_t core_frequency;
	uint64_t power;
	uint64_t transition_latency;
	uint64_t bus_master_latency;
	uint64_t control;
	uint64_t status;
};

typedef struct {
	union {
		struct xen_processor_px *p;
		uint64_t q;
	};
} __guest_handle_xen_processor_px;

struct xen_psd_package {
	uint64_t num_entries;
	uint64_t revision;
	uint64_t domain;
	uint64_t coord_type;
	uint64_t num_processors;
};

struct xen_processor_performance {
	uint32_t flags;
	uint32_t platform_limit;
	struct xen_pct_register control_register;
	struct xen_pct_register status_register;
	uint32_t state_count;
	__guest_handle_xen_processor_px states;
	struct xen_psd_package domain_info;
	uint32_t shared_type;
};

struct xenpf_set_processor_pminfo {
	uint32_t id;
	uint32_t type;
	union {
		struct xen_processor_power power;
		struct xen_processor_performance perf;
		__guest_handle_uint32_t pdc;
	};
};

struct xenpf_pcpuinfo {
	uint32_t xen_cpuid;
	uint32_t max_present;
	uint32_t flags;
	uint32_t apic_id;
	uint32_t acpi_id;
};

struct xenpf_cpu_ol {
	uint32_t cpuid;
};

struct xenpf_cpu_hotadd {
	uint32_t apic_id;
	uint32_t acpi_id;
	uint32_t pxm;
};

struct xenpf_mem_hotadd {
	uint64_t spfn;
	uint64_t epfn;
	uint32_t pxm;
	uint32_t flags;
};

struct xenpf_core_parking {
	uint32_t type;
	uint32_t idle_nums;
};

struct xenpf_symdata {
	uint32_t namelen;
	uint32_t symnum;
	__guest_handle_char name;
	uint64_t address;
	char type;
};

struct xen_platform_op {
	uint32_t cmd;
	uint32_t interface_version;
	union {
		struct xenpf_settime32 settime32;
		struct xenpf_settime64 settime64;
		struct xenpf_add_memtype add_memtype;
		struct xenpf_del_memtype del_memtype;
		struct xenpf_read_memtype read_memtype;
		struct xenpf_microcode_update microcode;
		struct xenpf_platform_quirk platform_quirk;
		struct xenpf_efi_runtime_call efi_runtime_call;
		struct xenpf_firmware_info firmware_info;
		struct xenpf_enter_acpi_sleep enter_acpi_sleep;
		struct xenpf_change_freq change_freq;
		struct xenpf_getidletime getidletime;
		struct xenpf_set_processor_pminfo set_pminfo;
		struct xenpf_pcpuinfo pcpu_info;
		struct xenpf_cpu_ol cpu_ol;
		struct xenpf_cpu_hotadd cpu_add;
		struct xenpf_mem_hotadd mem_add;
		struct xenpf_core_parking core_parking;
		struct xenpf_symdata symdata;
		uint8_t pad[128];
	} u;
};

struct xen_memory_region {
	long unsigned int start_pfn;
	long unsigned int n_pfns;
};

struct grant_frames {
	xen_pfn_t *pfn;
	unsigned int count;
	void *vaddr;
};

struct xen_hvm_param {
	domid_t domid;
	uint32_t index;
	uint64_t value;
};

struct vcpu_register_vcpu_info {
	uint64_t mfn;
	uint32_t offset;
	uint32_t rsvd;
};

struct xen_add_to_physmap {
	domid_t domid;
	uint16_t size;
	unsigned int space;
	xen_ulong_t idx;
	xen_pfn_t gpfn;
};

struct xsd_errors {
	int errnum;
	const char *errstring;
};

typedef uint32_t XENSTORE_RING_IDX;

struct xenstore_domain_interface {
	char req[1024];
	char rsp[1024];
	XENSTORE_RING_IDX req_cons;
	XENSTORE_RING_IDX req_prod;
	XENSTORE_RING_IDX rsp_cons;
	XENSTORE_RING_IDX rsp_prod;
};

struct tk_read_base {
	struct clocksource *clock;
	u64 mask;
	u64 cycle_last;
	u32 mult;
	u32 shift;
	u64 xtime_nsec;
	ktime_t base;
	u64 base_real;
};

struct timekeeper {
	struct tk_read_base tkr_mono;
	struct tk_read_base tkr_raw;
	u64 xtime_sec;
	long unsigned int ktime_sec;
	struct timespec64 wall_to_monotonic;
	ktime_t offs_real;
	ktime_t offs_boot;
	ktime_t offs_tai;
	s32 tai_offset;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
	ktime_t next_leap_ktime;
	u64 raw_sec;
	struct timespec64 monotonic_to_boot;
	u64 cycle_interval;
	u64 xtime_interval;
	s64 xtime_remainder;
	u64 raw_interval;
	u64 ntp_tick;
	s64 ntp_error;
	u32 ntp_error_shift;
	u32 ntp_err_mult;
	u32 skip_second_overflow;
};

typedef uint16_t grant_status_t;

typedef uint32_t grant_ref_t;

typedef uint32_t grant_handle_t;

struct gnttab_map_grant_ref {
	uint64_t host_addr;
	uint32_t flags;
	grant_ref_t ref;
	domid_t dom;
	int16_t status;
	grant_handle_t handle;
	uint64_t dev_bus_addr;
};

struct gnttab_unmap_grant_ref {
	uint64_t host_addr;
	uint64_t dev_bus_addr;
	grant_handle_t handle;
	int16_t status;
};

struct xen_p2m_entry {
	long unsigned int pfn;
	long unsigned int mfn;
	long unsigned int nr_pages;
	struct rb_node rbnode_phys;
};

struct gnttab_cache_flush {
	union {
		uint64_t dev_bus_addr;
		grant_ref_t ref;
	} a;
	uint16_t offset;
	uint16_t length;
	uint32_t op;
};

enum tk_offsets {
	TK_OFFS_REAL = 0,
	TK_OFFS_BOOT = 1,
	TK_OFFS_TAI = 2,
	TK_OFFS_MAX = 3,
};

struct clone_args {
	__u64 flags;
	__u64 pidfd;
	__u64 child_tid;
	__u64 parent_tid;
	__u64 exit_signal;
	__u64 stack;
	__u64 stack_size;
	__u64 tls;
	__u64 set_tid;
	__u64 set_tid_size;
	__u64 cgroup;
};

struct fdtable {
	unsigned int max_fds;
	struct file **fd;
	long unsigned int *close_on_exec;
	long unsigned int *open_fds;
	long unsigned int *full_fds_bits;
	struct callback_head rcu;
};

struct files_struct {
	atomic_t count;
	bool resize_in_progress;
	wait_queue_head_t resize_wait;
	struct fdtable *fdt;
	struct fdtable fdtab;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t file_lock;
	unsigned int next_fd;
	long unsigned int close_on_exec_init[1];
	long unsigned int open_fds_init[1];
	long unsigned int full_fds_bits_init[1];
	struct file *fd_array[64];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct robust_list {
	struct robust_list *next;
};

struct robust_list_head {
	struct robust_list list;
	long int futex_offset;
	struct robust_list *list_op_pending;
};

struct kernel_clone_args {
	u64 flags;
	int *pidfd;
	int *child_tid;
	int *parent_tid;
	int exit_signal;
	long unsigned int stack;
	long unsigned int stack_size;
	long unsigned int tls;
	pid_t *set_tid;
	size_t set_tid_size;
	int cgroup;
	int io_thread;
	struct cgroup *cgrp;
	struct css_set *cset;
};

struct multiprocess_signals {
	sigset_t signal;
	struct hlist_node node;
};

typedef int (*proc_visitor)(struct task_struct *, void *);

enum {
	IOPRIO_CLASS_NONE = 0,
	IOPRIO_CLASS_RT = 1,
	IOPRIO_CLASS_BE = 2,
	IOPRIO_CLASS_IDLE = 3,
};

enum {
	FUTEX_STATE_OK = 0,
	FUTEX_STATE_EXITING = 1,
	FUTEX_STATE_DEAD = 2,
};

enum proc_hidepid {
	HIDEPID_OFF = 0,
	HIDEPID_NO_ACCESS = 1,
	HIDEPID_INVISIBLE = 2,
	HIDEPID_NOT_PTRACEABLE = 4,
};

enum proc_pidonly {
	PROC_PIDONLY_OFF = 0,
	PROC_PIDONLY_ON = 1,
};

struct proc_fs_info {
	struct pid_namespace *pid_ns;
	struct dentry *proc_self;
	struct dentry *proc_thread_self;
	kgid_t pid_gid;
	enum proc_hidepid hide_pid;
	enum proc_pidonly pidonly;
};

struct trace_event_raw_task_newtask {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	long unsigned int clone_flags;
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_task_rename {
	struct trace_entry ent;
	pid_t pid;
	char oldcomm[16];
	char newcomm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_data_offsets_task_newtask {};

struct trace_event_data_offsets_task_rename {};

typedef void (*btf_trace_task_newtask)(void *, struct task_struct *, long unsigned int);

typedef void (*btf_trace_task_rename)(void *, struct task_struct *, const char *);

enum flow_dissector_key_id {
	FLOW_DISSECTOR_KEY_CONTROL = 0,
	FLOW_DISSECTOR_KEY_BASIC = 1,
	FLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,
	FLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,
	FLOW_DISSECTOR_KEY_PORTS = 4,
	FLOW_DISSECTOR_KEY_PORTS_RANGE = 5,
	FLOW_DISSECTOR_KEY_ICMP = 6,
	FLOW_DISSECTOR_KEY_ETH_ADDRS = 7,
	FLOW_DISSECTOR_KEY_TIPC = 8,
	FLOW_DISSECTOR_KEY_ARP = 9,
	FLOW_DISSECTOR_KEY_VLAN = 10,
	FLOW_DISSECTOR_KEY_FLOW_LABEL = 11,
	FLOW_DISSECTOR_KEY_GRE_KEYID = 12,
	FLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,
	FLOW_DISSECTOR_KEY_ENC_KEYID = 14,
	FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,
	FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,
	FLOW_DISSECTOR_KEY_ENC_CONTROL = 17,
	FLOW_DISSECTOR_KEY_ENC_PORTS = 18,
	FLOW_DISSECTOR_KEY_MPLS = 19,
	FLOW_DISSECTOR_KEY_TCP = 20,
	FLOW_DISSECTOR_KEY_IP = 21,
	FLOW_DISSECTOR_KEY_CVLAN = 22,
	FLOW_DISSECTOR_KEY_ENC_IP = 23,
	FLOW_DISSECTOR_KEY_ENC_OPTS = 24,
	FLOW_DISSECTOR_KEY_META = 25,
	FLOW_DISSECTOR_KEY_CT = 26,
	FLOW_DISSECTOR_KEY_HASH = 27,
	FLOW_DISSECTOR_KEY_MAX = 28,
};

enum {
	IPSTATS_MIB_NUM = 0,
	IPSTATS_MIB_INPKTS = 1,
	IPSTATS_MIB_INOCTETS = 2,
	IPSTATS_MIB_INDELIVERS = 3,
	IPSTATS_MIB_OUTFORWDATAGRAMS = 4,
	IPSTATS_MIB_OUTPKTS = 5,
	IPSTATS_MIB_OUTOCTETS = 6,
	IPSTATS_MIB_INHDRERRORS = 7,
	IPSTATS_MIB_INTOOBIGERRORS = 8,
	IPSTATS_MIB_INNOROUTES = 9,
	IPSTATS_MIB_INADDRERRORS = 10,
	IPSTATS_MIB_INUNKNOWNPROTOS = 11,
	IPSTATS_MIB_INTRUNCATEDPKTS = 12,
	IPSTATS_MIB_INDISCARDS = 13,
	IPSTATS_MIB_OUTDISCARDS = 14,
	IPSTATS_MIB_OUTNOROUTES = 15,
	IPSTATS_MIB_REASMTIMEOUT = 16,
	IPSTATS_MIB_REASMREQDS = 17,
	IPSTATS_MIB_REASMOKS = 18,
	IPSTATS_MIB_REASMFAILS = 19,
	IPSTATS_MIB_FRAGOKS = 20,
	IPSTATS_MIB_FRAGFAILS = 21,
	IPSTATS_MIB_FRAGCREATES = 22,
	IPSTATS_MIB_INMCASTPKTS = 23,
	IPSTATS_MIB_OUTMCASTPKTS = 24,
	IPSTATS_MIB_INBCASTPKTS = 25,
	IPSTATS_MIB_OUTBCASTPKTS = 26,
	IPSTATS_MIB_INMCASTOCTETS = 27,
	IPSTATS_MIB_OUTMCASTOCTETS = 28,
	IPSTATS_MIB_INBCASTOCTETS = 29,
	IPSTATS_MIB_OUTBCASTOCTETS = 30,
	IPSTATS_MIB_CSUMERRORS = 31,
	IPSTATS_MIB_NOECTPKTS = 32,
	IPSTATS_MIB_ECT1PKTS = 33,
	IPSTATS_MIB_ECT0PKTS = 34,
	IPSTATS_MIB_CEPKTS = 35,
	IPSTATS_MIB_REASM_OVERLAPS = 36,
	__IPSTATS_MIB_MAX = 37,
};

enum {
	ICMP_MIB_NUM = 0,
	ICMP_MIB_INMSGS = 1,
	ICMP_MIB_INERRORS = 2,
	ICMP_MIB_INDESTUNREACHS = 3,
	ICMP_MIB_INTIMEEXCDS = 4,
	ICMP_MIB_INPARMPROBS = 5,
	ICMP_MIB_INSRCQUENCHS = 6,
	ICMP_MIB_INREDIRECTS = 7,
	ICMP_MIB_INECHOS = 8,
	ICMP_MIB_INECHOREPS = 9,
	ICMP_MIB_INTIMESTAMPS = 10,
	ICMP_MIB_INTIMESTAMPREPS = 11,
	ICMP_MIB_INADDRMASKS = 12,
	ICMP_MIB_INADDRMASKREPS = 13,
	ICMP_MIB_OUTMSGS = 14,
	ICMP_MIB_OUTERRORS = 15,
	ICMP_MIB_OUTDESTUNREACHS = 16,
	ICMP_MIB_OUTTIMEEXCDS = 17,
	ICMP_MIB_OUTPARMPROBS = 18,
	ICMP_MIB_OUTSRCQUENCHS = 19,
	ICMP_MIB_OUTREDIRECTS = 20,
	ICMP_MIB_OUTECHOS = 21,
	ICMP_MIB_OUTECHOREPS = 22,
	ICMP_MIB_OUTTIMESTAMPS = 23,
	ICMP_MIB_OUTTIMESTAMPREPS = 24,
	ICMP_MIB_OUTADDRMASKS = 25,
	ICMP_MIB_OUTADDRMASKREPS = 26,
	ICMP_MIB_CSUMERRORS = 27,
	__ICMP_MIB_MAX = 28,
};

enum {
	ICMP6_MIB_NUM = 0,
	ICMP6_MIB_INMSGS = 1,
	ICMP6_MIB_INERRORS = 2,
	ICMP6_MIB_OUTMSGS = 3,
	ICMP6_MIB_OUTERRORS = 4,
	ICMP6_MIB_CSUMERRORS = 5,
	__ICMP6_MIB_MAX = 6,
};

enum {
	TCP_MIB_NUM = 0,
	TCP_MIB_RTOALGORITHM = 1,
	TCP_MIB_RTOMIN = 2,
	TCP_MIB_RTOMAX = 3,
	TCP_MIB_MAXCONN = 4,
	TCP_MIB_ACTIVEOPENS = 5,
	TCP_MIB_PASSIVEOPENS = 6,
	TCP_MIB_ATTEMPTFAILS = 7,
	TCP_MIB_ESTABRESETS = 8,
	TCP_MIB_CURRESTAB = 9,
	TCP_MIB_INSEGS = 10,
	TCP_MIB_OUTSEGS = 11,
	TCP_MIB_RETRANSSEGS = 12,
	TCP_MIB_INERRS = 13,
	TCP_MIB_OUTRSTS = 14,
	TCP_MIB_CSUMERRORS = 15,
	__TCP_MIB_MAX = 16,
};

enum {
	UDP_MIB_NUM = 0,
	UDP_MIB_INDATAGRAMS = 1,
	UDP_MIB_NOPORTS = 2,
	UDP_MIB_INERRORS = 3,
	UDP_MIB_OUTDATAGRAMS = 4,
	UDP_MIB_RCVBUFERRORS = 5,
	UDP_MIB_SNDBUFERRORS = 6,
	UDP_MIB_CSUMERRORS = 7,
	UDP_MIB_IGNOREDMULTI = 8,
	UDP_MIB_MEMERRORS = 9,
	__UDP_MIB_MAX = 10,
};

enum {
	LINUX_MIB_NUM = 0,
	LINUX_MIB_SYNCOOKIESSENT = 1,
	LINUX_MIB_SYNCOOKIESRECV = 2,
	LINUX_MIB_SYNCOOKIESFAILED = 3,
	LINUX_MIB_EMBRYONICRSTS = 4,
	LINUX_MIB_PRUNECALLED = 5,
	LINUX_MIB_RCVPRUNED = 6,
	LINUX_MIB_OFOPRUNED = 7,
	LINUX_MIB_OUTOFWINDOWICMPS = 8,
	LINUX_MIB_LOCKDROPPEDICMPS = 9,
	LINUX_MIB_ARPFILTER = 10,
	LINUX_MIB_TIMEWAITED = 11,
	LINUX_MIB_TIMEWAITRECYCLED = 12,
	LINUX_MIB_TIMEWAITKILLED = 13,
	LINUX_MIB_PAWSACTIVEREJECTED = 14,
	LINUX_MIB_PAWSESTABREJECTED = 15,
	LINUX_MIB_DELAYEDACKS = 16,
	LINUX_MIB_DELAYEDACKLOCKED = 17,
	LINUX_MIB_DELAYEDACKLOST = 18,
	LINUX_MIB_LISTENOVERFLOWS = 19,
	LINUX_MIB_LISTENDROPS = 20,
	LINUX_MIB_TCPHPHITS = 21,
	LINUX_MIB_TCPPUREACKS = 22,
	LINUX_MIB_TCPHPACKS = 23,
	LINUX_MIB_TCPRENORECOVERY = 24,
	LINUX_MIB_TCPSACKRECOVERY = 25,
	LINUX_MIB_TCPSACKRENEGING = 26,
	LINUX_MIB_TCPSACKREORDER = 27,
	LINUX_MIB_TCPRENOREORDER = 28,
	LINUX_MIB_TCPTSREORDER = 29,
	LINUX_MIB_TCPFULLUNDO = 30,
	LINUX_MIB_TCPPARTIALUNDO = 31,
	LINUX_MIB_TCPDSACKUNDO = 32,
	LINUX_MIB_TCPLOSSUNDO = 33,
	LINUX_MIB_TCPLOSTRETRANSMIT = 34,
	LINUX_MIB_TCPRENOFAILURES = 35,
	LINUX_MIB_TCPSACKFAILURES = 36,
	LINUX_MIB_TCPLOSSFAILURES = 37,
	LINUX_MIB_TCPFASTRETRANS = 38,
	LINUX_MIB_TCPSLOWSTARTRETRANS = 39,
	LINUX_MIB_TCPTIMEOUTS = 40,
	LINUX_MIB_TCPLOSSPROBES = 41,
	LINUX_MIB_TCPLOSSPROBERECOVERY = 42,
	LINUX_MIB_TCPRENORECOVERYFAIL = 43,
	LINUX_MIB_TCPSACKRECOVERYFAIL = 44,
	LINUX_MIB_TCPRCVCOLLAPSED = 45,
	LINUX_MIB_TCPDSACKOLDSENT = 46,
	LINUX_MIB_TCPDSACKOFOSENT = 47,
	LINUX_MIB_TCPDSACKRECV = 48,
	LINUX_MIB_TCPDSACKOFORECV = 49,
	LINUX_MIB_TCPABORTONDATA = 50,
	LINUX_MIB_TCPABORTONCLOSE = 51,
	LINUX_MIB_TCPABORTONMEMORY = 52,
	LINUX_MIB_TCPABORTONTIMEOUT = 53,
	LINUX_MIB_TCPABORTONLINGER = 54,
	LINUX_MIB_TCPABORTFAILED = 55,
	LINUX_MIB_TCPMEMORYPRESSURES = 56,
	LINUX_MIB_TCPMEMORYPRESSURESCHRONO = 57,
	LINUX_MIB_TCPSACKDISCARD = 58,
	LINUX_MIB_TCPDSACKIGNOREDOLD = 59,
	LINUX_MIB_TCPDSACKIGNOREDNOUNDO = 60,
	LINUX_MIB_TCPSPURIOUSRTOS = 61,
	LINUX_MIB_TCPMD5NOTFOUND = 62,
	LINUX_MIB_TCPMD5UNEXPECTED = 63,
	LINUX_MIB_TCPMD5FAILURE = 64,
	LINUX_MIB_SACKSHIFTED = 65,
	LINUX_MIB_SACKMERGED = 66,
	LINUX_MIB_SACKSHIFTFALLBACK = 67,
	LINUX_MIB_TCPBACKLOGDROP = 68,
	LINUX_MIB_PFMEMALLOCDROP = 69,
	LINUX_MIB_TCPMINTTLDROP = 70,
	LINUX_MIB_TCPDEFERACCEPTDROP = 71,
	LINUX_MIB_IPRPFILTER = 72,
	LINUX_MIB_TCPTIMEWAITOVERFLOW = 73,
	LINUX_MIB_TCPREQQFULLDOCOOKIES = 74,
	LINUX_MIB_TCPREQQFULLDROP = 75,
	LINUX_MIB_TCPRETRANSFAIL = 76,
	LINUX_MIB_TCPRCVCOALESCE = 77,
	LINUX_MIB_TCPBACKLOGCOALESCE = 78,
	LINUX_MIB_TCPOFOQUEUE = 79,
	LINUX_MIB_TCPOFODROP = 80,
	LINUX_MIB_TCPOFOMERGE = 81,
	LINUX_MIB_TCPCHALLENGEACK = 82,
	LINUX_MIB_TCPSYNCHALLENGE = 83,
	LINUX_MIB_TCPFASTOPENACTIVE = 84,
	LINUX_MIB_TCPFASTOPENACTIVEFAIL = 85,
	LINUX_MIB_TCPFASTOPENPASSIVE = 86,
	LINUX_MIB_TCPFASTOPENPASSIVEFAIL = 87,
	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW = 88,
	LINUX_MIB_TCPFASTOPENCOOKIEREQD = 89,
	LINUX_MIB_TCPFASTOPENBLACKHOLE = 90,
	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES = 91,
	LINUX_MIB_BUSYPOLLRXPACKETS = 92,
	LINUX_MIB_TCPAUTOCORKING = 93,
	LINUX_MIB_TCPFROMZEROWINDOWADV = 94,
	LINUX_MIB_TCPTOZEROWINDOWADV = 95,
	LINUX_MIB_TCPWANTZEROWINDOWADV = 96,
	LINUX_MIB_TCPSYNRETRANS = 97,
	LINUX_MIB_TCPORIGDATASENT = 98,
	LINUX_MIB_TCPHYSTARTTRAINDETECT = 99,
	LINUX_MIB_TCPHYSTARTTRAINCWND = 100,
	LINUX_MIB_TCPHYSTARTDELAYDETECT = 101,
	LINUX_MIB_TCPHYSTARTDELAYCWND = 102,
	LINUX_MIB_TCPACKSKIPPEDSYNRECV = 103,
	LINUX_MIB_TCPACKSKIPPEDPAWS = 104,
	LINUX_MIB_TCPACKSKIPPEDSEQ = 105,
	LINUX_MIB_TCPACKSKIPPEDFINWAIT2 = 106,
	LINUX_MIB_TCPACKSKIPPEDTIMEWAIT = 107,
	LINUX_MIB_TCPACKSKIPPEDCHALLENGE = 108,
	LINUX_MIB_TCPWINPROBE = 109,
	LINUX_MIB_TCPKEEPALIVE = 110,
	LINUX_MIB_TCPMTUPFAIL = 111,
	LINUX_MIB_TCPMTUPSUCCESS = 112,
	LINUX_MIB_TCPDELIVERED = 113,
	LINUX_MIB_TCPDELIVEREDCE = 114,
	LINUX_MIB_TCPACKCOMPRESSED = 115,
	LINUX_MIB_TCPZEROWINDOWDROP = 116,
	LINUX_MIB_TCPRCVQDROP = 117,
	LINUX_MIB_TCPWQUEUETOOBIG = 118,
	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY = 119,
	LINUX_MIB_TCPTIMEOUTREHASH = 120,
	LINUX_MIB_TCPDUPLICATEDATAREHASH = 121,
	LINUX_MIB_TCPDSACKRECVSEGS = 122,
	LINUX_MIB_TCPDSACKIGNOREDDUBIOUS = 123,
	__LINUX_MIB_MAX = 124,
};

enum {
	LINUX_MIB_XFRMNUM = 0,
	LINUX_MIB_XFRMINERROR = 1,
	LINUX_MIB_XFRMINBUFFERERROR = 2,
	LINUX_MIB_XFRMINHDRERROR = 3,
	LINUX_MIB_XFRMINNOSTATES = 4,
	LINUX_MIB_XFRMINSTATEPROTOERROR = 5,
	LINUX_MIB_XFRMINSTATEMODEERROR = 6,
	LINUX_MIB_XFRMINSTATESEQERROR = 7,
	LINUX_MIB_XFRMINSTATEEXPIRED = 8,
	LINUX_MIB_XFRMINSTATEMISMATCH = 9,
	LINUX_MIB_XFRMINSTATEINVALID = 10,
	LINUX_MIB_XFRMINTMPLMISMATCH = 11,
	LINUX_MIB_XFRMINNOPOLS = 12,
	LINUX_MIB_XFRMINPOLBLOCK = 13,
	LINUX_MIB_XFRMINPOLERROR = 14,
	LINUX_MIB_XFRMOUTERROR = 15,
	LINUX_MIB_XFRMOUTBUNDLEGENERROR = 16,
	LINUX_MIB_XFRMOUTBUNDLECHECKERROR = 17,
	LINUX_MIB_XFRMOUTNOSTATES = 18,
	LINUX_MIB_XFRMOUTSTATEPROTOERROR = 19,
	LINUX_MIB_XFRMOUTSTATEMODEERROR = 20,
	LINUX_MIB_XFRMOUTSTATESEQERROR = 21,
	LINUX_MIB_XFRMOUTSTATEEXPIRED = 22,
	LINUX_MIB_XFRMOUTPOLBLOCK = 23,
	LINUX_MIB_XFRMOUTPOLDEAD = 24,
	LINUX_MIB_XFRMOUTPOLERROR = 25,
	LINUX_MIB_XFRMFWDHDRERROR = 26,
	LINUX_MIB_XFRMOUTSTATEINVALID = 27,
	LINUX_MIB_XFRMACQUIREERROR = 28,
	__LINUX_MIB_XFRMMAX = 29,
};

enum {
	LINUX_MIB_TLSNUM = 0,
	LINUX_MIB_TLSCURRTXSW = 1,
	LINUX_MIB_TLSCURRRXSW = 2,
	LINUX_MIB_TLSCURRTXDEVICE = 3,
	LINUX_MIB_TLSCURRRXDEVICE = 4,
	LINUX_MIB_TLSTXSW = 5,
	LINUX_MIB_TLSRXSW = 6,
	LINUX_MIB_TLSTXDEVICE = 7,
	LINUX_MIB_TLSRXDEVICE = 8,
	LINUX_MIB_TLSDECRYPTERROR = 9,
	LINUX_MIB_TLSRXDEVICERESYNC = 10,
	__LINUX_MIB_TLSMAX = 11,
};

enum nf_inet_hooks {
	NF_INET_PRE_ROUTING = 0,
	NF_INET_LOCAL_IN = 1,
	NF_INET_FORWARD = 2,
	NF_INET_LOCAL_OUT = 3,
	NF_INET_POST_ROUTING = 4,
	NF_INET_NUMHOOKS = 5,
	NF_INET_INGRESS = 5,
};

enum {
	NFPROTO_UNSPEC = 0,
	NFPROTO_INET = 1,
	NFPROTO_IPV4 = 2,
	NFPROTO_ARP = 3,
	NFPROTO_NETDEV = 5,
	NFPROTO_BRIDGE = 7,
	NFPROTO_IPV6 = 10,
	NFPROTO_DECNET = 12,
	NFPROTO_NUMPROTO = 13,
};

enum tcp_conntrack {
	TCP_CONNTRACK_NONE = 0,
	TCP_CONNTRACK_SYN_SENT = 1,
	TCP_CONNTRACK_SYN_RECV = 2,
	TCP_CONNTRACK_ESTABLISHED = 3,
	TCP_CONNTRACK_FIN_WAIT = 4,
	TCP_CONNTRACK_CLOSE_WAIT = 5,
	TCP_CONNTRACK_LAST_ACK = 6,
	TCP_CONNTRACK_TIME_WAIT = 7,
	TCP_CONNTRACK_CLOSE = 8,
	TCP_CONNTRACK_LISTEN = 9,
	TCP_CONNTRACK_MAX = 10,
	TCP_CONNTRACK_IGNORE = 11,
	TCP_CONNTRACK_RETRANS = 12,
	TCP_CONNTRACK_UNACK = 13,
	TCP_CONNTRACK_TIMEOUT_MAX = 14,
};

enum ct_dccp_states {
	CT_DCCP_NONE = 0,
	CT_DCCP_REQUEST = 1,
	CT_DCCP_RESPOND = 2,
	CT_DCCP_PARTOPEN = 3,
	CT_DCCP_OPEN = 4,
	CT_DCCP_CLOSEREQ = 5,
	CT_DCCP_CLOSING = 6,
	CT_DCCP_TIMEWAIT = 7,
	CT_DCCP_IGNORE = 8,
	CT_DCCP_INVALID = 9,
	__CT_DCCP_MAX = 10,
};

enum ip_conntrack_dir {
	IP_CT_DIR_ORIGINAL = 0,
	IP_CT_DIR_REPLY = 1,
	IP_CT_DIR_MAX = 2,
};

enum sctp_conntrack {
	SCTP_CONNTRACK_NONE = 0,
	SCTP_CONNTRACK_CLOSED = 1,
	SCTP_CONNTRACK_COOKIE_WAIT = 2,
	SCTP_CONNTRACK_COOKIE_ECHOED = 3,
	SCTP_CONNTRACK_ESTABLISHED = 4,
	SCTP_CONNTRACK_SHUTDOWN_SENT = 5,
	SCTP_CONNTRACK_SHUTDOWN_RECD = 6,
	SCTP_CONNTRACK_SHUTDOWN_ACK_SENT = 7,
	SCTP_CONNTRACK_HEARTBEAT_SENT = 8,
	SCTP_CONNTRACK_HEARTBEAT_ACKED = 9,
	SCTP_CONNTRACK_MAX = 10,
};

enum udp_conntrack {
	UDP_CT_UNREPLIED = 0,
	UDP_CT_REPLIED = 1,
	UDP_CT_MAX = 2,
};

enum gre_conntrack {
	GRE_CT_UNREPLIED = 0,
	GRE_CT_REPLIED = 1,
	GRE_CT_MAX = 2,
};

enum {
	XFRM_POLICY_IN = 0,
	XFRM_POLICY_OUT = 1,
	XFRM_POLICY_FWD = 2,
	XFRM_POLICY_MASK = 3,
	XFRM_POLICY_MAX = 3,
};

enum netns_bpf_attach_type {
	NETNS_BPF_INVALID = 4294967295,
	NETNS_BPF_FLOW_DISSECTOR = 0,
	NETNS_BPF_SK_LOOKUP = 1,
	MAX_NETNS_BPF_ATTACH_TYPE = 2,
};

enum skb_ext_id {
	SKB_EXT_BRIDGE_NF = 0,
	SKB_EXT_SEC_PATH = 1,
	TC_SKB_EXT = 2,
	SKB_EXT_MPTCP = 3,
	SKB_EXT_NUM = 4,
};

enum kmsg_dump_reason {
	KMSG_DUMP_UNDEF = 0,
	KMSG_DUMP_PANIC = 1,
	KMSG_DUMP_OOPS = 2,
	KMSG_DUMP_EMERG = 3,
	KMSG_DUMP_SHUTDOWN = 4,
	KMSG_DUMP_MAX = 5,
};

struct vc {
	struct vc_data *d;
	struct work_struct SAK_work;
};

struct vt_spawn_console {
	spinlock_t lock;
	struct pid *pid;
	int sig;
};

enum con_flush_mode {
	CONSOLE_FLUSH_PENDING = 0,
	CONSOLE_REPLAY_ALL = 1,
};

struct warn_args {
	const char *fmt;
	va_list args;
};

enum hk_flags {
	HK_FLAG_TIMER = 1,
	HK_FLAG_RCU = 2,
	HK_FLAG_MISC = 4,
	HK_FLAG_SCHED = 8,
	HK_FLAG_TICK = 16,
	HK_FLAG_DOMAIN = 32,
	HK_FLAG_WQ = 64,
	HK_FLAG_MANAGED_IRQ = 128,
	HK_FLAG_KTHREAD = 256,
};

enum cpuhp_smt_control {
	CPU_SMT_ENABLED = 0,
	CPU_SMT_DISABLED = 1,
	CPU_SMT_FORCE_DISABLED = 2,
	CPU_SMT_NOT_SUPPORTED = 3,
	CPU_SMT_NOT_IMPLEMENTED = 4,
};

struct smp_hotplug_thread {
	struct task_struct **store;
	struct list_head list;
	int (*thread_should_run)(unsigned int);
	void (*thread_fn)(unsigned int);
	void (*create)(unsigned int);
	void (*setup)(unsigned int);
	void (*cleanup)(unsigned int, bool);
	void (*park)(unsigned int);
	void (*unpark)(unsigned int);
	bool selfparking;
	const char *thread_comm;
};

struct trace_event_raw_cpuhp_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_multi_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_exit {
	struct trace_entry ent;
	unsigned int cpu;
	int state;
	int idx;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_cpuhp_enter {};

struct trace_event_data_offsets_cpuhp_multi_enter {};

struct trace_event_data_offsets_cpuhp_exit {};

typedef void (*btf_trace_cpuhp_enter)(void *, unsigned int, int, int, int (*)(unsigned int));

typedef void (*btf_trace_cpuhp_multi_enter)(void *, unsigned int, int, int, int (*)(unsigned int, struct hlist_node *), struct hlist_node *);

typedef void (*btf_trace_cpuhp_exit)(void *, unsigned int, int, int, int);

struct cpuhp_cpu_state {
	enum cpuhp_state state;
	enum cpuhp_state target;
	enum cpuhp_state fail;
	struct task_struct *thread;
	bool should_run;
	bool rollback;
	bool single;
	bool bringup;
	int cpu;
	struct hlist_node *node;
	struct hlist_node *last;
	enum cpuhp_state cb_state;
	int result;
	struct completion done_up;
	struct completion done_down;
};

struct cpuhp_step {
	const char *name;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} startup;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} teardown;
	struct hlist_head list;
	bool cant_stop;
	bool multi_instance;
};

enum cpu_mitigations {
	CPU_MITIGATIONS_OFF = 0,
	CPU_MITIGATIONS_AUTO = 1,
	CPU_MITIGATIONS_AUTO_NOSMT = 2,
};

struct __kernel_old_timeval {
	__kernel_long_t tv_sec;
	__kernel_long_t tv_usec;
};

struct old_timeval32 {
	old_time32_t tv_sec;
	s32 tv_usec;
};

struct rusage {
	struct __kernel_old_timeval ru_utime;
	struct __kernel_old_timeval ru_stime;
	__kernel_long_t ru_maxrss;
	__kernel_long_t ru_ixrss;
	__kernel_long_t ru_idrss;
	__kernel_long_t ru_isrss;
	__kernel_long_t ru_minflt;
	__kernel_long_t ru_majflt;
	__kernel_long_t ru_nswap;
	__kernel_long_t ru_inblock;
	__kernel_long_t ru_oublock;
	__kernel_long_t ru_msgsnd;
	__kernel_long_t ru_msgrcv;
	__kernel_long_t ru_nsignals;
	__kernel_long_t ru_nvcsw;
	__kernel_long_t ru_nivcsw;
};

typedef u32 compat_uint_t;

typedef struct {} mm_segment_t;

struct compat_rusage {
	struct old_timeval32 ru_utime;
	struct old_timeval32 ru_stime;
	compat_long_t ru_maxrss;
	compat_long_t ru_ixrss;
	compat_long_t ru_idrss;
	compat_long_t ru_isrss;
	compat_long_t ru_minflt;
	compat_long_t ru_majflt;
	compat_long_t ru_nswap;
	compat_long_t ru_inblock;
	compat_long_t ru_oublock;
	compat_long_t ru_msgsnd;
	compat_long_t ru_msgrcv;
	compat_long_t ru_nsignals;
	compat_long_t ru_nvcsw;
	compat_long_t ru_nivcsw;
};

struct waitid_info {
	pid_t pid;
	uid_t uid;
	int status;
	int cause;
};

struct wait_opts {
	enum pid_type wo_type;
	int wo_flags;
	struct pid *wo_pid;
	struct waitid_info *wo_info;
	int wo_stat;
	struct rusage *wo_rusage;
	wait_queue_entry_t child_wait;
	int notask_error;
};

struct softirq_action {
	void (*action)(struct softirq_action *);
};

struct tasklet_struct {
	struct tasklet_struct *next;
	long unsigned int state;
	atomic_t count;
	bool use_callback;
	union {
		void (*func)(long unsigned int);
		void (*callback)(struct tasklet_struct *);
	};
	long unsigned int data;
};

enum {
	TASKLET_STATE_SCHED = 0,
	TASKLET_STATE_RUN = 1,
};

struct wait_bit_key {
	void *flags;
	int bit_nr;
	long unsigned int timeout;
};

struct wait_bit_queue_entry {
	struct wait_bit_key key;
	struct wait_queue_entry wq_entry;
};

struct trace_event_raw_irq_handler_entry {
	struct trace_entry ent;
	int irq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_irq_handler_exit {
	struct trace_entry ent;
	int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_softirq {
	struct trace_entry ent;
	unsigned int vec;
	char __data[0];
};

struct trace_event_data_offsets_irq_handler_entry {
	u32 name;
};

struct trace_event_data_offsets_irq_handler_exit {};

struct trace_event_data_offsets_softirq {};

typedef void (*btf_trace_irq_handler_entry)(void *, int, struct irqaction *);

typedef void (*btf_trace_irq_handler_exit)(void *, int, struct irqaction *, int);

typedef void (*btf_trace_softirq_entry)(void *, unsigned int);

typedef void (*btf_trace_softirq_exit)(void *, unsigned int);

typedef void (*btf_trace_softirq_raise)(void *, unsigned int);

struct tasklet_head {
	struct tasklet_struct *head;
	struct tasklet_struct **tail;
};

enum {
	IORES_DESC_NONE = 0,
	IORES_DESC_CRASH_KERNEL = 1,
	IORES_DESC_ACPI_TABLES = 2,
	IORES_DESC_ACPI_NV_STORAGE = 3,
	IORES_DESC_PERSISTENT_MEMORY = 4,
	IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
	IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
	IORES_DESC_RESERVED = 7,
	IORES_DESC_SOFT_RESERVED = 8,
};

enum {
	REGION_INTERSECTS = 0,
	REGION_DISJOINT = 1,
	REGION_MIXED = 2,
};

typedef void (*dr_release_t)(struct device *, void *);

struct resource_constraint {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t (*alignf)(void *, const struct resource *, resource_size_t, resource_size_t);
	void *alignf_data;
};

enum {
	MAX_IORES_LEVEL = 5,
};

struct region_devres {
	struct resource *parent;
	resource_size_t start;
	resource_size_t n;
};

enum sysctl_writes_mode {
	SYSCTL_WRITES_LEGACY = 4294967295,
	SYSCTL_WRITES_WARN = 0,
	SYSCTL_WRITES_STRICT = 1,
};

struct do_proc_dointvec_minmax_conv_param {
	int *min;
	int *max;
};

struct do_proc_douintvec_minmax_conv_param {
	unsigned int *min;
	unsigned int *max;
};

struct __user_cap_header_struct {
	__u32 version;
	int pid;
};

typedef struct __user_cap_header_struct *cap_user_header_t;

struct __user_cap_data_struct {
	__u32 effective;
	__u32 permitted;
	__u32 inheritable;
};

typedef struct __user_cap_data_struct *cap_user_data_t;

typedef struct siginfo siginfo_t;

struct sigqueue {
	struct list_head list;
	int flags;
	kernel_siginfo_t info;
	struct user_struct *user;
};

struct ptrace_peeksiginfo_args {
	__u64 off;
	__u32 flags;
	__s32 nr;
};

struct ptrace_syscall_info {
	__u8 op;
	__u8 pad[3];
	__u32 arch;
	__u64 instruction_pointer;
	__u64 stack_pointer;
	union {
		struct {
			__u64 nr;
			__u64 args[6];
		} entry;
		struct {
			__s64 rval;
			__u8 is_error;
		} exit;
		struct {
			__u64 nr;
			__u64 args[6];
			__u32 ret_data;
		} seccomp;
	};
};

struct ptrace_rseq_configuration {
	__u64 rseq_abi_pointer;
	__u32 rseq_abi_size;
	__u32 signature;
	__u32 flags;
	__u32 pad;
};

struct compat_iovec {
	compat_uptr_t iov_base;
	compat_size_t iov_len;
};

typedef struct compat_siginfo compat_siginfo_t;

typedef long unsigned int old_sigset_t;

typedef u32 compat_old_sigset_t;

struct compat_sigaction {
	compat_uptr_t sa_handler;
	compat_ulong_t sa_flags;
	compat_uptr_t sa_restorer;
	compat_sigset_t sa_mask;
};

struct compat_old_sigaction {
	compat_uptr_t sa_handler;
	compat_old_sigset_t sa_mask;
	compat_ulong_t sa_flags;
	compat_uptr_t sa_restorer;
};

enum {
	TRACE_SIGNAL_DELIVERED = 0,
	TRACE_SIGNAL_IGNORED = 1,
	TRACE_SIGNAL_ALREADY_PENDING = 2,
	TRACE_SIGNAL_OVERFLOW_FAIL = 3,
	TRACE_SIGNAL_LOSE_INFO = 4,
};

struct trace_event_raw_signal_generate {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	char comm[16];
	pid_t pid;
	int group;
	int result;
	char __data[0];
};

struct trace_event_raw_signal_deliver {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	long unsigned int sa_handler;
	long unsigned int sa_flags;
	char __data[0];
};

struct trace_event_data_offsets_signal_generate {};

struct trace_event_data_offsets_signal_deliver {};

typedef void (*btf_trace_signal_generate)(void *, int, struct kernel_siginfo *, struct task_struct *, int, int);

typedef void (*btf_trace_signal_deliver)(void *, int, struct kernel_siginfo *, struct k_sigaction *);

typedef int (*get_char_func)();

typedef __kernel_clock_t clock_t;

struct sysinfo {
	__kernel_long_t uptime;
	__kernel_ulong_t loads[3];
	__kernel_ulong_t totalram;
	__kernel_ulong_t freeram;
	__kernel_ulong_t sharedram;
	__kernel_ulong_t bufferram;
	__kernel_ulong_t totalswap;
	__kernel_ulong_t freeswap;
	__u16 procs;
	__u16 pad;
	__kernel_ulong_t totalhigh;
	__kernel_ulong_t freehigh;
	__u32 mem_unit;
	char _f[0];
};

struct prctl_mm_map {
	__u64 start_code;
	__u64 end_code;
	__u64 start_data;
	__u64 end_data;
	__u64 start_brk;
	__u64 brk;
	__u64 start_stack;
	__u64 arg_start;
	__u64 arg_end;
	__u64 env_start;
	__u64 env_end;
	__u64 *auxv;
	__u32 auxv_size;
	__u32 exe_fd;
};

struct rlimit64 {
	__u64 rlim_cur;
	__u64 rlim_max;
};

enum uts_proc {
	UTS_PROC_OSTYPE = 0,
	UTS_PROC_OSRELEASE = 1,
	UTS_PROC_VERSION = 2,
	UTS_PROC_HOSTNAME = 3,
	UTS_PROC_DOMAINNAME = 4,
};

struct compat_tms {
	compat_clock_t tms_utime;
	compat_clock_t tms_stime;
	compat_clock_t tms_cutime;
	compat_clock_t tms_cstime;
};

struct compat_rlimit {
	compat_ulong_t rlim_cur;
	compat_ulong_t rlim_max;
};

struct tms {
	__kernel_clock_t tms_utime;
	__kernel_clock_t tms_stime;
	__kernel_clock_t tms_cutime;
	__kernel_clock_t tms_cstime;
};

struct getcpu_cache {
	long unsigned int blob[16];
};

struct compat_sysinfo {
	s32 uptime;
	u32 loads[3];
	u32 totalram;
	u32 freeram;
	u32 sharedram;
	u32 bufferram;
	u32 totalswap;
	u32 freeswap;
	u16 procs;
	u16 pad;
	u32 totalhigh;
	u32 freehigh;
	u32 mem_unit;
	char _f[8];
};

struct wq_flusher;

struct worker;

struct workqueue_attrs;

struct pool_workqueue;

struct wq_device;

struct workqueue_struct {
	struct list_head pwqs;
	struct list_head list;
	struct mutex mutex;
	int work_color;
	int flush_color;
	atomic_t nr_pwqs_to_flush;
	struct wq_flusher *first_flusher;
	struct list_head flusher_queue;
	struct list_head flusher_overflow;
	struct list_head maydays;
	struct worker *rescuer;
	int nr_drainers;
	int saved_max_active;
	struct workqueue_attrs *unbound_attrs;
	struct pool_workqueue *dfl_pwq;
	struct wq_device *wq_dev;
	char name[24];
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int flags;
	struct pool_workqueue *cpu_pwqs;
	struct pool_workqueue *numa_pwq_tbl[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct workqueue_attrs {
	int nice;
	cpumask_var_t cpumask;
	bool no_numa;
};

struct execute_work {
	struct work_struct work;
};

enum {
	WQ_UNBOUND = 2,
	WQ_FREEZABLE = 4,
	WQ_MEM_RECLAIM = 8,
	WQ_HIGHPRI = 16,
	WQ_CPU_INTENSIVE = 32,
	WQ_SYSFS = 64,
	WQ_POWER_EFFICIENT = 128,
	__WQ_DRAINING = 65536,
	__WQ_ORDERED = 131072,
	__WQ_LEGACY = 262144,
	__WQ_ORDERED_EXPLICIT = 524288,
	WQ_MAX_ACTIVE = 512,
	WQ_MAX_UNBOUND_PER_CPU = 4,
	WQ_DFL_ACTIVE = 256,
};

typedef unsigned int xa_mark_t;

enum xa_lock_type {
	XA_LOCK_IRQ = 1,
	XA_LOCK_BH = 2,
};

struct __una_u32 {
	u32 x;
};

struct worker_pool;

struct worker {
	union {
		struct list_head entry;
		struct hlist_node hentry;
	};
	struct work_struct *current_work;
	work_func_t current_func;
	struct pool_workqueue *current_pwq;
	struct list_head scheduled;
	struct task_struct *task;
	struct worker_pool *pool;
	struct list_head node;
	long unsigned int last_active;
	unsigned int flags;
	int id;
	int sleeping;
	char desc[24];
	struct workqueue_struct *rescue_wq;
	work_func_t last_func;
};

struct pool_workqueue {
	struct worker_pool *pool;
	struct workqueue_struct *wq;
	int work_color;
	int flush_color;
	int refcnt;
	int nr_in_flight[15];
	int nr_active;
	int max_active;
	struct list_head delayed_works;
	struct list_head pwqs_node;
	struct list_head mayday_node;
	struct work_struct unbound_release_work;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct worker_pool {
	raw_spinlock_t lock;
	int cpu;
	int node;
	int id;
	unsigned int flags;
	long unsigned int watchdog_ts;
	struct list_head worklist;
	int nr_workers;
	int nr_idle;
	struct list_head idle_list;
	struct timer_list idle_timer;
	struct timer_list mayday_timer;
	struct hlist_head busy_hash[64];
	struct worker *manager;
	struct list_head workers;
	struct completion *detach_completion;
	struct ida worker_ida;
	struct workqueue_attrs *attrs;
	struct hlist_node hash_node;
	int refcnt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	atomic_t nr_running;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	POOL_MANAGER_ACTIVE = 1,
	POOL_DISASSOCIATED = 4,
	WORKER_DIE = 2,
	WORKER_IDLE = 4,
	WORKER_PREP = 8,
	WORKER_CPU_INTENSIVE = 64,
	WORKER_UNBOUND = 128,
	WORKER_REBOUND = 256,
	WORKER_NOT_RUNNING = 456,
	NR_STD_WORKER_POOLS = 2,
	UNBOUND_POOL_HASH_ORDER = 6,
	BUSY_WORKER_HASH_ORDER = 6,
	MAX_IDLE_WORKERS_RATIO = 4,
	IDLE_WORKER_TIMEOUT = 75000,
	MAYDAY_INITIAL_TIMEOUT = 2,
	MAYDAY_INTERVAL = 25,
	CREATE_COOLDOWN = 250,
	RESCUER_NICE_LEVEL = 4294967276,
	HIGHPRI_NICE_LEVEL = 4294967276,
	WQ_NAME_LEN = 24,
};

struct wq_flusher {
	struct list_head list;
	int flush_color;
	struct completion done;
};

struct wq_device {
	struct workqueue_struct *wq;
	struct device dev;
};

struct trace_event_raw_workqueue_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	u32 __data_loc_workqueue;
	unsigned int req_cpu;
	unsigned int cpu;
	char __data[0];
};

struct trace_event_raw_workqueue_activate_work {
	struct trace_entry ent;
	void *work;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_data_offsets_workqueue_queue_work {
	u32 workqueue;
};

struct trace_event_data_offsets_workqueue_activate_work {};

struct trace_event_data_offsets_workqueue_execute_start {};

struct trace_event_data_offsets_workqueue_execute_end {};

typedef void (*btf_trace_workqueue_queue_work)(void *, unsigned int, struct pool_workqueue *, struct work_struct *);

typedef void (*btf_trace_workqueue_activate_work)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_start)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_end)(void *, struct work_struct *, work_func_t);

struct wq_barrier {
	struct work_struct work;
	struct completion done;
	struct task_struct *task;
};

struct cwt_wait {
	wait_queue_entry_t wait;
	struct work_struct *work;
};

struct apply_wqattrs_ctx {
	struct workqueue_struct *wq;
	struct workqueue_attrs *attrs;
	struct list_head list;
	struct pool_workqueue *dfl_pwq;
	struct pool_workqueue *pwq_tbl[0];
};

struct work_for_cpu {
	struct work_struct work;
	long int (*fn)(void *);
	void *arg;
	long int ret;
};

typedef void (*task_work_func_t)(struct callback_head *);

enum task_work_notify_mode {
	TWA_NONE = 0,
	TWA_RESUME = 1,
	TWA_SIGNAL = 2,
};

enum {
	KERNEL_PARAM_OPS_FL_NOARG = 1,
};

enum {
	KERNEL_PARAM_FL_UNSAFE = 1,
	KERNEL_PARAM_FL_HWPARAM = 2,
};

struct param_attribute {
	struct module_attribute mattr;
	const struct kernel_param *param;
};

struct module_param_attrs {
	unsigned int num;
	struct attribute_group grp;
	struct param_attribute attrs[0];
};

struct module_version_attribute {
	struct module_attribute mattr;
	const char *module_name;
	const char *version;
};

enum lockdown_reason {
	LOCKDOWN_NONE = 0,
	LOCKDOWN_MODULE_SIGNATURE = 1,
	LOCKDOWN_DEV_MEM = 2,
	LOCKDOWN_EFI_TEST = 3,
	LOCKDOWN_KEXEC = 4,
	LOCKDOWN_HIBERNATION = 5,
	LOCKDOWN_PCI_ACCESS = 6,
	LOCKDOWN_IOPORT = 7,
	LOCKDOWN_MSR = 8,
	LOCKDOWN_ACPI_TABLES = 9,
	LOCKDOWN_PCMCIA_CIS = 10,
	LOCKDOWN_TIOCSSERIAL = 11,
	LOCKDOWN_MODULE_PARAMETERS = 12,
	LOCKDOWN_MMIOTRACE = 13,
	LOCKDOWN_DEBUGFS = 14,
	LOCKDOWN_XMON_WR = 15,
	LOCKDOWN_BPF_WRITE_USER = 16,
	LOCKDOWN_INTEGRITY_MAX = 17,
	LOCKDOWN_KCORE = 18,
	LOCKDOWN_KPROBES = 19,
	LOCKDOWN_BPF_READ = 20,
	LOCKDOWN_PERF = 21,
	LOCKDOWN_TRACEFS = 22,
	LOCKDOWN_XMON_RW = 23,
	LOCKDOWN_XFRM_SECRET = 24,
	LOCKDOWN_CONFIDENTIALITY_MAX = 25,
};

struct kmalloced_param {
	struct list_head list;
	char val[0];
};

struct sched_param {
	int sched_priority;
};

enum {
	__PERCPU_REF_ATOMIC = 1,
	__PERCPU_REF_DEAD = 2,
	__PERCPU_REF_ATOMIC_DEAD = 3,
	__PERCPU_REF_FLAG_BITS = 2,
};

struct kthread_work;

typedef void (*kthread_work_func_t)(struct kthread_work *);

struct kthread_worker;

struct kthread_work {
	struct list_head node;
	kthread_work_func_t func;
	struct kthread_worker *worker;
	int canceling;
};

enum {
	KTW_FREEZABLE = 1,
};

struct kthread_worker {
	unsigned int flags;
	raw_spinlock_t lock;
	struct list_head work_list;
	struct list_head delayed_work_list;
	struct task_struct *task;
	struct kthread_work *current_work;
};

struct kthread_delayed_work {
	struct kthread_work work;
	struct timer_list timer;
};

enum {
	CSS_NO_REF = 1,
	CSS_ONLINE = 2,
	CSS_RELEASED = 4,
	CSS_VISIBLE = 8,
	CSS_DYING = 16,
};

struct kthread_create_info {
	int (*threadfn)(void *);
	void *data;
	int node;
	struct task_struct *result;
	struct completion *done;
	struct list_head list;
};

struct kthread {
	long unsigned int flags;
	unsigned int cpu;
	int (*threadfn)(void *);
	void *data;
	mm_segment_t oldfs;
	struct completion parked;
	struct completion exited;
	struct cgroup_subsys_state *blkcg_css;
};

enum KTHREAD_BITS {
	KTHREAD_IS_PER_CPU = 0,
	KTHREAD_SHOULD_STOP = 1,
	KTHREAD_SHOULD_PARK = 2,
};

struct kthread_flush_work {
	struct kthread_work work;
	struct completion done;
};

struct pt_regs___2;

struct ipc_ids {
	int in_use;
	short unsigned int seq;
	struct rw_semaphore rwsem;
	struct idr ipcs_idr;
	int max_idx;
	int last_idx;
	int next_id;
	struct rhashtable key_ht;
};

struct ipc_namespace {
	struct ipc_ids ids[3];
	int sem_ctls[4];
	int used_sems;
	unsigned int msg_ctlmax;
	unsigned int msg_ctlmnb;
	unsigned int msg_ctlmni;
	atomic_t msg_bytes;
	atomic_t msg_hdrs;
	size_t shm_ctlmax;
	size_t shm_ctlall;
	long unsigned int shm_tot;
	int shm_ctlmni;
	int shm_rmid_forced;
	struct notifier_block ipcns_nb;
	struct vfsmount *mq_mnt;
	unsigned int mq_queues_count;
	unsigned int mq_queues_max;
	unsigned int mq_msg_max;
	unsigned int mq_msgsize_max;
	unsigned int mq_msg_default;
	unsigned int mq_msgsize_default;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct llist_node mnt_llist;
	struct ns_common ns;
};

struct srcu_notifier_head {
	struct mutex mutex;
	struct srcu_struct srcu;
	struct notifier_block *head;
};

struct lsmblob {
	u32 secid[3];
};

enum what {
	PROC_EVENT_NONE = 0,
	PROC_EVENT_FORK = 1,
	PROC_EVENT_EXEC = 2,
	PROC_EVENT_UID = 4,
	PROC_EVENT_GID = 64,
	PROC_EVENT_SID = 128,
	PROC_EVENT_PTRACE = 256,
	PROC_EVENT_COMM = 512,
	PROC_EVENT_COREDUMP = 1073741824,
	PROC_EVENT_EXIT = 2147483648,
};

struct async_entry {
	struct list_head domain_list;
	struct list_head global_list;
	struct work_struct work;
	async_cookie_t cookie;
	async_func_t func;
	void *data;
	struct async_domain *domain;
};

struct smpboot_thread_data {
	unsigned int cpu;
	unsigned int status;
	struct smp_hotplug_thread *ht;
};

enum {
	HP_THREAD_NONE = 0,
	HP_THREAD_ACTIVE = 1,
	HP_THREAD_PARKED = 2,
};

struct umd_info {
	const char *driver_name;
	struct file *pipe_to_umh;
	struct file *pipe_from_umh;
	struct path wd;
	struct pid *tgid;
};

struct pin_cookie {};

enum {
	CSD_FLAG_LOCK = 1,
	IRQ_WORK_PENDING = 1,
	IRQ_WORK_BUSY = 2,
	IRQ_WORK_LAZY = 4,
	IRQ_WORK_HARD_IRQ = 8,
	IRQ_WORK_CLAIMED = 3,
	CSD_TYPE_ASYNC = 0,
	CSD_TYPE_SYNC = 16,
	CSD_TYPE_IRQ_WORK = 32,
	CSD_TYPE_TTWU = 48,
	CSD_FLAG_TYPE_MASK = 240,
};

struct dl_bw {
	raw_spinlock_t lock;
	u64 bw;
	u64 total_bw;
};

struct cpudl_item;

struct cpudl {
	raw_spinlock_t lock;
	int size;
	cpumask_var_t free_cpus;
	struct cpudl_item *elements;
};

struct cpupri_vec {
	atomic_t count;
	cpumask_var_t mask;
};

struct cpupri {
	struct cpupri_vec pri_to_cpu[101];
	int *cpu_to_pri;
};

struct perf_domain;

struct root_domain___2 {
	atomic_t refcount;
	atomic_t rto_count;
	struct callback_head rcu;
	cpumask_var_t span;
	cpumask_var_t online;
	int overload;
	int overutilized;
	cpumask_var_t dlo_mask;
	atomic_t dlo_count;
	struct dl_bw dl_bw;
	struct cpudl cpudl;
	u64 visit_gen;
	struct irq_work rto_push_work;
	raw_spinlock_t rto_lock;
	int rto_loop;
	int rto_cpu;
	atomic_t rto_loop_next;
	atomic_t rto_loop_start;
	cpumask_var_t rto_mask;
	struct cpupri cpupri;
	long unsigned int max_cpu_capacity;
	struct perf_domain *pd;
};

struct cfs_rq {
	struct load_weight load;
	unsigned int nr_running;
	unsigned int h_nr_running;
	unsigned int idle_h_nr_running;
	u64 exec_clock;
	u64 min_vruntime;
	struct rb_root_cached tasks_timeline;
	struct sched_entity *curr;
	struct sched_entity *next;
	struct sched_entity *last;
	struct sched_entity *skip;
	unsigned int nr_spread_over;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg;
	struct {
		raw_spinlock_t lock;
		int nr;
		long unsigned int load_avg;
		long unsigned int util_avg;
		long unsigned int runnable_avg;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	} removed;
	long unsigned int tg_load_avg_contrib;
	long int propagate;
	long int prop_runnable_sum;
	long unsigned int h_load;
	u64 last_h_load_update;
	struct sched_entity *h_load_next;
	struct rq *rq;
	int on_list;
	struct list_head leaf_cfs_rq_list;
	struct task_group *tg;
	int runtime_enabled;
	s64 runtime_remaining;
	u64 throttled_clock;
	u64 throttled_clock_task;
	u64 throttled_clock_task_time;
	int throttled;
	int throttle_count;
	struct list_head throttled_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct cfs_bandwidth {
	raw_spinlock_t lock;
	ktime_t period;
	u64 quota;
	u64 runtime;
	s64 hierarchical_quota;
	u8 idle;
	u8 period_active;
	u8 slack_started;
	struct hrtimer period_timer;
	struct hrtimer slack_timer;
	struct list_head throttled_cfs_rq;
	int nr_periods;
	int nr_throttled;
	u64 throttled_time;
};

struct task_group {
	struct cgroup_subsys_state css;
	struct sched_entity **se;
	struct cfs_rq **cfs_rq;
	long unsigned int shares;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t load_avg;
	struct callback_head rcu;
	struct list_head list;
	struct task_group *parent;
	struct list_head siblings;
	struct list_head children;
	struct autogroup *autogroup;
	struct cfs_bandwidth cfs_bandwidth;
	unsigned int uclamp_pct[2];
	struct uclamp_se uclamp_req[2];
	struct uclamp_se uclamp[2];
};

struct update_util_data {
	void (*func)(struct update_util_data *, u64, unsigned int);
};

struct sched_domain_shared {
	atomic_t ref;
	atomic_t nr_busy_cpus;
	int has_idle_cores;
};

struct sched_group;

struct sched_domain {
	struct sched_domain *parent;
	struct sched_domain *child;
	struct sched_group *groups;
	long unsigned int min_interval;
	long unsigned int max_interval;
	unsigned int busy_factor;
	unsigned int imbalance_pct;
	unsigned int cache_nice_tries;
	int nohz_idle;
	int flags;
	int level;
	long unsigned int last_balance;
	unsigned int balance_interval;
	unsigned int nr_balance_failed;
	u64 max_newidle_lb_cost;
	long unsigned int next_decay_max_lb_cost;
	u64 avg_scan_cost;
	unsigned int lb_count[3];
	unsigned int lb_failed[3];
	unsigned int lb_balanced[3];
	unsigned int lb_imbalance[3];
	unsigned int lb_gained[3];
	unsigned int lb_hot_gained[3];
	unsigned int lb_nobusyg[3];
	unsigned int lb_nobusyq[3];
	unsigned int alb_count;
	unsigned int alb_failed;
	unsigned int alb_pushed;
	unsigned int sbe_count;
	unsigned int sbe_balanced;
	unsigned int sbe_pushed;
	unsigned int sbf_count;
	unsigned int sbf_balanced;
	unsigned int sbf_pushed;
	unsigned int ttwu_wake_remote;
	unsigned int ttwu_move_affine;
	unsigned int ttwu_move_balance;
	char *name;
	union {
		void *private;
		struct callback_head rcu;
	};
	struct sched_domain_shared *shared;
	unsigned int span_weight;
	long unsigned int span[0];
};

struct sched_group_capacity;

struct sched_group {
	struct sched_group *next;
	atomic_t ref;
	unsigned int group_weight;
	struct sched_group_capacity *sgc;
	int asym_prefer_cpu;
	long unsigned int cpumask[0];
};

struct sched_group_capacity {
	atomic_t ref;
	long unsigned int capacity;
	long unsigned int min_capacity;
	long unsigned int max_capacity;
	long unsigned int next_update;
	int imbalance;
	int id;
	long unsigned int cpumask[0];
};

struct autogroup {
	struct kref kref;
	struct task_group *tg;
	struct rw_semaphore lock;
	long unsigned int id;
	int nice;
};

enum {
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY = 1,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED = 2,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY = 4,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED = 8,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY = 16,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY = 64,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ = 128,
};

enum {
	CFTYPE_ONLY_ON_ROOT = 1,
	CFTYPE_NOT_ON_ROOT = 2,
	CFTYPE_NS_DELEGATABLE = 4,
	CFTYPE_NO_PREFIX = 8,
	CFTYPE_WORLD_WRITABLE = 16,
	CFTYPE_DEBUG = 32,
	__CFTYPE_ONLY_ON_DFL = 65536,
	__CFTYPE_NOT_ON_DFL = 131072,
};

struct css_task_iter {
	struct cgroup_subsys *ss;
	unsigned int flags;
	struct list_head *cset_pos;
	struct list_head *cset_head;
	struct list_head *tcset_pos;
	struct list_head *tcset_head;
	struct list_head *task_pos;
	struct list_head *cur_tasks_head;
	struct css_set *cur_cset;
	struct css_set *cur_dcset;
	struct task_struct *cur_task;
	struct list_head iters_node;
};

struct trace_event_raw_sched_kthread_stop {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_kthread_stop_ret {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	void *worker;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_wakeup_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int success;
	int target_cpu;
	char __data[0];
};

struct trace_event_raw_sched_switch {
	struct trace_entry ent;
	char prev_comm[16];
	pid_t prev_pid;
	int prev_prio;
	long int prev_state;
	char next_comm[16];
	pid_t next_pid;
	int next_prio;
	char __data[0];
};

struct trace_event_raw_sched_migrate_task {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int orig_cpu;
	int dest_cpu;
	char __data[0];
};

struct trace_event_raw_sched_process_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_wait {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_fork {
	struct trace_entry ent;
	char parent_comm[16];
	pid_t parent_pid;
	char child_comm[16];
	pid_t child_pid;
	char __data[0];
};

struct trace_event_raw_sched_process_exec {
	struct trace_entry ent;
	u32 __data_loc_filename;
	pid_t pid;
	pid_t old_pid;
	char __data[0];
};

struct trace_event_raw_sched_stat_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 delay;
	char __data[0];
};

struct trace_event_raw_sched_stat_runtime {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 runtime;
	u64 vruntime;
	char __data[0];
};

struct trace_event_raw_sched_pi_setprio {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int oldprio;
	int newprio;
	char __data[0];
};

struct trace_event_raw_sched_process_hang {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_move_numa {
	struct trace_entry ent;
	pid_t pid;
	pid_t tgid;
	pid_t ngid;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_numa_pair_template {
	struct trace_entry ent;
	pid_t src_pid;
	pid_t src_tgid;
	pid_t src_ngid;
	int src_cpu;
	int src_nid;
	pid_t dst_pid;
	pid_t dst_tgid;
	pid_t dst_ngid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_wake_idle_without_ipi {
	struct trace_entry ent;
	int cpu;
	char __data[0];
};

struct trace_event_data_offsets_sched_kthread_stop {};

struct trace_event_data_offsets_sched_kthread_stop_ret {};

struct trace_event_data_offsets_sched_kthread_work_queue_work {};

struct trace_event_data_offsets_sched_kthread_work_execute_start {};

struct trace_event_data_offsets_sched_kthread_work_execute_end {};

struct trace_event_data_offsets_sched_wakeup_template {};

struct trace_event_data_offsets_sched_switch {};

struct trace_event_data_offsets_sched_migrate_task {};

struct trace_event_data_offsets_sched_process_template {};

struct trace_event_data_offsets_sched_process_wait {};

struct trace_event_data_offsets_sched_process_fork {};

struct trace_event_data_offsets_sched_process_exec {
	u32 filename;
};

struct trace_event_data_offsets_sched_stat_template {};

struct trace_event_data_offsets_sched_stat_runtime {};

struct trace_event_data_offsets_sched_pi_setprio {};

struct trace_event_data_offsets_sched_process_hang {};

struct trace_event_data_offsets_sched_move_numa {};

struct trace_event_data_offsets_sched_numa_pair_template {};

struct trace_event_data_offsets_sched_wake_idle_without_ipi {};

typedef void (*btf_trace_sched_kthread_stop)(void *, struct task_struct *);

typedef void (*btf_trace_sched_kthread_stop_ret)(void *, int);

typedef void (*btf_trace_sched_kthread_work_queue_work)(void *, struct kthread_worker *, struct kthread_work *);

typedef void (*btf_trace_sched_kthread_work_execute_start)(void *, struct kthread_work *);

typedef void (*btf_trace_sched_kthread_work_execute_end)(void *, struct kthread_work *, kthread_work_func_t);

typedef void (*btf_trace_sched_waking)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup_new)(void *, struct task_struct *);

typedef void (*btf_trace_sched_switch)(void *, bool, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_migrate_task)(void *, struct task_struct *, int);

typedef void (*btf_trace_sched_process_free)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_exit)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wait_task)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_wait)(void *, struct pid *);

typedef void (*btf_trace_sched_process_fork)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_exec)(void *, struct task_struct *, pid_t, struct linux_binprm *);

typedef void (*btf_trace_sched_stat_wait)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_sleep)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_iowait)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_blocked)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_runtime)(void *, struct task_struct *, u64, u64);

typedef void (*btf_trace_sched_pi_setprio)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_hang)(void *, struct task_struct *);

typedef void (*btf_trace_sched_move_numa)(void *, struct task_struct *, int, int);

typedef void (*btf_trace_sched_stick_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_swap_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_wake_idle_without_ipi)(void *, int);

typedef void (*btf_trace_pelt_cfs_tp)(void *, struct cfs_rq *);

typedef void (*btf_trace_pelt_rt_tp)(void *, struct rq *);

struct uclamp_bucket {
	long unsigned int value: 11;
	long unsigned int tasks: 53;
};

struct uclamp_rq {
	unsigned int value;
	struct uclamp_bucket bucket[5];
};

struct rt_prio_array {
	long unsigned int bitmap[2];
	struct list_head queue[100];
};

struct rt_rq {
	struct rt_prio_array active;
	unsigned int rt_nr_running;
	unsigned int rr_nr_running;
	struct {
		int curr;
		int next;
	} highest_prio;
	long unsigned int rt_nr_migratory;
	long unsigned int rt_nr_total;
	int overloaded;
	struct plist_head pushable_tasks;
	int rt_queued;
	int rt_throttled;
	u64 rt_time;
	u64 rt_runtime;
	raw_spinlock_t rt_runtime_lock;
};

struct dl_rq {
	struct rb_root_cached root;
	long unsigned int dl_nr_running;
	struct {
		u64 curr;
		u64 next;
	} earliest_dl;
	long unsigned int dl_nr_migratory;
	int overloaded;
	struct rb_root_cached pushable_dl_tasks_root;
	u64 running_bw;
	u64 this_bw;
	u64 extra_bw;
	u64 bw_ratio;
};

typedef int (*cpu_stop_fn_t)(void *);

struct cpu_stop_done;

struct cpu_stop_work {
	struct list_head list;
	cpu_stop_fn_t fn;
	long unsigned int caller;
	void *arg;
	struct cpu_stop_done *done;
};

struct rq {
	raw_spinlock_t lock;
	unsigned int nr_running;
	unsigned int nr_numa_running;
	unsigned int nr_preferred_running;
	unsigned int numa_migrate_on;
	long unsigned int last_blocked_load_update_tick;
	unsigned int has_blocked_load;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t nohz_csd;
	unsigned int nohz_tick_stopped;
	atomic_t nohz_flags;
	unsigned int ttwu_pending;
	u64 nr_switches;
	long: 64;
	struct uclamp_rq uclamp[2];
	unsigned int uclamp_flags;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	struct cfs_rq cfs;
	struct rt_rq rt;
	struct dl_rq dl;
	struct list_head leaf_cfs_rq_list;
	struct list_head *tmp_alone_branch;
	long unsigned int nr_uninterruptible;
	struct task_struct *curr;
	struct task_struct *idle;
	struct task_struct *stop;
	long unsigned int next_balance;
	struct mm_struct *prev_mm;
	unsigned int clock_update_flags;
	u64 clock;
	long: 64;
	long: 64;
	long: 64;
	u64 clock_task;
	u64 clock_pelt;
	long unsigned int lost_idle_time;
	atomic_t nr_iowait;
	u64 last_seen_need_resched_ns;
	int ticks_without_resched;
	int membarrier_state;
	struct root_domain___2 *rd;
	struct sched_domain *sd;
	long unsigned int cpu_capacity;
	long unsigned int cpu_capacity_orig;
	struct callback_head *balance_callback;
	unsigned char nohz_idle_balance;
	unsigned char idle_balance;
	long unsigned int misfit_task_load;
	int active_balance;
	int push_cpu;
	struct cpu_stop_work active_balance_work;
	int cpu;
	int online;
	struct list_head cfs_tasks;
	long: 64;
	struct sched_avg avg_rt;
	struct sched_avg avg_dl;
	struct sched_avg avg_thermal;
	u64 idle_stamp;
	u64 avg_idle;
	u64 max_idle_balance_cost;
	struct rcuwait hotplug_wait;
	u64 prev_steal_time;
	long unsigned int calc_load_update;
	long int calc_load_active;
	long: 64;
	call_single_data_t hrtick_csd;
	struct hrtimer hrtick_timer;
	ktime_t hrtick_time;
	struct sched_info rq_sched_info;
	long long unsigned int rq_cpu_time;
	unsigned int yld_count;
	unsigned int sched_count;
	unsigned int sched_goidle;
	unsigned int ttwu_count;
	unsigned int ttwu_local;
	struct cpuidle_state *idle_state;
	unsigned int nr_pinned;
	unsigned int push_busy;
	struct cpu_stop_work push_work;
	long: 64;
	long: 64;
	long: 64;
};

typedef void (*btf_trace_pelt_dl_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_thermal_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_irq_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_se_tp)(void *, struct sched_entity *);

typedef void (*btf_trace_sched_cpu_capacity_tp)(void *, struct rq *);

typedef void (*btf_trace_sched_overutilized_tp)(void *, struct root_domain___2 *, bool);

typedef void (*btf_trace_sched_util_est_cfs_tp)(void *, struct cfs_rq *);

typedef void (*btf_trace_sched_util_est_se_tp)(void *, struct sched_entity *);

typedef void (*btf_trace_sched_update_nr_running_tp)(void *, struct rq *, int);

struct wake_q_head {
	struct wake_q_node *first;
	struct wake_q_node **lastp;
};

struct sched_attr {
	__u32 size;
	__u32 sched_policy;
	__u64 sched_flags;
	__s32 sched_nice;
	__u32 sched_priority;
	__u64 sched_runtime;
	__u64 sched_deadline;
	__u64 sched_period;
	__u32 sched_util_min;
	__u32 sched_util_max;
};

struct cpudl_item {
	u64 dl;
	int cpu;
	int idx;
};

struct rt_bandwidth {
	raw_spinlock_t rt_runtime_lock;
	ktime_t rt_period;
	u64 rt_runtime;
	struct hrtimer rt_period_timer;
	unsigned int rt_period_active;
};

struct dl_bandwidth {
	raw_spinlock_t dl_runtime_lock;
	u64 dl_runtime;
	u64 dl_period;
};

typedef int (*tg_visitor)(struct task_group *, void *);

struct perf_domain {
	struct em_perf_domain *em_pd;
	struct perf_domain *next;
	struct callback_head rcu;
};

struct rq_flags {
	long unsigned int flags;
	struct pin_cookie cookie;
	unsigned int clock_update_flags;
};

enum numa_topology_type {
	NUMA_DIRECT = 0,
	NUMA_GLUELESS_MESH = 1,
	NUMA_BACKPLANE = 2,
};

enum {
	__SCHED_FEAT_GENTLE_FAIR_SLEEPERS = 0,
	__SCHED_FEAT_START_DEBIT = 1,
	__SCHED_FEAT_NEXT_BUDDY = 2,
	__SCHED_FEAT_LAST_BUDDY = 3,
	__SCHED_FEAT_CACHE_HOT_BUDDY = 4,
	__SCHED_FEAT_WAKEUP_PREEMPTION = 5,
	__SCHED_FEAT_HRTICK = 6,
	__SCHED_FEAT_HRTICK_DL = 7,
	__SCHED_FEAT_DOUBLE_TICK = 8,
	__SCHED_FEAT_NONTASK_CAPACITY = 9,
	__SCHED_FEAT_TTWU_QUEUE = 10,
	__SCHED_FEAT_SIS_PROP = 11,
	__SCHED_FEAT_WARN_DOUBLE_CLOCK = 12,
	__SCHED_FEAT_RT_PUSH_IPI = 13,
	__SCHED_FEAT_RT_RUNTIME_SHARE = 14,
	__SCHED_FEAT_LB_MIN = 15,
	__SCHED_FEAT_ATTACH_AGE_LOAD = 16,
	__SCHED_FEAT_WA_IDLE = 17,
	__SCHED_FEAT_WA_WEIGHT = 18,
	__SCHED_FEAT_WA_BIAS = 19,
	__SCHED_FEAT_UTIL_EST = 20,
	__SCHED_FEAT_UTIL_EST_FASTUP = 21,
	__SCHED_FEAT_LATENCY_WARN = 22,
	__SCHED_FEAT_ALT_PERIOD = 23,
	__SCHED_FEAT_BASE_SLICE = 24,
	__SCHED_FEAT_NR = 25,
};

enum cpu_util_type {
	FREQUENCY_UTIL = 0,
	ENERGY_UTIL = 1,
};

struct set_affinity_pending;

struct migration_arg {
	struct task_struct *task;
	int dest_cpu;
	struct set_affinity_pending *pending;
};

struct set_affinity_pending {
	refcount_t refs;
	unsigned int stop_pending;
	struct completion done;
	struct cpu_stop_work stop_work;
	struct migration_arg arg;
};

struct migration_swap_arg {
	struct task_struct *src_task;
	struct task_struct *dst_task;
	int src_cpu;
	int dst_cpu;
};

struct uclamp_request {
	s64 percent;
	u64 util;
	int ret;
};

struct cfs_schedulable_data {
	struct task_group *tg;
	u64 period;
	u64 quota;
};

enum {
	cpuset = 0,
	possible = 1,
	fail = 2,
};

enum {
	SD_BALANCE_NEWIDLE = 1,
	SD_BALANCE_EXEC = 2,
	SD_BALANCE_FORK = 4,
	SD_BALANCE_WAKE = 8,
	SD_WAKE_AFFINE = 16,
	SD_ASYM_CPUCAPACITY = 32,
	SD_SHARE_CPUCAPACITY = 64,
	SD_SHARE_PKG_RESOURCES = 128,
	SD_SERIALIZE = 256,
	SD_ASYM_PACKING = 512,
	SD_PREFER_SIBLING = 1024,
	SD_OVERLAP = 2048,
	SD_NUMA = 4096,
};

struct idle_timer {
	struct hrtimer timer;
	int done;
};

typedef void (*rcu_callback_t)(struct callback_head *);

struct numa_group {
	refcount_t refcount;
	spinlock_t lock;
	int nr_tasks;
	pid_t gid;
	int active_nodes;
	struct callback_head rcu;
	long unsigned int total_faults;
	long unsigned int max_faults_cpu;
	long unsigned int *faults_cpu;
	long unsigned int faults[0];
};

enum sched_tunable_scaling {
	SCHED_TUNABLESCALING_NONE = 0,
	SCHED_TUNABLESCALING_LOG = 1,
	SCHED_TUNABLESCALING_LINEAR = 2,
	SCHED_TUNABLESCALING_END = 3,
};

enum numa_faults_stats {
	NUMA_MEM = 0,
	NUMA_CPU = 1,
	NUMA_MEMBUF = 2,
	NUMA_CPUBUF = 3,
};

enum numa_type {
	node_has_spare = 0,
	node_fully_busy = 1,
	node_overloaded = 2,
};

struct numa_stats {
	long unsigned int load;
	long unsigned int runnable;
	long unsigned int util;
	long unsigned int compute_capacity;
	unsigned int nr_running;
	unsigned int weight;
	enum numa_type node_type;
	int idle_cpu;
};

struct task_numa_env {
	struct task_struct *p;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	struct numa_stats src_stats;
	struct numa_stats dst_stats;
	int imbalance_pct;
	int dist;
	struct task_struct *best_task;
	long int best_imp;
	int best_cpu;
};

enum fbq_type {
	regular = 0,
	remote = 1,
	all = 2,
};

enum group_type {
	group_has_spare = 0,
	group_fully_busy = 1,
	group_misfit_task = 2,
	group_asym_packing = 3,
	group_imbalanced = 4,
	group_overloaded = 5,
};

enum migration_type {
	migrate_load = 0,
	migrate_util = 1,
	migrate_task = 2,
	migrate_misfit = 3,
};

struct lb_env {
	struct sched_domain *sd;
	struct rq *src_rq;
	int src_cpu;
	int dst_cpu;
	struct rq *dst_rq;
	struct cpumask *dst_grpmask;
	int new_dst_cpu;
	enum cpu_idle_type idle;
	long int imbalance;
	struct cpumask *cpus;
	unsigned int flags;
	unsigned int loop;
	unsigned int loop_break;
	unsigned int loop_max;
	enum fbq_type fbq_type;
	enum migration_type migration_type;
	struct list_head tasks;
};

struct sg_lb_stats {
	long unsigned int avg_load;
	long unsigned int group_load;
	long unsigned int group_capacity;
	long unsigned int group_util;
	long unsigned int group_runnable;
	unsigned int sum_nr_running;
	unsigned int sum_h_nr_running;
	unsigned int idle_cpus;
	unsigned int group_weight;
	enum group_type group_type;
	unsigned int group_asym_packing;
	long unsigned int group_misfit_task_load;
	unsigned int nr_numa_running;
	unsigned int nr_preferred_running;
};

struct sd_lb_stats {
	struct sched_group *busiest;
	struct sched_group *local;
	long unsigned int total_load;
	long unsigned int total_capacity;
	long unsigned int avg_load;
	unsigned int prefer_sibling;
	struct sg_lb_stats busiest_stat;
	struct sg_lb_stats local_stat;
};

typedef struct rt_rq *rt_rq_iter_t;

typedef int wait_bit_action_f(struct wait_bit_key *, int);

struct swait_queue {
	struct task_struct *task;
	struct list_head task_list;
};

struct sched_domain_attr {
	int relax_domain_level;
};

typedef const struct cpumask * (*sched_domain_mask_f)(int);

typedef int (*sched_domain_flags_f)();

struct sd_data {
	struct sched_domain **sd;
	struct sched_domain_shared **sds;
	struct sched_group **sg;
	struct sched_group_capacity **sgc;
};

struct sched_domain_topology_level {
	sched_domain_mask_f mask;
	sched_domain_flags_f sd_flags;
	int flags;
	int numa_level;
	struct sd_data data;
	char *name;
};

struct s_data {
	struct sched_domain **sd;
	struct root_domain___2 *rd;
};

enum s_alloc {
	sa_rootdomain = 0,
	sa_sd = 1,
	sa_sd_storage = 2,
	sa_none = 3,
};

enum cpuacct_stat_index {
	CPUACCT_STAT_USER = 0,
	CPUACCT_STAT_SYSTEM = 1,
	CPUACCT_STAT_NSTATS = 2,
};

struct cpuacct {
	struct cgroup_subsys_state css;
	u64 *cpuusage;
	struct kernel_cpustat *cpustat;
};

struct gov_attr_set {
	struct kobject kobj;
	struct list_head policy_list;
	struct mutex update_lock;
	int usage_count;
};

struct governor_attr {
	struct attribute attr;
	ssize_t (*show)(struct gov_attr_set *, char *);
	ssize_t (*store)(struct gov_attr_set *, const char *, size_t);
};

struct sugov_tunables {
	struct gov_attr_set attr_set;
	unsigned int rate_limit_us;
};

struct sugov_policy {
	struct cpufreq_policy *policy;
	struct sugov_tunables *tunables;
	struct list_head tunables_hook;
	raw_spinlock_t update_lock;
	u64 last_freq_update_time;
	s64 freq_update_delay_ns;
	unsigned int next_freq;
	unsigned int cached_raw_freq;
	struct irq_work irq_work;
	struct kthread_work work;
	struct mutex work_lock;
	struct kthread_worker worker;
	struct task_struct *thread;
	bool work_in_progress;
	bool limits_changed;
	bool need_freq_update;
};

struct sugov_cpu {
	struct update_util_data update_util;
	struct sugov_policy *sg_policy;
	unsigned int cpu;
	bool iowait_boost_pending;
	unsigned int iowait_boost;
	u64 last_update;
	long unsigned int util;
	long unsigned int bw_dl;
	long unsigned int max;
	long unsigned int saved_idle_calls;
};

enum {
	MEMBARRIER_FLAG_SYNC_CORE = 1,
	MEMBARRIER_FLAG_RSEQ = 2,
};

enum membarrier_cmd {
	MEMBARRIER_CMD_QUERY = 0,
	MEMBARRIER_CMD_GLOBAL = 1,
	MEMBARRIER_CMD_GLOBAL_EXPEDITED = 2,
	MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED = 4,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED = 8,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED = 16,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE = 64,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ = 128,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ = 256,
	MEMBARRIER_CMD_SHARED = 1,
};

enum membarrier_cmd_flag {
	MEMBARRIER_CMD_FLAG_CPU = 1,
};

struct proc_ops {
	unsigned int proc_flags;
	int (*proc_open)(struct inode *, struct file *);
	ssize_t (*proc_read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*proc_write)(struct file *, const char *, size_t, loff_t *);
	loff_t (*proc_lseek)(struct file *, loff_t, int);
	int (*proc_release)(struct inode *, struct file *);
	__poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
	long int (*proc_ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*proc_compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*proc_mmap)(struct file *, struct vm_area_struct *);
	long unsigned int (*proc_get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
};

enum psi_res {
	PSI_IO = 0,
	PSI_MEM = 1,
	PSI_CPU = 2,
	NR_PSI_RESOURCES = 3,
};

struct psi_window {
	u64 size;
	u64 start_time;
	u64 start_value;
	u64 prev_growth;
};

struct psi_trigger {
	enum psi_states state;
	u64 threshold;
	struct list_head node;
	struct psi_group *group;
	wait_queue_head_t event_wait;
	int event;
	struct psi_window win;
	u64 last_event_time;
};

struct ww_acquire_ctx;

struct ww_mutex {
	struct mutex base;
	struct ww_acquire_ctx *ctx;
};

struct ww_acquire_ctx {
	struct task_struct *task;
	long unsigned int stamp;
	unsigned int acquired;
	short unsigned int wounded;
	short unsigned int is_wait_die;
};

struct mutex_waiter {
	struct list_head list;
	struct task_struct *task;
	struct ww_acquire_ctx *ww_ctx;
};

struct semaphore {
	raw_spinlock_t lock;
	unsigned int count;
	struct list_head wait_list;
};

struct semaphore_waiter {
	struct list_head list;
	struct task_struct *task;
	bool up;
};

enum rwsem_waiter_type {
	RWSEM_WAITING_FOR_WRITE = 0,
	RWSEM_WAITING_FOR_READ = 1,
};

struct rwsem_waiter {
	struct list_head list;
	struct task_struct *task;
	enum rwsem_waiter_type type;
	long unsigned int timeout;
	bool handoff_set;
};

enum rwsem_wake_type {
	RWSEM_WAKE_ANY = 0,
	RWSEM_WAKE_READERS = 1,
	RWSEM_WAKE_READ_OWNED = 2,
};

enum owner_state {
	OWNER_NULL = 1,
	OWNER_WRITER = 2,
	OWNER_READER = 4,
	OWNER_NONSPINNABLE = 8,
};

struct optimistic_spin_node {
	struct optimistic_spin_node *next;
	struct optimistic_spin_node *prev;
	int locked;
	int cpu;
};

struct mcs_spinlock {
	struct mcs_spinlock *next;
	int locked;
	int count;
};

struct qnode {
	struct mcs_spinlock mcs;
};

struct hrtimer_sleeper {
	struct hrtimer timer;
	struct task_struct *task;
};

struct rt_mutex;

struct rt_mutex_waiter {
	struct rb_node tree_entry;
	struct rb_node pi_tree_entry;
	struct task_struct *task;
	struct rt_mutex *lock;
	int prio;
	u64 deadline;
};

struct rt_mutex {
	raw_spinlock_t wait_lock;
	struct rb_root_cached waiters;
	struct task_struct *owner;
};

enum rtmutex_chainwalk {
	RT_MUTEX_MIN_CHAINWALK = 0,
	RT_MUTEX_FULL_CHAINWALK = 1,
};

struct pm_qos_request {
	struct plist_node node;
	struct pm_qos_constraints *qos;
};

enum pm_qos_req_action {
	PM_QOS_ADD_REQ = 0,
	PM_QOS_UPDATE_REQ = 1,
	PM_QOS_REMOVE_REQ = 2,
};

enum {
	TEST_NONE = 0,
	TEST_CORE = 1,
	TEST_CPUS = 2,
	TEST_PLATFORM = 3,
	TEST_DEVICES = 4,
	TEST_FREEZER = 5,
	__TEST_AFTER_LAST = 6,
};

struct pm_vt_switch {
	struct list_head head;
	struct device *dev;
	bool required;
};

struct platform_suspend_ops {
	int (*valid)(suspend_state_t);
	int (*begin)(suspend_state_t);
	int (*prepare)();
	int (*prepare_late)();
	int (*enter)(suspend_state_t);
	void (*wake)();
	void (*finish)();
	bool (*suspend_again)();
	void (*end)();
	void (*recover)();
};

struct platform_s2idle_ops {
	int (*begin)();
	int (*prepare)();
	int (*prepare_late)();
	bool (*wake)();
	void (*restore_early)();
	void (*restore)();
	void (*end)();
};

struct wakelock {
	char *name;
	struct rb_node node;
	struct wakeup_source *ws;
	struct list_head lru;
};

struct em_data_callback {
	int (*active_power)(long unsigned int *, long unsigned int *, struct device *);
};

typedef struct {
	seqcount_t seqcount;
} seqcount_latch_t;

struct dev_printk_info {
	char subsystem[16];
	char device[48];
};

struct kmsg_dump_iter {
	u64 cur_seq;
	u64 next_seq;
};

struct kmsg_dumper {
	struct list_head list;
	void (*dump)(struct kmsg_dumper *, enum kmsg_dump_reason);
	enum kmsg_dump_reason max_reason;
	bool registered;
};

struct trace_event_raw_console {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_console {
	u32 msg;
};

typedef void (*btf_trace_console)(void *, const char *, size_t);

struct printk_info {
	u64 seq;
	u64 ts_nsec;
	u16 text_len;
	u8 facility;
	u8 flags: 5;
	u8 level: 3;
	u32 caller_id;
	struct dev_printk_info dev_info;
};

struct printk_record {
	struct printk_info *info;
	char *text_buf;
	unsigned int text_buf_size;
};

struct prb_data_blk_lpos {
	long unsigned int begin;
	long unsigned int next;
};

struct prb_desc {
	atomic_long_t state_var;
	struct prb_data_blk_lpos text_blk_lpos;
};

struct prb_data_ring {
	unsigned int size_bits;
	char *data;
	atomic_long_t head_lpos;
	atomic_long_t tail_lpos;
};

struct prb_desc_ring {
	unsigned int count_bits;
	struct prb_desc *descs;
	struct printk_info *infos;
	atomic_long_t head_id;
	atomic_long_t tail_id;
};

struct printk_ringbuffer {
	struct prb_desc_ring desc_ring;
	struct prb_data_ring text_data_ring;
	atomic_long_t fail;
};

struct prb_reserved_entry {
	struct printk_ringbuffer *rb;
	long unsigned int irqflags;
	long unsigned int id;
	unsigned int text_space;
};

enum desc_state {
	desc_miss = 4294967295,
	desc_reserved = 0,
	desc_committed = 1,
	desc_finalized = 2,
	desc_reusable = 3,
};

struct console_cmdline {
	char name[16];
	int index;
	bool user_specified;
	char *options;
};

enum devkmsg_log_bits {
	__DEVKMSG_LOG_BIT_ON = 0,
	__DEVKMSG_LOG_BIT_OFF = 1,
	__DEVKMSG_LOG_BIT_LOCK = 2,
};

enum devkmsg_log_masks {
	DEVKMSG_LOG_MASK_ON = 1,
	DEVKMSG_LOG_MASK_OFF = 2,
	DEVKMSG_LOG_MASK_LOCK = 4,
};

enum con_msg_format_flags {
	MSG_FORMAT_DEFAULT = 0,
	MSG_FORMAT_SYSLOG = 1,
};

enum log_flags {
	LOG_NEWLINE = 2,
	LOG_CONT = 8,
};

struct latched_seq {
	seqcount_latch_t latch;
	u64 val[2];
};

struct devkmsg_user {
	atomic64_t seq;
	struct ratelimit_state rs;
	struct mutex lock;
	char buf[8192];
	struct printk_info info;
	char text_buf[8192];
	struct printk_record record;
};

enum kdb_msgsrc {
	KDB_MSGSRC_INTERNAL = 0,
	KDB_MSGSRC_PRINTK = 1,
};

struct printk_safe_seq_buf {
	atomic_t len;
	atomic_t message_lost;
	struct irq_work work;
	unsigned char buffer[8160];
};

struct prb_data_block {
	long unsigned int id;
	char data[0];
};

enum {
	IRQS_AUTODETECT = 1,
	IRQS_SPURIOUS_DISABLED = 2,
	IRQS_POLL_INPROGRESS = 8,
	IRQS_ONESHOT = 32,
	IRQS_REPLAY = 64,
	IRQS_WAITING = 128,
	IRQS_PENDING = 512,
	IRQS_SUSPENDED = 2048,
	IRQS_TIMINGS = 4096,
	IRQS_NMI = 8192,
};

enum {
	_IRQ_DEFAULT_INIT_FLAGS = 0,
	_IRQ_PER_CPU = 512,
	_IRQ_LEVEL = 256,
	_IRQ_NOPROBE = 1024,
	_IRQ_NOREQUEST = 2048,
	_IRQ_NOTHREAD = 65536,
	_IRQ_NOAUTOEN = 4096,
	_IRQ_MOVE_PCNTXT = 16384,
	_IRQ_NO_BALANCING = 8192,
	_IRQ_NESTED_THREAD = 32768,
	_IRQ_PER_CPU_DEVID = 131072,
	_IRQ_IS_POLLED = 262144,
	_IRQ_DISABLE_UNLAZY = 524288,
	_IRQ_HIDDEN = 1048576,
	_IRQF_MODIFY_MASK = 2096911,
};

enum {
	IRQTF_RUNTHREAD = 0,
	IRQTF_WARNED = 1,
	IRQTF_AFFINITY = 2,
	IRQTF_FORCED_THREAD = 3,
};

enum {
	IRQ_SET_MASK_OK = 0,
	IRQ_SET_MASK_OK_NOCOPY = 1,
	IRQ_SET_MASK_OK_DONE = 2,
};

enum {
	IRQCHIP_SET_TYPE_MASKED = 1,
	IRQCHIP_EOI_IF_HANDLED = 2,
	IRQCHIP_MASK_ON_SUSPEND = 4,
	IRQCHIP_ONOFFLINE_ENABLED = 8,
	IRQCHIP_SKIP_SET_WAKE = 16,
	IRQCHIP_ONESHOT_SAFE = 32,
	IRQCHIP_EOI_THREADED = 64,
	IRQCHIP_SUPPORTS_LEVEL_MSI = 128,
	IRQCHIP_SUPPORTS_NMI = 256,
	IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND = 512,
	IRQCHIP_AFFINITY_PRE_STARTUP = 1024,
	IRQCHIP_SHUTDOWN_ON_SUSPEND = 2048,
};

enum {
	IRQC_IS_HARDIRQ = 0,
	IRQC_IS_NESTED = 1,
};

enum {
	IRQ_STARTUP_NORMAL = 0,
	IRQ_STARTUP_MANAGED = 1,
	IRQ_STARTUP_ABORT = 2,
};

struct irq_devres {
	unsigned int irq;
	void *dev_id;
};

struct irq_desc_devres {
	unsigned int from;
	unsigned int cnt;
};

struct irq_generic_chip_devres {
	struct irq_chip_generic *gc;
	u32 msk;
	unsigned int clr;
	unsigned int set;
};

enum {
	IRQ_DOMAIN_FLAG_HIERARCHY = 1,
	IRQ_DOMAIN_NAME_ALLOCATED = 2,
	IRQ_DOMAIN_FLAG_IPI_PER_CPU = 4,
	IRQ_DOMAIN_FLAG_IPI_SINGLE = 8,
	IRQ_DOMAIN_FLAG_MSI = 16,
	IRQ_DOMAIN_FLAG_MSI_REMAP = 32,
	IRQ_DOMAIN_MSI_NOMASK_QUIRK = 64,
	IRQ_DOMAIN_FLAG_NONCORE = 65536,
};

enum {
	IRQCHIP_FWNODE_REAL = 0,
	IRQCHIP_FWNODE_NAMED = 1,
	IRQCHIP_FWNODE_NAMED_ID = 2,
};

struct irqchip_fwid {
	struct fwnode_handle fwnode;
	unsigned int type;
	char *name;
	phys_addr_t *pa;
};

enum {
	AFFINITY = 0,
	AFFINITY_LIST = 1,
	EFFECTIVE = 2,
	EFFECTIVE_LIST = 3,
};

struct msi_alloc_info {
	struct msi_desc *desc;
	irq_hw_number_t hwirq;
	long unsigned int flags;
	union {
		long unsigned int ul;
		void *ptr;
	} scratchpad[2];
};

typedef struct msi_alloc_info msi_alloc_info_t;

struct msi_domain_info;

struct msi_domain_ops {
	irq_hw_number_t (*get_hwirq)(struct msi_domain_info *, msi_alloc_info_t *);
	int (*msi_init)(struct irq_domain *, struct msi_domain_info *, unsigned int, irq_hw_number_t, msi_alloc_info_t *);
	void (*msi_free)(struct irq_domain *, struct msi_domain_info *, unsigned int);
	int (*msi_check)(struct irq_domain *, struct msi_domain_info *, struct device *);
	int (*msi_prepare)(struct irq_domain *, struct device *, int, msi_alloc_info_t *);
	void (*msi_finish)(msi_alloc_info_t *, int);
	void (*set_desc)(msi_alloc_info_t *, struct msi_desc *);
	int (*handle_error)(struct irq_domain *, struct msi_desc *, int);
	int (*domain_alloc_irqs)(struct irq_domain *, struct device *, int);
	void (*domain_free_irqs)(struct irq_domain *, struct device *);
};

struct msi_domain_info {
	u32 flags;
	struct msi_domain_ops *ops;
	struct irq_chip *chip;
	void *chip_data;
	irq_flow_handler_t handler;
	void *handler_data;
	const char *handler_name;
	void *data;
};

enum {
	MSI_FLAG_USE_DEF_DOM_OPS = 1,
	MSI_FLAG_USE_DEF_CHIP_OPS = 2,
	MSI_FLAG_MULTI_PCI_MSI = 4,
	MSI_FLAG_PCI_MSIX = 8,
	MSI_FLAG_ACTIVATE_EARLY = 16,
	MSI_FLAG_MUST_REACTIVATE = 32,
	MSI_FLAG_LEVEL_CAPABLE = 64,
};

struct irq_affinity {
	unsigned int pre_vectors;
	unsigned int post_vectors;
	unsigned int nr_sets;
	unsigned int set_size[4];
	void (*calc_sets)(struct irq_affinity *, unsigned int);
	void *priv;
};

struct node_vectors {
	unsigned int id;
	union {
		unsigned int nvectors;
		unsigned int ncpus;
	};
};

typedef void (*call_rcu_func_t)(struct callback_head *, rcu_callback_t);

struct rcu_synchronize {
	struct callback_head head;
	struct completion completion;
};

struct trace_event_raw_rcu_utilization {
	struct trace_entry ent;
	const char *s;
	char __data[0];
};

struct trace_event_raw_rcu_stall_warning {
	struct trace_entry ent;
	const char *rcuname;
	const char *msg;
	char __data[0];
};

struct trace_event_data_offsets_rcu_utilization {};

struct trace_event_data_offsets_rcu_stall_warning {};

typedef void (*btf_trace_rcu_utilization)(void *, const char *);

typedef void (*btf_trace_rcu_stall_warning)(void *, const char *, const char *);

struct rcu_tasks;

typedef void (*rcu_tasks_gp_func_t)(struct rcu_tasks *);

typedef void (*pregp_func_t)();

typedef void (*pertask_func_t)(struct task_struct *, struct list_head *);

typedef void (*postscan_func_t)(struct list_head *);

typedef void (*holdouts_func_t)(struct list_head *, bool, bool *);

typedef void (*postgp_func_t)(struct rcu_tasks *);

struct rcu_tasks {
	struct callback_head *cbs_head;
	struct callback_head **cbs_tail;
	struct wait_queue_head cbs_wq;
	raw_spinlock_t cbs_lock;
	int gp_state;
	int gp_sleep;
	int init_fract;
	long unsigned int gp_jiffies;
	long unsigned int gp_start;
	long unsigned int n_gps;
	long unsigned int n_ipis;
	long unsigned int n_ipis_fails;
	struct task_struct *kthread_ptr;
	rcu_tasks_gp_func_t gp_func;
	pregp_func_t pregp_func;
	pertask_func_t pertask_func;
	postscan_func_t postscan_func;
	holdouts_func_t holdouts_func;
	postgp_func_t postgp_func;
	call_rcu_func_t call_func;
	char *name;
	char *kname;
};

enum {
	GP_IDLE = 0,
	GP_ENTER = 1,
	GP_PASSED = 2,
	GP_EXIT = 3,
	GP_REPLAY = 4,
};

struct rcu_cblist {
	struct callback_head *head;
	struct callback_head **tail;
	long int len;
};

enum rcutorture_type {
	RCU_FLAVOR = 0,
	RCU_TASKS_FLAVOR = 1,
	RCU_TASKS_RUDE_FLAVOR = 2,
	RCU_TASKS_TRACING_FLAVOR = 3,
	RCU_TRIVIAL_FLAVOR = 4,
	SRCU_FLAVOR = 5,
	INVALID_RCU_FLAVOR = 6,
};

enum tick_device_mode {
	TICKDEV_MODE_PERIODIC = 0,
	TICKDEV_MODE_ONESHOT = 1,
};

struct tick_device___2 {
	struct clock_event_device *evtdev;
	enum tick_device_mode mode;
};

enum tick_dep_bits {
	TICK_DEP_BIT_POSIX_TIMER = 0,
	TICK_DEP_BIT_PERF_EVENTS = 1,
	TICK_DEP_BIT_SCHED = 2,
	TICK_DEP_BIT_CLOCK_UNSTABLE = 3,
	TICK_DEP_BIT_RCU = 4,
	TICK_DEP_BIT_RCU_EXP = 5,
};

struct rcu_exp_work {
	long unsigned int rew_s;
	struct work_struct rew_work;
};

struct rcu_node {
	raw_spinlock_t lock;
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	long unsigned int completedqs;
	long unsigned int qsmask;
	long unsigned int rcu_gp_init_mask;
	long unsigned int qsmaskinit;
	long unsigned int qsmaskinitnext;
	long unsigned int ofl_seq;
	long unsigned int expmask;
	long unsigned int expmaskinit;
	long unsigned int expmaskinitnext;
	long unsigned int cbovldmask;
	long unsigned int ffmask;
	long unsigned int grpmask;
	int grplo;
	int grphi;
	u8 grpnum;
	u8 level;
	bool wait_blkd_tasks;
	struct rcu_node *parent;
	struct list_head blkd_tasks;
	struct list_head *gp_tasks;
	struct list_head *exp_tasks;
	struct list_head *boost_tasks;
	struct rt_mutex boost_mtx;
	long unsigned int boost_time;
	struct task_struct *boost_kthread_task;
	unsigned int boost_kthread_status;
	long: 32;
	long: 64;
	long: 64;
	raw_spinlock_t fqslock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t exp_lock;
	long unsigned int exp_seq_rq;
	wait_queue_head_t exp_wq[4];
	struct rcu_exp_work rew;
	bool exp_need_flush;
	long: 56;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

union rcu_noqs {
	struct {
		u8 norm;
		u8 exp;
	} b;
	u16 s;
};

struct rcu_data {
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	union rcu_noqs cpu_no_qs;
	bool core_needs_qs;
	bool beenonline;
	bool gpwrap;
	bool exp_deferred_qs;
	bool cpu_started;
	struct rcu_node *mynode;
	long unsigned int grpmask;
	long unsigned int ticks_this_gp;
	struct irq_work defer_qs_iw;
	bool defer_qs_iw_pending;
	struct work_struct strict_work;
	struct rcu_segcblist cblist;
	long int qlen_last_fqs_check;
	long unsigned int n_cbs_invoked;
	long unsigned int n_force_qs_snap;
	long int blimit;
	int dynticks_snap;
	long int dynticks_nesting;
	long int dynticks_nmi_nesting;
	atomic_t dynticks;
	bool rcu_need_heavy_qs;
	bool rcu_urgent_qs;
	bool rcu_forced_tick;
	bool rcu_forced_tick_exp;
	struct callback_head barrier_head;
	int exp_dynticks_snap;
	struct task_struct *rcu_cpu_kthread_task;
	unsigned int rcu_cpu_kthread_status;
	char rcu_cpu_has_work;
	unsigned int softirq_snap;
	struct irq_work rcu_iw;
	bool rcu_iw_pending;
	long unsigned int rcu_iw_gp_seq;
	long unsigned int rcu_ofl_gp_seq;
	short int rcu_ofl_gp_flags;
	long unsigned int rcu_onl_gp_seq;
	short int rcu_onl_gp_flags;
	long unsigned int last_fqs_resched;
	int cpu;
};

struct rcu_state {
	struct rcu_node node[17];
	struct rcu_node *level[3];
	int ncpus;
	int n_online_cpus;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 boost;
	long unsigned int gp_seq;
	long unsigned int gp_max;
	struct task_struct *gp_kthread;
	struct swait_queue_head gp_wq;
	short int gp_flags;
	short int gp_state;
	long unsigned int gp_wake_time;
	long unsigned int gp_wake_seq;
	struct mutex barrier_mutex;
	atomic_t barrier_cpu_count;
	struct completion barrier_completion;
	long unsigned int barrier_sequence;
	struct mutex exp_mutex;
	struct mutex exp_wake_mutex;
	long unsigned int expedited_sequence;
	atomic_t expedited_need_qs;
	struct swait_queue_head expedited_wq;
	int ncpus_snap;
	u8 cbovld;
	u8 cbovldnext;
	long unsigned int jiffies_force_qs;
	long unsigned int jiffies_kick_kthreads;
	long unsigned int n_force_qs;
	long unsigned int gp_start;
	long unsigned int gp_end;
	long unsigned int gp_activity;
	long unsigned int gp_req_activity;
	long unsigned int jiffies_stall;
	long unsigned int jiffies_resched;
	long unsigned int n_force_qs_gpstart;
	const char *name;
	char abbr;
	long: 56;
	long: 64;
	long: 64;
	raw_spinlock_t ofl_lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kvfree_rcu_bulk_data {
	long unsigned int nr_records;
	struct kvfree_rcu_bulk_data *next;
	void *records[0];
};

struct kfree_rcu_cpu;

struct kfree_rcu_cpu_work {
	struct rcu_work rcu_work;
	struct callback_head *head_free;
	struct kvfree_rcu_bulk_data *bkvhead_free[2];
	struct kfree_rcu_cpu *krcp;
};

struct kfree_rcu_cpu {
	struct callback_head *head;
	struct kvfree_rcu_bulk_data *bkvhead[2];
	struct kfree_rcu_cpu_work krw_arr[2];
	raw_spinlock_t lock;
	struct delayed_work monitor_work;
	bool monitor_todo;
	bool initialized;
	int count;
	struct work_struct page_cache_work;
	atomic_t work_in_progress;
	struct hrtimer hrtimer;
	struct llist_head bkvcache;
	int nr_bkv_objs;
};

struct dma_sgt_handle {
	struct sg_table sgt;
	struct page **pages;
};

struct dma_devres {
	size_t size;
	void *vaddr;
	dma_addr_t dma_handle;
	long unsigned int attrs;
};

struct reserved_mem_ops;

struct reserved_mem {
	const char *name;
	long unsigned int fdt_node;
	long unsigned int phandle;
	const struct reserved_mem_ops *ops;
	phys_addr_t base;
	phys_addr_t size;
	void *priv;
};

struct reserved_mem_ops {
	int (*device_init)(struct reserved_mem *, struct device *);
	void (*device_release)(struct reserved_mem *, struct device *);
};

typedef int (*reservedmem_of_init_fn)(struct reserved_mem *);

struct dma_coherent_mem {
	void *virt_base;
	dma_addr_t device_base;
	long unsigned int pfn_base;
	int size;
	long unsigned int *bitmap;
	spinlock_t spinlock;
	bool use_dev_dma_pfn_offset;
};

struct trace_event_raw_swiotlb_bounced {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u64 dma_mask;
	dma_addr_t dev_addr;
	size_t size;
	enum swiotlb_force swiotlb_force;
	char __data[0];
};

struct trace_event_data_offsets_swiotlb_bounced {
	u32 dev_name;
};

typedef void (*btf_trace_swiotlb_bounced)(void *, struct device *, dma_addr_t, size_t, enum swiotlb_force);

struct gen_pool;

typedef long unsigned int (*genpool_algo_t)(long unsigned int *, long unsigned int, long unsigned int, unsigned int, void *, struct gen_pool *, long unsigned int);

struct gen_pool {
	spinlock_t lock;
	struct list_head chunks;
	int min_alloc_order;
	genpool_algo_t algo;
	void *data;
	const char *name;
};

enum kcmp_type {
	KCMP_FILE = 0,
	KCMP_VM = 1,
	KCMP_FILES = 2,
	KCMP_FS = 3,
	KCMP_SIGHAND = 4,
	KCMP_IO = 5,
	KCMP_SYSVSEM = 6,
	KCMP_EPOLL_TFD = 7,
	KCMP_TYPES = 8,
};

struct kcmp_epoll_slot {
	__u32 efd;
	__u32 tfd;
	__u32 toff;
};

enum profile_type {
	PROFILE_TASK_EXIT = 0,
	PROFILE_MUNMAP = 1,
};

struct profile_hit {
	u32 pc;
	u32 hits;
};

struct stacktrace_cookie {
	long unsigned int *store;
	unsigned int size;
	unsigned int skip;
	unsigned int len;
};

typedef __kernel_long_t __kernel_suseconds_t;

typedef __kernel_suseconds_t suseconds_t;

typedef __u64 timeu64_t;

struct __kernel_itimerspec {
	struct __kernel_timespec it_interval;
	struct __kernel_timespec it_value;
};

struct itimerspec64 {
	struct timespec64 it_interval;
	struct timespec64 it_value;
};

struct old_itimerspec32 {
	struct old_timespec32 it_interval;
	struct old_timespec32 it_value;
};

struct old_timex32 {
	u32 modes;
	s32 offset;
	s32 freq;
	s32 maxerror;
	s32 esterror;
	s32 status;
	s32 constant;
	s32 precision;
	s32 tolerance;
	struct old_timeval32 time;
	s32 tick;
	s32 ppsfreq;
	s32 jitter;
	s32 shift;
	s32 stabil;
	s32 jitcnt;
	s32 calcnt;
	s32 errcnt;
	s32 stbcnt;
	s32 tai;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct __kernel_timex_timeval {
	__kernel_time64_t tv_sec;
	long long int tv_usec;
};

struct __kernel_timex {
	unsigned int modes;
	long long int offset;
	long long int freq;
	long long int maxerror;
	long long int esterror;
	int status;
	long long int constant;
	long long int precision;
	long long int tolerance;
	struct __kernel_timex_timeval time;
	long long int tick;
	long long int ppsfreq;
	long long int jitter;
	int shift;
	long long int stabil;
	long long int jitcnt;
	long long int calcnt;
	long long int errcnt;
	long long int stbcnt;
	int tai;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct trace_event_raw_timer_class {
	struct trace_entry ent;
	void *timer;
	char __data[0];
};

struct trace_event_raw_timer_start {
	struct trace_entry ent;
	void *timer;
	void *function;
	long unsigned int expires;
	long unsigned int now;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_timer_expire_entry {
	struct trace_entry ent;
	void *timer;
	long unsigned int now;
	void *function;
	long unsigned int baseclk;
	char __data[0];
};

struct trace_event_raw_hrtimer_init {
	struct trace_entry ent;
	void *hrtimer;
	clockid_t clockid;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_start {
	struct trace_entry ent;
	void *hrtimer;
	void *function;
	s64 expires;
	s64 softexpires;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_expire_entry {
	struct trace_entry ent;
	void *hrtimer;
	s64 now;
	void *function;
	char __data[0];
};

struct trace_event_raw_hrtimer_class {
	struct trace_entry ent;
	void *hrtimer;
	char __data[0];
};

struct trace_event_raw_itimer_state {
	struct trace_entry ent;
	int which;
	long long unsigned int expires;
	long int value_sec;
	long int value_nsec;
	long int interval_sec;
	long int interval_nsec;
	char __data[0];
};

struct trace_event_raw_itimer_expire {
	struct trace_entry ent;
	int which;
	pid_t pid;
	long long unsigned int now;
	char __data[0];
};

struct trace_event_raw_tick_stop {
	struct trace_entry ent;
	int success;
	int dependency;
	char __data[0];
};

struct trace_event_data_offsets_timer_class {};

struct trace_event_data_offsets_timer_start {};

struct trace_event_data_offsets_timer_expire_entry {};

struct trace_event_data_offsets_hrtimer_init {};

struct trace_event_data_offsets_hrtimer_start {};

struct trace_event_data_offsets_hrtimer_expire_entry {};

struct trace_event_data_offsets_hrtimer_class {};

struct trace_event_data_offsets_itimer_state {};

struct trace_event_data_offsets_itimer_expire {};

struct trace_event_data_offsets_tick_stop {};

typedef void (*btf_trace_timer_init)(void *, struct timer_list *);

typedef void (*btf_trace_timer_start)(void *, struct timer_list *, long unsigned int, unsigned int);

typedef void (*btf_trace_timer_expire_entry)(void *, struct timer_list *, long unsigned int);

typedef void (*btf_trace_timer_expire_exit)(void *, struct timer_list *);

typedef void (*btf_trace_timer_cancel)(void *, struct timer_list *);

typedef void (*btf_trace_hrtimer_init)(void *, struct hrtimer *, clockid_t, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_start)(void *, struct hrtimer *, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_expire_entry)(void *, struct hrtimer *, ktime_t *);

typedef void (*btf_trace_hrtimer_expire_exit)(void *, struct hrtimer *);

typedef void (*btf_trace_hrtimer_cancel)(void *, struct hrtimer *);

typedef void (*btf_trace_itimer_state)(void *, int, const struct itimerspec64 * const, long long unsigned int);

typedef void (*btf_trace_itimer_expire)(void *, int, struct pid *, long long unsigned int);

typedef void (*btf_trace_tick_stop)(void *, int, int);

struct timer_base {
	raw_spinlock_t lock;
	struct timer_list *running_timer;
	long unsigned int clk;
	long unsigned int next_expiry;
	unsigned int cpu;
	bool next_expiry_recalc;
	bool is_idle;
	bool timers_pending;
	long unsigned int pending_map[9];
	struct hlist_head vectors[576];
	long: 64;
	long: 64;
};

struct process_timer {
	struct timer_list timer;
	struct task_struct *task;
};

struct ktime_timestamps {
	u64 mono;
	u64 boot;
	u64 real;
};

struct system_device_crosststamp {
	ktime_t device;
	ktime_t sys_realtime;
	ktime_t sys_monoraw;
};

struct system_counterval_t {
	u64 cycles;
	struct clocksource *cs;
};

struct audit_ntp_val {
	long long int oldval;
	long long int newval;
};

struct audit_ntp_data {
	struct audit_ntp_val vals[6];
};

enum timekeeping_adv_mode {
	TK_ADV_TICK = 0,
	TK_ADV_FREQ = 1,
};

struct tk_fast {
	seqcount_latch_t seq;
	struct tk_read_base base[2];
};

struct rtc_time {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
};

struct rtc_wkalrm {
	unsigned char enabled;
	unsigned char pending;
	struct rtc_time time;
};

struct rtc_class_ops {
	int (*ioctl)(struct device *, unsigned int, long unsigned int);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*alarm_irq_enable)(struct device *, unsigned int);
	int (*read_offset)(struct device *, long int *);
	int (*set_offset)(struct device *, long int);
};

struct rtc_device;

struct rtc_timer {
	struct timerqueue_node node;
	ktime_t period;
	void (*func)(struct rtc_device *);
	struct rtc_device *rtc;
	int enabled;
};

struct rtc_device {
	struct device dev;
	struct module *owner;
	int id;
	const struct rtc_class_ops *ops;
	struct mutex ops_lock;
	struct cdev char_dev;
	long unsigned int flags;
	long unsigned int irq_data;
	spinlock_t irq_lock;
	wait_queue_head_t irq_queue;
	struct fasync_struct *async_queue;
	int irq_freq;
	int max_user_freq;
	struct timerqueue_head timerqueue;
	struct rtc_timer aie_timer;
	struct rtc_timer uie_rtctimer;
	struct hrtimer pie_timer;
	int pie_enabled;
	struct work_struct irqwork;
	int uie_unsupported;
	long unsigned int set_offset_nsec;
	long unsigned int features[1];
	time64_t range_min;
	timeu64_t range_max;
	time64_t start_secs;
	time64_t offset_secs;
	bool set_start_time;
};

enum tick_nohz_mode {
	NOHZ_MODE_INACTIVE = 0,
	NOHZ_MODE_LOWRES = 1,
	NOHZ_MODE_HIGHRES = 2,
};

struct tick_sched {
	struct hrtimer sched_timer;
	long unsigned int check_clocks;
	enum tick_nohz_mode nohz_mode;
	unsigned int inidle: 1;
	unsigned int tick_stopped: 1;
	unsigned int idle_active: 1;
	unsigned int do_timer_last: 1;
	unsigned int got_idle_tick: 1;
	ktime_t last_tick;
	ktime_t next_tick;
	long unsigned int idle_jiffies;
	long unsigned int idle_calls;
	long unsigned int idle_sleeps;
	ktime_t idle_entrytime;
	ktime_t idle_waketime;
	ktime_t idle_exittime;
	ktime_t idle_sleeptime;
	ktime_t iowait_sleeptime;
	long unsigned int last_jiffies;
	u64 timer_expires;
	u64 timer_expires_base;
	u64 next_timer;
	ktime_t idle_expires;
	atomic_t tick_dep_mask;
};

struct timer_list_iter {
	int cpu;
	bool second_pass;
	u64 now;
};

struct tm {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	long int tm_year;
	int tm_wday;
	int tm_yday;
};

typedef __kernel_timer_t timer_t;

enum alarmtimer_type {
	ALARM_REALTIME = 0,
	ALARM_BOOTTIME = 1,
	ALARM_NUMTYPE = 2,
	ALARM_REALTIME_FREEZER = 3,
	ALARM_BOOTTIME_FREEZER = 4,
};

enum alarmtimer_restart {
	ALARMTIMER_NORESTART = 0,
	ALARMTIMER_RESTART = 1,
};

struct alarm {
	struct timerqueue_node node;
	struct hrtimer timer;
	enum alarmtimer_restart (*function)(struct alarm *, ktime_t);
	enum alarmtimer_type type;
	int state;
	void *data;
};

struct cpu_timer {
	struct timerqueue_node node;
	struct timerqueue_head *head;
	struct pid *pid;
	struct list_head elist;
	int firing;
};

struct k_clock;

struct k_itimer {
	struct list_head list;
	struct hlist_node t_hash;
	spinlock_t it_lock;
	const struct k_clock *kclock;
	clockid_t it_clock;
	timer_t it_id;
	int it_active;
	s64 it_overrun;
	s64 it_overrun_last;
	int it_requeue_pending;
	int it_sigev_notify;
	ktime_t it_interval;
	struct signal_struct *it_signal;
	union {
		struct pid *it_pid;
		struct task_struct *it_process;
	};
	struct sigqueue *sigq;
	union {
		struct {
			struct hrtimer timer;
		} real;
		struct cpu_timer cpu;
		struct {
			struct alarm alarmtimer;
		} alarm;
	} it;
	struct callback_head rcu;
};

struct k_clock {
	int (*clock_getres)(const clockid_t, struct timespec64 *);
	int (*clock_set)(const clockid_t, const struct timespec64 *);
	int (*clock_get_timespec)(const clockid_t, struct timespec64 *);
	ktime_t (*clock_get_ktime)(const clockid_t);
	int (*clock_adj)(const clockid_t, struct __kernel_timex *);
	int (*timer_create)(struct k_itimer *);
	int (*nsleep)(const clockid_t, int, const struct timespec64 *);
	int (*timer_set)(struct k_itimer *, int, struct itimerspec64 *, struct itimerspec64 *);
	int (*timer_del)(struct k_itimer *);
	void (*timer_get)(struct k_itimer *, struct itimerspec64 *);
	void (*timer_rearm)(struct k_itimer *);
	s64 (*timer_forward)(struct k_itimer *, ktime_t);
	ktime_t (*timer_remaining)(struct k_itimer *, ktime_t);
	int (*timer_try_to_cancel)(struct k_itimer *);
	void (*timer_arm)(struct k_itimer *, ktime_t, bool, bool);
	void (*timer_wait_running)(struct k_itimer *);
};

struct class_interface {
	struct list_head node;
	struct class *class;
	int (*add_dev)(struct device *, struct class_interface *);
	void (*remove_dev)(struct device *, struct class_interface *);
};

struct property_entry;

struct platform_device_info {
	struct device *parent;
	struct fwnode_handle *fwnode;
	bool of_node_reused;
	const char *name;
	int id;
	const struct resource *res;
	unsigned int num_res;
	const void *data;
	size_t size_data;
	u64 dma_mask;
	const struct property_entry *properties;
};

enum dev_prop_type {
	DEV_PROP_U8 = 0,
	DEV_PROP_U16 = 1,
	DEV_PROP_U32 = 2,
	DEV_PROP_U64 = 3,
	DEV_PROP_STRING = 4,
	DEV_PROP_REF = 5,
};

struct property_entry {
	const char *name;
	size_t length;
	bool is_inline;
	enum dev_prop_type type;
	union {
		const void *pointer;
		union {
			u8 u8_data[8];
			u16 u16_data[4];
			u32 u32_data[2];
			u64 u64_data[1];
			const char *str[1];
		} value;
	};
};

struct trace_event_raw_alarmtimer_suspend {
	struct trace_entry ent;
	s64 expires;
	unsigned char alarm_type;
	char __data[0];
};

struct trace_event_raw_alarm_class {
	struct trace_entry ent;
	void *alarm;
	unsigned char alarm_type;
	s64 expires;
	s64 now;
	char __data[0];
};

struct trace_event_data_offsets_alarmtimer_suspend {};

struct trace_event_data_offsets_alarm_class {};

typedef void (*btf_trace_alarmtimer_suspend)(void *, ktime_t, int);

typedef void (*btf_trace_alarmtimer_fired)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_start)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_cancel)(void *, struct alarm *, ktime_t);

struct alarm_base {
	spinlock_t lock;
	struct timerqueue_head timerqueue;
	ktime_t (*get_ktime)();
	void (*get_timespec)(struct timespec64 *);
	clockid_t base_clockid;
};

struct sigevent {
	sigval_t sigev_value;
	int sigev_signo;
	int sigev_notify;
	union {
		int _pad[12];
		int _tid;
		struct {
			void (*_function)(sigval_t);
			void *_attribute;
		} _sigev_thread;
	} _sigev_un;
};

typedef struct sigevent sigevent_t;

struct compat_sigevent {
	compat_sigval_t sigev_value;
	compat_int_t sigev_signo;
	compat_int_t sigev_notify;
	union {
		compat_int_t _pad[13];
		compat_int_t _tid;
		struct {
			compat_uptr_t _function;
			compat_uptr_t _attribute;
		} _sigev_thread;
	} _sigev_un;
};

struct posix_clock;

struct posix_clock_operations {
	struct module *owner;
	int (*clock_adjtime)(struct posix_clock *, struct __kernel_timex *);
	int (*clock_gettime)(struct posix_clock *, struct timespec64 *);
	int (*clock_getres)(struct posix_clock *, struct timespec64 *);
	int (*clock_settime)(struct posix_clock *, const struct timespec64 *);
	long int (*ioctl)(struct posix_clock *, unsigned int, long unsigned int);
	int (*open)(struct posix_clock *, fmode_t);
	__poll_t (*poll)(struct posix_clock *, struct file *, poll_table *);
	int (*release)(struct posix_clock *);
	ssize_t (*read)(struct posix_clock *, uint, char *, size_t);
};

struct posix_clock {
	struct posix_clock_operations ops;
	struct cdev cdev;
	struct device *dev;
	struct rw_semaphore rwsem;
	bool zombie;
};

struct posix_clock_desc {
	struct file *fp;
	struct posix_clock *clk;
};

struct __kernel_old_itimerval {
	struct __kernel_old_timeval it_interval;
	struct __kernel_old_timeval it_value;
};

struct old_itimerval32 {
	struct old_timeval32 it_interval;
	struct old_timeval32 it_value;
};

typedef s64 int64_t;

struct ce_unbind {
	struct clock_event_device *ce;
	int res;
};

enum tick_broadcast_state {
	TICK_BROADCAST_EXIT = 0,
	TICK_BROADCAST_ENTER = 1,
};

enum tick_broadcast_mode {
	TICK_BROADCAST_OFF = 0,
	TICK_BROADCAST_ON = 1,
	TICK_BROADCAST_FORCE = 2,
};

struct clock_data {
	seqcount_latch_t seq;
	struct clock_read_data read_data[2];
	ktime_t wrap_kt;
	long unsigned int rate;
	u64 (*actual_read_sched_clock)();
};

struct proc_timens_offset {
	int clockid;
	struct timespec64 val;
};

union futex_key {
	struct {
		u64 i_seq;
		long unsigned int pgoff;
		unsigned int offset;
	} shared;
	struct {
		union {
			struct mm_struct *mm;
			u64 __tmp;
		};
		long unsigned int address;
		unsigned int offset;
	} private;
	struct {
		u64 ptr;
		long unsigned int word;
		unsigned int offset;
	} both;
};

struct futex_pi_state {
	struct list_head list;
	struct rt_mutex pi_mutex;
	struct task_struct *owner;
	refcount_t refcount;
	union futex_key key;
};

struct futex_q {
	struct plist_node list;
	struct task_struct *task;
	spinlock_t *lock_ptr;
	union futex_key key;
	struct futex_pi_state *pi_state;
	struct rt_mutex_waiter *rt_waiter;
	union futex_key *requeue_pi_key;
	u32 bitset;
};

struct futex_hash_bucket {
	atomic_t waiters;
	spinlock_t lock;
	struct plist_head chain;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum futex_access {
	FUTEX_READ = 0,
	FUTEX_WRITE = 1,
};

typedef bool (*smp_cond_func_t)(int, void *);

struct cfd_percpu {
	call_single_data_t csd;
};

struct call_function_data {
	struct cfd_percpu *pcpu;
	cpumask_var_t cpumask;
	cpumask_var_t cpumask_ipi;
};

struct smp_call_on_cpu_struct {
	struct work_struct work;
	struct completion done;
	int (*func)(void *);
	void *data;
	int ret;
	int cpu;
};

typedef short unsigned int __kernel_old_uid_t;

typedef short unsigned int __kernel_old_gid_t;

typedef __kernel_old_uid_t old_uid_t;

typedef __kernel_old_gid_t old_gid_t;

struct latch_tree_root {
	seqcount_latch_t seq;
	struct rb_root tree[2];
};

struct latch_tree_ops {
	bool (*less)(struct latch_tree_node *, struct latch_tree_node *);
	int (*comp)(void *, struct latch_tree_node *);
};

struct modversion_info {
	long unsigned int crc;
	char name[56];
};

struct module_use {
	struct list_head source_list;
	struct list_head target_list;
	struct module *source;
	struct module *target;
};

struct module_sect_attr {
	struct bin_attribute battr;
	long unsigned int address;
};

struct module_sect_attrs {
	struct attribute_group grp;
	unsigned int nsections;
	struct module_sect_attr attrs[0];
};

struct module_notes_attrs {
	struct kobject *dir;
	unsigned int notes;
	struct bin_attribute attrs[0];
};

enum kernel_read_file_id {
	READING_UNKNOWN = 0,
	READING_FIRMWARE = 1,
	READING_MODULE = 2,
	READING_KEXEC_IMAGE = 3,
	READING_KEXEC_INITRAMFS = 4,
	READING_POLICY = 5,
	READING_X509_CERTIFICATE = 6,
	READING_MAX_ID = 7,
};

enum kernel_load_data_id {
	LOADING_UNKNOWN = 0,
	LOADING_FIRMWARE = 1,
	LOADING_MODULE = 2,
	LOADING_KEXEC_IMAGE = 3,
	LOADING_KEXEC_INITRAMFS = 4,
	LOADING_POLICY = 5,
	LOADING_X509_CERTIFICATE = 6,
	LOADING_MAX_ID = 7,
};

enum {
	PROC_ENTRY_PERMANENT = 1,
};

struct load_info {
	const char *name;
	struct module *mod;
	Elf64_Ehdr *hdr;
	long unsigned int len;
	Elf64_Shdr *sechdrs;
	char *secstrings;
	char *strtab;
	long unsigned int symoffs;
	long unsigned int stroffs;
	long unsigned int init_typeoffs;
	long unsigned int core_typeoffs;
	struct _ddebug *debug;
	unsigned int num_debug;
	bool sig_ok;
	long unsigned int mod_kallsyms_init_off;
	struct {
		unsigned int sym;
		unsigned int str;
		unsigned int mod;
		unsigned int vers;
		unsigned int info;
		unsigned int pcpu;
	} index;
};

struct trace_event_raw_module_load {
	struct trace_entry ent;
	unsigned int taints;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_free {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_refcnt {
	struct trace_entry ent;
	long unsigned int ip;
	int refcnt;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_request {
	struct trace_entry ent;
	long unsigned int ip;
	bool wait;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_module_load {
	u32 name;
};

struct trace_event_data_offsets_module_free {
	u32 name;
};

struct trace_event_data_offsets_module_refcnt {
	u32 name;
};

struct trace_event_data_offsets_module_request {
	u32 name;
};

typedef void (*btf_trace_module_load)(void *, struct module *);

typedef void (*btf_trace_module_free)(void *, struct module *);

typedef void (*btf_trace_module_get)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_put)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_request)(void *, char *, bool, long unsigned int);

struct mod_tree_root {
	struct latch_tree_root root;
	long unsigned int addr_min;
	long unsigned int addr_max;
};

enum mod_license {
	NOT_GPL_ONLY = 0,
	GPL_ONLY = 1,
};

struct symsearch {
	const struct kernel_symbol *start;
	const struct kernel_symbol *stop;
	const s32 *crcs;
	enum mod_license license;
};

struct find_symbol_arg {
	const char *name;
	bool gplok;
	bool warn;
	struct module *owner;
	const s32 *crc;
	const struct kernel_symbol *sym;
	enum mod_license license;
};

struct mod_initfree {
	struct llist_node node;
	void *module_init;
};

struct module_signature {
	u8 algo;
	u8 hash;
	u8 id_type;
	u8 signer_len;
	u8 key_id_len;
	u8 __pad[3];
	__be32 sig_len;
};

struct asymmetric_key_subtype;

enum pkey_id_type {
	PKEY_ID_PGP = 0,
	PKEY_ID_X509 = 1,
	PKEY_ID_PKCS7 = 2,
};

struct kallsym_iter {
	loff_t pos;
	loff_t pos_arch_end;
	loff_t pos_mod_end;
	loff_t pos_ftrace_mod_end;
	loff_t pos_bpf_end;
	long unsigned int value;
	unsigned int nameoff;
	char type;
	char name[128];
	char module_name[56];
	int exported;
	int show_value;
};

typedef struct {
	int val[2];
} __kernel_fsid_t;

struct kstatfs {
	long int f_type;
	long int f_bsize;
	u64 f_blocks;
	u64 f_bfree;
	u64 f_bavail;
	u64 f_files;
	u64 f_ffree;
	__kernel_fsid_t f_fsid;
	long int f_namelen;
	long int f_frsize;
	long int f_flags;
	long int f_spare[4];
};

typedef __u16 comp_t;

struct acct_v3 {
	char ac_flag;
	char ac_version;
	__u16 ac_tty;
	__u32 ac_exitcode;
	__u32 ac_uid;
	__u32 ac_gid;
	__u32 ac_pid;
	__u32 ac_ppid;
	__u32 ac_btime;
	__u32 ac_etime;
	comp_t ac_utime;
	comp_t ac_stime;
	comp_t ac_mem;
	comp_t ac_io;
	comp_t ac_rw;
	comp_t ac_minflt;
	comp_t ac_majflt;
	comp_t ac_swaps;
	char ac_comm[16];
};

typedef struct acct_v3 acct_t;

struct fs_pin {
	wait_queue_head_t wait;
	int done;
	struct hlist_node s_list;
	struct hlist_node m_list;
	void (*kill)(struct fs_pin *);
};

struct bsd_acct_struct {
	struct fs_pin pin;
	atomic_long_t count;
	struct callback_head rcu;
	struct mutex lock;
	int active;
	long unsigned int needcheck;
	struct file *file;
	struct pid_namespace *ns;
	struct work_struct work;
	struct completion done;
};

struct elf64_note {
	Elf64_Word n_namesz;
	Elf64_Word n_descsz;
	Elf64_Word n_type;
};

struct elf_note_section {
	struct elf64_note n_hdr;
	u8 n_data[0];
};

typedef long unsigned int elf_greg_t;

typedef elf_greg_t elf_gregset_t[34];

struct elf_siginfo {
	int si_signo;
	int si_code;
	int si_errno;
};

struct elf_prstatus_common {
	struct elf_siginfo pr_info;
	short int pr_cursig;
	long unsigned int pr_sigpend;
	long unsigned int pr_sighold;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	struct __kernel_old_timeval pr_utime;
	struct __kernel_old_timeval pr_stime;
	struct __kernel_old_timeval pr_cutime;
	struct __kernel_old_timeval pr_cstime;
};

struct elf_prstatus {
	struct elf_prstatus_common common;
	elf_gregset_t pr_reg;
	int pr_fpvalid;
};

struct kexec_sha_region {
	long unsigned int start;
	long unsigned int len;
};

struct compat_kexec_segment {
	compat_uptr_t buf;
	compat_size_t bufsz;
	compat_ulong_t mem;
	compat_size_t memsz;
};

struct elf64_phdr {
	Elf64_Word p_type;
	Elf64_Word p_flags;
	Elf64_Off p_offset;
	Elf64_Addr p_vaddr;
	Elf64_Addr p_paddr;
	Elf64_Xword p_filesz;
	Elf64_Xword p_memsz;
	Elf64_Xword p_align;
};

typedef struct elf64_phdr Elf64_Phdr;

struct crypto_alg;

struct crypto_tfm {
	u32 crt_flags;
	int node;
	void (*exit)(struct crypto_tfm *);
	struct crypto_alg *__crt_alg;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__crt_ctx[0];
};

struct cipher_alg {
	unsigned int cia_min_keysize;
	unsigned int cia_max_keysize;
	int (*cia_setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	void (*cia_encrypt)(struct crypto_tfm *, u8 *, const u8 *);
	void (*cia_decrypt)(struct crypto_tfm *, u8 *, const u8 *);
};

struct compress_alg {
	int (*coa_compress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
	int (*coa_decompress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
};

struct crypto_istat_aead {
	atomic64_t encrypt_cnt;
	atomic64_t encrypt_tlen;
	atomic64_t decrypt_cnt;
	atomic64_t decrypt_tlen;
	atomic64_t err_cnt;
};

struct crypto_istat_akcipher {
	atomic64_t encrypt_cnt;
	atomic64_t encrypt_tlen;
	atomic64_t decrypt_cnt;
	atomic64_t decrypt_tlen;
	atomic64_t verify_cnt;
	atomic64_t sign_cnt;
	atomic64_t err_cnt;
};

struct crypto_istat_cipher {
	atomic64_t encrypt_cnt;
	atomic64_t encrypt_tlen;
	atomic64_t decrypt_cnt;
	atomic64_t decrypt_tlen;
	atomic64_t err_cnt;
};

struct crypto_istat_compress {
	atomic64_t compress_cnt;
	atomic64_t compress_tlen;
	atomic64_t decompress_cnt;
	atomic64_t decompress_tlen;
	atomic64_t err_cnt;
};

struct crypto_istat_hash {
	atomic64_t hash_cnt;
	atomic64_t hash_tlen;
	atomic64_t err_cnt;
};

struct crypto_istat_kpp {
	atomic64_t setsecret_cnt;
	atomic64_t generate_public_key_cnt;
	atomic64_t compute_shared_secret_cnt;
	atomic64_t err_cnt;
};

struct crypto_istat_rng {
	atomic64_t generate_cnt;
	atomic64_t generate_tlen;
	atomic64_t seed_cnt;
	atomic64_t err_cnt;
};

struct crypto_type;

struct crypto_alg {
	struct list_head cra_list;
	struct list_head cra_users;
	u32 cra_flags;
	unsigned int cra_blocksize;
	unsigned int cra_ctxsize;
	unsigned int cra_alignmask;
	int cra_priority;
	refcount_t cra_refcnt;
	char cra_name[128];
	char cra_driver_name[128];
	const struct crypto_type *cra_type;
	union {
		struct cipher_alg cipher;
		struct compress_alg compress;
	} cra_u;
	int (*cra_init)(struct crypto_tfm *);
	void (*cra_exit)(struct crypto_tfm *);
	void (*cra_destroy)(struct crypto_alg *);
	struct module *cra_module;
	union {
		struct crypto_istat_aead aead;
		struct crypto_istat_akcipher akcipher;
		struct crypto_istat_cipher cipher;
		struct crypto_istat_compress compress;
		struct crypto_istat_hash hash;
		struct crypto_istat_rng rng;
		struct crypto_istat_kpp kpp;
	} stats;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct crypto_instance;

struct crypto_type {
	unsigned int (*ctxsize)(struct crypto_alg *, u32, u32);
	unsigned int (*extsize)(struct crypto_alg *);
	int (*init)(struct crypto_tfm *, u32, u32);
	int (*init_tfm)(struct crypto_tfm *);
	void (*show)(struct seq_file *, struct crypto_alg *);
	int (*report)(struct sk_buff *, struct crypto_alg *);
	void (*free)(struct crypto_instance *);
	unsigned int type;
	unsigned int maskclear;
	unsigned int maskset;
	unsigned int tfmsize;
};

struct crypto_shash;

struct shash_desc {
	struct crypto_shash *tfm;
	void *__ctx[0];
};

struct crypto_shash {
	unsigned int descsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

enum migrate_reason {
	MR_COMPACTION = 0,
	MR_MEMORY_FAILURE = 1,
	MR_MEMORY_HOTPLUG = 2,
	MR_SYSCALL = 3,
	MR_MEMPOLICY_MBIND = 4,
	MR_NUMA_MISPLACED = 5,
	MR_CONTIG_RANGE = 6,
	MR_LONGTERM_PIN = 7,
	MR_TYPES = 8,
};

typedef __kernel_ulong_t ino_t;

enum kernfs_node_type {
	KERNFS_DIR = 1,
	KERNFS_FILE = 2,
	KERNFS_LINK = 4,
};

enum kernfs_root_flag {
	KERNFS_ROOT_CREATE_DEACTIVATED = 1,
	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2,
	KERNFS_ROOT_SUPPORT_EXPORTOP = 4,
	KERNFS_ROOT_SUPPORT_USER_XATTR = 8,
};

struct kernfs_fs_context {
	struct kernfs_root *root;
	void *ns_tag;
	long unsigned int magic;
	bool new_sb_created;
};

enum bpf_link_type {
	BPF_LINK_TYPE_UNSPEC = 0,
	BPF_LINK_TYPE_RAW_TRACEPOINT = 1,
	BPF_LINK_TYPE_TRACING = 2,
	BPF_LINK_TYPE_CGROUP = 3,
	BPF_LINK_TYPE_ITER = 4,
	BPF_LINK_TYPE_NETNS = 5,
	BPF_LINK_TYPE_XDP = 6,
	MAX_BPF_LINK_TYPE = 7,
};

struct bpf_link_info {
	__u32 type;
	__u32 id;
	__u32 prog_id;
	union {
		struct {
			__u64 tp_name;
			__u32 tp_name_len;
		} raw_tracepoint;
		struct {
			__u32 attach_type;
			__u32 target_obj_id;
			__u32 target_btf_id;
		} tracing;
		struct {
			__u64 cgroup_id;
			__u32 attach_type;
		} cgroup;
		struct {
			__u64 target_name;
			__u32 target_name_len;
			union {
				struct {
					__u32 map_id;
				} map;
			};
		} iter;
		struct {
			__u32 netns_ino;
			__u32 attach_type;
		} netns;
		struct {
			__u32 ifindex;
		} xdp;
	};
};

struct bpf_link_ops;

struct bpf_link {
	atomic64_t refcnt;
	u32 id;
	enum bpf_link_type type;
	const struct bpf_link_ops *ops;
	struct bpf_prog *prog;
	struct work_struct work;
};

struct bpf_link_ops {
	void (*release)(struct bpf_link *);
	void (*dealloc)(struct bpf_link *);
	int (*detach)(struct bpf_link *);
	int (*update_prog)(struct bpf_link *, struct bpf_prog *, struct bpf_prog *);
	void (*show_fdinfo)(const struct bpf_link *, struct seq_file *);
	int (*fill_link_info)(const struct bpf_link *, struct bpf_link_info *);
};

struct bpf_cgroup_link {
	struct bpf_link link;
	struct cgroup *cgroup;
	enum bpf_attach_type type;
};

enum {
	CGRP_NOTIFY_ON_RELEASE = 0,
	CGRP_CPUSET_CLONE_CHILDREN = 1,
	CGRP_FREEZE = 2,
	CGRP_FROZEN = 3,
};

enum {
	CGRP_ROOT_NOPREFIX = 2,
	CGRP_ROOT_XATTR = 4,
	CGRP_ROOT_NS_DELEGATE = 8,
	CGRP_ROOT_CPUSET_V2_MODE = 16,
	CGRP_ROOT_MEMORY_LOCAL_EVENTS = 32,
	CGRP_ROOT_MEMORY_RECURSIVE_PROT = 64,
};

struct cgroup_taskset {
	struct list_head src_csets;
	struct list_head dst_csets;
	int nr_tasks;
	int ssid;
	struct list_head *csets;
	struct css_set *cur_cset;
	struct task_struct *cur_task;
};

struct cgroup_fs_context {
	struct kernfs_fs_context kfc;
	struct cgroup_root *root;
	struct cgroup_namespace *ns;
	unsigned int flags;
	bool cpuset_clone_children;
	bool none;
	bool all_ss;
	u16 subsys_mask;
	char *name;
	char *release_agent;
};

struct cgroup_pidlist;

struct cgroup_file_ctx {
	struct cgroup_namespace *ns;
	struct {
		void *trigger;
	} psi;
	struct {
		bool started;
		struct css_task_iter iter;
	} procs;
	struct {
		struct cgroup_pidlist *pidlist;
	} procs1;
};

struct cgrp_cset_link {
	struct cgroup *cgrp;
	struct css_set *cset;
	struct list_head cset_link;
	struct list_head cgrp_link;
};

struct cgroup_mgctx {
	struct list_head preloaded_src_csets;
	struct list_head preloaded_dst_csets;
	struct cgroup_taskset tset;
	u16 ss_mask;
};

struct trace_event_raw_cgroup_root {
	struct trace_entry ent;
	int root;
	u16 ss_mask;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_cgroup {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_cgroup_migrate {
	struct trace_entry ent;
	int dst_root;
	int dst_level;
	u64 dst_id;
	int pid;
	u32 __data_loc_dst_path;
	u32 __data_loc_comm;
	char __data[0];
};

struct trace_event_raw_cgroup_event {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	int val;
	char __data[0];
};

struct trace_event_data_offsets_cgroup_root {
	u32 name;
};

struct trace_event_data_offsets_cgroup {
	u32 path;
};

struct trace_event_data_offsets_cgroup_migrate {
	u32 dst_path;
	u32 comm;
};

struct trace_event_data_offsets_cgroup_event {
	u32 path;
};

typedef void (*btf_trace_cgroup_setup_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_destroy_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_remount)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_mkdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rmdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_release)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rename)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_freeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_unfreeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_attach_task)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_transfer_tasks)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_notify_populated)(void *, struct cgroup *, const char *, int);

typedef void (*btf_trace_cgroup_notify_frozen)(void *, struct cgroup *, const char *, int);

enum cgroup2_param {
	Opt_nsdelegate = 0,
	Opt_memory_localevents = 1,
	Opt_memory_recursiveprot = 2,
	nr__cgroup2_params = 3,
};

struct cgroupstats {
	__u64 nr_sleeping;
	__u64 nr_running;
	__u64 nr_stopped;
	__u64 nr_uninterruptible;
	__u64 nr_io_wait;
};

enum cgroup_filetype {
	CGROUP_FILE_PROCS = 0,
	CGROUP_FILE_TASKS = 1,
};

struct cgroup_pidlist {
	struct {
		enum cgroup_filetype type;
		struct pid_namespace *ns;
	} key;
	pid_t *list;
	int length;
	struct list_head links;
	struct cgroup *owner;
	struct delayed_work destroy_dwork;
};

enum cgroup1_param {
	Opt_all = 0,
	Opt_clone_children = 1,
	Opt_cpuset_v2_mode = 2,
	Opt_name = 3,
	Opt_none = 4,
	Opt_noprefix = 5,
	Opt_release_agent = 6,
	Opt_xattr = 7,
};

enum freezer_state_flags {
	CGROUP_FREEZER_ONLINE = 1,
	CGROUP_FREEZING_SELF = 2,
	CGROUP_FREEZING_PARENT = 4,
	CGROUP_FROZEN = 8,
	CGROUP_FREEZING = 6,
};

struct freezer {
	struct cgroup_subsys_state css;
	unsigned int state;
};

struct pids_cgroup {
	struct cgroup_subsys_state css;
	atomic64_t counter;
	atomic64_t limit;
	struct cgroup_file events_file;
	atomic64_t events_limit;
};

typedef struct {
	char *from;
	char *to;
} substring_t;

enum rdmacg_resource_type {
	RDMACG_RESOURCE_HCA_HANDLE = 0,
	RDMACG_RESOURCE_HCA_OBJECT = 1,
	RDMACG_RESOURCE_MAX = 2,
};

struct rdma_cgroup {
	struct cgroup_subsys_state css;
	struct list_head rpools;
};

struct rdmacg_device {
	struct list_head dev_node;
	struct list_head rpools;
	char *name;
};

enum rdmacg_file_type {
	RDMACG_RESOURCE_TYPE_MAX = 0,
	RDMACG_RESOURCE_TYPE_STAT = 1,
};

struct rdmacg_resource {
	int max;
	int usage;
};

struct rdmacg_resource_pool {
	struct rdmacg_device *device;
	struct rdmacg_resource resources[2];
	struct list_head cg_node;
	struct list_head dev_node;
	u64 usage_sum;
	int num_max_cnt;
};

struct fmeter {
	int cnt;
	int val;
	time64_t time;
	spinlock_t lock;
};

struct cpuset {
	struct cgroup_subsys_state css;
	long unsigned int flags;
	cpumask_var_t cpus_allowed;
	nodemask_t mems_allowed;
	cpumask_var_t effective_cpus;
	nodemask_t effective_mems;
	cpumask_var_t subparts_cpus;
	nodemask_t old_mems_allowed;
	struct fmeter fmeter;
	int attach_in_progress;
	int pn;
	int relax_domain_level;
	int nr_subparts_cpus;
	int partition_root_state;
	int use_parent_ecpus;
	int child_ecpus_count;
};

struct tmpmasks {
	cpumask_var_t addmask;
	cpumask_var_t delmask;
	cpumask_var_t new_cpus;
};

typedef enum {
	CS_ONLINE = 0,
	CS_CPU_EXCLUSIVE = 1,
	CS_MEM_EXCLUSIVE = 2,
	CS_MEM_HARDWALL = 3,
	CS_MEMORY_MIGRATE = 4,
	CS_SCHED_LOAD_BALANCE = 5,
	CS_SPREAD_PAGE = 6,
	CS_SPREAD_SLAB = 7,
} cpuset_flagbits_t;

enum subparts_cmd {
	partcmd_enable = 0,
	partcmd_disable = 1,
	partcmd_update = 2,
};

struct cpuset_migrate_mm_work {
	struct work_struct work;
	struct mm_struct *mm;
	nodemask_t from;
	nodemask_t to;
};

typedef enum {
	FILE_MEMORY_MIGRATE = 0,
	FILE_CPULIST = 1,
	FILE_MEMLIST = 2,
	FILE_EFFECTIVE_CPULIST = 3,
	FILE_EFFECTIVE_MEMLIST = 4,
	FILE_SUBPARTS_CPULIST = 5,
	FILE_CPU_EXCLUSIVE = 6,
	FILE_MEM_EXCLUSIVE = 7,
	FILE_MEM_HARDWALL = 8,
	FILE_SCHED_LOAD_BALANCE = 9,
	FILE_PARTITION_ROOT = 10,
	FILE_SCHED_RELAX_DOMAIN_LEVEL = 11,
	FILE_MEMORY_PRESSURE_ENABLED = 12,
	FILE_MEMORY_PRESSURE = 13,
	FILE_SPREAD_PAGE = 14,
	FILE_SPREAD_SLAB = 15,
} cpuset_filetype_t;

enum misc_res_type {
	MISC_CG_RES_TYPES = 0,
};

struct misc_res {
	long unsigned int max;
	atomic_long_t usage;
	bool failed;
};

struct misc_cg {
	struct cgroup_subsys_state css;
	struct misc_res res[0];
};

struct kernel_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
};

enum kernel_pkey_operation {
	kernel_pkey_encrypt = 0,
	kernel_pkey_decrypt = 1,
	kernel_pkey_sign = 2,
	kernel_pkey_verify = 3,
};

struct kernel_pkey_params {
	struct key *key;
	const char *encoding;
	const char *hash_algo;
	char *info;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	enum kernel_pkey_operation op: 8;
};

struct key_preparsed_payload {
	const char *orig_description;
	char *description;
	union key_payload payload;
	const void *data;
	size_t datalen;
	size_t quotalen;
	time64_t expiry;
};

struct key_match_data {
	bool (*cmp)(const struct key *, const struct key_match_data *);
	const void *raw_data;
	void *preparsed;
	unsigned int lookup_type;
};

struct idmap_key {
	bool map_up;
	u32 id;
	u32 count;
};

struct ctl_path {
	const char *procname;
};

struct cpu_stop_done {
	atomic_t nr_todo;
	int ret;
	struct completion completion;
};

struct cpu_stopper {
	struct task_struct *thread;
	raw_spinlock_t lock;
	bool enabled;
	struct list_head works;
	struct cpu_stop_work stop_work;
	long unsigned int caller;
	cpu_stop_fn_t fn;
};

enum multi_stop_state {
	MULTI_STOP_NONE = 0,
	MULTI_STOP_PREPARE = 1,
	MULTI_STOP_DISABLE_IRQ = 2,
	MULTI_STOP_RUN = 3,
	MULTI_STOP_EXIT = 4,
};

struct multi_stop_data {
	cpu_stop_fn_t fn;
	void *data;
	unsigned int num_threads;
	const struct cpumask *active_cpus;
	enum multi_stop_state state;
	atomic_t thread_ack;
};

typedef int __kernel_mqd_t;

typedef __kernel_mqd_t mqd_t;

enum audit_state {
	AUDIT_DISABLED = 0,
	AUDIT_BUILD_CONTEXT = 1,
	AUDIT_RECORD_CONTEXT = 2,
};

struct audit_cap_data {
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	union {
		unsigned int fE;
		kernel_cap_t effective;
	};
	kernel_cap_t ambient;
	kuid_t rootid;
};

struct audit_names {
	struct list_head list;
	struct filename *name;
	int name_len;
	bool hidden;
	long unsigned int ino;
	dev_t dev;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	struct lsmblob oblob;
	struct audit_cap_data fcap;
	unsigned int fcap_ver;
	unsigned char type;
	bool should_free;
};

struct mq_attr {
	__kernel_long_t mq_flags;
	__kernel_long_t mq_maxmsg;
	__kernel_long_t mq_msgsize;
	__kernel_long_t mq_curmsgs;
	__kernel_long_t __reserved[4];
};

struct audit_proctitle {
	int len;
	char *value;
};

struct audit_aux_data;

struct audit_tree_refs;

struct audit_context {
	int dummy;
	int in_syscall;
	enum audit_state state;
	enum audit_state current_state;
	unsigned int serial;
	int major;
	struct timespec64 ctime;
	long unsigned int argv[4];
	long int return_code;
	u64 prio;
	int return_valid;
	struct audit_names preallocated_names[5];
	int name_count;
	struct list_head names_list;
	char *filterkey;
	struct path pwd;
	struct audit_aux_data *aux;
	struct audit_aux_data *aux_pids;
	struct __kernel_sockaddr_storage *sockaddr;
	size_t sockaddr_len;
	pid_t pid;
	pid_t ppid;
	kuid_t uid;
	kuid_t euid;
	kuid_t suid;
	kuid_t fsuid;
	kgid_t gid;
	kgid_t egid;
	kgid_t sgid;
	kgid_t fsgid;
	long unsigned int personality;
	int arch;
	pid_t target_pid;
	kuid_t target_auid;
	kuid_t target_uid;
	unsigned int target_sessionid;
	struct lsmblob target_lsm;
	char target_comm[16];
	struct audit_tree_refs *trees;
	struct audit_tree_refs *first_trees;
	struct list_head killed_trees;
	int tree_count;
	int type;
	union {
		struct {
			int nargs;
			long int args[6];
		} socketcall;
		struct {
			kuid_t uid;
			kgid_t gid;
			umode_t mode;
			struct lsmblob oblob;
			int has_perm;
			uid_t perm_uid;
			gid_t perm_gid;
			umode_t perm_mode;
			long unsigned int qbytes;
		} ipc;
		struct {
			mqd_t mqdes;
			struct mq_attr mqstat;
		} mq_getsetattr;
		struct {
			mqd_t mqdes;
			int sigev_signo;
		} mq_notify;
		struct {
			mqd_t mqdes;
			size_t msg_len;
			unsigned int msg_prio;
			struct timespec64 abs_timeout;
		} mq_sendrecv;
		struct {
			int oflag;
			umode_t mode;
			struct mq_attr attr;
		} mq_open;
		struct {
			pid_t pid;
			struct audit_cap_data cap;
		} capset;
		struct {
			int fd;
			int flags;
		} mmap;
		struct {
			int argc;
		} execve;
		struct {
			char *name;
		} module;
	};
	int fds[2];
	struct audit_proctitle proctitle;
};

struct lsmcontext {
	char *context;
	u32 len;
	int slot;
};

enum audit_nlgrps {
	AUDIT_NLGRP_NONE = 0,
	AUDIT_NLGRP_READLOG = 1,
	__AUDIT_NLGRP_MAX = 2,
};

struct audit_status {
	__u32 mask;
	__u32 enabled;
	__u32 failure;
	__u32 pid;
	__u32 rate_limit;
	__u32 backlog_limit;
	__u32 lost;
	__u32 backlog;
	union {
		__u32 version;
		__u32 feature_bitmap;
	};
	__u32 backlog_wait_time;
	__u32 backlog_wait_time_actual;
};

struct audit_features {
	__u32 vers;
	__u32 mask;
	__u32 features;
	__u32 lock;
};

struct audit_tty_status {
	__u32 enabled;
	__u32 log_passwd;
};

struct audit_sig_info {
	uid_t uid;
	pid_t pid;
	char ctx[0];
};

struct net_generic {
	union {
		struct {
			unsigned int len;
			struct callback_head rcu;
		} s;
		void *ptr[0];
	};
};

struct scm_creds {
	u32 pid;
	kuid_t uid;
	kgid_t gid;
};

struct netlink_skb_parms {
	struct scm_creds creds;
	__u32 portid;
	__u32 dst_group;
	__u32 flags;
	struct sock *sk;
	bool nsid_is_set;
	int nsid;
};

struct netlink_kernel_cfg {
	unsigned int groups;
	unsigned int flags;
	void (*input)(struct sk_buff *);
	struct mutex *cb_mutex;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
};

struct audit_netlink_list {
	__u32 portid;
	struct net *net;
	struct sk_buff_head q;
};

struct audit_net {
	struct sock *sk;
};

struct auditd_connection {
	struct pid *pid;
	u32 portid;
	struct net *net;
	struct callback_head rcu;
};

struct audit_ctl_mutex {
	struct mutex lock;
	void *owner;
};

struct audit_buffer {
	struct sk_buff *skb;
	struct audit_context *ctx;
	gfp_t gfp_mask;
};

struct audit_reply {
	__u32 portid;
	struct net *net;
	struct sk_buff *skb;
};

enum {
	Audit_equal = 0,
	Audit_not_equal = 1,
	Audit_bitmask = 2,
	Audit_bittest = 3,
	Audit_lt = 4,
	Audit_gt = 5,
	Audit_le = 6,
	Audit_ge = 7,
	Audit_bad = 8,
};

struct audit_rule_data {
	__u32 flags;
	__u32 action;
	__u32 field_count;
	__u32 mask[64];
	__u32 fields[64];
	__u32 values[64];
	__u32 fieldflags[64];
	__u32 buflen;
	char buf[0];
};

struct audit_field;

struct audit_watch;

struct audit_tree;

struct audit_fsnotify_mark;

struct audit_krule {
	u32 pflags;
	u32 flags;
	u32 listnr;
	u32 action;
	u32 mask[64];
	u32 buflen;
	u32 field_count;
	char *filterkey;
	struct audit_field *fields;
	struct audit_field *arch_f;
	struct audit_field *inode_f;
	struct audit_watch *watch;
	struct audit_tree *tree;
	struct audit_fsnotify_mark *exe;
	struct list_head rlist;
	struct list_head list;
	u64 prio;
};

struct audit_field {
	u32 type;
	union {
		u32 val;
		kuid_t uid;
		kgid_t gid;
		struct {
			bool lsm_isset;
			char *lsm_str;
			void *lsm_rules[3];
		};
	};
	u32 op;
};

struct audit_entry {
	struct list_head list;
	struct callback_head rcu;
	struct audit_krule rule;
};

struct audit_buffer___2;

typedef int __kernel_key_t;

typedef __kernel_key_t key_t;

struct kern_ipc_perm {
	spinlock_t lock;
	bool deleted;
	int id;
	key_t key;
	kuid_t uid;
	kgid_t gid;
	kuid_t cuid;
	kgid_t cgid;
	umode_t mode;
	long unsigned int seq;
	void *security;
	struct rhash_head khtnode;
	struct callback_head rcu;
	refcount_t refcount;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct cpu_vfs_cap_data {
	__u32 magic_etc;
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	kuid_t rootid;
};

typedef struct fsnotify_mark_connector *fsnotify_connp_t;

struct fsnotify_mark_connector {
	spinlock_t lock;
	short unsigned int type;
	short unsigned int flags;
	__kernel_fsid_t fsid;
	union {
		fsnotify_connp_t *obj;
		struct fsnotify_mark_connector *destroy_next;
	};
	struct hlist_head list;
};

enum audit_nfcfgop {
	AUDIT_XT_OP_REGISTER = 0,
	AUDIT_XT_OP_REPLACE = 1,
	AUDIT_XT_OP_UNREGISTER = 2,
	AUDIT_NFT_OP_TABLE_REGISTER = 3,
	AUDIT_NFT_OP_TABLE_UNREGISTER = 4,
	AUDIT_NFT_OP_CHAIN_REGISTER = 5,
	AUDIT_NFT_OP_CHAIN_UNREGISTER = 6,
	AUDIT_NFT_OP_RULE_REGISTER = 7,
	AUDIT_NFT_OP_RULE_UNREGISTER = 8,
	AUDIT_NFT_OP_SET_REGISTER = 9,
	AUDIT_NFT_OP_SET_UNREGISTER = 10,
	AUDIT_NFT_OP_SETELEM_REGISTER = 11,
	AUDIT_NFT_OP_SETELEM_UNREGISTER = 12,
	AUDIT_NFT_OP_GEN_REGISTER = 13,
	AUDIT_NFT_OP_OBJ_REGISTER = 14,
	AUDIT_NFT_OP_OBJ_UNREGISTER = 15,
	AUDIT_NFT_OP_OBJ_RESET = 16,
	AUDIT_NFT_OP_FLOWTABLE_REGISTER = 17,
	AUDIT_NFT_OP_FLOWTABLE_UNREGISTER = 18,
	AUDIT_NFT_OP_INVALID = 19,
};

enum fsnotify_obj_type {
	FSNOTIFY_OBJ_TYPE_INODE = 0,
	FSNOTIFY_OBJ_TYPE_PARENT = 1,
	FSNOTIFY_OBJ_TYPE_VFSMOUNT = 2,
	FSNOTIFY_OBJ_TYPE_SB = 3,
	FSNOTIFY_OBJ_TYPE_COUNT = 4,
	FSNOTIFY_OBJ_TYPE_DETACHED = 4,
};

struct audit_aux_data {
	struct audit_aux_data *next;
	int type;
};

struct audit_chunk;

struct audit_tree_refs {
	struct audit_tree_refs *next;
	struct audit_chunk *c[31];
};

struct audit_aux_data_pids {
	struct audit_aux_data d;
	pid_t target_pid[16];
	kuid_t target_auid[16];
	kuid_t target_uid[16];
	unsigned int target_sessionid[16];
	struct lsmblob target_lsm[16];
	char target_comm[256];
	int pid_count;
};

struct audit_aux_data_bprm_fcaps {
	struct audit_aux_data d;
	struct audit_cap_data fcap;
	unsigned int fcap_ver;
	struct audit_cap_data old_pcap;
	struct audit_cap_data new_pcap;
};

struct audit_nfcfgop_tab {
	enum audit_nfcfgop op;
	const char *s;
};

struct audit_parent;

struct audit_watch {
	refcount_t count;
	dev_t dev;
	char *path;
	long unsigned int ino;
	struct audit_parent *parent;
	struct list_head wlist;
	struct list_head rules;
};

struct fsnotify_group;

struct fsnotify_iter_info;

struct fsnotify_mark;

struct fsnotify_event;

struct fsnotify_ops {
	int (*handle_event)(struct fsnotify_group *, u32, const void *, int, struct inode *, const struct qstr *, u32, struct fsnotify_iter_info *);
	int (*handle_inode_event)(struct fsnotify_mark *, u32, struct inode *, struct inode *, const struct qstr *, u32);
	void (*free_group_priv)(struct fsnotify_group *);
	void (*freeing_mark)(struct fsnotify_mark *, struct fsnotify_group *);
	void (*free_event)(struct fsnotify_event *);
	void (*free_mark)(struct fsnotify_mark *);
};

struct inotify_group_private_data {
	spinlock_t idr_lock;
	struct idr idr;
	struct ucounts *ucounts;
};

struct fanotify_group_private_data {
	struct hlist_head *merge_hash;
	struct list_head access_list;
	wait_queue_head_t access_waitq;
	int flags;
	int f_flags;
	struct ucounts *ucounts;
};

struct fsnotify_group {
	const struct fsnotify_ops *ops;
	refcount_t refcnt;
	spinlock_t notification_lock;
	struct list_head notification_list;
	wait_queue_head_t notification_waitq;
	unsigned int q_len;
	unsigned int max_events;
	unsigned int priority;
	bool shutdown;
	struct mutex mark_mutex;
	atomic_t user_waits;
	struct list_head marks_list;
	struct fasync_struct *fsn_fa;
	struct fsnotify_event *overflow_event;
	struct mem_cgroup *memcg;
	union {
		void *private;
		struct inotify_group_private_data inotify_data;
		struct fanotify_group_private_data fanotify_data;
	};
};

struct fsnotify_iter_info {
	struct fsnotify_mark *marks[4];
	unsigned int report_mask;
	int srcu_idx;
};

struct fsnotify_mark {
	__u32 mask;
	refcount_t refcnt;
	struct fsnotify_group *group;
	struct list_head g_list;
	spinlock_t lock;
	struct hlist_node obj_list;
	struct fsnotify_mark_connector *connector;
	__u32 ignored_mask;
	unsigned int flags;
};

struct fsnotify_event {
	struct list_head list;
};

struct audit_parent {
	struct list_head watches;
	struct fsnotify_mark mark;
};

struct audit_fsnotify_mark {
	dev_t dev;
	long unsigned int ino;
	char *path;
	struct fsnotify_mark mark;
	struct audit_krule *rule;
};

struct audit_chunk___2;

struct audit_tree {
	refcount_t count;
	int goner;
	struct audit_chunk___2 *root;
	struct list_head chunks;
	struct list_head rules;
	struct list_head list;
	struct list_head same_root;
	struct callback_head head;
	char pathname[0];
};

struct node___2 {
	struct list_head list;
	struct audit_tree *owner;
	unsigned int index;
};

struct audit_chunk___2 {
	struct list_head hash;
	long unsigned int key;
	struct fsnotify_mark *mark;
	struct list_head trees;
	int count;
	atomic_long_t refs;
	struct callback_head head;
	struct node___2 owners[0];
};

struct audit_tree_mark {
	struct fsnotify_mark mark;
	struct audit_chunk___2 *chunk;
};

enum {
	HASH_SIZE = 128,
};

struct kprobe_blacklist_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
};

enum perf_record_ksymbol_type {
	PERF_RECORD_KSYMBOL_TYPE_UNKNOWN = 0,
	PERF_RECORD_KSYMBOL_TYPE_BPF = 1,
	PERF_RECORD_KSYMBOL_TYPE_OOL = 2,
	PERF_RECORD_KSYMBOL_TYPE_MAX = 3,
};

struct kprobe_insn_page {
	struct list_head list;
	kprobe_opcode_t *insns;
	struct kprobe_insn_cache *cache;
	int nused;
	int ngarbage;
	char slot_used[0];
};

enum kprobe_slot_state {
	SLOT_CLEAN = 0,
	SLOT_DIRTY = 1,
	SLOT_USED = 2,
};

enum {
	KDB_NOT_INITIALIZED = 0,
	KDB_INIT_EARLY = 1,
	KDB_INIT_FULL = 2,
};

struct kgdb_state {
	int ex_vector;
	int signo;
	int err_code;
	int cpu;
	int pass_exception;
	long unsigned int thr_query;
	long unsigned int threadid;
	long int kgdb_usethreadid;
	struct pt_regs *linux_regs;
	atomic_t *send_ready;
};

struct debuggerinfo_struct {
	void *debuggerinfo;
	struct task_struct *task;
	int exception_state;
	int ret_state;
	int irq_depth;
	int enter_kgdb;
	bool rounding_up;
};

struct _kdb_bp {
	long unsigned int bp_addr;
	unsigned int bp_free: 1;
	unsigned int bp_enabled: 1;
	unsigned int bp_type: 4;
	unsigned int bp_installed: 1;
	unsigned int bp_delay: 1;
	unsigned int bp_delayed: 1;
	unsigned int bph_length;
};

typedef struct _kdb_bp kdb_bp_t;

typedef enum {
	KDB_ENABLE_ALL = 1,
	KDB_ENABLE_MEM_READ = 2,
	KDB_ENABLE_MEM_WRITE = 4,
	KDB_ENABLE_REG_READ = 8,
	KDB_ENABLE_REG_WRITE = 16,
	KDB_ENABLE_INSPECT = 32,
	KDB_ENABLE_FLOW_CTRL = 64,
	KDB_ENABLE_SIGNAL = 128,
	KDB_ENABLE_REBOOT = 256,
	KDB_ENABLE_ALWAYS_SAFE = 512,
	KDB_ENABLE_MASK = 1023,
	KDB_ENABLE_ALL_NO_ARGS = 1024,
	KDB_ENABLE_MEM_READ_NO_ARGS = 2048,
	KDB_ENABLE_MEM_WRITE_NO_ARGS = 4096,
	KDB_ENABLE_REG_READ_NO_ARGS = 8192,
	KDB_ENABLE_REG_WRITE_NO_ARGS = 16384,
	KDB_ENABLE_INSPECT_NO_ARGS = 32768,
	KDB_ENABLE_FLOW_CTRL_NO_ARGS = 65536,
	KDB_ENABLE_SIGNAL_NO_ARGS = 131072,
	KDB_ENABLE_REBOOT_NO_ARGS = 262144,
	KDB_ENABLE_ALWAYS_SAFE_NO_ARGS = 524288,
	KDB_ENABLE_MASK_NO_ARGS = 1047552,
	KDB_REPEAT_NO_ARGS = 1073741824,
	KDB_REPEAT_WITH_ARGS = 2147483648,
} kdb_cmdflags_t;

typedef int (*kdb_func_t)(int, const char **);

typedef enum {
	KDB_REASON_ENTER = 1,
	KDB_REASON_ENTER_SLAVE = 2,
	KDB_REASON_BREAK = 3,
	KDB_REASON_DEBUG = 4,
	KDB_REASON_OOPS = 5,
	KDB_REASON_SWITCH = 6,
	KDB_REASON_KEYBOARD = 7,
	KDB_REASON_NMI = 8,
	KDB_REASON_RECURSE = 9,
	KDB_REASON_SSTEP = 10,
	KDB_REASON_SYSTEM_NMI = 11,
} kdb_reason_t;

struct __ksymtab {
	long unsigned int value;
	const char *mod_name;
	long unsigned int mod_start;
	long unsigned int mod_end;
	const char *sec_name;
	long unsigned int sec_start;
	long unsigned int sec_end;
	const char *sym_name;
	long unsigned int sym_start;
	long unsigned int sym_end;
};

typedef struct __ksymtab kdb_symtab_t;

struct _kdbtab {
	char *cmd_name;
	kdb_func_t cmd_func;
	char *cmd_usage;
	char *cmd_help;
	short int cmd_minlen;
	kdb_cmdflags_t cmd_flags;
	struct list_head list_node;
	bool is_dynamic;
};

typedef struct _kdbtab kdbtab_t;

typedef enum {
	KDB_DB_BPT = 0,
	KDB_DB_SS = 1,
	KDB_DB_SSBPT = 2,
	KDB_DB_NOBPT = 3,
} kdb_dbtrap_t;

struct _kdbmsg {
	int km_diag;
	char *km_msg;
};

typedef struct _kdbmsg kdbmsg_t;

struct defcmd_set {
	int count;
	bool usable;
	char *name;
	char *usage;
	char *help;
	char **command;
};

struct debug_alloc_header {
	u32 next;
	u32 size;
	void *caller;
};

typedef short unsigned int u_short;

struct seccomp_data {
	int nr;
	__u32 arch;
	__u64 instruction_pointer;
	__u64 args[6];
};

struct seccomp_notif_sizes {
	__u16 seccomp_notif;
	__u16 seccomp_notif_resp;
	__u16 seccomp_data;
};

struct seccomp_notif {
	__u64 id;
	__u32 pid;
	__u32 flags;
	struct seccomp_data data;
};

struct seccomp_notif_resp {
	__u64 id;
	__s64 val;
	__s32 error;
	__u32 flags;
};

struct seccomp_notif_addfd {
	__u64 id;
	__u32 flags;
	__u32 srcfd;
	__u32 newfd;
	__u32 newfd_flags;
};

struct action_cache {
	long unsigned int allow_native[7];
	long unsigned int allow_compat[7];
};

struct notification;

struct seccomp_filter {
	refcount_t refs;
	refcount_t users;
	bool log;
	struct action_cache cache;
	struct seccomp_filter *prev;
	struct bpf_prog *prog;
	struct notification *notif;
	struct mutex notify_lock;
	wait_queue_head_t wqh;
};

struct seccomp_metadata {
	__u64 filter_off;
	__u64 flags;
};

struct sock_fprog {
	short unsigned int len;
	struct sock_filter *filter;
};

struct compat_sock_fprog {
	u16 len;
	compat_uptr_t filter;
};

enum notify_state {
	SECCOMP_NOTIFY_INIT = 0,
	SECCOMP_NOTIFY_SENT = 1,
	SECCOMP_NOTIFY_REPLIED = 2,
};

struct seccomp_knotif {
	struct task_struct *task;
	u64 id;
	const struct seccomp_data *data;
	enum notify_state state;
	int error;
	long int val;
	u32 flags;
	struct completion ready;
	struct list_head list;
	struct list_head addfd;
};

struct seccomp_kaddfd {
	struct file *file;
	int fd;
	unsigned int flags;
	__u32 ioctl_flags;
	union {
		bool setfd;
		int ret;
	};
	struct completion completion;
	struct list_head list;
};

struct notification {
	struct semaphore request;
	u64 next_id;
	struct list_head notifications;
};

struct seccomp_log_name {
	u32 log;
	const char *name;
};

struct rchan;

struct rchan_buf {
	void *start;
	void *data;
	size_t offset;
	size_t subbufs_produced;
	size_t subbufs_consumed;
	struct rchan *chan;
	wait_queue_head_t read_wait;
	struct irq_work wakeup_work;
	struct dentry *dentry;
	struct kref kref;
	struct page **page_array;
	unsigned int page_count;
	unsigned int finalized;
	size_t *padding;
	size_t prev_padding;
	size_t bytes_consumed;
	size_t early_bytes;
	unsigned int cpu;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
};

struct rchan_callbacks;

struct rchan {
	u32 version;
	size_t subbuf_size;
	size_t n_subbufs;
	size_t alloc_size;
	const struct rchan_callbacks *cb;
	struct kref kref;
	void *private_data;
	size_t last_toobig;
	struct rchan_buf **buf;
	int is_global;
	struct list_head list;
	struct dentry *parent;
	int has_base_filename;
	char base_filename[255];
};

struct rchan_callbacks {
	int (*subbuf_start)(struct rchan_buf *, void *, void *, size_t);
	struct dentry * (*create_buf_file)(const char *, struct dentry *, umode_t, struct rchan_buf *, int *);
	int (*remove_buf_file)(struct dentry *);
};

struct partial_page {
	unsigned int offset;
	unsigned int len;
	long unsigned int private;
};

struct splice_pipe_desc {
	struct page **pages;
	struct partial_page *partial;
	int nr_pages;
	unsigned int nr_pages_max;
	const struct pipe_buf_operations *ops;
	void (*spd_release)(struct splice_pipe_desc *, unsigned int);
};

struct rchan_percpu_buf_dispatcher {
	struct rchan_buf *buf;
	struct dentry *dentry;
};

enum {
	TASKSTATS_TYPE_UNSPEC = 0,
	TASKSTATS_TYPE_PID = 1,
	TASKSTATS_TYPE_TGID = 2,
	TASKSTATS_TYPE_STATS = 3,
	TASKSTATS_TYPE_AGGR_PID = 4,
	TASKSTATS_TYPE_AGGR_TGID = 5,
	TASKSTATS_TYPE_NULL = 6,
	__TASKSTATS_TYPE_MAX = 7,
};

enum {
	TASKSTATS_CMD_ATTR_UNSPEC = 0,
	TASKSTATS_CMD_ATTR_PID = 1,
	TASKSTATS_CMD_ATTR_TGID = 2,
	TASKSTATS_CMD_ATTR_REGISTER_CPUMASK = 3,
	TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 4,
	__TASKSTATS_CMD_ATTR_MAX = 5,
};

enum {
	CGROUPSTATS_CMD_UNSPEC = 3,
	CGROUPSTATS_CMD_GET = 4,
	CGROUPSTATS_CMD_NEW = 5,
	__CGROUPSTATS_CMD_MAX = 6,
};

enum {
	CGROUPSTATS_TYPE_UNSPEC = 0,
	CGROUPSTATS_TYPE_CGROUP_STATS = 1,
	__CGROUPSTATS_TYPE_MAX = 2,
};

enum {
	CGROUPSTATS_CMD_ATTR_UNSPEC = 0,
	CGROUPSTATS_CMD_ATTR_FD = 1,
	__CGROUPSTATS_CMD_ATTR_MAX = 2,
};

struct genlmsghdr {
	__u8 cmd;
	__u8 version;
	__u16 reserved;
};

enum {
	NLA_UNSPEC = 0,
	NLA_U8 = 1,
	NLA_U16 = 2,
	NLA_U32 = 3,
	NLA_U64 = 4,
	NLA_STRING = 5,
	NLA_FLAG = 6,
	NLA_MSECS = 7,
	NLA_NESTED = 8,
	NLA_NESTED_ARRAY = 9,
	NLA_NUL_STRING = 10,
	NLA_BINARY = 11,
	NLA_S8 = 12,
	NLA_S16 = 13,
	NLA_S32 = 14,
	NLA_S64 = 15,
	NLA_BITFIELD32 = 16,
	NLA_REJECT = 17,
	__NLA_TYPE_MAX = 18,
};

struct genl_multicast_group {
	char name[16];
	u8 flags;
};

struct genl_ops;

struct genl_info;

struct genl_small_ops;

struct genl_family {
	int id;
	unsigned int hdrsize;
	char name[16];
	unsigned int version;
	unsigned int maxattr;
	unsigned int mcgrp_offset;
	u8 netnsok: 1;
	u8 parallel_ops: 1;
	u8 n_ops;
	u8 n_small_ops;
	u8 n_mcgrps;
	const struct nla_policy *policy;
	int (*pre_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	void (*post_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	const struct genl_ops *ops;
	const struct genl_small_ops *small_ops;
	const struct genl_multicast_group *mcgrps;
	struct module *module;
};

struct genl_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*start)(struct netlink_callback *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_info {
	u32 snd_seq;
	u32 snd_portid;
	struct nlmsghdr *nlhdr;
	struct genlmsghdr *genlhdr;
	void *userhdr;
	struct nlattr **attrs;
	possible_net_t _net;
	void *user_ptr[2];
	struct netlink_ext_ack *extack;
};

struct genl_small_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

enum genl_validate_flags {
	GENL_DONT_VALIDATE_STRICT = 1,
	GENL_DONT_VALIDATE_DUMP = 2,
	GENL_DONT_VALIDATE_DUMP_STRICT = 4,
};

struct listener {
	struct list_head list;
	pid_t pid;
	char valid;
};

struct listener_list {
	struct rw_semaphore sem;
	struct list_head list;
};

enum actions {
	REGISTER = 0,
	DEREGISTER = 1,
	CPU_DONT_CARE = 2,
};

struct tp_module {
	struct list_head list;
	struct module *mod;
};

enum tp_func_state {
	TP_FUNC_0 = 0,
	TP_FUNC_1 = 1,
	TP_FUNC_2 = 2,
	TP_FUNC_N = 3,
};

enum tp_transition_sync {
	TP_TRANSITION_SYNC_1_0_1 = 0,
	TP_TRANSITION_SYNC_N_2_1 = 1,
	_NR_TP_TRANSITION_SYNC = 2,
};

struct tp_transition_snapshot {
	long unsigned int rcu;
	long unsigned int srcu;
	bool ongoing;
};

struct tp_probes {
	struct callback_head rcu;
	struct tracepoint_func probes[0];
};

typedef int (*cmp_func_t)(const void *, const void *);

enum {
	TRACE_FTRACE_BIT = 0,
	TRACE_FTRACE_NMI_BIT = 1,
	TRACE_FTRACE_IRQ_BIT = 2,
	TRACE_FTRACE_SIRQ_BIT = 3,
	TRACE_FTRACE_TRANSITION_BIT = 4,
	TRACE_INTERNAL_BIT = 5,
	TRACE_INTERNAL_NMI_BIT = 6,
	TRACE_INTERNAL_IRQ_BIT = 7,
	TRACE_INTERNAL_SIRQ_BIT = 8,
	TRACE_INTERNAL_TRANSITION_BIT = 9,
	TRACE_BRANCH_BIT = 10,
	TRACE_IRQ_BIT = 11,
	TRACE_GRAPH_BIT = 12,
	TRACE_GRAPH_DEPTH_START_BIT = 13,
	TRACE_GRAPH_DEPTH_END_BIT = 14,
	TRACE_GRAPH_NOTRACE_BIT = 15,
	TRACE_RECORD_RECURSION_BIT = 16,
};

enum {
	TRACE_CTX_NMI = 0,
	TRACE_CTX_IRQ = 1,
	TRACE_CTX_SOFTIRQ = 2,
	TRACE_CTX_NORMAL = 3,
	TRACE_CTX_TRANSITION = 4,
};

enum {
	FTRACE_OPS_FL_ENABLED = 1,
	FTRACE_OPS_FL_DYNAMIC = 2,
	FTRACE_OPS_FL_SAVE_REGS = 4,
	FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED = 8,
	FTRACE_OPS_FL_RECURSION = 16,
	FTRACE_OPS_FL_STUB = 32,
	FTRACE_OPS_FL_INITIALIZED = 64,
	FTRACE_OPS_FL_DELETED = 128,
	FTRACE_OPS_FL_ADDING = 256,
	FTRACE_OPS_FL_REMOVING = 512,
	FTRACE_OPS_FL_MODIFYING = 1024,
	FTRACE_OPS_FL_ALLOC_TRAMP = 2048,
	FTRACE_OPS_FL_IPMODIFY = 4096,
	FTRACE_OPS_FL_PID = 8192,
	FTRACE_OPS_FL_RCU = 16384,
	FTRACE_OPS_FL_TRACE_ARRAY = 32768,
	FTRACE_OPS_FL_PERMANENT = 65536,
	FTRACE_OPS_FL_DIRECT = 131072,
};

struct ftrace_hash {
	long unsigned int size_bits;
	struct hlist_head *buckets;
	long unsigned int count;
	long unsigned int flags;
	struct callback_head rcu;
};

struct ftrace_func_entry {
	struct hlist_node hlist;
	long unsigned int ip;
	long unsigned int direct;
};

enum {
	FTRACE_FL_ENABLED = 2147483648,
	FTRACE_FL_REGS = 1073741824,
	FTRACE_FL_REGS_EN = 536870912,
	FTRACE_FL_TRAMP = 268435456,
	FTRACE_FL_TRAMP_EN = 134217728,
	FTRACE_FL_IPMODIFY = 67108864,
	FTRACE_FL_DISABLED = 33554432,
	FTRACE_FL_DIRECT = 16777216,
	FTRACE_FL_DIRECT_EN = 8388608,
};

enum {
	FTRACE_UPDATE_IGNORE = 0,
	FTRACE_UPDATE_MAKE_CALL = 1,
	FTRACE_UPDATE_MODIFY_CALL = 2,
	FTRACE_UPDATE_MAKE_NOP = 3,
};

enum {
	FTRACE_ITER_FILTER = 1,
	FTRACE_ITER_NOTRACE = 2,
	FTRACE_ITER_PRINTALL = 4,
	FTRACE_ITER_DO_PROBES = 8,
	FTRACE_ITER_PROBE = 16,
	FTRACE_ITER_MOD = 32,
	FTRACE_ITER_ENABLED = 64,
};

struct fgraph_ops {
	trace_func_graph_ent_t entryfunc;
	trace_func_graph_ret_t retfunc;
};

struct prog_entry;

struct event_filter {
	struct prog_entry *prog;
	char *filter_string;
};

struct trace_array_cpu;

struct array_buffer {
	struct trace_array *tr;
	struct trace_buffer *buffer;
	struct trace_array_cpu *data;
	u64 time_start;
	int cpu;
};

struct trace_pid_list;

struct trace_options;

struct cond_snapshot;

struct trace_func_repeats;

struct trace_array {
	struct list_head list;
	char *name;
	struct array_buffer array_buffer;
	struct array_buffer max_buffer;
	bool allocated_snapshot;
	long unsigned int max_latency;
	struct dentry *d_max_latency;
	struct work_struct fsnotify_work;
	struct irq_work fsnotify_irqwork;
	struct trace_pid_list *filtered_pids;
	struct trace_pid_list *filtered_no_pids;
	arch_spinlock_t max_lock;
	int buffer_disabled;
	int sys_refcount_enter;
	int sys_refcount_exit;
	struct trace_event_file *enter_syscall_files[447];
	struct trace_event_file *exit_syscall_files[447];
	int stop_count;
	int clock_id;
	int nr_topts;
	bool clear_trace;
	int buffer_percent;
	unsigned int n_err_log_entries;
	struct tracer *current_trace;
	unsigned int trace_flags;
	unsigned char trace_flags_index[32];
	unsigned int flags;
	raw_spinlock_t start_lock;
	struct list_head err_log;
	struct dentry *dir;
	struct dentry *options;
	struct dentry *percpu_dir;
	struct dentry *event_dir;
	struct trace_options *topts;
	struct list_head systems;
	struct list_head events;
	struct trace_event_file *trace_marker_file;
	cpumask_var_t tracing_cpumask;
	int ref;
	int trace_ref;
	struct ftrace_ops *ops;
	struct trace_pid_list *function_pids;
	struct trace_pid_list *function_no_pids;
	struct list_head func_probes;
	struct list_head mod_trace;
	struct list_head mod_notrace;
	int function_enabled;
	int no_filter_buffering_ref;
	struct list_head hist_vars;
	struct cond_snapshot *cond_snapshot;
	struct trace_func_repeats *last_func_repeats;
};

struct tracer_flags;

struct tracer {
	const char *name;
	int (*init)(struct trace_array *);
	void (*reset)(struct trace_array *);
	void (*start)(struct trace_array *);
	void (*stop)(struct trace_array *);
	int (*update_thresh)(struct trace_array *);
	void (*open)(struct trace_iterator *);
	void (*pipe_open)(struct trace_iterator *);
	void (*close)(struct trace_iterator *);
	void (*pipe_close)(struct trace_iterator *);
	ssize_t (*read)(struct trace_iterator *, struct file *, char *, size_t, loff_t *);
	ssize_t (*splice_read)(struct trace_iterator *, struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*print_header)(struct seq_file *);
	enum print_line_t (*print_line)(struct trace_iterator *);
	int (*set_flag)(struct trace_array *, u32, u32, int);
	int (*flag_changed)(struct trace_array *, u32, int);
	struct tracer *next;
	struct tracer_flags *flags;
	int enabled;
	bool print_max;
	bool allow_instances;
	bool use_max_tr;
	bool noboot;
};

struct event_subsystem;

struct trace_subsystem_dir {
	struct list_head list;
	struct event_subsystem *subsystem;
	struct trace_array *tr;
	struct dentry *entry;
	int ref_count;
	int nr_events;
};

struct trace_array_cpu {
	atomic_t disabled;
	void *buffer_page;
	long unsigned int entries;
	long unsigned int saved_latency;
	long unsigned int critical_start;
	long unsigned int critical_end;
	long unsigned int critical_sequence;
	long unsigned int nice;
	long unsigned int policy;
	long unsigned int rt_priority;
	long unsigned int skipped_entries;
	u64 preempt_timestamp;
	pid_t pid;
	kuid_t uid;
	char comm[16];
	int ftrace_ignore_pid;
	bool ignore_pid;
};

struct trace_option_dentry;

struct trace_options {
	struct tracer *tracer;
	struct trace_option_dentry *topts;
};

struct tracer_opt;

struct trace_option_dentry {
	struct tracer_opt *opt;
	struct tracer_flags *flags;
	struct trace_array *tr;
	struct dentry *entry;
};

struct trace_pid_list {
	int pid_max;
	long unsigned int *pids;
};

enum {
	TRACE_PIDS = 1,
	TRACE_NO_PIDS = 2,
};

typedef bool (*cond_update_fn_t)(struct trace_array *, void *);

struct cond_snapshot {
	void *cond_data;
	cond_update_fn_t update;
};

struct trace_func_repeats {
	long unsigned int ip;
	long unsigned int parent_ip;
	long unsigned int count;
	u64 ts_last_call;
};

enum {
	TRACE_ARRAY_FL_GLOBAL = 1,
};

struct tracer_opt {
	const char *name;
	u32 bit;
};

struct tracer_flags {
	u32 val;
	struct tracer_opt *opts;
	struct tracer *trace;
};

struct ftrace_mod_load {
	struct list_head list;
	char *func;
	char *module;
	int enable;
};

enum {
	FTRACE_HASH_FL_MOD = 1,
};

struct ftrace_func_command {
	struct list_head list;
	char *name;
	int (*func)(struct trace_array *, struct ftrace_hash *, char *, char *, char *, int);
};

struct ftrace_probe_ops {
	void (*func)(long unsigned int, long unsigned int, struct trace_array *, struct ftrace_probe_ops *, void *);
	int (*init)(struct ftrace_probe_ops *, struct trace_array *, long unsigned int, void *, void **);
	void (*free)(struct ftrace_probe_ops *, struct trace_array *, long unsigned int, void *);
	int (*print)(struct seq_file *, long unsigned int, struct ftrace_probe_ops *, void *);
};

typedef int (*ftrace_mapper_func)(void *);

struct trace_parser {
	bool cont;
	char *buffer;
	unsigned int idx;
	unsigned int size;
};

enum trace_iterator_bits {
	TRACE_ITER_PRINT_PARENT_BIT = 0,
	TRACE_ITER_SYM_OFFSET_BIT = 1,
	TRACE_ITER_SYM_ADDR_BIT = 2,
	TRACE_ITER_VERBOSE_BIT = 3,
	TRACE_ITER_RAW_BIT = 4,
	TRACE_ITER_HEX_BIT = 5,
	TRACE_ITER_BIN_BIT = 6,
	TRACE_ITER_BLOCK_BIT = 7,
	TRACE_ITER_PRINTK_BIT = 8,
	TRACE_ITER_ANNOTATE_BIT = 9,
	TRACE_ITER_USERSTACKTRACE_BIT = 10,
	TRACE_ITER_SYM_USEROBJ_BIT = 11,
	TRACE_ITER_PRINTK_MSGONLY_BIT = 12,
	TRACE_ITER_CONTEXT_INFO_BIT = 13,
	TRACE_ITER_LATENCY_FMT_BIT = 14,
	TRACE_ITER_RECORD_CMD_BIT = 15,
	TRACE_ITER_RECORD_TGID_BIT = 16,
	TRACE_ITER_OVERWRITE_BIT = 17,
	TRACE_ITER_STOP_ON_FREE_BIT = 18,
	TRACE_ITER_IRQ_INFO_BIT = 19,
	TRACE_ITER_MARKERS_BIT = 20,
	TRACE_ITER_EVENT_FORK_BIT = 21,
	TRACE_ITER_PAUSE_ON_TRACE_BIT = 22,
	TRACE_ITER_HASH_PTR_BIT = 23,
	TRACE_ITER_FUNCTION_BIT = 24,
	TRACE_ITER_FUNC_FORK_BIT = 25,
	TRACE_ITER_DISPLAY_GRAPH_BIT = 26,
	TRACE_ITER_STACKTRACE_BIT = 27,
	TRACE_ITER_LAST_BIT = 28,
};

struct event_subsystem {
	struct list_head list;
	const char *name;
	struct event_filter *filter;
	int ref_count;
};

enum regex_type {
	MATCH_FULL = 0,
	MATCH_FRONT_ONLY = 1,
	MATCH_MIDDLE_ONLY = 2,
	MATCH_END_ONLY = 3,
	MATCH_GLOB = 4,
	MATCH_INDEX = 5,
};

struct tracer_stat {
	const char *name;
	void * (*stat_start)(struct tracer_stat *);
	void * (*stat_next)(void *, int);
	cmp_func_t stat_cmp;
	int (*stat_show)(struct seq_file *, void *);
	void (*stat_release)(void *);
	int (*stat_headers)(struct seq_file *);
};

enum {
	FTRACE_MODIFY_ENABLE_FL = 1,
	FTRACE_MODIFY_MAY_SLEEP_FL = 2,
};

struct ftrace_profile {
	struct hlist_node node;
	long unsigned int ip;
	long unsigned int counter;
	long long unsigned int time;
	long long unsigned int time_squared;
};

struct ftrace_profile_page {
	struct ftrace_profile_page *next;
	long unsigned int index;
	struct ftrace_profile records[0];
};

struct ftrace_profile_stat {
	atomic_t disabled;
	struct hlist_head *hash;
	struct ftrace_profile_page *pages;
	struct ftrace_profile_page *start;
	struct tracer_stat stat;
};

struct ftrace_func_probe {
	struct ftrace_probe_ops *probe_ops;
	struct ftrace_ops ops;
	struct trace_array *tr;
	struct list_head list;
	void *data;
	int ref;
};

struct ftrace_page {
	struct ftrace_page *next;
	struct dyn_ftrace *records;
	int index;
	int order;
};

struct ftrace_rec_iter {
	struct ftrace_page *pg;
	int index;
};

struct ftrace_iterator {
	loff_t pos;
	loff_t func_pos;
	loff_t mod_pos;
	struct ftrace_page *pg;
	struct dyn_ftrace *func;
	struct ftrace_func_probe *probe;
	struct ftrace_func_entry *probe_entry;
	struct trace_parser parser;
	struct ftrace_hash *hash;
	struct ftrace_ops *ops;
	struct trace_array *tr;
	struct list_head *mod_list;
	int pidx;
	int idx;
	unsigned int flags;
};

struct ftrace_glob {
	char *search;
	unsigned int len;
	int type;
};

struct ftrace_func_map {
	struct ftrace_func_entry entry;
	void *data;
};

struct ftrace_func_mapper {
	struct ftrace_hash hash;
};

enum graph_filter_type {
	GRAPH_FILTER_NOTRACE = 0,
	GRAPH_FILTER_FUNCTION = 1,
};

struct ftrace_graph_data {
	struct ftrace_hash *hash;
	struct ftrace_func_entry *entry;
	int idx;
	enum graph_filter_type type;
	struct ftrace_hash *new_hash;
	const struct seq_operations *seq_ops;
	struct trace_parser parser;
};

struct ftrace_mod_func {
	struct list_head list;
	char *name;
	long unsigned int ip;
	unsigned int size;
};

struct ftrace_mod_map {
	struct callback_head rcu;
	struct list_head list;
	struct module *mod;
	long unsigned int start_addr;
	long unsigned int end_addr;
	struct list_head funcs;
	unsigned int num_funcs;
};

struct ftrace_init_func {
	struct list_head list;
	long unsigned int ip;
};

enum ring_buffer_type {
	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,
	RINGBUF_TYPE_PADDING = 29,
	RINGBUF_TYPE_TIME_EXTEND = 30,
	RINGBUF_TYPE_TIME_STAMP = 31,
};

enum ring_buffer_flags {
	RB_FL_OVERWRITE = 1,
};

struct ring_buffer_per_cpu;

struct buffer_page;

struct ring_buffer_iter {
	struct ring_buffer_per_cpu *cpu_buffer;
	long unsigned int head;
	long unsigned int next_event;
	struct buffer_page *head_page;
	struct buffer_page *cache_reader_page;
	long unsigned int cache_read;
	u64 read_stamp;
	u64 page_stamp;
	struct ring_buffer_event *event;
	int missed_events;
};

struct rb_irq_work {
	struct irq_work work;
	wait_queue_head_t waiters;
	wait_queue_head_t full_waiters;
	bool waiters_pending;
	bool full_waiters_pending;
	bool wakeup_full;
};

struct trace_buffer___2 {
	unsigned int flags;
	int cpus;
	atomic_t record_disabled;
	cpumask_var_t cpumask;
	struct lock_class_key *reader_lock_key;
	struct mutex mutex;
	struct ring_buffer_per_cpu **buffers;
	struct hlist_node node;
	u64 (*clock)();
	struct rb_irq_work irq_work;
	bool time_stamp_abs;
};

enum {
	RB_LEN_TIME_EXTEND = 8,
	RB_LEN_TIME_STAMP = 8,
};

struct buffer_data_page {
	u64 time_stamp;
	local_t commit;
	unsigned char data[0];
};

struct buffer_page {
	struct list_head list;
	local_t write;
	unsigned int read;
	local_t entries;
	long unsigned int real_end;
	struct buffer_data_page *page;
};

struct rb_event_info {
	u64 ts;
	u64 delta;
	u64 before;
	u64 after;
	long unsigned int length;
	struct buffer_page *tail_page;
	int add_timestamp;
};

enum {
	RB_ADD_STAMP_NONE = 0,
	RB_ADD_STAMP_EXTEND = 2,
	RB_ADD_STAMP_ABSOLUTE = 4,
	RB_ADD_STAMP_FORCE = 8,
};

enum {
	RB_CTX_TRANSITION = 0,
	RB_CTX_NMI = 1,
	RB_CTX_IRQ = 2,
	RB_CTX_SOFTIRQ = 3,
	RB_CTX_NORMAL = 4,
	RB_CTX_MAX = 5,
};

struct rb_time_struct {
	local64_t time;
};

typedef struct rb_time_struct rb_time_t;

struct ring_buffer_per_cpu {
	int cpu;
	atomic_t record_disabled;
	atomic_t resize_disabled;
	struct trace_buffer___2 *buffer;
	raw_spinlock_t reader_lock;
	arch_spinlock_t lock;
	struct lock_class_key lock_key;
	struct buffer_data_page *free_page;
	long unsigned int nr_pages;
	unsigned int current_context;
	struct list_head *pages;
	struct buffer_page *head_page;
	struct buffer_page *tail_page;
	struct buffer_page *commit_page;
	struct buffer_page *reader_page;
	long unsigned int lost_events;
	long unsigned int last_overrun;
	long unsigned int nest;
	local_t entries_bytes;
	local_t entries;
	local_t overrun;
	local_t commit_overrun;
	local_t dropped_events;
	local_t committing;
	local_t commits;
	local_t pages_touched;
	local_t pages_read;
	long int last_pages_touch;
	size_t shortest_full;
	long unsigned int read;
	long unsigned int read_bytes;
	rb_time_t write_stamp;
	rb_time_t before_stamp;
	u64 event_stamp[5];
	u64 read_stamp;
	long int nr_pages_to_update;
	struct list_head new_pages;
	struct work_struct update_pages_work;
	struct completion update_done;
	struct rb_irq_work irq_work;
};

struct trace_export {
	struct trace_export *next;
	void (*write)(struct trace_export *, const void *, unsigned int);
	int flags;
};

enum fsnotify_data_type {
	FSNOTIFY_EVENT_NONE = 0,
	FSNOTIFY_EVENT_PATH = 1,
	FSNOTIFY_EVENT_INODE = 2,
};

enum trace_iter_flags {
	TRACE_FILE_LAT_FMT = 1,
	TRACE_FILE_ANNOTATE = 2,
	TRACE_FILE_TIME_IN_NS = 4,
};

enum trace_flag_type {
	TRACE_FLAG_IRQS_OFF = 1,
	TRACE_FLAG_IRQS_NOSUPPORT = 2,
	TRACE_FLAG_NEED_RESCHED = 4,
	TRACE_FLAG_HARDIRQ = 8,
	TRACE_FLAG_SOFTIRQ = 16,
	TRACE_FLAG_PREEMPT_RESCHED = 32,
	TRACE_FLAG_NMI = 64,
};

enum event_trigger_type {
	ETT_NONE = 0,
	ETT_TRACE_ONOFF = 1,
	ETT_SNAPSHOT = 2,
	ETT_STACKTRACE = 4,
	ETT_EVENT_ENABLE = 8,
	ETT_EVENT_HIST = 16,
	ETT_HIST_ENABLE = 32,
};

enum trace_type {
	__TRACE_FIRST_TYPE = 0,
	TRACE_FN = 1,
	TRACE_CTX = 2,
	TRACE_WAKE = 3,
	TRACE_STACK = 4,
	TRACE_PRINT = 5,
	TRACE_BPRINT = 6,
	TRACE_MMIO_RW = 7,
	TRACE_MMIO_MAP = 8,
	TRACE_BRANCH = 9,
	TRACE_GRAPH_RET = 10,
	TRACE_GRAPH_ENT = 11,
	TRACE_USER_STACK = 12,
	TRACE_BLK = 13,
	TRACE_BPUTS = 14,
	TRACE_HWLAT = 15,
	TRACE_RAW_DATA = 16,
	TRACE_FUNC_REPEATS = 17,
	__TRACE_LAST_TYPE = 18,
};

struct ftrace_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
};

struct stack_entry {
	struct trace_entry ent;
	int size;
	long unsigned int caller[8];
};

struct bprint_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *fmt;
	u32 buf[0];
};

struct print_entry {
	struct trace_entry ent;
	long unsigned int ip;
	char buf[0];
};

struct raw_data_entry {
	struct trace_entry ent;
	unsigned int id;
	char buf[0];
};

struct bputs_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *str;
};

struct func_repeats_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
	u16 count;
	u16 top_delta_ts;
	u32 bottom_delta_ts;
};

enum trace_iterator_flags {
	TRACE_ITER_PRINT_PARENT = 1,
	TRACE_ITER_SYM_OFFSET = 2,
	TRACE_ITER_SYM_ADDR = 4,
	TRACE_ITER_VERBOSE = 8,
	TRACE_ITER_RAW = 16,
	TRACE_ITER_HEX = 32,
	TRACE_ITER_BIN = 64,
	TRACE_ITER_BLOCK = 128,
	TRACE_ITER_PRINTK = 256,
	TRACE_ITER_ANNOTATE = 512,
	TRACE_ITER_USERSTACKTRACE = 1024,
	TRACE_ITER_SYM_USEROBJ = 2048,
	TRACE_ITER_PRINTK_MSGONLY = 4096,
	TRACE_ITER_CONTEXT_INFO = 8192,
	TRACE_ITER_LATENCY_FMT = 16384,
	TRACE_ITER_RECORD_CMD = 32768,
	TRACE_ITER_RECORD_TGID = 65536,
	TRACE_ITER_OVERWRITE = 131072,
	TRACE_ITER_STOP_ON_FREE = 262144,
	TRACE_ITER_IRQ_INFO = 524288,
	TRACE_ITER_MARKERS = 1048576,
	TRACE_ITER_EVENT_FORK = 2097152,
	TRACE_ITER_PAUSE_ON_TRACE = 4194304,
	TRACE_ITER_HASH_PTR = 8388608,
	TRACE_ITER_FUNCTION = 16777216,
	TRACE_ITER_FUNC_FORK = 33554432,
	TRACE_ITER_DISPLAY_GRAPH = 67108864,
	TRACE_ITER_STACKTRACE = 134217728,
};

struct saved_cmdlines_buffer {
	unsigned int map_pid_to_cmdline[32769];
	unsigned int *map_cmdline_to_pid;
	unsigned int cmdline_num;
	int cmdline_idx;
	char *saved_cmdlines;
};

struct ftrace_stack {
	long unsigned int calls[1024];
};

struct ftrace_stacks {
	struct ftrace_stack stacks[4];
};

struct trace_buffer_struct {
	int nesting;
	char buffer[4096];
};

struct ftrace_buffer_info {
	struct trace_iterator iter;
	void *spare;
	unsigned int spare_cpu;
	unsigned int read;
};

struct err_info {
	const char **errs;
	u8 type;
	u8 pos;
	u64 ts;
};

struct tracing_log_err {
	struct list_head list;
	struct err_info info;
	char loc[128];
	char cmd[256];
};

struct buffer_ref {
	struct trace_buffer *buffer;
	void *page;
	int cpu;
	refcount_t refcount;
};

struct ftrace_func_mapper___2;

struct ctx_switch_entry {
	struct trace_entry ent;
	unsigned int prev_pid;
	unsigned int next_pid;
	unsigned int next_cpu;
	unsigned char prev_prio;
	unsigned char prev_state;
	unsigned char next_prio;
	unsigned char next_state;
};

struct userstack_entry {
	struct trace_entry ent;
	unsigned int tgid;
	long unsigned int caller[8];
};

struct hwlat_entry {
	struct trace_entry ent;
	u64 duration;
	u64 outer_duration;
	u64 nmi_total_ts;
	struct timespec64 timestamp;
	unsigned int nmi_count;
	unsigned int seqnum;
	unsigned int count;
};

struct trace_mark {
	long long unsigned int val;
	char sym;
};

struct stat_node {
	struct rb_node node;
	void *stat;
};

struct stat_session {
	struct list_head session_list;
	struct tracer_stat *ts;
	struct rb_root stat_root;
	struct mutex stat_mutex;
	struct dentry *file;
};

struct trace_bprintk_fmt {
	struct list_head list;
	const char *fmt;
};

typedef int (*tracing_map_cmp_fn_t)(void *, void *);

struct tracing_map_field {
	tracing_map_cmp_fn_t cmp_fn;
	union {
		atomic64_t sum;
		unsigned int offset;
	};
};

struct tracing_map;

struct tracing_map_elt {
	struct tracing_map *map;
	struct tracing_map_field *fields;
	atomic64_t *vars;
	bool *var_set;
	void *key;
	void *private_data;
};

struct tracing_map_sort_key {
	unsigned int field_idx;
	bool descending;
};

struct tracing_map_array;

struct tracing_map_ops;

struct tracing_map {
	unsigned int key_size;
	unsigned int map_bits;
	unsigned int map_size;
	unsigned int max_elts;
	atomic_t next_elt;
	struct tracing_map_array *elts;
	struct tracing_map_array *map;
	const struct tracing_map_ops *ops;
	void *private_data;
	struct tracing_map_field fields[6];
	unsigned int n_fields;
	int key_idx[3];
	unsigned int n_keys;
	struct tracing_map_sort_key sort_key;
	unsigned int n_vars;
	atomic64_t hits;
	atomic64_t drops;
};

struct tracing_map_entry {
	u32 key;
	struct tracing_map_elt *val;
};

struct tracing_map_sort_entry {
	void *key;
	struct tracing_map_elt *elt;
	bool elt_copied;
	bool dup;
};

struct tracing_map_array {
	unsigned int entries_per_page;
	unsigned int entry_size_shift;
	unsigned int entry_shift;
	unsigned int entry_mask;
	unsigned int n_pages;
	void **pages;
};

struct tracing_map_ops {
	int (*elt_alloc)(struct tracing_map_elt *);
	void (*elt_free)(struct tracing_map_elt *);
	void (*elt_clear)(struct tracing_map_elt *);
	void (*elt_init)(struct tracing_map_elt *);
};

enum {
	TRACE_FUNC_NO_OPTS = 0,
	TRACE_FUNC_OPT_STACK = 1,
	TRACE_FUNC_OPT_NO_REPEATS = 2,
	TRACE_FUNC_OPT_HIGHEST_BIT = 4,
};

struct hwlat_sample {
	u64 seqnum;
	u64 duration;
	u64 outer_duration;
	u64 nmi_total_ts;
	struct timespec64 timestamp;
	int nmi_count;
	int count;
};

struct hwlat_data {
	struct mutex lock;
	u64 count;
	u64 sample_window;
	u64 sample_width;
};

enum {
	TRACE_NOP_OPT_ACCEPT = 1,
	TRACE_NOP_OPT_REFUSE = 2,
};

struct ftrace_graph_ent_entry {
	struct trace_entry ent;
	struct ftrace_graph_ent graph_ent;
} __attribute__((packed));

struct ftrace_graph_ret_entry {
	struct trace_entry ent;
	struct ftrace_graph_ret ret;
};

struct fgraph_cpu_data {
	pid_t last_pid;
	int depth;
	int depth_irq;
	int ignore;
	long unsigned int enter_funcs[50];
};

struct fgraph_data {
	struct fgraph_cpu_data *cpu_data;
	struct ftrace_graph_ent_entry ent;
	struct ftrace_graph_ret_entry ret;
	int failed;
	int cpu;
	int: 32;
} __attribute__((packed));

enum {
	FLAGS_FILL_FULL = 268435456,
	FLAGS_FILL_START = 536870912,
	FLAGS_FILL_END = 805306368,
};

struct disk_stats {
	u64 nsecs[4];
	long unsigned int sectors[4];
	long unsigned int ios[4];
	long unsigned int merges[4];
	long unsigned int io_ticks;
	local_t in_flight[2];
};

struct blk_crypto_key;

struct bio_crypt_ctx {
	const struct blk_crypto_key *bc_key;
	u64 bc_dun[4];
};

typedef __u32 blk_mq_req_flags_t;

enum req_opf {
	REQ_OP_READ = 0,
	REQ_OP_WRITE = 1,
	REQ_OP_FLUSH = 2,
	REQ_OP_DISCARD = 3,
	REQ_OP_SECURE_ERASE = 5,
	REQ_OP_WRITE_SAME = 7,
	REQ_OP_WRITE_ZEROES = 9,
	REQ_OP_ZONE_OPEN = 10,
	REQ_OP_ZONE_CLOSE = 11,
	REQ_OP_ZONE_FINISH = 12,
	REQ_OP_ZONE_APPEND = 13,
	REQ_OP_ZONE_RESET = 15,
	REQ_OP_ZONE_RESET_ALL = 17,
	REQ_OP_SCSI_IN = 32,
	REQ_OP_SCSI_OUT = 33,
	REQ_OP_DRV_IN = 34,
	REQ_OP_DRV_OUT = 35,
	REQ_OP_LAST = 36,
};

enum req_flag_bits {
	__REQ_FAILFAST_DEV = 8,
	__REQ_FAILFAST_TRANSPORT = 9,
	__REQ_FAILFAST_DRIVER = 10,
	__REQ_SYNC = 11,
	__REQ_META = 12,
	__REQ_PRIO = 13,
	__REQ_NOMERGE = 14,
	__REQ_IDLE = 15,
	__REQ_INTEGRITY = 16,
	__REQ_FUA = 17,
	__REQ_PREFLUSH = 18,
	__REQ_RAHEAD = 19,
	__REQ_BACKGROUND = 20,
	__REQ_NOWAIT = 21,
	__REQ_CGROUP_PUNT = 22,
	__REQ_NOUNMAP = 23,
	__REQ_HIPRI = 24,
	__REQ_DRV = 25,
	__REQ_SWAP = 26,
	__REQ_NR_BITS = 27,
};

struct blk_mq_ctxs;

struct blk_mq_ctx {
	struct {
		spinlock_t lock;
		struct list_head rq_lists[3];
		long: 64;
	};
	unsigned int cpu;
	short unsigned int index_hw[3];
	struct blk_mq_hw_ctx *hctxs[3];
	long unsigned int rq_dispatched[2];
	long unsigned int rq_merged;
	long unsigned int rq_completed[2];
	struct request_queue *queue;
	struct blk_mq_ctxs *ctxs;
	struct kobject kobj;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbitmap_word;

struct sbitmap {
	unsigned int depth;
	unsigned int shift;
	unsigned int map_nr;
	bool round_robin;
	struct sbitmap_word *map;
	unsigned int *alloc_hint;
};

struct blk_mq_tags;

struct blk_mq_hw_ctx {
	struct {
		spinlock_t lock;
		struct list_head dispatch;
		long unsigned int state;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct delayed_work run_work;
	cpumask_var_t cpumask;
	int next_cpu;
	int next_cpu_batch;
	long unsigned int flags;
	void *sched_data;
	struct request_queue *queue;
	struct blk_flush_queue *fq;
	void *driver_data;
	struct sbitmap ctx_map;
	struct blk_mq_ctx *dispatch_from;
	unsigned int dispatch_busy;
	short unsigned int type;
	short unsigned int nr_ctx;
	struct blk_mq_ctx **ctxs;
	spinlock_t dispatch_wait_lock;
	wait_queue_entry_t dispatch_wait;
	atomic_t wait_index;
	struct blk_mq_tags *tags;
	struct blk_mq_tags *sched_tags;
	long unsigned int queued;
	long unsigned int run;
	long unsigned int dispatched[7];
	unsigned int numa_node;
	unsigned int queue_num;
	atomic_t nr_active;
	struct hlist_node cpuhp_online;
	struct hlist_node cpuhp_dead;
	struct kobject kobj;
	long unsigned int poll_considered;
	long unsigned int poll_invoked;
	long unsigned int poll_success;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct list_head hctx_list;
	struct srcu_struct srcu[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blk_mq_alloc_data {
	struct request_queue *q;
	blk_mq_req_flags_t flags;
	unsigned int shallow_depth;
	unsigned int cmd_flags;
	struct blk_mq_ctx *ctx;
	struct blk_mq_hw_ctx *hctx;
};

struct blk_stat_callback {
	struct list_head list;
	struct timer_list timer;
	struct blk_rq_stat *cpu_stat;
	int (*bucket_fn)(const struct request *);
	unsigned int buckets;
	struct blk_rq_stat *stat;
	void (*timer_fn)(struct blk_stat_callback *);
	void *data;
	struct callback_head rcu;
};

struct blk_trace {
	int trace_state;
	struct rchan *rchan;
	long unsigned int *sequence;
	unsigned char *msg_data;
	u16 act_mask;
	u64 start_lba;
	u64 end_lba;
	u32 pid;
	u32 dev;
	struct dentry *dir;
	struct list_head running_list;
	atomic_t dropped;
};

struct blk_flush_queue {
	unsigned int flush_pending_idx: 1;
	unsigned int flush_running_idx: 1;
	blk_status_t rq_status;
	long unsigned int flush_pending_since;
	struct list_head flush_queue[2];
	struct list_head flush_data_in_flight;
	struct request *flush_rq;
	spinlock_t mq_flush_lock;
};

struct blk_mq_queue_map {
	unsigned int *mq_map;
	unsigned int nr_queues;
	unsigned int queue_offset;
};

struct sbq_wait_state;

struct sbitmap_queue {
	struct sbitmap sb;
	unsigned int wake_batch;
	atomic_t wake_index;
	struct sbq_wait_state *ws;
	atomic_t ws_active;
	unsigned int min_shallow_depth;
};

struct blk_mq_tag_set {
	struct blk_mq_queue_map map[3];
	unsigned int nr_maps;
	const struct blk_mq_ops *ops;
	unsigned int nr_hw_queues;
	unsigned int queue_depth;
	unsigned int reserved_tags;
	unsigned int cmd_size;
	int numa_node;
	unsigned int timeout;
	unsigned int flags;
	void *driver_data;
	atomic_t active_queues_shared_sbitmap;
	struct sbitmap_queue __bitmap_tags;
	struct sbitmap_queue __breserved_tags;
	struct blk_mq_tags **tags;
	struct mutex tag_list_lock;
	struct list_head tag_list;
};

enum blktrace_cat {
	BLK_TC_READ = 1,
	BLK_TC_WRITE = 2,
	BLK_TC_FLUSH = 4,
	BLK_TC_SYNC = 8,
	BLK_TC_SYNCIO = 8,
	BLK_TC_QUEUE = 16,
	BLK_TC_REQUEUE = 32,
	BLK_TC_ISSUE = 64,
	BLK_TC_COMPLETE = 128,
	BLK_TC_FS = 256,
	BLK_TC_PC = 512,
	BLK_TC_NOTIFY = 1024,
	BLK_TC_AHEAD = 2048,
	BLK_TC_META = 4096,
	BLK_TC_DISCARD = 8192,
	BLK_TC_DRV_DATA = 16384,
	BLK_TC_FUA = 32768,
	BLK_TC_END = 32768,
};

enum blktrace_act {
	__BLK_TA_QUEUE = 1,
	__BLK_TA_BACKMERGE = 2,
	__BLK_TA_FRONTMERGE = 3,
	__BLK_TA_GETRQ = 4,
	__BLK_TA_SLEEPRQ = 5,
	__BLK_TA_REQUEUE = 6,
	__BLK_TA_ISSUE = 7,
	__BLK_TA_COMPLETE = 8,
	__BLK_TA_PLUG = 9,
	__BLK_TA_UNPLUG_IO = 10,
	__BLK_TA_UNPLUG_TIMER = 11,
	__BLK_TA_INSERT = 12,
	__BLK_TA_SPLIT = 13,
	__BLK_TA_BOUNCE = 14,
	__BLK_TA_REMAP = 15,
	__BLK_TA_ABORT = 16,
	__BLK_TA_DRV_DATA = 17,
	__BLK_TA_CGROUP = 256,
};

enum blktrace_notify {
	__BLK_TN_PROCESS = 0,
	__BLK_TN_TIMESTAMP = 1,
	__BLK_TN_MESSAGE = 2,
	__BLK_TN_CGROUP = 256,
};

struct blk_io_trace {
	__u32 magic;
	__u32 sequence;
	__u64 time;
	__u64 sector;
	__u32 bytes;
	__u32 action;
	__u32 pid;
	__u32 device;
	__u32 cpu;
	__u16 error;
	__u16 pdu_len;
};

struct blk_io_trace_remap {
	__be32 device_from;
	__be32 device_to;
	__be64 sector_from;
};

enum {
	Blktrace_setup = 1,
	Blktrace_running = 2,
	Blktrace_stopped = 3,
};

struct blk_user_trace_setup {
	char name[32];
	__u16 act_mask;
	__u32 buf_size;
	__u32 buf_nr;
	__u64 start_lba;
	__u64 end_lba;
	__u32 pid;
};

struct sbitmap_word {
	long unsigned int depth;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int word;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int cleared;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbq_wait_state {
	atomic_t wait_cnt;
	wait_queue_head_t wait;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blk_mq_tags {
	unsigned int nr_tags;
	unsigned int nr_reserved_tags;
	atomic_t active_queues;
	struct sbitmap_queue *bitmap_tags;
	struct sbitmap_queue *breserved_tags;
	struct sbitmap_queue __bitmap_tags;
	struct sbitmap_queue __breserved_tags;
	struct request **rqs;
	struct request **static_rqs;
	struct list_head page_list;
	spinlock_t lock;
};

struct blk_mq_queue_data {
	struct request *rq;
	bool last;
};

enum blk_crypto_mode_num {
	BLK_ENCRYPTION_MODE_INVALID = 0,
	BLK_ENCRYPTION_MODE_AES_256_XTS = 1,
	BLK_ENCRYPTION_MODE_AES_128_CBC_ESSIV = 2,
	BLK_ENCRYPTION_MODE_ADIANTUM = 3,
	BLK_ENCRYPTION_MODE_MAX = 4,
};

struct blk_crypto_config {
	enum blk_crypto_mode_num crypto_mode;
	unsigned int data_unit_size;
	unsigned int dun_bytes;
};

struct blk_crypto_key {
	struct blk_crypto_config crypto_cfg;
	unsigned int data_unit_size_bits;
	unsigned int size;
	u8 raw[64];
};

struct blk_crypto_mode {
	const char *cipher_str;
	unsigned int keysize;
	unsigned int ivsize;
};

struct blk_mq_ctxs {
	struct kobject kobj;
	struct blk_mq_ctx *queue_ctx;
};

typedef void blk_log_action_t(struct trace_iterator *, const char *, bool);

struct ftrace_event_field {
	struct list_head link;
	const char *name;
	const char *type;
	int filter_type;
	int offset;
	int size;
	int is_signed;
};

enum {
	FORMAT_HEADER = 1,
	FORMAT_FIELD_SEPERATOR = 2,
	FORMAT_PRINTFMT = 3,
};

struct event_probe_data {
	struct trace_event_file *file;
	long unsigned int count;
	int ref;
	bool enable;
};

struct syscall_trace_enter {
	struct trace_entry ent;
	int nr;
	long unsigned int args[0];
};

struct syscall_trace_exit {
	struct trace_entry ent;
	int nr;
	long int ret;
};

struct syscall_tp_t {
	long long unsigned int regs;
	long unsigned int syscall_nr;
	long unsigned int ret;
};

struct syscall_tp_t___2 {
	long long unsigned int regs;
	long unsigned int syscall_nr;
	long unsigned int args[6];
};

enum perf_event_sample_format {
	PERF_SAMPLE_IP = 1,
	PERF_SAMPLE_TID = 2,
	PERF_SAMPLE_TIME = 4,
	PERF_SAMPLE_ADDR = 8,
	PERF_SAMPLE_READ = 16,
	PERF_SAMPLE_CALLCHAIN = 32,
	PERF_SAMPLE_ID = 64,
	PERF_SAMPLE_CPU = 128,
	PERF_SAMPLE_PERIOD = 256,
	PERF_SAMPLE_STREAM_ID = 512,
	PERF_SAMPLE_RAW = 1024,
	PERF_SAMPLE_BRANCH_STACK = 2048,
	PERF_SAMPLE_REGS_USER = 4096,
	PERF_SAMPLE_STACK_USER = 8192,
	PERF_SAMPLE_WEIGHT = 16384,
	PERF_SAMPLE_DATA_SRC = 32768,
	PERF_SAMPLE_IDENTIFIER = 65536,
	PERF_SAMPLE_TRANSACTION = 131072,
	PERF_SAMPLE_REGS_INTR = 262144,
	PERF_SAMPLE_PHYS_ADDR = 524288,
	PERF_SAMPLE_AUX = 1048576,
	PERF_SAMPLE_CGROUP = 2097152,
	PERF_SAMPLE_DATA_PAGE_SIZE = 4194304,
	PERF_SAMPLE_CODE_PAGE_SIZE = 8388608,
	PERF_SAMPLE_WEIGHT_STRUCT = 16777216,
	PERF_SAMPLE_MAX = 33554432,
	__PERF_SAMPLE_CALLCHAIN_EARLY = 0,
};

typedef long unsigned int perf_trace_t[256];

struct filter_pred;

struct prog_entry {
	int target;
	int when_to_branch;
	struct filter_pred *pred;
};

typedef int (*filter_pred_fn_t)(struct filter_pred *, void *);

struct regex;

typedef int (*regex_match_func)(char *, struct regex *, int);

struct regex {
	char pattern[256];
	int len;
	int field_len;
	regex_match_func match;
};

struct filter_pred {
	filter_pred_fn_t fn;
	u64 val;
	struct regex regex;
	short unsigned int *ops;
	struct ftrace_event_field *field;
	int offset;
	int not;
	int op;
};

enum filter_op_ids {
	OP_GLOB = 0,
	OP_NE = 1,
	OP_EQ = 2,
	OP_LE = 3,
	OP_LT = 4,
	OP_GE = 5,
	OP_GT = 6,
	OP_BAND = 7,
	OP_MAX = 8,
};

enum {
	FILT_ERR_NONE = 0,
	FILT_ERR_INVALID_OP = 1,
	FILT_ERR_TOO_MANY_OPEN = 2,
	FILT_ERR_TOO_MANY_CLOSE = 3,
	FILT_ERR_MISSING_QUOTE = 4,
	FILT_ERR_OPERAND_TOO_LONG = 5,
	FILT_ERR_EXPECT_STRING = 6,
	FILT_ERR_EXPECT_DIGIT = 7,
	FILT_ERR_ILLEGAL_FIELD_OP = 8,
	FILT_ERR_FIELD_NOT_FOUND = 9,
	FILT_ERR_ILLEGAL_INTVAL = 10,
	FILT_ERR_BAD_SUBSYS_FILTER = 11,
	FILT_ERR_TOO_MANY_PREDS = 12,
	FILT_ERR_INVALID_FILTER = 13,
	FILT_ERR_IP_FIELD_ONLY = 14,
	FILT_ERR_INVALID_VALUE = 15,
	FILT_ERR_ERRNO = 16,
	FILT_ERR_NO_FILTER = 17,
};

struct filter_parse_error {
	int lasterr;
	int lasterr_pos;
};

typedef int (*parse_pred_fn)(const char *, void *, int, struct filter_parse_error *, struct filter_pred **);

enum {
	INVERT = 1,
	PROCESS_AND = 2,
	PROCESS_OR = 4,
};

enum {
	TOO_MANY_CLOSE = 4294967295,
	TOO_MANY_OPEN = 4294967294,
	MISSING_QUOTE = 4294967293,
};

struct filter_list {
	struct list_head list;
	struct event_filter *filter;
};

struct function_filter_data {
	struct ftrace_ops *ops;
	int first_filter;
	int first_notrace;
};

struct event_trigger_ops;

struct event_command;

struct event_trigger_data {
	long unsigned int count;
	int ref;
	struct event_trigger_ops *ops;
	struct event_command *cmd_ops;
	struct event_filter *filter;
	char *filter_str;
	void *private_data;
	bool paused;
	bool paused_tmp;
	struct list_head list;
	char *name;
	struct list_head named_list;
	struct event_trigger_data *named_data;
};

struct event_trigger_ops {
	void (*func)(struct event_trigger_data *, struct trace_buffer *, void *, struct ring_buffer_event *);
	int (*init)(struct event_trigger_ops *, struct event_trigger_data *);
	void (*free)(struct event_trigger_ops *, struct event_trigger_data *);
	int (*print)(struct seq_file *, struct event_trigger_ops *, struct event_trigger_data *);
};

struct event_command {
	struct list_head list;
	char *name;
	enum event_trigger_type trigger_type;
	int flags;
	int (*func)(struct event_command *, struct trace_event_file *, char *, char *, char *);
	int (*reg)(char *, struct event_trigger_ops *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg)(char *, struct event_trigger_ops *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg_all)(struct trace_event_file *);
	int (*set_filter)(char *, struct event_trigger_data *, struct trace_event_file *);
	struct event_trigger_ops * (*get_trigger_ops)(char *, char *);
};

struct enable_trigger_data {
	struct trace_event_file *file;
	bool enable;
	bool hist;
};

enum event_command_flags {
	EVENT_CMD_FL_POST_TRIGGER = 1,
	EVENT_CMD_FL_NEEDS_REC = 2,
};

enum dynevent_type {
	DYNEVENT_TYPE_SYNTH = 1,
	DYNEVENT_TYPE_KPROBE = 2,
	DYNEVENT_TYPE_NONE = 3,
};

struct dynevent_cmd;

typedef int (*dynevent_create_fn_t)(struct dynevent_cmd *);

struct dynevent_cmd {
	struct seq_buf seq;
	const char *event_name;
	unsigned int n_fields;
	enum dynevent_type type;
	dynevent_create_fn_t run_command;
	void *private_data;
};

struct synth_field_desc {
	const char *type;
	const char *name;
};

struct synth_trace_event;

struct synth_event;

struct synth_event_trace_state {
	struct trace_event_buffer fbuffer;
	struct synth_trace_event *entry;
	struct trace_buffer *buffer;
	struct synth_event *event;
	unsigned int cur_field;
	unsigned int n_u64;
	bool disabled;
	bool add_next;
	bool add_name;
};

struct synth_trace_event {
	struct trace_entry ent;
	u64 fields[0];
};

struct dyn_event_operations;

struct dyn_event {
	struct list_head list;
	struct dyn_event_operations *ops;
};

struct synth_field;

struct synth_event {
	struct dyn_event devent;
	int ref;
	char *name;
	struct synth_field **fields;
	unsigned int n_fields;
	struct synth_field **dynamic_fields;
	unsigned int n_dynamic_fields;
	unsigned int n_u64;
	struct trace_event_class class;
	struct trace_event_call call;
	struct tracepoint *tp;
	struct module *mod;
};

struct dyn_event_operations {
	struct list_head list;
	int (*create)(const char *);
	int (*show)(struct seq_file *, struct dyn_event *);
	bool (*is_busy)(struct dyn_event *);
	int (*free)(struct dyn_event *);
	bool (*match)(const char *, const char *, int, const char **, struct dyn_event *);
};

struct dynevent_arg {
	const char *str;
	char separator;
};

struct dynevent_arg_pair {
	const char *lhs;
	const char *rhs;
	char operator;
	char separator;
};

struct synth_field {
	char *type;
	char *name;
	size_t size;
	unsigned int offset;
	unsigned int field_pos;
	bool is_signed;
	bool is_string;
	bool is_dynamic;
};

enum {
	SYNTH_ERR_BAD_NAME = 0,
	SYNTH_ERR_INVALID_CMD = 1,
	SYNTH_ERR_INVALID_DYN_CMD = 2,
	SYNTH_ERR_EVENT_EXISTS = 3,
	SYNTH_ERR_TOO_MANY_FIELDS = 4,
	SYNTH_ERR_INCOMPLETE_TYPE = 5,
	SYNTH_ERR_INVALID_TYPE = 6,
	SYNTH_ERR_INVALID_FIELD = 7,
	SYNTH_ERR_INVALID_ARRAY_SPEC = 8,
};

enum {
	HIST_ERR_NONE = 0,
	HIST_ERR_DUPLICATE_VAR = 1,
	HIST_ERR_VAR_NOT_UNIQUE = 2,
	HIST_ERR_TOO_MANY_VARS = 3,
	HIST_ERR_MALFORMED_ASSIGNMENT = 4,
	HIST_ERR_NAMED_MISMATCH = 5,
	HIST_ERR_TRIGGER_EEXIST = 6,
	HIST_ERR_TRIGGER_ENOENT_CLEAR = 7,
	HIST_ERR_SET_CLOCK_FAIL = 8,
	HIST_ERR_BAD_FIELD_MODIFIER = 9,
	HIST_ERR_TOO_MANY_SUBEXPR = 10,
	HIST_ERR_TIMESTAMP_MISMATCH = 11,
	HIST_ERR_TOO_MANY_FIELD_VARS = 12,
	HIST_ERR_EVENT_FILE_NOT_FOUND = 13,
	HIST_ERR_HIST_NOT_FOUND = 14,
	HIST_ERR_HIST_CREATE_FAIL = 15,
	HIST_ERR_SYNTH_VAR_NOT_FOUND = 16,
	HIST_ERR_SYNTH_EVENT_NOT_FOUND = 17,
	HIST_ERR_SYNTH_TYPE_MISMATCH = 18,
	HIST_ERR_SYNTH_COUNT_MISMATCH = 19,
	HIST_ERR_FIELD_VAR_PARSE_FAIL = 20,
	HIST_ERR_VAR_CREATE_FIND_FAIL = 21,
	HIST_ERR_ONX_NOT_VAR = 22,
	HIST_ERR_ONX_VAR_NOT_FOUND = 23,
	HIST_ERR_ONX_VAR_CREATE_FAIL = 24,
	HIST_ERR_FIELD_VAR_CREATE_FAIL = 25,
	HIST_ERR_TOO_MANY_PARAMS = 26,
	HIST_ERR_PARAM_NOT_FOUND = 27,
	HIST_ERR_INVALID_PARAM = 28,
	HIST_ERR_ACTION_NOT_FOUND = 29,
	HIST_ERR_NO_SAVE_PARAMS = 30,
	HIST_ERR_TOO_MANY_SAVE_ACTIONS = 31,
	HIST_ERR_ACTION_MISMATCH = 32,
	HIST_ERR_NO_CLOSING_PAREN = 33,
	HIST_ERR_SUBSYS_NOT_FOUND = 34,
	HIST_ERR_INVALID_SUBSYS_EVENT = 35,
	HIST_ERR_INVALID_REF_KEY = 36,
	HIST_ERR_VAR_NOT_FOUND = 37,
	HIST_ERR_FIELD_NOT_FOUND = 38,
	HIST_ERR_EMPTY_ASSIGNMENT = 39,
	HIST_ERR_INVALID_SORT_MODIFIER = 40,
	HIST_ERR_EMPTY_SORT_FIELD = 41,
	HIST_ERR_TOO_MANY_SORT_FIELDS = 42,
	HIST_ERR_INVALID_SORT_FIELD = 43,
	HIST_ERR_INVALID_STR_OPERAND = 44,
};

struct hist_field;

typedef u64 (*hist_field_fn_t)(struct hist_field *, struct tracing_map_elt *, struct trace_buffer *, struct ring_buffer_event *, void *);

struct hist_trigger_data;

struct hist_var {
	char *name;
	struct hist_trigger_data *hist_data;
	unsigned int idx;
};

enum field_op_id {
	FIELD_OP_NONE = 0,
	FIELD_OP_PLUS = 1,
	FIELD_OP_MINUS = 2,
	FIELD_OP_UNARY_MINUS = 3,
};

struct hist_field {
	struct ftrace_event_field *field;
	long unsigned int flags;
	hist_field_fn_t fn;
	unsigned int ref;
	unsigned int size;
	unsigned int offset;
	unsigned int is_signed;
	const char *type;
	struct hist_field *operands[2];
	struct hist_trigger_data *hist_data;
	struct hist_var var;
	enum field_op_id operator;
	char *system;
	char *event_name;
	char *name;
	unsigned int var_ref_idx;
	bool read_once;
	unsigned int var_str_idx;
};

struct hist_trigger_attrs;

struct action_data;

struct field_var;

struct field_var_hist;

struct hist_trigger_data {
	struct hist_field *fields[22];
	unsigned int n_vals;
	unsigned int n_keys;
	unsigned int n_fields;
	unsigned int n_vars;
	unsigned int n_var_str;
	unsigned int key_size;
	struct tracing_map_sort_key sort_keys[2];
	unsigned int n_sort_keys;
	struct trace_event_file *event_file;
	struct hist_trigger_attrs *attrs;
	struct tracing_map *map;
	bool enable_timestamps;
	bool remove;
	struct hist_field *var_refs[16];
	unsigned int n_var_refs;
	struct action_data *actions[8];
	unsigned int n_actions;
	struct field_var *field_vars[32];
	unsigned int n_field_vars;
	unsigned int n_field_var_str;
	struct field_var_hist *field_var_hists[32];
	unsigned int n_field_var_hists;
	struct field_var *save_vars[32];
	unsigned int n_save_vars;
	unsigned int n_save_var_str;
};

enum hist_field_flags {
	HIST_FIELD_FL_HITCOUNT = 1,
	HIST_FIELD_FL_KEY = 2,
	HIST_FIELD_FL_STRING = 4,
	HIST_FIELD_FL_HEX = 8,
	HIST_FIELD_FL_SYM = 16,
	HIST_FIELD_FL_SYM_OFFSET = 32,
	HIST_FIELD_FL_EXECNAME = 64,
	HIST_FIELD_FL_SYSCALL = 128,
	HIST_FIELD_FL_STACKTRACE = 256,
	HIST_FIELD_FL_LOG2 = 512,
	HIST_FIELD_FL_TIMESTAMP = 1024,
	HIST_FIELD_FL_TIMESTAMP_USECS = 2048,
	HIST_FIELD_FL_VAR = 4096,
	HIST_FIELD_FL_EXPR = 8192,
	HIST_FIELD_FL_VAR_REF = 16384,
	HIST_FIELD_FL_CPU = 32768,
	HIST_FIELD_FL_ALIAS = 65536,
};

struct var_defs {
	unsigned int n_vars;
	char *name[16];
	char *expr[16];
};

struct hist_trigger_attrs {
	char *keys_str;
	char *vals_str;
	char *sort_key_str;
	char *name;
	char *clock;
	bool pause;
	bool cont;
	bool clear;
	bool ts_in_usecs;
	unsigned int map_bits;
	char *assignment_str[16];
	unsigned int n_assignments;
	char *action_str[8];
	unsigned int n_actions;
	struct var_defs var_defs;
};

struct field_var {
	struct hist_field *var;
	struct hist_field *val;
};

struct field_var_hist {
	struct hist_trigger_data *hist_data;
	char *cmd;
};

enum handler_id {
	HANDLER_ONMATCH = 1,
	HANDLER_ONMAX = 2,
	HANDLER_ONCHANGE = 3,
};

enum action_id {
	ACTION_SAVE = 1,
	ACTION_TRACE = 2,
	ACTION_SNAPSHOT = 3,
};

typedef void (*action_fn_t)(struct hist_trigger_data *, struct tracing_map_elt *, struct trace_buffer *, void *, struct ring_buffer_event *, void *, struct action_data *, u64 *);

typedef bool (*check_track_val_fn_t)(u64, u64);

struct action_data {
	enum handler_id handler;
	enum action_id action;
	char *action_name;
	action_fn_t fn;
	unsigned int n_params;
	char *params[32];
	unsigned int var_ref_idx[16];
	struct synth_event *synth_event;
	bool use_trace_keyword;
	char *synth_event_name;
	union {
		struct {
			char *event;
			char *event_system;
		} match_data;
		struct {
			char *var_str;
			struct hist_field *var_ref;
			struct hist_field *track_var;
			check_track_val_fn_t check_val;
			action_fn_t save_data;
		} track_data;
	};
};

struct track_data {
	u64 track_val;
	bool updated;
	unsigned int key_len;
	void *key;
	struct tracing_map_elt elt;
	struct action_data *action_data;
	struct hist_trigger_data *hist_data;
};

struct hist_elt_data {
	char *comm;
	u64 *var_ref_vals;
	char *field_var_str[32];
};

struct snapshot_context {
	struct tracing_map_elt *elt;
	void *key;
};

typedef void (*synth_probe_func_t)(void *, u64 *, unsigned int *);

struct hist_var_data {
	struct list_head list;
	struct hist_trigger_data *hist_data;
};

enum {
	BPF_F_INDEX_MASK = 4294967295,
	BPF_F_CURRENT_CPU = 4294967295,
	BPF_F_CTXLEN_MASK = 0,
};

enum {
	BPF_F_GET_BRANCH_RECORDS_SIZE = 1,
};

struct bpf_perf_event_value {
	__u64 counter;
	__u64 enabled;
	__u64 running;
};

struct bpf_raw_tracepoint_args {
	__u64 args[0];
};

enum bpf_task_fd_type {
	BPF_FD_TYPE_RAW_TRACEPOINT = 0,
	BPF_FD_TYPE_TRACEPOINT = 1,
	BPF_FD_TYPE_KPROBE = 2,
	BPF_FD_TYPE_KRETPROBE = 3,
	BPF_FD_TYPE_UPROBE = 4,
	BPF_FD_TYPE_URETPROBE = 5,
};

struct btf_ptr {
	void *ptr;
	__u32 type_id;
	__u32 flags;
};

enum {
	BTF_F_COMPACT = 1,
	BTF_F_NONAME = 2,
	BTF_F_PTR_RAW = 4,
	BTF_F_ZERO = 8,
};

struct bpf_local_storage_data;

struct bpf_local_storage {
	struct bpf_local_storage_data *cache[16];
	struct hlist_head list;
	void *owner;
	struct callback_head rcu;
	raw_spinlock_t lock;
};

struct bpf_local_storage_map_bucket;

struct bpf_local_storage_map {
	struct bpf_map map;
	struct bpf_local_storage_map_bucket *buckets;
	u32 bucket_log;
	u16 elem_size;
	u16 cache_idx;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_array_aux {
	struct {
		spinlock_t lock;
		enum bpf_prog_type type;
		bool jited;
	} owner;
	struct list_head poke_progs;
	struct bpf_map *map;
	struct mutex poke_mutex;
	struct work_struct work;
};

struct bpf_array {
	struct bpf_map map;
	u32 elem_size;
	u32 index_mask;
	struct bpf_array_aux *aux;
	union {
		char value[0];
		void *ptrs[0];
		void *pptrs[0];
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_event_entry {
	struct perf_event *event;
	struct file *perf_file;
	struct file *map_file;
	struct callback_head rcu;
};

typedef long unsigned int (*bpf_ctx_copy_t)(void *, const void *, long unsigned int, long unsigned int);

typedef struct user_pt_regs bpf_user_pt_regs_t;

struct bpf_perf_event_data {
	bpf_user_pt_regs_t regs;
	__u64 sample_period;
	__u64 addr;
};

struct perf_event_query_bpf {
	__u32 ids_len;
	__u32 prog_cnt;
	__u32 ids[0];
};

struct bpf_perf_event_data_kern {
	bpf_user_pt_regs_t *regs;
	struct perf_sample_data *data;
	struct perf_event *event;
};

struct btf_id_set {
	u32 cnt;
	u32 ids[0];
};

struct security_hook_heads {
	struct hlist_head binder_set_context_mgr;
	struct hlist_head binder_transaction;
	struct hlist_head binder_transfer_binder;
	struct hlist_head binder_transfer_file;
	struct hlist_head ptrace_access_check;
	struct hlist_head ptrace_traceme;
	struct hlist_head capget;
	struct hlist_head capset;
	struct hlist_head capable;
	struct hlist_head quotactl;
	struct hlist_head quota_on;
	struct hlist_head syslog;
	struct hlist_head settime;
	struct hlist_head vm_enough_memory;
	struct hlist_head bprm_creds_for_exec;
	struct hlist_head bprm_creds_from_file;
	struct hlist_head bprm_check_security;
	struct hlist_head bprm_committing_creds;
	struct hlist_head bprm_committed_creds;
	struct hlist_head fs_context_dup;
	struct hlist_head fs_context_parse_param;
	struct hlist_head sb_alloc_security;
	struct hlist_head sb_delete;
	struct hlist_head sb_free_security;
	struct hlist_head sb_free_mnt_opts;
	struct hlist_head sb_eat_lsm_opts;
	struct hlist_head sb_mnt_opts_compat;
	struct hlist_head sb_remount;
	struct hlist_head sb_kern_mount;
	struct hlist_head sb_show_options;
	struct hlist_head sb_statfs;
	struct hlist_head sb_mount;
	struct hlist_head sb_umount;
	struct hlist_head sb_pivotroot;
	struct hlist_head sb_set_mnt_opts;
	struct hlist_head sb_clone_mnt_opts;
	struct hlist_head sb_add_mnt_opt;
	struct hlist_head move_mount;
	struct hlist_head dentry_init_security;
	struct hlist_head dentry_create_files_as;
	struct hlist_head path_unlink;
	struct hlist_head path_mkdir;
	struct hlist_head path_rmdir;
	struct hlist_head path_mknod;
	struct hlist_head path_truncate;
	struct hlist_head path_symlink;
	struct hlist_head path_link;
	struct hlist_head path_rename;
	struct hlist_head path_chmod;
	struct hlist_head path_chown;
	struct hlist_head path_chroot;
	struct hlist_head path_notify;
	struct hlist_head inode_alloc_security;
	struct hlist_head inode_free_security;
	struct hlist_head inode_init_security;
	struct hlist_head inode_init_security_anon;
	struct hlist_head inode_create;
	struct hlist_head inode_link;
	struct hlist_head inode_unlink;
	struct hlist_head inode_symlink;
	struct hlist_head inode_mkdir;
	struct hlist_head inode_rmdir;
	struct hlist_head inode_mknod;
	struct hlist_head inode_rename;
	struct hlist_head inode_readlink;
	struct hlist_head inode_follow_link;
	struct hlist_head inode_permission;
	struct hlist_head inode_setattr;
	struct hlist_head inode_getattr;
	struct hlist_head inode_setxattr;
	struct hlist_head inode_post_setxattr;
	struct hlist_head inode_getxattr;
	struct hlist_head inode_listxattr;
	struct hlist_head inode_removexattr;
	struct hlist_head inode_need_killpriv;
	struct hlist_head inode_killpriv;
	struct hlist_head inode_getsecurity;
	struct hlist_head inode_setsecurity;
	struct hlist_head inode_listsecurity;
	struct hlist_head inode_getsecid;
	struct hlist_head inode_copy_up;
	struct hlist_head inode_copy_up_xattr;
	struct hlist_head kernfs_init_security;
	struct hlist_head file_permission;
	struct hlist_head file_alloc_security;
	struct hlist_head file_free_security;
	struct hlist_head file_ioctl;
	struct hlist_head mmap_addr;
	struct hlist_head mmap_file;
	struct hlist_head file_mprotect;
	struct hlist_head file_lock;
	struct hlist_head file_fcntl;
	struct hlist_head file_set_fowner;
	struct hlist_head file_send_sigiotask;
	struct hlist_head file_receive;
	struct hlist_head file_open;
	struct hlist_head task_alloc;
	struct hlist_head task_free;
	struct hlist_head cred_alloc_blank;
	struct hlist_head cred_free;
	struct hlist_head cred_prepare;
	struct hlist_head cred_transfer;
	struct hlist_head cred_getsecid;
	struct hlist_head kernel_act_as;
	struct hlist_head kernel_create_files_as;
	struct hlist_head kernel_module_request;
	struct hlist_head kernel_load_data;
	struct hlist_head kernel_post_load_data;
	struct hlist_head kernel_read_file;
	struct hlist_head kernel_post_read_file;
	struct hlist_head task_fix_setuid;
	struct hlist_head task_fix_setgid;
	struct hlist_head task_setpgid;
	struct hlist_head task_getpgid;
	struct hlist_head task_getsid;
	struct hlist_head task_getsecid_subj;
	struct hlist_head task_getsecid_obj;
	struct hlist_head task_setnice;
	struct hlist_head task_setioprio;
	struct hlist_head task_getioprio;
	struct hlist_head task_prlimit;
	struct hlist_head task_setrlimit;
	struct hlist_head task_setscheduler;
	struct hlist_head task_getscheduler;
	struct hlist_head task_movememory;
	struct hlist_head task_kill;
	struct hlist_head task_prctl;
	struct hlist_head task_to_inode;
	struct hlist_head ipc_permission;
	struct hlist_head ipc_getsecid;
	struct hlist_head msg_msg_alloc_security;
	struct hlist_head msg_msg_free_security;
	struct hlist_head msg_queue_alloc_security;
	struct hlist_head msg_queue_free_security;
	struct hlist_head msg_queue_associate;
	struct hlist_head msg_queue_msgctl;
	struct hlist_head msg_queue_msgsnd;
	struct hlist_head msg_queue_msgrcv;
	struct hlist_head shm_alloc_security;
	struct hlist_head shm_free_security;
	struct hlist_head shm_associate;
	struct hlist_head shm_shmctl;
	struct hlist_head shm_shmat;
	struct hlist_head sem_alloc_security;
	struct hlist_head sem_free_security;
	struct hlist_head sem_associate;
	struct hlist_head sem_semctl;
	struct hlist_head sem_semop;
	struct hlist_head netlink_send;
	struct hlist_head d_instantiate;
	struct hlist_head getprocattr;
	struct hlist_head setprocattr;
	struct hlist_head ismaclabel;
	struct hlist_head secid_to_secctx;
	struct hlist_head secctx_to_secid;
	struct hlist_head release_secctx;
	struct hlist_head inode_invalidate_secctx;
	struct hlist_head inode_notifysecctx;
	struct hlist_head inode_setsecctx;
	struct hlist_head inode_getsecctx;
	struct hlist_head post_notification;
	struct hlist_head watch_key;
	struct hlist_head unix_stream_connect;
	struct hlist_head unix_may_send;
	struct hlist_head socket_create;
	struct hlist_head socket_post_create;
	struct hlist_head socket_socketpair;
	struct hlist_head socket_bind;
	struct hlist_head socket_connect;
	struct hlist_head socket_listen;
	struct hlist_head socket_accept;
	struct hlist_head socket_sendmsg;
	struct hlist_head socket_recvmsg;
	struct hlist_head socket_getsockname;
	struct hlist_head socket_getpeername;
	struct hlist_head socket_getsockopt;
	struct hlist_head socket_setsockopt;
	struct hlist_head socket_shutdown;
	struct hlist_head socket_sock_rcv_skb;
	struct hlist_head socket_getpeersec_stream;
	struct hlist_head socket_getpeersec_dgram;
	struct hlist_head sk_alloc_security;
	struct hlist_head sk_free_security;
	struct hlist_head sk_clone_security;
	struct hlist_head sk_getsecid;
	struct hlist_head sock_graft;
	struct hlist_head inet_conn_request;
	struct hlist_head inet_csk_clone;
	struct hlist_head inet_conn_established;
	struct hlist_head secmark_relabel_packet;
	struct hlist_head secmark_refcount_inc;
	struct hlist_head secmark_refcount_dec;
	struct hlist_head req_classify_flow;
	struct hlist_head tun_dev_alloc_security;
	struct hlist_head tun_dev_free_security;
	struct hlist_head tun_dev_create;
	struct hlist_head tun_dev_attach_queue;
	struct hlist_head tun_dev_attach;
	struct hlist_head tun_dev_open;
	struct hlist_head sctp_assoc_request;
	struct hlist_head sctp_bind_connect;
	struct hlist_head sctp_sk_clone;
	struct hlist_head ib_pkey_access;
	struct hlist_head ib_endport_manage_subnet;
	struct hlist_head ib_alloc_security;
	struct hlist_head ib_free_security;
	struct hlist_head xfrm_policy_alloc_security;
	struct hlist_head xfrm_policy_clone_security;
	struct hlist_head xfrm_policy_free_security;
	struct hlist_head xfrm_policy_delete_security;
	struct hlist_head xfrm_state_alloc;
	struct hlist_head xfrm_state_alloc_acquire;
	struct hlist_head xfrm_state_free_security;
	struct hlist_head xfrm_state_delete_security;
	struct hlist_head xfrm_policy_lookup;
	struct hlist_head xfrm_state_pol_flow_match;
	struct hlist_head xfrm_decode_session;
	struct hlist_head key_alloc;
	struct hlist_head key_free;
	struct hlist_head key_permission;
	struct hlist_head key_getsecurity;
	struct hlist_head audit_rule_init;
	struct hlist_head audit_rule_known;
	struct hlist_head audit_rule_match;
	struct hlist_head audit_rule_free;
	struct hlist_head bpf;
	struct hlist_head bpf_map;
	struct hlist_head bpf_prog;
	struct hlist_head bpf_map_alloc_security;
	struct hlist_head bpf_map_free_security;
	struct hlist_head bpf_prog_alloc_security;
	struct hlist_head bpf_prog_free_security;
	struct hlist_head locked_down;
	struct hlist_head lock_kernel_down;
	struct hlist_head perf_event_open;
	struct hlist_head perf_event_alloc;
	struct hlist_head perf_event_free;
	struct hlist_head perf_event_read;
	struct hlist_head perf_event_write;
};

struct lsm_blob_sizes {
	int lbs_cred;
	int lbs_file;
	int lbs_inode;
	int lbs_superblock;
	int lbs_sock;
	int lbs_ipc;
	int lbs_msg_msg;
	int lbs_task;
};

enum lsm_order {
	LSM_ORDER_FIRST = 4294967295,
	LSM_ORDER_MUTABLE = 0,
};

struct lsm_info {
	const char *name;
	enum lsm_order order;
	long unsigned int flags;
	int *enabled;
	int (*init)();
	struct lsm_blob_sizes *blobs;
};

struct bpf_local_storage_map_bucket {
	struct hlist_head list;
	raw_spinlock_t lock;
};

struct bpf_local_storage_data {
	struct bpf_local_storage_map *smap;
	u8 data[0];
};

struct trace_event_raw_bpf_trace_printk {
	struct trace_entry ent;
	u32 __data_loc_bpf_string;
	char __data[0];
};

struct trace_event_data_offsets_bpf_trace_printk {
	u32 bpf_string;
};

typedef void (*btf_trace_bpf_trace_printk)(void *, const char *);

struct bpf_trace_module {
	struct module *module;
	struct list_head list;
};

typedef u64 (*btf_bpf_override_return)(struct pt_regs *, long unsigned int);

typedef u64 (*btf_bpf_probe_read_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_user_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_write_user)(void *, const void *, u32);

typedef u64 (*btf_bpf_trace_printk)(char *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_seq_printf)(struct seq_file *, char *, u32, const void *, u32);

typedef u64 (*btf_bpf_seq_write)(struct seq_file *, const void *, u32);

typedef u64 (*btf_bpf_seq_printf_btf)(struct seq_file *, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_perf_event_read)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_perf_event_read_value)(struct bpf_map *, u64, struct bpf_perf_event_value *, u32);

struct bpf_trace_sample_data {
	struct perf_sample_data sds[3];
};

typedef u64 (*btf_bpf_perf_event_output)(struct pt_regs *, struct bpf_map *, u64, void *, u64);

struct bpf_nested_pt_regs {
	struct pt_regs regs[3];
};

typedef u64 (*btf_bpf_get_current_task)();

typedef u64 (*btf_bpf_get_current_task_btf)();

typedef u64 (*btf_bpf_current_task_under_cgroup)(struct bpf_map *, u32);

struct send_signal_irq_work {
	struct irq_work irq_work;
	struct task_struct *task;
	u32 sig;
	enum pid_type type;
};

typedef u64 (*btf_bpf_send_signal)(u32);

typedef u64 (*btf_bpf_send_signal_thread)(u32);

typedef u64 (*btf_bpf_d_path)(struct path *, char *, u32);

typedef u64 (*btf_bpf_snprintf_btf)(char *, u32, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_perf_event_output_tp)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_tp)(void *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_tp)(void *, void *, u32, u64);

typedef u64 (*btf_bpf_perf_prog_read_value)(struct bpf_perf_event_data_kern *, struct bpf_perf_event_value *, u32);

typedef u64 (*btf_bpf_read_branch_records)(struct bpf_perf_event_data_kern *, void *, u32, u64);

struct bpf_raw_tp_regs {
	struct pt_regs regs[3];
};

typedef u64 (*btf_bpf_perf_event_output_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_raw_tp)(struct bpf_raw_tracepoint_args *, void *, u32, u64);

struct kprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int ip;
};

struct kretprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int func;
	long unsigned int ret_ip;
};

typedef int (*print_type_func_t)(struct trace_seq *, void *, void *);

enum fetch_op {
	FETCH_OP_NOP = 0,
	FETCH_OP_REG = 1,
	FETCH_OP_STACK = 2,
	FETCH_OP_STACKP = 3,
	FETCH_OP_RETVAL = 4,
	FETCH_OP_IMM = 5,
	FETCH_OP_COMM = 6,
	FETCH_OP_ARG = 7,
	FETCH_OP_FOFFS = 8,
	FETCH_OP_DATA = 9,
	FETCH_OP_DEREF = 10,
	FETCH_OP_UDEREF = 11,
	FETCH_OP_ST_RAW = 12,
	FETCH_OP_ST_MEM = 13,
	FETCH_OP_ST_UMEM = 14,
	FETCH_OP_ST_STRING = 15,
	FETCH_OP_ST_USTRING = 16,
	FETCH_OP_MOD_BF = 17,
	FETCH_OP_LP_ARRAY = 18,
	FETCH_OP_END = 19,
	FETCH_NOP_SYMBOL = 20,
};

struct fetch_insn {
	enum fetch_op op;
	union {
		unsigned int param;
		struct {
			unsigned int size;
			int offset;
		};
		struct {
			unsigned char basesize;
			unsigned char lshift;
			unsigned char rshift;
		};
		long unsigned int immediate;
		void *data;
	};
};

struct fetch_type {
	const char *name;
	size_t size;
	int is_signed;
	print_type_func_t print;
	const char *fmt;
	const char *fmttype;
};

struct probe_arg {
	struct fetch_insn *code;
	bool dynamic;
	unsigned int offset;
	unsigned int count;
	const char *name;
	const char *comm;
	char *fmt;
	const struct fetch_type *type;
};

struct trace_uprobe_filter {
	rwlock_t rwlock;
	int nr_systemwide;
	struct list_head perf_events;
};

struct trace_probe_event {
	unsigned int flags;
	struct trace_event_class class;
	struct trace_event_call call;
	struct list_head files;
	struct list_head probes;
	struct trace_uprobe_filter filter[0];
};

struct trace_probe {
	struct list_head list;
	struct trace_probe_event *event;
	ssize_t size;
	unsigned int nr_args;
	struct probe_arg args[0];
};

struct event_file_link {
	struct trace_event_file *file;
	struct list_head list;
};

enum {
	TP_ERR_FILE_NOT_FOUND = 0,
	TP_ERR_NO_REGULAR_FILE = 1,
	TP_ERR_BAD_REFCNT = 2,
	TP_ERR_REFCNT_OPEN_BRACE = 3,
	TP_ERR_BAD_REFCNT_SUFFIX = 4,
	TP_ERR_BAD_UPROBE_OFFS = 5,
	TP_ERR_MAXACT_NO_KPROBE = 6,
	TP_ERR_BAD_MAXACT = 7,
	TP_ERR_MAXACT_TOO_BIG = 8,
	TP_ERR_BAD_PROBE_ADDR = 9,
	TP_ERR_BAD_RETPROBE = 10,
	TP_ERR_BAD_ADDR_SUFFIX = 11,
	TP_ERR_NO_GROUP_NAME = 12,
	TP_ERR_GROUP_TOO_LONG = 13,
	TP_ERR_BAD_GROUP_NAME = 14,
	TP_ERR_NO_EVENT_NAME = 15,
	TP_ERR_EVENT_TOO_LONG = 16,
	TP_ERR_BAD_EVENT_NAME = 17,
	TP_ERR_EVENT_EXIST = 18,
	TP_ERR_RETVAL_ON_PROBE = 19,
	TP_ERR_BAD_STACK_NUM = 20,
	TP_ERR_BAD_ARG_NUM = 21,
	TP_ERR_BAD_VAR = 22,
	TP_ERR_BAD_REG_NAME = 23,
	TP_ERR_BAD_MEM_ADDR = 24,
	TP_ERR_BAD_IMM = 25,
	TP_ERR_IMMSTR_NO_CLOSE = 26,
	TP_ERR_FILE_ON_KPROBE = 27,
	TP_ERR_BAD_FILE_OFFS = 28,
	TP_ERR_SYM_ON_UPROBE = 29,
	TP_ERR_TOO_MANY_OPS = 30,
	TP_ERR_DEREF_NEED_BRACE = 31,
	TP_ERR_BAD_DEREF_OFFS = 32,
	TP_ERR_DEREF_OPEN_BRACE = 33,
	TP_ERR_COMM_CANT_DEREF = 34,
	TP_ERR_BAD_FETCH_ARG = 35,
	TP_ERR_ARRAY_NO_CLOSE = 36,
	TP_ERR_BAD_ARRAY_SUFFIX = 37,
	TP_ERR_BAD_ARRAY_NUM = 38,
	TP_ERR_ARRAY_TOO_BIG = 39,
	TP_ERR_BAD_TYPE = 40,
	TP_ERR_BAD_STRING = 41,
	TP_ERR_BAD_BITFIELD = 42,
	TP_ERR_ARG_NAME_TOO_LONG = 43,
	TP_ERR_NO_ARG_NAME = 44,
	TP_ERR_BAD_ARG_NAME = 45,
	TP_ERR_USED_ARG_NAME = 46,
	TP_ERR_ARG_TOO_LONG = 47,
	TP_ERR_NO_ARG_BODY = 48,
	TP_ERR_BAD_INSN_BNDRY = 49,
	TP_ERR_FAIL_REG_PROBE = 50,
	TP_ERR_DIFF_PROBE_TYPE = 51,
	TP_ERR_DIFF_ARG_TYPE = 52,
	TP_ERR_SAME_PROBE = 53,
};

struct trace_kprobe {
	struct dyn_event devent;
	struct kretprobe rp;
	long unsigned int *nhit;
	const char *symbol;
	struct trace_probe tp;
};

enum error_detector {
	ERROR_DETECTOR_KFENCE = 0,
	ERROR_DETECTOR_KASAN = 1,
};

struct trace_event_raw_error_report_template {
	struct trace_entry ent;
	enum error_detector error_detector;
	long unsigned int id;
	char __data[0];
};

struct trace_event_data_offsets_error_report_template {};

typedef void (*btf_trace_error_report_end)(void *, enum error_detector, long unsigned int);

struct trace_event_raw_cpu {
	struct trace_entry ent;
	u32 state;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_powernv_throttle {
	struct trace_entry ent;
	int chip_id;
	u32 __data_loc_reason;
	int pmax;
	char __data[0];
};

struct trace_event_raw_pstate_sample {
	struct trace_entry ent;
	u32 core_busy;
	u32 scaled_busy;
	u32 from;
	u32 to;
	u64 mperf;
	u64 aperf;
	u64 tsc;
	u32 freq;
	u32 io_boost;
	char __data[0];
};

struct trace_event_raw_cpu_frequency_limits {
	struct trace_entry ent;
	u32 min_freq;
	u32 max_freq;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_start {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u32 __data_loc_parent;
	u32 __data_loc_pm_ops;
	int event;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_end {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	int error;
	char __data[0];
};

struct trace_event_raw_suspend_resume {
	struct trace_entry ent;
	const char *action;
	int val;
	bool start;
	char __data[0];
};

struct trace_event_raw_wakeup_source {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	char __data[0];
};

struct trace_event_raw_clock {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_power_domain {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_latency_qos_request {
	struct trace_entry ent;
	s32 value;
	char __data[0];
};

struct trace_event_raw_pm_qos_update {
	struct trace_entry ent;
	enum pm_qos_req_action action;
	int prev_value;
	int curr_value;
	char __data[0];
};

struct trace_event_raw_dev_pm_qos_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	enum dev_pm_qos_req_type type;
	s32 new_value;
	char __data[0];
};

struct trace_event_data_offsets_cpu {};

struct trace_event_data_offsets_powernv_throttle {
	u32 reason;
};

struct trace_event_data_offsets_pstate_sample {};

struct trace_event_data_offsets_cpu_frequency_limits {};

struct trace_event_data_offsets_device_pm_callback_start {
	u32 device;
	u32 driver;
	u32 parent;
	u32 pm_ops;
};

struct trace_event_data_offsets_device_pm_callback_end {
	u32 device;
	u32 driver;
};

struct trace_event_data_offsets_suspend_resume {};

struct trace_event_data_offsets_wakeup_source {
	u32 name;
};

struct trace_event_data_offsets_clock {
	u32 name;
};

struct trace_event_data_offsets_power_domain {
	u32 name;
};

struct trace_event_data_offsets_cpu_latency_qos_request {};

struct trace_event_data_offsets_pm_qos_update {};

struct trace_event_data_offsets_dev_pm_qos_request {
	u32 name;
};

typedef void (*btf_trace_cpu_idle)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_powernv_throttle)(void *, int, const char *, int);

typedef void (*btf_trace_pstate_sample)(void *, u32, u32, u32, u32, u64, u64, u64, u32, u32);

typedef void (*btf_trace_cpu_frequency)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_frequency_limits)(void *, struct cpufreq_policy *);

typedef void (*btf_trace_device_pm_callback_start)(void *, struct device *, const char *, int);

typedef void (*btf_trace_device_pm_callback_end)(void *, struct device *, int);

typedef void (*btf_trace_suspend_resume)(void *, const char *, int, bool);

typedef void (*btf_trace_wakeup_source_activate)(void *, const char *, unsigned int);

typedef void (*btf_trace_wakeup_source_deactivate)(void *, const char *, unsigned int);

typedef void (*btf_trace_clock_enable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_disable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_set_rate)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_power_domain_target)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_pm_qos_add_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_request)(void *, s32);

typedef void (*btf_trace_pm_qos_remove_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_target)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_pm_qos_update_flags)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_dev_pm_qos_add_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_update_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_remove_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

struct trace_event_raw_rpm_internal {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flags;
	int usage_count;
	int disable_depth;
	int runtime_auto;
	int request_pending;
	int irq_safe;
	int child_count;
	char __data[0];
};

struct trace_event_raw_rpm_return_int {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int ip;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_rpm_internal {
	u32 name;
};

struct trace_event_data_offsets_rpm_return_int {
	u32 name;
};

typedef void (*btf_trace_rpm_suspend)(void *, struct device *, int);

typedef void (*btf_trace_rpm_resume)(void *, struct device *, int);

typedef void (*btf_trace_rpm_idle)(void *, struct device *, int);

typedef void (*btf_trace_rpm_usage)(void *, struct device *, int);

typedef void (*btf_trace_rpm_return_int)(void *, struct device *, long unsigned int, int);

typedef int (*dynevent_check_arg_fn_t)(void *);

struct trace_probe_log {
	const char *subsystem;
	const char **argv;
	int argc;
	int index;
};

enum uprobe_filter_ctx {
	UPROBE_FILTER_REGISTER = 0,
	UPROBE_FILTER_UNREGISTER = 1,
	UPROBE_FILTER_MMAP = 2,
};

struct uprobe_consumer {
	int (*handler)(struct uprobe_consumer *, struct pt_regs *);
	int (*ret_handler)(struct uprobe_consumer *, long unsigned int, struct pt_regs *);
	bool (*filter)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);
	struct uprobe_consumer *next;
};

struct uprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int vaddr[0];
};

struct trace_uprobe {
	struct dyn_event devent;
	struct uprobe_consumer consumer;
	struct path path;
	struct inode *inode;
	char *filename;
	long unsigned int offset;
	long unsigned int ref_ctr_offset;
	long unsigned int nhit;
	struct trace_probe tp;
};

struct uprobe_dispatch_data {
	struct trace_uprobe *tu;
	long unsigned int bp_addr;
};

struct uprobe_cpu_buffer {
	struct mutex mutex;
	void *buf;
};

typedef bool (*filter_func_t)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);

struct rnd_state {
	__u32 s1;
	__u32 s2;
	__u32 s3;
	__u32 s4;
};

struct rhash_lock_head;

struct bucket_table {
	unsigned int size;
	unsigned int nest;
	u32 hash_rnd;
	struct list_head walkers;
	struct callback_head rcu;
	struct bucket_table *future_tbl;
	struct lockdep_map dep_map;
	long: 64;
	struct rhash_lock_head *buckets[0];
};

enum xdp_action {
	XDP_ABORTED = 0,
	XDP_DROP = 1,
	XDP_PASS = 2,
	XDP_TX = 3,
	XDP_REDIRECT = 4,
};

enum bpf_jit_poke_reason {
	BPF_POKE_REASON_TAIL_CALL = 0,
};

enum bpf_text_poke_type {
	BPF_MOD_CALL = 0,
	BPF_MOD_JUMP = 1,
};

enum xdp_mem_type {
	MEM_TYPE_PAGE_SHARED = 0,
	MEM_TYPE_PAGE_ORDER0 = 1,
	MEM_TYPE_PAGE_POOL = 2,
	MEM_TYPE_XSK_BUFF_POOL = 3,
	MEM_TYPE_MAX = 4,
};

struct xdp_cpumap_stats {
	unsigned int redirect;
	unsigned int pass;
	unsigned int drop;
};

typedef void (*bpf_jit_fill_hole_t)(void *, unsigned int);

struct bpf_prog_dummy {
	struct bpf_prog prog;
};

typedef u64 (*btf_bpf_user_rnd_u32)();

typedef u64 (*btf_bpf_get_raw_cpu_id)();

struct _bpf_dtab_netdev {
	struct net_device *dev;
};

struct rhash_lock_head {};

struct zero_copy_allocator;

struct page_pool;

struct xdp_mem_allocator {
	struct xdp_mem_info mem;
	union {
		void *allocator;
		struct page_pool *page_pool;
		struct zero_copy_allocator *zc_alloc;
	};
	struct rhash_head node;
	struct callback_head rcu;
};

struct trace_event_raw_xdp_exception {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_xdp_bulk_tx {
	struct trace_entry ent;
	int ifindex;
	u32 act;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_xdp_redirect_template {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	int err;
	int to_ifindex;
	u32 map_id;
	int map_index;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_kthread {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int sched;
	unsigned int xdp_pass;
	unsigned int xdp_drop;
	unsigned int xdp_redirect;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_enqueue {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int to_cpu;
	char __data[0];
};

struct trace_event_raw_xdp_devmap_xmit {
	struct trace_entry ent;
	int from_ifindex;
	u32 act;
	int to_ifindex;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_mem_disconnect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	char __data[0];
};

struct trace_event_raw_mem_connect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	const struct xdp_rxq_info *rxq;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_mem_return_failed {
	struct trace_entry ent;
	const struct page *page;
	u32 mem_id;
	u32 mem_type;
	char __data[0];
};

struct trace_event_data_offsets_xdp_exception {};

struct trace_event_data_offsets_xdp_bulk_tx {};

struct trace_event_data_offsets_xdp_redirect_template {};

struct trace_event_data_offsets_xdp_cpumap_kthread {};

struct trace_event_data_offsets_xdp_cpumap_enqueue {};

struct trace_event_data_offsets_xdp_devmap_xmit {};

struct trace_event_data_offsets_mem_disconnect {};

struct trace_event_data_offsets_mem_connect {};

struct trace_event_data_offsets_mem_return_failed {};

typedef void (*btf_trace_xdp_exception)(void *, const struct net_device *, const struct bpf_prog *, u32);

typedef void (*btf_trace_xdp_bulk_tx)(void *, const struct net_device *, int, int, int);

typedef void (*btf_trace_xdp_redirect)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_map)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_map_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_cpumap_kthread)(void *, int, unsigned int, unsigned int, int, struct xdp_cpumap_stats *);

typedef void (*btf_trace_xdp_cpumap_enqueue)(void *, int, unsigned int, unsigned int, int);

typedef void (*btf_trace_xdp_devmap_xmit)(void *, const struct net_device *, const struct net_device *, int, int, int);

typedef void (*btf_trace_mem_disconnect)(void *, const struct xdp_mem_allocator *);

typedef void (*btf_trace_mem_connect)(void *, const struct xdp_mem_allocator *, const struct xdp_rxq_info *);

typedef void (*btf_trace_mem_return_failed)(void *, const struct xdp_mem_info *, const struct page *);

enum bpf_cmd {
	BPF_MAP_CREATE = 0,
	BPF_MAP_LOOKUP_ELEM = 1,
	BPF_MAP_UPDATE_ELEM = 2,
	BPF_MAP_DELETE_ELEM = 3,
	BPF_MAP_GET_NEXT_KEY = 4,
	BPF_PROG_LOAD = 5,
	BPF_OBJ_PIN = 6,
	BPF_OBJ_GET = 7,
	BPF_PROG_ATTACH = 8,
	BPF_PROG_DETACH = 9,
	BPF_PROG_TEST_RUN = 10,
	BPF_PROG_GET_NEXT_ID = 11,
	BPF_MAP_GET_NEXT_ID = 12,
	BPF_PROG_GET_FD_BY_ID = 13,
	BPF_MAP_GET_FD_BY_ID = 14,
	BPF_OBJ_GET_INFO_BY_FD = 15,
	BPF_PROG_QUERY = 16,
	BPF_RAW_TRACEPOINT_OPEN = 17,
	BPF_BTF_LOAD = 18,
	BPF_BTF_GET_FD_BY_ID = 19,
	BPF_TASK_FD_QUERY = 20,
	BPF_MAP_LOOKUP_AND_DELETE_ELEM = 21,
	BPF_MAP_FREEZE = 22,
	BPF_BTF_GET_NEXT_ID = 23,
	BPF_MAP_LOOKUP_BATCH = 24,
	BPF_MAP_LOOKUP_AND_DELETE_BATCH = 25,
	BPF_MAP_UPDATE_BATCH = 26,
	BPF_MAP_DELETE_BATCH = 27,
	BPF_LINK_CREATE = 28,
	BPF_LINK_UPDATE = 29,
	BPF_LINK_GET_FD_BY_ID = 30,
	BPF_LINK_GET_NEXT_ID = 31,
	BPF_ENABLE_STATS = 32,
	BPF_ITER_CREATE = 33,
	BPF_LINK_DETACH = 34,
	BPF_PROG_BIND_MAP = 35,
};

enum {
	BPF_ANY = 0,
	BPF_NOEXIST = 1,
	BPF_EXIST = 2,
	BPF_F_LOCK = 4,
};

enum {
	BPF_F_NO_PREALLOC = 1,
	BPF_F_NO_COMMON_LRU = 2,
	BPF_F_NUMA_NODE = 4,
	BPF_F_RDONLY = 8,
	BPF_F_WRONLY = 16,
	BPF_F_STACK_BUILD_ID = 32,
	BPF_F_ZERO_SEED = 64,
	BPF_F_RDONLY_PROG = 128,
	BPF_F_WRONLY_PROG = 256,
	BPF_F_CLONE = 512,
	BPF_F_MMAPABLE = 1024,
	BPF_F_PRESERVE_ELEMS = 2048,
	BPF_F_INNER_MAP = 4096,
};

enum bpf_stats_type {
	BPF_STATS_RUN_TIME = 0,
};

struct bpf_prog_info {
	__u32 type;
	__u32 id;
	__u8 tag[8];
	__u32 jited_prog_len;
	__u32 xlated_prog_len;
	__u64 jited_prog_insns;
	__u64 xlated_prog_insns;
	__u64 load_time;
	__u32 created_by_uid;
	__u32 nr_map_ids;
	__u64 map_ids;
	char name[16];
	__u32 ifindex;
	__u32 gpl_compatible: 1;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 nr_jited_ksyms;
	__u32 nr_jited_func_lens;
	__u64 jited_ksyms;
	__u64 jited_func_lens;
	__u32 btf_id;
	__u32 func_info_rec_size;
	__u64 func_info;
	__u32 nr_func_info;
	__u32 nr_line_info;
	__u64 line_info;
	__u64 jited_line_info;
	__u32 nr_jited_line_info;
	__u32 line_info_rec_size;
	__u32 jited_line_info_rec_size;
	__u32 nr_prog_tags;
	__u64 prog_tags;
	__u64 run_time_ns;
	__u64 run_cnt;
	__u64 recursion_misses;
};

struct bpf_map_info {
	__u32 type;
	__u32 id;
	__u32 key_size;
	__u32 value_size;
	__u32 max_entries;
	__u32 map_flags;
	char name[16];
	__u32 ifindex;
	__u32 btf_vmlinux_value_type_id;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 btf_id;
	__u32 btf_key_type_id;
	__u32 btf_value_type_id;
};

struct bpf_btf_info {
	__u64 btf;
	__u32 btf_size;
	__u32 id;
	__u64 name;
	__u32 name_len;
	__u32 kernel_btf;
};

struct bpf_spin_lock {
	__u32 val;
};

struct bpf_verifier_log {
	u32 level;
	char kbuf[1024];
	char *ubuf;
	u32 len_used;
	u32 len_total;
};

struct bpf_subprog_info {
	u32 start;
	u32 linfo_idx;
	u16 stack_depth;
	bool has_tail_call;
	bool tail_call_reachable;
	bool has_ld_abs;
};

struct bpf_id_pair {
	u32 old;
	u32 cur;
};

struct bpf_verifier_stack_elem;

struct bpf_verifier_state;

struct bpf_verifier_state_list;

struct bpf_insn_aux_data;

struct bpf_verifier_env {
	u32 insn_idx;
	u32 prev_insn_idx;
	struct bpf_prog *prog;
	const struct bpf_verifier_ops *ops;
	struct bpf_verifier_stack_elem *head;
	int stack_size;
	bool strict_alignment;
	bool test_state_freq;
	struct bpf_verifier_state *cur_state;
	struct bpf_verifier_state_list **explored_states;
	struct bpf_verifier_state_list *free_list;
	struct bpf_map *used_maps[64];
	struct btf_mod_pair used_btfs[64];
	u32 used_map_cnt;
	u32 used_btf_cnt;
	u32 id_gen;
	bool explore_alu_limits;
	bool allow_ptr_leaks;
	bool allow_uninit_stack;
	bool allow_ptr_to_map_access;
	bool bpf_capable;
	bool bypass_spec_v1;
	bool bypass_spec_v4;
	bool seen_direct_write;
	struct bpf_insn_aux_data *insn_aux_data;
	const struct bpf_line_info *prev_linfo;
	struct bpf_verifier_log log;
	struct bpf_subprog_info subprog_info[257];
	struct bpf_id_pair idmap_scratch[75];
	struct {
		int *insn_state;
		int *insn_stack;
		int cur_stack;
	} cfg;
	u32 pass_cnt;
	u32 subprog_cnt;
	u32 prev_insn_processed;
	u32 insn_processed;
	u32 prev_jmps_processed;
	u32 jmps_processed;
	u64 verification_time;
	u32 max_states_per_insn;
	u32 total_states;
	u32 peak_states;
	u32 longest_mark_read_walk;
};

struct tnum {
	u64 value;
	u64 mask;
};

enum bpf_reg_liveness {
	REG_LIVE_NONE = 0,
	REG_LIVE_READ32 = 1,
	REG_LIVE_READ64 = 2,
	REG_LIVE_READ = 3,
	REG_LIVE_WRITTEN = 4,
	REG_LIVE_DONE = 8,
};

struct bpf_reg_state {
	enum bpf_reg_type type;
	s32 off;
	union {
		int range;
		struct bpf_map *map_ptr;
		struct {
			struct btf *btf;
			u32 btf_id;
		};
		u32 mem_size;
		struct {
			long unsigned int raw1;
			long unsigned int raw2;
		} raw;
		u32 subprogno;
	};
	u32 id;
	u32 ref_obj_id;
	struct tnum var_off;
	s64 smin_value;
	s64 smax_value;
	u64 umin_value;
	u64 umax_value;
	s32 s32_min_value;
	s32 s32_max_value;
	u32 u32_min_value;
	u32 u32_max_value;
	struct bpf_reg_state *parent;
	u32 frameno;
	s32 subreg_def;
	enum bpf_reg_liveness live;
	bool precise;
};

struct bpf_reference_state;

struct bpf_stack_state;

struct bpf_func_state {
	struct bpf_reg_state regs[11];
	int callsite;
	u32 frameno;
	u32 subprogno;
	int acquired_refs;
	struct bpf_reference_state *refs;
	int allocated_stack;
	bool in_callback_fn;
	struct bpf_stack_state *stack;
};

struct bpf_attach_target_info {
	struct btf_func_model fmodel;
	long int tgt_addr;
	const char *tgt_name;
	const struct btf_type *tgt_type;
};

struct bpf_link_primer {
	struct bpf_link *link;
	struct file *file;
	int fd;
	u32 id;
};

struct bpf_stack_state {
	struct bpf_reg_state spilled_ptr;
	u8 slot_type[8];
};

struct bpf_reference_state {
	int id;
	int insn_idx;
};

struct bpf_idx_pair {
	u32 prev_idx;
	u32 idx;
};

struct bpf_verifier_state {
	struct bpf_func_state *frame[8];
	struct bpf_verifier_state *parent;
	u32 branches;
	u32 insn_idx;
	u32 curframe;
	u32 active_spin_lock;
	bool speculative;
	u32 first_insn_idx;
	u32 last_insn_idx;
	struct bpf_idx_pair *jmp_history;
	u32 jmp_history_cnt;
};

struct bpf_verifier_state_list {
	struct bpf_verifier_state state;
	struct bpf_verifier_state_list *next;
	int miss_cnt;
	int hit_cnt;
};

struct bpf_insn_aux_data {
	union {
		enum bpf_reg_type ptr_type;
		long unsigned int map_ptr_state;
		s32 call_imm;
		u32 alu_limit;
		struct {
			u32 map_index;
			u32 map_off;
		};
		struct {
			enum bpf_reg_type reg_type;
			union {
				struct {
					struct btf *btf;
					u32 btf_id;
				};
				u32 mem_size;
			};
		} btf_var;
	};
	u64 map_key_state;
	int ctx_field_size;
	u32 seen;
	bool sanitize_stack_spill;
	bool zext_dst;
	u8 alu_state;
	unsigned int orig_idx;
	bool prune_point;
};

enum perf_bpf_event_type {
	PERF_BPF_EVENT_UNKNOWN = 0,
	PERF_BPF_EVENT_PROG_LOAD = 1,
	PERF_BPF_EVENT_PROG_UNLOAD = 2,
	PERF_BPF_EVENT_MAX = 3,
};

enum bpf_audit {
	BPF_AUDIT_LOAD = 0,
	BPF_AUDIT_UNLOAD = 1,
	BPF_AUDIT_MAX = 2,
};

struct bpf_tracing_link {
	struct bpf_link link;
	enum bpf_attach_type attach_type;
	struct bpf_trampoline *trampoline;
	struct bpf_prog *tgt_prog;
};

struct bpf_raw_tp_link {
	struct bpf_link link;
	struct bpf_raw_event_map *btp;
};

struct btf_member {
	__u32 name_off;
	__u32 type;
	__u32 offset;
};

struct btf_param {
	__u32 name_off;
	__u32 type;
};

enum btf_func_linkage {
	BTF_FUNC_STATIC = 0,
	BTF_FUNC_GLOBAL = 1,
	BTF_FUNC_EXTERN = 2,
};

struct btf_var_secinfo {
	__u32 type;
	__u32 offset;
	__u32 size;
};

enum sk_action {
	SK_DROP = 0,
	SK_PASS = 1,
};

struct bpf_kfunc_desc {
	struct btf_func_model func_model;
	u32 func_id;
	s32 imm;
};

struct bpf_kfunc_desc_tab {
	struct bpf_kfunc_desc descs[256];
	u32 nr_descs;
};

struct bpf_struct_ops {
	const struct bpf_verifier_ops *verifier_ops;
	int (*init)(struct btf *);
	int (*check_member)(const struct btf_type *, const struct btf_member *);
	int (*init_member)(const struct btf_type *, const struct btf_member *, void *, const void *);
	int (*reg)(void *);
	void (*unreg)(void *);
	const struct btf_type *type;
	const struct btf_type *value_type;
	const char *name;
	struct btf_func_model func_models[64];
	u32 type_id;
	u32 value_id;
};

typedef u32 (*bpf_convert_ctx_access_t)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);

enum bpf_stack_slot_type {
	STACK_INVALID = 0,
	STACK_SPILL = 1,
	STACK_MISC = 2,
	STACK_ZERO = 3,
};

struct bpf_verifier_stack_elem {
	struct bpf_verifier_state st;
	int insn_idx;
	int prev_insn_idx;
	struct bpf_verifier_stack_elem *next;
	u32 log_pos;
};

enum {
	BTF_SOCK_TYPE_INET = 0,
	BTF_SOCK_TYPE_INET_CONN = 1,
	BTF_SOCK_TYPE_INET_REQ = 2,
	BTF_SOCK_TYPE_INET_TW = 3,
	BTF_SOCK_TYPE_REQ = 4,
	BTF_SOCK_TYPE_SOCK = 5,
	BTF_SOCK_TYPE_SOCK_COMMON = 6,
	BTF_SOCK_TYPE_TCP = 7,
	BTF_SOCK_TYPE_TCP_REQ = 8,
	BTF_SOCK_TYPE_TCP_TW = 9,
	BTF_SOCK_TYPE_TCP6 = 10,
	BTF_SOCK_TYPE_UDP = 11,
	BTF_SOCK_TYPE_UDP6 = 12,
	MAX_BTF_SOCK_TYPE = 13,
};

typedef void (*bpf_insn_print_t)(void *, const char *, ...);

typedef const char * (*bpf_insn_revmap_call_t)(void *, const struct bpf_insn *);

typedef const char * (*bpf_insn_print_imm_t)(void *, const struct bpf_insn *, __u64);

struct bpf_insn_cbs {
	bpf_insn_print_t cb_print;
	bpf_insn_revmap_call_t cb_call;
	bpf_insn_print_imm_t cb_imm;
	void *private_data;
};

struct bpf_call_arg_meta {
	struct bpf_map *map_ptr;
	bool raw_mode;
	bool pkt_access;
	int regno;
	int access_size;
	int mem_size;
	u64 msize_max_value;
	int ref_obj_id;
	int func_id;
	struct btf *btf;
	u32 btf_id;
	struct btf *ret_btf;
	u32 ret_btf_id;
	u32 subprogno;
};

enum reg_arg_type {
	SRC_OP = 0,
	DST_OP = 1,
	DST_OP_NO_MARK = 2,
};

enum stack_access_src {
	ACCESS_DIRECT = 1,
	ACCESS_HELPER = 2,
};

struct bpf_reg_types {
	const enum bpf_reg_type types[10];
	u32 *btf_id;
};

enum {
	AT_PKT_END = 4294967295,
	BEYOND_PKT_END = 4294967294,
};

typedef int (*set_callee_state_fn)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *, int);

enum {
	REASON_BOUNDS = 4294967295,
	REASON_TYPE = 4294967294,
	REASON_PATHS = 4294967293,
	REASON_LIMIT = 4294967292,
	REASON_STACK = 4294967291,
};

struct bpf_sanitize_info {
	struct bpf_insn_aux_data aux;
	bool mask_to_left;
};

enum {
	DISCOVERED = 16,
	EXPLORED = 32,
	FALLTHROUGH = 1,
	BRANCH = 2,
};

enum {
	DONE_EXPLORING = 0,
	KEEP_EXPLORING = 1,
};

struct tree_descr {
	const char *name;
	const struct file_operations *ops;
	int mode;
};

struct bpf_preload_info {
	char link_name[16];
	int link_id;
};

struct bpf_preload_ops {
	struct umd_info info;
	int (*preload)(struct bpf_preload_info *);
	int (*finish)();
	struct module *owner;
};

enum bpf_type {
	BPF_TYPE_UNSPEC = 0,
	BPF_TYPE_PROG = 1,
	BPF_TYPE_MAP = 2,
	BPF_TYPE_LINK = 3,
};

struct map_iter {
	void *key;
	bool done;
};

enum {
	OPT_MODE = 0,
};

struct bpf_mount_opts {
	umode_t mode;
};

struct bpf_pidns_info {
	__u32 pid;
	__u32 tgid;
};

typedef u64 (*btf_bpf_map_lookup_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_update_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_map_delete_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_push_elem)(struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_map_pop_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_peek_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_get_smp_processor_id)();

typedef u64 (*btf_bpf_get_numa_node_id)();

typedef u64 (*btf_bpf_ktime_get_ns)();

typedef u64 (*btf_bpf_ktime_get_boot_ns)();

typedef u64 (*btf_bpf_ktime_get_coarse_ns)();

typedef u64 (*btf_bpf_get_current_pid_tgid)();

typedef u64 (*btf_bpf_get_current_uid_gid)();

typedef u64 (*btf_bpf_get_current_comm)(char *, u32);

typedef u64 (*btf_bpf_spin_lock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_spin_unlock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_jiffies64)();

typedef u64 (*btf_bpf_get_current_cgroup_id)();

typedef u64 (*btf_bpf_get_current_ancestor_cgroup_id)(int);

typedef u64 (*btf_bpf_get_local_storage)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_strtol)(const char *, size_t, u64, long int *);

typedef u64 (*btf_bpf_strtoul)(const char *, size_t, u64, long unsigned int *);

typedef u64 (*btf_bpf_get_ns_current_pid_tgid)(u64, u64, struct bpf_pidns_info *, u32);

typedef u64 (*btf_bpf_event_output_data)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_copy_from_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_per_cpu_ptr)(const void *, u32);

typedef u64 (*btf_bpf_this_cpu_ptr)(const void *);

struct bpf_bprintf_buffers {
	char tmp_bufs[1536];
};

typedef u64 (*btf_bpf_snprintf)(char *, u32, char *, const void *, u32);

union bpf_iter_link_info {
	struct {
		__u32 map_fd;
	} map;
};

typedef int (*bpf_iter_attach_target_t)(struct bpf_prog *, union bpf_iter_link_info *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_detach_target_t)(struct bpf_iter_aux_info *);

typedef void (*bpf_iter_show_fdinfo_t)(const struct bpf_iter_aux_info *, struct seq_file *);

typedef int (*bpf_iter_fill_link_info_t)(const struct bpf_iter_aux_info *, struct bpf_link_info *);

enum bpf_iter_feature {
	BPF_ITER_RESCHED = 1,
};

struct bpf_iter_reg {
	const char *target;
	bpf_iter_attach_target_t attach_target;
	bpf_iter_detach_target_t detach_target;
	bpf_iter_show_fdinfo_t show_fdinfo;
	bpf_iter_fill_link_info_t fill_link_info;
	u32 ctx_arg_info_size;
	u32 feature;
	struct bpf_ctx_arg_aux ctx_arg_info[2];
	const struct bpf_iter_seq_info *seq_info;
};

struct bpf_iter_meta {
	union {
		struct seq_file *seq;
	};
	u64 session_id;
	u64 seq_num;
};

struct bpf_iter_target_info {
	struct list_head list;
	const struct bpf_iter_reg *reg_info;
	u32 btf_id;
};

struct bpf_iter_link {
	struct bpf_link link;
	struct bpf_iter_aux_info aux;
	struct bpf_iter_target_info *tinfo;
};

struct bpf_iter_priv_data {
	struct bpf_iter_target_info *tinfo;
	const struct bpf_iter_seq_info *seq_info;
	struct bpf_prog *prog;
	u64 session_id;
	u64 seq_num;
	bool done_stop;
	long: 56;
	u8 target_private[0];
};

typedef u64 (*btf_bpf_for_each_map_elem)(struct bpf_map *, void *, void *, u64);

struct bpf_iter_seq_map_info {
	u32 map_id;
};

struct bpf_iter__bpf_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
};

struct bpf_iter_seq_task_common {
	struct pid_namespace *ns;
};

struct bpf_iter_seq_task_info {
	struct bpf_iter_seq_task_common common;
	u32 tid;
};

struct bpf_iter__task {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
};

struct bpf_iter_seq_task_file_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	u32 tid;
	u32 fd;
};

struct bpf_iter__task_file {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	u32 fd;
	union {
		struct file *file;
	};
};

struct bpf_iter_seq_task_vma_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	struct vm_area_struct *vma;
	u32 tid;
	long unsigned int prev_vm_start;
	long unsigned int prev_vm_end;
};

enum bpf_task_vma_iter_find_op {
	task_vma_iter_first_vma = 0,
	task_vma_iter_next_vma = 1,
	task_vma_iter_find_vma = 2,
};

struct bpf_iter__task_vma {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	union {
		struct vm_area_struct *vma;
	};
};

struct bpf_iter_seq_prog_info {
	u32 prog_id;
};

struct bpf_iter__bpf_prog {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_prog *prog;
	};
};

struct bpf_iter__bpf_map_elem {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		void *value;
	};
};

struct pcpu_freelist_node;

struct pcpu_freelist_head {
	struct pcpu_freelist_node *first;
	raw_spinlock_t lock;
};

struct pcpu_freelist_node {
	struct pcpu_freelist_node *next;
};

struct pcpu_freelist {
	struct pcpu_freelist_head *freelist;
	struct pcpu_freelist_head extralist;
};

struct bpf_lru_node {
	struct list_head list;
	u16 cpu;
	u8 type;
	u8 ref;
};

struct bpf_lru_list {
	struct list_head lists[3];
	unsigned int counts[2];
	struct list_head *next_inactive_rotation;
	raw_spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_lru_locallist {
	struct list_head lists[2];
	u16 next_steal;
	raw_spinlock_t lock;
};

struct bpf_common_lru {
	struct bpf_lru_list lru_list;
	struct bpf_lru_locallist *local_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef bool (*del_from_htab_func)(void *, struct bpf_lru_node *);

struct bpf_lru {
	union {
		struct bpf_common_lru common_lru;
		struct bpf_lru_list *percpu_lru;
	};
	del_from_htab_func del_from_htab;
	void *del_arg;
	unsigned int hash_offset;
	unsigned int nr_scans;
	bool percpu;
	long: 56;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bucket {
	struct hlist_nulls_head head;
	union {
		raw_spinlock_t raw_lock;
		spinlock_t lock;
	};
};

struct htab_elem;

struct bpf_htab {
	struct bpf_map map;
	struct bucket *buckets;
	void *elems;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct pcpu_freelist freelist;
		struct bpf_lru lru;
	};
	struct htab_elem **extra_elems;
	atomic_t count;
	u32 n_buckets;
	u32 elem_size;
	u32 hashrnd;
	struct lock_class_key lockdep_key;
	int *map_locked[8];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct htab_elem {
	union {
		struct hlist_nulls_node hash_node;
		struct {
			void *padding;
			union {
				struct bpf_htab *htab;
				struct pcpu_freelist_node fnode;
				struct htab_elem *batch_flink;
			};
		};
	};
	union {
		struct callback_head rcu;
		struct bpf_lru_node lru_node;
	};
	u32 hash;
	int: 32;
	char key[0];
};

struct bpf_iter_seq_hash_map_info {
	struct bpf_map *map;
	struct bpf_htab *htab;
	void *percpu_value_buf;
	u32 bucket_id;
	u32 skip_elems;
};

struct bpf_iter_seq_array_map_info {
	struct bpf_map *map;
	void *percpu_value_buf;
	u32 index;
};

struct prog_poke_elem {
	struct list_head list;
	struct bpf_prog_aux *aux;
};

enum bpf_lru_list_type {
	BPF_LRU_LIST_T_ACTIVE = 0,
	BPF_LRU_LIST_T_INACTIVE = 1,
	BPF_LRU_LIST_T_FREE = 2,
	BPF_LRU_LOCAL_LIST_T_FREE = 3,
	BPF_LRU_LOCAL_LIST_T_PENDING = 4,
};

struct bpf_lpm_trie_key {
	__u32 prefixlen;
	__u8 data[0];
};

struct lpm_trie_node {
	struct callback_head rcu;
	struct lpm_trie_node *child[2];
	u32 prefixlen;
	u32 flags;
	u8 data[0];
};

struct lpm_trie {
	struct bpf_map map;
	struct lpm_trie_node *root;
	size_t n_entries;
	size_t max_prefixlen;
	size_t data_size;
	spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_cgroup_storage_map {
	struct bpf_map map;
	spinlock_t lock;
	struct rb_root root;
	struct list_head list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_queue_stack {
	struct bpf_map map;
	raw_spinlock_t lock;
	u32 head;
	u32 tail;
	u32 size;
	char elements[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	BPF_RB_NO_WAKEUP = 1,
	BPF_RB_FORCE_WAKEUP = 2,
};

enum {
	BPF_RB_AVAIL_DATA = 0,
	BPF_RB_RING_SIZE = 1,
	BPF_RB_CONS_POS = 2,
	BPF_RB_PROD_POS = 3,
};

enum {
	BPF_RINGBUF_BUSY_BIT = 2147483648,
	BPF_RINGBUF_DISCARD_BIT = 1073741824,
	BPF_RINGBUF_HDR_SZ = 8,
};

struct bpf_ringbuf {
	wait_queue_head_t waitq;
	struct irq_work work;
	u64 mask;
	struct page **pages;
	int nr_pages;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t spinlock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int consumer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int producer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_ringbuf_map {
	struct bpf_map map;
	struct bpf_ringbuf *rb;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_ringbuf_hdr {
	u32 len;
	u32 pg_off;
};

typedef u64 (*btf_bpf_ringbuf_reserve)(struct bpf_map *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_submit)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_discard)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_output)(struct bpf_map *, void *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_query)(struct bpf_map *, u64);

struct bpf_local_storage_elem {
	struct hlist_node map_node;
	struct hlist_node snode;
	struct bpf_local_storage *local_storage;
	struct callback_head rcu;
	long: 64;
	struct bpf_local_storage_data sdata;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_cache {
	spinlock_t idx_lock;
	u64 idx_usage_counts[16];
};

enum {
	BPF_LOCAL_STORAGE_GET_F_CREATE = 1,
	BPF_SK_STORAGE_GET_F_CREATE = 1,
};

typedef u64 (*btf_bpf_task_storage_get)(struct bpf_map *, struct task_struct *, void *, u64);

typedef u64 (*btf_bpf_task_storage_delete)(struct bpf_map *, struct task_struct *);

struct bpf_tramp_progs {
	struct bpf_prog *progs[38];
	int nr_progs;
};

struct btf_enum {
	__u32 name_off;
	__s32 val;
};

struct btf_array {
	__u32 type;
	__u32 index_type;
	__u32 nelems;
};

enum {
	BTF_VAR_STATIC = 0,
	BTF_VAR_GLOBAL_ALLOCATED = 1,
	BTF_VAR_GLOBAL_EXTERN = 2,
};

struct btf_var {
	__u32 linkage;
};

struct bpf_flow_keys {
	__u16 nhoff;
	__u16 thoff;
	__u16 addr_proto;
	__u8 is_frag;
	__u8 is_first_frag;
	__u8 is_encap;
	__u8 ip_proto;
	__be16 n_proto;
	__be16 sport;
	__be16 dport;
	union {
		struct {
			__be32 ipv4_src;
			__be32 ipv4_dst;
		};
		struct {
			__u32 ipv6_src[4];
			__u32 ipv6_dst[4];
		};
	};
	__u32 flags;
	__be32 flow_label;
};

struct bpf_sock {
	__u32 bound_dev_if;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 mark;
	__u32 priority;
	__u32 src_ip4;
	__u32 src_ip6[4];
	__u32 src_port;
	__u32 dst_port;
	__u32 dst_ip4;
	__u32 dst_ip6[4];
	__u32 state;
	__s32 rx_queue_mapping;
};

struct __sk_buff {
	__u32 len;
	__u32 pkt_type;
	__u32 mark;
	__u32 queue_mapping;
	__u32 protocol;
	__u32 vlan_present;
	__u32 vlan_tci;
	__u32 vlan_proto;
	__u32 priority;
	__u32 ingress_ifindex;
	__u32 ifindex;
	__u32 tc_index;
	__u32 cb[5];
	__u32 hash;
	__u32 tc_classid;
	__u32 data;
	__u32 data_end;
	__u32 napi_id;
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 data_meta;
	union {
		struct bpf_flow_keys *flow_keys;
	};
	__u64 tstamp;
	__u32 wire_len;
	__u32 gso_segs;
	union {
		struct bpf_sock *sk;
	};
	__u32 gso_size;
};

struct xdp_md {
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	__u32 ingress_ifindex;
	__u32 rx_queue_index;
	__u32 egress_ifindex;
};

struct sk_msg_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 size;
	union {
		struct bpf_sock *sk;
	};
};

struct sk_reuseport_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 len;
	__u32 eth_protocol;
	__u32 ip_protocol;
	__u32 bind_inany;
	__u32 hash;
};

struct bpf_sock_addr {
	__u32 user_family;
	__u32 user_ip4;
	__u32 user_ip6[4];
	__u32 user_port;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 msg_src_ip4;
	__u32 msg_src_ip6[4];
	union {
		struct bpf_sock *sk;
	};
};

struct bpf_sock_ops {
	__u32 op;
	union {
		__u32 args[4];
		__u32 reply;
		__u32 replylong[4];
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 is_fullsock;
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 bpf_sock_ops_cb_flags;
	__u32 state;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u32 sk_txhash;
	__u64 bytes_received;
	__u64 bytes_acked;
	union {
		struct bpf_sock *sk;
	};
	union {
		void *skb_data;
	};
	union {
		void *skb_data_end;
	};
	__u32 skb_len;
	__u32 skb_tcp_flags;
};

struct bpf_cgroup_dev_ctx {
	__u32 access_type;
	__u32 major;
	__u32 minor;
};

struct bpf_sysctl {
	__u32 write;
	__u32 file_pos;
};

struct bpf_sockopt {
	union {
		struct bpf_sock *sk;
	};
	union {
		void *optval;
	};
	union {
		void *optval_end;
	};
	__s32 level;
	__s32 optname;
	__s32 optlen;
	__s32 retval;
};

struct bpf_sk_lookup {
	union {
		union {
			struct bpf_sock *sk;
		};
		__u64 cookie;
	};
	__u32 family;
	__u32 protocol;
	__u32 remote_ip4;
	__u32 remote_ip6[4];
	__u32 remote_port;
	__u32 local_ip4;
	__u32 local_ip6[4];
	__u32 local_port;
};

struct sk_reuseport_kern {
	struct sk_buff *skb;
	struct sock *sk;
	struct sock *selected_sk;
	void *data_end;
	u32 hash;
	u32 reuseport_id;
	bool bind_inany;
};

struct bpf_flow_dissector {
	struct bpf_flow_keys *flow_keys;
	const struct sk_buff *skb;
	const void *data;
	const void *data_end;
};

struct inet_listen_hashbucket {
	spinlock_t lock;
	unsigned int count;
	union {
		struct hlist_head head;
		struct hlist_nulls_head nulls_head;
	};
};

struct inet_ehash_bucket;

struct inet_bind_hashbucket;

struct inet_hashinfo {
	struct inet_ehash_bucket *ehash;
	spinlock_t *ehash_locks;
	unsigned int ehash_mask;
	unsigned int ehash_locks_mask;
	struct kmem_cache *bind_bucket_cachep;
	struct inet_bind_hashbucket *bhash;
	unsigned int bhash_size;
	unsigned int lhash2_mask;
	struct inet_listen_hashbucket *lhash2;
	long: 64;
	struct inet_listen_hashbucket listening_hash[32];
};

struct ip_ra_chain {
	struct ip_ra_chain *next;
	struct sock *sk;
	union {
		void (*destructor)(struct sock *);
		struct sock *saved_sk;
	};
	struct callback_head rcu;
};

struct fib_table {
	struct hlist_node tb_hlist;
	u32 tb_id;
	int tb_num_default;
	struct callback_head rcu;
	long unsigned int *tb_data;
	long unsigned int __data[0];
};

struct inet_peer_base {
	struct rb_root rb_root;
	seqlock_t lock;
	int total;
};

struct tcp_fastopen_context {
	siphash_key_t key[2];
	int num;
	struct callback_head rcu;
};

struct in_addr {
	__be32 s_addr;
};

struct xdp_txq_info {
	struct net_device *dev;
};

struct xdp_buff {
	void *data;
	void *data_end;
	void *data_meta;
	void *data_hard_start;
	struct xdp_rxq_info *rxq;
	struct xdp_txq_info *txq;
	u32 frame_sz;
};

struct bpf_sock_addr_kern {
	struct sock *sk;
	struct sockaddr *uaddr;
	u64 tmp_reg;
	void *t_ctx;
};

struct bpf_sock_ops_kern {
	struct sock *sk;
	union {
		u32 args[4];
		u32 reply;
		u32 replylong[4];
	};
	struct sk_buff *syn_skb;
	struct sk_buff *skb;
	void *skb_data_end;
	u8 op;
	u8 is_fullsock;
	u8 remaining_opt_len;
	u64 temp;
};

struct bpf_sysctl_kern {
	struct ctl_table_header *head;
	struct ctl_table *table;
	void *cur_val;
	size_t cur_len;
	void *new_val;
	size_t new_len;
	int new_updated;
	int write;
	loff_t *ppos;
	u64 tmp_reg;
};

struct bpf_sockopt_kern {
	struct sock *sk;
	u8 *optval;
	u8 *optval_end;
	s32 level;
	s32 optname;
	s32 optlen;
	s32 retval;
};

struct bpf_sk_lookup_kern {
	u16 family;
	u16 protocol;
	__be16 sport;
	u16 dport;
	struct {
		__be32 saddr;
		__be32 daddr;
	} v4;
	struct {
		const struct in6_addr *saddr;
		const struct in6_addr *daddr;
	} v6;
	struct sock *selected_sk;
	bool no_reuseport;
};

struct lwtunnel_state {
	__u16 type;
	__u16 flags;
	__u16 headroom;
	atomic_t refcnt;
	int (*orig_output)(struct net *, struct sock *, struct sk_buff *);
	int (*orig_input)(struct sk_buff *);
	struct callback_head rcu;
	__u8 data[0];
};

struct sock_reuseport {
	struct callback_head rcu;
	u16 max_socks;
	u16 num_socks;
	unsigned int synq_overflow_ts;
	unsigned int reuseport_id;
	unsigned int bind_inany: 1;
	unsigned int has_conns: 1;
	struct bpf_prog *prog;
	struct sock *socks[0];
};

struct sk_psock_progs {
	struct bpf_prog *msg_parser;
	struct bpf_prog *stream_parser;
	struct bpf_prog *stream_verdict;
	struct bpf_prog *skb_verdict;
};

struct strp_stats {
	long long unsigned int msgs;
	long long unsigned int bytes;
	unsigned int mem_fail;
	unsigned int need_more_hdr;
	unsigned int msg_too_big;
	unsigned int msg_timeouts;
	unsigned int bad_hdr_len;
};

struct strparser;

struct strp_callbacks {
	int (*parse_msg)(struct strparser *, struct sk_buff *);
	void (*rcv_msg)(struct strparser *, struct sk_buff *);
	int (*read_sock_done)(struct strparser *, int);
	void (*abort_parser)(struct strparser *, int);
	void (*lock)(struct strparser *);
	void (*unlock)(struct strparser *);
};

struct strparser {
	struct sock *sk;
	u32 stopped: 1;
	u32 paused: 1;
	u32 aborted: 1;
	u32 interrupted: 1;
	u32 unrecov_intr: 1;
	struct sk_buff **skb_nextp;
	struct sk_buff *skb_head;
	unsigned int need_bytes;
	struct delayed_work msg_timer_work;
	struct work_struct work;
	struct strp_stats stats;
	struct strp_callbacks cb;
};

struct sk_psock_work_state {
	struct sk_buff *skb;
	u32 len;
	u32 off;
};

struct sk_msg;

struct sk_psock {
	struct sock *sk;
	struct sock *sk_redir;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 eval;
	struct sk_msg *cork;
	struct sk_psock_progs progs;
	struct strparser strp;
	struct sk_buff_head ingress_skb;
	struct list_head ingress_msg;
	spinlock_t ingress_lock;
	long unsigned int state;
	struct list_head link;
	spinlock_t link_lock;
	refcount_t refcnt;
	void (*saved_unhash)(struct sock *);
	void (*saved_close)(struct sock *, long int);
	void (*saved_write_space)(struct sock *);
	void (*saved_data_ready)(struct sock *);
	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
	struct proto *sk_proto;
	struct mutex work_mutex;
	struct sk_psock_work_state work_state;
	struct work_struct work;
	struct rcu_work rwork;
};

struct inet_connection_sock_af_ops {
	int (*queue_xmit)(struct sock *, struct sk_buff *, struct flowi *);
	void (*send_check)(struct sock *, struct sk_buff *);
	int (*rebuild_header)(struct sock *);
	void (*sk_rx_dst_set)(struct sock *, const struct sk_buff *);
	int (*conn_request)(struct sock *, struct sk_buff *);
	struct sock * (*syn_recv_sock)(const struct sock *, struct sk_buff *, struct request_sock *, struct dst_entry *, struct request_sock *, bool *);
	u16 net_header_len;
	u16 net_frag_header_len;
	u16 sockaddr_len;
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*addr2sockaddr)(struct sock *, struct sockaddr *);
	void (*mtu_reduced)(struct sock *);
};

struct tcp_fastopen_cookie {
	__le64 val[2];
	s8 len;
	bool exp;
};

enum tcp_synack_type {
	TCP_SYNACK_NORMAL = 0,
	TCP_SYNACK_FASTOPEN = 1,
	TCP_SYNACK_COOKIE = 2,
};

struct tcp_md5sig_key;

struct tcp_request_sock_ops {
	u16 mss_clamp;
	struct tcp_md5sig_key * (*req_md5_lookup)(const struct sock *, const struct sock *);
	int (*calc_md5_hash)(char *, const struct tcp_md5sig_key *, const struct sock *, const struct sk_buff *);
	__u32 (*cookie_init_seq)(const struct sk_buff *, __u16 *);
	struct dst_entry * (*route_req)(const struct sock *, struct sk_buff *, struct flowi *, struct request_sock *);
	u32 (*init_seq)(const struct sk_buff *);
	u32 (*init_ts_off)(const struct net *, const struct sk_buff *);
	int (*send_synack)(const struct sock *, struct dst_entry *, struct flowi *, struct request_sock *, struct tcp_fastopen_cookie *, enum tcp_synack_type, struct sk_buff *);
};

union tcp_md5_addr {
	struct in_addr a4;
	struct in6_addr a6;
};

struct tcp_md5sig_key {
	struct hlist_node node;
	u8 keylen;
	u8 family;
	u8 prefixlen;
	union tcp_md5_addr addr;
	int l3index;
	u8 key[80];
	struct callback_head rcu;
};

struct ip_rt_acct {
	__u32 o_bytes;
	__u32 o_packets;
	__u32 i_bytes;
	__u32 i_packets;
};

struct inet_ehash_bucket {
	struct hlist_nulls_head chain;
};

struct inet_bind_hashbucket {
	spinlock_t lock;
	struct hlist_head chain;
};

struct ack_sample {
	u32 pkts_acked;
	s32 rtt_us;
	u32 in_flight;
};

struct rate_sample {
	u64 prior_mstamp;
	u32 prior_delivered;
	s32 delivered;
	long int interval_us;
	u32 snd_interval_us;
	u32 rcv_interval_us;
	long int rtt_us;
	int losses;
	u32 acked_sacked;
	u32 prior_in_flight;
	bool is_app_limited;
	bool is_retrans;
	bool is_ack_delayed;
};

struct sk_msg_sg {
	u32 start;
	u32 curr;
	u32 end;
	u32 size;
	u32 copybreak;
	long unsigned int copy;
	struct scatterlist data[19];
};

struct sk_msg {
	struct sk_msg_sg sg;
	void *data;
	void *data_end;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 flags;
	struct sk_buff *skb;
	struct sock *sk_redir;
	struct sock *sk;
	struct list_head list;
};

enum verifier_phase {
	CHECK_META = 0,
	CHECK_TYPE = 1,
};

struct resolve_vertex {
	const struct btf_type *t;
	u32 type_id;
	u16 next_member;
};

enum visit_state {
	NOT_VISITED = 0,
	VISITED = 1,
	RESOLVED = 2,
};

enum resolve_mode {
	RESOLVE_TBD = 0,
	RESOLVE_PTR = 1,
	RESOLVE_STRUCT_OR_ARRAY = 2,
};

struct btf_sec_info {
	u32 off;
	u32 len;
};

struct btf_verifier_env {
	struct btf *btf;
	u8 *visit_states;
	struct resolve_vertex stack[32];
	struct bpf_verifier_log log;
	u32 log_type_id;
	u32 top_stack;
	enum verifier_phase phase;
	enum resolve_mode resolve_mode;
};

struct btf_show {
	u64 flags;
	void *target;
	void (*showfn)(struct btf_show *, const char *, va_list);
	const struct btf *btf;
	struct {
		u8 depth;
		u8 depth_to_show;
		u8 depth_check;
		u8 array_member: 1;
		u8 array_terminated: 1;
		u16 array_encoding;
		u32 type_id;
		int status;
		const struct btf_type *type;
		const struct btf_member *member;
		char name[80];
	} state;
	struct {
		u32 size;
		void *head;
		void *data;
		u8 safe[32];
	} obj;
};

struct btf_kind_operations {
	s32 (*check_meta)(struct btf_verifier_env *, const struct btf_type *, u32);
	int (*resolve)(struct btf_verifier_env *, const struct resolve_vertex *);
	int (*check_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	int (*check_kflag_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	void (*log_details)(struct btf_verifier_env *, const struct btf_type *);
	void (*show)(const struct btf *, const struct btf_type *, u32, void *, u8, struct btf_show *);
};

struct bpf_ctx_convert {
	struct __sk_buff BPF_PROG_TYPE_SOCKET_FILTER_prog;
	struct sk_buff BPF_PROG_TYPE_SOCKET_FILTER_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_CLS_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_CLS_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_ACT_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_ACT_kern;
	struct xdp_md BPF_PROG_TYPE_XDP_prog;
	struct xdp_buff BPF_PROG_TYPE_XDP_kern;
	struct __sk_buff BPF_PROG_TYPE_CGROUP_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_CGROUP_SKB_kern;
	struct bpf_sock BPF_PROG_TYPE_CGROUP_SOCK_prog;
	struct sock BPF_PROG_TYPE_CGROUP_SOCK_kern;
	struct bpf_sock_addr BPF_PROG_TYPE_CGROUP_SOCK_ADDR_prog;
	struct bpf_sock_addr_kern BPF_PROG_TYPE_CGROUP_SOCK_ADDR_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_IN_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_IN_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_OUT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_OUT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_XMIT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_XMIT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_kern;
	struct bpf_sock_ops BPF_PROG_TYPE_SOCK_OPS_prog;
	struct bpf_sock_ops_kern BPF_PROG_TYPE_SOCK_OPS_kern;
	struct __sk_buff BPF_PROG_TYPE_SK_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_SK_SKB_kern;
	struct sk_msg_md BPF_PROG_TYPE_SK_MSG_prog;
	struct sk_msg BPF_PROG_TYPE_SK_MSG_kern;
	struct __sk_buff BPF_PROG_TYPE_FLOW_DISSECTOR_prog;
	struct bpf_flow_dissector BPF_PROG_TYPE_FLOW_DISSECTOR_kern;
	bpf_user_pt_regs_t BPF_PROG_TYPE_KPROBE_prog;
	struct pt_regs BPF_PROG_TYPE_KPROBE_kern;
	__u64 BPF_PROG_TYPE_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_TRACEPOINT_kern;
	struct bpf_perf_event_data BPF_PROG_TYPE_PERF_EVENT_prog;
	struct bpf_perf_event_data_kern BPF_PROG_TYPE_PERF_EVENT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_kern;
	void *BPF_PROG_TYPE_TRACING_prog;
	void *BPF_PROG_TYPE_TRACING_kern;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_prog;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_kern;
	struct bpf_sysctl BPF_PROG_TYPE_CGROUP_SYSCTL_prog;
	struct bpf_sysctl_kern BPF_PROG_TYPE_CGROUP_SYSCTL_kern;
	struct bpf_sockopt BPF_PROG_TYPE_CGROUP_SOCKOPT_prog;
	struct bpf_sockopt_kern BPF_PROG_TYPE_CGROUP_SOCKOPT_kern;
	struct sk_reuseport_md BPF_PROG_TYPE_SK_REUSEPORT_prog;
	struct sk_reuseport_kern BPF_PROG_TYPE_SK_REUSEPORT_kern;
	struct bpf_sk_lookup BPF_PROG_TYPE_SK_LOOKUP_prog;
	struct bpf_sk_lookup_kern BPF_PROG_TYPE_SK_LOOKUP_kern;
	void *BPF_PROG_TYPE_STRUCT_OPS_prog;
	void *BPF_PROG_TYPE_STRUCT_OPS_kern;
	void *BPF_PROG_TYPE_EXT_prog;
	void *BPF_PROG_TYPE_EXT_kern;
};

enum {
	__ctx_convertBPF_PROG_TYPE_SOCKET_FILTER = 0,
	__ctx_convertBPF_PROG_TYPE_SCHED_CLS = 1,
	__ctx_convertBPF_PROG_TYPE_SCHED_ACT = 2,
	__ctx_convertBPF_PROG_TYPE_XDP = 3,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SKB = 4,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK = 5,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK_ADDR = 6,
	__ctx_convertBPF_PROG_TYPE_LWT_IN = 7,
	__ctx_convertBPF_PROG_TYPE_LWT_OUT = 8,
	__ctx_convertBPF_PROG_TYPE_LWT_XMIT = 9,
	__ctx_convertBPF_PROG_TYPE_LWT_SEG6LOCAL = 10,
	__ctx_convertBPF_PROG_TYPE_SOCK_OPS = 11,
	__ctx_convertBPF_PROG_TYPE_SK_SKB = 12,
	__ctx_convertBPF_PROG_TYPE_SK_MSG = 13,
	__ctx_convertBPF_PROG_TYPE_FLOW_DISSECTOR = 14,
	__ctx_convertBPF_PROG_TYPE_KPROBE = 15,
	__ctx_convertBPF_PROG_TYPE_TRACEPOINT = 16,
	__ctx_convertBPF_PROG_TYPE_PERF_EVENT = 17,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT = 18,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 19,
	__ctx_convertBPF_PROG_TYPE_TRACING = 20,
	__ctx_convertBPF_PROG_TYPE_CGROUP_DEVICE = 21,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SYSCTL = 22,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCKOPT = 23,
	__ctx_convertBPF_PROG_TYPE_SK_REUSEPORT = 24,
	__ctx_convertBPF_PROG_TYPE_SK_LOOKUP = 25,
	__ctx_convertBPF_PROG_TYPE_STRUCT_OPS = 26,
	__ctx_convertBPF_PROG_TYPE_EXT = 27,
	__ctx_convert_unused = 28,
};

enum bpf_struct_walk_result {
	WALK_SCALAR = 0,
	WALK_PTR = 1,
	WALK_STRUCT = 2,
};

struct btf_show_snprintf {
	struct btf_show show;
	int len_left;
	int len;
};

struct btf_module {
	struct list_head list;
	struct module *module;
	struct btf *btf;
	struct bin_attribute *sysfs_attr;
};

struct bpf_devmap_val {
	__u32 ifindex;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

enum net_device_flags {
	IFF_UP = 1,
	IFF_BROADCAST = 2,
	IFF_DEBUG = 4,
	IFF_LOOPBACK = 8,
	IFF_POINTOPOINT = 16,
	IFF_NOTRAILERS = 32,
	IFF_RUNNING = 64,
	IFF_NOARP = 128,
	IFF_PROMISC = 256,
	IFF_ALLMULTI = 512,
	IFF_MASTER = 1024,
	IFF_SLAVE = 2048,
	IFF_MULTICAST = 4096,
	IFF_PORTSEL = 8192,
	IFF_AUTOMEDIA = 16384,
	IFF_DYNAMIC = 32768,
	IFF_LOWER_UP = 65536,
	IFF_DORMANT = 131072,
	IFF_ECHO = 262144,
};

struct xdp_dev_bulk_queue {
	struct xdp_frame *q[16];
	struct list_head flush_node;
	struct net_device *dev;
	struct net_device *dev_rx;
	unsigned int count;
};

enum netdev_cmd {
	NETDEV_UP = 1,
	NETDEV_DOWN = 2,
	NETDEV_REBOOT = 3,
	NETDEV_CHANGE = 4,
	NETDEV_REGISTER = 5,
	NETDEV_UNREGISTER = 6,
	NETDEV_CHANGEMTU = 7,
	NETDEV_CHANGEADDR = 8,
	NETDEV_PRE_CHANGEADDR = 9,
	NETDEV_GOING_DOWN = 10,
	NETDEV_CHANGENAME = 11,
	NETDEV_FEAT_CHANGE = 12,
	NETDEV_BONDING_FAILOVER = 13,
	NETDEV_PRE_UP = 14,
	NETDEV_PRE_TYPE_CHANGE = 15,
	NETDEV_POST_TYPE_CHANGE = 16,
	NETDEV_POST_INIT = 17,
	NETDEV_RELEASE = 18,
	NETDEV_NOTIFY_PEERS = 19,
	NETDEV_JOIN = 20,
	NETDEV_CHANGEUPPER = 21,
	NETDEV_RESEND_IGMP = 22,
	NETDEV_PRECHANGEMTU = 23,
	NETDEV_CHANGEINFODATA = 24,
	NETDEV_BONDING_INFO = 25,
	NETDEV_PRECHANGEUPPER = 26,
	NETDEV_CHANGELOWERSTATE = 27,
	NETDEV_UDP_TUNNEL_PUSH_INFO = 28,
	NETDEV_UDP_TUNNEL_DROP_INFO = 29,
	NETDEV_CHANGE_TX_QUEUE_LEN = 30,
	NETDEV_CVLAN_FILTER_PUSH_INFO = 31,
	NETDEV_CVLAN_FILTER_DROP_INFO = 32,
	NETDEV_SVLAN_FILTER_PUSH_INFO = 33,
	NETDEV_SVLAN_FILTER_DROP_INFO = 34,
};

struct netdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct bpf_dtab;

struct bpf_dtab_netdev {
	struct net_device *dev;
	struct hlist_node index_hlist;
	struct bpf_dtab *dtab;
	struct bpf_prog *xdp_prog;
	struct callback_head rcu;
	unsigned int idx;
	struct bpf_devmap_val val;
};

struct bpf_dtab {
	struct bpf_map map;
	struct bpf_dtab_netdev **netdev_map;
	struct list_head list;
	struct hlist_head *dev_index_head;
	spinlock_t index_lock;
	unsigned int items;
	u32 n_buckets;
	long: 32;
	long: 64;
	long: 64;
};

struct bpf_cpumap_val {
	__u32 qsize;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

struct ptr_ring {
	int producer;
	spinlock_t producer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int consumer_head;
	int consumer_tail;
	spinlock_t consumer_lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int size;
	int batch;
	void **queue;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_cpu_map_entry;

struct xdp_bulk_queue {
	void *q[8];
	struct list_head flush_node;
	struct bpf_cpu_map_entry *obj;
	unsigned int count;
};

struct bpf_cpu_map;

struct bpf_cpu_map_entry {
	u32 cpu;
	int map_id;
	struct xdp_bulk_queue *bulkq;
	struct bpf_cpu_map *cmap;
	struct ptr_ring *queue;
	struct task_struct *kthread;
	struct bpf_cpumap_val value;
	struct bpf_prog *prog;
	atomic_t refcnt;
	struct callback_head rcu;
	struct work_struct kthread_stop_wq;
};

struct bpf_cpu_map {
	struct bpf_map map;
	struct bpf_cpu_map_entry **cpu_map;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rhlist_head {
	struct rhash_head rhead;
	struct rhlist_head *next;
};

struct bpf_prog_offload_ops {
	int (*insn_hook)(struct bpf_verifier_env *, int, int);
	int (*finalize)(struct bpf_verifier_env *);
	int (*replace_insn)(struct bpf_verifier_env *, u32, struct bpf_insn *);
	int (*remove_insns)(struct bpf_verifier_env *, u32, u32);
	int (*prepare)(struct bpf_prog *);
	int (*translate)(struct bpf_prog *);
	void (*destroy)(struct bpf_prog *);
};

struct bpf_offload_dev {
	const struct bpf_prog_offload_ops *ops;
	struct list_head netdevs;
	void *priv;
};

struct bpf_offload_netdev {
	struct rhash_head l;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	struct list_head progs;
	struct list_head maps;
	struct list_head offdev_netdevs;
};

struct ns_get_path_bpf_prog_args {
	struct bpf_prog *prog;
	struct bpf_prog_info *info;
};

struct ns_get_path_bpf_map_args {
	struct bpf_offloaded_map *offmap;
	struct bpf_map_info *info;
};

struct bpf_netns_link {
	struct bpf_link link;
	enum bpf_attach_type type;
	enum netns_bpf_attach_type netns_type;
	struct net *net;
	struct list_head node;
};

enum bpf_stack_build_id_status {
	BPF_STACK_BUILD_ID_EMPTY = 0,
	BPF_STACK_BUILD_ID_VALID = 1,
	BPF_STACK_BUILD_ID_IP = 2,
};

struct bpf_stack_build_id {
	__s32 status;
	unsigned char build_id[20];
	union {
		__u64 offset;
		__u64 ip;
	};
};

enum {
	BPF_F_SKIP_FIELD_MASK = 255,
	BPF_F_USER_STACK = 256,
	BPF_F_FAST_STACK_CMP = 512,
	BPF_F_REUSE_STACKID = 1024,
	BPF_F_USER_BUILD_ID = 2048,
};

enum perf_callchain_context {
	PERF_CONTEXT_HV = 4294967264,
	PERF_CONTEXT_KERNEL = 4294967168,
	PERF_CONTEXT_USER = 4294966784,
	PERF_CONTEXT_GUEST = 4294965248,
	PERF_CONTEXT_GUEST_KERNEL = 4294965120,
	PERF_CONTEXT_GUEST_USER = 4294964736,
	PERF_CONTEXT_MAX = 4294963201,
};

struct stack_map_bucket {
	struct pcpu_freelist_node fnode;
	u32 hash;
	u32 nr;
	u64 data[0];
};

struct bpf_stack_map {
	struct bpf_map map;
	void *elems;
	struct pcpu_freelist freelist;
	u32 n_buckets;
	struct stack_map_bucket *buckets[0];
	long: 64;
	long: 64;
	long: 64;
};

struct stack_map_irq_work {
	struct irq_work irq_work;
	struct mm_struct *mm;
};

typedef u64 (*btf_bpf_get_stackid)(struct pt_regs *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stackid_pe)(struct bpf_perf_event_data_kern *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack)(struct pt_regs *, void *, u32, u64);

typedef u64 (*btf_bpf_get_task_stack)(struct task_struct *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_pe)(struct bpf_perf_event_data_kern *, void *, u32, u64);

enum {
	BPF_F_SYSCTL_BASE_NAME = 1,
};

struct bpf_prog_list {
	struct list_head node;
	struct bpf_prog *prog;
	struct bpf_cgroup_link *link;
	struct bpf_cgroup_storage *storage[2];
};

struct qdisc_skb_cb {
	struct {
		unsigned int pkt_len;
		u16 slave_dev_queue_mapping;
		u16 tc_classid;
	};
	unsigned char data[20];
};

struct bpf_skb_data_end {
	struct qdisc_skb_cb qdisc_cb;
	void *data_meta;
	void *data_end;
};

struct bpf_sockopt_buf {
	u8 data[32];
};

enum {
	TCPF_ESTABLISHED = 2,
	TCPF_SYN_SENT = 4,
	TCPF_SYN_RECV = 8,
	TCPF_FIN_WAIT1 = 16,
	TCPF_FIN_WAIT2 = 32,
	TCPF_TIME_WAIT = 64,
	TCPF_CLOSE = 128,
	TCPF_CLOSE_WAIT = 256,
	TCPF_LAST_ACK = 512,
	TCPF_LISTEN = 1024,
	TCPF_CLOSING = 2048,
	TCPF_NEW_SYN_RECV = 4096,
};

typedef u64 (*btf_bpf_sysctl_get_name)(struct bpf_sysctl_kern *, char *, size_t, u64);

typedef u64 (*btf_bpf_sysctl_get_current_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_get_new_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_set_new_value)(struct bpf_sysctl_kern *, const char *, size_t);

enum sock_type {
	SOCK_STREAM = 1,
	SOCK_DGRAM = 2,
	SOCK_RAW = 3,
	SOCK_RDM = 4,
	SOCK_SEQPACKET = 5,
	SOCK_DCCP = 6,
	SOCK_PACKET = 10,
};

enum {
	IPPROTO_IP = 0,
	IPPROTO_ICMP = 1,
	IPPROTO_IGMP = 2,
	IPPROTO_IPIP = 4,
	IPPROTO_TCP = 6,
	IPPROTO_EGP = 8,
	IPPROTO_PUP = 12,
	IPPROTO_UDP = 17,
	IPPROTO_IDP = 22,
	IPPROTO_TP = 29,
	IPPROTO_DCCP = 33,
	IPPROTO_IPV6 = 41,
	IPPROTO_RSVP = 46,
	IPPROTO_GRE = 47,
	IPPROTO_ESP = 50,
	IPPROTO_AH = 51,
	IPPROTO_MTP = 92,
	IPPROTO_BEETPH = 94,
	IPPROTO_ENCAP = 98,
	IPPROTO_PIM = 103,
	IPPROTO_COMP = 108,
	IPPROTO_SCTP = 132,
	IPPROTO_UDPLITE = 136,
	IPPROTO_MPLS = 137,
	IPPROTO_ETHERNET = 143,
	IPPROTO_RAW = 255,
	IPPROTO_MPTCP = 262,
	IPPROTO_MAX = 263,
};

enum sock_flags {
	SOCK_DEAD = 0,
	SOCK_DONE = 1,
	SOCK_URGINLINE = 2,
	SOCK_KEEPOPEN = 3,
	SOCK_LINGER = 4,
	SOCK_DESTROY = 5,
	SOCK_BROADCAST = 6,
	SOCK_TIMESTAMP = 7,
	SOCK_ZAPPED = 8,
	SOCK_USE_WRITE_QUEUE = 9,
	SOCK_DBG = 10,
	SOCK_RCVTSTAMP = 11,
	SOCK_RCVTSTAMPNS = 12,
	SOCK_LOCALROUTE = 13,
	SOCK_MEMALLOC = 14,
	SOCK_TIMESTAMPING_RX_SOFTWARE = 15,
	SOCK_FASYNC = 16,
	SOCK_RXQ_OVFL = 17,
	SOCK_ZEROCOPY = 18,
	SOCK_WIFI_STATUS = 19,
	SOCK_NOFCS = 20,
	SOCK_FILTER_LOCKED = 21,
	SOCK_SELECT_ERR_QUEUE = 22,
	SOCK_RCU_FREE = 23,
	SOCK_TXTIME = 24,
	SOCK_XDP = 25,
	SOCK_TSTAMP_NEW = 26,
};

struct reuseport_array {
	struct bpf_map map;
	struct sock *ptrs[0];
};

enum bpf_struct_ops_state {
	BPF_STRUCT_OPS_STATE_INIT = 0,
	BPF_STRUCT_OPS_STATE_INUSE = 1,
	BPF_STRUCT_OPS_STATE_TOBEFREE = 2,
};

struct bpf_struct_ops_value {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_struct_ops_map {
	struct bpf_map map;
	const struct bpf_struct_ops *st_ops;
	struct mutex lock;
	struct bpf_prog **progs;
	void *image;
	struct bpf_struct_ops_value *uvalue;
	struct bpf_struct_ops_value kvalue;
};

struct bpf_struct_ops_tcp_congestion_ops {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct tcp_congestion_ops data;
};

enum perf_branch_sample_type {
	PERF_SAMPLE_BRANCH_USER = 1,
	PERF_SAMPLE_BRANCH_KERNEL = 2,
	PERF_SAMPLE_BRANCH_HV = 4,
	PERF_SAMPLE_BRANCH_ANY = 8,
	PERF_SAMPLE_BRANCH_ANY_CALL = 16,
	PERF_SAMPLE_BRANCH_ANY_RETURN = 32,
	PERF_SAMPLE_BRANCH_IND_CALL = 64,
	PERF_SAMPLE_BRANCH_ABORT_TX = 128,
	PERF_SAMPLE_BRANCH_IN_TX = 256,
	PERF_SAMPLE_BRANCH_NO_TX = 512,
	PERF_SAMPLE_BRANCH_COND = 1024,
	PERF_SAMPLE_BRANCH_CALL_STACK = 2048,
	PERF_SAMPLE_BRANCH_IND_JUMP = 4096,
	PERF_SAMPLE_BRANCH_CALL = 8192,
	PERF_SAMPLE_BRANCH_NO_FLAGS = 16384,
	PERF_SAMPLE_BRANCH_NO_CYCLES = 32768,
	PERF_SAMPLE_BRANCH_TYPE_SAVE = 65536,
	PERF_SAMPLE_BRANCH_HW_INDEX = 131072,
	PERF_SAMPLE_BRANCH_MAX = 262144,
};

enum perf_event_read_format {
	PERF_FORMAT_TOTAL_TIME_ENABLED = 1,
	PERF_FORMAT_TOTAL_TIME_RUNNING = 2,
	PERF_FORMAT_ID = 4,
	PERF_FORMAT_GROUP = 8,
	PERF_FORMAT_MAX = 16,
};

enum perf_event_ioc_flags {
	PERF_IOC_FLAG_GROUP = 1,
};

struct perf_event_header {
	__u32 type;
	__u16 misc;
	__u16 size;
};

struct perf_ns_link_info {
	__u64 dev;
	__u64 ino;
};

enum {
	NET_NS_INDEX = 0,
	UTS_NS_INDEX = 1,
	IPC_NS_INDEX = 2,
	PID_NS_INDEX = 3,
	USER_NS_INDEX = 4,
	MNT_NS_INDEX = 5,
	CGROUP_NS_INDEX = 6,
	NR_NAMESPACES = 7,
};

enum perf_event_type {
	PERF_RECORD_MMAP = 1,
	PERF_RECORD_LOST = 2,
	PERF_RECORD_COMM = 3,
	PERF_RECORD_EXIT = 4,
	PERF_RECORD_THROTTLE = 5,
	PERF_RECORD_UNTHROTTLE = 6,
	PERF_RECORD_FORK = 7,
	PERF_RECORD_READ = 8,
	PERF_RECORD_SAMPLE = 9,
	PERF_RECORD_MMAP2 = 10,
	PERF_RECORD_AUX = 11,
	PERF_RECORD_ITRACE_START = 12,
	PERF_RECORD_LOST_SAMPLES = 13,
	PERF_RECORD_SWITCH = 14,
	PERF_RECORD_SWITCH_CPU_WIDE = 15,
	PERF_RECORD_NAMESPACES = 16,
	PERF_RECORD_KSYMBOL = 17,
	PERF_RECORD_BPF_EVENT = 18,
	PERF_RECORD_CGROUP = 19,
	PERF_RECORD_TEXT_POKE = 20,
	PERF_RECORD_MAX = 21,
};

enum perf_addr_filter_action_t {
	PERF_ADDR_FILTER_ACTION_STOP = 0,
	PERF_ADDR_FILTER_ACTION_START = 1,
	PERF_ADDR_FILTER_ACTION_FILTER = 2,
};

struct perf_addr_filter {
	struct list_head entry;
	struct path path;
	long unsigned int offset;
	long unsigned int size;
	enum perf_addr_filter_action_t action;
};

struct swevent_hlist {
	struct hlist_head heads[256];
	struct callback_head callback_head;
};

struct pmu_event_list {
	raw_spinlock_t lock;
	struct list_head list;
};

struct perf_buffer {
	refcount_t refcount;
	struct callback_head callback_head;
	int nr_pages;
	int overwrite;
	int paused;
	atomic_t poll;
	local_t head;
	unsigned int nest;
	local_t events;
	local_t wakeup;
	local_t lost;
	long int watermark;
	long int aux_watermark;
	spinlock_t event_lock;
	struct list_head event_list;
	atomic_t mmap_count;
	long unsigned int mmap_locked;
	struct user_struct *mmap_user;
	long int aux_head;
	unsigned int aux_nest;
	long int aux_wakeup;
	long unsigned int aux_pgoff;
	int aux_nr_pages;
	int aux_overwrite;
	atomic_t aux_mmap_count;
	long unsigned int aux_mmap_locked;
	void (*free_aux)(void *);
	refcount_t aux_refcount;
	int aux_in_sampling;
	void **aux_pages;
	void *aux_priv;
	struct perf_event_mmap_page *user_page;
	void *data_pages[0];
};

struct match_token {
	int token;
	const char *pattern;
};

enum {
	MAX_OPT_ARGS = 3,
};

struct min_heap {
	void *data;
	int nr;
	int size;
};

struct min_heap_callbacks {
	int elem_size;
	bool (*less)(const void *, const void *);
	void (*swp)(void *, void *);
};

typedef int (*remote_function_f)(void *);

struct remote_function_call {
	struct task_struct *p;
	remote_function_f func;
	void *info;
	int ret;
};

typedef void (*event_f)(struct perf_event *, struct perf_cpu_context *, struct perf_event_context *, void *);

struct event_function_struct {
	struct perf_event *event;
	event_f func;
	void *data;
};

enum event_type_t {
	EVENT_FLEXIBLE = 1,
	EVENT_PINNED = 2,
	EVENT_TIME = 4,
	EVENT_CPU = 8,
	EVENT_ALL = 3,
};

struct __group_key {
	int cpu;
	struct cgroup *cgroup;
};

struct stop_event_data {
	struct perf_event *event;
	unsigned int restart;
};

struct perf_read_data {
	struct perf_event *event;
	bool group;
	int ret;
};

struct perf_read_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

typedef void perf_iterate_f(struct perf_event *, void *);

struct remote_output {
	struct perf_buffer *rb;
	int err;
};

struct perf_task_event {
	struct task_struct *task;
	struct perf_event_context *task_ctx;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 ppid;
		u32 tid;
		u32 ptid;
		u64 time;
	} event_id;
};

struct perf_comm_event {
	struct task_struct *task;
	char *comm;
	int comm_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
	} event_id;
};

struct perf_namespaces_event {
	struct task_struct *task;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 nr_namespaces;
		struct perf_ns_link_info link_info[7];
	} event_id;
};

struct perf_cgroup_event {
	char *path;
	int path_size;
	struct {
		struct perf_event_header header;
		u64 id;
		char path[0];
	} event_id;
};

struct perf_mmap_event {
	struct vm_area_struct *vma;
	const char *file_name;
	int file_size;
	int maj;
	int min;
	u64 ino;
	u64 ino_generation;
	u32 prot;
	u32 flags;
	u8 build_id[20];
	u32 build_id_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 start;
		u64 len;
		u64 pgoff;
	} event_id;
};

struct perf_switch_event {
	struct task_struct *task;
	struct task_struct *next_prev;
	struct {
		struct perf_event_header header;
		u32 next_prev_pid;
		u32 next_prev_tid;
	} event_id;
};

struct perf_ksymbol_event {
	const char *name;
	int name_len;
	struct {
		struct perf_event_header header;
		u64 addr;
		u32 len;
		u16 ksym_type;
		u16 flags;
	} event_id;
};

struct perf_bpf_event {
	struct bpf_prog *prog;
	struct {
		struct perf_event_header header;
		u16 type;
		u16 flags;
		u32 id;
		u8 tag[8];
	} event_id;
};

struct perf_text_poke_event {
	const void *old_bytes;
	const void *new_bytes;
	size_t pad;
	u16 old_len;
	u16 new_len;
	struct {
		struct perf_event_header header;
		u64 addr;
	} event_id;
};

struct swevent_htable {
	struct swevent_hlist *swevent_hlist;
	struct mutex hlist_mutex;
	int hlist_refcount;
	int recursion[4];
};

enum perf_probe_config {
	PERF_PROBE_CONFIG_IS_RETPROBE = 1,
	PERF_UPROBE_REF_CTR_OFFSET_BITS = 32,
	PERF_UPROBE_REF_CTR_OFFSET_SHIFT = 32,
};

enum {
	IF_ACT_NONE = 4294967295,
	IF_ACT_FILTER = 0,
	IF_ACT_START = 1,
	IF_ACT_STOP = 2,
	IF_SRC_FILE = 3,
	IF_SRC_KERNEL = 4,
	IF_SRC_FILEADDR = 5,
	IF_SRC_KERNELADDR = 6,
};

enum {
	IF_STATE_ACTION = 0,
	IF_STATE_SOURCE = 1,
	IF_STATE_END = 2,
};

struct perf_aux_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct perf_aux_event___2 {
	struct perf_event_header header;
	u64 offset;
	u64 size;
	u64 flags;
};

struct callchain_cpus_entries {
	struct callback_head callback_head;
	struct perf_callchain_entry *cpu_entries[0];
};

struct bp_cpuinfo {
	unsigned int cpu_pinned;
	unsigned int *tsk_pinned;
	unsigned int flexible;
};

struct bp_busy_slots {
	unsigned int pinned;
	unsigned int flexible;
};

struct compact_control;

struct capture_control {
	struct compact_control *cc;
	struct page *page;
};

typedef u32 uprobe_opcode_t;

struct uprobe {
	struct rb_node rb_node;
	refcount_t ref;
	struct rw_semaphore register_rwsem;
	struct rw_semaphore consumer_rwsem;
	struct list_head pending_list;
	struct uprobe_consumer *consumers;
	struct inode *inode;
	loff_t offset;
	loff_t ref_ctr_offset;
	long unsigned int flags;
	struct arch_uprobe arch;
};

struct xol_area {
	wait_queue_head_t wq;
	atomic_t slot_count;
	long unsigned int *bitmap;
	struct vm_special_mapping xol_mapping;
	struct page *pages[2];
	long unsigned int vaddr;
};

typedef long unsigned int vm_flags_t;

struct page_vma_mapped_walk {
	struct page *page;
	struct vm_area_struct *vma;
	long unsigned int address;
	pmd_t *pmd;
	pte_t *pte;
	spinlock_t *ptl;
	unsigned int flags;
};

struct compact_control {
	struct list_head freepages;
	struct list_head migratepages;
	unsigned int nr_freepages;
	unsigned int nr_migratepages;
	long unsigned int free_pfn;
	long unsigned int migrate_pfn;
	long unsigned int fast_start_pfn;
	struct zone *zone;
	long unsigned int total_migrate_scanned;
	long unsigned int total_free_scanned;
	short unsigned int fast_search_fail;
	short int search_order;
	const gfp_t gfp_mask;
	int order;
	int migratetype;
	const unsigned int alloc_flags;
	const int highest_zoneidx;
	enum migrate_mode mode;
	bool ignore_skip_hint;
	bool no_set_skip_hint;
	bool ignore_block_suitable;
	bool direct_compaction;
	bool proactive_compaction;
	bool whole_zone;
	bool contended;
	bool rescan;
	bool alloc_contig;
};

struct delayed_uprobe {
	struct list_head list;
	struct uprobe *uprobe;
	struct mm_struct *mm;
};

struct __uprobe_key {
	struct inode *inode;
	loff_t offset;
};

struct map_info {
	struct map_info *next;
	struct mm_struct *mm;
	long unsigned int vaddr;
};

struct parallel_data;

struct padata_priv {
	struct list_head list;
	struct parallel_data *pd;
	int cb_cpu;
	unsigned int seq_nr;
	int info;
	void (*parallel)(struct padata_priv *);
	void (*serial)(struct padata_priv *);
};

struct padata_cpumask {
	cpumask_var_t pcpu;
	cpumask_var_t cbcpu;
};

struct padata_shell;

struct padata_list;

struct padata_serial_queue;

struct parallel_data {
	struct padata_shell *ps;
	struct padata_list *reorder_list;
	struct padata_serial_queue *squeue;
	atomic_t refcnt;
	unsigned int seq_nr;
	unsigned int processed;
	int cpu;
	struct padata_cpumask cpumask;
	struct work_struct reorder_work;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct padata_list {
	struct list_head list;
	spinlock_t lock;
};

struct padata_serial_queue {
	struct padata_list serial;
	struct work_struct work;
	struct parallel_data *pd;
};

struct padata_instance;

struct padata_shell {
	struct padata_instance *pinst;
	struct parallel_data *pd;
	struct parallel_data *opd;
	struct list_head list;
};

struct padata_instance {
	struct hlist_node cpu_online_node;
	struct hlist_node cpu_dead_node;
	struct workqueue_struct *parallel_wq;
	struct workqueue_struct *serial_wq;
	struct list_head pslist;
	struct padata_cpumask cpumask;
	struct kobject kobj;
	struct mutex lock;
	u8 flags;
};

struct padata_mt_job {
	void (*thread_fn)(long unsigned int, long unsigned int, void *);
	void *fn_arg;
	long unsigned int start;
	long unsigned int size;
	long unsigned int align;
	long unsigned int min_chunk;
	int max_threads;
};

struct padata_work {
	struct work_struct pw_work;
	struct list_head pw_list;
	void *pw_data;
};

struct padata_mt_job_state {
	spinlock_t lock;
	struct completion completion;
	struct padata_mt_job *job;
	int nworks;
	int nworks_fini;
	long unsigned int chunk_size;
};

struct padata_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct padata_instance *, struct attribute *, char *);
	ssize_t (*store)(struct padata_instance *, struct attribute *, const char *, size_t);
};

struct static_key_mod {
	struct static_key_mod *next;
	struct jump_entry *entries;
	struct module *mod;
};

struct static_key_deferred {
	struct static_key key;
	long unsigned int timeout;
	struct delayed_work work;
};

enum rseq_cpu_id_state {
	RSEQ_CPU_ID_UNINITIALIZED = 4294967295,
	RSEQ_CPU_ID_REGISTRATION_FAILED = 4294967294,
};

enum rseq_flags {
	RSEQ_FLAG_UNREGISTER = 1,
};

enum rseq_cs_flags {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL = 2,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE = 4,
};

struct rseq_cs {
	__u32 version;
	__u32 flags;
	__u64 start_ip;
	__u64 post_commit_offset;
	__u64 abort_ip;
};

struct trace_event_raw_rseq_update {
	struct trace_entry ent;
	s32 cpu_id;
	char __data[0];
};

struct trace_event_raw_rseq_ip_fixup {
	struct trace_entry ent;
	long unsigned int regs_ip;
	long unsigned int start_ip;
	long unsigned int post_commit_offset;
	long unsigned int abort_ip;
	char __data[0];
};

struct trace_event_data_offsets_rseq_update {};

struct trace_event_data_offsets_rseq_ip_fixup {};

typedef void (*btf_trace_rseq_update)(void *, struct task_struct *);

typedef void (*btf_trace_rseq_ip_fixup)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

struct watch;

struct watch_list {
	struct callback_head rcu;
	struct hlist_head watchers;
	void (*release_watch)(struct watch *);
	spinlock_t lock;
};

enum watch_notification_type {
	WATCH_TYPE_META = 0,
	WATCH_TYPE_KEY_NOTIFY = 1,
	WATCH_TYPE__NR = 2,
};

enum watch_meta_notification_subtype {
	WATCH_META_REMOVAL_NOTIFICATION = 0,
	WATCH_META_LOSS_NOTIFICATION = 1,
};

struct watch_notification {
	__u32 type: 24;
	__u32 subtype: 8;
	__u32 info;
};

struct watch_notification_type_filter {
	__u32 type;
	__u32 info_filter;
	__u32 info_mask;
	__u32 subtype_filter[8];
};

struct watch_notification_filter {
	__u32 nr_filters;
	__u32 __reserved;
	struct watch_notification_type_filter filters[0];
};

struct watch_notification_removal {
	struct watch_notification watch;
	__u64 id;
};

struct watch_type_filter {
	enum watch_notification_type type;
	__u32 subtype_filter[1];
	__u32 info_filter;
	__u32 info_mask;
};

struct watch_filter {
	union {
		struct callback_head rcu;
		long unsigned int type_filter[2];
	};
	u32 nr_filters;
	struct watch_type_filter filters[0];
};

struct watch_queue {
	struct callback_head rcu;
	struct watch_filter *filter;
	struct pipe_inode_info *pipe;
	struct hlist_head watches;
	struct page **notes;
	long unsigned int *notes_bitmap;
	struct kref usage;
	spinlock_t lock;
	unsigned int nr_notes;
	unsigned int nr_pages;
	bool defunct;
};

struct watch {
	union {
		struct callback_head rcu;
		u32 info_id;
	};
	struct watch_queue *queue;
	struct hlist_node queue_node;
	struct watch_list *watch_list;
	struct hlist_node list_node;
	const struct cred *cred;
	void *private;
	u64 id;
	struct kref usage;
};

struct pkcs7_message;

struct __key_reference_with_attributes;

typedef struct __key_reference_with_attributes *key_ref_t;

typedef int __kernel_rwf_t;

enum positive_aop_returns {
	AOP_WRITEPAGE_ACTIVATE = 524288,
	AOP_TRUNCATED_PAGE = 524289,
};

enum iter_type {
	ITER_IOVEC = 4,
	ITER_KVEC = 8,
	ITER_BVEC = 16,
	ITER_PIPE = 32,
	ITER_DISCARD = 64,
	ITER_XARRAY = 128,
};

enum mapping_flags {
	AS_EIO = 0,
	AS_ENOSPC = 1,
	AS_MM_ALL_LOCKS = 2,
	AS_UNEVICTABLE = 3,
	AS_EXITING = 4,
	AS_NO_WRITEBACK_TAGS = 5,
	AS_THP_SUPPORT = 6,
};

struct wait_page_key {
	struct page *page;
	int bit_nr;
	int page_match;
};

struct pagevec {
	unsigned char nr;
	bool percpu_pvec_drained;
	struct page *pages[15];
};

struct fid {
	union {
		struct {
			u32 ino;
			u32 gen;
			u32 parent_ino;
			u32 parent_gen;
		} i32;
		struct {
			u32 block;
			u16 partref;
			u16 parent_partref;
			u32 generation;
			u32 parent_block;
			u32 parent_generation;
		} udf;
		__u32 raw[0];
	};
};

struct trace_event_raw_mm_filemap_op_page_cache {
	struct trace_entry ent;
	long unsigned int pfn;
	long unsigned int i_ino;
	long unsigned int index;
	dev_t s_dev;
	char __data[0];
};

struct trace_event_raw_filemap_set_wb_err {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t errseq;
	char __data[0];
};

struct trace_event_raw_file_check_and_advance_wb_err {
	struct trace_entry ent;
	struct file *file;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t old;
	errseq_t new;
	char __data[0];
};

struct trace_event_data_offsets_mm_filemap_op_page_cache {};

struct trace_event_data_offsets_filemap_set_wb_err {};

struct trace_event_data_offsets_file_check_and_advance_wb_err {};

typedef void (*btf_trace_mm_filemap_delete_from_page_cache)(void *, struct page *);

typedef void (*btf_trace_mm_filemap_add_to_page_cache)(void *, struct page *);

typedef void (*btf_trace_filemap_set_wb_err)(void *, struct address_space *, errseq_t);

typedef void (*btf_trace_file_check_and_advance_wb_err)(void *, struct file *, errseq_t);

enum behavior {
	EXCLUSIVE = 0,
	SHARED = 1,
	DROP = 2,
};

struct reciprocal_value {
	u32 m;
	u8 sh1;
	u8 sh2;
};

struct kmem_cache_order_objects {
	unsigned int x;
};

struct kmem_cache_cpu;

struct kmem_cache_node;

struct kmem_cache {
	struct kmem_cache_cpu *cpu_slab;
	slab_flags_t flags;
	long unsigned int min_partial;
	unsigned int size;
	unsigned int object_size;
	struct reciprocal_value reciprocal_size;
	unsigned int offset;
	unsigned int cpu_partial;
	struct kmem_cache_order_objects oo;
	struct kmem_cache_order_objects max;
	struct kmem_cache_order_objects min;
	gfp_t allocflags;
	int refcount;
	void (*ctor)(void *);
	unsigned int inuse;
	unsigned int align;
	unsigned int red_left_pad;
	const char *name;
	struct list_head list;
	struct kobject kobj;
	long unsigned int random;
	unsigned int remote_node_defrag_ratio;
	unsigned int *random_seq;
	unsigned int useroffset;
	unsigned int usersize;
	struct kmem_cache_node *node[64];
};

struct kmem_cache_cpu {
	void **freelist;
	long unsigned int tid;
	struct page *page;
	struct page *partial;
};

struct kmem_cache_node {
	spinlock_t list_lock;
	long unsigned int nr_partial;
	struct list_head partial;
	atomic_long_t nr_slabs;
	atomic_long_t total_objects;
	struct list_head full;
};

enum slab_state {
	DOWN = 0,
	PARTIAL = 1,
	PARTIAL_NODE = 2,
	UP = 3,
	FULL = 4,
};

struct kmalloc_info_struct {
	const char *name[3];
	unsigned int size;
};

enum oom_constraint {
	CONSTRAINT_NONE = 0,
	CONSTRAINT_CPUSET = 1,
	CONSTRAINT_MEMORY_POLICY = 2,
	CONSTRAINT_MEMCG = 3,
};

struct oom_control {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct mem_cgroup *memcg;
	const gfp_t gfp_mask;
	const int order;
	long unsigned int totalpages;
	struct task_struct *chosen;
	long int chosen_points;
	enum oom_constraint constraint;
};

struct mmu_table_batch {
	struct callback_head rcu;
	unsigned int nr;
	void *tables[0];
};

struct mmu_gather_batch {
	struct mmu_gather_batch *next;
	unsigned int nr;
	unsigned int max;
	struct page *pages[0];
};

struct mmu_gather {
	struct mm_struct *mm;
	struct mmu_table_batch *batch;
	long unsigned int start;
	long unsigned int end;
	unsigned int fullmm: 1;
	unsigned int need_flush_all: 1;
	unsigned int freed_tables: 1;
	unsigned int cleared_ptes: 1;
	unsigned int cleared_pmds: 1;
	unsigned int cleared_puds: 1;
	unsigned int cleared_p4ds: 1;
	unsigned int vma_exec: 1;
	unsigned int vma_huge: 1;
	unsigned int batch_count;
	struct mmu_gather_batch *active;
	struct mmu_gather_batch local;
	struct page *__pages[8];
};

enum compact_priority {
	COMPACT_PRIO_SYNC_FULL = 0,
	MIN_COMPACT_PRIORITY = 0,
	COMPACT_PRIO_SYNC_LIGHT = 1,
	MIN_COMPACT_COSTLY_PRIORITY = 1,
	DEF_COMPACT_PRIORITY = 1,
	COMPACT_PRIO_ASYNC = 2,
	INIT_COMPACT_PRIORITY = 2,
};

enum compact_result {
	COMPACT_NOT_SUITABLE_ZONE = 0,
	COMPACT_SKIPPED = 1,
	COMPACT_DEFERRED = 2,
	COMPACT_NO_SUITABLE_PAGE = 3,
	COMPACT_CONTINUE = 4,
	COMPACT_COMPLETE = 5,
	COMPACT_PARTIAL_SKIPPED = 6,
	COMPACT_CONTENDED = 7,
	COMPACT_SUCCESS = 8,
};

struct trace_event_raw_oom_score_adj_update {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_reclaim_retry_zone {
	struct trace_entry ent;
	int node;
	int zone_idx;
	int order;
	long unsigned int reclaimable;
	long unsigned int available;
	long unsigned int min_wmark;
	int no_progress_loops;
	bool wmark_check;
	char __data[0];
};

struct trace_event_raw_mark_victim {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_wake_reaper {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_start_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_finish_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_skip_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_compact_retry {
	struct trace_entry ent;
	int order;
	int priority;
	int result;
	int retries;
	int max_retries;
	bool ret;
	char __data[0];
};

struct trace_event_data_offsets_oom_score_adj_update {};

struct trace_event_data_offsets_reclaim_retry_zone {};

struct trace_event_data_offsets_mark_victim {};

struct trace_event_data_offsets_wake_reaper {};

struct trace_event_data_offsets_start_task_reaping {};

struct trace_event_data_offsets_finish_task_reaping {};

struct trace_event_data_offsets_skip_task_reaping {};

struct trace_event_data_offsets_compact_retry {};

typedef void (*btf_trace_oom_score_adj_update)(void *, struct task_struct *);

typedef void (*btf_trace_reclaim_retry_zone)(void *, struct zoneref *, int, long unsigned int, long unsigned int, long unsigned int, int, bool);

typedef void (*btf_trace_mark_victim)(void *, int);

typedef void (*btf_trace_wake_reaper)(void *, int);

typedef void (*btf_trace_start_task_reaping)(void *, int);

typedef void (*btf_trace_finish_task_reaping)(void *, int);

typedef void (*btf_trace_skip_task_reaping)(void *, int);

typedef void (*btf_trace_compact_retry)(void *, int, enum compact_priority, enum compact_result, int, int, bool);

enum wb_congested_state {
	WB_async_congested = 0,
	WB_sync_congested = 1,
};

enum {
	XA_CHECK_SCHED = 4096,
};

enum wb_state {
	WB_registered = 0,
	WB_writeback_running = 1,
	WB_has_dirty_io = 2,
	WB_start_all = 3,
};

enum {
	BLK_RW_ASYNC = 0,
	BLK_RW_SYNC = 1,
};

struct wb_lock_cookie {
	bool locked;
	long unsigned int flags;
};

typedef int (*writepage_t)(struct page *, struct writeback_control *, void *);

enum page_memcg_data_flags {
	MEMCG_DATA_OBJCGS = 1,
	MEMCG_DATA_KMEM = 2,
	__NR_MEMCG_DATA_FLAGS = 4,
};

struct dirty_throttle_control {
	struct wb_domain *dom;
	struct dirty_throttle_control *gdtc;
	struct bdi_writeback *wb;
	struct fprop_local_percpu *wb_completions;
	long unsigned int avail;
	long unsigned int dirty;
	long unsigned int thresh;
	long unsigned int bg_thresh;
	long unsigned int wb_dirty;
	long unsigned int wb_thresh;
	long unsigned int wb_bg_thresh;
	long unsigned int pos_ratio;
};

typedef struct {} local_lock_t;

struct trace_event_raw_mm_lru_insertion {
	struct trace_entry ent;
	struct page *page;
	long unsigned int pfn;
	enum lru_list lru;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_mm_lru_activate {
	struct trace_entry ent;
	struct page *page;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_data_offsets_mm_lru_insertion {};

struct trace_event_data_offsets_mm_lru_activate {};

typedef void (*btf_trace_mm_lru_insertion)(void *, struct page *);

typedef void (*btf_trace_mm_lru_activate)(void *, struct page *);

struct lru_rotate {
	local_lock_t lock;
	struct pagevec pvec;
};

struct lru_pvecs {
	local_lock_t lock;
	struct pagevec lru_add;
	struct pagevec lru_deactivate_file;
	struct pagevec lru_deactivate;
	struct pagevec lru_lazyfree;
	struct pagevec activate_page;
};

enum lruvec_flags {
	LRUVEC_CONGESTED = 0,
};

enum pgdat_flags {
	PGDAT_DIRTY = 0,
	PGDAT_WRITEBACK = 1,
	PGDAT_RECLAIM_LOCKED = 2,
};

struct reclaim_stat {
	unsigned int nr_dirty;
	unsigned int nr_unqueued_dirty;
	unsigned int nr_congested;
	unsigned int nr_writeback;
	unsigned int nr_immediate;
	unsigned int nr_pageout;
	unsigned int nr_activate[2];
	unsigned int nr_ref_keep;
	unsigned int nr_unmap_fail;
	unsigned int nr_lazyfree_fail;
};

enum ttu_flags {
	TTU_MIGRATION = 1,
	TTU_MUNLOCK = 2,
	TTU_SPLIT_HUGE_PMD = 4,
	TTU_IGNORE_MLOCK = 8,
	TTU_SYNC = 16,
	TTU_IGNORE_HWPOISON = 32,
	TTU_BATCH_FLUSH = 64,
	TTU_RMAP_LOCKED = 128,
	TTU_SPLIT_FREEZE = 256,
};

struct trace_event_raw_mm_vmscan_kswapd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_kswapd_wake {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_wakeup_kswapd {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_begin_template {
	struct trace_entry ent;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_end_template {
	struct trace_entry ent;
	long unsigned int nr_reclaimed;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_start {
	struct trace_entry ent;
	struct shrinker *shr;
	void *shrink;
	int nid;
	long int nr_objects_to_shrink;
	gfp_t gfp_flags;
	long unsigned int cache_items;
	long long unsigned int delta;
	long unsigned int total_scan;
	int priority;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_end {
	struct trace_entry ent;
	struct shrinker *shr;
	int nid;
	void *shrink;
	long int unused_scan;
	long int new_scan;
	int retval;
	long int total_scan;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_isolate {
	struct trace_entry ent;
	int highest_zoneidx;
	int order;
	long unsigned int nr_requested;
	long unsigned int nr_scanned;
	long unsigned int nr_skipped;
	long unsigned int nr_taken;
	isolate_mode_t isolate_mode;
	int lru;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_writepage {
	struct trace_entry ent;
	long unsigned int pfn;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_inactive {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int nr_congested;
	long unsigned int nr_immediate;
	unsigned int nr_activate0;
	unsigned int nr_activate1;
	long unsigned int nr_ref_keep;
	long unsigned int nr_unmap_fail;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_active {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_taken;
	long unsigned int nr_active;
	long unsigned int nr_deactivated;
	long unsigned int nr_referenced;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_inactive_list_is_low {
	struct trace_entry ent;
	int nid;
	int reclaim_idx;
	long unsigned int total_inactive;
	long unsigned int inactive;
	long unsigned int total_active;
	long unsigned int active;
	long unsigned int ratio;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_node_reclaim_begin {
	struct trace_entry ent;
	int nid;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_data_offsets_mm_vmscan_kswapd_sleep {};

struct trace_event_data_offsets_mm_vmscan_kswapd_wake {};

struct trace_event_data_offsets_mm_vmscan_wakeup_kswapd {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_begin_template {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_end_template {};

struct trace_event_data_offsets_mm_shrink_slab_start {};

struct trace_event_data_offsets_mm_shrink_slab_end {};

struct trace_event_data_offsets_mm_vmscan_lru_isolate {};

struct trace_event_data_offsets_mm_vmscan_writepage {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_inactive {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_active {};

struct trace_event_data_offsets_mm_vmscan_inactive_list_is_low {};

struct trace_event_data_offsets_mm_vmscan_node_reclaim_begin {};

typedef void (*btf_trace_mm_vmscan_kswapd_sleep)(void *, int);

typedef void (*btf_trace_mm_vmscan_kswapd_wake)(void *, int, int, int);

typedef void (*btf_trace_mm_vmscan_wakeup_kswapd)(void *, int, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_shrink_slab_start)(void *, struct shrinker *, struct shrink_control *, long int, long unsigned int, long long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_shrink_slab_end)(void *, struct shrinker *, int, int, long int, long int, long int);

typedef void (*btf_trace_mm_vmscan_lru_isolate)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, isolate_mode_t, int);

typedef void (*btf_trace_mm_vmscan_writepage)(void *, struct page *);

typedef void (*btf_trace_mm_vmscan_lru_shrink_inactive)(void *, int, long unsigned int, long unsigned int, struct reclaim_stat *, int, int);

typedef void (*btf_trace_mm_vmscan_lru_shrink_active)(void *, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int, int);

typedef void (*btf_trace_mm_vmscan_inactive_list_is_low)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_vmscan_node_reclaim_begin)(void *, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_node_reclaim_end)(void *, long unsigned int);

struct scan_control {
	long unsigned int nr_to_reclaim;
	nodemask_t *nodemask;
	struct mem_cgroup *target_mem_cgroup;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	unsigned int may_deactivate: 2;
	unsigned int force_deactivate: 1;
	unsigned int skipped_deactivate: 1;
	unsigned int may_writepage: 1;
	unsigned int may_unmap: 1;
	unsigned int may_swap: 1;
	unsigned int memcg_low_reclaim: 1;
	unsigned int memcg_low_skipped: 1;
	unsigned int hibernation_mode: 1;
	unsigned int compaction_ready: 1;
	unsigned int cache_trim_mode: 1;
	unsigned int file_is_tiny: 1;
	s8 order;
	s8 priority;
	s8 reclaim_idx;
	gfp_t gfp_mask;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	struct {
		unsigned int dirty;
		unsigned int unqueued_dirty;
		unsigned int congested;
		unsigned int writeback;
		unsigned int immediate;
		unsigned int file_taken;
		unsigned int taken;
	} nr;
	struct reclaim_state reclaim_state;
};

typedef enum {
	PAGE_KEEP = 0,
	PAGE_ACTIVATE = 1,
	PAGE_SUCCESS = 2,
	PAGE_CLEAN = 3,
} pageout_t;

enum page_references {
	PAGEREF_RECLAIM = 0,
	PAGEREF_RECLAIM_CLEAN = 1,
	PAGEREF_KEEP = 2,
	PAGEREF_ACTIVATE = 3,
};

enum scan_balance {
	SCAN_EQUAL = 0,
	SCAN_FRACT = 1,
	SCAN_ANON = 2,
	SCAN_FILE = 3,
};

enum transparent_hugepage_flag {
	TRANSPARENT_HUGEPAGE_NEVER_DAX = 0,
	TRANSPARENT_HUGEPAGE_FLAG = 1,
	TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG = 2,
	TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG = 3,
	TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG = 4,
	TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG = 5,
	TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG = 6,
	TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG = 7,
	TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG = 8,
};

struct xattr {
	const char *name;
	void *value;
	size_t value_len;
};

struct constant_table {
	const char *name;
	int value;
};

enum {
	MPOL_DEFAULT = 0,
	MPOL_PREFERRED = 1,
	MPOL_BIND = 2,
	MPOL_INTERLEAVE = 3,
	MPOL_LOCAL = 4,
	MPOL_MAX = 5,
};

struct shared_policy {
	struct rb_root root;
	rwlock_t lock;
};

struct simple_xattrs {
	struct list_head head;
	spinlock_t lock;
};

struct simple_xattr {
	struct list_head list;
	char *name;
	size_t size;
	char value[0];
};

struct shmem_inode_info {
	spinlock_t lock;
	unsigned int seals;
	long unsigned int flags;
	long unsigned int alloced;
	long unsigned int swapped;
	struct list_head shrinklist;
	struct list_head swaplist;
	struct shared_policy policy;
	struct simple_xattrs xattrs;
	atomic_t stop_eviction;
	struct inode vfs_inode;
};

struct shmem_sb_info {
	long unsigned int max_blocks;
	struct percpu_counter used_blocks;
	long unsigned int max_inodes;
	long unsigned int free_inodes;
	spinlock_t stat_lock;
	umode_t mode;
	unsigned char huge;
	kuid_t uid;
	kgid_t gid;
	bool full_inums;
	ino_t next_ino;
	ino_t *ino_batch;
	struct mempolicy *mpol;
	spinlock_t shrinklist_lock;
	struct list_head shrinklist;
	long unsigned int shrinklist_len;
};

enum sgp_type {
	SGP_READ = 0,
	SGP_CACHE = 1,
	SGP_NOHUGE = 2,
	SGP_HUGE = 3,
	SGP_WRITE = 4,
	SGP_FALLOC = 5,
};

enum fid_type {
	FILEID_ROOT = 0,
	FILEID_INO32_GEN = 1,
	FILEID_INO32_GEN_PARENT = 2,
	FILEID_BTRFS_WITHOUT_PARENT = 77,
	FILEID_BTRFS_WITH_PARENT = 78,
	FILEID_BTRFS_WITH_PARENT_ROOT = 79,
	FILEID_UDF_WITHOUT_PARENT = 81,
	FILEID_UDF_WITH_PARENT = 82,
	FILEID_NILFS_WITHOUT_PARENT = 97,
	FILEID_NILFS_WITH_PARENT = 98,
	FILEID_FAT_WITHOUT_PARENT = 113,
	FILEID_FAT_WITH_PARENT = 114,
	FILEID_LUSTRE = 151,
	FILEID_KERNFS = 254,
	FILEID_INVALID = 255,
};

struct shmem_falloc {
	wait_queue_head_t *waitq;
	long unsigned int start;
	long unsigned int next;
	long unsigned int nr_falloced;
	long unsigned int nr_unswapped;
};

struct shmem_options {
	long long unsigned int blocks;
	long long unsigned int inodes;
	struct mempolicy *mpol;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	bool full_inums;
	int huge;
	int seen;
};

enum shmem_param {
	Opt_gid = 0,
	Opt_huge = 1,
	Opt_mode = 2,
	Opt_mpol = 3,
	Opt_nr_blocks = 4,
	Opt_nr_inodes = 5,
	Opt_size = 6,
	Opt_uid = 7,
	Opt_inode32 = 8,
	Opt_inode64 = 9,
};

enum writeback_stat_item {
	NR_DIRTY_THRESHOLD = 0,
	NR_DIRTY_BG_THRESHOLD = 1,
	NR_VM_WRITEBACK_STAT_ITEMS = 2,
};

struct contig_page_info {
	long unsigned int free_pages;
	long unsigned int free_blocks_total;
	long unsigned int free_blocks_suitable;
};

struct radix_tree_iter {
	long unsigned int index;
	long unsigned int next_index;
	long unsigned int tags;
	struct xa_node *node;
};

enum {
	RADIX_TREE_ITER_TAG_MASK = 15,
	RADIX_TREE_ITER_TAGGED = 16,
	RADIX_TREE_ITER_CONTIG = 32,
};

struct pcpu_group_info {
	int nr_units;
	long unsigned int base_offset;
	unsigned int *cpu_map;
};

struct pcpu_alloc_info {
	size_t static_size;
	size_t reserved_size;
	size_t dyn_size;
	size_t unit_size;
	size_t atom_size;
	size_t alloc_size;
	size_t __ai_size;
	int nr_groups;
	struct pcpu_group_info groups[0];
};

typedef void * (*pcpu_fc_alloc_fn_t)(unsigned int, size_t, size_t);

typedef void (*pcpu_fc_free_fn_t)(void *, size_t);

typedef int pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);

struct trace_event_raw_percpu_alloc_percpu {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_free_percpu {
	struct trace_entry ent;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_alloc_percpu_fail {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	char __data[0];
};

struct trace_event_raw_percpu_create_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_raw_percpu_destroy_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_data_offsets_percpu_alloc_percpu {};

struct trace_event_data_offsets_percpu_free_percpu {};

struct trace_event_data_offsets_percpu_alloc_percpu_fail {};

struct trace_event_data_offsets_percpu_create_chunk {};

struct trace_event_data_offsets_percpu_destroy_chunk {};

typedef void (*btf_trace_percpu_alloc_percpu)(void *, bool, bool, size_t, size_t, void *, int, void *);

typedef void (*btf_trace_percpu_free_percpu)(void *, void *, int, void *);

typedef void (*btf_trace_percpu_alloc_percpu_fail)(void *, bool, bool, size_t, size_t);

typedef void (*btf_trace_percpu_create_chunk)(void *, void *);

typedef void (*btf_trace_percpu_destroy_chunk)(void *, void *);

enum pcpu_chunk_type {
	PCPU_CHUNK_ROOT = 0,
	PCPU_CHUNK_MEMCG = 1,
	PCPU_NR_CHUNK_TYPES = 2,
	PCPU_FAIL_ALLOC = 2,
};

struct pcpu_block_md {
	int scan_hint;
	int scan_hint_start;
	int contig_hint;
	int contig_hint_start;
	int left_free;
	int right_free;
	int first_free;
	int nr_bits;
};

struct pcpu_chunk {
	struct list_head list;
	int free_bytes;
	struct pcpu_block_md chunk_md;
	void *base_addr;
	long unsigned int *alloc_map;
	long unsigned int *bound_map;
	struct pcpu_block_md *md_blocks;
	void *data;
	bool immutable;
	int start_offset;
	int end_offset;
	struct obj_cgroup **obj_cgroups;
	int nr_pages;
	int nr_populated;
	int nr_empty_pop_pages;
	long unsigned int populated[0];
};

struct trace_event_raw_kmem_alloc {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_kmem_alloc_node {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	gfp_t gfp_flags;
	int node;
	char __data[0];
};

struct trace_event_raw_kfree {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	char __data[0];
};

struct trace_event_raw_kmem_cache_free {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_mm_page_free {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	char __data[0];
};

struct trace_event_raw_mm_page_free_batched {
	struct trace_entry ent;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	gfp_t gfp_flags;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_pcpu_drain {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc_extfrag {
	struct trace_entry ent;
	long unsigned int pfn;
	int alloc_order;
	int fallback_order;
	int alloc_migratetype;
	int fallback_migratetype;
	int change_ownership;
	char __data[0];
};

struct trace_event_raw_rss_stat {
	struct trace_entry ent;
	unsigned int mm_id;
	unsigned int curr;
	int member;
	long int size;
	char __data[0];
};

struct trace_event_data_offsets_kmem_alloc {};

struct trace_event_data_offsets_kmem_alloc_node {};

struct trace_event_data_offsets_kfree {};

struct trace_event_data_offsets_kmem_cache_free {
	u32 name;
};

struct trace_event_data_offsets_mm_page_free {};

struct trace_event_data_offsets_mm_page_free_batched {};

struct trace_event_data_offsets_mm_page_alloc {};

struct trace_event_data_offsets_mm_page {};

struct trace_event_data_offsets_mm_page_pcpu_drain {};

struct trace_event_data_offsets_mm_page_alloc_extfrag {};

struct trace_event_data_offsets_rss_stat {};

typedef void (*btf_trace_kmalloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t);

typedef void (*btf_trace_kmem_cache_alloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t);

typedef void (*btf_trace_kmalloc_node)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kmem_cache_alloc_node)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kfree)(void *, long unsigned int, const void *);

typedef void (*btf_trace_kmem_cache_free)(void *, long unsigned int, const void *, const char *);

typedef void (*btf_trace_mm_page_free)(void *, struct page *, unsigned int);

typedef void (*btf_trace_mm_page_free_batched)(void *, struct page *);

typedef void (*btf_trace_mm_page_alloc)(void *, struct page *, unsigned int, gfp_t, int);

typedef void (*btf_trace_mm_page_alloc_zone_locked)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_page_pcpu_drain)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_page_alloc_extfrag)(void *, struct page *, int, int, int, int);

typedef void (*btf_trace_rss_stat)(void *, struct mm_struct *, int, long int);

struct slabinfo {
	long unsigned int active_objs;
	long unsigned int num_objs;
	long unsigned int active_slabs;
	long unsigned int num_slabs;
	long unsigned int shared_avail;
	unsigned int limit;
	unsigned int batchcount;
	unsigned int shared;
	unsigned int objects_per_slab;
	unsigned int cache_order;
};

struct kmem_obj_info {
	void *kp_ptr;
	struct page *kp_page;
	void *kp_objp;
	long unsigned int kp_data_offset;
	struct kmem_cache *kp_slab_cache;
	void *kp_ret;
	void *kp_stack[16];
};

enum pageblock_bits {
	PB_migrate = 0,
	PB_migrate_end = 2,
	PB_migrate_skip = 3,
	NR_PAGEBLOCK_BITS = 4,
};

struct alloc_context {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct zoneref *preferred_zoneref;
	int migratetype;
	enum zone_type highest_zoneidx;
	bool spread_dirty_pages;
};

struct trace_event_raw_mm_compaction_isolate_template {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int nr_scanned;
	long unsigned int nr_taken;
	char __data[0];
};

struct trace_event_raw_mm_compaction_migratepages {
	struct trace_entry ent;
	long unsigned int nr_migrated;
	long unsigned int nr_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_begin {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	char __data[0];
};

struct trace_event_raw_mm_compaction_end {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_compaction_try_to_compact_pages {
	struct trace_entry ent;
	int order;
	gfp_t gfp_mask;
	int prio;
	char __data[0];
};

struct trace_event_raw_mm_compaction_suitable_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	int ret;
	char __data[0];
};

struct trace_event_raw_mm_compaction_defer_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	unsigned int considered;
	unsigned int defer_shift;
	int order_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_kcompactd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_kcompactd_wake_template {
	struct trace_entry ent;
	int nid;
	int order;
	enum zone_type highest_zoneidx;
	char __data[0];
};

struct trace_event_data_offsets_mm_compaction_isolate_template {};

struct trace_event_data_offsets_mm_compaction_migratepages {};

struct trace_event_data_offsets_mm_compaction_begin {};

struct trace_event_data_offsets_mm_compaction_end {};

struct trace_event_data_offsets_mm_compaction_try_to_compact_pages {};

struct trace_event_data_offsets_mm_compaction_suitable_template {};

struct trace_event_data_offsets_mm_compaction_defer_template {};

struct trace_event_data_offsets_mm_compaction_kcompactd_sleep {};

struct trace_event_data_offsets_kcompactd_wake_template {};

typedef void (*btf_trace_mm_compaction_isolate_migratepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_migratepages)(void *, long unsigned int, int, struct list_head *);

typedef void (*btf_trace_mm_compaction_begin)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, bool);

typedef void (*btf_trace_mm_compaction_end)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, bool, int);

typedef void (*btf_trace_mm_compaction_try_to_compact_pages)(void *, int, gfp_t, int);

typedef void (*btf_trace_mm_compaction_finished)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_suitable)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_deferred)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_compaction)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_reset)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_kcompactd_sleep)(void *, int);

typedef void (*btf_trace_mm_compaction_wakeup_kcompactd)(void *, int, int, enum zone_type);

typedef void (*btf_trace_mm_compaction_kcompactd_wake)(void *, int, int, enum zone_type);

typedef enum {
	ISOLATE_ABORT = 0,
	ISOLATE_NONE = 1,
	ISOLATE_SUCCESS = 2,
} isolate_migrate_t;

struct anon_vma_chain {
	struct vm_area_struct *vma;
	struct anon_vma *anon_vma;
	struct list_head same_vma;
	struct rb_node rb;
	long unsigned int rb_subtree_last;
};

struct rb_augment_callbacks {
	void (*propagate)(struct rb_node *, struct rb_node *);
	void (*copy)(struct rb_node *, struct rb_node *);
	void (*rotate)(struct rb_node *, struct rb_node *);
};

enum lru_status {
	LRU_REMOVED = 0,
	LRU_REMOVED_RETRY = 1,
	LRU_ROTATE = 2,
	LRU_SKIP = 3,
	LRU_RETRY = 4,
};

typedef enum lru_status (*list_lru_walk_cb)(struct list_head *, struct list_lru_one *, spinlock_t *, void *);

typedef struct {
	long unsigned int pd;
} hugepd_t;

struct migration_target_control {
	int nid;
	nodemask_t *nmask;
	gfp_t gfp_mask;
};

struct follow_page_context {
	struct dev_pagemap *pgmap;
	unsigned int page_mask;
};

struct trace_event_raw_mmap_lock_start_locking {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	char __data[0];
};

struct trace_event_raw_mmap_lock_acquire_returned {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	bool success;
	char __data[0];
};

struct trace_event_raw_mmap_lock_released {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	char __data[0];
};

struct trace_event_data_offsets_mmap_lock_start_locking {
	u32 memcg_path;
};

struct trace_event_data_offsets_mmap_lock_acquire_returned {
	u32 memcg_path;
};

struct trace_event_data_offsets_mmap_lock_released {
	u32 memcg_path;
};

typedef void (*btf_trace_mmap_lock_start_locking)(void *, struct mm_struct *, const char *, bool);

typedef void (*btf_trace_mmap_lock_acquire_returned)(void *, struct mm_struct *, const char *, bool, bool);

typedef void (*btf_trace_mmap_lock_released)(void *, struct mm_struct *, const char *, bool);

struct memcg_path {
	local_lock_t lock;
	char *buf;
	local_t buf_idx;
};

typedef struct {
	u64 val;
} pfn_t;

typedef unsigned int pgtbl_mod_mask;

struct zap_details {
	struct address_space *check_mapping;
	long unsigned int first_index;
	long unsigned int last_index;
	struct page *single_page;
};

typedef int (*pte_fn_t)(pte_t *, long unsigned int, void *);

enum {
	SWP_USED = 1,
	SWP_WRITEOK = 2,
	SWP_DISCARDABLE = 4,
	SWP_DISCARDING = 8,
	SWP_SOLIDSTATE = 16,
	SWP_CONTINUED = 32,
	SWP_BLKDEV = 64,
	SWP_ACTIVATED = 128,
	SWP_FS_OPS = 256,
	SWP_AREA_DISCARD = 512,
	SWP_PAGE_DISCARD = 1024,
	SWP_STABLE_WRITES = 2048,
	SWP_SYNCHRONOUS_IO = 4096,
	SWP_VALID = 8192,
	SWP_SCANNING = 16384,
};

struct copy_subpage_arg {
	struct page *dst;
	struct page *src;
	struct vm_area_struct *vma;
};

struct mm_walk;

struct mm_walk_ops {
	int (*pgd_entry)(pgd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*p4d_entry)(p4d_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pud_entry)(pud_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pmd_entry)(pmd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_entry)(pte_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_hole)(long unsigned int, long unsigned int, int, struct mm_walk *);
	int (*hugetlb_entry)(pte_t *, long unsigned int, long unsigned int, long unsigned int, struct mm_walk *);
	int (*test_walk)(long unsigned int, long unsigned int, struct mm_walk *);
	int (*pre_vma)(long unsigned int, long unsigned int, struct mm_walk *);
	void (*post_vma)(struct mm_walk *);
};

enum page_walk_action {
	ACTION_SUBTREE = 0,
	ACTION_CONTINUE = 1,
	ACTION_AGAIN = 2,
};

struct mm_walk {
	const struct mm_walk_ops *ops;
	struct mm_struct *mm;
	pgd_t *pgd;
	struct vm_area_struct *vma;
	enum page_walk_action action;
	bool no_vma;
	void *private;
};

struct vm_unmapped_area_info {
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
};

enum {
	HUGETLB_SHMFS_INODE = 1,
	HUGETLB_ANONHUGE_INODE = 2,
};

struct trace_event_raw_vm_unmapped_area {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int total_vm;
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
	char __data[0];
};

struct trace_event_data_offsets_vm_unmapped_area {};

typedef void (*btf_trace_vm_unmapped_area)(void *, long unsigned int, struct vm_unmapped_area_info *);

enum pgt_entry {
	NORMAL_PMD = 0,
	HPAGE_PMD = 1,
	NORMAL_PUD = 2,
};

struct rmap_walk_control {
	void *arg;
	bool (*rmap_one)(struct page *, struct vm_area_struct *, long unsigned int, void *);
	int (*done)(struct page *);
	struct anon_vma * (*anon_lock)(struct page *);
	bool (*invalid_vma)(struct vm_area_struct *, void *);
};

struct page_referenced_arg {
	int mapcount;
	int referenced;
	long unsigned int vm_flags;
	struct mem_cgroup *memcg;
};

struct vmap_area {
	long unsigned int va_start;
	long unsigned int va_end;
	struct rb_node rb_node;
	struct list_head list;
	union {
		long unsigned int subtree_max_size;
		struct vm_struct *vm;
	};
};

struct vfree_deferred {
	struct llist_head list;
	struct work_struct wq;
};

enum fit_type {
	NOTHING_FIT = 0,
	FL_FIT_TYPE = 1,
	LE_FIT_TYPE = 2,
	RE_FIT_TYPE = 3,
	NE_FIT_TYPE = 4,
};

struct vmap_block_queue {
	spinlock_t lock;
	struct list_head free;
};

struct vmap_block {
	spinlock_t lock;
	struct vmap_area *va;
	long unsigned int free;
	long unsigned int dirty;
	long unsigned int dirty_min;
	long unsigned int dirty_max;
	struct list_head free_list;
	struct callback_head callback_head;
	struct list_head purge;
};

struct page_frag_cache {
	void *va;
	__u16 offset;
	__u16 size;
	unsigned int pagecnt_bias;
	bool pfmemalloc;
};

enum zone_flags {
	ZONE_BOOSTED_WATERMARK = 0,
};

enum mminit_level {
	MMINIT_WARNING = 0,
	MMINIT_VERIFY = 1,
	MMINIT_TRACE = 2,
};

typedef int fpi_t;

struct pcpu_drain {
	struct zone *zone;
	struct work_struct work;
};

struct mminit_pfnnid_cache {
	long unsigned int last_start;
	long unsigned int last_end;
	int last_nid;
};

enum {
	MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE = 12,
	SECTION_INFO = 12,
	MIX_SECTION_INFO = 13,
	NODE_INFO = 14,
	MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE = 14,
};

enum {
	MMOP_OFFLINE = 0,
	MMOP_ONLINE = 1,
	MMOP_ONLINE_KERNEL = 2,
	MMOP_ONLINE_MOVABLE = 3,
};

typedef int mhp_t;

typedef void (*online_page_callback_t)(struct page *, unsigned int);

struct memory_block {
	long unsigned int start_section_nr;
	long unsigned int state;
	int online_type;
	int nid;
	struct device dev;
	long unsigned int nr_vmemmap_pages;
};

enum hugetlb_page_flags {
	HPG_restore_reserve = 0,
	HPG_migratable = 1,
	HPG_temporary = 2,
	HPG_freed = 3,
	__NR_HPAGEFLAGS = 4,
};

enum mf_flags {
	MF_COUNT_INCREASED = 1,
	MF_ACTION_REQUIRED = 2,
	MF_MUST_KILL = 4,
	MF_SOFT_OFFLINE = 8,
};

struct madvise_walk_private {
	struct mmu_gather *tlb;
	bool pageout;
};

enum {
	BIO_NO_PAGE_REF = 0,
	BIO_CLONED = 1,
	BIO_BOUNCED = 2,
	BIO_WORKINGSET = 3,
	BIO_QUIET = 4,
	BIO_CHAIN = 5,
	BIO_REFFED = 6,
	BIO_THROTTLED = 7,
	BIO_TRACE_COMPLETION = 8,
	BIO_CGROUP_ACCT = 9,
	BIO_TRACKED = 10,
	BIO_REMAPPED = 11,
	BIO_ZONE_WRITE_LOCKED = 12,
	BIO_FLAG_LAST = 13,
};

struct vma_swap_readahead {
	short unsigned int win;
	short unsigned int offset;
	short unsigned int nr_pte;
	pte_t *ptes;
};

union swap_header {
	struct {
		char reserved[4086];
		char magic[10];
	} magic;
	struct {
		char bootbits[1024];
		__u32 version;
		__u32 last_page;
		__u32 nr_badpages;
		unsigned char sws_uuid[16];
		unsigned char sws_volume[16];
		__u32 padding[117];
		__u32 badpages[1];
	} info;
};

struct swap_extent {
	struct rb_node rb_node;
	long unsigned int start_page;
	long unsigned int nr_pages;
	sector_t start_block;
};

struct swap_slots_cache {
	bool lock_initialized;
	struct mutex alloc_lock;
	swp_entry_t *slots;
	int nr;
	int cur;
	spinlock_t free_lock;
	swp_entry_t *slots_ret;
	int n_ret;
};

struct frontswap_ops {
	void (*init)(unsigned int);
	int (*store)(unsigned int, long unsigned int, struct page *);
	int (*load)(unsigned int, long unsigned int, struct page *);
	void (*invalidate_page)(unsigned int, long unsigned int);
	void (*invalidate_area)(unsigned int);
	struct frontswap_ops *next;
};

struct crypto_async_request;

typedef void (*crypto_completion_t)(struct crypto_async_request *, int);

struct crypto_async_request {
	struct list_head list;
	crypto_completion_t complete;
	void *data;
	struct crypto_tfm *tfm;
	u32 flags;
};

struct crypto_wait {
	struct completion completion;
	int err;
};

struct zpool;

struct zpool_ops {
	int (*evict)(struct zpool *, long unsigned int);
};

enum zpool_mapmode {
	ZPOOL_MM_RW = 0,
	ZPOOL_MM_RO = 1,
	ZPOOL_MM_WO = 2,
	ZPOOL_MM_DEFAULT = 0,
};

struct acomp_req {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int slen;
	unsigned int dlen;
	u32 flags;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_acomp {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	unsigned int reqsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct crypto_acomp_ctx {
	struct crypto_acomp *acomp;
	struct acomp_req *req;
	struct crypto_wait wait;
	u8 *dstmem;
	struct mutex *mutex;
};

struct zswap_pool {
	struct zpool *zpool;
	struct crypto_acomp_ctx *acomp_ctx;
	struct kref kref;
	struct list_head list;
	struct work_struct release_work;
	struct work_struct shrink_work;
	struct hlist_node node;
	char tfm_name[128];
};

struct zswap_entry {
	struct rb_node rbnode;
	long unsigned int offset;
	int refcount;
	unsigned int length;
	struct zswap_pool *pool;
	union {
		long unsigned int handle;
		long unsigned int value;
	};
};

struct zswap_header {
	swp_entry_t swpentry;
};

struct zswap_tree {
	struct rb_root rbroot;
	spinlock_t lock;
};

enum zswap_get_swap_ret {
	ZSWAP_SWAPCACHE_NEW = 0,
	ZSWAP_SWAPCACHE_EXIST = 1,
	ZSWAP_SWAPCACHE_FAIL = 2,
};

struct dma_pool {
	struct list_head page_list;
	spinlock_t lock;
	size_t size;
	struct device *dev;
	size_t allocation;
	size_t boundary;
	char name[32];
	struct list_head pools;
};

struct dma_page {
	struct list_head page_list;
	void *vaddr;
	dma_addr_t dma;
	unsigned int in_use;
	unsigned int offset;
};

enum string_size_units {
	STRING_UNITS_10 = 0,
	STRING_UNITS_2 = 1,
};

enum mcopy_atomic_mode {
	MCOPY_ATOMIC_NORMAL = 0,
	MCOPY_ATOMIC_ZEROPAGE = 1,
	MCOPY_ATOMIC_CONTINUE = 2,
};

struct resv_map {
	struct kref refs;
	spinlock_t lock;
	struct list_head regions;
	long int adds_in_progress;
	struct list_head region_cache;
	long int region_cache_count;
	struct page_counter *reservation_counter;
	long unsigned int pages_per_hpage;
	struct cgroup_subsys_state *css;
};

struct file_region {
	struct list_head link;
	long int from;
	long int to;
	struct page_counter *reservation_counter;
	struct cgroup_subsys_state *css;
};

struct huge_bootmem_page {
	struct list_head list;
	struct hstate *hstate;
};

enum hugetlb_memory_event {
	HUGETLB_MAX = 0,
	HUGETLB_NR_MEMORY_EVENTS = 1,
};

struct hugetlb_cgroup {
	struct cgroup_subsys_state css;
	struct page_counter hugepage[4];
	struct page_counter rsvd_hugepage[4];
	atomic_long_t events[4];
	atomic_long_t events_local[4];
	struct cgroup_file events_file[4];
	struct cgroup_file events_local_file[4];
};

enum vma_resv_mode {
	VMA_NEEDS_RESV = 0,
	VMA_COMMIT_RESV = 1,
	VMA_END_RESV = 2,
	VMA_ADD_RESV = 3,
	VMA_DEL_RESV = 4,
};

struct node_hstate {
	struct kobject *hugepages_kobj;
	struct kobject *hstate_kobjs[4];
};

struct nodemask_scratch {
	nodemask_t mask1;
	nodemask_t mask2;
};

struct sp_node {
	struct rb_node nd;
	long unsigned int start;
	long unsigned int end;
	struct mempolicy *policy;
};

struct mempolicy_operations {
	int (*create)(struct mempolicy *, const nodemask_t *);
	void (*rebind)(struct mempolicy *, const nodemask_t *);
};

struct queue_pages {
	struct list_head *pagelist;
	long unsigned int flags;
	nodemask_t *nmask;
	long unsigned int start;
	long unsigned int end;
	struct vm_area_struct *first;
};

struct mmu_notifier_subscriptions {
	struct hlist_head list;
	bool has_itree;
	spinlock_t lock;
	long unsigned int invalidate_seq;
	long unsigned int active_invalidate_ranges;
	struct rb_root_cached itree;
	wait_queue_head_t wq;
	struct hlist_head deferred_list;
};

struct interval_tree_node {
	struct rb_node rb;
	long unsigned int start;
	long unsigned int last;
	long unsigned int __subtree_last;
};

struct mmu_interval_notifier;

struct mmu_interval_notifier_ops {
	bool (*invalidate)(struct mmu_interval_notifier *, const struct mmu_notifier_range *, long unsigned int);
};

struct mmu_interval_notifier {
	struct interval_tree_node interval_tree;
	const struct mmu_interval_notifier_ops *ops;
	struct mm_struct *mm;
	struct hlist_node deferred_item;
	long unsigned int invalidate_seq;
};

struct rmap_item;

struct mm_slot {
	struct hlist_node link;
	struct list_head mm_list;
	struct rmap_item *rmap_list;
	struct mm_struct *mm;
};

struct stable_node;

struct rmap_item {
	struct rmap_item *rmap_list;
	union {
		struct anon_vma *anon_vma;
		int nid;
	};
	struct mm_struct *mm;
	long unsigned int address;
	unsigned int oldchecksum;
	union {
		struct rb_node node;
		struct {
			struct stable_node *head;
			struct hlist_node hlist;
		};
	};
};

struct ksm_scan {
	struct mm_slot *mm_slot;
	long unsigned int address;
	struct rmap_item **rmap_list;
	long unsigned int seqnr;
};

struct stable_node {
	union {
		struct rb_node node;
		struct {
			struct list_head *head;
			struct {
				struct hlist_node hlist_dup;
				struct list_head list;
			};
		};
	};
	struct hlist_head hlist;
	union {
		long unsigned int kpfn;
		long unsigned int chain_prune_time;
	};
	int rmap_hlist_len;
	int nid;
};

enum get_ksm_page_flags {
	GET_KSM_PAGE_NOLOCK = 0,
	GET_KSM_PAGE_LOCK = 1,
	GET_KSM_PAGE_TRYLOCK = 2,
};

enum stat_item {
	ALLOC_FASTPATH = 0,
	ALLOC_SLOWPATH = 1,
	FREE_FASTPATH = 2,
	FREE_SLOWPATH = 3,
	FREE_FROZEN = 4,
	FREE_ADD_PARTIAL = 5,
	FREE_REMOVE_PARTIAL = 6,
	ALLOC_FROM_PARTIAL = 7,
	ALLOC_SLAB = 8,
	ALLOC_REFILL = 9,
	ALLOC_NODE_MISMATCH = 10,
	FREE_SLAB = 11,
	CPUSLAB_FLUSH = 12,
	DEACTIVATE_FULL = 13,
	DEACTIVATE_EMPTY = 14,
	DEACTIVATE_TO_HEAD = 15,
	DEACTIVATE_TO_TAIL = 16,
	DEACTIVATE_REMOTE_FREES = 17,
	DEACTIVATE_BYPASS = 18,
	ORDER_FALLBACK = 19,
	CMPXCHG_DOUBLE_CPU_FAIL = 20,
	CMPXCHG_DOUBLE_FAIL = 21,
	CPU_PARTIAL_ALLOC = 22,
	CPU_PARTIAL_FREE = 23,
	CPU_PARTIAL_NODE = 24,
	CPU_PARTIAL_DRAIN = 25,
	NR_SLUB_STAT_ITEMS = 26,
};

struct track {
	long unsigned int addr;
	long unsigned int addrs[16];
	int cpu;
	int pid;
	long unsigned int when;
};

enum track_item {
	TRACK_ALLOC = 0,
	TRACK_FREE = 1,
};

struct detached_freelist {
	struct page *page;
	void *tail;
	void *freelist;
	int cnt;
	struct kmem_cache *s;
};

struct location {
	long unsigned int count;
	long unsigned int addr;
	long long int sum_time;
	long int min_time;
	long int max_time;
	long int min_pid;
	long int max_pid;
	long unsigned int cpus[4];
	nodemask_t nodes;
};

struct loc_track {
	long unsigned int max;
	long unsigned int count;
	struct location *loc;
};

enum slab_stat_type {
	SL_ALL = 0,
	SL_PARTIAL = 1,
	SL_CPU = 2,
	SL_OBJECTS = 3,
	SL_TOTAL = 4,
};

struct slab_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kmem_cache *, char *);
	ssize_t (*store)(struct kmem_cache *, const char *, size_t);
};

struct saved_alias {
	struct kmem_cache *s;
	const char *name;
	struct saved_alias *next;
};

enum slab_modes {
	M_NONE = 0,
	M_PARTIAL = 1,
	M_FULL = 2,
	M_FREE = 3,
};

struct buffer_head;

typedef void bh_end_io_t(struct buffer_head *, int);

struct buffer_head {
	long unsigned int b_state;
	struct buffer_head *b_this_page;
	struct page *b_page;
	sector_t b_blocknr;
	size_t b_size;
	char *b_data;
	struct block_device *b_bdev;
	bh_end_io_t *b_end_io;
	void *b_private;
	struct list_head b_assoc_buffers;
	struct address_space *b_assoc_map;
	atomic_t b_count;
	spinlock_t b_uptodate_lock;
};

typedef struct page *new_page_t(struct page *, long unsigned int);

typedef void free_page_t(struct page *, long unsigned int);

enum migrate_vma_direction {
	MIGRATE_VMA_SELECT_SYSTEM = 1,
	MIGRATE_VMA_SELECT_DEVICE_PRIVATE = 2,
};

struct migrate_vma {
	struct vm_area_struct *vma;
	long unsigned int *dst;
	long unsigned int *src;
	long unsigned int cpages;
	long unsigned int npages;
	long unsigned int start;
	long unsigned int end;
	void *pgmap_owner;
	long unsigned int flags;
};

enum bh_state_bits {
	BH_Uptodate = 0,
	BH_Dirty = 1,
	BH_Lock = 2,
	BH_Req = 3,
	BH_Mapped = 4,
	BH_New = 5,
	BH_Async_Read = 6,
	BH_Async_Write = 7,
	BH_Delay = 8,
	BH_Boundary = 9,
	BH_Write_EIO = 10,
	BH_Unwritten = 11,
	BH_Quiet = 12,
	BH_Meta = 13,
	BH_Prio = 14,
	BH_Defer_Completion = 15,
	BH_PrivateStart = 16,
};

struct trace_event_raw_mm_migrate_pages {
	struct trace_entry ent;
	long unsigned int succeeded;
	long unsigned int failed;
	long unsigned int thp_succeeded;
	long unsigned int thp_failed;
	long unsigned int thp_split;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_raw_mm_migrate_pages_start {
	struct trace_entry ent;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_data_offsets_mm_migrate_pages {};

struct trace_event_data_offsets_mm_migrate_pages_start {};

typedef void (*btf_trace_mm_migrate_pages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, enum migrate_mode, int);

typedef void (*btf_trace_mm_migrate_pages_start)(void *, enum migrate_mode, int);

enum scan_result {
	SCAN_FAIL = 0,
	SCAN_SUCCEED = 1,
	SCAN_PMD_NULL = 2,
	SCAN_EXCEED_NONE_PTE = 3,
	SCAN_EXCEED_SWAP_PTE = 4,
	SCAN_EXCEED_SHARED_PTE = 5,
	SCAN_PTE_NON_PRESENT = 6,
	SCAN_PTE_UFFD_WP = 7,
	SCAN_PAGE_RO = 8,
	SCAN_LACK_REFERENCED_PAGE = 9,
	SCAN_PAGE_NULL = 10,
	SCAN_SCAN_ABORT = 11,
	SCAN_PAGE_COUNT = 12,
	SCAN_PAGE_LRU = 13,
	SCAN_PAGE_LOCK = 14,
	SCAN_PAGE_ANON = 15,
	SCAN_PAGE_COMPOUND = 16,
	SCAN_ANY_PROCESS = 17,
	SCAN_VMA_NULL = 18,
	SCAN_VMA_CHECK = 19,
	SCAN_ADDRESS_RANGE = 20,
	SCAN_SWAP_CACHE_PAGE = 21,
	SCAN_DEL_PAGE_LRU = 22,
	SCAN_ALLOC_HUGE_PAGE_FAIL = 23,
	SCAN_CGROUP_CHARGE_FAIL = 24,
	SCAN_TRUNCATED = 25,
	SCAN_PAGE_HAS_PRIVATE = 26,
};

struct trace_event_raw_mm_khugepaged_scan_pmd {
	struct trace_entry ent;
	struct mm_struct *mm;
	long unsigned int pfn;
	bool writable;
	int referenced;
	int none_or_zero;
	int status;
	int unmapped;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page {
	struct trace_entry ent;
	struct mm_struct *mm;
	int isolated;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page_isolate {
	struct trace_entry ent;
	long unsigned int pfn;
	int none_or_zero;
	int referenced;
	bool writable;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page_swapin {
	struct trace_entry ent;
	struct mm_struct *mm;
	int swapped_in;
	int referenced;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_mm_khugepaged_scan_pmd {};

struct trace_event_data_offsets_mm_collapse_huge_page {};

struct trace_event_data_offsets_mm_collapse_huge_page_isolate {};

struct trace_event_data_offsets_mm_collapse_huge_page_swapin {};

typedef void (*btf_trace_mm_khugepaged_scan_pmd)(void *, struct mm_struct *, struct page *, bool, int, int, int, int);

typedef void (*btf_trace_mm_collapse_huge_page)(void *, struct mm_struct *, int, int);

typedef void (*btf_trace_mm_collapse_huge_page_isolate)(void *, struct page *, int, int, bool, int);

typedef void (*btf_trace_mm_collapse_huge_page_swapin)(void *, struct mm_struct *, int, int, int);

struct mm_slot___2 {
	struct hlist_node hash;
	struct list_head mm_node;
	struct mm_struct *mm;
	int nr_pte_mapped_thp;
	long unsigned int pte_mapped_thp[8];
};

struct khugepaged_scan {
	struct list_head mm_head;
	struct mm_slot___2 *mm_slot;
	long unsigned int address;
};

struct mem_cgroup_reclaim_cookie {
	pg_data_t *pgdat;
	unsigned int generation;
};

struct mem_cgroup_tree_per_node {
	struct rb_root rb_root;
	struct rb_node *rb_rightmost;
	spinlock_t lock;
};

struct mem_cgroup_tree {
	struct mem_cgroup_tree_per_node *rb_tree_per_node[64];
};

struct mem_cgroup_eventfd_list {
	struct list_head list;
	struct eventfd_ctx *eventfd;
};

struct mem_cgroup_event {
	struct mem_cgroup *memcg;
	struct eventfd_ctx *eventfd;
	struct list_head list;
	int (*register_event)(struct mem_cgroup *, struct eventfd_ctx *, const char *);
	void (*unregister_event)(struct mem_cgroup *, struct eventfd_ctx *);
	poll_table pt;
	wait_queue_head_t *wqh;
	wait_queue_entry_t wait;
	struct work_struct remove;
};

struct move_charge_struct {
	spinlock_t lock;
	struct mm_struct *mm;
	struct mem_cgroup *from;
	struct mem_cgroup *to;
	long unsigned int flags;
	long unsigned int precharge;
	long unsigned int moved_charge;
	long unsigned int moved_swap;
	struct task_struct *moving_task;
	wait_queue_head_t waitq;
};

enum res_type {
	_MEM = 0,
	_MEMSWAP = 1,
	_OOM_TYPE = 2,
	_KMEM = 3,
	_TCP = 4,
};

struct memory_stat {
	const char *name;
	unsigned int idx;
};

struct oom_wait_info {
	struct mem_cgroup *memcg;
	wait_queue_entry_t wait;
};

enum oom_status {
	OOM_SUCCESS = 0,
	OOM_FAILED = 1,
	OOM_ASYNC = 2,
	OOM_SKIPPED = 3,
};

struct memcg_stock_pcp {
	struct mem_cgroup *cached;
	unsigned int nr_pages;
	struct obj_cgroup *cached_objcg;
	unsigned int nr_bytes;
	struct work_struct work;
	long unsigned int flags;
};

enum {
	RES_USAGE = 0,
	RES_LIMIT = 1,
	RES_MAX_USAGE = 2,
	RES_FAILCNT = 3,
	RES_SOFT_LIMIT = 4,
};

union mc_target {
	struct page *page;
	swp_entry_t ent;
};

enum mc_target_type {
	MC_TARGET_NONE = 0,
	MC_TARGET_PAGE = 1,
	MC_TARGET_SWAP = 2,
	MC_TARGET_DEVICE = 3,
};

struct uncharge_gather {
	struct mem_cgroup *memcg;
	long unsigned int nr_memory;
	long unsigned int pgpgout;
	long unsigned int nr_kmem;
	struct page *dummy_page;
};

struct numa_stat {
	const char *name;
	unsigned int lru_mask;
};

enum vmpressure_levels {
	VMPRESSURE_LOW = 0,
	VMPRESSURE_MEDIUM = 1,
	VMPRESSURE_CRITICAL = 2,
	VMPRESSURE_NUM_LEVELS = 3,
};

enum vmpressure_modes {
	VMPRESSURE_NO_PASSTHROUGH = 0,
	VMPRESSURE_HIERARCHY = 1,
	VMPRESSURE_LOCAL = 2,
	VMPRESSURE_NUM_MODES = 3,
};

struct vmpressure_event {
	struct eventfd_ctx *efd;
	enum vmpressure_levels level;
	enum vmpressure_modes mode;
	struct list_head node;
};

struct swap_cgroup_ctrl {
	struct page **map;
	long unsigned int length;
	spinlock_t lock;
};

struct swap_cgroup {
	short unsigned int id;
};

enum {
	RES_USAGE___2 = 0,
	RES_RSVD_USAGE = 1,
	RES_LIMIT___2 = 2,
	RES_RSVD_LIMIT = 3,
	RES_MAX_USAGE___2 = 4,
	RES_RSVD_MAX_USAGE = 5,
	RES_FAILCNT___2 = 6,
	RES_RSVD_FAILCNT = 7,
};

enum mf_result {
	MF_IGNORED = 0,
	MF_FAILED = 1,
	MF_DELAYED = 2,
	MF_RECOVERED = 3,
};

enum mf_action_page_type {
	MF_MSG_KERNEL = 0,
	MF_MSG_KERNEL_HIGH_ORDER = 1,
	MF_MSG_SLAB = 2,
	MF_MSG_DIFFERENT_COMPOUND = 3,
	MF_MSG_POISONED_HUGE = 4,
	MF_MSG_HUGE = 5,
	MF_MSG_FREE_HUGE = 6,
	MF_MSG_NON_PMD_HUGE = 7,
	MF_MSG_UNMAP_FAILED = 8,
	MF_MSG_DIRTY_SWAPCACHE = 9,
	MF_MSG_CLEAN_SWAPCACHE = 10,
	MF_MSG_DIRTY_MLOCKED_LRU = 11,
	MF_MSG_CLEAN_MLOCKED_LRU = 12,
	MF_MSG_DIRTY_UNEVICTABLE_LRU = 13,
	MF_MSG_CLEAN_UNEVICTABLE_LRU = 14,
	MF_MSG_DIRTY_LRU = 15,
	MF_MSG_CLEAN_LRU = 16,
	MF_MSG_TRUNCATED_LRU = 17,
	MF_MSG_BUDDY = 18,
	MF_MSG_BUDDY_2ND = 19,
	MF_MSG_DAX = 20,
	MF_MSG_UNSPLIT_THP = 21,
	MF_MSG_UNKNOWN = 22,
};

typedef long unsigned int dax_entry_t;

struct __kfifo {
	unsigned int in;
	unsigned int out;
	unsigned int mask;
	unsigned int esize;
	void *data;
};

struct to_kill {
	struct list_head nd;
	struct task_struct *tsk;
	long unsigned int addr;
	short int size_shift;
};

struct page_state {
	long unsigned int mask;
	long unsigned int res;
	enum mf_action_page_type type;
	int (*action)(struct page *, long unsigned int);
};

struct memory_failure_entry {
	long unsigned int pfn;
	int flags;
};

struct memory_failure_cpu {
	struct {
		union {
			struct __kfifo kfifo;
			struct memory_failure_entry *type;
			const struct memory_failure_entry *const_type;
			char (*rectype)[0];
			struct memory_failure_entry *ptr;
			const struct memory_failure_entry *ptr_const;
		};
		struct memory_failure_entry buf[16];
	} fifo;
	spinlock_t lock;
	struct work_struct work;
};

struct cleancache_filekey {
	union {
		ino_t ino;
		__u32 fh[6];
		u32 key[6];
	} u;
};

struct cleancache_ops {
	int (*init_fs)(size_t);
	int (*init_shared_fs)(uuid_t *, size_t);
	int (*get_page)(int, struct cleancache_filekey, long unsigned int, struct page *);
	void (*put_page)(int, struct cleancache_filekey, long unsigned int, struct page *);
	void (*invalidate_page)(int, struct cleancache_filekey, long unsigned int);
	void (*invalidate_inode)(int, struct cleancache_filekey);
	void (*invalidate_fs)(int);
};

struct trace_event_raw_test_pages_isolated {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int fin_pfn;
	char __data[0];
};

struct trace_event_data_offsets_test_pages_isolated {};

typedef void (*btf_trace_test_pages_isolated)(void *, long unsigned int, long unsigned int, long unsigned int);

struct zpool_driver;

struct zpool {
	struct zpool_driver *driver;
	void *pool;
	const struct zpool_ops *ops;
	bool evictable;
	bool can_sleep_mapped;
	struct list_head list;
};

struct zpool_driver {
	char *type;
	struct module *owner;
	atomic_t refcount;
	struct list_head list;
	void * (*create)(const char *, gfp_t, const struct zpool_ops *, struct zpool *);
	void (*destroy)(void *);
	bool malloc_support_movable;
	int (*malloc)(void *, size_t, gfp_t, long unsigned int *);
	void (*free)(void *, long unsigned int);
	int (*shrink)(void *, unsigned int, unsigned int *);
	bool sleep_mapped;
	void * (*map)(void *, long unsigned int, enum zpool_mapmode);
	void (*unmap)(void *, long unsigned int);
	u64 (*total_size)(void *);
};

typedef void (*exitcall_t)();

struct zbud_pool;

struct zbud_ops {
	int (*evict)(struct zbud_pool *, long unsigned int);
};

struct zbud_pool {
	spinlock_t lock;
	struct list_head unbuddied[63];
	struct list_head buddied;
	struct list_head lru;
	u64 pages_nr;
	const struct zbud_ops *ops;
	struct zpool *zpool;
	const struct zpool_ops *zpool_ops;
};

struct zbud_header {
	struct list_head buddy;
	struct list_head lru;
	unsigned int first_chunks;
	unsigned int last_chunks;
	bool under_reclaim;
};

enum buddy {
	FIRST = 0,
	LAST = 1,
};

enum zs_mapmode {
	ZS_MM_RW = 0,
	ZS_MM_RO = 1,
	ZS_MM_WO = 2,
};

struct zs_pool_stats {
	atomic_long_t pages_compacted;
};

enum fullness_group {
	ZS_EMPTY = 0,
	ZS_ALMOST_EMPTY = 1,
	ZS_ALMOST_FULL = 2,
	ZS_FULL = 3,
	NR_ZS_FULLNESS = 4,
};

enum zs_stat_type {
	CLASS_EMPTY = 0,
	CLASS_ALMOST_EMPTY = 1,
	CLASS_ALMOST_FULL = 2,
	CLASS_FULL = 3,
	OBJ_ALLOCATED = 4,
	OBJ_USED = 5,
	NR_ZS_STAT_TYPE = 6,
};

struct zs_size_stat {
	long unsigned int objs[6];
};

struct size_class {
	spinlock_t lock;
	struct list_head fullness_list[4];
	int size;
	int objs_per_zspage;
	int pages_per_zspage;
	unsigned int index;
	struct zs_size_stat stats;
};

struct link_free {
	union {
		long unsigned int next;
		long unsigned int handle;
	};
};

struct zs_pool {
	const char *name;
	struct size_class *size_class[255];
	struct kmem_cache *handle_cachep;
	struct kmem_cache *zspage_cachep;
	atomic_long_t pages_allocated;
	struct zs_pool_stats stats;
	struct shrinker shrinker;
	struct inode *inode;
	struct work_struct free_work;
	struct wait_queue_head migration_wait;
	atomic_long_t isolated_pages;
	bool destroying;
};

struct zspage {
	struct {
		unsigned int fullness: 2;
		unsigned int class: 9;
		unsigned int isolated: 3;
		unsigned int magic: 8;
	};
	unsigned int inuse;
	unsigned int freeobj;
	struct page *first_page;
	struct list_head list;
	rwlock_t lock;
};

struct mapping_area {
	char *vm_buf;
	char *vm_addr;
	enum zs_mapmode vm_mm;
};

struct zs_compact_control {
	struct page *s_page;
	struct page *d_page;
	int obj_idx;
};

struct cma_kobject;

struct cma {
	long unsigned int base_pfn;
	long unsigned int count;
	long unsigned int *bitmap;
	unsigned int order_per_bit;
	spinlock_t lock;
	char name[64];
	atomic64_t nr_pages_succeeded;
	atomic64_t nr_pages_failed;
	struct cma_kobject *cma_kobj;
};

struct trace_event_raw_cma_alloc_class {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int pfn;
	const struct page *page;
	long unsigned int count;
	unsigned int align;
	char __data[0];
};

struct trace_event_raw_cma_release {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int pfn;
	const struct page *page;
	long unsigned int count;
	char __data[0];
};

struct trace_event_raw_cma_alloc_start {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int count;
	unsigned int align;
	char __data[0];
};

struct trace_event_data_offsets_cma_alloc_class {
	u32 name;
};

struct trace_event_data_offsets_cma_release {
	u32 name;
};

struct trace_event_data_offsets_cma_alloc_start {
	u32 name;
};

typedef void (*btf_trace_cma_release)(void *, const char *, long unsigned int, const struct page *, long unsigned int);

typedef void (*btf_trace_cma_alloc_start)(void *, const char *, long unsigned int, unsigned int);

typedef void (*btf_trace_cma_alloc_finish)(void *, const char *, long unsigned int, const struct page *, long unsigned int, unsigned int);

typedef void (*btf_trace_cma_alloc_busy_retry)(void *, const char *, long unsigned int, const struct page *, long unsigned int, unsigned int);

struct cma_kobject {
	struct kobject kobj;
	struct cma *cma;
};

struct balloon_dev_info {
	long unsigned int isolated_pages;
	spinlock_t pages_lock;
	struct list_head pages;
	int (*migratepage)(struct balloon_dev_info *, struct page *, struct page *, enum migrate_mode);
	struct inode *inode;
};

enum {
	BAD_STACK = 4294967295,
	NOT_STACK = 0,
	GOOD_FRAME = 1,
	GOOD_STACK = 2,
};

enum hmm_pfn_flags {
	HMM_PFN_VALID = 0,
	HMM_PFN_WRITE = 0,
	HMM_PFN_ERROR = 0,
	HMM_PFN_ORDER_SHIFT = 56,
	HMM_PFN_REQ_FAULT = 0,
	HMM_PFN_REQ_WRITE = 0,
	HMM_PFN_FLAGS = 0,
};

struct hmm_range {
	struct mmu_interval_notifier *notifier;
	long unsigned int notifier_seq;
	long unsigned int start;
	long unsigned int end;
	long unsigned int *hmm_pfns;
	long unsigned int default_flags;
	long unsigned int pfn_flags_mask;
	void *dev_private_owner;
};

struct hmm_vma_walk {
	struct hmm_range *range;
	long unsigned int last;
};

enum {
	HMM_NEED_FAULT = 1,
	HMM_NEED_WRITE_FAULT = 2,
	HMM_NEED_ALL_BITS = 3,
};

struct hugetlbfs_inode_info {
	struct shared_policy policy;
	struct inode vfs_inode;
	unsigned int seals;
};

struct page_reporting_dev_info {
	int (*report)(struct page_reporting_dev_info *, struct scatterlist *, unsigned int);
	struct delayed_work work;
	atomic_t state;
};

enum {
	PAGE_REPORTING_IDLE = 0,
	PAGE_REPORTING_REQUESTED = 1,
	PAGE_REPORTING_ACTIVE = 2,
};

typedef s32 compat_off_t;

struct open_how {
	__u64 flags;
	__u64 mode;
	__u64 resolve;
};

struct fs_context_operations___2;

struct open_flags {
	int open_flag;
	umode_t mode;
	int acc_mode;
	int intent;
	int lookup_flags;
};

typedef s64 compat_loff_t;

typedef __kernel_rwf_t rwf_t;

struct fscrypt_policy_v1 {
	__u8 version;
	__u8 contents_encryption_mode;
	__u8 filenames_encryption_mode;
	__u8 flags;
	__u8 master_key_descriptor[8];
};

struct fscrypt_policy_v2 {
	__u8 version;
	__u8 contents_encryption_mode;
	__u8 filenames_encryption_mode;
	__u8 flags;
	__u8 __reserved[4];
	__u8 master_key_identifier[16];
};

union fscrypt_policy {
	u8 version;
	struct fscrypt_policy_v1 v1;
	struct fscrypt_policy_v2 v2;
};

enum vfs_get_super_keying {
	vfs_get_single_super = 0,
	vfs_get_single_reconf_super = 1,
	vfs_get_keyed_super = 2,
	vfs_get_independent_super = 3,
};

struct kobj_map;

struct char_device_struct {
	struct char_device_struct *next;
	unsigned int major;
	unsigned int baseminor;
	int minorct;
	char name[64];
	struct cdev *cdev;
};

struct stat {
	long unsigned int st_dev;
	long unsigned int st_ino;
	unsigned int st_mode;
	unsigned int st_nlink;
	unsigned int st_uid;
	unsigned int st_gid;
	long unsigned int st_rdev;
	long unsigned int __pad1;
	long int st_size;
	int st_blksize;
	int __pad2;
	long int st_blocks;
	long int st_atime;
	long unsigned int st_atime_nsec;
	long int st_mtime;
	long unsigned int st_mtime_nsec;
	long int st_ctime;
	long unsigned int st_ctime_nsec;
	unsigned int __unused4;
	unsigned int __unused5;
};

typedef u32 compat_ino_t;

typedef u16 compat_ushort_t;

typedef s64 compat_s64;

typedef u16 __compat_uid16_t;

typedef u16 __compat_gid16_t;

typedef u16 compat_mode_t;

typedef u32 compat_dev_t;

struct compat_stat {
	compat_dev_t st_dev;
	compat_ino_t st_ino;
	compat_mode_t st_mode;
	compat_ushort_t st_nlink;
	__compat_uid16_t st_uid;
	__compat_gid16_t st_gid;
	compat_dev_t st_rdev;
	compat_off_t st_size;
	compat_off_t st_blksize;
	compat_off_t st_blocks;
	old_time32_t st_atime;
	compat_ulong_t st_atime_nsec;
	old_time32_t st_mtime;
	compat_ulong_t st_mtime_nsec;
	old_time32_t st_ctime;
	compat_ulong_t st_ctime_nsec;
	compat_ulong_t __unused4[2];
};

struct stat64 {
	compat_u64 st_dev;
	unsigned char __pad0[4];
	compat_ulong_t __st_ino;
	compat_uint_t st_mode;
	compat_uint_t st_nlink;
	compat_ulong_t st_uid;
	compat_ulong_t st_gid;
	compat_u64 st_rdev;
	unsigned char __pad3[4];
	compat_s64 st_size;
	compat_ulong_t st_blksize;
	compat_u64 st_blocks;
	compat_ulong_t st_atime;
	compat_ulong_t st_atime_nsec;
	compat_ulong_t st_mtime;
	compat_ulong_t st_mtime_nsec;
	compat_ulong_t st_ctime;
	compat_ulong_t st_ctime_nsec;
	compat_u64 st_ino;
};

struct statx_timestamp {
	__s64 tv_sec;
	__u32 tv_nsec;
	__s32 __reserved;
};

struct statx {
	__u32 stx_mask;
	__u32 stx_blksize;
	__u64 stx_attributes;
	__u32 stx_nlink;
	__u32 stx_uid;
	__u32 stx_gid;
	__u16 stx_mode;
	__u16 __spare0[1];
	__u64 stx_ino;
	__u64 stx_size;
	__u64 stx_blocks;
	__u64 stx_attributes_mask;
	struct statx_timestamp stx_atime;
	struct statx_timestamp stx_btime;
	struct statx_timestamp stx_ctime;
	struct statx_timestamp stx_mtime;
	__u32 stx_rdev_major;
	__u32 stx_rdev_minor;
	__u32 stx_dev_major;
	__u32 stx_dev_minor;
	__u64 stx_mnt_id;
	__u64 __spare2;
	__u64 __spare3[12];
};

struct mount;

struct mnt_namespace {
	struct ns_common ns;
	struct mount *root;
	struct list_head list;
	spinlock_t ns_lock;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	u64 seq;
	wait_queue_head_t poll;
	u64 event;
	unsigned int mounts;
	unsigned int pending_mounts;
};

struct mnt_pcp;

struct mountpoint;

struct mount {
	struct hlist_node mnt_hash;
	struct mount *mnt_parent;
	struct dentry *mnt_mountpoint;
	struct vfsmount mnt;
	union {
		struct callback_head mnt_rcu;
		struct llist_node mnt_llist;
	};
	struct mnt_pcp *mnt_pcp;
	struct list_head mnt_mounts;
	struct list_head mnt_child;
	struct list_head mnt_instance;
	const char *mnt_devname;
	struct list_head mnt_list;
	struct list_head mnt_expire;
	struct list_head mnt_share;
	struct list_head mnt_slave_list;
	struct list_head mnt_slave;
	struct mount *mnt_master;
	struct mnt_namespace *mnt_ns;
	struct mountpoint *mnt_mp;
	union {
		struct hlist_node mnt_mp_list;
		struct hlist_node mnt_umount;
	};
	struct list_head mnt_umounting;
	struct fsnotify_mark_connector *mnt_fsnotify_marks;
	__u32 mnt_fsnotify_mask;
	int mnt_id;
	int mnt_group_id;
	int mnt_expiry_mark;
	struct hlist_head mnt_pins;
	struct hlist_head mnt_stuck_children;
};

struct mnt_pcp {
	int mnt_count;
	int mnt_writers;
};

struct mountpoint {
	struct hlist_node m_hash;
	struct dentry *m_dentry;
	struct hlist_head m_list;
	int m_count;
};

typedef short unsigned int ushort;

struct user_arg_ptr {
	bool is_compat;
	union {
		const char * const *native;
		const compat_uptr_t *compat;
	} ptr;
};

enum inode_i_mutex_lock_class {
	I_MUTEX_NORMAL = 0,
	I_MUTEX_PARENT = 1,
	I_MUTEX_CHILD = 2,
	I_MUTEX_XATTR = 3,
	I_MUTEX_NONDIR2 = 4,
	I_MUTEX_PARENT2 = 5,
};

struct pseudo_fs_context {
	const struct super_operations *ops;
	const struct xattr_handler **xattr;
	const struct dentry_operations *dops;
	long unsigned int magic;
};

struct name_snapshot {
	struct qstr name;
	unsigned char inline_name[32];
};

struct saved {
	struct path link;
	struct delayed_call done;
	const char *name;
	unsigned int seq;
};

struct nameidata {
	struct path path;
	struct qstr last;
	struct path root;
	struct inode *inode;
	unsigned int flags;
	unsigned int seq;
	unsigned int m_seq;
	unsigned int r_seq;
	int last_type;
	unsigned int depth;
	int total_link_count;
	struct saved *stack;
	struct saved internal[2];
	struct filename *name;
	struct nameidata *saved;
	unsigned int root_seq;
	int dfd;
	kuid_t dir_uid;
	umode_t dir_mode;
};

struct renamedata {
	struct user_namespace *old_mnt_userns;
	struct inode *old_dir;
	struct dentry *old_dentry;
	struct user_namespace *new_mnt_userns;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct inode **delegated_inode;
	unsigned int flags;
};

enum {
	LAST_NORM = 0,
	LAST_ROOT = 1,
	LAST_DOT = 2,
	LAST_DOTDOT = 3,
};

enum {
	WALK_TRAILING = 1,
	WALK_MORE = 2,
	WALK_NOFOLLOW = 4,
};

struct word_at_a_time {
	const long unsigned int one_bits;
	const long unsigned int high_bits;
};

struct compat_flock {
	short int l_type;
	short int l_whence;
	compat_off_t l_start;
	compat_off_t l_len;
	compat_pid_t l_pid;
};

struct compat_flock64 {
	short int l_type;
	short int l_whence;
	compat_loff_t l_start;
	compat_loff_t l_len;
	compat_pid_t l_pid;
};

struct f_owner_ex {
	int type;
	__kernel_pid_t pid;
};

struct flock {
	short int l_type;
	short int l_whence;
	__kernel_off_t l_start;
	__kernel_off_t l_len;
	__kernel_pid_t l_pid;
};

struct file_clone_range {
	__s64 src_fd;
	__u64 src_offset;
	__u64 src_length;
	__u64 dest_offset;
};

struct file_dedupe_range_info {
	__s64 dest_fd;
	__u64 dest_offset;
	__u64 bytes_deduped;
	__s32 status;
	__u32 reserved;
};

struct file_dedupe_range {
	__u64 src_offset;
	__u64 src_length;
	__u16 dest_count;
	__u16 reserved1;
	__u32 reserved2;
	struct file_dedupe_range_info info[0];
};

struct fsxattr {
	__u32 fsx_xflags;
	__u32 fsx_extsize;
	__u32 fsx_nextents;
	__u32 fsx_projid;
	__u32 fsx_cowextsize;
	unsigned char fsx_pad[8];
};

typedef int get_block_t(struct inode *, sector_t, struct buffer_head *, int);

struct fiemap_extent;

struct fiemap_extent_info {
	unsigned int fi_flags;
	unsigned int fi_extents_mapped;
	unsigned int fi_extents_max;
	struct fiemap_extent *fi_extents_start;
};

struct fileattr {
	u32 flags;
	u32 fsx_xflags;
	u32 fsx_extsize;
	u32 fsx_nextents;
	u32 fsx_projid;
	u32 fsx_cowextsize;
	bool flags_valid: 1;
	bool fsx_valid: 1;
};

struct space_resv {
	__s16 l_type;
	__s16 l_whence;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
};

struct fiemap_extent {
	__u64 fe_logical;
	__u64 fe_physical;
	__u64 fe_length;
	__u64 fe_reserved64[2];
	__u32 fe_flags;
	__u32 fe_reserved[3];
};

struct fiemap {
	__u64 fm_start;
	__u64 fm_length;
	__u32 fm_flags;
	__u32 fm_mapped_extents;
	__u32 fm_extent_count;
	__u32 fm_reserved;
	struct fiemap_extent fm_extents[0];
};

struct linux_dirent64 {
	u64 d_ino;
	s64 d_off;
	short unsigned int d_reclen;
	unsigned char d_type;
	char d_name[0];
};

struct linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_off;
	short unsigned int d_reclen;
	char d_name[1];
};

struct getdents_callback {
	struct dir_context ctx;
	struct linux_dirent *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct getdents_callback64 {
	struct dir_context ctx;
	struct linux_dirent64 *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct compat_old_linux_dirent {
	compat_ulong_t d_ino;
	compat_ulong_t d_offset;
	short unsigned int d_namlen;
	char d_name[1];
};

struct compat_readdir_callback {
	struct dir_context ctx;
	struct compat_old_linux_dirent *dirent;
	int result;
};

struct compat_linux_dirent {
	compat_ulong_t d_ino;
	compat_ulong_t d_off;
	short unsigned int d_reclen;
	char d_name[1];
};

struct compat_getdents_callback {
	struct dir_context ctx;
	struct compat_linux_dirent *current_dir;
	int prev_reclen;
	int count;
	int error;
};

typedef struct {
	long unsigned int fds_bits[16];
} __kernel_fd_set;

typedef __kernel_fd_set fd_set;

struct poll_table_entry {
	struct file *filp;
	__poll_t key;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_address;
};

struct poll_table_page;

struct poll_wqueues {
	poll_table pt;
	struct poll_table_page *table;
	struct task_struct *polling_task;
	int triggered;
	int error;
	int inline_index;
	struct poll_table_entry inline_entries[9];
};

struct poll_table_page {
	struct poll_table_page *next;
	struct poll_table_entry *entry;
	struct poll_table_entry entries[0];
};

enum poll_time_type {
	PT_TIMEVAL = 0,
	PT_OLD_TIMEVAL = 1,
	PT_TIMESPEC = 2,
	PT_OLD_TIMESPEC = 3,
};

typedef struct {
	long unsigned int *in;
	long unsigned int *out;
	long unsigned int *ex;
	long unsigned int *res_in;
	long unsigned int *res_out;
	long unsigned int *res_ex;
} fd_set_bits;

struct sigset_argpack {
	sigset_t *p;
	size_t size;
};

struct poll_list {
	struct poll_list *next;
	int len;
	struct pollfd entries[0];
};

struct compat_sel_arg_struct {
	compat_ulong_t n;
	compat_uptr_t inp;
	compat_uptr_t outp;
	compat_uptr_t exp;
	compat_uptr_t tvp;
};

struct compat_sigset_argpack {
	compat_uptr_t p;
	compat_size_t size;
};

enum dentry_d_lock_class {
	DENTRY_D_LOCK_NORMAL = 0,
	DENTRY_D_LOCK_NESTED = 1,
};

struct external_name {
	union {
		atomic_t count;
		struct callback_head head;
	} u;
	unsigned char name[0];
};

enum d_walk_ret {
	D_WALK_CONTINUE = 0,
	D_WALK_QUIT = 1,
	D_WALK_NORETRY = 2,
	D_WALK_SKIP = 3,
};

struct check_mount {
	struct vfsmount *mnt;
	unsigned int mounted;
};

struct select_data {
	struct dentry *start;
	union {
		long int found;
		struct dentry *victim;
	};
	struct list_head dispose;
};

enum file_time_flags {
	S_ATIME = 1,
	S_MTIME = 2,
	S_CTIME = 4,
	S_VERSION = 8,
};

struct mount_attr {
	__u64 attr_set;
	__u64 attr_clr;
	__u64 propagation;
	__u64 userns_fd;
};

struct proc_mounts {
	struct mnt_namespace *ns;
	struct path root;
	int (*show)(struct seq_file *, struct vfsmount *);
	struct mount cursor;
};

struct mount_kattr {
	unsigned int attr_set;
	unsigned int attr_clr;
	unsigned int propagation;
	unsigned int lookup_flags;
	bool recurse;
	struct user_namespace *mnt_userns;
};

enum umount_tree_flags {
	UMOUNT_SYNC = 1,
	UMOUNT_PROPAGATE = 2,
	UMOUNT_CONNECTED = 4,
};

struct unicode_map {
	const char *charset;
	int version;
};

struct simple_transaction_argresp {
	ssize_t size;
	char data[0];
};

struct simple_attr {
	int (*get)(void *, u64 *);
	int (*set)(void *, u64);
	char get_buf[24];
	char set_buf[24];
	void *data;
	const char *fmt;
	struct mutex mutex;
};

struct wb_writeback_work {
	long int nr_pages;
	struct super_block *sb;
	enum writeback_sync_modes sync_mode;
	unsigned int tagged_writepages: 1;
	unsigned int for_kupdate: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_background: 1;
	unsigned int for_sync: 1;
	unsigned int auto_free: 1;
	enum wb_reason reason;
	struct list_head list;
	struct wb_completion *done;
};

struct trace_event_raw_writeback_page_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_writeback_dirty_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_inode_foreign_history {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	ino_t cgroup_ino;
	unsigned int history;
	char __data[0];
};

struct trace_event_raw_inode_switch_wbs {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	ino_t old_cgroup_ino;
	ino_t new_cgroup_ino;
	char __data[0];
};

struct trace_event_raw_track_foreign_dirty {
	struct trace_entry ent;
	char name[32];
	u64 bdi_id;
	ino_t ino;
	unsigned int memcg_id;
	ino_t cgroup_ino;
	ino_t page_cgroup_ino;
	char __data[0];
};

struct trace_event_raw_flush_foreign {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	unsigned int frn_bdi_id;
	unsigned int frn_memcg_id;
	char __data[0];
};

struct trace_event_raw_writeback_write_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	int sync_mode;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_work_class {
	struct trace_entry ent;
	char name[32];
	long int nr_pages;
	dev_t sb_dev;
	int sync_mode;
	int for_kupdate;
	int range_cyclic;
	int for_background;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_pages_written {
	struct trace_entry ent;
	long int pages;
	char __data[0];
};

struct trace_event_raw_writeback_class {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_bdi_register {
	struct trace_entry ent;
	char name[32];
	char __data[0];
};

struct trace_event_raw_wbc_class {
	struct trace_entry ent;
	char name[32];
	long int nr_to_write;
	long int pages_skipped;
	int sync_mode;
	int for_kupdate;
	int for_background;
	int for_reclaim;
	int range_cyclic;
	long int range_start;
	long int range_end;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_queue_io {
	struct trace_entry ent;
	char name[32];
	long unsigned int older;
	long int age;
	int moved;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_global_dirty_state {
	struct trace_entry ent;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int background_thresh;
	long unsigned int dirty_thresh;
	long unsigned int dirty_limit;
	long unsigned int nr_dirtied;
	long unsigned int nr_written;
	char __data[0];
};

struct trace_event_raw_bdi_dirty_ratelimit {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int write_bw;
	long unsigned int avg_write_bw;
	long unsigned int dirty_rate;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_balance_dirty_pages {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int limit;
	long unsigned int setpoint;
	long unsigned int dirty;
	long unsigned int bdi_setpoint;
	long unsigned int bdi_dirty;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	unsigned int dirtied;
	unsigned int dirtied_pause;
	long unsigned int paused;
	long int pause;
	long unsigned int period;
	long int think;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_sb_inodes_requeue {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_congest_waited_template {
	struct trace_entry ent;
	unsigned int usec_timeout;
	unsigned int usec_delayed;
	char __data[0];
};

struct trace_event_raw_writeback_single_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	long unsigned int writeback_index;
	long int nr_to_write;
	long unsigned int wrote;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_inode_template {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int state;
	__u16 mode;
	long unsigned int dirtied_when;
	char __data[0];
};

struct trace_event_data_offsets_writeback_page_template {};

struct trace_event_data_offsets_writeback_dirty_inode_template {};

struct trace_event_data_offsets_inode_foreign_history {};

struct trace_event_data_offsets_inode_switch_wbs {};

struct trace_event_data_offsets_track_foreign_dirty {};

struct trace_event_data_offsets_flush_foreign {};

struct trace_event_data_offsets_writeback_write_inode_template {};

struct trace_event_data_offsets_writeback_work_class {};

struct trace_event_data_offsets_writeback_pages_written {};

struct trace_event_data_offsets_writeback_class {};

struct trace_event_data_offsets_writeback_bdi_register {};

struct trace_event_data_offsets_wbc_class {};

struct trace_event_data_offsets_writeback_queue_io {};

struct trace_event_data_offsets_global_dirty_state {};

struct trace_event_data_offsets_bdi_dirty_ratelimit {};

struct trace_event_data_offsets_balance_dirty_pages {};

struct trace_event_data_offsets_writeback_sb_inodes_requeue {};

struct trace_event_data_offsets_writeback_congest_waited_template {};

struct trace_event_data_offsets_writeback_single_inode_template {};

struct trace_event_data_offsets_writeback_inode_template {};

typedef void (*btf_trace_writeback_dirty_page)(void *, struct page *, struct address_space *);

typedef void (*btf_trace_wait_on_page_writeback)(void *, struct page *, struct address_space *);

typedef void (*btf_trace_writeback_mark_inode_dirty)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode_start)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode)(void *, struct inode *, int);

typedef void (*btf_trace_inode_foreign_history)(void *, struct inode *, struct writeback_control *, unsigned int);

typedef void (*btf_trace_inode_switch_wbs)(void *, struct inode *, struct bdi_writeback *, struct bdi_writeback *);

typedef void (*btf_trace_track_foreign_dirty)(void *, struct page *, struct bdi_writeback *);

typedef void (*btf_trace_flush_foreign)(void *, struct bdi_writeback *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_write_inode_start)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_write_inode)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_queue)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_exec)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_start)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_written)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_wait)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_pages_written)(void *, long int);

typedef void (*btf_trace_writeback_wake_background)(void *, struct bdi_writeback *);

typedef void (*btf_trace_writeback_bdi_register)(void *, struct backing_dev_info *);

typedef void (*btf_trace_wbc_writepage)(void *, struct writeback_control *, struct backing_dev_info *);

typedef void (*btf_trace_writeback_queue_io)(void *, struct bdi_writeback *, struct wb_writeback_work *, long unsigned int, int);

typedef void (*btf_trace_global_dirty_state)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_bdi_dirty_ratelimit)(void *, struct bdi_writeback *, long unsigned int, long unsigned int);

typedef void (*btf_trace_balance_dirty_pages)(void *, struct bdi_writeback *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long int, long unsigned int);

typedef void (*btf_trace_writeback_sb_inodes_requeue)(void *, struct inode *);

typedef void (*btf_trace_writeback_congestion_wait)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_wait_iff_congested)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_single_inode_start)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_single_inode)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_lazytime)(void *, struct inode *);

typedef void (*btf_trace_writeback_lazytime_iput)(void *, struct inode *);

typedef void (*btf_trace_writeback_dirty_inode_enqueue)(void *, struct inode *);

typedef void (*btf_trace_sb_mark_inode_writeback)(void *, struct inode *);

typedef void (*btf_trace_sb_clear_inode_writeback)(void *, struct inode *);

struct inode_switch_wbs_context {
	struct inode *inode;
	struct bdi_writeback *new_wb;
	struct callback_head callback_head;
	struct work_struct work;
};

struct splice_desc {
	size_t total_len;
	unsigned int len;
	unsigned int flags;
	union {
		void *userptr;
		struct file *file;
		void *data;
	} u;
	loff_t pos;
	loff_t *opos;
	size_t num_spliced;
	bool need_wakeup;
};

typedef int splice_actor(struct pipe_inode_info *, struct pipe_buffer *, struct splice_desc *);

typedef int splice_direct_actor(struct pipe_inode_info *, struct splice_desc *);

struct old_utimbuf32 {
	old_time32_t actime;
	old_time32_t modtime;
};

typedef int __kernel_daddr_t;

struct ustat {
	__kernel_daddr_t f_tfree;
	long unsigned int f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

typedef s32 compat_daddr_t;

typedef __kernel_fsid_t compat_fsid_t;

struct compat_statfs {
	int f_type;
	int f_bsize;
	int f_blocks;
	int f_bfree;
	int f_bavail;
	int f_files;
	int f_ffree;
	compat_fsid_t f_fsid;
	int f_namelen;
	int f_frsize;
	int f_flags;
	int f_spare[4];
};

struct compat_ustat {
	compat_daddr_t f_tfree;
	compat_ino_t f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

struct statfs {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__kernel_long_t f_blocks;
	__kernel_long_t f_bfree;
	__kernel_long_t f_bavail;
	__kernel_long_t f_files;
	__kernel_long_t f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct statfs64 {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct compat_statfs64___2 {
	__u32 f_type;
	__u32 f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__u32 f_namelen;
	__u32 f_frsize;
	__u32 f_flags;
	__u32 f_spare[4];
} __attribute__((packed));

typedef struct ns_common *ns_get_path_helper_t(void *);

struct ns_get_path_task_args {
	const struct proc_ns_operations *ns_ops;
	struct task_struct *task;
};

enum legacy_fs_param {
	LEGACY_FS_UNSET_PARAMS = 0,
	LEGACY_FS_MONOLITHIC_PARAMS = 1,
	LEGACY_FS_INDIVIDUAL_PARAMS = 2,
};

struct legacy_fs_context {
	char *legacy_data;
	size_t data_size;
	enum legacy_fs_param param_type;
};

enum fsconfig_command {
	FSCONFIG_SET_FLAG = 0,
	FSCONFIG_SET_STRING = 1,
	FSCONFIG_SET_BINARY = 2,
	FSCONFIG_SET_PATH = 3,
	FSCONFIG_SET_PATH_EMPTY = 4,
	FSCONFIG_SET_FD = 5,
	FSCONFIG_CMD_CREATE = 6,
	FSCONFIG_CMD_RECONFIGURE = 7,
};

struct dax_device;

struct iomap_page_ops;

struct iomap___2 {
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	struct block_device *bdev;
	struct dax_device *dax_dev;
	void *inline_data;
	void *private;
	const struct iomap_page_ops *page_ops;
};

struct iomap_page_ops {
	int (*page_prepare)(struct inode *, loff_t, unsigned int, struct iomap___2 *);
	void (*page_done)(struct inode *, loff_t, unsigned int, struct page *, struct iomap___2 *);
};

struct decrypt_bh_ctx {
	struct work_struct work;
	struct buffer_head *bh;
};

struct bh_lru {
	struct buffer_head *bhs[16];
};

struct bh_accounting {
	int nr;
	int ratelimit;
};

enum stat_group {
	STAT_READ = 0,
	STAT_WRITE = 1,
	STAT_DISCARD = 2,
	STAT_FLUSH = 3,
	NR_STAT_GROUPS = 4,
};

enum {
	DISK_EVENT_MEDIA_CHANGE = 1,
	DISK_EVENT_EJECT_REQUEST = 2,
};

enum {
	BIOSET_NEED_BVECS = 1,
	BIOSET_NEED_RESCUER = 2,
};

struct bdev_inode {
	struct block_device bdev;
	struct inode vfs_inode;
};

struct blkdev_dio {
	union {
		struct kiocb *iocb;
		struct task_struct *waiter;
	};
	size_t size;
	atomic_t ref;
	bool multi_bio: 1;
	bool should_dirty: 1;
	bool is_sync: 1;
	struct bio bio;
};

struct bd_holder_disk {
	struct list_head list;
	struct gendisk *disk;
	int refcnt;
};

typedef int dio_iodone_t(struct kiocb *, loff_t, ssize_t, void *);

typedef void dio_submit_t(struct bio *, struct inode *, loff_t);

enum {
	DIO_LOCKING = 1,
	DIO_SKIP_HOLES = 2,
};

struct dio_submit {
	struct bio *bio;
	unsigned int blkbits;
	unsigned int blkfactor;
	unsigned int start_zero_done;
	int pages_in_io;
	sector_t block_in_file;
	unsigned int blocks_available;
	int reap_counter;
	sector_t final_block_in_request;
	int boundary;
	get_block_t *get_block;
	dio_submit_t *submit_io;
	loff_t logical_offset_in_bio;
	sector_t final_block_in_bio;
	sector_t next_block_for_io;
	struct page *cur_page;
	unsigned int cur_page_offset;
	unsigned int cur_page_len;
	sector_t cur_page_block;
	loff_t cur_page_fs_offset;
	struct iov_iter *iter;
	unsigned int head;
	unsigned int tail;
	size_t from;
	size_t to;
};

struct dio {
	int flags;
	int op;
	int op_flags;
	blk_qc_t bio_cookie;
	struct gendisk *bio_disk;
	struct inode *inode;
	loff_t i_size;
	dio_iodone_t *end_io;
	void *private;
	spinlock_t bio_lock;
	int page_errors;
	int is_async;
	bool defer_completion;
	bool should_dirty;
	int io_error;
	long unsigned int refcount;
	struct bio *bio_list;
	struct task_struct *waiter;
	struct kiocb *iocb;
	ssize_t result;
	union {
		struct page *pages[64];
		struct work_struct complete_work;
	};
	long: 64;
};

struct bvec_iter_all {
	struct bio_vec bv;
	int idx;
	unsigned int done;
};

struct mpage_readpage_args {
	struct bio *bio;
	struct page *page;
	unsigned int nr_pages;
	bool is_readahead;
	sector_t last_block_in_bio;
	struct buffer_head map_bh;
	long unsigned int first_logical_block;
	get_block_t *get_block;
};

struct mpage_data {
	struct bio *bio;
	sector_t last_block_in_bio;
	get_block_t *get_block;
	unsigned int use_writepage;
};

typedef u32 nlink_t;

typedef int (*proc_write_t)(struct file *, char *, size_t);

struct proc_dir_entry {
	atomic_t in_use;
	refcount_t refcnt;
	struct list_head pde_openers;
	spinlock_t pde_unload_lock;
	struct completion *pde_unload_completion;
	const struct inode_operations *proc_iops;
	union {
		const struct proc_ops *proc_ops;
		const struct file_operations *proc_dir_ops;
	};
	const struct dentry_operations *proc_dops;
	union {
		const struct seq_operations *seq_ops;
		int (*single_show)(struct seq_file *, void *);
	};
	proc_write_t write;
	void *data;
	unsigned int state_size;
	unsigned int low_ino;
	nlink_t nlink;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct proc_dir_entry *parent;
	struct rb_root subdir;
	struct rb_node subdir_node;
	char *name;
	umode_t mode;
	u8 flags;
	u8 namelen;
	char inline_name[0];
};

union proc_op {
	int (*proc_get_link)(struct dentry *, struct path *);
	int (*proc_show)(struct seq_file *, struct pid_namespace *, struct pid *, struct task_struct *);
	const char *lsm;
};

struct proc_inode {
	struct pid *pid;
	unsigned int fd;
	union proc_op op;
	struct proc_dir_entry *pde;
	struct ctl_table_header *sysctl;
	struct ctl_table *sysctl_entry;
	struct hlist_node sibling_inodes;
	const struct proc_ns_operations *ns_ops;
	struct inode vfs_inode;
};

struct proc_fs_opts {
	int flag;
	const char *str;
};

struct file_handle {
	__u32 handle_bytes;
	int handle_type;
	unsigned char f_handle[0];
};

struct inotify_inode_mark {
	struct fsnotify_mark fsn_mark;
	int wd;
};

struct dnotify_struct {
	struct dnotify_struct *dn_next;
	__u32 dn_mask;
	int dn_fd;
	struct file *dn_filp;
	fl_owner_t dn_owner;
};

struct dnotify_mark {
	struct fsnotify_mark fsn_mark;
	struct dnotify_struct *dn;
};

struct inotify_event_info {
	struct fsnotify_event fse;
	u32 mask;
	int wd;
	u32 sync_cookie;
	int name_len;
	char name[0];
};

struct inotify_event {
	__s32 wd;
	__u32 mask;
	__u32 cookie;
	__u32 len;
	char name[0];
};

enum {
	FAN_EVENT_INIT = 0,
	FAN_EVENT_REPORTED = 1,
	FAN_EVENT_ANSWERED = 2,
	FAN_EVENT_CANCELED = 3,
};

struct fanotify_fh {
	u8 type;
	u8 len;
	u8 flags;
	u8 pad;
	unsigned char buf[0];
};

struct fanotify_info {
	u8 dir_fh_totlen;
	u8 file_fh_totlen;
	u8 name_len;
	u8 pad;
	unsigned char buf[0];
};

enum fanotify_event_type {
	FANOTIFY_EVENT_TYPE_FID = 0,
	FANOTIFY_EVENT_TYPE_FID_NAME = 1,
	FANOTIFY_EVENT_TYPE_PATH = 2,
	FANOTIFY_EVENT_TYPE_PATH_PERM = 3,
	FANOTIFY_EVENT_TYPE_OVERFLOW = 4,
	__FANOTIFY_EVENT_TYPE_NUM = 5,
};

struct fanotify_event {
	struct fsnotify_event fse;
	struct hlist_node merge_list;
	u32 mask;
	struct {
		unsigned int type: 3;
		unsigned int hash: 29;
	};
	struct pid *pid;
};

struct fanotify_fid_event {
	struct fanotify_event fae;
	__kernel_fsid_t fsid;
	struct fanotify_fh object_fh;
	unsigned char _inline_fh_buf[12];
};

struct fanotify_name_event {
	struct fanotify_event fae;
	__kernel_fsid_t fsid;
	struct fanotify_info info;
};

struct fanotify_path_event {
	struct fanotify_event fae;
	struct path path;
};

struct fanotify_perm_event {
	struct fanotify_event fae;
	struct path path;
	short unsigned int response;
	short unsigned int state;
	int fd;
};

struct fanotify_event_metadata {
	__u32 event_len;
	__u8 vers;
	__u8 reserved;
	__u16 metadata_len;
	__u64 mask;
	__s32 fd;
	__s32 pid;
};

struct fanotify_event_info_header {
	__u8 info_type;
	__u8 pad;
	__u16 len;
};

struct fanotify_event_info_fid {
	struct fanotify_event_info_header hdr;
	__kernel_fsid_t fsid;
	unsigned char handle[0];
};

struct fanotify_response {
	__s32 fd;
	__u32 response;
};

struct epoll_event {
	__poll_t events;
	__u64 data;
};

struct epoll_filefd {
	struct file *file;
	int fd;
} __attribute__((packed));

struct epitem;

struct eppoll_entry {
	struct eppoll_entry *next;
	struct epitem *base;
	wait_queue_entry_t wait;
	wait_queue_head_t *whead;
};

struct eventpoll;

struct epitem {
	union {
		struct rb_node rbn;
		struct callback_head rcu;
	};
	struct list_head rdllink;
	struct epitem *next;
	struct epoll_filefd ffd;
	struct eppoll_entry *pwqlist;
	struct eventpoll *ep;
	struct hlist_node fllink;
	struct wakeup_source *ws;
	struct epoll_event event;
};

struct eventpoll {
	struct mutex mtx;
	wait_queue_head_t wq;
	wait_queue_head_t poll_wait;
	struct list_head rdllist;
	rwlock_t lock;
	struct rb_root_cached rbr;
	struct epitem *ovflist;
	struct wakeup_source *ws;
	struct user_struct *user;
	struct file *file;
	u64 gen;
	struct hlist_head refs;
	unsigned int napi_id;
};

struct ep_pqueue {
	poll_table pt;
	struct epitem *epi;
};

struct epitems_head {
	struct hlist_head epitems;
	struct epitems_head *next;
};

struct signalfd_siginfo {
	__u32 ssi_signo;
	__s32 ssi_errno;
	__s32 ssi_code;
	__u32 ssi_pid;
	__u32 ssi_uid;
	__s32 ssi_fd;
	__u32 ssi_tid;
	__u32 ssi_band;
	__u32 ssi_overrun;
	__u32 ssi_trapno;
	__s32 ssi_status;
	__s32 ssi_int;
	__u64 ssi_ptr;
	__u64 ssi_utime;
	__u64 ssi_stime;
	__u64 ssi_addr;
	__u16 ssi_addr_lsb;
	__u16 __pad2;
	__s32 ssi_syscall;
	__u64 ssi_call_addr;
	__u32 ssi_arch;
	__u8 __pad[28];
};

struct signalfd_ctx {
	sigset_t sigmask;
};

struct timerfd_ctx {
	union {
		struct hrtimer tmr;
		struct alarm alarm;
	} t;
	ktime_t tintv;
	ktime_t moffs;
	wait_queue_head_t wqh;
	u64 ticks;
	int clockid;
	short unsigned int expired;
	short unsigned int settime_flags;
	struct callback_head rcu;
	struct list_head clist;
	spinlock_t cancel_lock;
	bool might_cancel;
};

struct eventfd_ctx___2 {
	struct kref kref;
	wait_queue_head_t wqh;
	__u64 count;
	unsigned int flags;
	int id;
};

struct userfaultfd_ctx {
	wait_queue_head_t fault_pending_wqh;
	wait_queue_head_t fault_wqh;
	wait_queue_head_t fd_wqh;
	wait_queue_head_t event_wqh;
	seqcount_spinlock_t refile_seq;
	refcount_t refcount;
	unsigned int flags;
	unsigned int features;
	bool released;
	bool mmap_changing;
	struct mm_struct *mm;
};

struct uffd_msg {
	__u8 event;
	__u8 reserved1;
	__u16 reserved2;
	__u32 reserved3;
	union {
		struct {
			__u64 flags;
			__u64 address;
			union {
				__u32 ptid;
			} feat;
		} pagefault;
		struct {
			__u32 ufd;
		} fork;
		struct {
			__u64 from;
			__u64 to;
			__u64 len;
		} remap;
		struct {
			__u64 start;
			__u64 end;
		} remove;
		struct {
			__u64 reserved1;
			__u64 reserved2;
			__u64 reserved3;
		} reserved;
	} arg;
};

struct uffdio_api {
	__u64 api;
	__u64 features;
	__u64 ioctls;
};

struct uffdio_range {
	__u64 start;
	__u64 len;
};

struct uffdio_register {
	struct uffdio_range range;
	__u64 mode;
	__u64 ioctls;
};

struct uffdio_copy {
	__u64 dst;
	__u64 src;
	__u64 len;
	__u64 mode;
	__s64 copy;
};

struct uffdio_zeropage {
	struct uffdio_range range;
	__u64 mode;
	__s64 zeropage;
};

struct uffdio_writeprotect {
	struct uffdio_range range;
	__u64 mode;
};

struct uffdio_continue {
	struct uffdio_range range;
	__u64 mode;
	__s64 mapped;
};

struct userfaultfd_fork_ctx {
	struct userfaultfd_ctx *orig;
	struct userfaultfd_ctx *new;
	struct list_head list;
};

struct userfaultfd_unmap_ctx {
	struct userfaultfd_ctx *ctx;
	long unsigned int start;
	long unsigned int end;
	struct list_head list;
};

struct userfaultfd_wait_queue {
	struct uffd_msg msg;
	wait_queue_entry_t wq;
	struct userfaultfd_ctx *ctx;
	bool waken;
};

struct userfaultfd_wake_range {
	long unsigned int start;
	long unsigned int len;
};

typedef u32 compat_aio_context_t;

struct kioctx;

struct kioctx_table {
	struct callback_head rcu;
	unsigned int nr;
	struct kioctx *table[0];
};

typedef __kernel_ulong_t aio_context_t;

enum {
	IOCB_CMD_PREAD = 0,
	IOCB_CMD_PWRITE = 1,
	IOCB_CMD_FSYNC = 2,
	IOCB_CMD_FDSYNC = 3,
	IOCB_CMD_POLL = 5,
	IOCB_CMD_NOOP = 6,
	IOCB_CMD_PREADV = 7,
	IOCB_CMD_PWRITEV = 8,
};

struct io_event {
	__u64 data;
	__u64 obj;
	__s64 res;
	__s64 res2;
};

struct iocb {
	__u64 aio_data;
	__u32 aio_key;
	__kernel_rwf_t aio_rw_flags;
	__u16 aio_lio_opcode;
	__s16 aio_reqprio;
	__u32 aio_fildes;
	__u64 aio_buf;
	__u64 aio_nbytes;
	__s64 aio_offset;
	__u64 aio_reserved2;
	__u32 aio_flags;
	__u32 aio_resfd;
};

typedef int kiocb_cancel_fn(struct kiocb *);

struct aio_ring {
	unsigned int id;
	unsigned int nr;
	unsigned int head;
	unsigned int tail;
	unsigned int magic;
	unsigned int compat_features;
	unsigned int incompat_features;
	unsigned int header_length;
	struct io_event io_events[0];
};

struct kioctx_cpu;

struct ctx_rq_wait;

struct kioctx {
	struct percpu_ref users;
	atomic_t dead;
	struct percpu_ref reqs;
	long unsigned int user_id;
	struct kioctx_cpu *cpu;
	unsigned int req_batch;
	unsigned int max_reqs;
	unsigned int nr_events;
	long unsigned int mmap_base;
	long unsigned int mmap_size;
	struct page **ring_pages;
	long int nr_pages;
	struct rcu_work free_rwork;
	struct ctx_rq_wait *rq_wait;
	long: 64;
	long: 64;
	long: 64;
	struct {
		atomic_t reqs_available;
		long: 32;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		spinlock_t ctx_lock;
		struct list_head active_reqs;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex ring_lock;
		wait_queue_head_t wait;
		long: 64;
	};
	struct {
		unsigned int tail;
		unsigned int completed_events;
		spinlock_t completion_lock;
		long: 32;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct page *internal_pages[8];
	struct file *aio_ring_file;
	unsigned int id;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kioctx_cpu {
	unsigned int reqs_available;
};

struct ctx_rq_wait {
	struct completion comp;
	atomic_t count;
};

struct fsync_iocb {
	struct file *file;
	struct work_struct work;
	bool datasync;
	struct cred *creds;
};

struct poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool cancelled;
	bool work_scheduled;
	bool work_need_resched;
	struct wait_queue_entry wait;
	struct work_struct work;
};

struct aio_kiocb {
	union {
		struct file *ki_filp;
		struct kiocb rw;
		struct fsync_iocb fsync;
		struct poll_iocb poll;
	};
	struct kioctx *ki_ctx;
	kiocb_cancel_fn *ki_cancel;
	struct io_event ki_res;
	struct list_head ki_list;
	refcount_t ki_refcnt;
	struct eventfd_ctx *ki_eventfd;
};

struct aio_poll_table {
	struct poll_table_struct pt;
	struct aio_kiocb *iocb;
	bool queued;
	int error;
};

struct __aio_sigset {
	const sigset_t *sigmask;
	size_t sigsetsize;
};

struct __compat_aio_sigset {
	compat_uptr_t sigmask;
	compat_size_t sigsetsize;
};

typedef s32 compat_ssize_t;

struct io_wq;

struct io_wq_work_node;

struct io_wq_work_list {
	struct io_wq_work_node *first;
	struct io_wq_work_node *last;
};

struct io_ring_ctx;

struct io_uring_task {
	struct xarray xa;
	struct wait_queue_head wait;
	const struct io_ring_ctx *last;
	struct io_wq *io_wq;
	struct percpu_counter inflight;
	atomic_t inflight_tracked;
	atomic_t in_idle;
	spinlock_t task_lock;
	struct io_wq_work_list task_list;
	long unsigned int task_state;
	struct callback_head task_work;
};

struct xa_limit {
	u32 max;
	u32 min;
};

enum {
	PERCPU_REF_INIT_ATOMIC = 1,
	PERCPU_REF_INIT_DEAD = 2,
	PERCPU_REF_ALLOW_REINIT = 4,
};

struct user_msghdr {
	void *msg_name;
	int msg_namelen;
	struct iovec *msg_iov;
	__kernel_size_t msg_iovlen;
	void *msg_control;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
};

struct compat_msghdr {
	compat_uptr_t msg_name;
	compat_int_t msg_namelen;
	compat_uptr_t msg_iov;
	compat_size_t msg_iovlen;
	compat_uptr_t msg_control;
	compat_size_t msg_controllen;
	compat_uint_t msg_flags;
};

struct scm_fp_list {
	short int count;
	short int max;
	struct user_struct *user;
	struct file *fp[253];
};

struct unix_skb_parms {
	struct pid *pid;
	kuid_t uid;
	kgid_t gid;
	struct scm_fp_list *fp;
	struct lsmblob lsmblob;
	u32 consumed;
};

struct trace_event_raw_io_uring_create {
	struct trace_entry ent;
	int fd;
	void *ctx;
	u32 sq_entries;
	u32 cq_entries;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_io_uring_register {
	struct trace_entry ent;
	void *ctx;
	unsigned int opcode;
	unsigned int nr_files;
	unsigned int nr_bufs;
	bool eventfd;
	long int ret;
	char __data[0];
};

struct trace_event_raw_io_uring_file_get {
	struct trace_entry ent;
	void *ctx;
	int fd;
	char __data[0];
};

struct io_wq_work;

struct trace_event_raw_io_uring_queue_async_work {
	struct trace_entry ent;
	void *ctx;
	int rw;
	void *req;
	struct io_wq_work *work;
	unsigned int flags;
	char __data[0];
};

struct io_wq_work_node {
	struct io_wq_work_node *next;
};

struct io_wq_work {
	struct io_wq_work_node list;
	unsigned int flags;
};

struct trace_event_raw_io_uring_defer {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int data;
	char __data[0];
};

struct trace_event_raw_io_uring_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	void *target_req;
	char __data[0];
};

struct trace_event_raw_io_uring_cqring_wait {
	struct trace_entry ent;
	void *ctx;
	int min_events;
	char __data[0];
};

struct trace_event_raw_io_uring_fail_link {
	struct trace_entry ent;
	void *req;
	void *link;
	char __data[0];
};

struct trace_event_raw_io_uring_complete {
	struct trace_entry ent;
	void *ctx;
	u64 user_data;
	int res;
	unsigned int cflags;
	char __data[0];
};

struct trace_event_raw_io_uring_submit_sqe {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	bool force_nonblock;
	bool sq_thread;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_arm {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	int events;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_wake {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	char __data[0];
};

struct trace_event_raw_io_uring_task_add {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	char __data[0];
};

struct trace_event_raw_io_uring_task_run {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	char __data[0];
};

struct trace_event_data_offsets_io_uring_create {};

struct trace_event_data_offsets_io_uring_register {};

struct trace_event_data_offsets_io_uring_file_get {};

struct trace_event_data_offsets_io_uring_queue_async_work {};

struct trace_event_data_offsets_io_uring_defer {};

struct trace_event_data_offsets_io_uring_link {};

struct trace_event_data_offsets_io_uring_cqring_wait {};

struct trace_event_data_offsets_io_uring_fail_link {};

struct trace_event_data_offsets_io_uring_complete {};

struct trace_event_data_offsets_io_uring_submit_sqe {};

struct trace_event_data_offsets_io_uring_poll_arm {};

struct trace_event_data_offsets_io_uring_poll_wake {};

struct trace_event_data_offsets_io_uring_task_add {};

struct trace_event_data_offsets_io_uring_task_run {};

typedef void (*btf_trace_io_uring_create)(void *, int, void *, u32, u32, u32);

typedef void (*btf_trace_io_uring_register)(void *, void *, unsigned int, unsigned int, unsigned int, bool, long int);

typedef void (*btf_trace_io_uring_file_get)(void *, void *, int);

typedef void (*btf_trace_io_uring_queue_async_work)(void *, void *, int, void *, struct io_wq_work *, unsigned int);

typedef void (*btf_trace_io_uring_defer)(void *, void *, void *, long long unsigned int);

typedef void (*btf_trace_io_uring_link)(void *, void *, void *, void *);

typedef void (*btf_trace_io_uring_cqring_wait)(void *, void *, int);

typedef void (*btf_trace_io_uring_fail_link)(void *, void *, void *);

typedef void (*btf_trace_io_uring_complete)(void *, void *, u64, int, unsigned int);

typedef void (*btf_trace_io_uring_submit_sqe)(void *, void *, u8, u64, bool, bool);

typedef void (*btf_trace_io_uring_poll_arm)(void *, void *, u8, u64, int, int);

typedef void (*btf_trace_io_uring_poll_wake)(void *, void *, u8, u64, int);

typedef void (*btf_trace_io_uring_task_add)(void *, void *, u8, u64, int);

typedef void (*btf_trace_io_uring_task_run)(void *, void *, u8, u64);

struct io_uring_sqe {
	__u8 opcode;
	__u8 flags;
	__u16 ioprio;
	__s32 fd;
	union {
		__u64 off;
		__u64 addr2;
	};
	union {
		__u64 addr;
		__u64 splice_off_in;
	};
	__u32 len;
	union {
		__kernel_rwf_t rw_flags;
		__u32 fsync_flags;
		__u16 poll_events;
		__u32 poll32_events;
		__u32 sync_range_flags;
		__u32 msg_flags;
		__u32 timeout_flags;
		__u32 accept_flags;
		__u32 cancel_flags;
		__u32 open_flags;
		__u32 statx_flags;
		__u32 fadvise_advice;
		__u32 splice_flags;
		__u32 rename_flags;
		__u32 unlink_flags;
	};
	__u64 user_data;
	union {
		struct {
			union {
				__u16 buf_index;
				__u16 buf_group;
			};
			__u16 personality;
			__s32 splice_fd_in;
		};
		__u64 __pad2[3];
	};
};

enum {
	IOSQE_FIXED_FILE_BIT = 0,
	IOSQE_IO_DRAIN_BIT = 1,
	IOSQE_IO_LINK_BIT = 2,
	IOSQE_IO_HARDLINK_BIT = 3,
	IOSQE_ASYNC_BIT = 4,
	IOSQE_BUFFER_SELECT_BIT = 5,
};

enum {
	IORING_OP_NOP = 0,
	IORING_OP_READV = 1,
	IORING_OP_WRITEV = 2,
	IORING_OP_FSYNC = 3,
	IORING_OP_READ_FIXED = 4,
	IORING_OP_WRITE_FIXED = 5,
	IORING_OP_POLL_ADD = 6,
	IORING_OP_POLL_REMOVE = 7,
	IORING_OP_SYNC_FILE_RANGE = 8,
	IORING_OP_SENDMSG = 9,
	IORING_OP_RECVMSG = 10,
	IORING_OP_TIMEOUT = 11,
	IORING_OP_TIMEOUT_REMOVE = 12,
	IORING_OP_ACCEPT = 13,
	IORING_OP_ASYNC_CANCEL = 14,
	IORING_OP_LINK_TIMEOUT = 15,
	IORING_OP_CONNECT = 16,
	IORING_OP_FALLOCATE = 17,
	IORING_OP_OPENAT = 18,
	IORING_OP_CLOSE = 19,
	IORING_OP_FILES_UPDATE = 20,
	IORING_OP_STATX = 21,
	IORING_OP_READ = 22,
	IORING_OP_WRITE = 23,
	IORING_OP_FADVISE = 24,
	IORING_OP_MADVISE = 25,
	IORING_OP_SEND = 26,
	IORING_OP_RECV = 27,
	IORING_OP_OPENAT2 = 28,
	IORING_OP_EPOLL_CTL = 29,
	IORING_OP_SPLICE = 30,
	IORING_OP_PROVIDE_BUFFERS = 31,
	IORING_OP_REMOVE_BUFFERS = 32,
	IORING_OP_TEE = 33,
	IORING_OP_SHUTDOWN = 34,
	IORING_OP_RENAMEAT = 35,
	IORING_OP_UNLINKAT = 36,
	IORING_OP_LAST = 37,
};

struct io_uring_cqe {
	__u64 user_data;
	__s32 res;
	__u32 flags;
};

enum {
	IORING_CQE_BUFFER_SHIFT = 16,
};

struct io_sqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 flags;
	__u32 dropped;
	__u32 array;
	__u32 resv1;
	__u64 resv2;
};

struct io_cqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 overflow;
	__u32 cqes;
	__u32 flags;
	__u32 resv1;
	__u64 resv2;
};

struct io_uring_params {
	__u32 sq_entries;
	__u32 cq_entries;
	__u32 flags;
	__u32 sq_thread_cpu;
	__u32 sq_thread_idle;
	__u32 features;
	__u32 wq_fd;
	__u32 resv[3];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
};

enum {
	IORING_REGISTER_BUFFERS = 0,
	IORING_UNREGISTER_BUFFERS = 1,
	IORING_REGISTER_FILES = 2,
	IORING_UNREGISTER_FILES = 3,
	IORING_REGISTER_EVENTFD = 4,
	IORING_UNREGISTER_EVENTFD = 5,
	IORING_REGISTER_FILES_UPDATE = 6,
	IORING_REGISTER_EVENTFD_ASYNC = 7,
	IORING_REGISTER_PROBE = 8,
	IORING_REGISTER_PERSONALITY = 9,
	IORING_UNREGISTER_PERSONALITY = 10,
	IORING_REGISTER_RESTRICTIONS = 11,
	IORING_REGISTER_ENABLE_RINGS = 12,
	IORING_REGISTER_FILES2 = 13,
	IORING_REGISTER_FILES_UPDATE2 = 14,
	IORING_REGISTER_BUFFERS2 = 15,
	IORING_REGISTER_BUFFERS_UPDATE = 16,
	IORING_REGISTER_LAST = 17,
};

struct io_uring_rsrc_register {
	__u32 nr;
	__u32 resv;
	__u64 resv2;
	__u64 data;
	__u64 tags;
};

struct io_uring_rsrc_update2 {
	__u32 offset;
	__u32 resv;
	__u64 data;
	__u64 tags;
	__u32 nr;
	__u32 resv2;
};

struct io_uring_probe_op {
	__u8 op;
	__u8 resv;
	__u16 flags;
	__u32 resv2;
};

struct io_uring_probe {
	__u8 last_op;
	__u8 ops_len;
	__u16 resv;
	__u32 resv2[3];
	struct io_uring_probe_op ops[0];
};

struct io_uring_restriction {
	__u16 opcode;
	union {
		__u8 register_op;
		__u8 sqe_op;
		__u8 sqe_flags;
	};
	__u8 resv;
	__u32 resv2[3];
};

enum {
	IORING_RESTRICTION_REGISTER_OP = 0,
	IORING_RESTRICTION_SQE_OP = 1,
	IORING_RESTRICTION_SQE_FLAGS_ALLOWED = 2,
	IORING_RESTRICTION_SQE_FLAGS_REQUIRED = 3,
	IORING_RESTRICTION_LAST = 4,
};

struct io_uring_getevents_arg {
	__u64 sigmask;
	__u32 sigmask_sz;
	__u32 pad;
	__u64 ts;
};

enum {
	IO_WQ_WORK_CANCEL = 1,
	IO_WQ_WORK_HASHED = 2,
	IO_WQ_WORK_UNBOUND = 4,
	IO_WQ_WORK_CONCURRENT = 16,
	IO_WQ_HASH_SHIFT = 24,
};

enum io_wq_cancel {
	IO_WQ_CANCEL_OK = 0,
	IO_WQ_CANCEL_RUNNING = 1,
	IO_WQ_CANCEL_NOTFOUND = 2,
};

typedef struct io_wq_work *free_work_fn(struct io_wq_work *);

typedef void io_wq_work_fn(struct io_wq_work *);

struct io_wq_hash {
	refcount_t refs;
	long unsigned int map;
	struct wait_queue_head wait;
};

struct io_wq_data {
	struct io_wq_hash *hash;
	struct task_struct *task;
	io_wq_work_fn *do_work;
	free_work_fn *free_work;
};

struct io_uring {
	u32 head;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 tail;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_rings {
	struct io_uring sq;
	struct io_uring cq;
	u32 sq_ring_mask;
	u32 cq_ring_mask;
	u32 sq_ring_entries;
	u32 cq_ring_entries;
	u32 sq_dropped;
	u32 sq_flags;
	u32 cq_flags;
	u32 cq_overflow;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct io_uring_cqe cqes[0];
};

enum io_uring_cmd_flags {
	IO_URING_F_NONBLOCK = 1,
	IO_URING_F_COMPLETE_DEFER = 2,
};

struct io_mapped_ubuf {
	u64 ubuf;
	u64 ubuf_end;
	unsigned int nr_bvecs;
	long unsigned int acct_pages;
	struct bio_vec bvec[0];
};

struct io_overflow_cqe {
	struct io_uring_cqe cqe;
	struct list_head list;
};

struct io_fixed_file {
	long unsigned int file_ptr;
};

struct io_rsrc_put {
	struct list_head list;
	u64 tag;
	union {
		void *rsrc;
		struct file *file;
		struct io_mapped_ubuf *buf;
	};
};

struct io_file_table {
	struct io_fixed_file **files;
};

struct io_rsrc_data;

struct io_rsrc_node {
	struct percpu_ref refs;
	struct list_head node;
	struct list_head rsrc_list;
	struct io_rsrc_data *rsrc_data;
	struct llist_node llist;
	bool done;
};

typedef void rsrc_put_fn(struct io_ring_ctx *, struct io_rsrc_put *);

struct io_rsrc_data {
	struct io_ring_ctx *ctx;
	u64 *tags;
	rsrc_put_fn *do_put;
	atomic_t refs;
	struct completion done;
	bool quiesce;
};

struct io_kiocb;

struct io_submit_link {
	struct io_kiocb *head;
	struct io_kiocb *last;
};

struct io_comp_state {
	struct io_kiocb *reqs[32];
	unsigned int nr;
	struct list_head free_list;
};

struct io_submit_state {
	struct blk_plug plug;
	struct io_submit_link link;
	void *reqs[32];
	unsigned int free_reqs;
	bool plug_started;
	struct io_comp_state comp;
	struct file *file;
	unsigned int fd;
	unsigned int file_refs;
	unsigned int ios_left;
};

struct io_restriction {
	long unsigned int register_op[1];
	long unsigned int sqe_op[1];
	u8 sqe_flags_allowed;
	u8 sqe_flags_required;
	bool registered;
};

struct io_sq_data;

struct io_ring_ctx {
	struct {
		struct percpu_ref refs;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		unsigned int flags;
		unsigned int compat: 1;
		unsigned int drain_next: 1;
		unsigned int eventfd_async: 1;
		unsigned int restricted: 1;
		u32 *sq_array;
		unsigned int cached_sq_head;
		unsigned int sq_entries;
		unsigned int sq_mask;
		unsigned int sq_thread_idle;
		unsigned int cached_sq_dropped;
		unsigned int cached_cq_overflow;
		long unsigned int sq_check_overflow;
		struct list_head defer_list;
		struct list_head timeout_list;
		struct list_head cq_overflow_list;
		struct io_uring_sqe *sq_sqes;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex uring_lock;
		wait_queue_head_t wait;
		long: 64;
	};
	struct io_submit_state submit_state;
	struct list_head locked_free_list;
	unsigned int locked_free_nr;
	struct io_rings *rings;
	const struct cred *sq_creds;
	struct io_sq_data *sq_data;
	struct wait_queue_head sqo_sq_wait;
	struct list_head sqd_list;
	struct io_rsrc_data *file_data;
	struct io_file_table file_table;
	unsigned int nr_user_files;
	struct io_rsrc_data *buf_data;
	unsigned int nr_user_bufs;
	struct io_mapped_ubuf **user_bufs;
	struct xarray io_buffers;
	struct xarray personalities;
	u32 pers_next;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct {
		unsigned int cached_cq_tail;
		unsigned int cq_entries;
		unsigned int cq_mask;
		atomic_t cq_timeouts;
		unsigned int cq_last_tm_flush;
		unsigned int cq_extra;
		long unsigned int cq_check_overflow;
		struct wait_queue_head cq_wait;
		struct eventfd_ctx *cq_ev_fd;
	};
	struct {
		spinlock_t completion_lock;
		struct list_head iopoll_list;
		struct hlist_head *cancel_hash;
		unsigned int cancel_hash_bits;
		bool poll_multi_file;
		long: 24;
		long: 64;
		long: 64;
		long: 64;
	};
	struct delayed_work rsrc_put_work;
	struct llist_head rsrc_put_llist;
	struct list_head rsrc_ref_list;
	spinlock_t rsrc_ref_lock;
	struct io_rsrc_node *rsrc_node;
	struct io_rsrc_node *rsrc_backup_node;
	struct io_mapped_ubuf *dummy_ubuf;
	struct io_restriction restrictions;
	struct {
		struct socket *ring_sock;
		struct io_wq_hash *hash_map;
		struct user_struct *user;
		struct mm_struct *mm_account;
		struct callback_head *exit_task_work;
		struct work_struct exit_work;
		struct list_head tctx_list;
		struct completion ref_comp;
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_buffer {
	struct list_head list;
	__u64 addr;
	__u32 len;
	__u16 bid;
};

enum {
	IO_SQ_THREAD_SHOULD_STOP = 0,
	IO_SQ_THREAD_SHOULD_PARK = 1,
};

struct io_sq_data {
	refcount_t refs;
	atomic_t park_pending;
	struct mutex lock;
	struct list_head ctx_list;
	struct task_struct *thread;
	struct wait_queue_head wait;
	unsigned int sq_thread_idle;
	int sq_cpu;
	pid_t task_pid;
	pid_t task_tgid;
	long unsigned int state;
	struct completion exited;
	struct callback_head *park_task_work;
};

struct io_rw {
	struct kiocb kiocb;
	u64 addr;
	u64 len;
};

struct io_poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool done;
	bool canceled;
	struct wait_queue_entry wait;
};

struct io_poll_update {
	struct file *file;
	u64 old_user_data;
	u64 new_user_data;
	__poll_t events;
	bool update_events;
	bool update_user_data;
};

struct io_accept {
	struct file *file;
	struct sockaddr *addr;
	int *addr_len;
	int flags;
	long unsigned int nofile;
};

struct io_sync {
	struct file *file;
	loff_t len;
	loff_t off;
	int flags;
	int mode;
};

struct io_cancel {
	struct file *file;
	u64 addr;
};

struct io_timeout {
	struct file *file;
	u32 off;
	u32 target_seq;
	struct list_head list;
	struct io_kiocb *head;
};

struct io_timeout_rem {
	struct file *file;
	u64 addr;
	struct timespec64 ts;
	u32 flags;
};

struct io_connect {
	struct file *file;
	struct sockaddr *addr;
	int addr_len;
};

struct io_sr_msg {
	struct file *file;
	union {
		struct compat_msghdr *umsg_compat;
		struct user_msghdr *umsg;
		void *buf;
	};
	int msg_flags;
	int bgid;
	size_t len;
	struct io_buffer *kbuf;
};

struct io_open {
	struct file *file;
	int dfd;
	struct filename *filename;
	struct open_how how;
	long unsigned int nofile;
};

struct io_close {
	struct file *file;
	int fd;
};

struct io_rsrc_update {
	struct file *file;
	u64 arg;
	u32 nr_args;
	u32 offset;
};

struct io_fadvise {
	struct file *file;
	u64 offset;
	u32 len;
	u32 advice;
};

struct io_madvise {
	struct file *file;
	u64 addr;
	u32 len;
	u32 advice;
};

struct io_epoll {
	struct file *file;
	int epfd;
	int op;
	int fd;
	struct epoll_event event;
};

struct io_splice {
	struct file *file_out;
	struct file *file_in;
	loff_t off_out;
	loff_t off_in;
	u64 len;
	unsigned int flags;
};

struct io_provide_buf {
	struct file *file;
	__u64 addr;
	__u32 len;
	__u32 bgid;
	__u16 nbufs;
	__u16 bid;
};

struct io_statx {
	struct file *file;
	int dfd;
	unsigned int mask;
	unsigned int flags;
	const char *filename;
	struct statx *buffer;
};

struct io_shutdown {
	struct file *file;
	int how;
};

struct io_rename {
	struct file *file;
	int old_dfd;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
	int flags;
};

struct io_unlink {
	struct file *file;
	int dfd;
	int flags;
	struct filename *filename;
};

struct io_completion {
	struct file *file;
	struct list_head list;
	u32 cflags;
};

struct io_task_work {
	struct io_wq_work_node node;
	task_work_func_t func;
};

struct async_poll;

struct io_kiocb {
	union {
		struct file *file;
		struct io_rw rw;
		struct io_poll_iocb poll;
		struct io_poll_update poll_update;
		struct io_accept accept;
		struct io_sync sync;
		struct io_cancel cancel;
		struct io_timeout timeout;
		struct io_timeout_rem timeout_rem;
		struct io_connect connect;
		struct io_sr_msg sr_msg;
		struct io_open open;
		struct io_close close;
		struct io_rsrc_update rsrc_update;
		struct io_fadvise fadvise;
		struct io_madvise madvise;
		struct io_epoll epoll;
		struct io_splice splice;
		struct io_provide_buf pbuf;
		struct io_statx statx;
		struct io_shutdown shutdown;
		struct io_rename rename;
		struct io_unlink unlink;
		struct io_completion compl;
	};
	void *async_data;
	u8 opcode;
	u8 iopoll_completed;
	u16 buf_index;
	u32 result;
	struct io_ring_ctx *ctx;
	unsigned int flags;
	atomic_t refs;
	struct task_struct *task;
	u64 user_data;
	struct io_kiocb *link;
	struct percpu_ref *fixed_rsrc_refs;
	struct list_head inflight_entry;
	union {
		struct io_task_work io_task_work;
		struct callback_head task_work;
	};
	struct hlist_node hash_node;
	struct async_poll *apoll;
	struct io_wq_work work;
	const struct cred *creds;
	struct io_mapped_ubuf *imu;
};

struct io_timeout_data {
	struct io_kiocb *req;
	struct hrtimer timer;
	struct timespec64 ts;
	enum hrtimer_mode mode;
};

struct io_async_connect {
	struct __kernel_sockaddr_storage address;
};

struct io_async_msghdr {
	struct iovec fast_iov[8];
	struct iovec *free_iov;
	struct sockaddr *uaddr;
	struct msghdr msg;
	struct __kernel_sockaddr_storage addr;
};

struct io_async_rw {
	struct iovec fast_iov[8];
	const struct iovec *free_iovec;
	struct iov_iter iter;
	size_t bytes_done;
	struct wait_page_queue wpq;
};

enum {
	REQ_F_FIXED_FILE_BIT = 0,
	REQ_F_IO_DRAIN_BIT = 1,
	REQ_F_LINK_BIT = 2,
	REQ_F_HARDLINK_BIT = 3,
	REQ_F_FORCE_ASYNC_BIT = 4,
	REQ_F_BUFFER_SELECT_BIT = 5,
	REQ_F_FAIL_LINK_BIT = 8,
	REQ_F_INFLIGHT_BIT = 9,
	REQ_F_CUR_POS_BIT = 10,
	REQ_F_NOWAIT_BIT = 11,
	REQ_F_LINK_TIMEOUT_BIT = 12,
	REQ_F_NEED_CLEANUP_BIT = 13,
	REQ_F_POLLED_BIT = 14,
	REQ_F_BUFFER_SELECTED_BIT = 15,
	REQ_F_LTIMEOUT_ACTIVE_BIT = 16,
	REQ_F_COMPLETE_INLINE_BIT = 17,
	REQ_F_REISSUE_BIT = 18,
	REQ_F_DONT_REISSUE_BIT = 19,
	REQ_F_ASYNC_READ_BIT = 20,
	REQ_F_ASYNC_WRITE_BIT = 21,
	REQ_F_ISREG_BIT = 22,
	__REQ_F_LAST_BIT = 23,
};

enum {
	REQ_F_FIXED_FILE = 1,
	REQ_F_IO_DRAIN = 2,
	REQ_F_LINK = 4,
	REQ_F_HARDLINK = 8,
	REQ_F_FORCE_ASYNC = 16,
	REQ_F_BUFFER_SELECT = 32,
	REQ_F_FAIL_LINK = 256,
	REQ_F_INFLIGHT = 512,
	REQ_F_CUR_POS = 1024,
	REQ_F_NOWAIT = 2048,
	REQ_F_LINK_TIMEOUT = 4096,
	REQ_F_NEED_CLEANUP = 8192,
	REQ_F_POLLED = 16384,
	REQ_F_BUFFER_SELECTED = 32768,
	REQ_F_LTIMEOUT_ACTIVE = 65536,
	REQ_F_COMPLETE_INLINE = 131072,
	REQ_F_REISSUE = 262144,
	REQ_F_DONT_REISSUE = 524288,
	REQ_F_ASYNC_READ = 1048576,
	REQ_F_ASYNC_WRITE = 2097152,
	REQ_F_ISREG = 4194304,
};

struct async_poll {
	struct io_poll_iocb poll;
	struct io_poll_iocb *double_poll;
};

enum {
	IORING_RSRC_FILE = 0,
	IORING_RSRC_BUFFER = 1,
};

struct io_tctx_node {
	struct list_head ctx_node;
	struct task_struct *task;
	struct io_ring_ctx *ctx;
};

struct io_defer_entry {
	struct list_head list;
	struct io_kiocb *req;
	u32 seq;
};

struct io_op_def {
	unsigned int needs_file: 1;
	unsigned int hash_reg_file: 1;
	unsigned int unbound_nonreg_file: 1;
	unsigned int not_supported: 1;
	unsigned int pollin: 1;
	unsigned int pollout: 1;
	unsigned int buffer_select: 1;
	unsigned int needs_async_setup: 1;
	unsigned int plug: 1;
	short unsigned int async_size;
};

struct req_batch {
	struct task_struct *task;
	int task_refs;
	int ctx_refs;
};

struct io_poll_table {
	struct poll_table_struct pt;
	struct io_kiocb *req;
	int nr_entries;
	int error;
};

struct io_cancel_data {
	struct io_ring_ctx *ctx;
	u64 user_data;
};

struct io_wait_queue {
	struct wait_queue_entry wq;
	struct io_ring_ctx *ctx;
	unsigned int to_wait;
	unsigned int nr_timeouts;
};

struct io_tctx_exit {
	struct callback_head task_work;
	struct completion completion;
	struct io_ring_ctx *ctx;
};

struct io_task_cancel {
	struct task_struct *task;
	bool all;
};

struct creds;

typedef bool work_cancel_fn(struct io_wq_work *, void *);

enum {
	IO_WORKER_F_UP = 1,
	IO_WORKER_F_RUNNING = 2,
	IO_WORKER_F_FREE = 4,
	IO_WORKER_F_FIXED = 8,
	IO_WORKER_F_BOUND = 16,
};

enum {
	IO_WQ_BIT_EXIT = 0,
};

enum {
	IO_WQE_FLAG_STALLED = 1,
};

struct io_wqe;

struct io_worker {
	refcount_t ref;
	unsigned int flags;
	struct hlist_nulls_node nulls_node;
	struct list_head all_list;
	struct task_struct *task;
	struct io_wqe *wqe;
	struct io_wq_work *cur_work;
	spinlock_t lock;
	struct completion ref_done;
	long unsigned int create_state;
	struct callback_head create_work;
	int create_index;
	struct callback_head rcu;
};

struct io_wqe_acct {
	unsigned int nr_workers;
	unsigned int max_workers;
	int index;
	atomic_t nr_running;
};

struct io_wq___2;

struct io_wqe {
	struct {
		raw_spinlock_t lock;
		struct io_wq_work_list work_list;
		unsigned int flags;
		long: 32;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	int node;
	struct io_wqe_acct acct[2];
	struct hlist_nulls_head free_list;
	struct list_head all_list;
	struct wait_queue_entry wait;
	struct io_wq___2 *wq;
	struct io_wq_work *hash_tail[64];
	long: 64;
	long: 64;
};

enum {
	IO_WQ_ACCT_BOUND = 0,
	IO_WQ_ACCT_UNBOUND = 1,
};

struct io_wq___2 {
	struct io_wqe **wqes;
	long unsigned int state;
	free_work_fn *free_work;
	io_wq_work_fn *do_work;
	struct io_wq_hash *hash;
	refcount_t refs;
	atomic_t worker_refs;
	struct completion worker_done;
	struct hlist_node cpuhp_node;
	struct task_struct *task;
};

struct io_cb_cancel_data {
	work_cancel_fn *fn;
	void *data;
	int nr_running;
	int nr_pending;
	bool cancel_all;
};

struct iomap_ops {
	int (*iomap_begin)(struct inode *, loff_t, loff_t, unsigned int, struct iomap___2 *, struct iomap___2 *);
	int (*iomap_end)(struct inode *, loff_t, loff_t, ssize_t, unsigned int, struct iomap___2 *);
};

struct trace_event_raw_dax_pmd_fault_class {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int vm_start;
	long unsigned int vm_end;
	long unsigned int vm_flags;
	long unsigned int address;
	long unsigned int pgoff;
	long unsigned int max_pgoff;
	dev_t dev;
	unsigned int flags;
	int result;
	char __data[0];
};

struct trace_event_raw_dax_pmd_load_hole_class {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int vm_flags;
	long unsigned int address;
	struct page *zero_page;
	void *radix_entry;
	dev_t dev;
	char __data[0];
};

struct trace_event_raw_dax_pmd_insert_mapping_class {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int vm_flags;
	long unsigned int address;
	long int length;
	u64 pfn_val;
	void *radix_entry;
	dev_t dev;
	int write;
	char __data[0];
};

struct trace_event_raw_dax_pte_fault_class {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int vm_flags;
	long unsigned int address;
	long unsigned int pgoff;
	dev_t dev;
	unsigned int flags;
	int result;
	char __data[0];
};

struct trace_event_raw_dax_insert_mapping {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int vm_flags;
	long unsigned int address;
	void *radix_entry;
	dev_t dev;
	int write;
	char __data[0];
};

struct trace_event_raw_dax_writeback_range_class {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int start_index;
	long unsigned int end_index;
	dev_t dev;
	char __data[0];
};

struct trace_event_raw_dax_writeback_one {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int pgoff;
	long unsigned int pglen;
	dev_t dev;
	char __data[0];
};

struct trace_event_data_offsets_dax_pmd_fault_class {};

struct trace_event_data_offsets_dax_pmd_load_hole_class {};

struct trace_event_data_offsets_dax_pmd_insert_mapping_class {};

struct trace_event_data_offsets_dax_pte_fault_class {};

struct trace_event_data_offsets_dax_insert_mapping {};

struct trace_event_data_offsets_dax_writeback_range_class {};

struct trace_event_data_offsets_dax_writeback_one {};

typedef void (*btf_trace_dax_pmd_fault)(void *, struct inode *, struct vm_fault *, long unsigned int, int);

typedef void (*btf_trace_dax_pmd_fault_done)(void *, struct inode *, struct vm_fault *, long unsigned int, int);

typedef void (*btf_trace_dax_pmd_load_hole)(void *, struct inode *, struct vm_fault *, struct page *, void *);

typedef void (*btf_trace_dax_pmd_load_hole_fallback)(void *, struct inode *, struct vm_fault *, struct page *, void *);

typedef void (*btf_trace_dax_pmd_insert_mapping)(void *, struct inode *, struct vm_fault *, long int, pfn_t, void *);

typedef void (*btf_trace_dax_pte_fault)(void *, struct inode *, struct vm_fault *, int);

typedef void (*btf_trace_dax_pte_fault_done)(void *, struct inode *, struct vm_fault *, int);

typedef void (*btf_trace_dax_load_hole)(void *, struct inode *, struct vm_fault *, int);

typedef void (*btf_trace_dax_insert_pfn_mkwrite_no_entry)(void *, struct inode *, struct vm_fault *, int);

typedef void (*btf_trace_dax_insert_pfn_mkwrite)(void *, struct inode *, struct vm_fault *, int);

typedef void (*btf_trace_dax_insert_mapping)(void *, struct inode *, struct vm_fault *, void *);

typedef void (*btf_trace_dax_writeback_range)(void *, struct inode *, long unsigned int, long unsigned int);

typedef void (*btf_trace_dax_writeback_range_done)(void *, struct inode *, long unsigned int, long unsigned int);

typedef void (*btf_trace_dax_writeback_one)(void *, struct inode *, long unsigned int, long unsigned int);

struct exceptional_entry_key {
	struct xarray *xa;
	long unsigned int entry_start;
};

struct wait_exceptional_entry_queue {
	wait_queue_entry_t wait;
	struct exceptional_entry_key key;
};

enum dax_wake_mode {
	WAKE_ALL = 0,
	WAKE_NEXT = 1,
};

struct crypto_skcipher;

struct fscrypt_blk_crypto_key;

struct fscrypt_prepared_key {
	struct crypto_skcipher *tfm;
	struct fscrypt_blk_crypto_key *blk_key;
};

struct fscrypt_mode;

struct fscrypt_direct_key;

struct fscrypt_info {
	struct fscrypt_prepared_key ci_enc_key;
	bool ci_owns_key;
	bool ci_inlinecrypt;
	struct fscrypt_mode *ci_mode;
	struct inode *ci_inode;
	struct key *ci_master_key;
	struct list_head ci_master_key_link;
	struct fscrypt_direct_key *ci_direct_key;
	siphash_key_t ci_dirhash_key;
	bool ci_dirhash_key_initialized;
	union fscrypt_policy ci_policy;
	u8 ci_nonce[16];
	u32 ci_hashed_ino;
};

struct skcipher_request {
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	struct crypto_async_request base;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_skcipher {
	unsigned int reqsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct fscrypt_mode {
	const char *friendly_name;
	const char *cipher_str;
	int keysize;
	int security_strength;
	int ivsize;
	int logged_impl_name;
	enum blk_crypto_mode_num blk_crypto_mode;
};

typedef enum {
	FS_DECRYPT = 0,
	FS_ENCRYPT = 1,
} fscrypt_direction_t;

union fscrypt_iv {
	struct {
		__le64 lblk_num;
		u8 nonce[16];
	};
	u8 raw[32];
	__le64 dun[4];
};

struct fscrypt_str {
	unsigned char *name;
	u32 len;
};

struct fscrypt_name {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	u32 hash;
	u32 minor_hash;
	struct fscrypt_str crypto_buf;
	bool is_nokey_name;
};

struct fscrypt_nokey_name {
	u32 dirhash[2];
	u8 bytes[149];
	u8 sha256[32];
};

struct shash_alg {
	int (*init)(struct shash_desc *);
	int (*update)(struct shash_desc *, const u8 *, unsigned int);
	int (*final)(struct shash_desc *, u8 *);
	int (*finup)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*digest)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*export)(struct shash_desc *, void *);
	int (*import)(struct shash_desc *, const void *);
	int (*setkey)(struct crypto_shash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_shash *);
	void (*exit_tfm)(struct crypto_shash *);
	unsigned int descsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int digestsize;
	unsigned int statesize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct fscrypt_hkdf {
	struct crypto_shash *hmac_tfm;
};

struct fscrypt_key_specifier {
	__u32 type;
	__u32 __reserved;
	union {
		__u8 __reserved[32];
		__u8 descriptor[8];
		__u8 identifier[16];
	} u;
};

struct fscrypt_symlink_data {
	__le16 len;
	char encrypted_path[1];
} __attribute__((packed));

struct fscrypt_master_key_secret {
	struct fscrypt_hkdf hkdf;
	u32 size;
	u8 raw[64];
};

struct fscrypt_master_key {
	struct fscrypt_master_key_secret mk_secret;
	struct fscrypt_key_specifier mk_spec;
	struct key *mk_users;
	refcount_t mk_refcount;
	struct list_head mk_decrypted_inodes;
	spinlock_t mk_decrypted_inodes_lock;
	struct fscrypt_prepared_key mk_direct_keys[10];
	struct fscrypt_prepared_key mk_iv_ino_lblk_64_keys[10];
	struct fscrypt_prepared_key mk_iv_ino_lblk_32_keys[10];
	siphash_key_t mk_ino_hash_key;
	bool mk_ino_hash_key_initialized;
};

enum key_need_perm {
	KEY_NEED_UNSPECIFIED = 0,
	KEY_NEED_VIEW = 1,
	KEY_NEED_READ = 2,
	KEY_NEED_WRITE = 3,
	KEY_NEED_SEARCH = 4,
	KEY_NEED_LINK = 5,
	KEY_NEED_SETATTR = 6,
	KEY_NEED_UNLINK = 7,
	KEY_SYSADMIN_OVERRIDE = 8,
	KEY_AUTHTOKEN_OVERRIDE = 9,
	KEY_DEFER_PERM_CHECK = 10,
};

enum key_state {
	KEY_IS_UNINSTANTIATED = 0,
	KEY_IS_POSITIVE = 1,
};

struct fscrypt_provisioning_key_payload {
	__u32 type;
	__u32 __reserved;
	__u8 raw[0];
};

struct fscrypt_add_key_arg {
	struct fscrypt_key_specifier key_spec;
	__u32 raw_size;
	__u32 key_id;
	__u32 __reserved[8];
	__u8 raw[0];
};

struct fscrypt_remove_key_arg {
	struct fscrypt_key_specifier key_spec;
	__u32 removal_status_flags;
	__u32 __reserved[5];
};

struct fscrypt_get_key_status_arg {
	struct fscrypt_key_specifier key_spec;
	__u32 __reserved[6];
	__u32 status;
	__u32 status_flags;
	__u32 user_count;
	__u32 __out_reserved[13];
};

struct skcipher_alg {
	int (*setkey)(struct crypto_skcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct skcipher_request *);
	int (*decrypt)(struct skcipher_request *);
	int (*init)(struct crypto_skcipher *);
	void (*exit)(struct crypto_skcipher *);
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
	unsigned int chunksize;
	unsigned int walksize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct fscrypt_context_v1 {
	u8 version;
	u8 contents_encryption_mode;
	u8 filenames_encryption_mode;
	u8 flags;
	u8 master_key_descriptor[8];
	u8 nonce[16];
};

struct fscrypt_context_v2 {
	u8 version;
	u8 contents_encryption_mode;
	u8 filenames_encryption_mode;
	u8 flags;
	u8 __reserved[4];
	u8 master_key_identifier[16];
	u8 nonce[16];
};

union fscrypt_context {
	u8 version;
	struct fscrypt_context_v1 v1;
	struct fscrypt_context_v2 v2;
};

struct crypto_template;

struct crypto_spawn;

struct crypto_instance {
	struct crypto_alg alg;
	struct crypto_template *tmpl;
	union {
		struct hlist_node list;
		struct crypto_spawn *spawns;
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_spawn {
	struct list_head list;
	struct crypto_alg *alg;
	union {
		struct crypto_instance *inst;
		struct crypto_spawn *next;
	};
	const struct crypto_type *frontend;
	u32 mask;
	bool dead;
	bool registered;
};

struct rtattr;

struct crypto_template {
	struct list_head list;
	struct hlist_head instances;
	struct module *module;
	int (*create)(struct crypto_template *, struct rtattr **);
	char name[128];
};

struct user_key_payload {
	struct callback_head rcu;
	short unsigned int datalen;
	long: 48;
	char data[0];
};

struct fscrypt_key {
	__u32 mode;
	__u8 raw[64];
	__u32 size;
};

struct fscrypt_direct_key {
	struct hlist_node dk_node;
	refcount_t dk_refcount;
	const struct fscrypt_mode *dk_mode;
	struct fscrypt_prepared_key dk_key;
	u8 dk_descriptor[8];
	u8 dk_raw[64];
};

struct fscrypt_get_policy_ex_arg {
	__u64 policy_size;
	union {
		__u8 version;
		struct fscrypt_policy_v1 v1;
		struct fscrypt_policy_v2 v2;
	} policy;
};

struct fscrypt_dummy_policy {
	const union fscrypt_policy *policy;
};

struct fscrypt_blk_crypto_key {
	struct blk_crypto_key base;
	int num_devs;
	struct request_queue *devs[0];
};

struct fsverity_hash_alg;

struct merkle_tree_params {
	struct fsverity_hash_alg *hash_alg;
	const u8 *hashstate;
	unsigned int digest_size;
	unsigned int block_size;
	unsigned int hashes_per_block;
	unsigned int log_blocksize;
	unsigned int log_arity;
	unsigned int num_levels;
	u64 tree_size;
	long unsigned int level0_blocks;
	u64 level_start[8];
};

struct fsverity_info {
	struct merkle_tree_params tree_params;
	u8 root_hash[64];
	u8 file_digest[64];
	const struct inode *inode;
};

struct fsverity_enable_arg {
	__u32 version;
	__u32 hash_algorithm;
	__u32 block_size;
	__u32 salt_size;
	__u64 salt_ptr;
	__u32 sig_size;
	__u32 __reserved1;
	__u64 sig_ptr;
	__u64 __reserved2[11];
};

struct fsverity_descriptor {
	__u8 version;
	__u8 hash_algorithm;
	__u8 log_blocksize;
	__u8 salt_size;
	__le32 sig_size;
	__le64 data_size;
	__u8 root_hash[64];
	__u8 salt[32];
	__u8 __reserved[144];
	__u8 signature[0];
};

struct crypto_ahash;

struct fsverity_hash_alg {
	struct crypto_ahash *tfm;
	const char *name;
	unsigned int digest_size;
	unsigned int block_size;
	mempool_t req_pool;
};

struct ahash_request;

struct crypto_ahash {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	unsigned int reqsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct ahash_request {
	struct crypto_async_request base;
	unsigned int nbytes;
	struct scatterlist *src;
	u8 *result;
	void *priv;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct hash_alg_common {
	unsigned int digestsize;
	unsigned int statesize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct fsverity_digest {
	__u16 digest_algorithm;
	__u16 digest_size;
	__u8 digest[0];
};

struct fsverity_read_metadata_arg {
	__u64 metadata_type;
	__u64 offset;
	__u64 length;
	__u64 buf_ptr;
	__u64 __reserved;
};

struct fsverity_formatted_digest {
	char magic[8];
	__le16 digest_algorithm;
	__le16 digest_size;
	__u8 digest[0];
};

struct flock64 {
	short int l_type;
	short int l_whence;
	__kernel_loff_t l_start;
	__kernel_loff_t l_len;
	__kernel_pid_t l_pid;
};

struct trace_event_raw_locks_get_lock_context {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	unsigned char type;
	struct file_lock_context *ctx;
	char __data[0];
};

struct trace_event_raw_filelock_lock {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_pid;
	unsigned int fl_flags;
	unsigned char fl_type;
	loff_t fl_start;
	loff_t fl_end;
	int ret;
	char __data[0];
};

struct trace_event_raw_filelock_lease {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	char __data[0];
};

struct trace_event_raw_generic_add_lease {
	struct trace_entry ent;
	long unsigned int i_ino;
	int wcount;
	int rcount;
	int icount;
	dev_t s_dev;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	char __data[0];
};

struct trace_event_raw_leases_conflict {
	struct trace_entry ent;
	void *lease;
	void *breaker;
	unsigned int l_fl_flags;
	unsigned int b_fl_flags;
	unsigned char l_fl_type;
	unsigned char b_fl_type;
	bool conflict;
	char __data[0];
};

struct trace_event_data_offsets_locks_get_lock_context {};

struct trace_event_data_offsets_filelock_lock {};

struct trace_event_data_offsets_filelock_lease {};

struct trace_event_data_offsets_generic_add_lease {};

struct trace_event_data_offsets_leases_conflict {};

typedef void (*btf_trace_locks_get_lock_context)(void *, struct inode *, int, struct file_lock_context *);

typedef void (*btf_trace_posix_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_fcntl_setlk)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_locks_remove_posix)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_flock_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_break_lease_noblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_block)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_unblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_delete_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_time_out_leases)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_add_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_leases_conflict)(void *, bool, struct file_lock *, struct file_lock *);

struct file_lock_list_struct {
	spinlock_t lock;
	struct hlist_head hlist;
};

struct locks_iterator {
	int li_cpu;
	loff_t li_pos;
};

typedef unsigned int __kernel_uid_t;

typedef unsigned int __kernel_gid_t;

struct gnu_property {
	u32 pr_type;
	u32 pr_datasz;
};

struct elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	long unsigned int pr_flag;
	__kernel_uid_t pr_uid;
	__kernel_gid_t pr_gid;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct core_vma_metadata {
	long unsigned int start;
	long unsigned int end;
	long unsigned int flags;
	long unsigned int dump_size;
};

struct memelfnote {
	const char *name;
	int type;
	unsigned int datasz;
	void *data;
};

struct elf_thread_core_info {
	struct elf_thread_core_info *next;
	struct task_struct *task;
	struct elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elf_note_info {
	struct elf_thread_core_info *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

typedef __u32 Elf32_Addr;

typedef __u16 Elf32_Half;

typedef __u32 Elf32_Off;

struct elf32_hdr {
	unsigned char e_ident[16];
	Elf32_Half e_type;
	Elf32_Half e_machine;
	Elf32_Word e_version;
	Elf32_Addr e_entry;
	Elf32_Off e_phoff;
	Elf32_Off e_shoff;
	Elf32_Word e_flags;
	Elf32_Half e_ehsize;
	Elf32_Half e_phentsize;
	Elf32_Half e_phnum;
	Elf32_Half e_shentsize;
	Elf32_Half e_shnum;
	Elf32_Half e_shstrndx;
};

struct elf32_phdr {
	Elf32_Word p_type;
	Elf32_Off p_offset;
	Elf32_Addr p_vaddr;
	Elf32_Addr p_paddr;
	Elf32_Word p_filesz;
	Elf32_Word p_memsz;
	Elf32_Word p_flags;
	Elf32_Word p_align;
};

struct elf32_shdr {
	Elf32_Word sh_name;
	Elf32_Word sh_type;
	Elf32_Word sh_flags;
	Elf32_Addr sh_addr;
	Elf32_Off sh_offset;
	Elf32_Word sh_size;
	Elf32_Word sh_link;
	Elf32_Word sh_info;
	Elf32_Word sh_addralign;
	Elf32_Word sh_entsize;
};

typedef u16 __compat_uid_t;

typedef u16 __compat_gid_t;

typedef unsigned int compat_elf_greg_t;

typedef compat_elf_greg_t compat_elf_gregset_t[18];

struct compat_elf_siginfo {
	compat_int_t si_signo;
	compat_int_t si_code;
	compat_int_t si_errno;
};

struct compat_elf_prstatus_common {
	struct compat_elf_siginfo pr_info;
	short int pr_cursig;
	compat_ulong_t pr_sigpend;
	compat_ulong_t pr_sighold;
	compat_pid_t pr_pid;
	compat_pid_t pr_ppid;
	compat_pid_t pr_pgrp;
	compat_pid_t pr_sid;
	struct old_timeval32 pr_utime;
	struct old_timeval32 pr_stime;
	struct old_timeval32 pr_cutime;
	struct old_timeval32 pr_cstime;
};

struct compat_elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	compat_ulong_t pr_flag;
	__compat_uid_t pr_uid;
	__compat_gid_t pr_gid;
	compat_pid_t pr_pid;
	compat_pid_t pr_ppid;
	compat_pid_t pr_pgrp;
	compat_pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct compat_elf_prstatus {
	struct compat_elf_prstatus_common common;
	compat_elf_gregset_t pr_reg;
	compat_int_t pr_fpvalid;
};

struct elf_thread_core_info___2 {
	struct elf_thread_core_info___2 *next;
	struct task_struct *task;
	struct compat_elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elf_note_info___2 {
	struct elf_thread_core_info___2 *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	compat_siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct mb_cache_entry {
	struct list_head e_list;
	struct hlist_bl_node e_hash_list;
	atomic_t e_refcnt;
	u32 e_key;
	u32 e_referenced: 1;
	u32 e_reusable: 1;
	u64 e_value;
};

struct mb_cache {
	struct hlist_bl_head *c_hash;
	int c_bucket_bits;
	long unsigned int c_max_entries;
	spinlock_t c_list_lock;
	struct list_head c_list;
	long unsigned int c_entry_count;
	struct shrinker c_shrink;
	struct work_struct c_shrink_work;
};

struct posix_acl_xattr_entry {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
};

struct posix_acl_xattr_header {
	__le32 a_version;
};

struct nfs_seqid_counter {
	ktime_t create_time;
	int owner_id;
	int flags;
	u32 counter;
	spinlock_t lock;
	struct list_head list;
	struct rpc_wait_queue wait;
};

struct nfs4_lock_state {
	struct list_head ls_locks;
	struct nfs4_state *ls_state;
	long unsigned int ls_flags;
	struct nfs_seqid_counter ls_seqid;
	nfs4_stateid ls_stateid;
	refcount_t ls_count;
	fl_owner_t ls_owner;
};

struct nfs_seqid {
	struct nfs_seqid_counter *sequence;
	struct list_head list;
	struct rpc_task *task;
};

struct nfs4_pathname {
	unsigned int ncomponents;
	struct nfs4_string components[512];
};

struct nfs4_fs_location {
	unsigned int nservers;
	struct nfs4_string servers[10];
	struct nfs4_pathname rootpath;
};

struct nfs4_fs_locations {
	struct nfs_fattr fattr;
	const struct nfs_server *server;
	struct nfs4_pathname fs_path;
	int nlocations;
	struct nfs4_fs_location locations[10];
};

struct nfs4_state_owner;

struct nfs4_state {
	struct list_head open_states;
	struct list_head inode_states;
	struct list_head lock_states;
	struct nfs4_state_owner *owner;
	struct inode *inode;
	long unsigned int flags;
	spinlock_t state_lock;
	seqlock_t seqlock;
	nfs4_stateid stateid;
	nfs4_stateid open_stateid;
	unsigned int n_rdonly;
	unsigned int n_wronly;
	unsigned int n_rdwr;
	fmode_t state;
	refcount_t count;
	wait_queue_head_t waitq;
	struct callback_head callback_head;
};

struct nfs4_ssc_client_ops;

struct nfs_ssc_client_ops;

struct nfs_ssc_client_ops_tbl {
	const struct nfs4_ssc_client_ops *ssc_nfs4_ops;
	const struct nfs_ssc_client_ops *ssc_nfs_ops;
};

struct nfs4_ssc_client_ops {
	struct file * (*sco_open)(struct vfsmount *, struct nfs_fh *, nfs4_stateid *);
	void (*sco_close)(struct file *);
};

struct nfs_ssc_client_ops {
	void (*sco_sb_deactive)(struct super_block *);
};

struct nfs4_state_recovery_ops {
	int owner_flag_bit;
	int state_flag_bit;
	int (*recover_open)(struct nfs4_state_owner *, struct nfs4_state *);
	int (*recover_lock)(struct nfs4_state *, struct file_lock *);
	int (*establish_clid)(struct nfs_client *, const struct cred *);
	int (*reclaim_complete)(struct nfs_client *, const struct cred *);
	int (*detect_trunking)(struct nfs_client *, struct nfs_client **, const struct cred *);
};

struct nfs4_state_maintenance_ops {
	int (*sched_state_renewal)(struct nfs_client *, const struct cred *, unsigned int);
	const struct cred * (*get_state_renewal_cred)(struct nfs_client *);
	int (*renew_lease)(struct nfs_client *, const struct cred *);
};

struct nfs4_mig_recovery_ops {
	int (*get_locations)(struct inode *, struct nfs4_fs_locations *, struct page *, const struct cred *);
	int (*fsid_present)(struct inode *, const struct cred *);
};

struct nfs4_state_owner {
	struct nfs_server *so_server;
	struct list_head so_lru;
	long unsigned int so_expires;
	struct rb_node so_server_node;
	const struct cred *so_cred;
	spinlock_t so_lock;
	atomic_t so_count;
	long unsigned int so_flags;
	struct list_head so_states;
	struct nfs_seqid_counter so_seqid;
	seqcount_spinlock_t so_reclaim_seqcount;
	struct mutex so_delegreturn_mutex;
};

struct svc_version;

struct core_name {
	char *corename;
	int used;
	int size;
};

struct trace_event_raw_iomap_readpage_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	int nr_pages;
	char __data[0];
};

struct trace_event_raw_iomap_range_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t size;
	long unsigned int offset;
	unsigned int length;
	char __data[0];
};

struct trace_event_raw_iomap_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	dev_t bdev;
	char __data[0];
};

struct trace_event_raw_iomap_apply {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t pos;
	loff_t length;
	unsigned int flags;
	const void *ops;
	void *actor;
	long unsigned int caller;
	char __data[0];
};

struct trace_event_data_offsets_iomap_readpage_class {};

struct trace_event_data_offsets_iomap_range_class {};

struct trace_event_data_offsets_iomap_class {};

struct trace_event_data_offsets_iomap_apply {};

typedef void (*btf_trace_iomap_readpage)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_readahead)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_writepage)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_releasepage)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_invalidatepage)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_dio_invalidate_fail)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_apply_dstmap)(void *, struct inode *, struct iomap___2 *);

typedef void (*btf_trace_iomap_apply_srcmap)(void *, struct inode *, struct iomap___2 *);

typedef void (*btf_trace_iomap_apply)(void *, struct inode *, loff_t, loff_t, unsigned int, const void *, void *, long unsigned int);

typedef loff_t (*iomap_actor_t)(struct inode *, loff_t, loff_t, void *, struct iomap___2 *, struct iomap___2 *);

struct iomap_ioend {
	struct list_head io_list;
	u16 io_type;
	u16 io_flags;
	struct inode *io_inode;
	size_t io_size;
	loff_t io_offset;
	struct bio *io_bio;
	struct bio io_inline_bio;
};

struct iomap_writepage_ctx;

struct iomap_writeback_ops {
	int (*map_blocks)(struct iomap_writepage_ctx *, struct inode *, loff_t);
	int (*prepare_ioend)(struct iomap_ioend *, int);
	void (*discard_page)(struct page *, loff_t);
};

struct iomap_writepage_ctx {
	struct iomap___2 iomap;
	struct iomap_ioend *ioend;
	const struct iomap_writeback_ops *ops;
};

struct iomap_page {
	atomic_t read_bytes_pending;
	atomic_t write_bytes_pending;
	spinlock_t uptodate_lock;
	long unsigned int uptodate[0];
};

struct iomap_readpage_ctx {
	struct page *cur_page;
	bool cur_page_in_bio;
	struct bio *bio;
	struct readahead_control *rac;
};

enum {
	IOMAP_WRITE_F_UNSHARE = 1,
};

struct iomap_dio_ops {
	int (*end_io)(struct kiocb *, ssize_t, int, unsigned int);
	blk_qc_t (*submit_io)(struct inode *, struct iomap___2 *, struct bio *, loff_t);
};

struct iomap_dio {
	struct kiocb *iocb;
	const struct iomap_dio_ops *dops;
	loff_t i_size;
	loff_t size;
	atomic_t ref;
	unsigned int flags;
	int error;
	bool wait_for_completion;
	union {
		struct {
			struct iov_iter *iter;
			struct task_struct *waiter;
			struct request_queue *last_queue;
			blk_qc_t cookie;
		} submit;
		struct {
			struct work_struct work;
		} aio;
	};
};

struct fiemap_ctx {
	struct fiemap_extent_info *fi;
	struct iomap___2 prev;
};

struct iomap_swapfile_info {
	struct iomap___2 iomap;
	struct swap_info_struct *sis;
	uint64_t lowest_ppage;
	uint64_t highest_ppage;
	long unsigned int nr_pages;
	int nr_extents;
	struct file *file;
};

enum {
	QIF_BLIMITS_B = 0,
	QIF_SPACE_B = 1,
	QIF_ILIMITS_B = 2,
	QIF_INODES_B = 3,
	QIF_BTIME_B = 4,
	QIF_ITIME_B = 5,
};

typedef __kernel_uid32_t qid_t;

enum {
	DQF_INFO_DIRTY_B = 17,
};

enum {
	_DQUOT_USAGE_ENABLED = 0,
	_DQUOT_LIMITS_ENABLED = 1,
	_DQUOT_SUSPENDED = 2,
	_DQUOT_STATE_FLAGS = 3,
};

struct quota_module_name {
	int qm_fmt_id;
	char *qm_mod_name;
};

struct dquot_warn {
	struct super_block *w_sb;
	struct kqid w_dq_id;
	short int w_type;
};

struct fs_disk_quota {
	__s8 d_version;
	__s8 d_flags;
	__u16 d_fieldmask;
	__u32 d_id;
	__u64 d_blk_hardlimit;
	__u64 d_blk_softlimit;
	__u64 d_ino_hardlimit;
	__u64 d_ino_softlimit;
	__u64 d_bcount;
	__u64 d_icount;
	__s32 d_itimer;
	__s32 d_btimer;
	__u16 d_iwarns;
	__u16 d_bwarns;
	__s8 d_itimer_hi;
	__s8 d_btimer_hi;
	__s8 d_rtbtimer_hi;
	__s8 d_padding2;
	__u64 d_rtb_hardlimit;
	__u64 d_rtb_softlimit;
	__u64 d_rtbcount;
	__s32 d_rtbtimer;
	__u16 d_rtbwarns;
	__s16 d_padding3;
	char d_padding4[8];
};

struct fs_qfilestat {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
};

typedef struct fs_qfilestat fs_qfilestat_t;

struct fs_quota_stat {
	__s8 qs_version;
	__u16 qs_flags;
	__s8 qs_pad;
	fs_qfilestat_t qs_uquota;
	fs_qfilestat_t qs_gquota;
	__u32 qs_incoredqs;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
};

struct fs_qfilestatv {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
	__u32 qfs_pad;
};

struct fs_quota_statv {
	__s8 qs_version;
	__u8 qs_pad1;
	__u16 qs_flags;
	__u32 qs_incoredqs;
	struct fs_qfilestatv qs_uquota;
	struct fs_qfilestatv qs_gquota;
	struct fs_qfilestatv qs_pquota;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
	__u16 qs_rtbwarnlimit;
	__u16 qs_pad3;
	__u32 qs_pad4;
	__u64 qs_pad2[7];
};

struct if_dqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
};

struct if_nextdqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
	__u32 dqb_id;
};

struct if_dqinfo {
	__u64 dqi_bgrace;
	__u64 dqi_igrace;
	__u32 dqi_flags;
	__u32 dqi_valid;
};

struct compat_if_dqblk {
	compat_u64 dqb_bhardlimit;
	compat_u64 dqb_bsoftlimit;
	compat_u64 dqb_curspace;
	compat_u64 dqb_ihardlimit;
	compat_u64 dqb_isoftlimit;
	compat_u64 dqb_curinodes;
	compat_u64 dqb_btime;
	compat_u64 dqb_itime;
	compat_uint_t dqb_valid;
};

enum {
	QUOTA_NL_C_UNSPEC = 0,
	QUOTA_NL_C_WARNING = 1,
	__QUOTA_NL_C_MAX = 2,
};

enum {
	QUOTA_NL_A_UNSPEC = 0,
	QUOTA_NL_A_QTYPE = 1,
	QUOTA_NL_A_EXCESS_ID = 2,
	QUOTA_NL_A_WARNING = 3,
	QUOTA_NL_A_DEV_MAJOR = 4,
	QUOTA_NL_A_DEV_MINOR = 5,
	QUOTA_NL_A_CAUSED_ID = 6,
	QUOTA_NL_A_PAD = 7,
	__QUOTA_NL_A_MAX = 8,
};

struct proc_maps_private {
	struct inode *inode;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *tail_vma;
	struct mempolicy *task_mempolicy;
};

struct mem_size_stats {
	long unsigned int resident;
	long unsigned int shared_clean;
	long unsigned int shared_dirty;
	long unsigned int private_clean;
	long unsigned int private_dirty;
	long unsigned int referenced;
	long unsigned int anonymous;
	long unsigned int lazyfree;
	long unsigned int anonymous_thp;
	long unsigned int shmem_thp;
	long unsigned int file_thp;
	long unsigned int swap;
	long unsigned int shared_hugetlb;
	long unsigned int private_hugetlb;
	u64 pss;
	u64 pss_anon;
	u64 pss_file;
	u64 pss_shmem;
	u64 pss_locked;
	u64 swap_pss;
	bool check_shmem_swap;
};

enum clear_refs_types {
	CLEAR_REFS_ALL = 1,
	CLEAR_REFS_ANON = 2,
	CLEAR_REFS_MAPPED = 3,
	CLEAR_REFS_SOFT_DIRTY = 4,
	CLEAR_REFS_MM_HIWATER_RSS = 5,
	CLEAR_REFS_LAST = 6,
};

struct clear_refs_private {
	enum clear_refs_types type;
};

typedef struct {
	u64 pme;
} pagemap_entry_t;

struct pagemapread {
	int pos;
	int len;
	pagemap_entry_t *buffer;
	bool show_pfn;
};

struct numa_maps {
	long unsigned int pages;
	long unsigned int anon;
	long unsigned int active;
	long unsigned int writeback;
	long unsigned int mapcount_max;
	long unsigned int dirty;
	long unsigned int swapcache;
	long unsigned int node[64];
};

struct numa_maps_private {
	struct proc_maps_private proc_maps;
	struct numa_maps md;
};

struct pde_opener {
	struct list_head lh;
	struct file *file;
	bool closing;
	struct completion *c;
};

enum {
	BIAS = 2147483648,
};

struct proc_fs_context {
	struct pid_namespace *pid_ns;
	unsigned int mask;
	enum proc_hidepid hidepid;
	int gid;
	enum proc_pidonly pidonly;
};

enum proc_param {
	Opt_gid___2 = 0,
	Opt_hidepid = 1,
	Opt_subset = 2,
};

struct genradix_root;

struct __genradix {
	struct genradix_root *root;
};

struct syscall_info {
	__u64 sp;
	struct seccomp_data data;
};

typedef struct dentry *instantiate_t(struct dentry *, struct task_struct *, const void *);

struct pid_entry {
	const char *name;
	unsigned int len;
	umode_t mode;
	const struct inode_operations *iop;
	const struct file_operations *fop;
	union proc_op op;
};

struct limit_names {
	const char *name;
	const char *unit;
};

struct map_files_info {
	long unsigned int start;
	long unsigned int end;
	fmode_t mode;
};

struct timers_private {
	struct pid *pid;
	struct task_struct *task;
	struct sighand_struct *sighand;
	struct pid_namespace *ns;
	long unsigned int flags;
};

struct tgid_iter {
	unsigned int tgid;
	struct task_struct *task;
};

struct fd_data {
	fmode_t mode;
	unsigned int fd;
};

struct sysctl_alias {
	const char *kernel_param;
	const char *sysctl_param;
};

struct seq_net_private {
	struct net *net;
};

struct bpf_iter_aux_info___2;

enum kcore_type {
	KCORE_TEXT = 0,
	KCORE_VMALLOC = 1,
	KCORE_RAM = 2,
	KCORE_VMEMMAP = 3,
	KCORE_USER = 4,
	KCORE_OTHER = 5,
	KCORE_REMAP = 6,
};

struct kcore_list {
	struct list_head list;
	long unsigned int addr;
	long unsigned int vaddr;
	size_t size;
	int type;
};

struct vmcore {
	struct list_head list;
	long long unsigned int paddr;
	long long unsigned int size;
	loff_t offset;
};

struct vmcoredd_node {
	struct list_head list;
	void *buf;
	unsigned int size;
};

typedef struct elf32_hdr Elf32_Ehdr;

typedef struct elf32_phdr Elf32_Phdr;

typedef struct elf32_note Elf32_Nhdr;

typedef struct elf64_note Elf64_Nhdr;

struct vmcoredd_header {
	__u32 n_namesz;
	__u32 n_descsz;
	__u32 n_type;
	__u8 name[8];
	__u8 dump_name[44];
};

struct vmcoredd_data {
	char dump_name[44];
	unsigned int size;
	int (*vmcoredd_callback)(struct vmcoredd_data *, void *);
};

struct kernfs_iattrs {
	kuid_t ia_uid;
	kgid_t ia_gid;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct simple_xattrs xattrs;
	atomic_t nr_user_xattrs;
	atomic_t user_xattr_size;
};

struct kernfs_super_info {
	struct super_block *sb;
	struct kernfs_root *root;
	const void *ns;
	struct list_head node;
};

enum kernfs_node_flag {
	KERNFS_ACTIVATED = 16,
	KERNFS_NS = 32,
	KERNFS_HAS_SEQ_SHOW = 64,
	KERNFS_HAS_MMAP = 128,
	KERNFS_LOCKDEP = 256,
	KERNFS_SUICIDAL = 1024,
	KERNFS_SUICIDED = 2048,
	KERNFS_EMPTY_DIR = 4096,
	KERNFS_HAS_RELEASE = 8192,
};

struct kernfs_open_node {
	atomic_t refcnt;
	atomic_t event;
	wait_queue_head_t poll;
	struct list_head files;
};

struct config_group;

struct config_item_type;

struct config_item {
	char *ci_name;
	char ci_namebuf[20];
	struct kref ci_kref;
	struct list_head ci_entry;
	struct config_item *ci_parent;
	struct config_group *ci_group;
	const struct config_item_type *ci_type;
	struct dentry *ci_dentry;
};

struct configfs_subsystem;

struct config_group {
	struct config_item cg_item;
	struct list_head cg_children;
	struct configfs_subsystem *cg_subsys;
	struct list_head default_groups;
	struct list_head group_entry;
};

struct configfs_item_operations;

struct configfs_group_operations;

struct configfs_attribute;

struct configfs_bin_attribute;

struct config_item_type {
	struct module *ct_owner;
	struct configfs_item_operations *ct_item_ops;
	struct configfs_group_operations *ct_group_ops;
	struct configfs_attribute **ct_attrs;
	struct configfs_bin_attribute **ct_bin_attrs;
};

struct configfs_item_operations {
	void (*release)(struct config_item *);
	int (*allow_link)(struct config_item *, struct config_item *);
	void (*drop_link)(struct config_item *, struct config_item *);
};

struct configfs_group_operations {
	struct config_item * (*make_item)(struct config_group *, const char *);
	struct config_group * (*make_group)(struct config_group *, const char *);
	int (*commit_item)(struct config_item *);
	void (*disconnect_notify)(struct config_group *, struct config_item *);
	void (*drop_item)(struct config_group *, struct config_item *);
};

struct configfs_attribute {
	const char *ca_name;
	struct module *ca_owner;
	umode_t ca_mode;
	ssize_t (*show)(struct config_item *, char *);
	ssize_t (*store)(struct config_item *, const char *, size_t);
};

struct configfs_bin_attribute {
	struct configfs_attribute cb_attr;
	void *cb_private;
	size_t cb_max_size;
	ssize_t (*read)(struct config_item *, void *, size_t);
	ssize_t (*write)(struct config_item *, const void *, size_t);
};

struct configfs_subsystem {
	struct config_group su_group;
	struct mutex su_mutex;
};

struct configfs_fragment {
	atomic_t frag_count;
	struct rw_semaphore frag_sem;
	bool frag_dead;
};

struct configfs_dirent {
	atomic_t s_count;
	int s_dependent_count;
	struct list_head s_sibling;
	struct list_head s_children;
	int s_links;
	void *s_element;
	int s_type;
	umode_t s_mode;
	struct dentry *s_dentry;
	struct iattr *s_iattr;
	struct configfs_fragment *s_frag;
};

struct configfs_buffer {
	size_t count;
	loff_t pos;
	char *page;
	struct configfs_item_operations *ops;
	struct mutex mutex;
	int needs_read_fill;
	bool read_in_progress;
	bool write_in_progress;
	char *bin_buffer;
	int bin_buffer_size;
	int cb_max_size;
	struct config_item *item;
	struct module *owner;
	union {
		struct configfs_attribute *attr;
		struct configfs_bin_attribute *bin_attr;
	};
};

struct pts_mount_opts {
	int setuid;
	int setgid;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	umode_t ptmxmode;
	int reserve;
	int max;
};

enum {
	Opt_uid___2 = 0,
	Opt_gid___3 = 1,
	Opt_mode___2 = 2,
	Opt_ptmxmode = 3,
	Opt_newinstance = 4,
	Opt_max = 5,
	Opt_err = 6,
};

struct pts_fs_info {
	struct ida allocated_ptys;
	struct pts_mount_opts mount_opts;
	struct super_block *sb;
	struct dentry *ptmx_dentry;
};

typedef unsigned int tid_t;

struct transaction_chp_stats_s {
	long unsigned int cs_chp_time;
	__u32 cs_forced_to_close;
	__u32 cs_written;
	__u32 cs_dropped;
};

struct journal_s;

typedef struct journal_s journal_t;

struct journal_head;

struct transaction_s;

typedef struct transaction_s transaction_t;

struct transaction_s {
	journal_t *t_journal;
	tid_t t_tid;
	enum {
		T_RUNNING = 0,
		T_LOCKED = 1,
		T_SWITCH = 2,
		T_FLUSH = 3,
		T_COMMIT = 4,
		T_COMMIT_DFLUSH = 5,
		T_COMMIT_JFLUSH = 6,
		T_COMMIT_CALLBACK = 7,
		T_FINISHED = 8,
	} t_state;
	long unsigned int t_log_start;
	int t_nr_buffers;
	struct journal_head *t_reserved_list;
	struct journal_head *t_buffers;
	struct journal_head *t_forget;
	struct journal_head *t_checkpoint_list;
	struct journal_head *t_checkpoint_io_list;
	struct journal_head *t_shadow_list;
	struct list_head t_inode_list;
	spinlock_t t_handle_lock;
	long unsigned int t_max_wait;
	long unsigned int t_start;
	long unsigned int t_requested;
	struct transaction_chp_stats_s t_chp_stats;
	atomic_t t_updates;
	atomic_t t_outstanding_credits;
	atomic_t t_outstanding_revokes;
	atomic_t t_handle_count;
	transaction_t *t_cpnext;
	transaction_t *t_cpprev;
	long unsigned int t_expires;
	ktime_t t_start_time;
	unsigned int t_synchronous_commit: 1;
	int t_need_data_flush;
	struct list_head t_private_list;
};

struct jbd2_buffer_trigger_type;

struct journal_head {
	struct buffer_head *b_bh;
	spinlock_t b_state_lock;
	int b_jcount;
	unsigned int b_jlist;
	unsigned int b_modified;
	char *b_frozen_data;
	char *b_committed_data;
	transaction_t *b_transaction;
	transaction_t *b_next_transaction;
	struct journal_head *b_tnext;
	struct journal_head *b_tprev;
	transaction_t *b_cp_transaction;
	struct journal_head *b_cpnext;
	struct journal_head *b_cpprev;
	struct jbd2_buffer_trigger_type *b_triggers;
	struct jbd2_buffer_trigger_type *b_frozen_triggers;
};

struct jbd2_buffer_trigger_type {
	void (*t_frozen)(struct jbd2_buffer_trigger_type *, struct buffer_head *, void *, size_t);
	void (*t_abort)(struct jbd2_buffer_trigger_type *, struct buffer_head *);
};

struct jbd2_journal_handle;

typedef struct jbd2_journal_handle handle_t;

struct jbd2_journal_handle {
	union {
		transaction_t *h_transaction;
		journal_t *h_journal;
	};
	handle_t *h_rsv_handle;
	int h_total_credits;
	int h_revoke_credits;
	int h_revoke_credits_requested;
	int h_ref;
	int h_err;
	unsigned int h_sync: 1;
	unsigned int h_jdata: 1;
	unsigned int h_reserved: 1;
	unsigned int h_aborted: 1;
	unsigned int h_type: 8;
	unsigned int h_line_no: 16;
	long unsigned int h_start_jiffies;
	unsigned int h_requested_credits;
	unsigned int saved_alloc_context;
};

struct transaction_run_stats_s {
	long unsigned int rs_wait;
	long unsigned int rs_request_delay;
	long unsigned int rs_running;
	long unsigned int rs_locked;
	long unsigned int rs_flushing;
	long unsigned int rs_logging;
	__u32 rs_handle_count;
	__u32 rs_blocks;
	__u32 rs_blocks_logged;
};

struct transaction_stats_s {
	long unsigned int ts_tid;
	long unsigned int ts_requested;
	struct transaction_run_stats_s run;
};

enum passtype {
	PASS_SCAN = 0,
	PASS_REVOKE = 1,
	PASS_REPLAY = 2,
};

struct journal_superblock_s;

typedef struct journal_superblock_s journal_superblock_t;

struct jbd2_revoke_table_s;

struct jbd2_inode;

struct journal_s {
	long unsigned int j_flags;
	int j_errno;
	struct mutex j_abort_mutex;
	struct buffer_head *j_sb_buffer;
	journal_superblock_t *j_superblock;
	int j_format_version;
	rwlock_t j_state_lock;
	int j_barrier_count;
	struct mutex j_barrier;
	transaction_t *j_running_transaction;
	transaction_t *j_committing_transaction;
	transaction_t *j_checkpoint_transactions;
	wait_queue_head_t j_wait_transaction_locked;
	wait_queue_head_t j_wait_done_commit;
	wait_queue_head_t j_wait_commit;
	wait_queue_head_t j_wait_updates;
	wait_queue_head_t j_wait_reserved;
	wait_queue_head_t j_fc_wait;
	struct mutex j_checkpoint_mutex;
	struct buffer_head *j_chkpt_bhs[64];
	long unsigned int j_head;
	long unsigned int j_tail;
	long unsigned int j_free;
	long unsigned int j_first;
	long unsigned int j_last;
	long unsigned int j_fc_first;
	long unsigned int j_fc_off;
	long unsigned int j_fc_last;
	struct block_device *j_dev;
	int j_blocksize;
	long long unsigned int j_blk_offset;
	char j_devname[56];
	struct block_device *j_fs_dev;
	unsigned int j_total_len;
	atomic_t j_reserved_credits;
	spinlock_t j_list_lock;
	struct inode *j_inode;
	tid_t j_tail_sequence;
	tid_t j_transaction_sequence;
	tid_t j_commit_sequence;
	tid_t j_commit_request;
	__u8 j_uuid[16];
	struct task_struct *j_task;
	int j_max_transaction_buffers;
	int j_revoke_records_per_block;
	long unsigned int j_commit_interval;
	struct timer_list j_commit_timer;
	spinlock_t j_revoke_lock;
	struct jbd2_revoke_table_s *j_revoke;
	struct jbd2_revoke_table_s *j_revoke_table[2];
	struct buffer_head **j_wbuf;
	struct buffer_head **j_fc_wbuf;
	int j_wbufsize;
	int j_fc_wbufsize;
	pid_t j_last_sync_writer;
	u64 j_average_commit_time;
	u32 j_min_batch_time;
	u32 j_max_batch_time;
	void (*j_commit_callback)(journal_t *, transaction_t *);
	int (*j_submit_inode_data_buffers)(struct jbd2_inode *);
	int (*j_finish_inode_data_buffers)(struct jbd2_inode *);
	spinlock_t j_history_lock;
	struct proc_dir_entry *j_proc_entry;
	struct transaction_stats_s j_stats;
	unsigned int j_failed_commit;
	void *j_private;
	struct crypto_shash *j_chksum_driver;
	__u32 j_csum_seed;
	void (*j_fc_cleanup_callback)(struct journal_s *, int);
	int (*j_fc_replay_callback)(struct journal_s *, struct buffer_head *, enum passtype, int, tid_t);
};

struct journal_header_s {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
};

typedef struct journal_header_s journal_header_t;

struct journal_superblock_s {
	journal_header_t s_header;
	__be32 s_blocksize;
	__be32 s_maxlen;
	__be32 s_first;
	__be32 s_sequence;
	__be32 s_start;
	__be32 s_errno;
	__be32 s_feature_compat;
	__be32 s_feature_incompat;
	__be32 s_feature_ro_compat;
	__u8 s_uuid[16];
	__be32 s_nr_users;
	__be32 s_dynsuper;
	__be32 s_max_transaction;
	__be32 s_max_trans_data;
	__u8 s_checksum_type;
	__u8 s_padding2[3];
	__be32 s_num_fc_blks;
	__u32 s_padding[41];
	__be32 s_checksum;
	__u8 s_users[768];
};

enum jbd_state_bits {
	BH_JBD = 16,
	BH_JWrite = 17,
	BH_Freed = 18,
	BH_Revoked = 19,
	BH_RevokeValid = 20,
	BH_JBDDirty = 21,
	BH_JournalHead = 22,
	BH_Shadow = 23,
	BH_Verified = 24,
	BH_JBDPrivateStart = 25,
};

struct jbd2_inode {
	transaction_t *i_transaction;
	transaction_t *i_next_transaction;
	struct list_head i_list;
	struct inode *i_vfs_inode;
	long unsigned int i_flags;
	loff_t i_dirty_start;
	loff_t i_dirty_end;
};

struct bgl_lock {
	spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blockgroup_lock {
	struct bgl_lock locks[128];
};

typedef int ext4_grpblk_t;

typedef long long unsigned int ext4_fsblk_t;

typedef __u32 ext4_lblk_t;

typedef unsigned int ext4_group_t;

struct ext4_allocation_request {
	struct inode *inode;
	unsigned int len;
	ext4_lblk_t logical;
	ext4_lblk_t lleft;
	ext4_lblk_t lright;
	ext4_fsblk_t goal;
	ext4_fsblk_t pleft;
	ext4_fsblk_t pright;
	unsigned int flags;
};

struct ext4_system_blocks {
	struct rb_root root;
	struct callback_head rcu;
};

struct ext4_group_desc {
	__le32 bg_block_bitmap_lo;
	__le32 bg_inode_bitmap_lo;
	__le32 bg_inode_table_lo;
	__le16 bg_free_blocks_count_lo;
	__le16 bg_free_inodes_count_lo;
	__le16 bg_used_dirs_count_lo;
	__le16 bg_flags;
	__le32 bg_exclude_bitmap_lo;
	__le16 bg_block_bitmap_csum_lo;
	__le16 bg_inode_bitmap_csum_lo;
	__le16 bg_itable_unused_lo;
	__le16 bg_checksum;
	__le32 bg_block_bitmap_hi;
	__le32 bg_inode_bitmap_hi;
	__le32 bg_inode_table_hi;
	__le16 bg_free_blocks_count_hi;
	__le16 bg_free_inodes_count_hi;
	__le16 bg_used_dirs_count_hi;
	__le16 bg_itable_unused_hi;
	__le32 bg_exclude_bitmap_hi;
	__le16 bg_block_bitmap_csum_hi;
	__le16 bg_inode_bitmap_csum_hi;
	__u32 bg_reserved;
};

struct flex_groups {
	atomic64_t free_clusters;
	atomic_t free_inodes;
	atomic_t used_dirs;
};

struct extent_status {
	struct rb_node rb_node;
	ext4_lblk_t es_lblk;
	ext4_lblk_t es_len;
	ext4_fsblk_t es_pblk;
};

struct ext4_es_tree {
	struct rb_root root;
	struct extent_status *cache_es;
};

struct ext4_es_stats {
	long unsigned int es_stats_shrunk;
	struct percpu_counter es_stats_cache_hits;
	struct percpu_counter es_stats_cache_misses;
	u64 es_stats_scan_time;
	u64 es_stats_max_scan_time;
	struct percpu_counter es_stats_all_cnt;
	struct percpu_counter es_stats_shk_cnt;
};

struct ext4_pending_tree {
	struct rb_root root;
};

struct ext4_fc_stats {
	unsigned int fc_ineligible_reason_count[10];
	long unsigned int fc_num_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_numblks;
};

struct ext4_fc_alloc_region {
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	int ino;
	int len;
};

struct ext4_fc_replay_state {
	int fc_replay_num_tags;
	int fc_replay_expected_off;
	int fc_current_pass;
	int fc_cur_tag;
	int fc_crc;
	struct ext4_fc_alloc_region *fc_regions;
	int fc_regions_size;
	int fc_regions_used;
	int fc_regions_valid;
	int *fc_modified_inodes;
	int fc_modified_inodes_used;
	int fc_modified_inodes_size;
};

struct ext4_inode_info {
	__le32 i_data[15];
	__u32 i_dtime;
	ext4_fsblk_t i_file_acl;
	ext4_group_t i_block_group;
	ext4_lblk_t i_dir_start_lookup;
	long unsigned int i_flags;
	struct rw_semaphore xattr_sem;
	struct list_head i_orphan;
	struct list_head i_fc_list;
	ext4_lblk_t i_fc_lblk_start;
	ext4_lblk_t i_fc_lblk_len;
	atomic_t i_fc_updates;
	wait_queue_head_t i_fc_wait;
	struct mutex i_fc_lock;
	loff_t i_disksize;
	struct rw_semaphore i_data_sem;
	struct rw_semaphore i_mmap_sem;
	struct inode vfs_inode;
	struct jbd2_inode *jinode;
	spinlock_t i_raw_lock;
	struct timespec64 i_crtime;
	atomic_t i_prealloc_active;
	struct list_head i_prealloc_list;
	spinlock_t i_prealloc_lock;
	struct ext4_es_tree i_es_tree;
	rwlock_t i_es_lock;
	struct list_head i_es_list;
	unsigned int i_es_all_nr;
	unsigned int i_es_shk_nr;
	ext4_lblk_t i_es_shrink_lblk;
	ext4_group_t i_last_alloc_group;
	unsigned int i_reserved_data_blocks;
	struct ext4_pending_tree i_pending_tree;
	__u16 i_extra_isize;
	u16 i_inline_off;
	u16 i_inline_size;
	qsize_t i_reserved_quota;
	spinlock_t i_completed_io_lock;
	struct list_head i_rsv_conversion_list;
	struct work_struct i_rsv_conversion_work;
	atomic_t i_unwritten;
	spinlock_t i_block_reservation_lock;
	tid_t i_sync_tid;
	tid_t i_datasync_tid;
	struct dquot *i_dquot[3];
	__u32 i_csum_seed;
	kprojid_t i_projid;
};

struct ext4_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count_lo;
	__le32 s_r_blocks_count_lo;
	__le32 s_free_blocks_count_lo;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_cluster_size;
	__le32 s_blocks_per_group;
	__le32 s_clusters_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__le16 s_reserved_gdt_blocks;
	__u8 s_journal_uuid[16];
	__le32 s_journal_inum;
	__le32 s_journal_dev;
	__le32 s_last_orphan;
	__le32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_jnl_backup_type;
	__le16 s_desc_size;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__le32 s_mkfs_time;
	__le32 s_jnl_blocks[17];
	__le32 s_blocks_count_hi;
	__le32 s_r_blocks_count_hi;
	__le32 s_free_blocks_count_hi;
	__le16 s_min_extra_isize;
	__le16 s_want_extra_isize;
	__le32 s_flags;
	__le16 s_raid_stride;
	__le16 s_mmp_update_interval;
	__le64 s_mmp_block;
	__le32 s_raid_stripe_width;
	__u8 s_log_groups_per_flex;
	__u8 s_checksum_type;
	__u8 s_encryption_level;
	__u8 s_reserved_pad;
	__le64 s_kbytes_written;
	__le32 s_snapshot_inum;
	__le32 s_snapshot_id;
	__le64 s_snapshot_r_blocks_count;
	__le32 s_snapshot_list;
	__le32 s_error_count;
	__le32 s_first_error_time;
	__le32 s_first_error_ino;
	__le64 s_first_error_block;
	__u8 s_first_error_func[32];
	__le32 s_first_error_line;
	__le32 s_last_error_time;
	__le32 s_last_error_ino;
	__le32 s_last_error_line;
	__le64 s_last_error_block;
	__u8 s_last_error_func[32];
	__u8 s_mount_opts[64];
	__le32 s_usr_quota_inum;
	__le32 s_grp_quota_inum;
	__le32 s_overhead_clusters;
	__le32 s_backup_bgs[2];
	__u8 s_encrypt_algos[4];
	__u8 s_encrypt_pw_salt[16];
	__le32 s_lpf_ino;
	__le32 s_prj_quota_inum;
	__le32 s_checksum_seed;
	__u8 s_wtime_hi;
	__u8 s_mtime_hi;
	__u8 s_mkfs_time_hi;
	__u8 s_lastcheck_hi;
	__u8 s_first_error_time_hi;
	__u8 s_last_error_time_hi;
	__u8 s_first_error_errcode;
	__u8 s_last_error_errcode;
	__le16 s_encoding;
	__le16 s_encoding_flags;
	__le32 s_reserved[95];
	__le32 s_checksum;
};

struct mb_cache___2;

struct ext4_group_info;

struct ext4_locality_group;

struct ext4_li_request;

struct ext4_sb_info {
	long unsigned int s_desc_size;
	long unsigned int s_inodes_per_block;
	long unsigned int s_blocks_per_group;
	long unsigned int s_clusters_per_group;
	long unsigned int s_inodes_per_group;
	long unsigned int s_itb_per_group;
	long unsigned int s_gdb_count;
	long unsigned int s_desc_per_block;
	ext4_group_t s_groups_count;
	ext4_group_t s_blockfile_groups;
	long unsigned int s_overhead;
	unsigned int s_cluster_ratio;
	unsigned int s_cluster_bits;
	loff_t s_bitmap_maxbytes;
	struct buffer_head *s_sbh;
	struct ext4_super_block *s_es;
	struct buffer_head **s_group_desc;
	unsigned int s_mount_opt;
	unsigned int s_mount_opt2;
	long unsigned int s_mount_flags;
	unsigned int s_def_mount_opt;
	ext4_fsblk_t s_sb_block;
	atomic64_t s_resv_clusters;
	kuid_t s_resuid;
	kgid_t s_resgid;
	short unsigned int s_mount_state;
	short unsigned int s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	unsigned int s_inode_readahead_blks;
	unsigned int s_inode_goal;
	u32 s_hash_seed[4];
	int s_def_hash_version;
	int s_hash_unsigned;
	struct percpu_counter s_freeclusters_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct percpu_counter s_dirtyclusters_counter;
	struct percpu_counter s_sra_exceeded_retry_limit;
	struct blockgroup_lock *s_blockgroup_lock;
	struct proc_dir_entry *s_proc;
	struct kobject s_kobj;
	struct completion s_kobj_unregister;
	struct super_block *s_sb;
	struct buffer_head *s_mmp_bh;
	struct journal_s *s_journal;
	struct list_head s_orphan;
	struct mutex s_orphan_lock;
	long unsigned int s_ext4_flags;
	long unsigned int s_commit_interval;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	struct block_device *s_journal_bdev;
	char *s_qf_names[3];
	int s_jquota_fmt;
	unsigned int s_want_extra_isize;
	struct ext4_system_blocks *s_system_blks;
	struct ext4_group_info ***s_group_info;
	struct inode *s_buddy_cache;
	spinlock_t s_md_lock;
	short unsigned int *s_mb_offsets;
	unsigned int *s_mb_maxs;
	unsigned int s_group_info_size;
	unsigned int s_mb_free_pending;
	struct list_head s_freed_data_list;
	struct rb_root s_mb_avg_fragment_size_root;
	rwlock_t s_mb_rb_lock;
	struct list_head *s_mb_largest_free_orders;
	rwlock_t *s_mb_largest_free_orders_locks;
	long unsigned int s_stripe;
	unsigned int s_mb_max_linear_groups;
	unsigned int s_mb_stream_request;
	unsigned int s_mb_max_to_scan;
	unsigned int s_mb_min_to_scan;
	unsigned int s_mb_stats;
	unsigned int s_mb_order2_reqs;
	unsigned int s_mb_group_prealloc;
	unsigned int s_mb_max_inode_prealloc;
	unsigned int s_max_dir_size_kb;
	long unsigned int s_mb_last_group;
	long unsigned int s_mb_last_start;
	unsigned int s_mb_prefetch;
	unsigned int s_mb_prefetch_limit;
	atomic_t s_bal_reqs;
	atomic_t s_bal_success;
	atomic_t s_bal_allocated;
	atomic_t s_bal_ex_scanned;
	atomic_t s_bal_groups_scanned;
	atomic_t s_bal_goals;
	atomic_t s_bal_breaks;
	atomic_t s_bal_2orders;
	atomic_t s_bal_cr0_bad_suggestions;
	atomic_t s_bal_cr1_bad_suggestions;
	atomic64_t s_bal_cX_groups_considered[4];
	atomic64_t s_bal_cX_hits[4];
	atomic64_t s_bal_cX_failed[4];
	atomic_t s_mb_buddies_generated;
	atomic64_t s_mb_generation_time;
	atomic_t s_mb_lost_chunks;
	atomic_t s_mb_preallocated;
	atomic_t s_mb_discarded;
	atomic_t s_lock_busy;
	struct ext4_locality_group *s_locality_groups;
	long unsigned int s_sectors_written_start;
	u64 s_kbytes_written;
	unsigned int s_extent_max_zeroout_kb;
	unsigned int s_log_groups_per_flex;
	struct flex_groups **s_flex_groups;
	ext4_group_t s_flex_groups_allocated;
	struct workqueue_struct *rsv_conversion_wq;
	struct timer_list s_err_report;
	struct ext4_li_request *s_li_request;
	unsigned int s_li_wait_mult;
	struct task_struct *s_mmp_tsk;
	atomic_t s_last_trim_minblks;
	struct crypto_shash *s_chksum_driver;
	__u32 s_csum_seed;
	struct shrinker s_es_shrinker;
	struct list_head s_es_list;
	long int s_es_nr_inode;
	struct ext4_es_stats s_es_stats;
	struct mb_cache___2 *s_ea_block_cache;
	struct mb_cache___2 *s_ea_inode_cache;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t s_es_lock;
	struct ratelimit_state s_err_ratelimit_state;
	struct ratelimit_state s_warning_ratelimit_state;
	struct ratelimit_state s_msg_ratelimit_state;
	atomic_t s_warning_count;
	atomic_t s_msg_count;
	struct fscrypt_dummy_policy s_dummy_enc_policy;
	struct percpu_rw_semaphore s_writepages_rwsem;
	struct dax_device *s_daxdev;
	errseq_t s_bdev_wb_err;
	spinlock_t s_bdev_wb_lock;
	spinlock_t s_error_lock;
	int s_add_error_count;
	int s_first_error_code;
	__u32 s_first_error_line;
	__u32 s_first_error_ino;
	__u64 s_first_error_block;
	const char *s_first_error_func;
	time64_t s_first_error_time;
	int s_last_error_code;
	__u32 s_last_error_line;
	__u32 s_last_error_ino;
	__u64 s_last_error_block;
	const char *s_last_error_func;
	time64_t s_last_error_time;
	struct work_struct s_error_work;
	atomic_t s_fc_subtid;
	atomic_t s_fc_ineligible_updates;
	struct list_head s_fc_q[2];
	struct list_head s_fc_dentry_q[2];
	unsigned int s_fc_bytes;
	spinlock_t s_fc_lock;
	struct buffer_head *s_fc_bh;
	struct ext4_fc_stats s_fc_stats;
	u64 s_fc_avg_commit_time;
	struct ext4_fc_replay_state s_fc_replay_state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ext4_group_info {
	long unsigned int bb_state;
	struct rb_root bb_free_root;
	ext4_grpblk_t bb_first_free;
	ext4_grpblk_t bb_free;
	ext4_grpblk_t bb_fragments;
	ext4_grpblk_t bb_largest_free_order;
	ext4_group_t bb_group;
	struct list_head bb_prealloc_list;
	struct rw_semaphore alloc_sem;
	struct rb_node bb_avg_fragment_size_rb;
	struct list_head bb_largest_free_order_node;
	ext4_grpblk_t bb_counters[0];
};

struct ext4_locality_group {
	struct mutex lg_mutex;
	struct list_head lg_prealloc_list[10];
	spinlock_t lg_prealloc_lock;
};

enum ext4_li_mode {
	EXT4_LI_MODE_PREFETCH_BBITMAP = 0,
	EXT4_LI_MODE_ITABLE = 1,
};

struct ext4_li_request {
	struct super_block *lr_super;
	enum ext4_li_mode lr_mode;
	ext4_group_t lr_first_not_zeroed;
	ext4_group_t lr_next_group;
	struct list_head lr_request;
	long unsigned int lr_next_sched;
	long unsigned int lr_timeout;
};

struct iomap_ops___2;

struct ext4_map_blocks {
	ext4_fsblk_t m_pblk;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	unsigned int m_flags;
};

struct ext4_system_zone {
	struct rb_node node;
	ext4_fsblk_t start_blk;
	unsigned int count;
	u32 ino;
};

enum {
	EXT4_INODE_SECRM = 0,
	EXT4_INODE_UNRM = 1,
	EXT4_INODE_COMPR = 2,
	EXT4_INODE_SYNC = 3,
	EXT4_INODE_IMMUTABLE = 4,
	EXT4_INODE_APPEND = 5,
	EXT4_INODE_NODUMP = 6,
	EXT4_INODE_NOATIME = 7,
	EXT4_INODE_DIRTY = 8,
	EXT4_INODE_COMPRBLK = 9,
	EXT4_INODE_NOCOMPR = 10,
	EXT4_INODE_ENCRYPT = 11,
	EXT4_INODE_INDEX = 12,
	EXT4_INODE_IMAGIC = 13,
	EXT4_INODE_JOURNAL_DATA = 14,
	EXT4_INODE_NOTAIL = 15,
	EXT4_INODE_DIRSYNC = 16,
	EXT4_INODE_TOPDIR = 17,
	EXT4_INODE_HUGE_FILE = 18,
	EXT4_INODE_EXTENTS = 19,
	EXT4_INODE_VERITY = 20,
	EXT4_INODE_EA_INODE = 21,
	EXT4_INODE_DAX = 25,
	EXT4_INODE_INLINE_DATA = 28,
	EXT4_INODE_PROJINHERIT = 29,
	EXT4_INODE_CASEFOLD = 30,
	EXT4_INODE_RESERVED = 31,
};

enum {
	EXT4_FC_REASON_OK = 0,
	EXT4_FC_REASON_INELIGIBLE = 1,
	EXT4_FC_REASON_ALREADY_COMMITTED = 2,
	EXT4_FC_REASON_FC_START_FAILED = 3,
	EXT4_FC_REASON_FC_FAILED = 4,
	EXT4_FC_REASON_XATTR = 0,
	EXT4_FC_REASON_CROSS_RENAME = 1,
	EXT4_FC_REASON_JOURNAL_FLAG_CHANGE = 2,
	EXT4_FC_REASON_NOMEM = 3,
	EXT4_FC_REASON_SWAP_BOOT = 4,
	EXT4_FC_REASON_RESIZE = 5,
	EXT4_FC_REASON_RENAME_DIR = 6,
	EXT4_FC_REASON_FALLOC_RANGE = 7,
	EXT4_FC_REASON_INODE_JOURNAL_DATA = 8,
	EXT4_FC_COMMIT_FAILED = 9,
	EXT4_FC_REASON_MAX = 10,
};

struct ext4_dir_entry_hash {
	__le32 hash;
	__le32 minor_hash;
};

struct ext4_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[255];
};

struct fname;

struct dir_private_info {
	struct rb_root root;
	struct rb_node *curr_node;
	struct fname *extra_fname;
	loff_t last_pos;
	__u32 curr_hash;
	__u32 curr_minor_hash;
	__u32 next_hash;
};

struct fname {
	__u32 hash;
	__u32 minor_hash;
	struct rb_node rb_hash;
	struct fname *next;
	__u32 inode;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

enum SHIFT_DIRECTION {
	SHIFT_LEFT = 0,
	SHIFT_RIGHT = 1,
};

struct ext4_io_end_vec {
	struct list_head list;
	loff_t offset;
	ssize_t size;
};

struct ext4_io_end {
	struct list_head list;
	handle_t *handle;
	struct inode *inode;
	struct bio *bio;
	unsigned int flag;
	atomic_t count;
	struct list_head list_vec;
};

typedef struct ext4_io_end ext4_io_end_t;

enum {
	ES_WRITTEN_B = 0,
	ES_UNWRITTEN_B = 1,
	ES_DELAYED_B = 2,
	ES_HOLE_B = 3,
	ES_REFERENCED_B = 4,
	ES_FLAGS = 5,
};

enum {
	EXT4_STATE_JDATA = 0,
	EXT4_STATE_NEW = 1,
	EXT4_STATE_XATTR = 2,
	EXT4_STATE_NO_EXPAND = 3,
	EXT4_STATE_DA_ALLOC_CLOSE = 4,
	EXT4_STATE_EXT_MIGRATE = 5,
	EXT4_STATE_NEWENTRY = 6,
	EXT4_STATE_MAY_INLINE_DATA = 7,
	EXT4_STATE_EXT_PRECACHED = 8,
	EXT4_STATE_LUSTRE_EA_INODE = 9,
	EXT4_STATE_VERITY_IN_PROGRESS = 10,
	EXT4_STATE_FC_COMMITTING = 11,
};

struct ext4_iloc {
	struct buffer_head *bh;
	long unsigned int offset;
	ext4_group_t block_group;
};

struct ext4_extent_tail {
	__le32 et_checksum;
};

struct ext4_extent {
	__le32 ee_block;
	__le16 ee_len;
	__le16 ee_start_hi;
	__le32 ee_start_lo;
};

struct ext4_extent_idx {
	__le32 ei_block;
	__le32 ei_leaf_lo;
	__le16 ei_leaf_hi;
	__u16 ei_unused;
};

struct ext4_extent_header {
	__le16 eh_magic;
	__le16 eh_entries;
	__le16 eh_max;
	__le16 eh_depth;
	__le32 eh_generation;
};

struct ext4_ext_path {
	ext4_fsblk_t p_block;
	__u16 p_depth;
	__u16 p_maxdepth;
	struct ext4_extent *p_ext;
	struct ext4_extent_idx *p_idx;
	struct ext4_extent_header *p_hdr;
	struct buffer_head *p_bh;
};

struct partial_cluster {
	ext4_fsblk_t pclu;
	ext4_lblk_t lblk;
	enum {
		initial = 0,
		tofree = 1,
		nofree = 2,
	} state;
};

struct pending_reservation {
	struct rb_node rb_node;
	ext4_lblk_t lclu;
};

struct rsvd_count {
	int ndelonly;
	bool first_do_lblk_found;
	ext4_lblk_t first_do_lblk;
	ext4_lblk_t last_do_lblk;
	struct extent_status *left_es;
	bool partial;
	ext4_lblk_t lclu;
};

enum {
	EXT4_MF_MNTDIR_SAMPLED = 0,
	EXT4_MF_FS_ABORTED = 1,
	EXT4_MF_FC_INELIGIBLE = 2,
	EXT4_MF_FC_COMMITTING = 3,
};

struct fsmap {
	__u32 fmr_device;
	__u32 fmr_flags;
	__u64 fmr_physical;
	__u64 fmr_owner;
	__u64 fmr_offset;
	__u64 fmr_length;
	__u64 fmr_reserved[3];
};

struct ext4_fsmap {
	struct list_head fmr_list;
	dev_t fmr_device;
	uint32_t fmr_flags;
	uint64_t fmr_physical;
	uint64_t fmr_owner;
	uint64_t fmr_length;
};

struct ext4_fsmap_head {
	uint32_t fmh_iflags;
	uint32_t fmh_oflags;
	unsigned int fmh_count;
	unsigned int fmh_entries;
	struct ext4_fsmap fmh_keys[2];
};

typedef int (*ext4_fsmap_format_t)(struct ext4_fsmap *, void *);

struct ext4_getfsmap_info {
	struct ext4_fsmap_head *gfi_head;
	ext4_fsmap_format_t gfi_formatter;
	void *gfi_format_arg;
	ext4_fsblk_t gfi_next_fsblk;
	u32 gfi_dev;
	ext4_group_t gfi_agno;
	struct ext4_fsmap gfi_low;
	struct ext4_fsmap gfi_high;
	struct ext4_fsmap gfi_lastfree;
	struct list_head gfi_meta_list;
	bool gfi_last;
};

struct ext4_getfsmap_dev {
	int (*gfd_fn)(struct super_block *, struct ext4_fsmap *, struct ext4_getfsmap_info *);
	u32 gfd_dev;
};

struct dx_hash_info {
	u32 hash;
	u32 minor_hash;
	int hash_version;
	u32 *seed;
};

typedef unsigned int __kernel_mode_t;

typedef __kernel_mode_t mode_t;

struct ext4_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size_lo;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks_lo;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_version;
		} linux1;
		struct {
			__u32 h_i_translator;
		} hurd1;
		struct {
			__u32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl_lo;
	__le32 i_size_high;
	__le32 i_obso_faddr;
	union {
		struct {
			__le16 l_i_blocks_high;
			__le16 l_i_file_acl_high;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__le16 l_i_checksum_lo;
			__le16 l_i_reserved;
		} linux2;
		struct {
			__le16 h_i_reserved1;
			__u16 h_i_mode_high;
			__u16 h_i_uid_high;
			__u16 h_i_gid_high;
			__u32 h_i_author;
		} hurd2;
		struct {
			__le16 h_i_reserved1;
			__le16 m_i_file_acl_high;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
	__le16 i_extra_isize;
	__le16 i_checksum_hi;
	__le32 i_ctime_extra;
	__le32 i_mtime_extra;
	__le32 i_atime_extra;
	__le32 i_crtime;
	__le32 i_crtime_extra;
	__le32 i_version_hi;
	__le32 i_projid;
};

struct orlov_stats {
	__u64 free_clusters;
	__u32 free_inodes;
	__u32 used_dirs;
};

typedef struct {
	__le32 *p;
	__le32 key;
	struct buffer_head *bh;
} Indirect;

struct ext4_filename {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	struct dx_hash_info hinfo;
	struct fscrypt_str crypto_buf;
	struct fscrypt_str cf_name;
};

struct ext4_xattr_ibody_header {
	__le32 h_magic;
};

struct ext4_xattr_entry {
	__u8 e_name_len;
	__u8 e_name_index;
	__le16 e_value_offs;
	__le32 e_value_inum;
	__le32 e_value_size;
	__le32 e_hash;
	char e_name[0];
};

struct ext4_xattr_info {
	const char *name;
	const void *value;
	size_t value_len;
	int name_index;
	int in_inode;
};

struct ext4_xattr_search {
	struct ext4_xattr_entry *first;
	void *base;
	void *end;
	struct ext4_xattr_entry *here;
	int not_found;
};

struct ext4_xattr_ibody_find {
	struct ext4_xattr_search s;
	struct ext4_iloc iloc;
};

typedef short unsigned int __kernel_uid16_t;

typedef short unsigned int __kernel_gid16_t;

typedef __kernel_uid16_t uid16_t;

typedef __kernel_gid16_t gid16_t;

struct ext4_io_submit {
	struct writeback_control *io_wbc;
	struct bio *io_bio;
	ext4_io_end_t *io_end;
	sector_t io_next_block;
};

typedef enum {
	EXT4_IGET_NORMAL = 0,
	EXT4_IGET_SPECIAL = 1,
	EXT4_IGET_HANDLE = 2,
} ext4_iget_flags;

struct ext4_xattr_inode_array {
	unsigned int count;
	struct inode *inodes[0];
};

struct mpage_da_data {
	struct inode *inode;
	struct writeback_control *wbc;
	long unsigned int first_page;
	long unsigned int next_page;
	long unsigned int last_page;
	struct ext4_map_blocks map;
	struct ext4_io_submit io_submit;
	unsigned int do_map: 1;
	unsigned int scanned_until_end: 1;
};

struct fstrim_range {
	__u64 start;
	__u64 len;
	__u64 minlen;
};

struct ext4_new_group_input {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 unused;
};

struct compat_ext4_new_group_input {
	u32 group;
	compat_u64 block_bitmap;
	compat_u64 inode_bitmap;
	compat_u64 inode_table;
	u32 blocks_count;
	u16 reserved_blocks;
	u16 unused;
};

struct ext4_new_group_data {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 mdata_blocks;
	__u32 free_clusters_count;
};

struct move_extent {
	__u32 reserved;
	__u32 donor_fd;
	__u64 orig_start;
	__u64 donor_start;
	__u64 len;
	__u64 moved_len;
};

struct fsmap_head {
	__u32 fmh_iflags;
	__u32 fmh_oflags;
	__u32 fmh_count;
	__u32 fmh_entries;
	__u64 fmh_reserved[6];
	struct fsmap fmh_keys[2];
	struct fsmap fmh_recs[0];
};

struct getfsmap_info {
	struct super_block *gi_sb;
	struct fsmap_head *gi_data;
	unsigned int gi_idx;
	__u32 gi_last_flags;
};

enum blk_default_limits {
	BLK_MAX_SEGMENTS = 128,
	BLK_SAFE_MAX_SECTORS = 255,
	BLK_DEF_MAX_SECTORS = 2560,
	BLK_MAX_SEGMENT_SIZE = 65536,
	BLK_SEG_BOUNDARY_MASK = 4294967295,
};

struct ext4_free_data {
	struct list_head efd_list;
	struct rb_node efd_node;
	ext4_group_t efd_group;
	ext4_grpblk_t efd_start_cluster;
	ext4_grpblk_t efd_count;
	tid_t efd_tid;
};

struct ext4_prealloc_space {
	struct list_head pa_inode_list;
	struct list_head pa_group_list;
	union {
		struct list_head pa_tmp_list;
		struct callback_head pa_rcu;
	} u;
	spinlock_t pa_lock;
	atomic_t pa_count;
	unsigned int pa_deleted;
	ext4_fsblk_t pa_pstart;
	ext4_lblk_t pa_lstart;
	ext4_grpblk_t pa_len;
	ext4_grpblk_t pa_free;
	short unsigned int pa_type;
	spinlock_t *pa_obj_lock;
	struct inode *pa_inode;
};

enum {
	MB_INODE_PA = 0,
	MB_GROUP_PA = 1,
};

struct ext4_free_extent {
	ext4_lblk_t fe_logical;
	ext4_grpblk_t fe_start;
	ext4_group_t fe_group;
	ext4_grpblk_t fe_len;
};

struct ext4_allocation_context {
	struct inode *ac_inode;
	struct super_block *ac_sb;
	struct ext4_free_extent ac_o_ex;
	struct ext4_free_extent ac_g_ex;
	struct ext4_free_extent ac_b_ex;
	struct ext4_free_extent ac_f_ex;
	ext4_group_t ac_last_optimal_group;
	__u32 ac_groups_considered;
	__u32 ac_flags;
	__u16 ac_groups_scanned;
	__u16 ac_groups_linear_remaining;
	__u16 ac_found;
	__u16 ac_tail;
	__u16 ac_buddy;
	__u8 ac_status;
	__u8 ac_criteria;
	__u8 ac_2order;
	__u8 ac_op;
	struct page *ac_bitmap_page;
	struct page *ac_buddy_page;
	struct ext4_prealloc_space *ac_pa;
	struct ext4_locality_group *ac_lg;
};

struct ext4_buddy {
	struct page *bd_buddy_page;
	void *bd_buddy;
	struct page *bd_bitmap_page;
	void *bd_bitmap;
	struct ext4_group_info *bd_info;
	struct super_block *bd_sb;
	__u16 bd_blkbits;
	ext4_group_t bd_group;
};

typedef int (*ext4_mballoc_query_range_fn)(struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t, void *);

struct sg {
	struct ext4_group_info info;
	ext4_grpblk_t counters[18];
};

struct migrate_struct {
	ext4_lblk_t first_block;
	ext4_lblk_t last_block;
	ext4_lblk_t curr_block;
	ext4_fsblk_t first_pblock;
	ext4_fsblk_t last_pblock;
};

struct mmp_struct {
	__le32 mmp_magic;
	__le32 mmp_seq;
	__le64 mmp_time;
	char mmp_nodename[64];
	char mmp_bdevname[32];
	__le16 mmp_check_interval;
	__le16 mmp_pad1;
	__le32 mmp_pad2[226];
	__le32 mmp_checksum;
};

struct ext4_dir_entry {
	__le32 inode;
	__le16 rec_len;
	__le16 name_len;
	char name[255];
};

struct ext4_dir_entry_tail {
	__le32 det_reserved_zero1;
	__le16 det_rec_len;
	__u8 det_reserved_zero2;
	__u8 det_reserved_ft;
	__le32 det_checksum;
};

typedef enum {
	EITHER = 0,
	INDEX = 1,
	DIRENT = 2,
	DIRENT_HTREE = 3,
} dirblock_type_t;

struct fake_dirent {
	__le32 inode;
	__le16 rec_len;
	u8 name_len;
	u8 file_type;
};

struct dx_countlimit {
	__le16 limit;
	__le16 count;
};

struct dx_entry {
	__le32 hash;
	__le32 block;
};

struct dx_root_info {
	__le32 reserved_zero;
	u8 hash_version;
	u8 info_length;
	u8 indirect_levels;
	u8 unused_flags;
};

struct dx_root {
	struct fake_dirent dot;
	char dot_name[4];
	struct fake_dirent dotdot;
	char dotdot_name[4];
	struct dx_root_info info;
	struct dx_entry entries[0];
};

struct dx_node {
	struct fake_dirent fake;
	struct dx_entry entries[0];
};

struct dx_frame {
	struct buffer_head *bh;
	struct dx_entry *entries;
	struct dx_entry *at;
};

struct dx_map_entry {
	u32 hash;
	u16 offs;
	u16 size;
};

struct dx_tail {
	u32 dt_reserved;
	__le32 dt_checksum;
};

struct ext4_renament {
	struct inode *dir;
	struct dentry *dentry;
	struct inode *inode;
	bool is_dir;
	int dir_nlink_delta;
	struct buffer_head *bh;
	struct ext4_dir_entry_2 *de;
	int inlined;
	struct buffer_head *dir_bh;
	struct ext4_dir_entry_2 *parent_de;
	int dir_inlined;
};

enum bio_post_read_step {
	STEP_INITIAL = 0,
	STEP_DECRYPT = 1,
	STEP_VERITY = 2,
	STEP_MAX = 3,
};

struct bio_post_read_ctx {
	struct bio *bio;
	struct work_struct work;
	unsigned int cur_step;
	unsigned int enabled_steps;
};

enum {
	BLOCK_BITMAP = 0,
	INODE_BITMAP = 1,
	INODE_TABLE = 2,
	GROUP_TABLE_COUNT = 3,
};

struct ext4_rcu_ptr {
	struct callback_head rcu;
	void *ptr;
};

struct ext4_new_flex_group_data {
	struct ext4_new_group_data *groups;
	__u16 *bg_flags;
	ext4_group_t count;
};

enum {
	I_DATA_SEM_NORMAL = 0,
	I_DATA_SEM_OTHER = 1,
	I_DATA_SEM_QUOTA = 2,
};

struct ext4_lazy_init {
	long unsigned int li_state;
	struct list_head li_request_list;
	struct mutex li_list_mtx;
};

struct ext4_journal_cb_entry {
	struct list_head jce_list;
	void (*jce_func)(struct super_block *, struct ext4_journal_cb_entry *, int);
};

struct trace_event_raw_ext4_other_inode_update_time {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t orig_ino;
	uid_t uid;
	gid_t gid;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_free_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	uid_t uid;
	gid_t gid;
	__u64 blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_request_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_evict_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int nlink;
	char __data[0];
};

struct trace_event_raw_ext4_drop_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int drop;
	char __data[0];
};

struct trace_event_raw_ext4_nfs_commit_metadata {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_mark_inode_dirty {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int ip;
	char __data[0];
};

struct trace_event_raw_ext4_begin_ordered_truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_ext4__write_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__write_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int copied;
	char __data[0];
};

struct trace_event_raw_ext4_writepages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	long unsigned int writeback_index;
	int sync_mode;
	char for_kupdate;
	char range_cyclic;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int first_page;
	long int nr_to_write;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 lblk;
	__u32 len;
	__u32 flags;
	char __data[0];
};

struct trace_event_raw_ext4_writepages_result {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	int pages_written;
	long int pages_skipped;
	long unsigned int writeback_index;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4__page_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_ext4_invalidatepage_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	unsigned int offset;
	unsigned int length;
	char __data[0];
};

struct trace_event_raw_ext4_discard_blocks {
	struct trace_entry ent;
	dev_t dev;
	__u64 blk;
	__u64 count;
	char __data[0];
};

struct trace_event_raw_ext4__mb_new_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 pa_pstart;
	__u64 pa_lstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_inode_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	__u32 count;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_group_pa {
	struct trace_entry ent;
	dev_t dev;
	__u64 pa_pstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	unsigned int needed;
	char __data[0];
};

struct trace_event_raw_ext4_mb_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	int needed;
	char __data[0];
};

struct trace_event_raw_ext4_request_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_free_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	long unsigned int count;
	int flags;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	int datasync;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_sync_fs {
	struct trace_entry ent;
	dev_t dev;
	int wait;
	char __data[0];
};

struct trace_event_raw_ext4_alloc_da_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int data_blocks;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 goal_logical;
	int goal_start;
	__u32 goal_group;
	int goal_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	__u16 found;
	__u16 groups;
	__u16 buddy;
	__u16 flags;
	__u16 tail;
	__u8 cr;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_prealloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4__mballoc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4_forget {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	int is_metadata;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_update_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int used_blocks;
	int reserved_data_blocks;
	int quota_claim;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_release_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int freed_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4__bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_read_block_bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	bool prefetch;
	char __data[0];
};

struct trace_event_raw_ext4__fallocate_mode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	int mode;
	char __data[0];
};

struct trace_event_raw_ext4_fallocate_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int blocks;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	loff_t size;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 blocks;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_fastpath {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	ext4_lblk_t i_lblk;
	unsigned int i_len;
	ext4_fsblk_t i_pblk;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int flags;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int mflags;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_load_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_load_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	int rsv_blocks;
	int revoke_creds;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_reserved {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	char __data[0];
};

struct trace_event_raw_ext4__trim {
	struct trace_entry ent;
	int dev_major;
	int dev_minor;
	__u32 group;
	int start;
	int len;
	char __data[0];
};

struct trace_event_raw_ext4_ext_handle_unwritten_extents {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	unsigned int allocated;
	ext4_fsblk_t newblk;
	char __data[0];
};

struct trace_event_raw_ext4_get_implied_cluster_alloc_exit {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_show_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	short unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_remove_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	ext4_fsblk_t ee_pblk;
	ext4_lblk_t ee_lblk;
	short unsigned int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_leaf {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t ee_lblk;
	ext4_fsblk_t ee_pblk;
	short int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_idx {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space_done {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	short unsigned int eh_entries;
	char __data[0];
};

struct trace_event_raw_ext4__es_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_remove_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t lblk;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	int found;
	char __data[0];
};

struct trace_event_raw_ext4__es_shrink_enter {
	struct trace_entry ent;
	dev_t dev;
	int nr_to_scan;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_collapse_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_insert_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	long long unsigned int scan_time;
	int nr_skipped;
	int retried;
	char __data[0];
};

struct trace_event_raw_ext4_es_insert_delayed_block {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	bool allocated;
	char __data[0];
};

struct trace_event_raw_ext4_fsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u32 agno;
	u64 bno;
	u64 len;
	u64 owner;
	char __data[0];
};

struct trace_event_raw_ext4_getfsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u64 block;
	u64 len;
	u64 owner;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_ext4_shutdown {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_error {
	struct trace_entry ent;
	dev_t dev;
	const char *function;
	unsigned int line;
	char __data[0];
};

struct trace_event_raw_ext4_prefetch_bitmaps {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	__u32 next;
	__u32 ios;
	char __data[0];
};

struct trace_event_raw_ext4_lazy_itable_init {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay_scan {
	struct trace_entry ent;
	dev_t dev;
	int error;
	int off;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay {
	struct trace_entry ent;
	dev_t dev;
	int tag;
	int ino;
	int priv1;
	int priv2;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_start {
	struct trace_entry ent;
	dev_t dev;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_stop {
	struct trace_entry ent;
	dev_t dev;
	int nblks;
	int reason;
	int num_fc;
	int num_fc_ineligible;
	int nblks_agg;
	char __data[0];
};

struct trace_event_raw_ext4_fc_stats {
	struct trace_entry ent;
	dev_t dev;
	struct ext4_sb_info *sbi;
	int count;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_create {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_link {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_unlink {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_inode {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_range {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	long int start;
	long int end;
	int error;
	char __data[0];
};

struct trace_event_data_offsets_ext4_other_inode_update_time {};

struct trace_event_data_offsets_ext4_free_inode {};

struct trace_event_data_offsets_ext4_request_inode {};

struct trace_event_data_offsets_ext4_allocate_inode {};

struct trace_event_data_offsets_ext4_evict_inode {};

struct trace_event_data_offsets_ext4_drop_inode {};

struct trace_event_data_offsets_ext4_nfs_commit_metadata {};

struct trace_event_data_offsets_ext4_mark_inode_dirty {};

struct trace_event_data_offsets_ext4_begin_ordered_truncate {};

struct trace_event_data_offsets_ext4__write_begin {};

struct trace_event_data_offsets_ext4__write_end {};

struct trace_event_data_offsets_ext4_writepages {};

struct trace_event_data_offsets_ext4_da_write_pages {};

struct trace_event_data_offsets_ext4_da_write_pages_extent {};

struct trace_event_data_offsets_ext4_writepages_result {};

struct trace_event_data_offsets_ext4__page_op {};

struct trace_event_data_offsets_ext4_invalidatepage_op {};

struct trace_event_data_offsets_ext4_discard_blocks {};

struct trace_event_data_offsets_ext4__mb_new_pa {};

struct trace_event_data_offsets_ext4_mb_release_inode_pa {};

struct trace_event_data_offsets_ext4_mb_release_group_pa {};

struct trace_event_data_offsets_ext4_discard_preallocations {};

struct trace_event_data_offsets_ext4_mb_discard_preallocations {};

struct trace_event_data_offsets_ext4_request_blocks {};

struct trace_event_data_offsets_ext4_allocate_blocks {};

struct trace_event_data_offsets_ext4_free_blocks {};

struct trace_event_data_offsets_ext4_sync_file_enter {};

struct trace_event_data_offsets_ext4_sync_file_exit {};

struct trace_event_data_offsets_ext4_sync_fs {};

struct trace_event_data_offsets_ext4_alloc_da_blocks {};

struct trace_event_data_offsets_ext4_mballoc_alloc {};

struct trace_event_data_offsets_ext4_mballoc_prealloc {};

struct trace_event_data_offsets_ext4__mballoc {};

struct trace_event_data_offsets_ext4_forget {};

struct trace_event_data_offsets_ext4_da_update_reserve_space {};

struct trace_event_data_offsets_ext4_da_reserve_space {};

struct trace_event_data_offsets_ext4_da_release_space {};

struct trace_event_data_offsets_ext4__bitmap_load {};

struct trace_event_data_offsets_ext4_read_block_bitmap_load {};

struct trace_event_data_offsets_ext4__fallocate_mode {};

struct trace_event_data_offsets_ext4_fallocate_exit {};

struct trace_event_data_offsets_ext4_unlink_enter {};

struct trace_event_data_offsets_ext4_unlink_exit {};

struct trace_event_data_offsets_ext4__truncate {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_enter {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_fastpath {};

struct trace_event_data_offsets_ext4__map_blocks_enter {};

struct trace_event_data_offsets_ext4__map_blocks_exit {};

struct trace_event_data_offsets_ext4_ext_load_extent {};

struct trace_event_data_offsets_ext4_load_inode {};

struct trace_event_data_offsets_ext4_journal_start {};

struct trace_event_data_offsets_ext4_journal_start_reserved {};

struct trace_event_data_offsets_ext4__trim {};

struct trace_event_data_offsets_ext4_ext_handle_unwritten_extents {};

struct trace_event_data_offsets_ext4_get_implied_cluster_alloc_exit {};

struct trace_event_data_offsets_ext4_ext_show_extent {};

struct trace_event_data_offsets_ext4_remove_blocks {};

struct trace_event_data_offsets_ext4_ext_rm_leaf {};

struct trace_event_data_offsets_ext4_ext_rm_idx {};

struct trace_event_data_offsets_ext4_ext_remove_space {};

struct trace_event_data_offsets_ext4_ext_remove_space_done {};

struct trace_event_data_offsets_ext4__es_extent {};

struct trace_event_data_offsets_ext4_es_remove_extent {};

struct trace_event_data_offsets_ext4_es_find_extent_range_enter {};

struct trace_event_data_offsets_ext4_es_find_extent_range_exit {};

struct trace_event_data_offsets_ext4_es_lookup_extent_enter {};

struct trace_event_data_offsets_ext4_es_lookup_extent_exit {};

struct trace_event_data_offsets_ext4__es_shrink_enter {};

struct trace_event_data_offsets_ext4_es_shrink_scan_exit {};

struct trace_event_data_offsets_ext4_collapse_range {};

struct trace_event_data_offsets_ext4_insert_range {};

struct trace_event_data_offsets_ext4_es_shrink {};

struct trace_event_data_offsets_ext4_es_insert_delayed_block {};

struct trace_event_data_offsets_ext4_fsmap_class {};

struct trace_event_data_offsets_ext4_getfsmap_class {};

struct trace_event_data_offsets_ext4_shutdown {};

struct trace_event_data_offsets_ext4_error {};

struct trace_event_data_offsets_ext4_prefetch_bitmaps {};

struct trace_event_data_offsets_ext4_lazy_itable_init {};

struct trace_event_data_offsets_ext4_fc_replay_scan {};

struct trace_event_data_offsets_ext4_fc_replay {};

struct trace_event_data_offsets_ext4_fc_commit_start {};

struct trace_event_data_offsets_ext4_fc_commit_stop {};

struct trace_event_data_offsets_ext4_fc_stats {};

struct trace_event_data_offsets_ext4_fc_track_create {};

struct trace_event_data_offsets_ext4_fc_track_link {};

struct trace_event_data_offsets_ext4_fc_track_unlink {};

struct trace_event_data_offsets_ext4_fc_track_inode {};

struct trace_event_data_offsets_ext4_fc_track_range {};

typedef void (*btf_trace_ext4_other_inode_update_time)(void *, struct inode *, ino_t);

typedef void (*btf_trace_ext4_free_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_request_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_allocate_inode)(void *, struct inode *, struct inode *, int);

typedef void (*btf_trace_ext4_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_drop_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_nfs_commit_metadata)(void *, struct inode *);

typedef void (*btf_trace_ext4_mark_inode_dirty)(void *, struct inode *, long unsigned int);

typedef void (*btf_trace_ext4_begin_ordered_truncate)(void *, struct inode *, loff_t);

typedef void (*btf_trace_ext4_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_writepages)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages)(void *, struct inode *, long unsigned int, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages_extent)(void *, struct inode *, struct ext4_map_blocks *);

typedef void (*btf_trace_ext4_writepages_result)(void *, struct inode *, struct writeback_control *, int, int);

typedef void (*btf_trace_ext4_writepage)(void *, struct page *);

typedef void (*btf_trace_ext4_readpage)(void *, struct page *);

typedef void (*btf_trace_ext4_releasepage)(void *, struct page *);

typedef void (*btf_trace_ext4_invalidatepage)(void *, struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_invalidatepage)(void *, struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_discard_blocks)(void *, struct super_block *, long long unsigned int, long long unsigned int);

typedef void (*btf_trace_ext4_mb_new_inode_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_new_group_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_release_inode_pa)(void *, struct ext4_prealloc_space *, long long unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_release_group_pa)(void *, struct super_block *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_discard_preallocations)(void *, struct inode *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_discard_preallocations)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_request_blocks)(void *, struct ext4_allocation_request *);

typedef void (*btf_trace_ext4_allocate_blocks)(void *, struct ext4_allocation_request *, long long unsigned int);

typedef void (*btf_trace_ext4_free_blocks)(void *, struct inode *, __u64, long unsigned int, int);

typedef void (*btf_trace_ext4_sync_file_enter)(void *, struct file *, int);

typedef void (*btf_trace_ext4_sync_file_exit)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_sync_fs)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_alloc_da_blocks)(void *, struct inode *);

typedef void (*btf_trace_ext4_mballoc_alloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_prealloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_discard)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_mballoc_free)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_forget)(void *, struct inode *, int, __u64);

typedef void (*btf_trace_ext4_da_update_reserve_space)(void *, struct inode *, int, int);

typedef void (*btf_trace_ext4_da_reserve_space)(void *, struct inode *);

typedef void (*btf_trace_ext4_da_release_space)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_mb_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mb_buddy_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_load_inode_bitmap)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_read_block_bitmap_load)(void *, struct super_block *, long unsigned int, bool);

typedef void (*btf_trace_ext4_fallocate_enter)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_punch_hole)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_zero_range)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_fallocate_exit)(void *, struct inode *, loff_t, unsigned int, int);

typedef void (*btf_trace_ext4_unlink_enter)(void *, struct inode *, struct dentry *);

typedef void (*btf_trace_ext4_unlink_exit)(void *, struct dentry *, int);

typedef void (*btf_trace_ext4_truncate_enter)(void *, struct inode *);

typedef void (*btf_trace_ext4_truncate_exit)(void *, struct inode *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_enter)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_fastpath)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ind_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ext_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ind_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_load_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t);

typedef void (*btf_trace_ext4_load_inode)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_journal_start)(void *, struct super_block *, int, int, int, long unsigned int);

typedef void (*btf_trace_ext4_journal_start_reserved)(void *, struct super_block *, int, long unsigned int);

typedef void (*btf_trace_ext4_trim_extent)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_trim_all_free)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_ext_handle_unwritten_extents)(void *, struct inode *, struct ext4_map_blocks *, int, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_get_implied_cluster_alloc_exit)(void *, struct super_block *, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_show_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t, short unsigned int);

typedef void (*btf_trace_ext4_remove_blocks)(void *, struct inode *, struct ext4_extent *, ext4_lblk_t, ext4_fsblk_t, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_leaf)(void *, struct inode *, ext4_lblk_t, struct ext4_extent *, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_idx)(void *, struct inode *, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_remove_space)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_ext_remove_space_done)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, struct partial_cluster *, __le16);

typedef void (*btf_trace_ext4_es_insert_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_cache_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_remove_extent)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_exit)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_lookup_extent_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_lookup_extent_exit)(void *, struct inode *, struct extent_status *, int);

typedef void (*btf_trace_ext4_es_shrink_count)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_enter)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_exit)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_collapse_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_insert_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_es_shrink)(void *, struct super_block *, int, u64, int, int);

typedef void (*btf_trace_ext4_es_insert_delayed_block)(void *, struct inode *, struct extent_status *, bool);

typedef void (*btf_trace_ext4_fsmap_low_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_high_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_mapping)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_getfsmap_low_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_high_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_mapping)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_shutdown)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_error)(void *, struct super_block *, const char *, unsigned int);

typedef void (*btf_trace_ext4_prefetch_bitmaps)(void *, struct super_block *, ext4_group_t, ext4_group_t, unsigned int);

typedef void (*btf_trace_ext4_lazy_itable_init)(void *, struct super_block *, ext4_group_t);

typedef void (*btf_trace_ext4_fc_replay_scan)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_replay)(void *, struct super_block *, int, int, int, int);

typedef void (*btf_trace_ext4_fc_commit_start)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_commit_stop)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_stats)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_track_create)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_link)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_unlink)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_fc_track_range)(void *, struct inode *, long int, long int, int);

struct ext4_err_translation {
	int code;
	int errno;
};

enum {
	Opt_bsd_df = 0,
	Opt_minix_df = 1,
	Opt_grpid = 2,
	Opt_nogrpid = 3,
	Opt_resgid = 4,
	Opt_resuid = 5,
	Opt_sb = 6,
	Opt_err_cont = 7,
	Opt_err_panic = 8,
	Opt_err_ro = 9,
	Opt_nouid32 = 10,
	Opt_debug = 11,
	Opt_removed = 12,
	Opt_user_xattr = 13,
	Opt_nouser_xattr = 14,
	Opt_acl = 15,
	Opt_noacl = 16,
	Opt_auto_da_alloc = 17,
	Opt_noauto_da_alloc = 18,
	Opt_noload = 19,
	Opt_commit = 20,
	Opt_min_batch_time = 21,
	Opt_max_batch_time = 22,
	Opt_journal_dev = 23,
	Opt_journal_path = 24,
	Opt_journal_checksum = 25,
	Opt_journal_async_commit = 26,
	Opt_abort = 27,
	Opt_data_journal = 28,
	Opt_data_ordered = 29,
	Opt_data_writeback = 30,
	Opt_data_err_abort = 31,
	Opt_data_err_ignore = 32,
	Opt_test_dummy_encryption = 33,
	Opt_inlinecrypt = 34,
	Opt_usrjquota = 35,
	Opt_grpjquota = 36,
	Opt_offusrjquota = 37,
	Opt_offgrpjquota = 38,
	Opt_jqfmt_vfsold = 39,
	Opt_jqfmt_vfsv0 = 40,
	Opt_jqfmt_vfsv1 = 41,
	Opt_quota = 42,
	Opt_noquota = 43,
	Opt_barrier = 44,
	Opt_nobarrier = 45,
	Opt_err___2 = 46,
	Opt_usrquota = 47,
	Opt_grpquota = 48,
	Opt_prjquota = 49,
	Opt_i_version = 50,
	Opt_dax = 51,
	Opt_dax_always = 52,
	Opt_dax_inode = 53,
	Opt_dax_never = 54,
	Opt_stripe = 55,
	Opt_delalloc = 56,
	Opt_nodelalloc = 57,
	Opt_warn_on_error = 58,
	Opt_nowarn_on_error = 59,
	Opt_mblk_io_submit = 60,
	Opt_lazytime = 61,
	Opt_nolazytime = 62,
	Opt_debug_want_extra_isize = 63,
	Opt_nomblk_io_submit = 64,
	Opt_block_validity = 65,
	Opt_noblock_validity = 66,
	Opt_inode_readahead_blks = 67,
	Opt_journal_ioprio = 68,
	Opt_dioread_nolock = 69,
	Opt_dioread_lock = 70,
	Opt_discard = 71,
	Opt_nodiscard = 72,
	Opt_init_itable = 73,
	Opt_noinit_itable = 74,
	Opt_max_dir_size_kb = 75,
	Opt_nojournal_checksum = 76,
	Opt_nombcache = 77,
	Opt_no_prefetch_block_bitmaps = 78,
	Opt_mb_optimize_scan = 79,
};

struct mount_opts {
	int token;
	int mount_opt;
	int flags;
};

struct ext4_sb_encodings {
	__u16 magic;
	char *name;
	char *version;
};

struct ext4_parsed_options {
	long unsigned int journal_devnum;
	unsigned int journal_ioprio;
	int mb_optimize_scan;
};

struct ext4_mount_options {
	long unsigned int s_mount_opt;
	long unsigned int s_mount_opt2;
	kuid_t s_resuid;
	kgid_t s_resgid;
	long unsigned int s_commit_interval;
	u32 s_min_batch_time;
	u32 s_max_batch_time;
	int s_jquota_fmt;
	char *s_qf_names[3];
};

enum {
	attr_noop = 0,
	attr_delayed_allocation_blocks = 1,
	attr_session_write_kbytes = 2,
	attr_lifetime_write_kbytes = 3,
	attr_reserved_clusters = 4,
	attr_sra_exceeded_retry_limit = 5,
	attr_inode_readahead = 6,
	attr_trigger_test_error = 7,
	attr_first_error_time = 8,
	attr_last_error_time = 9,
	attr_feature = 10,
	attr_pointer_ui = 11,
	attr_pointer_ul = 12,
	attr_pointer_u64 = 13,
	attr_pointer_u8 = 14,
	attr_pointer_string = 15,
	attr_pointer_atomic = 16,
	attr_journal_task = 17,
};

enum {
	ptr_explicit = 0,
	ptr_ext4_sb_info_offset = 1,
	ptr_ext4_super_block_offset = 2,
};

struct ext4_attr {
	struct attribute attr;
	short int attr_id;
	short int attr_ptr;
	short unsigned int attr_size;
	union {
		int offset;
		void *explicit_ptr;
	} u;
};

struct ext4_xattr_header {
	__le32 h_magic;
	__le32 h_refcount;
	__le32 h_blocks;
	__le32 h_hash;
	__le32 h_checksum;
	__u32 h_reserved[3];
};

struct ext4_xattr_block_find {
	struct ext4_xattr_search s;
	struct buffer_head *bh;
};

struct ext4_fc_tl {
	__le16 fc_tag;
	__le16 fc_len;
};

struct ext4_fc_head {
	__le32 fc_features;
	__le32 fc_tid;
};

struct ext4_fc_add_range {
	__le32 fc_ino;
	__u8 fc_ex[12];
};

struct ext4_fc_del_range {
	__le32 fc_ino;
	__le32 fc_lblk;
	__le32 fc_len;
};

struct ext4_fc_dentry_info {
	__le32 fc_parent_ino;
	__le32 fc_ino;
	__u8 fc_dname[0];
};

struct ext4_fc_inode {
	__le32 fc_ino;
	__u8 fc_raw_inode[0];
};

struct ext4_fc_tail {
	__le32 fc_tid;
	__le32 fc_crc;
};

struct ext4_fc_dentry_update {
	int fcd_op;
	int fcd_parent;
	int fcd_ino;
	struct qstr fcd_name;
	unsigned char fcd_iname[32];
	struct list_head fcd_list;
};

struct __track_dentry_update_args {
	struct dentry *dentry;
	int op;
};

struct __track_range_args {
	ext4_lblk_t start;
	ext4_lblk_t end;
};

struct dentry_info_args {
	int parent_ino;
	int dname_len;
	int ino;
	int inode_len;
	char *dname;
};

typedef struct {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
} ext4_acl_entry;

typedef struct {
	__le32 a_version;
} ext4_acl_header;

struct commit_header {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
	unsigned char h_chksum_type;
	unsigned char h_chksum_size;
	unsigned char h_padding[2];
	__be32 h_chksum[8];
	__be64 h_commit_sec;
	__be32 h_commit_nsec;
};

struct journal_block_tag3_s {
	__be32 t_blocknr;
	__be32 t_flags;
	__be32 t_blocknr_high;
	__be32 t_checksum;
};

typedef struct journal_block_tag3_s journal_block_tag3_t;

struct journal_block_tag_s {
	__be32 t_blocknr;
	__be16 t_checksum;
	__be16 t_flags;
	__be32 t_blocknr_high;
};

typedef struct journal_block_tag_s journal_block_tag_t;

struct jbd2_journal_block_tail {
	__be32 t_checksum;
};

struct jbd2_journal_revoke_header_s {
	journal_header_t r_header;
	__be32 r_count;
};

typedef struct jbd2_journal_revoke_header_s jbd2_journal_revoke_header_t;

struct recovery_info {
	tid_t start_transaction;
	tid_t end_transaction;
	int nr_replays;
	int nr_revokes;
	int nr_revoke_hits;
};

struct jbd2_revoke_table_s {
	int hash_size;
	int hash_shift;
	struct list_head *hash_table;
};

struct jbd2_revoke_record_s {
	struct list_head hash;
	tid_t sequence;
	long long unsigned int blocknr;
};

struct trace_event_raw_jbd2_checkpoint {
	struct trace_entry ent;
	dev_t dev;
	int result;
	char __data[0];
};

struct trace_event_raw_jbd2_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	int transaction;
	char __data[0];
};

struct trace_event_raw_jbd2_end_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	int transaction;
	int head;
	char __data[0];
};

struct trace_event_raw_jbd2_submit_inode_data {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_start_class {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_extend {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int buffer_credits;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int interval;
	int sync;
	int requested_blocks;
	int dirtied_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_run_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	long unsigned int wait;
	long unsigned int request_delay;
	long unsigned int running;
	long unsigned int locked;
	long unsigned int flushing;
	long unsigned int logging;
	__u32 handle_count;
	__u32 blocks;
	__u32 blocks_logged;
	char __data[0];
};

struct trace_event_raw_jbd2_checkpoint_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	long unsigned int chp_time;
	__u32 forced_to_close;
	__u32 written;
	__u32 dropped;
	char __data[0];
};

struct trace_event_raw_jbd2_update_log_tail {
	struct trace_entry ent;
	dev_t dev;
	tid_t tail_sequence;
	tid_t first_tid;
	long unsigned int block_nr;
	long unsigned int freed;
	char __data[0];
};

struct trace_event_raw_jbd2_write_superblock {
	struct trace_entry ent;
	dev_t dev;
	int write_op;
	char __data[0];
};

struct trace_event_raw_jbd2_lock_buffer_stall {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int stall_ms;
	char __data[0];
};

struct trace_event_data_offsets_jbd2_checkpoint {};

struct trace_event_data_offsets_jbd2_commit {};

struct trace_event_data_offsets_jbd2_end_commit {};

struct trace_event_data_offsets_jbd2_submit_inode_data {};

struct trace_event_data_offsets_jbd2_handle_start_class {};

struct trace_event_data_offsets_jbd2_handle_extend {};

struct trace_event_data_offsets_jbd2_handle_stats {};

struct trace_event_data_offsets_jbd2_run_stats {};

struct trace_event_data_offsets_jbd2_checkpoint_stats {};

struct trace_event_data_offsets_jbd2_update_log_tail {};

struct trace_event_data_offsets_jbd2_write_superblock {};

struct trace_event_data_offsets_jbd2_lock_buffer_stall {};

typedef void (*btf_trace_jbd2_checkpoint)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_start_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_locking)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_flushing)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_logging)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_drop_transaction)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_end_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_submit_inode_data)(void *, struct inode *);

typedef void (*btf_trace_jbd2_handle_start)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_restart)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_extend)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int, int);

typedef void (*btf_trace_jbd2_handle_stats)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int, int, int, int);

typedef void (*btf_trace_jbd2_run_stats)(void *, dev_t, long unsigned int, struct transaction_run_stats_s *);

typedef void (*btf_trace_jbd2_checkpoint_stats)(void *, dev_t, long unsigned int, struct transaction_chp_stats_s *);

typedef void (*btf_trace_jbd2_update_log_tail)(void *, journal_t *, tid_t, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_write_superblock)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_lock_buffer_stall)(void *, dev_t, long unsigned int);

struct jbd2_stats_proc_session {
	journal_t *journal;
	struct transaction_stats_s *stats;
	int start;
	int max;
};

struct meta_entry {
	u64 data_block;
	unsigned int index_block;
	short unsigned int offset;
	short unsigned int pad;
};

struct meta_index {
	unsigned int inode_number;
	unsigned int offset;
	short unsigned int entries;
	short unsigned int skip;
	short unsigned int locked;
	short unsigned int pad;
	struct meta_entry meta_entry[127];
};

struct squashfs_cache_entry;

struct squashfs_cache {
	char *name;
	int entries;
	int curr_blk;
	int next_blk;
	int num_waiters;
	int unused;
	int block_size;
	int pages;
	spinlock_t lock;
	wait_queue_head_t wait_queue;
	struct squashfs_cache_entry *entry;
};

struct squashfs_page_actor;

struct squashfs_cache_entry {
	u64 block;
	int length;
	int refcount;
	u64 next_index;
	int pending;
	int error;
	int num_waiters;
	wait_queue_head_t wait_queue;
	struct squashfs_cache *cache;
	void **data;
	struct squashfs_page_actor *actor;
};

struct squashfs_page_actor {
	union {
		void **buffer;
		struct page **page;
	};
	void *pageaddr;
	void * (*squashfs_first_page)(struct squashfs_page_actor *);
	void * (*squashfs_next_page)(struct squashfs_page_actor *);
	void (*squashfs_finish_page)(struct squashfs_page_actor *);
	int pages;
	int length;
	int next_page;
};

struct squashfs_decompressor;

struct squashfs_stream;

struct squashfs_sb_info {
	const struct squashfs_decompressor *decompressor;
	int devblksize;
	int devblksize_log2;
	struct squashfs_cache *block_cache;
	struct squashfs_cache *fragment_cache;
	struct squashfs_cache *read_page;
	int next_meta_index;
	__le64 *id_table;
	__le64 *fragment_index;
	__le64 *xattr_id_table;
	struct mutex meta_index_mutex;
	struct meta_index *meta_index;
	struct squashfs_stream *stream;
	__le64 *inode_lookup_table;
	u64 inode_table;
	u64 directory_table;
	u64 xattr_table;
	unsigned int block_size;
	short unsigned int block_log;
	long long int bytes_used;
	unsigned int inodes;
	unsigned int fragments;
	int xattr_ids;
	unsigned int ids;
};

struct squashfs_decompressor {
	void * (*init)(struct squashfs_sb_info *, void *);
	void * (*comp_opts)(struct squashfs_sb_info *, void *, int);
	void (*free)(void *);
	int (*decompress)(struct squashfs_sb_info *, void *, struct bio *, int, int, struct squashfs_page_actor *);
	int id;
	char *name;
	int supported;
};

struct squashfs_dir_index {
	__le32 index;
	__le32 start_block;
	__le32 size;
	unsigned char name[0];
};

struct squashfs_dir_entry {
	__le16 offset;
	__le16 inode_number;
	__le16 type;
	__le16 size;
	char name[0];
};

struct squashfs_dir_header {
	__le32 count;
	__le32 start_block;
	__le32 inode_number;
};

struct squashfs_inode_info {
	u64 start;
	int offset;
	u64 xattr;
	unsigned int xattr_size;
	int xattr_count;
	union {
		struct {
			u64 fragment_block;
			int fragment_size;
			int fragment_offset;
			u64 block_list_start;
		};
		struct {
			u64 dir_idx_start;
			int dir_idx_offset;
			int dir_idx_cnt;
			int parent;
		};
	};
	struct inode vfs_inode;
};

struct squashfs_fragment_entry {
	__le64 start_block;
	__le32 size;
	unsigned int unused;
};

struct squashfs_base_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
};

struct squashfs_ipc_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
};

struct squashfs_lipc_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 xattr;
};

struct squashfs_dev_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 rdev;
};

struct squashfs_ldev_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 rdev;
	__le32 xattr;
};

struct squashfs_symlink_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 symlink_size;
	char symlink[0];
};

struct squashfs_reg_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 start_block;
	__le32 fragment;
	__le32 offset;
	__le32 file_size;
	__le16 block_list[0];
};

struct squashfs_lreg_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le64 start_block;
	__le64 file_size;
	__le64 sparse;
	__le32 nlink;
	__le32 fragment;
	__le32 offset;
	__le32 xattr;
	__le16 block_list[0];
};

struct squashfs_dir_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 start_block;
	__le32 nlink;
	__le16 file_size;
	__le16 offset;
	__le32 parent_inode;
};

struct squashfs_ldir_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 file_size;
	__le32 start_block;
	__le32 parent_inode;
	__le16 i_count;
	__le16 offset;
	__le32 xattr;
	struct squashfs_dir_index index[0];
};

union squashfs_inode {
	struct squashfs_base_inode base;
	struct squashfs_dev_inode dev;
	struct squashfs_ldev_inode ldev;
	struct squashfs_symlink_inode symlink;
	struct squashfs_reg_inode reg;
	struct squashfs_lreg_inode lreg;
	struct squashfs_dir_inode dir;
	struct squashfs_ldir_inode ldir;
	struct squashfs_ipc_inode ipc;
	struct squashfs_lipc_inode lipc;
};

struct squashfs_super_block {
	__le32 s_magic;
	__le32 inodes;
	__le32 mkfs_time;
	__le32 block_size;
	__le32 fragments;
	__le16 compression;
	__le16 block_log;
	__le16 flags;
	__le16 no_ids;
	__le16 s_major;
	__le16 s_minor;
	__le64 root_inode;
	__le64 bytes_used;
	__le64 id_table_start;
	__le64 xattr_id_table_start;
	__le64 inode_table_start;
	__le64 directory_table_start;
	__le64 fragment_table_start;
	__le64 lookup_table_start;
};

struct squashfs_stream {
	void *stream;
	struct mutex mutex;
};

struct squashfs_xattr_entry {
	__le16 type;
	__le16 size;
	char data[0];
};

struct squashfs_xattr_val {
	__le32 vsize;
	char value[0];
};

struct squashfs_xattr_id {
	__le64 xattr;
	__le32 count;
	__le32 size;
};

struct squashfs_xattr_id_table {
	__le64 xattr_table_start;
	__le32 xattr_ids;
	__le32 unused;
};

struct lz4_comp_opts {
	__le32 version;
	__le32 flags;
};

struct squashfs_lz4 {
	void *input;
	void *output;
};

struct squashfs_lzo {
	void *input;
	void *output;
};

enum xz_mode {
	XZ_SINGLE = 0,
	XZ_PREALLOC = 1,
	XZ_DYNALLOC = 2,
};

enum xz_ret {
	XZ_OK = 0,
	XZ_STREAM_END = 1,
	XZ_UNSUPPORTED_CHECK = 2,
	XZ_MEM_ERROR = 3,
	XZ_MEMLIMIT_ERROR = 4,
	XZ_FORMAT_ERROR = 5,
	XZ_OPTIONS_ERROR = 6,
	XZ_DATA_ERROR = 7,
	XZ_BUF_ERROR = 8,
};

struct xz_buf {
	const uint8_t *in;
	size_t in_pos;
	size_t in_size;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
};

struct xz_dec;

struct squashfs_xz {
	struct xz_dec *state;
	struct xz_buf buf;
};

struct disk_comp_opts {
	__le32 dictionary_size;
	__le32 flags;
};

struct comp_opts {
	int dict_size;
};

typedef unsigned char Byte;

typedef long unsigned int uLong;

struct internal_state;

struct z_stream_s {
	const Byte *next_in;
	uLong avail_in;
	uLong total_in;
	Byte *next_out;
	uLong avail_out;
	uLong total_out;
	char *msg;
	struct internal_state *state;
	void *workspace;
	int data_type;
	uLong adler;
	uLong reserved;
};

struct internal_state {
	int dummy;
};

typedef struct z_stream_s z_stream;

typedef enum {
	ZSTD_error_no_error = 0,
	ZSTD_error_GENERIC = 1,
	ZSTD_error_prefix_unknown = 2,
	ZSTD_error_version_unsupported = 3,
	ZSTD_error_parameter_unknown = 4,
	ZSTD_error_frameParameter_unsupported = 5,
	ZSTD_error_frameParameter_unsupportedBy32bits = 6,
	ZSTD_error_frameParameter_windowTooLarge = 7,
	ZSTD_error_compressionParameter_unsupported = 8,
	ZSTD_error_init_missing = 9,
	ZSTD_error_memory_allocation = 10,
	ZSTD_error_stage_wrong = 11,
	ZSTD_error_dstSize_tooSmall = 12,
	ZSTD_error_srcSize_wrong = 13,
	ZSTD_error_corruption_detected = 14,
	ZSTD_error_checksum_wrong = 15,
	ZSTD_error_tableLog_tooLarge = 16,
	ZSTD_error_maxSymbolValue_tooLarge = 17,
	ZSTD_error_maxSymbolValue_tooSmall = 18,
	ZSTD_error_dictionary_corrupted = 19,
	ZSTD_error_dictionary_wrong = 20,
	ZSTD_error_dictionaryCreation_failed = 21,
	ZSTD_error_maxCode = 22,
} ZSTD_ErrorCode;

struct ZSTD_inBuffer_s {
	const void *src;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_inBuffer_s ZSTD_inBuffer;

struct ZSTD_outBuffer_s {
	void *dst;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_outBuffer_s ZSTD_outBuffer;

struct ZSTD_DStream_s;

typedef struct ZSTD_DStream_s ZSTD_DStream;

struct workspace {
	void *mem;
	size_t mem_size;
	size_t window_size;
};

struct ramfs_mount_opts {
	umode_t mode;
};

struct ramfs_fs_info {
	struct ramfs_mount_opts mount_opts;
};

enum ramfs_param {
	Opt_mode___3 = 0,
};

enum hugetlbfs_size_type {
	NO_SIZE = 0,
	SIZE_STD = 1,
	SIZE_PERCENT = 2,
};

struct hugetlbfs_fs_context {
	struct hstate *hstate;
	long long unsigned int max_size_opt;
	long long unsigned int min_size_opt;
	long int max_hpages;
	long int nr_inodes;
	long int min_hpages;
	enum hugetlbfs_size_type max_val_type;
	enum hugetlbfs_size_type min_val_type;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

enum hugetlb_param {
	Opt_gid___4 = 0,
	Opt_min_size = 1,
	Opt_mode___4 = 2,
	Opt_nr_inodes___2 = 3,
	Opt_pagesize = 4,
	Opt_size___2 = 5,
	Opt_uid___3 = 6,
};

typedef u16 vm_wchar_t;

struct nls_table {
	const char *charset;
	const char *alias;
	int (*uni2char)(vm_wchar_t, unsigned char *, int);
	int (*char2uni)(const unsigned char *, int, vm_wchar_t *);
	const unsigned char *charset2lower;
	const unsigned char *charset2upper;
	struct module *owner;
	struct nls_table *next;
};

struct fat_mount_options {
	kuid_t fs_uid;
	kgid_t fs_gid;
	short unsigned int fs_fmask;
	short unsigned int fs_dmask;
	short unsigned int codepage;
	int time_offset;
	char *iocharset;
	short unsigned int shortname;
	unsigned char name_check;
	unsigned char errors;
	unsigned char nfs;
	short unsigned int allow_utime;
	unsigned int quiet: 1;
	unsigned int showexec: 1;
	unsigned int sys_immutable: 1;
	unsigned int dotsOK: 1;
	unsigned int isvfat: 1;
	unsigned int utf8: 1;
	unsigned int unicode_xlate: 1;
	unsigned int numtail: 1;
	unsigned int flush: 1;
	unsigned int nocase: 1;
	unsigned int usefree: 1;
	unsigned int tz_set: 1;
	unsigned int rodir: 1;
	unsigned int discard: 1;
	unsigned int dos1xfloppy: 1;
};

struct fatent_operations;

struct msdos_sb_info {
	short unsigned int sec_per_clus;
	short unsigned int cluster_bits;
	unsigned int cluster_size;
	unsigned char fats;
	unsigned char fat_bits;
	short unsigned int fat_start;
	long unsigned int fat_length;
	long unsigned int dir_start;
	short unsigned int dir_entries;
	long unsigned int data_start;
	long unsigned int max_cluster;
	long unsigned int root_cluster;
	long unsigned int fsinfo_sector;
	struct mutex fat_lock;
	struct mutex nfs_build_inode_lock;
	struct mutex s_lock;
	unsigned int prev_free;
	unsigned int free_clusters;
	unsigned int free_clus_valid;
	struct fat_mount_options options;
	struct nls_table *nls_disk;
	struct nls_table *nls_io;
	const void *dir_ops;
	int dir_per_block;
	int dir_per_block_bits;
	unsigned int vol_id;
	int fatent_shift;
	const struct fatent_operations *fatent_ops;
	struct inode *fat_inode;
	struct inode *fsinfo_inode;
	struct ratelimit_state ratelimit;
	spinlock_t inode_hash_lock;
	struct hlist_head inode_hashtable[256];
	spinlock_t dir_hash_lock;
	struct hlist_head dir_hashtable[256];
	unsigned int dirty;
	struct callback_head rcu;
};

struct fat_entry;

struct fatent_operations {
	void (*ent_blocknr)(struct super_block *, int, int *, sector_t *);
	void (*ent_set_ptr)(struct fat_entry *, int);
	int (*ent_bread)(struct super_block *, struct fat_entry *, int, sector_t);
	int (*ent_get)(struct fat_entry *);
	void (*ent_put)(struct fat_entry *, int);
	int (*ent_next)(struct fat_entry *);
};

struct msdos_inode_info {
	spinlock_t cache_lru_lock;
	struct list_head cache_lru;
	int nr_caches;
	unsigned int cache_valid_id;
	loff_t mmu_private;
	int i_start;
	int i_logstart;
	int i_attrs;
	loff_t i_pos;
	struct hlist_node i_fat_hash;
	struct hlist_node i_dir_hash;
	struct rw_semaphore truncate_lock;
	struct inode vfs_inode;
};

struct fat_entry {
	int entry;
	union {
		u8 *ent12_p[2];
		__le16 *ent16_p;
		__le32 *ent32_p;
	} u;
	int nr_bhs;
	struct buffer_head *bhs[2];
	struct inode *fat_inode;
};

struct fat_cache {
	struct list_head cache_list;
	int nr_contig;
	int fcluster;
	int dcluster;
};

struct fat_cache_id {
	unsigned int id;
	int nr_contig;
	int fcluster;
	int dcluster;
};

struct compat_dirent {
	u32 d_ino;
	compat_off_t d_off;
	u16 d_reclen;
	char d_name[256];
};

enum utf16_endian {
	UTF16_HOST_ENDIAN = 0,
	UTF16_LITTLE_ENDIAN = 1,
	UTF16_BIG_ENDIAN = 2,
};

struct __fat_dirent {
	long int d_ino;
	__kernel_off_t d_off;
	short unsigned int d_reclen;
	char d_name[256];
};

struct msdos_dir_entry {
	__u8 name[11];
	__u8 attr;
	__u8 lcase;
	__u8 ctime_cs;
	__le16 ctime;
	__le16 cdate;
	__le16 adate;
	__le16 starthi;
	__le16 time;
	__le16 date;
	__le16 start;
	__le32 size;
};

struct msdos_dir_slot {
	__u8 id;
	__u8 name0_4[10];
	__u8 attr;
	__u8 reserved;
	__u8 alias_checksum;
	__u8 name5_10[12];
	__le16 start;
	__u8 name11_12[4];
};

struct fat_slot_info {
	loff_t i_pos;
	loff_t slot_off;
	int nr_slots;
	struct msdos_dir_entry *de;
	struct buffer_head *bh;
};

typedef long long unsigned int llu;

enum {
	PARSE_INVALID = 1,
	PARSE_NOT_LONGNAME = 2,
	PARSE_EOF = 3,
};

struct fat_ioctl_filldir_callback {
	struct dir_context ctx;
	void *dirent;
	int result;
	const char *longname;
	int long_len;
	const char *shortname;
	int short_len;
};

struct fatent_ra {
	sector_t cur;
	sector_t limit;
	unsigned int ra_blocks;
	sector_t ra_advance;
	sector_t ra_next;
	sector_t ra_limit;
};

struct fat_boot_sector {
	__u8 ignored[3];
	__u8 system_id[8];
	__u8 sector_size[2];
	__u8 sec_per_clus;
	__le16 reserved;
	__u8 fats;
	__u8 dir_entries[2];
	__u8 sectors[2];
	__u8 media;
	__le16 fat_length;
	__le16 secs_track;
	__le16 heads;
	__le32 hidden;
	__le32 total_sect;
	union {
		struct {
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat16;
		struct {
			__le32 length;
			__le16 flags;
			__u8 version[2];
			__le32 root_cluster;
			__le16 info_sector;
			__le16 backup_boot;
			__le16 reserved2[6];
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat32;
	};
};

struct fat_boot_fsinfo {
	__le32 signature1;
	__le32 reserved1[120];
	__le32 signature2;
	__le32 free_clusters;
	__le32 next_cluster;
	__le32 reserved2[4];
};

struct fat_bios_param_block {
	u16 fat_sector_size;
	u8 fat_sec_per_clus;
	u16 fat_reserved;
	u8 fat_fats;
	u16 fat_dir_entries;
	u16 fat_sectors;
	u16 fat_fat_length;
	u32 fat_total_sect;
	u8 fat16_state;
	u32 fat16_vol_id;
	u32 fat32_length;
	u32 fat32_root_cluster;
	u16 fat32_info_sector;
	u8 fat32_state;
	u32 fat32_vol_id;
};

struct fat_floppy_defaults {
	unsigned int nr_sectors;
	unsigned int sec_per_clus;
	unsigned int dir_entries;
	unsigned int media;
	unsigned int fat_length;
};

enum {
	Opt_check_n = 0,
	Opt_check_r = 1,
	Opt_check_s = 2,
	Opt_uid___4 = 3,
	Opt_gid___5 = 4,
	Opt_umask = 5,
	Opt_dmask = 6,
	Opt_fmask = 7,
	Opt_allow_utime = 8,
	Opt_codepage = 9,
	Opt_usefree = 10,
	Opt_nocase = 11,
	Opt_quiet = 12,
	Opt_showexec = 13,
	Opt_debug___2 = 14,
	Opt_immutable = 15,
	Opt_dots = 16,
	Opt_nodots = 17,
	Opt_charset = 18,
	Opt_shortname_lower = 19,
	Opt_shortname_win95 = 20,
	Opt_shortname_winnt = 21,
	Opt_shortname_mixed = 22,
	Opt_utf8_no = 23,
	Opt_utf8_yes = 24,
	Opt_uni_xl_no = 25,
	Opt_uni_xl_yes = 26,
	Opt_nonumtail_no = 27,
	Opt_nonumtail_yes = 28,
	Opt_obsolete = 29,
	Opt_flush = 30,
	Opt_tz_utc = 31,
	Opt_rodir = 32,
	Opt_err_cont___2 = 33,
	Opt_err_panic___2 = 34,
	Opt_err_ro___2 = 35,
	Opt_discard___2 = 36,
	Opt_nfs = 37,
	Opt_time_offset = 38,
	Opt_nfs_stale_rw = 39,
	Opt_nfs_nostale_ro = 40,
	Opt_err___3 = 41,
	Opt_dos1xfloppy = 42,
};

struct fat_fid {
	u32 i_gen;
	u32 i_pos_low;
	u16 i_pos_hi;
	u16 parent_i_pos_hi;
	u32 parent_i_pos_low;
	u32 parent_i_gen;
};

struct shortname_info {
	unsigned char lower: 1;
	unsigned char upper: 1;
	unsigned char valid: 1;
};

struct ecryptfs_mount_crypt_stat;

struct ecryptfs_crypt_stat {
	u32 flags;
	unsigned int file_version;
	size_t iv_bytes;
	size_t metadata_size;
	size_t extent_size;
	size_t key_size;
	size_t extent_shift;
	unsigned int extent_mask;
	struct ecryptfs_mount_crypt_stat *mount_crypt_stat;
	struct crypto_skcipher *tfm;
	struct crypto_shash *hash_tfm;
	unsigned char cipher[32];
	unsigned char key[64];
	unsigned char root_iv[16];
	struct list_head keysig_list;
	struct mutex keysig_list_mutex;
	struct mutex cs_tfm_mutex;
	struct mutex cs_mutex;
};

struct ecryptfs_mount_crypt_stat {
	u32 flags;
	struct list_head global_auth_tok_list;
	struct mutex global_auth_tok_list_mutex;
	size_t global_default_cipher_key_size;
	size_t global_default_fn_cipher_key_bytes;
	unsigned char global_default_cipher_name[32];
	unsigned char global_default_fn_cipher_name[32];
	char global_default_fnek_sig[17];
};

struct ecryptfs_inode_info {
	struct inode vfs_inode;
	struct inode *wii_inode;
	struct mutex lower_file_mutex;
	atomic_t lower_file_count;
	struct file *lower_file;
	struct ecryptfs_crypt_stat crypt_stat;
};

struct ecryptfs_dentry_info {
	struct path lower_path;
	struct callback_head rcu;
};

struct ecryptfs_sb_info {
	struct super_block *wsi_sb;
	struct ecryptfs_mount_crypt_stat mount_crypt_stat;
};

struct ecryptfs_file_info {
	struct file *wfi_file;
	struct ecryptfs_crypt_stat *crypt_stat;
};

struct ecryptfs_getdents_callback {
	struct dir_context ctx;
	struct dir_context *caller;
	struct super_block *sb;
	int filldir_called;
	int entries_written;
};

struct ecryptfs_session_key {
	u32 flags;
	u32 encrypted_key_size;
	u32 decrypted_key_size;
	u8 encrypted_key[512];
	u8 decrypted_key[64];
};

struct ecryptfs_password {
	u32 password_bytes;
	s32 hash_algo;
	u32 hash_iterations;
	u32 session_key_encryption_key_bytes;
	u32 flags;
	u8 session_key_encryption_key[64];
	u8 signature[17];
	u8 salt[8];
};

struct ecryptfs_private_key {
	u32 key_size;
	u32 data_len;
	u8 signature[17];
	char pki_type[17];
	u8 data[0];
};

struct ecryptfs_auth_tok {
	u16 version;
	u16 token_type;
	u32 flags;
	struct ecryptfs_session_key session_key;
	u8 reserved[32];
	union {
		struct ecryptfs_password password;
		struct ecryptfs_private_key private_key;
	} token;
};

struct ecryptfs_global_auth_tok {
	u32 flags;
	struct list_head mount_crypt_stat_list;
	struct key *global_auth_tok_key;
	unsigned char sig[17];
};

enum {
	ecryptfs_opt_sig = 0,
	ecryptfs_opt_ecryptfs_sig = 1,
	ecryptfs_opt_cipher = 2,
	ecryptfs_opt_ecryptfs_cipher = 3,
	ecryptfs_opt_ecryptfs_key_bytes = 4,
	ecryptfs_opt_passthrough = 5,
	ecryptfs_opt_xattr_metadata = 6,
	ecryptfs_opt_encrypted_view = 7,
	ecryptfs_opt_fnek_sig = 8,
	ecryptfs_opt_fn_cipher = 9,
	ecryptfs_opt_fn_cipher_key_bytes = 10,
	ecryptfs_opt_unlink_sigs = 11,
	ecryptfs_opt_mount_auth_tok_only = 12,
	ecryptfs_opt_check_dev_ruid = 13,
	ecryptfs_opt_err = 14,
};

struct ecryptfs_cache_info {
	struct kmem_cache **cache;
	const char *name;
	size_t size;
	slab_flags_t flags;
	void (*ctor)(void *);
};

struct ecryptfs_key_sig {
	struct list_head crypt_stat_list;
	char keysig[17];
};

struct ecryptfs_filename {
	struct list_head crypt_stat_list;
	u32 flags;
	u32 seq_no;
	char *filename;
	char *encrypted_filename;
	size_t filename_size;
	size_t encrypted_filename_size;
	char fnek_sig[16];
	char dentry_name[57];
};

struct ecryptfs_key_tfm {
	struct crypto_skcipher *key_tfm;
	size_t key_size;
	struct mutex key_tfm_mutex;
	struct list_head key_tfm_list;
	unsigned char cipher_name[32];
};

struct extent_crypt_result {
	struct completion completion;
	int rc;
};

struct ecryptfs_flag_map_elem {
	u32 file_flag;
	u32 local_flag;
};

struct ecryptfs_cipher_code_str_map_elem {
	char cipher_str[16];
	u8 cipher_code;
};

struct encrypted_key_payload {
	struct callback_head rcu;
	char *format;
	char *master_desc;
	char *datalen;
	u8 *iv;
	u8 *encrypted_data;
	short unsigned int datablob_len;
	short unsigned int decrypted_datalen;
	short unsigned int payload_datalen;
	short unsigned int encrypted_key_format;
	u8 *decrypted_data;
	u8 payload_data[0];
};

enum ecryptfs_token_types {
	ECRYPTFS_PASSWORD = 0,
	ECRYPTFS_PRIVATE_KEY = 1,
};

struct ecryptfs_key_record {
	unsigned char type;
	size_t enc_key_size;
	unsigned char sig[8];
	unsigned char enc_key[512];
};

struct ecryptfs_auth_tok_list_item {
	unsigned char encrypted_session_key[64];
	struct list_head list;
	struct ecryptfs_auth_tok auth_tok;
};

struct ecryptfs_message {
	u32 index;
	u32 data_len;
	u8 data[0];
};

struct ecryptfs_msg_ctx {
	u8 state;
	u8 type;
	u32 index;
	u32 counter;
	size_t msg_size;
	struct ecryptfs_message *msg;
	struct task_struct *task;
	struct list_head node;
	struct list_head daemon_out_list;
	struct mutex mux;
};

struct ecryptfs_write_tag_70_packet_silly_stack {
	u8 cipher_code;
	size_t max_packet_size;
	size_t packet_size_len;
	size_t block_aligned_filename_size;
	size_t block_size;
	size_t i;
	size_t j;
	size_t num_rand_bytes;
	struct mutex *tfm_mutex;
	char *block_aligned_filename;
	struct ecryptfs_auth_tok *auth_tok;
	struct scatterlist src_sg[2];
	struct scatterlist dst_sg[2];
	struct crypto_skcipher *skcipher_tfm;
	struct skcipher_request *skcipher_req;
	char iv[16];
	char hash[16];
	char tmp_hash[16];
	struct crypto_shash *hash_tfm;
	struct shash_desc *hash_desc;
};

struct ecryptfs_parse_tag_70_packet_silly_stack {
	u8 cipher_code;
	size_t max_packet_size;
	size_t packet_size_len;
	size_t parsed_tag_70_packet_size;
	size_t block_aligned_filename_size;
	size_t block_size;
	size_t i;
	struct mutex *tfm_mutex;
	char *decrypted_filename;
	struct ecryptfs_auth_tok *auth_tok;
	struct scatterlist src_sg[2];
	struct scatterlist dst_sg[2];
	struct crypto_skcipher *skcipher_tfm;
	struct skcipher_request *skcipher_req;
	char fnek_sig_hex[17];
	char iv[16];
	char cipher_string[32];
};

struct ecryptfs_open_req {
	struct file **lower_file;
	struct path path;
	struct completion done;
	struct list_head kthread_ctl_list;
};

struct ecryptfs_kthread_ctl {
	u32 flags;
	struct mutex mux;
	struct list_head req_list;
	wait_queue_head_t wait;
};

struct ecryptfs_daemon {
	u32 flags;
	u32 num_queued_msg_ctx;
	struct file *file;
	struct mutex mux;
	struct list_head msg_ctx_out_queue;
	wait_queue_head_t wait;
	struct hlist_node euid_chain;
};

struct getdents_callback___2 {
	struct dir_context ctx;
	char *name;
	u64 ino;
	int found;
	int sequence;
};

typedef u32 unicode_t;

struct utf8_table {
	int cmask;
	int cval;
	int shift;
	long int lmask;
	long int lval;
};

struct utf8data;

struct utf8cursor {
	const struct utf8data *data;
	const char *s;
	const char *p;
	const char *ss;
	const char *sp;
	unsigned int len;
	unsigned int slen;
	short int ccc;
	short int nccc;
	unsigned char hangul[12];
};

struct utf8data {
	unsigned int maxage;
	unsigned int offset;
};

typedef const unsigned char utf8trie_t;

typedef const unsigned char utf8leaf_t;

enum fuse_opcode {
	FUSE_LOOKUP = 1,
	FUSE_FORGET = 2,
	FUSE_GETATTR = 3,
	FUSE_SETATTR = 4,
	FUSE_READLINK = 5,
	FUSE_SYMLINK = 6,
	FUSE_MKNOD = 8,
	FUSE_MKDIR = 9,
	FUSE_UNLINK = 10,
	FUSE_RMDIR = 11,
	FUSE_RENAME = 12,
	FUSE_LINK = 13,
	FUSE_OPEN = 14,
	FUSE_READ = 15,
	FUSE_WRITE = 16,
	FUSE_STATFS = 17,
	FUSE_RELEASE = 18,
	FUSE_FSYNC = 20,
	FUSE_SETXATTR = 21,
	FUSE_GETXATTR = 22,
	FUSE_LISTXATTR = 23,
	FUSE_REMOVEXATTR = 24,
	FUSE_FLUSH = 25,
	FUSE_INIT = 26,
	FUSE_OPENDIR = 27,
	FUSE_READDIR = 28,
	FUSE_RELEASEDIR = 29,
	FUSE_FSYNCDIR = 30,
	FUSE_GETLK = 31,
	FUSE_SETLK = 32,
	FUSE_SETLKW = 33,
	FUSE_ACCESS = 34,
	FUSE_CREATE = 35,
	FUSE_INTERRUPT = 36,
	FUSE_BMAP = 37,
	FUSE_DESTROY = 38,
	FUSE_IOCTL = 39,
	FUSE_POLL = 40,
	FUSE_NOTIFY_REPLY = 41,
	FUSE_BATCH_FORGET = 42,
	FUSE_FALLOCATE = 43,
	FUSE_READDIRPLUS = 44,
	FUSE_RENAME2 = 45,
	FUSE_LSEEK = 46,
	FUSE_COPY_FILE_RANGE = 47,
	FUSE_SETUPMAPPING = 48,
	FUSE_REMOVEMAPPING = 49,
	FUSE_SYNCFS = 50,
	CUSE_INIT = 4096,
	CUSE_INIT_BSWAP_RESERVED = 1048576,
	FUSE_INIT_BSWAP_RESERVED = 436207616,
};

enum fuse_notify_code {
	FUSE_NOTIFY_POLL = 1,
	FUSE_NOTIFY_INVAL_INODE = 2,
	FUSE_NOTIFY_INVAL_ENTRY = 3,
	FUSE_NOTIFY_STORE = 4,
	FUSE_NOTIFY_RETRIEVE = 5,
	FUSE_NOTIFY_DELETE = 6,
	FUSE_NOTIFY_CODE_MAX = 7,
};

struct fuse_forget_in {
	uint64_t nlookup;
};

struct fuse_forget_one {
	uint64_t nodeid;
	uint64_t nlookup;
};

struct fuse_batch_forget_in {
	uint32_t count;
	uint32_t dummy;
};

struct fuse_interrupt_in {
	uint64_t unique;
};

struct fuse_notify_poll_wakeup_out {
	uint64_t kh;
};

struct fuse_in_header {
	uint32_t len;
	uint32_t opcode;
	uint64_t unique;
	uint64_t nodeid;
	uint32_t uid;
	uint32_t gid;
	uint32_t pid;
	uint32_t padding;
};

struct fuse_out_header {
	uint32_t len;
	int32_t error;
	uint64_t unique;
};

struct fuse_notify_inval_inode_out {
	uint64_t ino;
	int64_t off;
	int64_t len;
};

struct fuse_notify_inval_entry_out {
	uint64_t parent;
	uint32_t namelen;
	uint32_t padding;
};

struct fuse_notify_delete_out {
	uint64_t parent;
	uint64_t child;
	uint32_t namelen;
	uint32_t padding;
};

struct fuse_notify_store_out {
	uint64_t nodeid;
	uint64_t offset;
	uint32_t size;
	uint32_t padding;
};

struct fuse_notify_retrieve_out {
	uint64_t notify_unique;
	uint64_t nodeid;
	uint64_t offset;
	uint32_t size;
	uint32_t padding;
};

struct fuse_notify_retrieve_in {
	uint64_t dummy1;
	uint64_t offset;
	uint32_t size;
	uint32_t dummy2;
	uint64_t dummy3;
	uint64_t dummy4;
};

struct fuse_forget_link {
	struct fuse_forget_one forget_one;
	struct fuse_forget_link *next;
};

struct fuse_mount;

struct fuse_release_args;

struct fuse_file {
	struct fuse_mount *fm;
	struct fuse_release_args *release_args;
	u64 kh;
	u64 fh;
	u64 nodeid;
	refcount_t count;
	u32 open_flags;
	struct list_head write_entry;
	struct {
		struct mutex lock;
		loff_t pos;
		loff_t cache_off;
		u64 version;
	} readdir;
	struct rb_node polled_node;
	wait_queue_head_t poll_wait;
	bool flock: 1;
};

struct fuse_conn;

struct fuse_mount {
	struct fuse_conn *fc;
	struct super_block *sb;
	struct list_head fc_entry;
};

struct fuse_in_arg {
	unsigned int size;
	const void *value;
};

struct fuse_arg {
	unsigned int size;
	void *value;
};

struct fuse_page_desc {
	unsigned int length;
	unsigned int offset;
};

struct fuse_args {
	uint64_t nodeid;
	uint32_t opcode;
	short unsigned int in_numargs;
	short unsigned int out_numargs;
	bool force: 1;
	bool noreply: 1;
	bool nocreds: 1;
	bool in_pages: 1;
	bool out_pages: 1;
	bool out_argvar: 1;
	bool page_zeroing: 1;
	bool page_replace: 1;
	bool may_block: 1;
	struct fuse_in_arg in_args[3];
	struct fuse_arg out_args[2];
	void (*end)(struct fuse_mount *, struct fuse_args *, int);
};

struct fuse_args_pages {
	struct fuse_args args;
	struct page **pages;
	struct fuse_page_desc *descs;
	unsigned int num_pages;
};

enum fuse_req_flag {
	FR_ISREPLY = 0,
	FR_FORCE = 1,
	FR_BACKGROUND = 2,
	FR_WAITING = 3,
	FR_ABORTED = 4,
	FR_INTERRUPTED = 5,
	FR_LOCKED = 6,
	FR_PENDING = 7,
	FR_SENT = 8,
	FR_FINISHED = 9,
	FR_PRIVATE = 10,
	FR_ASYNC = 11,
};

struct fuse_req {
	struct list_head list;
	struct list_head intr_entry;
	struct fuse_args *args;
	refcount_t count;
	long unsigned int flags;
	struct {
		struct fuse_in_header h;
	} in;
	struct {
		struct fuse_out_header h;
	} out;
	wait_queue_head_t waitq;
	void *argbuf;
	struct fuse_mount *fm;
};

struct fuse_iqueue;

struct fuse_iqueue_ops {
	void (*wake_forget_and_unlock)(struct fuse_iqueue *);
	void (*wake_interrupt_and_unlock)(struct fuse_iqueue *);
	void (*wake_pending_and_unlock)(struct fuse_iqueue *);
	void (*release)(struct fuse_iqueue *);
};

struct fuse_iqueue {
	unsigned int connected;
	spinlock_t lock;
	wait_queue_head_t waitq;
	u64 reqctr;
	struct list_head pending;
	struct list_head interrupts;
	struct fuse_forget_link forget_list_head;
	struct fuse_forget_link *forget_list_tail;
	int forget_batch;
	struct fasync_struct *fasync;
	const struct fuse_iqueue_ops *ops;
	void *priv;
};

struct fuse_pqueue {
	unsigned int connected;
	spinlock_t lock;
	struct list_head *processing;
	struct list_head io;
};

struct fuse_dev {
	struct fuse_conn *fc;
	struct fuse_pqueue pq;
	struct list_head entry;
};

struct fuse_conn_dax;

struct fuse_sync_bucket;

struct fuse_conn {
	spinlock_t lock;
	refcount_t count;
	atomic_t dev_count;
	struct callback_head rcu;
	kuid_t user_id;
	kgid_t group_id;
	struct pid_namespace *pid_ns;
	struct user_namespace *user_ns;
	unsigned int max_read;
	unsigned int max_write;
	unsigned int max_pages;
	unsigned int max_pages_limit;
	struct fuse_iqueue iq;
	atomic64_t khctr;
	struct rb_root polled_files;
	unsigned int max_background;
	unsigned int congestion_threshold;
	unsigned int num_background;
	unsigned int active_background;
	struct list_head bg_queue;
	spinlock_t bg_lock;
	int initialized;
	int blocked;
	wait_queue_head_t blocked_waitq;
	unsigned int connected;
	bool aborted;
	unsigned int conn_error: 1;
	unsigned int conn_init: 1;
	unsigned int async_read: 1;
	unsigned int abort_err: 1;
	unsigned int atomic_o_trunc: 1;
	unsigned int export_support: 1;
	unsigned int writeback_cache: 1;
	unsigned int parallel_dirops: 1;
	unsigned int handle_killpriv: 1;
	unsigned int cache_symlinks: 1;
	unsigned int legacy_opts_show: 1;
	unsigned int handle_killpriv_v2: 1;
	unsigned int no_open: 1;
	unsigned int no_opendir: 1;
	unsigned int no_fsync: 1;
	unsigned int no_fsyncdir: 1;
	unsigned int no_flush: 1;
	unsigned int no_setxattr: 1;
	unsigned int setxattr_ext: 1;
	unsigned int no_getxattr: 1;
	unsigned int no_listxattr: 1;
	unsigned int no_removexattr: 1;
	unsigned int no_lock: 1;
	unsigned int no_access: 1;
	unsigned int no_create: 1;
	unsigned int no_interrupt: 1;
	unsigned int no_bmap: 1;
	unsigned int no_poll: 1;
	unsigned int big_writes: 1;
	unsigned int dont_mask: 1;
	unsigned int no_flock: 1;
	unsigned int no_fallocate: 1;
	unsigned int no_rename2: 1;
	unsigned int auto_inval_data: 1;
	unsigned int explicit_inval_data: 1;
	unsigned int do_readdirplus: 1;
	unsigned int readdirplus_auto: 1;
	unsigned int async_dio: 1;
	unsigned int no_lseek: 1;
	unsigned int posix_acl: 1;
	unsigned int default_permissions: 1;
	unsigned int allow_other: 1;
	unsigned int no_copy_file_range: 1;
	unsigned int destroy: 1;
	unsigned int delete_stale: 1;
	unsigned int no_control: 1;
	unsigned int no_force_umount: 1;
	unsigned int auto_submounts: 1;
	unsigned int sync_fs: 1;
	atomic_t num_waiting;
	unsigned int minor;
	struct list_head entry;
	dev_t dev;
	struct dentry *ctl_dentry[5];
	int ctl_ndents;
	u32 scramble_key[4];
	atomic64_t attr_version;
	void (*release)(struct fuse_conn *);
	struct rw_semaphore killsb;
	struct list_head devices;
	struct fuse_conn_dax *dax;
	struct list_head mounts;
	struct fuse_sync_bucket *curr_bucket;
};

struct fuse_sync_bucket {
	atomic_t count;
	wait_queue_head_t waitq;
	struct callback_head rcu;
};

struct fuse_copy_state {
	int write;
	struct fuse_req *req;
	struct iov_iter *iter;
	struct pipe_buffer *pipebufs;
	struct pipe_buffer *currbuf;
	struct pipe_inode_info *pipe;
	long unsigned int nr_segs;
	struct page *pg;
	unsigned int len;
	unsigned int offset;
	unsigned int move_pages: 1;
};

struct fuse_retrieve_args {
	struct fuse_args_pages ap;
	struct fuse_notify_retrieve_in inarg;
};

struct fuse_attr {
	uint64_t ino;
	uint64_t size;
	uint64_t blocks;
	uint64_t atime;
	uint64_t mtime;
	uint64_t ctime;
	uint32_t atimensec;
	uint32_t mtimensec;
	uint32_t ctimensec;
	uint32_t mode;
	uint32_t nlink;
	uint32_t uid;
	uint32_t gid;
	uint32_t rdev;
	uint32_t blksize;
	uint32_t flags;
};

struct fuse_entry_out {
	uint64_t nodeid;
	uint64_t generation;
	uint64_t entry_valid;
	uint64_t attr_valid;
	uint32_t entry_valid_nsec;
	uint32_t attr_valid_nsec;
	struct fuse_attr attr;
};

struct fuse_getattr_in {
	uint32_t getattr_flags;
	uint32_t dummy;
	uint64_t fh;
};

struct fuse_attr_out {
	uint64_t attr_valid;
	uint32_t attr_valid_nsec;
	uint32_t dummy;
	struct fuse_attr attr;
};

struct fuse_mknod_in {
	uint32_t mode;
	uint32_t rdev;
	uint32_t umask;
	uint32_t padding;
};

struct fuse_mkdir_in {
	uint32_t mode;
	uint32_t umask;
};

struct fuse_rename2_in {
	uint64_t newdir;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_link_in {
	uint64_t oldnodeid;
};

struct fuse_setattr_in {
	uint32_t valid;
	uint32_t padding;
	uint64_t fh;
	uint64_t size;
	uint64_t lock_owner;
	uint64_t atime;
	uint64_t mtime;
	uint64_t ctime;
	uint32_t atimensec;
	uint32_t mtimensec;
	uint32_t ctimensec;
	uint32_t mode;
	uint32_t unused4;
	uint32_t uid;
	uint32_t gid;
	uint32_t unused5;
};

struct fuse_create_in {
	uint32_t flags;
	uint32_t mode;
	uint32_t umask;
	uint32_t open_flags;
};

struct fuse_open_out {
	uint64_t fh;
	uint32_t open_flags;
	uint32_t padding;
};

struct fuse_access_in {
	uint32_t mask;
	uint32_t padding;
};

struct fuse_inode_dax;

struct fuse_inode {
	struct inode inode;
	u64 nodeid;
	u64 nlookup;
	struct fuse_forget_link *forget;
	u64 i_time;
	u32 inval_mask;
	umode_t orig_i_mode;
	u64 orig_ino;
	u64 attr_version;
	union {
		struct {
			struct list_head write_files;
			struct list_head queued_writes;
			int writectr;
			wait_queue_head_t page_waitq;
			struct rb_root writepages;
		};
		struct {
			bool cached;
			loff_t size;
			loff_t pos;
			u64 version;
			struct timespec64 mtime;
			u64 iversion;
			spinlock_t lock;
		} rdc;
	};
	long unsigned int state;
	struct mutex mutex;
	spinlock_t lock;
	struct rw_semaphore i_mmap_sem;
	struct fuse_inode_dax *dax;
};

enum {
	FUSE_I_ADVISE_RDPLUS = 0,
	FUSE_I_INIT_RDPLUS = 1,
	FUSE_I_SIZE_UNSTABLE = 2,
	FUSE_I_BAD = 3,
};

struct fuse_file_lock {
	uint64_t start;
	uint64_t end;
	uint32_t type;
	uint32_t pid;
};

struct fuse_open_in {
	uint32_t flags;
	uint32_t open_flags;
};

struct fuse_release_in {
	uint64_t fh;
	uint32_t flags;
	uint32_t release_flags;
	uint64_t lock_owner;
};

struct fuse_flush_in {
	uint64_t fh;
	uint32_t unused;
	uint32_t padding;
	uint64_t lock_owner;
};

struct fuse_read_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t size;
	uint32_t read_flags;
	uint64_t lock_owner;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_write_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t size;
	uint32_t write_flags;
	uint64_t lock_owner;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_write_out {
	uint32_t size;
	uint32_t padding;
};

struct fuse_fsync_in {
	uint64_t fh;
	uint32_t fsync_flags;
	uint32_t padding;
};

struct fuse_lk_in {
	uint64_t fh;
	uint64_t owner;
	struct fuse_file_lock lk;
	uint32_t lk_flags;
	uint32_t padding;
};

struct fuse_lk_out {
	struct fuse_file_lock lk;
};

struct fuse_bmap_in {
	uint64_t block;
	uint32_t blocksize;
	uint32_t padding;
};

struct fuse_bmap_out {
	uint64_t block;
};

struct fuse_poll_in {
	uint64_t fh;
	uint64_t kh;
	uint32_t flags;
	uint32_t events;
};

struct fuse_poll_out {
	uint32_t revents;
	uint32_t padding;
};

struct fuse_fallocate_in {
	uint64_t fh;
	uint64_t offset;
	uint64_t length;
	uint32_t mode;
	uint32_t padding;
};

struct fuse_lseek_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t whence;
	uint32_t padding;
};

struct fuse_lseek_out {
	uint64_t offset;
};

struct fuse_copy_file_range_in {
	uint64_t fh_in;
	uint64_t off_in;
	uint64_t nodeid_out;
	uint64_t fh_out;
	uint64_t off_out;
	uint64_t len;
	uint64_t flags;
};

struct fuse_release_args {
	struct fuse_args args;
	struct fuse_release_in inarg;
	struct inode *inode;
};

struct fuse_io_priv {
	struct kref refcnt;
	int async;
	spinlock_t lock;
	unsigned int reqs;
	ssize_t bytes;
	size_t size;
	__u64 offset;
	bool write;
	bool should_dirty;
	int err;
	struct kiocb *iocb;
	struct completion *done;
	bool blocking;
};

struct fuse_io_args {
	union {
		struct {
			struct fuse_read_in in;
			u64 attr_ver;
		} read;
		struct {
			struct fuse_write_in in;
			struct fuse_write_out out;
			bool page_locked;
		} write;
	};
	struct fuse_args_pages ap;
	struct fuse_io_priv *io;
	struct fuse_file *ff;
};

struct fuse_writepage_args {
	struct fuse_io_args ia;
	struct rb_node writepages_entry;
	struct list_head queue_entry;
	struct fuse_writepage_args *next;
	struct inode *inode;
	struct fuse_sync_bucket *bucket;
};

struct fuse_fill_wb_data {
	struct fuse_writepage_args *wpa;
	struct fuse_file *ff;
	struct inode *inode;
	struct page **orig_pages;
	unsigned int max_pages;
};

struct fuse_kstatfs {
	uint64_t blocks;
	uint64_t bfree;
	uint64_t bavail;
	uint64_t files;
	uint64_t ffree;
	uint32_t bsize;
	uint32_t namelen;
	uint32_t frsize;
	uint32_t padding;
	uint32_t spare[6];
};

struct fuse_statfs_out {
	struct fuse_kstatfs st;
};

struct fuse_init_in {
	uint32_t major;
	uint32_t minor;
	uint32_t max_readahead;
	uint32_t flags;
};

struct fuse_init_out {
	uint32_t major;
	uint32_t minor;
	uint32_t max_readahead;
	uint32_t flags;
	uint16_t max_background;
	uint16_t congestion_threshold;
	uint32_t max_write;
	uint32_t time_gran;
	uint16_t max_pages;
	uint16_t map_alignment;
	uint32_t unused[8];
};

struct fuse_syncfs_in {
	uint64_t padding;
};

struct fuse_fs_context {
	int fd;
	unsigned int rootmode;
	kuid_t user_id;
	kgid_t group_id;
	bool is_bdev: 1;
	bool fd_present: 1;
	bool rootmode_present: 1;
	bool user_id_present: 1;
	bool group_id_present: 1;
	bool default_permissions: 1;
	bool allow_other: 1;
	bool destroy: 1;
	bool no_control: 1;
	bool no_force_umount: 1;
	bool legacy_opts_show: 1;
	bool dax: 1;
	unsigned int max_read;
	unsigned int blksize;
	const char *subtype;
	struct dax_device *dax_dev;
	void **fudptr;
};

enum {
	OPT_SOURCE = 0,
	OPT_SUBTYPE = 1,
	OPT_FD = 2,
	OPT_ROOTMODE = 3,
	OPT_USER_ID = 4,
	OPT_GROUP_ID = 5,
	OPT_DEFAULT_PERMISSIONS = 6,
	OPT_ALLOW_OTHER = 7,
	OPT_MAX_READ = 8,
	OPT_BLKSIZE = 9,
	OPT_ERR = 10,
};

struct fuse_inode_handle {
	u64 nodeid;
	u32 generation;
};

struct fuse_init_args {
	struct fuse_args args;
	struct fuse_init_in in;
	struct fuse_init_out out;
};

struct fuse_setxattr_in {
	uint32_t size;
	uint32_t flags;
	uint32_t setxattr_flags;
	uint32_t padding;
};

struct fuse_getxattr_in {
	uint32_t size;
	uint32_t padding;
};

struct fuse_getxattr_out {
	uint32_t size;
	uint32_t padding;
};

struct fuse_dirent {
	uint64_t ino;
	uint64_t off;
	uint32_t namelen;
	uint32_t type;
	char name[0];
};

struct fuse_direntplus {
	struct fuse_entry_out entry_out;
	struct fuse_dirent dirent;
};

enum fuse_parse_result {
	FOUND_ERR = 4294967295,
	FOUND_NONE = 0,
	FOUND_SOME = 1,
	FOUND_ALL = 2,
};

struct fuse_ioctl_in {
	uint64_t fh;
	uint32_t flags;
	uint32_t cmd;
	uint64_t arg;
	uint32_t in_size;
	uint32_t out_size;
};

struct fuse_ioctl_iovec {
	uint64_t base;
	uint64_t len;
};

struct fuse_ioctl_out {
	int32_t result;
	uint32_t flags;
	uint32_t in_iovs;
	uint32_t out_iovs;
};

struct fuse_setupmapping_in {
	uint64_t fh;
	uint64_t foffset;
	uint64_t len;
	uint64_t flags;
	uint64_t moffset;
};

struct fuse_removemapping_in {
	uint32_t count;
};

struct fuse_removemapping_one {
	uint64_t moffset;
	uint64_t len;
};

struct fuse_inode_dax {
	struct rw_semaphore sem;
	struct rb_root_cached tree;
	long unsigned int nr;
};

struct fuse_conn_dax {
	struct dax_device *dev;
	spinlock_t lock;
	long unsigned int nr_busy_ranges;
	struct list_head busy_ranges;
	struct delayed_work free_work;
	wait_queue_head_t range_waitq;
	long int nr_free_ranges;
	struct list_head free_ranges;
	long unsigned int nr_ranges;
};

struct fuse_dax_mapping {
	struct inode *inode;
	struct list_head list;
	struct interval_tree_node itn;
	struct list_head busy_list;
	u64 window_offset;
	loff_t length;
	bool writable;
	refcount_t refcnt;
};

typedef struct vfsmount * (*debugfs_automount_t)(struct dentry *, void *);

struct debugfs_fsdata {
	const struct file_operations *real_fops;
	refcount_t active_users;
	struct completion active_users_drained;
};

struct debugfs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

enum {
	Opt_uid___5 = 0,
	Opt_gid___6 = 1,
	Opt_mode___5 = 2,
	Opt_err___4 = 3,
};

struct debugfs_fs_info {
	struct debugfs_mount_opts mount_opts;
};

struct debugfs_blob_wrapper {
	void *data;
	long unsigned int size;
};

struct debugfs_reg32 {
	char *name;
	long unsigned int offset;
};

struct debugfs_regset32 {
	const struct debugfs_reg32 *regs;
	int nregs;
	void *base;
	struct device *dev;
};

struct debugfs_u32_array {
	u32 *array;
	u32 n_elements;
};

struct debugfs_devm_entry {
	int (*read)(struct seq_file *, void *);
	struct device *dev;
};

struct tracefs_dir_ops {
	int (*mkdir)(const char *);
	int (*rmdir)(const char *);
};

struct tracefs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

struct tracefs_fs_info {
	struct tracefs_mount_opts mount_opts;
};

enum pstore_type_id {
	PSTORE_TYPE_DMESG = 0,
	PSTORE_TYPE_MCE = 1,
	PSTORE_TYPE_CONSOLE = 2,
	PSTORE_TYPE_FTRACE = 3,
	PSTORE_TYPE_PPC_RTAS = 4,
	PSTORE_TYPE_PPC_OF = 5,
	PSTORE_TYPE_PPC_COMMON = 6,
	PSTORE_TYPE_PMSG = 7,
	PSTORE_TYPE_PPC_OPAL = 8,
	PSTORE_TYPE_MAX = 9,
};

struct pstore_info;

struct pstore_record {
	struct pstore_info *psi;
	enum pstore_type_id type;
	u64 id;
	struct timespec64 time;
	char *buf;
	ssize_t size;
	ssize_t ecc_notice_size;
	int count;
	enum kmsg_dump_reason reason;
	unsigned int part;
	bool compressed;
};

struct pstore_info {
	struct module *owner;
	const char *name;
	struct semaphore buf_lock;
	char *buf;
	size_t bufsize;
	struct mutex read_mutex;
	int flags;
	int max_reason;
	void *data;
	int (*open)(struct pstore_info *);
	int (*close)(struct pstore_info *);
	ssize_t (*read)(struct pstore_record *);
	int (*write)(struct pstore_record *);
	int (*write_user)(struct pstore_record *, const char *);
	int (*erase)(struct pstore_record *);
};

struct pstore_ftrace_record {
	long unsigned int ip;
	long unsigned int parent_ip;
	u64 ts;
};

struct pstore_private {
	struct list_head list;
	struct dentry *dentry;
	struct pstore_record *record;
	size_t total_size;
};

struct pstore_ftrace_seq_data {
	const void *ptr;
	size_t off;
	size_t size;
};

enum {
	Opt_kmsg_bytes = 0,
	Opt_err___5 = 1,
};

struct crypto_comp {
	struct crypto_tfm base;
};

struct pstore_zbackend {
	int (*zbufsize)(size_t);
	const char *name;
};

struct efi_variable {
	efi_char16_t VariableName[512];
	efi_guid_t VendorGuid;
	long unsigned int DataSize;
	__u8 Data[1024];
	efi_status_t Status;
	__u32 Attributes;
} __attribute__((packed));

struct efivar_entry {
	struct efi_variable var;
	struct list_head list;
	struct kobject kobj;
	bool scanning;
	bool deleting;
};

typedef s32 compat_key_t;

struct ipc64_perm {
	__kernel_key_t key;
	__kernel_uid32_t uid;
	__kernel_gid32_t gid;
	__kernel_uid32_t cuid;
	__kernel_gid32_t cgid;
	__kernel_mode_t mode;
	unsigned char __pad1[0];
	short unsigned int seq;
	short unsigned int __pad2;
	__kernel_ulong_t __unused1;
	__kernel_ulong_t __unused2;
};

typedef u32 __compat_gid32_t;

struct compat_ipc64_perm {
	compat_key_t key;
	__compat_uid32_t uid;
	__compat_gid32_t gid;
	__compat_uid32_t cuid;
	__compat_gid32_t cgid;
	short unsigned int mode;
	short unsigned int __pad1;
	short unsigned int seq;
	short unsigned int __pad2;
	compat_ulong_t unused1;
	compat_ulong_t unused2;
};

struct compat_ipc_perm {
	key_t key;
	__compat_uid_t uid;
	__compat_gid_t gid;
	__compat_uid_t cuid;
	__compat_gid_t cgid;
	compat_mode_t mode;
	short unsigned int seq;
};

struct ipc_perm {
	__kernel_key_t key;
	__kernel_uid_t uid;
	__kernel_gid_t gid;
	__kernel_uid_t cuid;
	__kernel_gid_t cgid;
	__kernel_mode_t mode;
	short unsigned int seq;
};

struct ipc_params {
	key_t key;
	int flg;
	union {
		size_t size;
		int nsems;
	} u;
};

struct ipc_ops {
	int (*getnew)(struct ipc_namespace *, struct ipc_params *);
	int (*associate)(struct kern_ipc_perm *, int);
	int (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);
};

struct ipc_proc_iface {
	const char *path;
	const char *header;
	int ids;
	int (*show)(struct seq_file *, void *);
};

struct ipc_proc_iter {
	struct ipc_namespace *ns;
	struct pid_namespace *pid_ns;
	struct ipc_proc_iface *iface;
};

struct msg_msgseg;

struct msg_msg {
	struct list_head m_list;
	long int m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

struct msg_msgseg {
	struct msg_msgseg *next;
};

typedef int __kernel_ipc_pid_t;

typedef __kernel_long_t __kernel_old_time_t;

struct msgbuf {
	__kernel_long_t mtype;
	char mtext[1];
};

struct msg;

struct msqid_ds {
	struct ipc_perm msg_perm;
	struct msg *msg_first;
	struct msg *msg_last;
	__kernel_old_time_t msg_stime;
	__kernel_old_time_t msg_rtime;
	__kernel_old_time_t msg_ctime;
	long unsigned int msg_lcbytes;
	long unsigned int msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	__kernel_ipc_pid_t msg_lspid;
	__kernel_ipc_pid_t msg_lrpid;
};

struct msqid64_ds {
	struct ipc64_perm msg_perm;
	long int msg_stime;
	long int msg_rtime;
	long int msg_ctime;
	long unsigned int msg_cbytes;
	long unsigned int msg_qnum;
	long unsigned int msg_qbytes;
	__kernel_pid_t msg_lspid;
	__kernel_pid_t msg_lrpid;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct msginfo {
	int msgpool;
	int msgmap;
	int msgmax;
	int msgmnb;
	int msgmni;
	int msgssz;
	int msgtql;
	short unsigned int msgseg;
};

typedef u16 compat_ipc_pid_t;

struct compat_msqid64_ds {
	struct compat_ipc64_perm msg_perm;
	compat_ulong_t msg_stime;
	compat_ulong_t msg_stime_high;
	compat_ulong_t msg_rtime;
	compat_ulong_t msg_rtime_high;
	compat_ulong_t msg_ctime;
	compat_ulong_t msg_ctime_high;
	compat_ulong_t msg_cbytes;
	compat_ulong_t msg_qnum;
	compat_ulong_t msg_qbytes;
	compat_pid_t msg_lspid;
	compat_pid_t msg_lrpid;
	compat_ulong_t __unused4;
	compat_ulong_t __unused5;
};

struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;
	time64_t q_rtime;
	time64_t q_ctime;
	long unsigned int q_cbytes;
	long unsigned int q_qnum;
	long unsigned int q_qbytes;
	struct pid *q_lspid;
	struct pid *q_lrpid;
	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
	long: 64;
	long: 64;
};

struct msg_receiver {
	struct list_head r_list;
	struct task_struct *r_tsk;
	int r_mode;
	long int r_msgtype;
	long int r_maxsize;
	struct msg_msg *r_msg;
};

struct msg_sender {
	struct list_head list;
	struct task_struct *tsk;
	size_t msgsz;
};

struct compat_msqid_ds {
	struct compat_ipc_perm msg_perm;
	compat_uptr_t msg_first;
	compat_uptr_t msg_last;
	old_time32_t msg_stime;
	old_time32_t msg_rtime;
	old_time32_t msg_ctime;
	compat_ulong_t msg_lcbytes;
	compat_ulong_t msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	compat_ipc_pid_t msg_lspid;
	compat_ipc_pid_t msg_lrpid;
};

struct compat_msgbuf {
	compat_long_t mtype;
	char mtext[1];
};

struct sem;

struct sem_queue;

struct sem_undo;

struct semid_ds {
	struct ipc_perm sem_perm;
	__kernel_old_time_t sem_otime;
	__kernel_old_time_t sem_ctime;
	struct sem *sem_base;
	struct sem_queue *sem_pending;
	struct sem_queue **sem_pending_last;
	struct sem_undo *undo;
	short unsigned int sem_nsems;
};

struct sem {
	int semval;
	struct pid *sempid;
	spinlock_t lock;
	struct list_head pending_alter;
	struct list_head pending_const;
	time64_t sem_otime;
};

struct sembuf;

struct sem_queue {
	struct list_head list;
	struct task_struct *sleeper;
	struct sem_undo *undo;
	struct pid *pid;
	int status;
	struct sembuf *sops;
	struct sembuf *blocking;
	int nsops;
	bool alter;
	bool dupsop;
};

struct sem_undo {
	struct list_head list_proc;
	struct callback_head rcu;
	struct sem_undo_list *ulp;
	struct list_head list_id;
	int semid;
	short int *semadj;
};

struct semid64_ds {
	struct ipc64_perm sem_perm;
	long int sem_otime;
	long int sem_ctime;
	long unsigned int sem_nsems;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct sembuf {
	short unsigned int sem_num;
	short int sem_op;
	short int sem_flg;
};

struct seminfo {
	int semmap;
	int semmni;
	int semmns;
	int semmnu;
	int semmsl;
	int semopm;
	int semume;
	int semusz;
	int semvmx;
	int semaem;
};

struct sem_undo_list {
	refcount_t refcnt;
	spinlock_t lock;
	struct list_head list_proc;
};

struct compat_semid64_ds {
	struct compat_ipc64_perm sem_perm;
	compat_ulong_t sem_otime;
	compat_ulong_t sem_otime_high;
	compat_ulong_t sem_ctime;
	compat_ulong_t sem_ctime_high;
	compat_ulong_t sem_nsems;
	compat_ulong_t __unused3;
	compat_ulong_t __unused4;
};

struct sem_array {
	struct kern_ipc_perm sem_perm;
	time64_t sem_ctime;
	struct list_head pending_alter;
	struct list_head pending_const;
	struct list_head list_id;
	int sem_nsems;
	int complex_count;
	unsigned int use_global_lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sem sems[0];
};

struct compat_semid_ds {
	struct compat_ipc_perm sem_perm;
	old_time32_t sem_otime;
	old_time32_t sem_ctime;
	compat_uptr_t sem_base;
	compat_uptr_t sem_pending;
	compat_uptr_t sem_pending_last;
	compat_uptr_t undo;
	short unsigned int sem_nsems;
};

struct shmid_ds {
	struct ipc_perm shm_perm;
	int shm_segsz;
	__kernel_old_time_t shm_atime;
	__kernel_old_time_t shm_dtime;
	__kernel_old_time_t shm_ctime;
	__kernel_ipc_pid_t shm_cpid;
	__kernel_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	void *shm_unused2;
	void *shm_unused3;
};

struct shmid64_ds {
	struct ipc64_perm shm_perm;
	size_t shm_segsz;
	long int shm_atime;
	long int shm_dtime;
	long int shm_ctime;
	__kernel_pid_t shm_cpid;
	__kernel_pid_t shm_lpid;
	long unsigned int shm_nattch;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct shminfo64 {
	long unsigned int shmmax;
	long unsigned int shmmin;
	long unsigned int shmmni;
	long unsigned int shmseg;
	long unsigned int shmall;
	long unsigned int __unused1;
	long unsigned int __unused2;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct shminfo {
	int shmmax;
	int shmmin;
	int shmmni;
	int shmseg;
	int shmall;
};

struct shm_info {
	int used_ids;
	__kernel_ulong_t shm_tot;
	__kernel_ulong_t shm_rss;
	__kernel_ulong_t shm_swp;
	__kernel_ulong_t swap_attempts;
	__kernel_ulong_t swap_successes;
};

struct compat_shmid64_ds {
	struct compat_ipc64_perm shm_perm;
	compat_size_t shm_segsz;
	compat_ulong_t shm_atime;
	compat_ulong_t shm_atime_high;
	compat_ulong_t shm_dtime;
	compat_ulong_t shm_dtime_high;
	compat_ulong_t shm_ctime;
	compat_ulong_t shm_ctime_high;
	compat_pid_t shm_cpid;
	compat_pid_t shm_lpid;
	compat_ulong_t shm_nattch;
	compat_ulong_t __unused4;
	compat_ulong_t __unused5;
};

struct shmid_kernel {
	struct kern_ipc_perm shm_perm;
	struct file *shm_file;
	long unsigned int shm_nattch;
	long unsigned int shm_segsz;
	time64_t shm_atim;
	time64_t shm_dtim;
	time64_t shm_ctim;
	struct pid *shm_cprid;
	struct pid *shm_lprid;
	struct user_struct *mlock_user;
	struct task_struct *shm_creator;
	struct list_head shm_clist;
	struct ipc_namespace *ns;
	long: 64;
	long: 64;
	long: 64;
};

struct shm_file_data {
	int id;
	struct ipc_namespace *ns;
	struct file *file;
	const struct vm_operations_struct *vm_ops;
};

struct compat_shmid_ds {
	struct compat_ipc_perm shm_perm;
	int shm_segsz;
	old_time32_t shm_atime;
	old_time32_t shm_dtime;
	old_time32_t shm_ctime;
	compat_ipc_pid_t shm_cpid;
	compat_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	compat_uptr_t shm_unused2;
	compat_uptr_t shm_unused3;
};

struct compat_shminfo64 {
	compat_ulong_t shmmax;
	compat_ulong_t shmmin;
	compat_ulong_t shmmni;
	compat_ulong_t shmseg;
	compat_ulong_t shmall;
	compat_ulong_t __unused1;
	compat_ulong_t __unused2;
	compat_ulong_t __unused3;
	compat_ulong_t __unused4;
};

struct compat_shm_info {
	compat_int_t used_ids;
	compat_ulong_t shm_tot;
	compat_ulong_t shm_rss;
	compat_ulong_t shm_swp;
	compat_ulong_t swap_attempts;
	compat_ulong_t swap_successes;
};

struct mqueue_fs_context {
	struct ipc_namespace *ipc_ns;
};

struct posix_msg_tree_node {
	struct rb_node rb_node;
	struct list_head msg_list;
	int priority;
};

struct ext_wait_queue {
	struct task_struct *task;
	struct list_head list;
	struct msg_msg *msg;
	int state;
};

struct mqueue_inode_info {
	spinlock_t lock;
	struct inode vfs_inode;
	wait_queue_head_t wait_q;
	struct rb_root msg_tree;
	struct rb_node *msg_tree_rightmost;
	struct posix_msg_tree_node *node_cache;
	struct mq_attr attr;
	struct sigevent notify;
	struct pid *notify_owner;
	u32 notify_self_exec_id;
	struct user_namespace *notify_user_ns;
	struct user_struct *user;
	struct sock *notify_sock;
	struct sk_buff *notify_cookie;
	struct ext_wait_queue e_wait_q[2];
	long unsigned int qsize;
};

struct compat_mq_attr {
	compat_long_t mq_flags;
	compat_long_t mq_maxmsg;
	compat_long_t mq_msgsize;
	compat_long_t mq_curmsgs;
	compat_long_t __reserved[4];
};

struct key_user {
	struct rb_node node;
	struct mutex cons_lock;
	spinlock_t lock;
	refcount_t usage;
	atomic_t nkeys;
	atomic_t nikeys;
	kuid_t uid;
	int qnkeys;
	int qnbytes;
};

enum key_notification_subtype {
	NOTIFY_KEY_INSTANTIATED = 0,
	NOTIFY_KEY_UPDATED = 1,
	NOTIFY_KEY_LINKED = 2,
	NOTIFY_KEY_UNLINKED = 3,
	NOTIFY_KEY_CLEARED = 4,
	NOTIFY_KEY_REVOKED = 5,
	NOTIFY_KEY_INVALIDATED = 6,
	NOTIFY_KEY_SETATTR = 7,
};

struct key_notification {
	struct watch_notification watch;
	__u32 key_id;
	__u32 aux;
};

struct assoc_array_edit;

struct assoc_array_ops {
	long unsigned int (*get_key_chunk)(const void *, int);
	long unsigned int (*get_object_key_chunk)(const void *, int);
	bool (*compare_object)(const void *, const void *);
	int (*diff_objects)(const void *, const void *);
	void (*free_object)(void *);
};

struct assoc_array_node {
	struct assoc_array_ptr *back_pointer;
	u8 parent_slot;
	struct assoc_array_ptr *slots[16];
	long unsigned int nr_leaves_on_branch;
};

struct assoc_array_shortcut {
	struct assoc_array_ptr *back_pointer;
	int parent_slot;
	int skip_to_level;
	struct assoc_array_ptr *next_node;
	long unsigned int index_key[0];
};

struct assoc_array_edit___2 {
	struct callback_head rcu;
	struct assoc_array *array;
	const struct assoc_array_ops *ops;
	const struct assoc_array_ops *ops_for_excised_subtree;
	struct assoc_array_ptr *leaf;
	struct assoc_array_ptr **leaf_p;
	struct assoc_array_ptr *dead_leaf;
	struct assoc_array_ptr *new_meta[3];
	struct assoc_array_ptr *excised_meta[1];
	struct assoc_array_ptr *excised_subtree;
	struct assoc_array_ptr **set_backpointers[16];
	struct assoc_array_ptr *set_backpointers_to;
	struct assoc_array_node *adjust_count_on;
	long int adjust_count_by;
	struct {
		struct assoc_array_ptr **ptr;
		struct assoc_array_ptr *to;
	} set[2];
	struct {
		u8 *p;
		u8 to;
	} set_parent_slot[1];
	u8 segment_cache[17];
};

struct keyring_search_context {
	struct keyring_index_key index_key;
	const struct cred *cred;
	struct key_match_data match_data;
	unsigned int flags;
	int (*iterator)(const void *, void *);
	int skipped_ret;
	bool possessed;
	key_ref_t result;
	time64_t now;
};

struct keyring_read_iterator_context {
	size_t buflen;
	size_t count;
	key_serial_t *buffer;
};

struct keyctl_dh_params {
	union {
		__s32 private;
		__s32 priv;
	};
	__s32 prime;
	__s32 base;
};

struct keyctl_kdf_params {
	char *hashname;
	char *otherinfo;
	__u32 otherinfolen;
	__u32 __spare[8];
};

struct keyctl_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
	__u32 __spare[10];
};

struct keyctl_pkey_params {
	__s32 key_id;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	__u32 __spare[7];
};

struct request_key_auth {
	struct callback_head rcu;
	struct key *target_key;
	struct key *dest_keyring;
	const struct cred *cred;
	void *callout_info;
	size_t callout_len;
	pid_t pid;
	char op[8];
};

struct compat_keyctl_kdf_params {
	compat_uptr_t hashname;
	compat_uptr_t otherinfo;
	__u32 otherinfolen;
	__u32 __spare[8];
};

struct kpp_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_kpp {
	struct crypto_tfm base;
};

struct kpp_alg {
	int (*set_secret)(struct crypto_kpp *, const void *, unsigned int);
	int (*generate_public_key)(struct kpp_request *);
	int (*compute_shared_secret)(struct kpp_request *);
	unsigned int (*max_size)(struct crypto_kpp *);
	int (*init)(struct crypto_kpp *);
	void (*exit)(struct crypto_kpp *);
	unsigned int reqsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct dh {
	void *key;
	void *p;
	void *q;
	void *g;
	unsigned int key_size;
	unsigned int p_size;
	unsigned int q_size;
	unsigned int g_size;
};

struct dh_completion {
	struct completion completion;
	int err;
};

struct kdf_sdesc {
	struct shash_desc shash;
	char ctx[0];
};

enum {
	Opt_err___6 = 0,
	Opt_enc = 1,
	Opt_hash = 2,
};

enum hash_algo {
	HASH_ALGO_MD4 = 0,
	HASH_ALGO_MD5 = 1,
	HASH_ALGO_SHA1 = 2,
	HASH_ALGO_RIPE_MD_160 = 3,
	HASH_ALGO_SHA256 = 4,
	HASH_ALGO_SHA384 = 5,
	HASH_ALGO_SHA512 = 6,
	HASH_ALGO_SHA224 = 7,
	HASH_ALGO_RIPE_MD_128 = 8,
	HASH_ALGO_RIPE_MD_256 = 9,
	HASH_ALGO_RIPE_MD_320 = 10,
	HASH_ALGO_WP_256 = 11,
	HASH_ALGO_WP_384 = 12,
	HASH_ALGO_WP_512 = 13,
	HASH_ALGO_TGR_128 = 14,
	HASH_ALGO_TGR_160 = 15,
	HASH_ALGO_TGR_192 = 16,
	HASH_ALGO_SM3_256 = 17,
	HASH_ALGO_STREEBOG_256 = 18,
	HASH_ALGO_STREEBOG_512 = 19,
	HASH_ALGO__LAST = 20,
};

enum tpm_duration {
	TPM_SHORT = 0,
	TPM_MEDIUM = 1,
	TPM_LONG = 2,
	TPM_LONG_LONG = 3,
	TPM_UNDEFINED = 4,
	TPM_NUM_DURATIONS = 4,
};

struct trusted_key_payload {
	struct callback_head rcu;
	unsigned int key_len;
	unsigned int blob_len;
	unsigned char migratable;
	unsigned char old_format;
	unsigned char key[129];
	unsigned char blob[512];
};

struct trusted_key_ops {
	unsigned char migratable;
	int (*init)();
	int (*seal)(struct trusted_key_payload *, char *);
	int (*unseal)(struct trusted_key_payload *, char *);
	int (*get_random)(unsigned char *, size_t);
	void (*exit)();
};

struct trusted_key_source {
	char *name;
	struct trusted_key_ops *ops;
};

enum {
	Opt_err___7 = 0,
	Opt_new = 1,
	Opt_load = 2,
	Opt_update = 3,
};

struct hwrng {
	const char *name;
	int (*init)(struct hwrng *);
	void (*cleanup)(struct hwrng *);
	int (*data_present)(struct hwrng *, int);
	int (*data_read)(struct hwrng *, u32 *);
	int (*read)(struct hwrng *, void *, size_t, bool);
	long unsigned int priv;
	short unsigned int quality;
	struct list_head list;
	struct kref ref;
	struct completion cleanup_done;
};

struct tpm_digest {
	u16 alg_id;
	u8 digest[64];
};

struct tpm_bank_info {
	u16 alg_id;
	u16 digest_size;
	u16 crypto_id;
};

struct tpm_chip;

struct tpm_class_ops {
	unsigned int flags;
	const u8 req_complete_mask;
	const u8 req_complete_val;
	bool (*req_canceled)(struct tpm_chip *, u8);
	int (*recv)(struct tpm_chip *, u8 *, size_t);
	int (*send)(struct tpm_chip *, u8 *, size_t);
	void (*cancel)(struct tpm_chip *);
	u8 (*status)(struct tpm_chip *);
	void (*update_timeouts)(struct tpm_chip *, long unsigned int *);
	void (*update_durations)(struct tpm_chip *, long unsigned int *);
	int (*go_idle)(struct tpm_chip *);
	int (*cmd_ready)(struct tpm_chip *);
	int (*request_locality)(struct tpm_chip *, int);
	int (*relinquish_locality)(struct tpm_chip *, int);
	void (*clk_enable)(struct tpm_chip *, bool);
};

struct tpm_bios_log {
	void *bios_event_log;
	void *bios_event_log_end;
};

struct tpm_chip_seqops {
	struct tpm_chip *chip;
	const struct seq_operations *seqops;
};

struct tpm_space {
	u32 context_tbl[3];
	u8 *context_buf;
	u32 session_tbl[3];
	u8 *session_buf;
	u32 buf_size;
};

struct tpm_chip {
	struct device dev;
	struct device devs;
	struct cdev cdev;
	struct cdev cdevs;
	struct rw_semaphore ops_sem;
	const struct tpm_class_ops *ops;
	struct tpm_bios_log log;
	struct tpm_chip_seqops bin_log_seqops;
	struct tpm_chip_seqops ascii_log_seqops;
	unsigned int flags;
	int dev_num;
	long unsigned int is_open;
	char hwrng_name[64];
	struct hwrng hwrng;
	struct mutex tpm_mutex;
	long unsigned int timeout_a;
	long unsigned int timeout_b;
	long unsigned int timeout_c;
	long unsigned int timeout_d;
	bool timeout_adjusted;
	long unsigned int duration[4];
	bool duration_adjusted;
	struct dentry *bios_dir[3];
	const struct attribute_group *groups[8];
	unsigned int groups_cnt;
	u32 nr_allocated_banks;
	struct tpm_bank_info *allocated_banks;
	acpi_handle acpi_dev_handle;
	char ppi_version[4];
	struct tpm_space work_space;
	u32 last_cc;
	u32 nr_commands;
	u32 *cc_attrs_tbl;
	int locality;
};

struct tpm_header {
	__be16 tag;
	__be32 length;
	union {
		__be32 ordinal;
		__be32 return_code;
	};
} __attribute__((packed));

enum tpm_buf_flags {
	TPM_BUF_OVERFLOW = 1,
};

struct tpm_buf {
	unsigned int flags;
	u8 *data;
};

struct trusted_key_options {
	uint16_t keytype;
	uint32_t keyhandle;
	unsigned char keyauth[20];
	uint32_t blobauth_len;
	unsigned char blobauth[20];
	uint32_t pcrinfo_len;
	unsigned char pcrinfo[64];
	int pcrlock;
	uint32_t hash;
	uint32_t policydigest_len;
	unsigned char policydigest[64];
	uint32_t policyhandle;
};

struct osapsess {
	uint32_t handle;
	unsigned char secret[20];
	unsigned char enonce[20];
};

enum {
	SEAL_keytype = 1,
	SRK_keytype = 4,
};

struct sdesc {
	struct shash_desc shash;
	char ctx[0];
};

struct tpm_digests {
	unsigned char encauth[20];
	unsigned char pubauth[20];
	unsigned char xorwork[40];
	unsigned char xorhash[20];
	unsigned char nonceodd[20];
};

enum {
	Opt_err___8 = 0,
	Opt_keyhandle = 1,
	Opt_keyauth = 2,
	Opt_blobauth = 3,
	Opt_pcrinfo = 4,
	Opt_pcrlock = 5,
	Opt_migratable = 6,
	Opt_hash___2 = 7,
	Opt_policydigest = 8,
	Opt_policyhandle = 9,
};

typedef int (*asn1_action_t)(void *, size_t, unsigned char, const void *, size_t);

struct asn1_decoder {
	const unsigned char *machine;
	size_t machlen;
	const asn1_action_t *actions;
};

enum OID {
	OID_id_dsa_with_sha1 = 0,
	OID_id_dsa = 1,
	OID_id_ecPublicKey = 2,
	OID_id_prime192v1 = 3,
	OID_id_prime256v1 = 4,
	OID_id_ecdsa_with_sha1 = 5,
	OID_id_ecdsa_with_sha224 = 6,
	OID_id_ecdsa_with_sha256 = 7,
	OID_id_ecdsa_with_sha384 = 8,
	OID_id_ecdsa_with_sha512 = 9,
	OID_rsaEncryption = 10,
	OID_md2WithRSAEncryption = 11,
	OID_md3WithRSAEncryption = 12,
	OID_md4WithRSAEncryption = 13,
	OID_sha1WithRSAEncryption = 14,
	OID_sha256WithRSAEncryption = 15,
	OID_sha384WithRSAEncryption = 16,
	OID_sha512WithRSAEncryption = 17,
	OID_sha224WithRSAEncryption = 18,
	OID_data = 19,
	OID_signed_data = 20,
	OID_email_address = 21,
	OID_contentType = 22,
	OID_messageDigest = 23,
	OID_signingTime = 24,
	OID_smimeCapabilites = 25,
	OID_smimeAuthenticatedAttrs = 26,
	OID_md2 = 27,
	OID_md4 = 28,
	OID_md5 = 29,
	OID_msIndirectData = 30,
	OID_msStatementType = 31,
	OID_msSpOpusInfo = 32,
	OID_msPeImageDataObjId = 33,
	OID_msIndividualSPKeyPurpose = 34,
	OID_msOutlookExpress = 35,
	OID_certAuthInfoAccess = 36,
	OID_sha1 = 37,
	OID_id_ansip384r1 = 38,
	OID_sha256 = 39,
	OID_sha384 = 40,
	OID_sha512 = 41,
	OID_sha224 = 42,
	OID_commonName = 43,
	OID_surname = 44,
	OID_countryName = 45,
	OID_locality = 46,
	OID_stateOrProvinceName = 47,
	OID_organizationName = 48,
	OID_organizationUnitName = 49,
	OID_title = 50,
	OID_description = 51,
	OID_name = 52,
	OID_givenName = 53,
	OID_initials = 54,
	OID_generationalQualifier = 55,
	OID_subjectKeyIdentifier = 56,
	OID_keyUsage = 57,
	OID_subjectAltName = 58,
	OID_issuerAltName = 59,
	OID_basicConstraints = 60,
	OID_crlDistributionPoints = 61,
	OID_certPolicies = 62,
	OID_authorityKeyIdentifier = 63,
	OID_extKeyUsage = 64,
	OID_gostCPSignA = 65,
	OID_gostCPSignB = 66,
	OID_gostCPSignC = 67,
	OID_gost2012PKey256 = 68,
	OID_gost2012PKey512 = 69,
	OID_gost2012Digest256 = 70,
	OID_gost2012Digest512 = 71,
	OID_gost2012Signature256 = 72,
	OID_gost2012Signature512 = 73,
	OID_gostTC26Sign256A = 74,
	OID_gostTC26Sign256B = 75,
	OID_gostTC26Sign256C = 76,
	OID_gostTC26Sign256D = 77,
	OID_gostTC26Sign512A = 78,
	OID_gostTC26Sign512B = 79,
	OID_gostTC26Sign512C = 80,
	OID_sm2 = 81,
	OID_sm3 = 82,
	OID_SM2_with_SM3 = 83,
	OID_sm3WithRSAEncryption = 84,
	OID_TPMLoadableKey = 85,
	OID_TPMImportableKey = 86,
	OID_TPMSealedData = 87,
	OID__NR = 88,
};

enum tpm_algorithms {
	TPM_ALG_ERROR = 0,
	TPM_ALG_SHA1 = 4,
	TPM_ALG_KEYEDHASH = 8,
	TPM_ALG_SHA256 = 11,
	TPM_ALG_SHA384 = 12,
	TPM_ALG_SHA512 = 13,
	TPM_ALG_NULL = 16,
	TPM_ALG_SM3_256 = 18,
};

enum tpm2_structures {
	TPM2_ST_NO_SESSIONS = 32769,
	TPM2_ST_SESSIONS = 32770,
};

enum tpm2_return_codes {
	TPM2_RC_SUCCESS = 0,
	TPM2_RC_HASH = 131,
	TPM2_RC_HANDLE = 139,
	TPM2_RC_INITIALIZE = 256,
	TPM2_RC_FAILURE = 257,
	TPM2_RC_DISABLED = 288,
	TPM2_RC_COMMAND_CODE = 323,
	TPM2_RC_TESTING = 2314,
	TPM2_RC_REFERENCE_H0 = 2320,
	TPM2_RC_RETRY = 2338,
};

enum tpm2_command_codes {
	TPM2_CC_FIRST = 287,
	TPM2_CC_HIERARCHY_CONTROL = 289,
	TPM2_CC_HIERARCHY_CHANGE_AUTH = 297,
	TPM2_CC_CREATE_PRIMARY = 305,
	TPM2_CC_SEQUENCE_COMPLETE = 318,
	TPM2_CC_SELF_TEST = 323,
	TPM2_CC_STARTUP = 324,
	TPM2_CC_SHUTDOWN = 325,
	TPM2_CC_NV_READ = 334,
	TPM2_CC_CREATE = 339,
	TPM2_CC_LOAD = 343,
	TPM2_CC_SEQUENCE_UPDATE = 348,
	TPM2_CC_UNSEAL = 350,
	TPM2_CC_CONTEXT_LOAD = 353,
	TPM2_CC_CONTEXT_SAVE = 354,
	TPM2_CC_FLUSH_CONTEXT = 357,
	TPM2_CC_VERIFY_SIGNATURE = 375,
	TPM2_CC_GET_CAPABILITY = 378,
	TPM2_CC_GET_RANDOM = 379,
	TPM2_CC_PCR_READ = 382,
	TPM2_CC_PCR_EXTEND = 386,
	TPM2_CC_EVENT_SEQUENCE_COMPLETE = 389,
	TPM2_CC_HASH_SEQUENCE_START = 390,
	TPM2_CC_CREATE_LOADED = 401,
	TPM2_CC_LAST = 403,
};

enum tpm2_permanent_handles {
	TPM2_RS_PW = 1073741833,
};

enum tpm2_object_attributes {
	TPM2_OA_FIXED_TPM = 2,
	TPM2_OA_FIXED_PARENT = 16,
	TPM2_OA_USER_WITH_AUTH = 64,
};

enum tpm2_session_attributes {
	TPM2_SA_CONTINUE_SESSION = 1,
};

struct tpm2_hash {
	unsigned int crypto_id;
	unsigned int tpm_id;
};

struct tpm2_key_context {
	u32 parent;
	const u8 *pub;
	u32 pub_len;
	const u8 *priv;
	u32 priv_len;
};

enum asn1_class {
	ASN1_UNIV = 0,
	ASN1_APPL = 1,
	ASN1_CONT = 2,
	ASN1_PRIV = 3,
};

enum asn1_method {
	ASN1_PRIM = 0,
	ASN1_CONS = 1,
};

enum asn1_tag {
	ASN1_EOC = 0,
	ASN1_BOOL = 1,
	ASN1_INT = 2,
	ASN1_BTS = 3,
	ASN1_OTS = 4,
	ASN1_NULL = 5,
	ASN1_OID = 6,
	ASN1_ODE = 7,
	ASN1_EXT = 8,
	ASN1_REAL = 9,
	ASN1_ENUM = 10,
	ASN1_EPDV = 11,
	ASN1_UTF8STR = 12,
	ASN1_RELOID = 13,
	ASN1_SEQ = 16,
	ASN1_SET = 17,
	ASN1_NUMSTR = 18,
	ASN1_PRNSTR = 19,
	ASN1_TEXSTR = 20,
	ASN1_VIDSTR = 21,
	ASN1_IA5STR = 22,
	ASN1_UNITIM = 23,
	ASN1_GENTIM = 24,
	ASN1_GRASTR = 25,
	ASN1_VISSTR = 26,
	ASN1_GENSTR = 27,
	ASN1_UNISTR = 28,
	ASN1_CHRSTR = 29,
	ASN1_BMPSTR = 30,
	ASN1_LONG_TAG = 31,
};

enum asn1_opcode {
	ASN1_OP_MATCH = 0,
	ASN1_OP_MATCH_OR_SKIP = 1,
	ASN1_OP_MATCH_ACT = 2,
	ASN1_OP_MATCH_ACT_OR_SKIP = 3,
	ASN1_OP_MATCH_JUMP = 4,
	ASN1_OP_MATCH_JUMP_OR_SKIP = 5,
	ASN1_OP_MATCH_ANY = 8,
	ASN1_OP_MATCH_ANY_OR_SKIP = 9,
	ASN1_OP_MATCH_ANY_ACT = 10,
	ASN1_OP_MATCH_ANY_ACT_OR_SKIP = 11,
	ASN1_OP_COND_MATCH_OR_SKIP = 17,
	ASN1_OP_COND_MATCH_ACT_OR_SKIP = 19,
	ASN1_OP_COND_MATCH_JUMP_OR_SKIP = 21,
	ASN1_OP_COND_MATCH_ANY = 24,
	ASN1_OP_COND_MATCH_ANY_OR_SKIP = 25,
	ASN1_OP_COND_MATCH_ANY_ACT = 26,
	ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP = 27,
	ASN1_OP_COND_FAIL = 28,
	ASN1_OP_COMPLETE = 29,
	ASN1_OP_ACT = 30,
	ASN1_OP_MAYBE_ACT = 31,
	ASN1_OP_END_SEQ = 32,
	ASN1_OP_END_SET = 33,
	ASN1_OP_END_SEQ_OF = 34,
	ASN1_OP_END_SET_OF = 35,
	ASN1_OP_END_SEQ_ACT = 36,
	ASN1_OP_END_SET_ACT = 37,
	ASN1_OP_END_SEQ_OF_ACT = 38,
	ASN1_OP_END_SET_OF_ACT = 39,
	ASN1_OP_RETURN = 40,
	ASN1_OP__NR = 41,
};

enum tpm2key_actions {
	ACT_tpm2_key_parent = 0,
	ACT_tpm2_key_priv = 1,
	ACT_tpm2_key_pub = 2,
	ACT_tpm2_key_type = 3,
	NR__tpm2key_actions = 4,
};

enum {
	Opt_new___2 = 0,
	Opt_load___2 = 1,
	Opt_update___2 = 2,
	Opt_err___9 = 3,
};

enum {
	Opt_default = 0,
	Opt_ecryptfs = 1,
	Opt_enc32 = 2,
	Opt_error = 3,
};

enum derived_key_type {
	ENC_KEY = 0,
	AUTH_KEY = 1,
};

struct vfs_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
};

struct vfs_ns_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
	__le32 rootid;
};

struct sctp_endpoint;

struct xfrm_sec_ctx;

struct xfrm_user_sec_ctx;

union security_list_options {
	int (*binder_set_context_mgr)(struct task_struct *);
	int (*binder_transaction)(struct task_struct *, struct task_struct *);
	int (*binder_transfer_binder)(struct task_struct *, struct task_struct *);
	int (*binder_transfer_file)(struct task_struct *, struct task_struct *, struct file *);
	int (*ptrace_access_check)(struct task_struct *, unsigned int);
	int (*ptrace_traceme)(struct task_struct *);
	int (*capget)(struct task_struct *, kernel_cap_t *, kernel_cap_t *, kernel_cap_t *);
	int (*capset)(struct cred *, const struct cred *, const kernel_cap_t *, const kernel_cap_t *, const kernel_cap_t *);
	int (*capable)(const struct cred *, struct user_namespace *, int, unsigned int);
	int (*quotactl)(int, int, int, struct super_block *);
	int (*quota_on)(struct dentry *);
	int (*syslog)(int);
	int (*settime)(const struct timespec64 *, const struct timezone *);
	int (*vm_enough_memory)(struct mm_struct *, long int);
	int (*bprm_creds_for_exec)(struct linux_binprm *);
	int (*bprm_creds_from_file)(struct linux_binprm *, struct file *);
	int (*bprm_check_security)(struct linux_binprm *);
	void (*bprm_committing_creds)(struct linux_binprm *);
	void (*bprm_committed_creds)(struct linux_binprm *);
	int (*fs_context_dup)(struct fs_context *, struct fs_context *);
	int (*fs_context_parse_param)(struct fs_context *, struct fs_parameter *);
	int (*sb_alloc_security)(struct super_block *);
	void (*sb_delete)(struct super_block *);
	void (*sb_free_security)(struct super_block *);
	void (*sb_free_mnt_opts)(void *);
	int (*sb_eat_lsm_opts)(char *, void **);
	int (*sb_mnt_opts_compat)(struct super_block *, void *);
	int (*sb_remount)(struct super_block *, void *);
	int (*sb_kern_mount)(struct super_block *);
	int (*sb_show_options)(struct seq_file *, struct super_block *);
	int (*sb_statfs)(struct dentry *);
	int (*sb_mount)(const char *, const struct path *, const char *, long unsigned int, void *);
	int (*sb_umount)(struct vfsmount *, int);
	int (*sb_pivotroot)(const struct path *, const struct path *);
	int (*sb_set_mnt_opts)(struct super_block *, void *, long unsigned int, long unsigned int *);
	int (*sb_clone_mnt_opts)(const struct super_block *, struct super_block *, long unsigned int, long unsigned int *);
	int (*sb_add_mnt_opt)(const char *, const char *, int, void **);
	int (*move_mount)(const struct path *, const struct path *);
	int (*dentry_init_security)(struct dentry *, int, const struct qstr *, void **, u32 *);
	int (*dentry_create_files_as)(struct dentry *, int, struct qstr *, const struct cred *, struct cred *);
	int (*path_unlink)(const struct path *, struct dentry *);
	int (*path_mkdir)(const struct path *, struct dentry *, umode_t);
	int (*path_rmdir)(const struct path *, struct dentry *);
	int (*path_mknod)(const struct path *, struct dentry *, umode_t, unsigned int);
	int (*path_truncate)(const struct path *);
	int (*path_symlink)(const struct path *, struct dentry *, const char *);
	int (*path_link)(struct dentry *, const struct path *, struct dentry *);
	int (*path_rename)(const struct path *, struct dentry *, const struct path *, struct dentry *);
	int (*path_chmod)(const struct path *, umode_t);
	int (*path_chown)(const struct path *, kuid_t, kgid_t);
	int (*path_chroot)(const struct path *);
	int (*path_notify)(const struct path *, u64, unsigned int);
	int (*inode_alloc_security)(struct inode *);
	void (*inode_free_security)(struct inode *);
	int (*inode_init_security)(struct inode *, struct inode *, const struct qstr *, const char **, void **, size_t *);
	int (*inode_init_security_anon)(struct inode *, const struct qstr *, const struct inode *);
	int (*inode_create)(struct inode *, struct dentry *, umode_t);
	int (*inode_link)(struct dentry *, struct inode *, struct dentry *);
	int (*inode_unlink)(struct inode *, struct dentry *);
	int (*inode_symlink)(struct inode *, struct dentry *, const char *);
	int (*inode_mkdir)(struct inode *, struct dentry *, umode_t);
	int (*inode_rmdir)(struct inode *, struct dentry *);
	int (*inode_mknod)(struct inode *, struct dentry *, umode_t, dev_t);
	int (*inode_rename)(struct inode *, struct dentry *, struct inode *, struct dentry *);
	int (*inode_readlink)(struct dentry *);
	int (*inode_follow_link)(struct dentry *, struct inode *, bool);
	int (*inode_permission)(struct inode *, int);
	int (*inode_setattr)(struct dentry *, struct iattr *);
	int (*inode_getattr)(const struct path *);
	int (*inode_setxattr)(struct user_namespace *, struct dentry *, const char *, const void *, size_t, int);
	void (*inode_post_setxattr)(struct dentry *, const char *, const void *, size_t, int);
	int (*inode_getxattr)(struct dentry *, const char *);
	int (*inode_listxattr)(struct dentry *);
	int (*inode_removexattr)(struct user_namespace *, struct dentry *, const char *);
	int (*inode_need_killpriv)(struct dentry *);
	int (*inode_killpriv)(struct user_namespace *, struct dentry *);
	int (*inode_getsecurity)(struct user_namespace *, struct inode *, const char *, void **, bool);
	int (*inode_setsecurity)(struct inode *, const char *, const void *, size_t, int);
	int (*inode_listsecurity)(struct inode *, char *, size_t);
	void (*inode_getsecid)(struct inode *, u32 *);
	int (*inode_copy_up)(struct dentry *, struct cred **);
	int (*inode_copy_up_xattr)(const char *);
	int (*kernfs_init_security)(struct kernfs_node *, struct kernfs_node *);
	int (*file_permission)(struct file *, int);
	int (*file_alloc_security)(struct file *);
	void (*file_free_security)(struct file *);
	int (*file_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*mmap_addr)(long unsigned int);
	int (*mmap_file)(struct file *, long unsigned int, long unsigned int, long unsigned int);
	int (*file_mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int);
	int (*file_lock)(struct file *, unsigned int);
	int (*file_fcntl)(struct file *, unsigned int, long unsigned int);
	void (*file_set_fowner)(struct file *);
	int (*file_send_sigiotask)(struct task_struct *, struct fown_struct *, int);
	int (*file_receive)(struct file *);
	int (*file_open)(struct file *);
	int (*task_alloc)(struct task_struct *, long unsigned int);
	void (*task_free)(struct task_struct *);
	int (*cred_alloc_blank)(struct cred *, gfp_t);
	void (*cred_free)(struct cred *);
	int (*cred_prepare)(struct cred *, const struct cred *, gfp_t);
	void (*cred_transfer)(struct cred *, const struct cred *);
	void (*cred_getsecid)(const struct cred *, u32 *);
	int (*kernel_act_as)(struct cred *, u32);
	int (*kernel_create_files_as)(struct cred *, struct inode *);
	int (*kernel_module_request)(char *);
	int (*kernel_load_data)(enum kernel_load_data_id, bool);
	int (*kernel_post_load_data)(char *, loff_t, enum kernel_load_data_id, char *);
	int (*kernel_read_file)(struct file *, enum kernel_read_file_id, bool);
	int (*kernel_post_read_file)(struct file *, char *, loff_t, enum kernel_read_file_id);
	int (*task_fix_setuid)(struct cred *, const struct cred *, int);
	int (*task_fix_setgid)(struct cred *, const struct cred *, int);
	int (*task_setpgid)(struct task_struct *, pid_t);
	int (*task_getpgid)(struct task_struct *);
	int (*task_getsid)(struct task_struct *);
	void (*task_getsecid_subj)(struct task_struct *, u32 *);
	void (*task_getsecid_obj)(struct task_struct *, u32 *);
	int (*task_setnice)(struct task_struct *, int);
	int (*task_setioprio)(struct task_struct *, int);
	int (*task_getioprio)(struct task_struct *);
	int (*task_prlimit)(const struct cred *, const struct cred *, unsigned int);
	int (*task_setrlimit)(struct task_struct *, unsigned int, struct rlimit *);
	int (*task_setscheduler)(struct task_struct *);
	int (*task_getscheduler)(struct task_struct *);
	int (*task_movememory)(struct task_struct *);
	int (*task_kill)(struct task_struct *, struct kernel_siginfo *, int, const struct cred *);
	int (*task_prctl)(int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	void (*task_to_inode)(struct task_struct *, struct inode *);
	int (*ipc_permission)(struct kern_ipc_perm *, short int);
	void (*ipc_getsecid)(struct kern_ipc_perm *, u32 *);
	int (*msg_msg_alloc_security)(struct msg_msg *);
	void (*msg_msg_free_security)(struct msg_msg *);
	int (*msg_queue_alloc_security)(struct kern_ipc_perm *);
	void (*msg_queue_free_security)(struct kern_ipc_perm *);
	int (*msg_queue_associate)(struct kern_ipc_perm *, int);
	int (*msg_queue_msgctl)(struct kern_ipc_perm *, int);
	int (*msg_queue_msgsnd)(struct kern_ipc_perm *, struct msg_msg *, int);
	int (*msg_queue_msgrcv)(struct kern_ipc_perm *, struct msg_msg *, struct task_struct *, long int, int);
	int (*shm_alloc_security)(struct kern_ipc_perm *);
	void (*shm_free_security)(struct kern_ipc_perm *);
	int (*shm_associate)(struct kern_ipc_perm *, int);
	int (*shm_shmctl)(struct kern_ipc_perm *, int);
	int (*shm_shmat)(struct kern_ipc_perm *, char *, int);
	int (*sem_alloc_security)(struct kern_ipc_perm *);
	void (*sem_free_security)(struct kern_ipc_perm *);
	int (*sem_associate)(struct kern_ipc_perm *, int);
	int (*sem_semctl)(struct kern_ipc_perm *, int);
	int (*sem_semop)(struct kern_ipc_perm *, struct sembuf *, unsigned int, int);
	int (*netlink_send)(struct sock *, struct sk_buff *);
	void (*d_instantiate)(struct dentry *, struct inode *);
	int (*getprocattr)(struct task_struct *, char *, char **);
	int (*setprocattr)(const char *, void *, size_t);
	int (*ismaclabel)(const char *);
	int (*secid_to_secctx)(u32, char **, u32 *);
	int (*secctx_to_secid)(const char *, u32, u32 *);
	void (*release_secctx)(char *, u32);
	void (*inode_invalidate_secctx)(struct inode *);
	int (*inode_notifysecctx)(struct inode *, void *, u32);
	int (*inode_setsecctx)(struct dentry *, void *, u32);
	int (*inode_getsecctx)(struct inode *, void **, u32 *);
	int (*post_notification)(const struct cred *, const struct cred *, struct watch_notification *);
	int (*watch_key)(struct key *);
	int (*unix_stream_connect)(struct sock *, struct sock *, struct sock *);
	int (*unix_may_send)(struct socket *, struct socket *);
	int (*socket_create)(int, int, int, int);
	int (*socket_post_create)(struct socket *, int, int, int, int);
	int (*socket_socketpair)(struct socket *, struct socket *);
	int (*socket_bind)(struct socket *, struct sockaddr *, int);
	int (*socket_connect)(struct socket *, struct sockaddr *, int);
	int (*socket_listen)(struct socket *, int);
	int (*socket_accept)(struct socket *, struct socket *);
	int (*socket_sendmsg)(struct socket *, struct msghdr *, int);
	int (*socket_recvmsg)(struct socket *, struct msghdr *, int, int);
	int (*socket_getsockname)(struct socket *);
	int (*socket_getpeername)(struct socket *);
	int (*socket_getsockopt)(struct socket *, int, int);
	int (*socket_setsockopt)(struct socket *, int, int);
	int (*socket_shutdown)(struct socket *, int);
	int (*socket_sock_rcv_skb)(struct sock *, struct sk_buff *);
	int (*socket_getpeersec_stream)(struct socket *, char *, int *, unsigned int);
	int (*socket_getpeersec_dgram)(struct socket *, struct sk_buff *, u32 *);
	int (*sk_alloc_security)(struct sock *, int, gfp_t);
	void (*sk_free_security)(struct sock *);
	void (*sk_clone_security)(const struct sock *, struct sock *);
	void (*sk_getsecid)(struct sock *, u32 *);
	void (*sock_graft)(struct sock *, struct socket *);
	int (*inet_conn_request)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*inet_csk_clone)(struct sock *, const struct request_sock *);
	void (*inet_conn_established)(struct sock *, struct sk_buff *);
	int (*secmark_relabel_packet)(u32);
	void (*secmark_refcount_inc)();
	void (*secmark_refcount_dec)();
	void (*req_classify_flow)(const struct request_sock *, struct flowi_common *);
	int (*tun_dev_alloc_security)(void **);
	void (*tun_dev_free_security)(void *);
	int (*tun_dev_create)();
	int (*tun_dev_attach_queue)(void *);
	int (*tun_dev_attach)(struct sock *, void *);
	int (*tun_dev_open)(void *);
	int (*sctp_assoc_request)(struct sctp_endpoint *, struct sk_buff *);
	int (*sctp_bind_connect)(struct sock *, int, struct sockaddr *, int);
	void (*sctp_sk_clone)(struct sctp_endpoint *, struct sock *, struct sock *);
	int (*ib_pkey_access)(void *, u64, u16);
	int (*ib_endport_manage_subnet)(void *, const char *, u8);
	int (*ib_alloc_security)(void **);
	void (*ib_free_security)(void *);
	int (*xfrm_policy_alloc_security)(struct xfrm_sec_ctx **, struct xfrm_user_sec_ctx *, gfp_t);
	int (*xfrm_policy_clone_security)(struct xfrm_sec_ctx *, struct xfrm_sec_ctx **);
	void (*xfrm_policy_free_security)(struct xfrm_sec_ctx *);
	int (*xfrm_policy_delete_security)(struct xfrm_sec_ctx *);
	int (*xfrm_state_alloc)(struct xfrm_state *, struct xfrm_user_sec_ctx *);
	int (*xfrm_state_alloc_acquire)(struct xfrm_state *, struct xfrm_sec_ctx *, u32);
	void (*xfrm_state_free_security)(struct xfrm_state *);
	int (*xfrm_state_delete_security)(struct xfrm_state *);
	int (*xfrm_policy_lookup)(struct xfrm_sec_ctx *, u32, u8);
	int (*xfrm_state_pol_flow_match)(struct xfrm_state *, struct xfrm_policy *, const struct flowi_common *);
	int (*xfrm_decode_session)(struct sk_buff *, u32 *, int);
	int (*key_alloc)(struct key *, const struct cred *, long unsigned int);
	void (*key_free)(struct key *);
	int (*key_permission)(key_ref_t, const struct cred *, enum key_need_perm);
	int (*key_getsecurity)(struct key *, char **);
	int (*audit_rule_init)(u32, u32, char *, void **);
	int (*audit_rule_known)(struct audit_krule *);
	int (*audit_rule_match)(u32, u32, u32, void *);
	void (*audit_rule_free)(void *);
	int (*bpf)(int, union bpf_attr *, unsigned int);
	int (*bpf_map)(struct bpf_map *, fmode_t);
	int (*bpf_prog)(struct bpf_prog *);
	int (*bpf_map_alloc_security)(struct bpf_map *);
	void (*bpf_map_free_security)(struct bpf_map *);
	int (*bpf_prog_alloc_security)(struct bpf_prog_aux *);
	void (*bpf_prog_free_security)(struct bpf_prog_aux *);
	int (*locked_down)(enum lockdown_reason);
	int (*lock_kernel_down)(const char *, enum lockdown_reason);
	int (*perf_event_open)(struct perf_event_attr *, int);
	int (*perf_event_alloc)(struct perf_event *);
	void (*perf_event_free)(struct perf_event *);
	int (*perf_event_read)(struct perf_event *);
	int (*perf_event_write)(struct perf_event *);
};

struct lsm_id {
	const char *lsm;
	int slot;
};

struct security_hook_list {
	struct hlist_node list;
	struct hlist_head *head;
	union security_list_options hook;
	struct lsm_id *lsmid;
};

enum lsm_event {
	LSM_POLICY_CHANGE = 0,
};

typedef int (*initxattrs)(struct inode *, const struct xattr *, void *);

struct xfrm_sec_ctx {
	__u8 ctx_doi;
	__u8 ctx_alg;
	__u16 ctx_len;
	__u32 ctx_sid;
	char ctx_str[0];
};

struct xfrm_user_sec_ctx {
	__u16 len;
	__u16 exttype;
	__u8 ctx_alg;
	__u8 ctx_doi;
	__u16 ctx_len;
};

struct ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_proto;
};

struct ethtool_drvinfo {
	__u32 cmd;
	char driver[32];
	char version[32];
	char fw_version[32];
	char bus_info[32];
	char erom_version[32];
	char reserved2[12];
	__u32 n_priv_flags;
	__u32 n_stats;
	__u32 testinfo_len;
	__u32 eedump_len;
	__u32 regdump_len;
};

struct ethtool_wolinfo {
	__u32 cmd;
	__u32 supported;
	__u32 wolopts;
	__u8 sopass[6];
};

struct ethtool_tunable {
	__u32 cmd;
	__u32 id;
	__u32 type_id;
	__u32 len;
	void *data[0];
};

struct ethtool_regs {
	__u32 cmd;
	__u32 version;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eeprom {
	__u32 cmd;
	__u32 magic;
	__u32 offset;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eee {
	__u32 cmd;
	__u32 supported;
	__u32 advertised;
	__u32 lp_advertised;
	__u32 eee_active;
	__u32 eee_enabled;
	__u32 tx_lpi_enabled;
	__u32 tx_lpi_timer;
	__u32 reserved[2];
};

struct ethtool_modinfo {
	__u32 cmd;
	__u32 type;
	__u32 eeprom_len;
	__u32 reserved[8];
};

struct ethtool_coalesce {
	__u32 cmd;
	__u32 rx_coalesce_usecs;
	__u32 rx_max_coalesced_frames;
	__u32 rx_coalesce_usecs_irq;
	__u32 rx_max_coalesced_frames_irq;
	__u32 tx_coalesce_usecs;
	__u32 tx_max_coalesced_frames;
	__u32 tx_coalesce_usecs_irq;
	__u32 tx_max_coalesced_frames_irq;
	__u32 stats_block_coalesce_usecs;
	__u32 use_adaptive_rx_coalesce;
	__u32 use_adaptive_tx_coalesce;
	__u32 pkt_rate_low;
	__u32 rx_coalesce_usecs_low;
	__u32 rx_max_coalesced_frames_low;
	__u32 tx_coalesce_usecs_low;
	__u32 tx_max_coalesced_frames_low;
	__u32 pkt_rate_high;
	__u32 rx_coalesce_usecs_high;
	__u32 rx_max_coalesced_frames_high;
	__u32 tx_coalesce_usecs_high;
	__u32 tx_max_coalesced_frames_high;
	__u32 rate_sample_interval;
};

struct ethtool_ringparam {
	__u32 cmd;
	__u32 rx_max_pending;
	__u32 rx_mini_max_pending;
	__u32 rx_jumbo_max_pending;
	__u32 tx_max_pending;
	__u32 rx_pending;
	__u32 rx_mini_pending;
	__u32 rx_jumbo_pending;
	__u32 tx_pending;
};

struct ethtool_channels {
	__u32 cmd;
	__u32 max_rx;
	__u32 max_tx;
	__u32 max_other;
	__u32 max_combined;
	__u32 rx_count;
	__u32 tx_count;
	__u32 other_count;
	__u32 combined_count;
};

struct ethtool_pauseparam {
	__u32 cmd;
	__u32 autoneg;
	__u32 rx_pause;
	__u32 tx_pause;
};

enum ethtool_link_ext_state {
	ETHTOOL_LINK_EXT_STATE_AUTONEG = 0,
	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE = 1,
	ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH = 2,
	ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY = 3,
	ETHTOOL_LINK_EXT_STATE_NO_CABLE = 4,
	ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE = 5,
	ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE = 6,
	ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE = 7,
	ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED = 8,
	ETHTOOL_LINK_EXT_STATE_OVERHEAT = 9,
};

enum ethtool_link_ext_substate_autoneg {
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE = 5,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD = 6,
};

enum ethtool_link_ext_substate_link_training {
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT = 4,
};

enum ethtool_link_ext_substate_link_logical_mismatch {
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED = 5,
};

enum ethtool_link_ext_substate_bad_signal_integrity {
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE = 2,
};

enum ethtool_link_ext_substate_cable_issue {
	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE = 2,
};

struct ethtool_test {
	__u32 cmd;
	__u32 flags;
	__u32 reserved;
	__u32 len;
	__u64 data[0];
};

struct ethtool_stats {
	__u32 cmd;
	__u32 n_stats;
	__u64 data[0];
};

struct ethtool_tcpip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be16 psrc;
	__be16 pdst;
	__u8 tos;
};

struct ethtool_ah_espip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 spi;
	__u8 tos;
};

struct ethtool_usrip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 l4_4_bytes;
	__u8 tos;
	__u8 ip_ver;
	__u8 proto;
};

struct ethtool_tcpip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be16 psrc;
	__be16 pdst;
	__u8 tclass;
};

struct ethtool_ah_espip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 spi;
	__u8 tclass;
};

struct ethtool_usrip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 l4_4_bytes;
	__u8 tclass;
	__u8 l4_proto;
};

union ethtool_flow_union {
	struct ethtool_tcpip4_spec tcp_ip4_spec;
	struct ethtool_tcpip4_spec udp_ip4_spec;
	struct ethtool_tcpip4_spec sctp_ip4_spec;
	struct ethtool_ah_espip4_spec ah_ip4_spec;
	struct ethtool_ah_espip4_spec esp_ip4_spec;
	struct ethtool_usrip4_spec usr_ip4_spec;
	struct ethtool_tcpip6_spec tcp_ip6_spec;
	struct ethtool_tcpip6_spec udp_ip6_spec;
	struct ethtool_tcpip6_spec sctp_ip6_spec;
	struct ethtool_ah_espip6_spec ah_ip6_spec;
	struct ethtool_ah_espip6_spec esp_ip6_spec;
	struct ethtool_usrip6_spec usr_ip6_spec;
	struct ethhdr ether_spec;
	__u8 hdata[52];
};

struct ethtool_flow_ext {
	__u8 padding[2];
	unsigned char h_dest[6];
	__be16 vlan_etype;
	__be16 vlan_tci;
	__be32 data[2];
};

struct ethtool_rx_flow_spec {
	__u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	__u64 ring_cookie;
	__u32 location;
};

struct ethtool_rxnfc {
	__u32 cmd;
	__u32 flow_type;
	__u64 data;
	struct ethtool_rx_flow_spec fs;
	union {
		__u32 rule_cnt;
		__u32 rss_context;
	};
	__u32 rule_locs[0];
};

struct ethtool_flash {
	__u32 cmd;
	__u32 region;
	char data[128];
};

struct ethtool_dump {
	__u32 cmd;
	__u32 version;
	__u32 flag;
	__u32 len;
	__u8 data[0];
};

struct ethtool_ts_info {
	__u32 cmd;
	__u32 so_timestamping;
	__s32 phc_index;
	__u32 tx_types;
	__u32 tx_reserved[3];
	__u32 rx_filters;
	__u32 rx_reserved[3];
};

struct ethtool_fecparam {
	__u32 cmd;
	__u32 active_fec;
	__u32 fec;
	__u32 reserved;
};

enum ethtool_link_mode_bit_indices {
	ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
	ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
	ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
	ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
	ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
	ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
	ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
	ETHTOOL_LINK_MODE_TP_BIT = 7,
	ETHTOOL_LINK_MODE_AUI_BIT = 8,
	ETHTOOL_LINK_MODE_MII_BIT = 9,
	ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
	ETHTOOL_LINK_MODE_BNC_BIT = 11,
	ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
	ETHTOOL_LINK_MODE_Pause_BIT = 13,
	ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
	ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
	ETHTOOL_LINK_MODE_Backplane_BIT = 16,
	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,
	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
	ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
	ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
	ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
	ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,
	ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
	ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
	ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
	ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
	ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT = 69,
	ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT = 70,
	ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
	ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT = 72,
	ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT = 73,
	ETHTOOL_LINK_MODE_FEC_LLRS_BIT = 74,
	ETHTOOL_LINK_MODE_100000baseKR_Full_BIT = 75,
	ETHTOOL_LINK_MODE_100000baseSR_Full_BIT = 76,
	ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT = 77,
	ETHTOOL_LINK_MODE_100000baseCR_Full_BIT = 78,
	ETHTOOL_LINK_MODE_100000baseDR_Full_BIT = 79,
	ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT = 80,
	ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT = 81,
	ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT = 82,
	ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT = 83,
	ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT = 84,
	ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT = 85,
	ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT = 86,
	ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT = 87,
	ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT = 88,
	ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT = 89,
	ETHTOOL_LINK_MODE_100baseFX_Half_BIT = 90,
	ETHTOOL_LINK_MODE_100baseFX_Full_BIT = 91,
	__ETHTOOL_LINK_MODE_MASK_NBITS = 92,
};

struct ethtool_link_settings {
	__u32 cmd;
	__u32 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 autoneg;
	__u8 mdio_support;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__s8 link_mode_masks_nwords;
	__u8 transceiver;
	__u8 master_slave_cfg;
	__u8 master_slave_state;
	__u8 reserved1[1];
	__u32 reserved[7];
	__u32 link_mode_masks[0];
};

struct ethtool_link_ext_state_info {
	enum ethtool_link_ext_state link_ext_state;
	union {
		enum ethtool_link_ext_substate_autoneg autoneg;
		enum ethtool_link_ext_substate_link_training link_training;
		enum ethtool_link_ext_substate_link_logical_mismatch link_logical_mismatch;
		enum ethtool_link_ext_substate_bad_signal_integrity bad_signal_integrity;
		enum ethtool_link_ext_substate_cable_issue cable_issue;
		u8 __link_ext_substate;
	};
};

struct ethtool_link_ksettings {
	struct ethtool_link_settings base;
	struct {
		long unsigned int supported[2];
		long unsigned int advertising[2];
		long unsigned int lp_advertising[2];
	} link_modes;
	u32 lanes;
};

struct ethtool_eth_mac_stats {
	u64 FramesTransmittedOK;
	u64 SingleCollisionFrames;
	u64 MultipleCollisionFrames;
	u64 FramesReceivedOK;
	u64 FrameCheckSequenceErrors;
	u64 AlignmentErrors;
	u64 OctetsTransmittedOK;
	u64 FramesWithDeferredXmissions;
	u64 LateCollisions;
	u64 FramesAbortedDueToXSColls;
	u64 FramesLostDueToIntMACXmitError;
	u64 CarrierSenseErrors;
	u64 OctetsReceivedOK;
	u64 FramesLostDueToIntMACRcvError;
	u64 MulticastFramesXmittedOK;
	u64 BroadcastFramesXmittedOK;
	u64 FramesWithExcessiveDeferral;
	u64 MulticastFramesReceivedOK;
	u64 BroadcastFramesReceivedOK;
	u64 InRangeLengthErrors;
	u64 OutOfRangeLengthField;
	u64 FrameTooLongErrors;
};

struct ethtool_eth_phy_stats {
	u64 SymbolErrorDuringCarrier;
};

struct ethtool_eth_ctrl_stats {
	u64 MACControlFramesTransmitted;
	u64 MACControlFramesReceived;
	u64 UnsupportedOpcodesReceived;
};

struct ethtool_pause_stats {
	u64 tx_pause_frames;
	u64 rx_pause_frames;
};

struct ethtool_fec_stat {
	u64 total;
	u64 lanes[8];
};

struct ethtool_fec_stats {
	struct ethtool_fec_stat corrected_blocks;
	struct ethtool_fec_stat uncorrectable_blocks;
	struct ethtool_fec_stat corrected_bits;
};

struct ethtool_rmon_hist_range {
	u16 low;
	u16 high;
};

struct ethtool_rmon_stats {
	u64 undersize_pkts;
	u64 oversize_pkts;
	u64 fragments;
	u64 jabbers;
	u64 hist[10];
	u64 hist_tx[10];
};

struct ethtool_module_eeprom {
	__u32 offset;
	__u32 length;
	__u8 page;
	__u8 bank;
	__u8 i2c_address;
	__u8 *data;
};

enum ib_uverbs_write_cmds {
	IB_USER_VERBS_CMD_GET_CONTEXT = 0,
	IB_USER_VERBS_CMD_QUERY_DEVICE = 1,
	IB_USER_VERBS_CMD_QUERY_PORT = 2,
	IB_USER_VERBS_CMD_ALLOC_PD = 3,
	IB_USER_VERBS_CMD_DEALLOC_PD = 4,
	IB_USER_VERBS_CMD_CREATE_AH = 5,
	IB_USER_VERBS_CMD_MODIFY_AH = 6,
	IB_USER_VERBS_CMD_QUERY_AH = 7,
	IB_USER_VERBS_CMD_DESTROY_AH = 8,
	IB_USER_VERBS_CMD_REG_MR = 9,
	IB_USER_VERBS_CMD_REG_SMR = 10,
	IB_USER_VERBS_CMD_REREG_MR = 11,
	IB_USER_VERBS_CMD_QUERY_MR = 12,
	IB_USER_VERBS_CMD_DEREG_MR = 13,
	IB_USER_VERBS_CMD_ALLOC_MW = 14,
	IB_USER_VERBS_CMD_BIND_MW = 15,
	IB_USER_VERBS_CMD_DEALLOC_MW = 16,
	IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL = 17,
	IB_USER_VERBS_CMD_CREATE_CQ = 18,
	IB_USER_VERBS_CMD_RESIZE_CQ = 19,
	IB_USER_VERBS_CMD_DESTROY_CQ = 20,
	IB_USER_VERBS_CMD_POLL_CQ = 21,
	IB_USER_VERBS_CMD_PEEK_CQ = 22,
	IB_USER_VERBS_CMD_REQ_NOTIFY_CQ = 23,
	IB_USER_VERBS_CMD_CREATE_QP = 24,
	IB_USER_VERBS_CMD_QUERY_QP = 25,
	IB_USER_VERBS_CMD_MODIFY_QP = 26,
	IB_USER_VERBS_CMD_DESTROY_QP = 27,
	IB_USER_VERBS_CMD_POST_SEND = 28,
	IB_USER_VERBS_CMD_POST_RECV = 29,
	IB_USER_VERBS_CMD_ATTACH_MCAST = 30,
	IB_USER_VERBS_CMD_DETACH_MCAST = 31,
	IB_USER_VERBS_CMD_CREATE_SRQ = 32,
	IB_USER_VERBS_CMD_MODIFY_SRQ = 33,
	IB_USER_VERBS_CMD_QUERY_SRQ = 34,
	IB_USER_VERBS_CMD_DESTROY_SRQ = 35,
	IB_USER_VERBS_CMD_POST_SRQ_RECV = 36,
	IB_USER_VERBS_CMD_OPEN_XRCD = 37,
	IB_USER_VERBS_CMD_CLOSE_XRCD = 38,
	IB_USER_VERBS_CMD_CREATE_XSRQ = 39,
	IB_USER_VERBS_CMD_OPEN_QP = 40,
};

enum ib_uverbs_wc_opcode {
	IB_UVERBS_WC_SEND = 0,
	IB_UVERBS_WC_RDMA_WRITE = 1,
	IB_UVERBS_WC_RDMA_READ = 2,
	IB_UVERBS_WC_COMP_SWAP = 3,
	IB_UVERBS_WC_FETCH_ADD = 4,
	IB_UVERBS_WC_BIND_MW = 5,
	IB_UVERBS_WC_LOCAL_INV = 6,
	IB_UVERBS_WC_TSO = 7,
};

enum ib_uverbs_create_qp_mask {
	IB_UVERBS_CREATE_QP_MASK_IND_TABLE = 1,
};

enum ib_uverbs_wr_opcode {
	IB_UVERBS_WR_RDMA_WRITE = 0,
	IB_UVERBS_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_UVERBS_WR_SEND = 2,
	IB_UVERBS_WR_SEND_WITH_IMM = 3,
	IB_UVERBS_WR_RDMA_READ = 4,
	IB_UVERBS_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_UVERBS_WR_LOCAL_INV = 7,
	IB_UVERBS_WR_BIND_MW = 8,
	IB_UVERBS_WR_SEND_WITH_INV = 9,
	IB_UVERBS_WR_TSO = 10,
	IB_UVERBS_WR_RDMA_READ_WITH_INV = 11,
	IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
};

enum ib_uverbs_access_flags {
	IB_UVERBS_ACCESS_LOCAL_WRITE = 1,
	IB_UVERBS_ACCESS_REMOTE_WRITE = 2,
	IB_UVERBS_ACCESS_REMOTE_READ = 4,
	IB_UVERBS_ACCESS_REMOTE_ATOMIC = 8,
	IB_UVERBS_ACCESS_MW_BIND = 16,
	IB_UVERBS_ACCESS_ZERO_BASED = 32,
	IB_UVERBS_ACCESS_ON_DEMAND = 64,
	IB_UVERBS_ACCESS_HUGETLB = 128,
	IB_UVERBS_ACCESS_RELAXED_ORDERING = 1048576,
	IB_UVERBS_ACCESS_OPTIONAL_RANGE = 1072693248,
};

enum ib_uverbs_srq_type {
	IB_UVERBS_SRQT_BASIC = 0,
	IB_UVERBS_SRQT_XRC = 1,
	IB_UVERBS_SRQT_TM = 2,
};

enum ib_uverbs_wq_type {
	IB_UVERBS_WQT_RQ = 0,
};

enum ib_uverbs_wq_flags {
	IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING = 1,
	IB_UVERBS_WQ_FLAGS_SCATTER_FCS = 2,
	IB_UVERBS_WQ_FLAGS_DELAY_DROP = 4,
	IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING = 8,
};

enum ib_uverbs_qp_type {
	IB_UVERBS_QPT_RC = 2,
	IB_UVERBS_QPT_UC = 3,
	IB_UVERBS_QPT_UD = 4,
	IB_UVERBS_QPT_RAW_PACKET = 8,
	IB_UVERBS_QPT_XRC_INI = 9,
	IB_UVERBS_QPT_XRC_TGT = 10,
	IB_UVERBS_QPT_DRIVER = 255,
};

enum ib_uverbs_qp_create_flags {
	IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
	IB_UVERBS_QP_CREATE_SCATTER_FCS = 256,
	IB_UVERBS_QP_CREATE_CVLAN_STRIPPING = 512,
	IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING = 2048,
	IB_UVERBS_QP_CREATE_SQ_SIG_ALL = 4096,
};

enum ib_uverbs_gid_type {
	IB_UVERBS_GID_TYPE_IB = 0,
	IB_UVERBS_GID_TYPE_ROCE_V1 = 1,
	IB_UVERBS_GID_TYPE_ROCE_V2 = 2,
};

union ib_gid {
	u8 raw[16];
	struct {
		__be64 subnet_prefix;
		__be64 interface_id;
	} global;
};

enum ib_poll_context {
	IB_POLL_SOFTIRQ = 0,
	IB_POLL_WORKQUEUE = 1,
	IB_POLL_UNBOUND_WORKQUEUE = 2,
	IB_POLL_LAST_POOL_TYPE = 2,
	IB_POLL_DIRECT = 3,
};

struct lsm_network_audit {
	int netif;
	const struct sock *sk;
	u16 family;
	__be16 dport;
	__be16 sport;
	union {
		struct {
			__be32 daddr;
			__be32 saddr;
		} v4;
		struct {
			struct in6_addr daddr;
			struct in6_addr saddr;
		} v6;
	} fam;
};

struct lsm_ioctlop_audit {
	struct path path;
	u16 cmd;
};

struct lsm_ibpkey_audit {
	u64 subnet_prefix;
	u16 pkey;
};

struct lsm_ibendport_audit {
	char dev_name[64];
	u8 port;
};

struct selinux_state;

struct selinux_audit_data {
	u32 ssid;
	u32 tsid;
	u16 tclass;
	u32 requested;
	u32 audited;
	u32 denied;
	int result;
	struct selinux_state *state;
};

struct smack_audit_data;

struct apparmor_audit_data;

struct common_audit_data {
	char type;
	union {
		struct path path;
		struct dentry *dentry;
		struct inode *inode;
		struct lsm_network_audit *net;
		int cap;
		int ipc_id;
		struct task_struct *tsk;
		struct {
			key_serial_t key;
			char *key_desc;
		} key_struct;
		char *kmod_name;
		struct lsm_ioctlop_audit *op;
		struct file *file;
		struct lsm_ibpkey_audit *ibpkey;
		struct lsm_ibendport_audit *ibendport;
		int reason;
	} u;
	union {
		struct smack_audit_data *smack_audit_data;
		struct selinux_audit_data *selinux_audit_data;
		struct apparmor_audit_data *apparmor_audit_data;
	};
};

enum {
	POLICYDB_CAPABILITY_NETPEER = 0,
	POLICYDB_CAPABILITY_OPENPERM = 1,
	POLICYDB_CAPABILITY_EXTSOCKCLASS = 2,
	POLICYDB_CAPABILITY_ALWAYSNETWORK = 3,
	POLICYDB_CAPABILITY_CGROUPSECLABEL = 4,
	POLICYDB_CAPABILITY_NNP_NOSUID_TRANSITION = 5,
	POLICYDB_CAPABILITY_GENFS_SECLABEL_SYMLINKS = 6,
	__POLICYDB_CAPABILITY_MAX = 7,
};

struct lsm_id___2;

struct selinux_avc;

struct selinux_policy;

struct selinux_state {
	bool enforcing;
	bool checkreqprot;
	bool initialized;
	bool policycap[7];
	struct page *status_page;
	struct mutex status_lock;
	struct selinux_avc *avc;
	struct selinux_policy *policy;
	struct mutex policy_mutex;
};

struct avc_cache {
	struct hlist_head slots[512];
	spinlock_t slots_lock[512];
	atomic_t lru_hint;
	atomic_t active_nodes;
	u32 latest_notif;
};

struct selinux_avc {
	unsigned int avc_cache_threshold;
	struct avc_cache avc_cache;
};

struct av_decision {
	u32 allowed;
	u32 auditallow;
	u32 auditdeny;
	u32 seqno;
	u32 flags;
};

struct extended_perms_data {
	u32 p[8];
};

struct extended_perms_decision {
	u8 used;
	u8 driver;
	struct extended_perms_data *allowed;
	struct extended_perms_data *auditallow;
	struct extended_perms_data *dontaudit;
};

struct extended_perms {
	u16 len;
	struct extended_perms_data drivers;
};

struct avc_cache_stats {
	unsigned int lookups;
	unsigned int misses;
	unsigned int allocations;
	unsigned int reclaims;
	unsigned int frees;
};

struct security_class_mapping {
	const char *name;
	const char *perms[33];
};

struct trace_event_raw_selinux_audited {
	struct trace_entry ent;
	u32 requested;
	u32 denied;
	u32 audited;
	int result;
	u32 __data_loc_scontext;
	u32 __data_loc_tcontext;
	u32 __data_loc_tclass;
	char __data[0];
};

struct trace_event_data_offsets_selinux_audited {
	u32 scontext;
	u32 tcontext;
	u32 tclass;
};

typedef void (*btf_trace_selinux_audited)(void *, struct selinux_audit_data *, char *, char *, const char *);

struct avc_xperms_node;

struct avc_entry {
	u32 ssid;
	u32 tsid;
	u16 tclass;
	struct av_decision avd;
	struct avc_xperms_node *xp_node;
};

struct avc_xperms_node {
	struct extended_perms xp;
	struct list_head xpd_head;
};

struct avc_node {
	struct avc_entry ae;
	struct hlist_node list;
	struct callback_head rhead;
};

struct avc_xperms_decision_node {
	struct extended_perms_decision xpd;
	struct list_head xpd_list;
};

struct avc_callback_node {
	int (*callback)(u32);
	u32 events;
	struct avc_callback_node *next;
};

typedef __u16 __sum16;

typedef u16 u_int16_t;

struct rhltable {
	struct rhashtable ht;
};

enum sctp_endpoint_type {
	SCTP_EP_TYPE_SOCKET = 0,
	SCTP_EP_TYPE_ASSOCIATION = 1,
};

struct sctp_chunk;

struct sctp_inq {
	struct list_head in_chunk_list;
	struct sctp_chunk *in_progress;
	struct work_struct immediate;
};

struct sctp_bind_addr {
	__u16 port;
	struct list_head address_list;
};

struct sctp_ep_common {
	struct hlist_node node;
	int hashent;
	enum sctp_endpoint_type type;
	refcount_t refcnt;
	bool dead;
	struct sock *sk;
	struct net *net;
	struct sctp_inq inqueue;
	struct sctp_bind_addr bind_addr;
};

struct sctp_hmac_algo_param;

struct sctp_chunks_param;

struct sctp_endpoint {
	struct sctp_ep_common base;
	struct list_head asocs;
	__u8 secret_key[32];
	__u8 *digest;
	__u32 sndbuf_policy;
	__u32 rcvbuf_policy;
	struct crypto_shash **auth_hmacs;
	struct sctp_hmac_algo_param *auth_hmacs_list;
	struct sctp_chunks_param *auth_chunk_list;
	struct list_head endpoint_shared_keys;
	__u16 active_key_id;
	__u8 ecn_enable: 1;
	__u8 auth_enable: 1;
	__u8 intl_enable: 1;
	__u8 prsctp_enable: 1;
	__u8 asconf_enable: 1;
	__u8 reconf_enable: 1;
	__u8 strreset_enable;
	u32 secid;
	u32 peer_secid;
	struct callback_head rcu;
};

struct sockaddr_in6 {
	short unsigned int sin6_family;
	__be16 sin6_port;
	__be32 sin6_flowinfo;
	struct in6_addr sin6_addr;
	__u32 sin6_scope_id;
};

enum ip_conntrack_info {
	IP_CT_ESTABLISHED = 0,
	IP_CT_RELATED = 1,
	IP_CT_NEW = 2,
	IP_CT_IS_REPLY = 3,
	IP_CT_ESTABLISHED_REPLY = 3,
	IP_CT_RELATED_REPLY = 4,
	IP_CT_NUMBER = 5,
	IP_CT_UNTRACKED = 7,
};

struct nf_conntrack {
	atomic_t use;
};

struct sockaddr_in {
	__kernel_sa_family_t sin_family;
	__be16 sin_port;
	struct in_addr sin_addr;
	unsigned char __pad[8];
};

struct nf_hook_state;

typedef unsigned int nf_hookfn(void *, struct sk_buff *, const struct nf_hook_state *);

struct nf_hook_entry {
	nf_hookfn *hook;
	void *priv;
};

struct nf_hook_entries {
	u16 num_hook_entries;
	struct nf_hook_entry hooks[0];
};

struct nf_hook_state {
	unsigned int hook;
	u_int8_t pf;
	struct net_device *in;
	struct net_device *out;
	struct sock *sk;
	struct net *net;
	int (*okfn)(struct net *, struct sock *, struct sk_buff *);
};

struct nf_hook_ops {
	nf_hookfn *hook;
	struct net_device *dev;
	void *priv;
	u_int8_t pf;
	unsigned int hooknum;
	int priority;
};

enum nf_nat_manip_type {
	NF_NAT_MANIP_SRC = 0,
	NF_NAT_MANIP_DST = 1,
};

struct nf_conn;

struct nf_nat_hook {
	int (*parse_nat_setup)(struct nf_conn *, enum nf_nat_manip_type, const struct nlattr *);
	void (*decode_session)(struct sk_buff *, struct flowi *);
	unsigned int (*manip_pkt)(struct sk_buff *, struct nf_conn *, enum nf_nat_manip_type, enum ip_conntrack_dir);
};

struct nf_conntrack_zone {
	u16 id;
	u8 flags;
	u8 dir;
};

union nf_inet_addr {
	__u32 all[4];
	__be32 ip;
	__be32 ip6[4];
	struct in_addr in;
	struct in6_addr in6;
};

union nf_conntrack_man_proto {
	__be16 all;
	struct {
		__be16 port;
	} tcp;
	struct {
		__be16 port;
	} udp;
	struct {
		__be16 id;
	} icmp;
	struct {
		__be16 port;
	} dccp;
	struct {
		__be16 port;
	} sctp;
	struct {
		__be16 key;
	} gre;
};

struct nf_conntrack_man {
	union nf_inet_addr u3;
	union nf_conntrack_man_proto u;
	u_int16_t l3num;
};

struct nf_conntrack_tuple {
	struct nf_conntrack_man src;
	struct {
		union nf_inet_addr u3;
		union {
			__be16 all;
			struct {
				__be16 port;
			} tcp;
			struct {
				__be16 port;
			} udp;
			struct {
				u_int8_t type;
				u_int8_t code;
			} icmp;
			struct {
				__be16 port;
			} dccp;
			struct {
				__be16 port;
			} sctp;
			struct {
				__be16 key;
			} gre;
		} u;
		u_int8_t protonum;
		u_int8_t dir;
	} dst;
};

struct nf_conntrack_tuple_hash {
	struct hlist_nulls_node hnnode;
	struct nf_conntrack_tuple tuple;
};

typedef u32 u_int32_t;

typedef u64 u_int64_t;

struct nf_ct_dccp {
	u_int8_t role[2];
	u_int8_t state;
	u_int8_t last_pkt;
	u_int8_t last_dir;
	u_int64_t handshake_seq;
};

struct ip_ct_sctp {
	enum sctp_conntrack state;
	__be32 vtag[2];
	u8 last_dir;
	u8 flags;
};

struct ip_ct_tcp_state {
	u_int32_t td_end;
	u_int32_t td_maxend;
	u_int32_t td_maxwin;
	u_int32_t td_maxack;
	u_int8_t td_scale;
	u_int8_t flags;
};

struct ip_ct_tcp {
	struct ip_ct_tcp_state seen[2];
	u_int8_t state;
	u_int8_t last_dir;
	u_int8_t retrans;
	u_int8_t last_index;
	u_int32_t last_seq;
	u_int32_t last_ack;
	u_int32_t last_end;
	u_int16_t last_win;
	u_int8_t last_wscale;
	u_int8_t last_flags;
};

struct nf_ct_udp {
	long unsigned int stream_ts;
};

struct nf_ct_gre {
	unsigned int stream_timeout;
	unsigned int timeout;
};

union nf_conntrack_proto {
	struct nf_ct_dccp dccp;
	struct ip_ct_sctp sctp;
	struct ip_ct_tcp tcp;
	struct nf_ct_udp udp;
	struct nf_ct_gre gre;
	unsigned int tmpl_padto;
};

struct nf_ct_ext;

struct nf_conn {
	struct nf_conntrack ct_general;
	spinlock_t lock;
	u32 timeout;
	struct nf_conntrack_zone zone;
	struct nf_conntrack_tuple_hash tuplehash[2];
	long unsigned int status;
	u16 cpu;
	possible_net_t ct_net;
	struct hlist_node nat_bysource;
	struct {	} __nfct_init_offset;
	struct nf_conn *master;
	u_int32_t mark;
	u_int32_t secmark;
	struct nf_ct_ext *ext;
	union nf_conntrack_proto proto;
};

struct nf_ct_hook {
	int (*update)(struct net *, struct sk_buff *);
	void (*destroy)(struct nf_conntrack *);
	bool (*get_tuple_skb)(struct nf_conntrack_tuple *, const struct sk_buff *);
};

struct nfnl_ct_hook {
	size_t (*build_size)(const struct nf_conn *);
	int (*build)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, u_int16_t, u_int16_t);
	int (*parse)(const struct nlattr *, struct nf_conn *);
	int (*attach_expect)(const struct nlattr *, struct nf_conn *, u32, u32);
	void (*seq_adjust)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, s32);
};

enum nf_ip_hook_priorities {
	NF_IP_PRI_FIRST = 2147483648,
	NF_IP_PRI_RAW_BEFORE_DEFRAG = 4294966846,
	NF_IP_PRI_CONNTRACK_DEFRAG = 4294966896,
	NF_IP_PRI_RAW = 4294966996,
	NF_IP_PRI_SELINUX_FIRST = 4294967071,
	NF_IP_PRI_CONNTRACK = 4294967096,
	NF_IP_PRI_MANGLE = 4294967146,
	NF_IP_PRI_NAT_DST = 4294967196,
	NF_IP_PRI_FILTER = 0,
	NF_IP_PRI_SECURITY = 50,
	NF_IP_PRI_NAT_SRC = 100,
	NF_IP_PRI_SELINUX_LAST = 225,
	NF_IP_PRI_CONNTRACK_HELPER = 300,
	NF_IP_PRI_CONNTRACK_CONFIRM = 2147483647,
	NF_IP_PRI_LAST = 2147483647,
};

enum nf_ip6_hook_priorities {
	NF_IP6_PRI_FIRST = 2147483648,
	NF_IP6_PRI_RAW_BEFORE_DEFRAG = 4294966846,
	NF_IP6_PRI_CONNTRACK_DEFRAG = 4294966896,
	NF_IP6_PRI_RAW = 4294966996,
	NF_IP6_PRI_SELINUX_FIRST = 4294967071,
	NF_IP6_PRI_CONNTRACK = 4294967096,
	NF_IP6_PRI_MANGLE = 4294967146,
	NF_IP6_PRI_NAT_DST = 4294967196,
	NF_IP6_PRI_FILTER = 0,
	NF_IP6_PRI_SECURITY = 50,
	NF_IP6_PRI_NAT_SRC = 100,
	NF_IP6_PRI_SELINUX_LAST = 225,
	NF_IP6_PRI_CONNTRACK_HELPER = 300,
	NF_IP6_PRI_LAST = 2147483647,
};

struct socket_alloc {
	struct socket socket;
	struct inode vfs_inode;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ip_options {
	__be32 faddr;
	__be32 nexthop;
	unsigned char optlen;
	unsigned char srr;
	unsigned char rr;
	unsigned char ts;
	unsigned char is_strictroute: 1;
	unsigned char srr_is_hit: 1;
	unsigned char is_changed: 1;
	unsigned char rr_needaddr: 1;
	unsigned char ts_needtime: 1;
	unsigned char ts_needaddr: 1;
	unsigned char router_alert;
	unsigned char cipso;
	unsigned char __pad2;
	unsigned char __data[0];
};

struct ip_options_rcu {
	struct callback_head rcu;
	struct ip_options opt;
};

struct ipv6_opt_hdr;

struct ipv6_rt_hdr;

struct ipv6_txoptions {
	refcount_t refcnt;
	int tot_len;
	__u16 opt_flen;
	__u16 opt_nflen;
	struct ipv6_opt_hdr *hopopt;
	struct ipv6_opt_hdr *dst0opt;
	struct ipv6_rt_hdr *srcrt;
	struct ipv6_opt_hdr *dst1opt;
	struct callback_head rcu;
};

struct inet_cork {
	unsigned int flags;
	__be32 addr;
	struct ip_options *opt;
	unsigned int fragsize;
	int length;
	struct dst_entry *dst;
	u8 tx_flags;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
	u64 transmit_time;
	u32 mark;
};

struct inet_cork_full {
	struct inet_cork base;
	struct flowi fl;
};

struct ipv6_pinfo;

struct ip_mc_socklist;

struct inet_sock {
	struct sock sk;
	struct ipv6_pinfo *pinet6;
	__be32 inet_saddr;
	__s16 uc_ttl;
	__u16 cmsg_flags;
	struct ip_options_rcu *inet_opt;
	__be16 inet_sport;
	__u16 inet_id;
	__u8 tos;
	__u8 min_ttl;
	__u8 mc_ttl;
	__u8 pmtudisc;
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 recverr_rfc4884: 1;
	__u8 defer_connect: 1;
	__u8 rcv_tos;
	__u8 convert_csum;
	int uc_index;
	int mc_index;
	__be32 mc_addr;
	struct ip_mc_socklist *mc_list;
	struct inet_cork_full cork;
};

struct in6_pktinfo {
	struct in6_addr ipi6_addr;
	int ipi6_ifindex;
};

struct inet6_cork {
	struct ipv6_txoptions *opt;
	u8 hop_limit;
	u8 tclass;
};

struct ipv6_mc_socklist;

struct ipv6_ac_socklist;

struct ipv6_fl_socklist;

struct ipv6_pinfo {
	struct in6_addr saddr;
	struct in6_pktinfo sticky_pktinfo;
	const struct in6_addr *daddr_cache;
	const struct in6_addr *saddr_cache;
	__be32 flow_label;
	__u32 frag_size;
	__u16 __unused_1: 7;
	__s16 hop_limit: 9;
	__u16 mc_loop: 1;
	__u16 __unused_2: 6;
	__s16 mcast_hops: 9;
	int ucast_oif;
	int mcast_oif;
	union {
		struct {
			__u16 srcrt: 1;
			__u16 osrcrt: 1;
			__u16 rxinfo: 1;
			__u16 rxoinfo: 1;
			__u16 rxhlim: 1;
			__u16 rxohlim: 1;
			__u16 hopopts: 1;
			__u16 ohopopts: 1;
			__u16 dstopts: 1;
			__u16 odstopts: 1;
			__u16 rxflow: 1;
			__u16 rxtclass: 1;
			__u16 rxpmtu: 1;
			__u16 rxorigdstaddr: 1;
			__u16 recvfragsize: 1;
		} bits;
		__u16 all;
	} rxopt;
	__u16 recverr: 1;
	__u16 sndflow: 1;
	__u16 repflow: 1;
	__u16 pmtudisc: 3;
	__u16 padding: 1;
	__u16 srcprefs: 3;
	__u16 dontfrag: 1;
	__u16 autoflowlabel: 1;
	__u16 autoflowlabel_set: 1;
	__u16 mc_all: 1;
	__u16 recverr_rfc4884: 1;
	__u16 rtalert_isolate: 1;
	__u8 min_hopcount;
	__u8 tclass;
	__be32 rcv_flowinfo;
	__u32 dst_cookie;
	struct ipv6_mc_socklist *ipv6_mc_list;
	struct ipv6_ac_socklist *ipv6_ac_list;
	struct ipv6_fl_socklist *ipv6_fl_list;
	struct ipv6_txoptions *opt;
	struct sk_buff *pktoptions;
	struct sk_buff *rxpmtu;
	struct inet6_cork cork;
};

struct tcphdr {
	__be16 source;
	__be16 dest;
	__be32 seq;
	__be32 ack_seq;
	__u16 res1: 4;
	__u16 doff: 4;
	__u16 fin: 1;
	__u16 syn: 1;
	__u16 rst: 1;
	__u16 psh: 1;
	__u16 ack: 1;
	__u16 urg: 1;
	__u16 ece: 1;
	__u16 cwr: 1;
	__be16 window;
	__sum16 check;
	__be16 urg_ptr;
};

struct iphdr {
	__u8 ihl: 4;
	__u8 version: 4;
	__u8 tos;
	__be16 tot_len;
	__be16 id;
	__be16 frag_off;
	__u8 ttl;
	__u8 protocol;
	__sum16 check;
	__be32 saddr;
	__be32 daddr;
};

struct ipv6_rt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
};

struct ipv6_opt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
};

struct ipv6hdr {
	__u8 priority: 4;
	__u8 version: 4;
	__u8 flow_lbl[3];
	__be16 payload_len;
	__u8 nexthdr;
	__u8 hop_limit;
	struct in6_addr saddr;
	struct in6_addr daddr;
};

struct udphdr {
	__be16 source;
	__be16 dest;
	__be16 len;
	__sum16 check;
};

struct inet6_skb_parm {
	int iif;
	__be16 ra;
	__u16 dst0;
	__u16 srcrt;
	__u16 dst1;
	__u16 lastopt;
	__u16 nhoff;
	__u16 flags;
	__u16 dsthao;
	__u16 frag_max_size;
	__u16 srhoff;
};

struct ip6_sf_socklist;

struct ipv6_mc_socklist {
	struct in6_addr addr;
	int ifindex;
	unsigned int sfmode;
	struct ipv6_mc_socklist *next;
	struct ip6_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ipv6_ac_socklist {
	struct in6_addr acl_addr;
	int acl_ifindex;
	struct ipv6_ac_socklist *acl_next;
};

struct ip6_flowlabel;

struct ipv6_fl_socklist {
	struct ipv6_fl_socklist *next;
	struct ip6_flowlabel *fl;
	struct callback_head rcu;
};

struct ip6_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	struct in6_addr sl_addr[0];
};

struct ip6_flowlabel {
	struct ip6_flowlabel *next;
	__be32 label;
	atomic_t users;
	struct in6_addr dst;
	struct ipv6_txoptions *opt;
	long unsigned int linger;
	struct callback_head rcu;
	u8 share;
	union {
		struct pid *pid;
		kuid_t uid;
	} owner;
	long unsigned int lastuse;
	long unsigned int expires;
	struct net *fl_net;
};

struct inet_skb_parm {
	int iif;
	struct ip_options opt;
	u16 flags;
	u16 frag_max_size;
};

struct nf_ipv6_ops {
	void (*route_input)(struct sk_buff *);
	int (*fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	int (*reroute)(struct sk_buff *, const struct nf_queue_entry *);
};

struct nf_queue_entry {
	struct list_head list;
	struct sk_buff *skb;
	unsigned int id;
	unsigned int hook_index;
	struct net_device *physin;
	struct net_device *physout;
	struct nf_hook_state state;
	u16 size;
};

struct tty_file_private {
	struct tty_struct *tty;
	struct file *file;
	struct list_head list;
};

struct icmp_err {
	int errno;
	unsigned int fatal: 1;
};

struct netlbl_lsm_cache {
	refcount_t refcount;
	void (*free)(const void *);
	void *data;
};

struct netlbl_lsm_catmap {
	u32 startbit;
	u64 bitmap[4];
	struct netlbl_lsm_catmap *next;
};

struct netlbl_lsm_secattr {
	u32 flags;
	u32 type;
	char *domain;
	struct netlbl_lsm_cache *cache;
	struct {
		struct {
			struct netlbl_lsm_catmap *cat;
			u32 lvl;
		} mls;
		struct lsmblob lsmblob;
	} attr;
};

struct dccp_hdr {
	__be16 dccph_sport;
	__be16 dccph_dport;
	__u8 dccph_doff;
	__u8 dccph_cscov: 4;
	__u8 dccph_ccval: 4;
	__sum16 dccph_checksum;
	__u8 dccph_x: 1;
	__u8 dccph_type: 4;
	__u8 dccph_reserved: 3;
	__u8 dccph_seq2;
	__be16 dccph_seq;
};

enum dccp_state {
	DCCP_OPEN = 1,
	DCCP_REQUESTING = 2,
	DCCP_LISTEN = 10,
	DCCP_RESPOND = 3,
	DCCP_ACTIVE_CLOSEREQ = 4,
	DCCP_PASSIVE_CLOSE = 8,
	DCCP_CLOSING = 11,
	DCCP_TIME_WAIT = 6,
	DCCP_CLOSED = 7,
	DCCP_NEW_SYN_RECV = 12,
	DCCP_PARTOPEN = 13,
	DCCP_PASSIVE_CLOSEREQ = 14,
	DCCP_MAX_STATES = 15,
};

typedef __s32 sctp_assoc_t;

enum sctp_msg_flags {
	MSG_NOTIFICATION = 32768,
};

struct sctp_initmsg {
	__u16 sinit_num_ostreams;
	__u16 sinit_max_instreams;
	__u16 sinit_max_attempts;
	__u16 sinit_max_init_timeo;
};

struct sctp_sndrcvinfo {
	__u16 sinfo_stream;
	__u16 sinfo_ssn;
	__u16 sinfo_flags;
	__u32 sinfo_ppid;
	__u32 sinfo_context;
	__u32 sinfo_timetolive;
	__u32 sinfo_tsn;
	__u32 sinfo_cumtsn;
	sctp_assoc_t sinfo_assoc_id;
};

struct sctp_rtoinfo {
	sctp_assoc_t srto_assoc_id;
	__u32 srto_initial;
	__u32 srto_max;
	__u32 srto_min;
};

struct sctp_assocparams {
	sctp_assoc_t sasoc_assoc_id;
	__u16 sasoc_asocmaxrxt;
	__u16 sasoc_number_peer_destinations;
	__u32 sasoc_peer_rwnd;
	__u32 sasoc_local_rwnd;
	__u32 sasoc_cookie_life;
};

struct sctp_paddrparams {
	sctp_assoc_t spp_assoc_id;
	struct __kernel_sockaddr_storage spp_address;
	__u32 spp_hbinterval;
	__u16 spp_pathmaxrxt;
	__u32 spp_pathmtu;
	__u32 spp_sackdelay;
	__u32 spp_flags;
	__u32 spp_ipv6_flowlabel;
	__u8 spp_dscp;
	char: 8;
} __attribute__((packed));

struct sctphdr {
	__be16 source;
	__be16 dest;
	__be32 vtag;
	__le32 checksum;
};

struct sctp_chunkhdr {
	__u8 type;
	__u8 flags;
	__be16 length;
};

enum sctp_cid {
	SCTP_CID_DATA = 0,
	SCTP_CID_INIT = 1,
	SCTP_CID_INIT_ACK = 2,
	SCTP_CID_SACK = 3,
	SCTP_CID_HEARTBEAT = 4,
	SCTP_CID_HEARTBEAT_ACK = 5,
	SCTP_CID_ABORT = 6,
	SCTP_CID_SHUTDOWN = 7,
	SCTP_CID_SHUTDOWN_ACK = 8,
	SCTP_CID_ERROR = 9,
	SCTP_CID_COOKIE_ECHO = 10,
	SCTP_CID_COOKIE_ACK = 11,
	SCTP_CID_ECN_ECNE = 12,
	SCTP_CID_ECN_CWR = 13,
	SCTP_CID_SHUTDOWN_COMPLETE = 14,
	SCTP_CID_AUTH = 15,
	SCTP_CID_I_DATA = 64,
	SCTP_CID_FWD_TSN = 192,
	SCTP_CID_ASCONF = 193,
	SCTP_CID_I_FWD_TSN = 194,
	SCTP_CID_ASCONF_ACK = 128,
	SCTP_CID_RECONF = 130,
};

struct sctp_paramhdr {
	__be16 type;
	__be16 length;
};

enum sctp_param {
	SCTP_PARAM_HEARTBEAT_INFO = 256,
	SCTP_PARAM_IPV4_ADDRESS = 1280,
	SCTP_PARAM_IPV6_ADDRESS = 1536,
	SCTP_PARAM_STATE_COOKIE = 1792,
	SCTP_PARAM_UNRECOGNIZED_PARAMETERS = 2048,
	SCTP_PARAM_COOKIE_PRESERVATIVE = 2304,
	SCTP_PARAM_HOST_NAME_ADDRESS = 2816,
	SCTP_PARAM_SUPPORTED_ADDRESS_TYPES = 3072,
	SCTP_PARAM_ECN_CAPABLE = 128,
	SCTP_PARAM_RANDOM = 640,
	SCTP_PARAM_CHUNKS = 896,
	SCTP_PARAM_HMAC_ALGO = 1152,
	SCTP_PARAM_SUPPORTED_EXT = 2176,
	SCTP_PARAM_FWD_TSN_SUPPORT = 192,
	SCTP_PARAM_ADD_IP = 448,
	SCTP_PARAM_DEL_IP = 704,
	SCTP_PARAM_ERR_CAUSE = 960,
	SCTP_PARAM_SET_PRIMARY = 1216,
	SCTP_PARAM_SUCCESS_REPORT = 1472,
	SCTP_PARAM_ADAPTATION_LAYER_IND = 1728,
	SCTP_PARAM_RESET_OUT_REQUEST = 3328,
	SCTP_PARAM_RESET_IN_REQUEST = 3584,
	SCTP_PARAM_RESET_TSN_REQUEST = 3840,
	SCTP_PARAM_RESET_RESPONSE = 4096,
	SCTP_PARAM_RESET_ADD_OUT_STREAMS = 4352,
	SCTP_PARAM_RESET_ADD_IN_STREAMS = 4608,
};

struct sctp_datahdr {
	__be32 tsn;
	__be16 stream;
	__be16 ssn;
	__u32 ppid;
	__u8 payload[0];
};

struct sctp_idatahdr {
	__be32 tsn;
	__be16 stream;
	__be16 reserved;
	__be32 mid;
	union {
		__u32 ppid;
		__be32 fsn;
	};
	__u8 payload[0];
};

struct sctp_inithdr {
	__be32 init_tag;
	__be32 a_rwnd;
	__be16 num_outbound_streams;
	__be16 num_inbound_streams;
	__be32 initial_tsn;
	__u8 params[0];
};

struct sctp_init_chunk {
	struct sctp_chunkhdr chunk_hdr;
	struct sctp_inithdr init_hdr;
};

struct sctp_ipv4addr_param {
	struct sctp_paramhdr param_hdr;
	struct in_addr addr;
};

struct sctp_ipv6addr_param {
	struct sctp_paramhdr param_hdr;
	struct in6_addr addr;
};

struct sctp_cookie_preserve_param {
	struct sctp_paramhdr param_hdr;
	__be32 lifespan_increment;
};

struct sctp_hostname_param {
	struct sctp_paramhdr param_hdr;
	uint8_t hostname[0];
};

struct sctp_supported_addrs_param {
	struct sctp_paramhdr param_hdr;
	__be16 types[0];
};

struct sctp_adaptation_ind_param {
	struct sctp_paramhdr param_hdr;
	__be32 adaptation_ind;
};

struct sctp_supported_ext_param {
	struct sctp_paramhdr param_hdr;
	__u8 chunks[0];
};

struct sctp_random_param {
	struct sctp_paramhdr param_hdr;
	__u8 random_val[0];
};

struct sctp_chunks_param {
	struct sctp_paramhdr param_hdr;
	__u8 chunks[0];
};

struct sctp_hmac_algo_param {
	struct sctp_paramhdr param_hdr;
	__be16 hmac_ids[0];
};

struct sctp_cookie_param {
	struct sctp_paramhdr p;
	__u8 body[0];
};

struct sctp_gap_ack_block {
	__be16 start;
	__be16 end;
};

union sctp_sack_variable {
	struct sctp_gap_ack_block gab;
	__be32 dup;
};

struct sctp_sackhdr {
	__be32 cum_tsn_ack;
	__be32 a_rwnd;
	__be16 num_gap_ack_blocks;
	__be16 num_dup_tsns;
	union sctp_sack_variable variable[0];
};

struct sctp_heartbeathdr {
	struct sctp_paramhdr info;
};

struct sctp_shutdownhdr {
	__be32 cum_tsn_ack;
};

struct sctp_errhdr {
	__be16 cause;
	__be16 length;
	__u8 variable[0];
};

struct sctp_ecnehdr {
	__be32 lowest_tsn;
};

struct sctp_cwrhdr {
	__be32 lowest_tsn;
};

struct sctp_fwdtsn_skip {
	__be16 stream;
	__be16 ssn;
};

struct sctp_fwdtsn_hdr {
	__be32 new_cum_tsn;
	struct sctp_fwdtsn_skip skip[0];
};

struct sctp_ifwdtsn_skip {
	__be16 stream;
	__u8 reserved;
	__u8 flags;
	__be32 mid;
};

struct sctp_ifwdtsn_hdr {
	__be32 new_cum_tsn;
	struct sctp_ifwdtsn_skip skip[0];
};

struct sctp_addip_param {
	struct sctp_paramhdr param_hdr;
	__be32 crr_id;
};

struct sctp_addiphdr {
	__be32 serial;
	__u8 params[0];
};

struct sctp_authhdr {
	__be16 shkey_id;
	__be16 hmac_id;
	__u8 hmac[0];
};

union sctp_addr {
	struct sockaddr_in v4;
	struct sockaddr_in6 v6;
	struct sockaddr sa;
};

struct sctp_cookie {
	__u32 my_vtag;
	__u32 peer_vtag;
	__u32 my_ttag;
	__u32 peer_ttag;
	ktime_t expiration;
	__u16 sinit_num_ostreams;
	__u16 sinit_max_instreams;
	__u32 initial_tsn;
	union sctp_addr peer_addr;
	__u16 my_port;
	__u8 prsctp_capable;
	__u8 padding;
	__u32 adaptation_ind;
	__u8 auth_random[36];
	__u8 auth_hmacs[10];
	__u8 auth_chunks[20];
	__u32 raw_addr_list_len;
	struct sctp_init_chunk peer_init[0];
};

struct sctp_tsnmap {
	long unsigned int *tsn_map;
	__u32 base_tsn;
	__u32 cumulative_tsn_ack_point;
	__u32 max_tsn_seen;
	__u16 len;
	__u16 pending_data;
	__u16 num_dup_tsns;
	__be32 dup_tsns[16];
};

struct sctp_inithdr_host {
	__u32 init_tag;
	__u32 a_rwnd;
	__u16 num_outbound_streams;
	__u16 num_inbound_streams;
	__u32 initial_tsn;
};

enum sctp_state {
	SCTP_STATE_CLOSED = 0,
	SCTP_STATE_COOKIE_WAIT = 1,
	SCTP_STATE_COOKIE_ECHOED = 2,
	SCTP_STATE_ESTABLISHED = 3,
	SCTP_STATE_SHUTDOWN_PENDING = 4,
	SCTP_STATE_SHUTDOWN_SENT = 5,
	SCTP_STATE_SHUTDOWN_RECEIVED = 6,
	SCTP_STATE_SHUTDOWN_ACK_SENT = 7,
};

struct sctp_stream_out_ext;

struct sctp_stream_out {
	union {
		__u32 mid;
		__u16 ssn;
	};
	__u32 mid_uo;
	struct sctp_stream_out_ext *ext;
	__u8 state;
};

struct sctp_stream_in {
	union {
		__u32 mid;
		__u16 ssn;
	};
	__u32 mid_uo;
	__u32 fsn;
	__u32 fsn_uo;
	char pd_mode;
	char pd_mode_uo;
};

struct sctp_stream_interleave;

struct sctp_stream {
	struct {
		struct __genradix tree;
		struct sctp_stream_out type[0];
	} out;
	struct {
		struct __genradix tree;
		struct sctp_stream_in type[0];
	} in;
	__u16 outcnt;
	__u16 incnt;
	struct sctp_stream_out *out_curr;
	union {
		struct {
			struct list_head prio_list;
		};
		struct {
			struct list_head rr_list;
			struct sctp_stream_out_ext *rr_next;
		};
	};
	struct sctp_stream_interleave *si;
};

struct sctp_sched_ops;

struct sctp_association;

struct sctp_outq {
	struct sctp_association *asoc;
	struct list_head out_chunk_list;
	struct sctp_sched_ops *sched;
	unsigned int out_qlen;
	unsigned int error;
	struct list_head control_chunk_list;
	struct list_head sacked;
	struct list_head retransmit;
	struct list_head abandoned;
	__u32 outstanding_bytes;
	char fast_rtx;
	char cork;
};

struct sctp_ulpq {
	char pd_mode;
	struct sctp_association *asoc;
	struct sk_buff_head reasm;
	struct sk_buff_head reasm_uo;
	struct sk_buff_head lobby;
};

struct sctp_priv_assoc_stats {
	struct __kernel_sockaddr_storage obs_rto_ipaddr;
	__u64 max_obs_rto;
	__u64 isacks;
	__u64 osacks;
	__u64 opackets;
	__u64 ipackets;
	__u64 rtxchunks;
	__u64 outofseqtsns;
	__u64 idupchunks;
	__u64 gapcnt;
	__u64 ouodchunks;
	__u64 iuodchunks;
	__u64 oodchunks;
	__u64 iodchunks;
	__u64 octrlchunks;
	__u64 ictrlchunks;
};

struct sctp_transport;

struct sctp_auth_bytes;

struct sctp_shared_key;

struct sctp_association {
	struct sctp_ep_common base;
	struct list_head asocs;
	sctp_assoc_t assoc_id;
	struct sctp_endpoint *ep;
	struct sctp_cookie c;
	struct {
		struct list_head transport_addr_list;
		__u32 rwnd;
		__u16 transport_count;
		__u16 port;
		struct sctp_transport *primary_path;
		union sctp_addr primary_addr;
		struct sctp_transport *active_path;
		struct sctp_transport *retran_path;
		struct sctp_transport *last_sent_to;
		struct sctp_transport *last_data_from;
		struct sctp_tsnmap tsn_map;
		__be16 addip_disabled_mask;
		__u16 ecn_capable: 1;
		__u16 ipv4_address: 1;
		__u16 ipv6_address: 1;
		__u16 hostname_address: 1;
		__u16 asconf_capable: 1;
		__u16 prsctp_capable: 1;
		__u16 reconf_capable: 1;
		__u16 intl_capable: 1;
		__u16 auth_capable: 1;
		__u16 sack_needed: 1;
		__u16 sack_generation: 1;
		__u16 zero_window_announced: 1;
		__u32 sack_cnt;
		__u32 adaptation_ind;
		struct sctp_inithdr_host i;
		void *cookie;
		int cookie_len;
		__u32 addip_serial;
		struct sctp_random_param *peer_random;
		struct sctp_chunks_param *peer_chunks;
		struct sctp_hmac_algo_param *peer_hmacs;
	} peer;
	enum sctp_state state;
	int overall_error_count;
	ktime_t cookie_life;
	long unsigned int rto_initial;
	long unsigned int rto_max;
	long unsigned int rto_min;
	int max_burst;
	int max_retrans;
	__u16 pf_retrans;
	__u16 ps_retrans;
	__u16 max_init_attempts;
	__u16 init_retries;
	long unsigned int max_init_timeo;
	long unsigned int hbinterval;
	__be16 encap_port;
	__u16 pathmaxrxt;
	__u32 flowlabel;
	__u8 dscp;
	__u8 pmtu_pending;
	__u32 pathmtu;
	__u32 param_flags;
	__u32 sackfreq;
	long unsigned int sackdelay;
	long unsigned int timeouts[11];
	struct timer_list timers[11];
	struct sctp_transport *shutdown_last_sent_to;
	struct sctp_transport *init_last_sent_to;
	int shutdown_retries;
	__u32 next_tsn;
	__u32 ctsn_ack_point;
	__u32 adv_peer_ack_point;
	__u32 highest_sacked;
	__u32 fast_recovery_exit;
	__u8 fast_recovery;
	__u16 unack_data;
	__u32 rtx_data_chunks;
	__u32 rwnd;
	__u32 a_rwnd;
	__u32 rwnd_over;
	__u32 rwnd_press;
	int sndbuf_used;
	atomic_t rmem_alloc;
	wait_queue_head_t wait;
	__u32 frag_point;
	__u32 user_frag;
	int init_err_counter;
	int init_cycle;
	__u16 default_stream;
	__u16 default_flags;
	__u32 default_ppid;
	__u32 default_context;
	__u32 default_timetolive;
	__u32 default_rcv_context;
	struct sctp_stream stream;
	struct sctp_outq outqueue;
	struct sctp_ulpq ulpq;
	__u32 last_ecne_tsn;
	__u32 last_cwr_tsn;
	int numduptsns;
	struct sctp_chunk *addip_last_asconf;
	struct list_head asconf_ack_list;
	struct list_head addip_chunk_list;
	__u32 addip_serial;
	int src_out_of_asoc_ok;
	union sctp_addr *asconf_addr_del_pending;
	struct sctp_transport *new_transport;
	struct list_head endpoint_shared_keys;
	struct sctp_auth_bytes *asoc_shared_key;
	struct sctp_shared_key *shkey;
	__u16 default_hmac_id;
	__u16 active_key_id;
	__u8 need_ecne: 1;
	__u8 temp: 1;
	__u8 pf_expose: 2;
	__u8 force_delay: 1;
	__u8 strreset_enable;
	__u8 strreset_outstanding;
	__u32 strreset_outseq;
	__u32 strreset_inseq;
	__u32 strreset_result[2];
	struct sctp_chunk *strreset_chunk;
	struct sctp_priv_assoc_stats stats;
	int sent_cnt_removable;
	__u16 subscribe;
	__u64 abandoned_unsent[3];
	__u64 abandoned_sent[3];
	struct callback_head rcu;
};

struct sctp_auth_bytes {
	refcount_t refcnt;
	__u32 len;
	__u8 data[0];
};

struct sctp_shared_key {
	struct list_head key_list;
	struct sctp_auth_bytes *key;
	refcount_t refcnt;
	__u16 key_id;
	__u8 deactivated;
};

enum {
	SCTP_MAX_STREAM = 65535,
};

enum sctp_event_timeout {
	SCTP_EVENT_TIMEOUT_NONE = 0,
	SCTP_EVENT_TIMEOUT_T1_COOKIE = 1,
	SCTP_EVENT_TIMEOUT_T1_INIT = 2,
	SCTP_EVENT_TIMEOUT_T2_SHUTDOWN = 3,
	SCTP_EVENT_TIMEOUT_T3_RTX = 4,
	SCTP_EVENT_TIMEOUT_T4_RTO = 5,
	SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD = 6,
	SCTP_EVENT_TIMEOUT_HEARTBEAT = 7,
	SCTP_EVENT_TIMEOUT_RECONF = 8,
	SCTP_EVENT_TIMEOUT_SACK = 9,
	SCTP_EVENT_TIMEOUT_AUTOCLOSE = 10,
};

enum {
	SCTP_MAX_DUP_TSNS = 16,
};

enum sctp_scope {
	SCTP_SCOPE_GLOBAL = 0,
	SCTP_SCOPE_PRIVATE = 1,
	SCTP_SCOPE_LINK = 2,
	SCTP_SCOPE_LOOPBACK = 3,
	SCTP_SCOPE_UNUSABLE = 4,
};

enum {
	SCTP_AUTH_HMAC_ID_RESERVED_0 = 0,
	SCTP_AUTH_HMAC_ID_SHA1 = 1,
	SCTP_AUTH_HMAC_ID_RESERVED_2 = 2,
	SCTP_AUTH_HMAC_ID_SHA256 = 3,
	__SCTP_AUTH_HMAC_MAX = 4,
};

struct sctp_ulpevent {
	struct sctp_association *asoc;
	struct sctp_chunk *chunk;
	unsigned int rmem_len;
	union {
		__u32 mid;
		__u16 ssn;
	};
	union {
		__u32 ppid;
		__u32 fsn;
	};
	__u32 tsn;
	__u32 cumtsn;
	__u16 stream;
	__u16 flags;
	__u16 msg_flags;
} __attribute__((packed));

union sctp_addr_param;

union sctp_params {
	void *v;
	struct sctp_paramhdr *p;
	struct sctp_cookie_preserve_param *life;
	struct sctp_hostname_param *dns;
	struct sctp_cookie_param *cookie;
	struct sctp_supported_addrs_param *sat;
	struct sctp_ipv4addr_param *v4;
	struct sctp_ipv6addr_param *v6;
	union sctp_addr_param *addr;
	struct sctp_adaptation_ind_param *aind;
	struct sctp_supported_ext_param *ext;
	struct sctp_random_param *random;
	struct sctp_chunks_param *chunks;
	struct sctp_hmac_algo_param *hmac_algo;
	struct sctp_addip_param *addip;
};

struct sctp_sender_hb_info;

struct sctp_signed_cookie;

struct sctp_datamsg;

struct sctp_chunk {
	struct list_head list;
	refcount_t refcnt;
	int sent_count;
	union {
		struct list_head transmitted_list;
		struct list_head stream_list;
	};
	struct list_head frag_list;
	struct sk_buff *skb;
	union {
		struct sk_buff *head_skb;
		struct sctp_shared_key *shkey;
	};
	union sctp_params param_hdr;
	union {
		__u8 *v;
		struct sctp_datahdr *data_hdr;
		struct sctp_inithdr *init_hdr;
		struct sctp_sackhdr *sack_hdr;
		struct sctp_heartbeathdr *hb_hdr;
		struct sctp_sender_hb_info *hbs_hdr;
		struct sctp_shutdownhdr *shutdown_hdr;
		struct sctp_signed_cookie *cookie_hdr;
		struct sctp_ecnehdr *ecne_hdr;
		struct sctp_cwrhdr *ecn_cwr_hdr;
		struct sctp_errhdr *err_hdr;
		struct sctp_addiphdr *addip_hdr;
		struct sctp_fwdtsn_hdr *fwdtsn_hdr;
		struct sctp_authhdr *auth_hdr;
		struct sctp_idatahdr *idata_hdr;
		struct sctp_ifwdtsn_hdr *ifwdtsn_hdr;
	} subh;
	__u8 *chunk_end;
	struct sctp_chunkhdr *chunk_hdr;
	struct sctphdr *sctp_hdr;
	struct sctp_sndrcvinfo sinfo;
	struct sctp_association *asoc;
	struct sctp_ep_common *rcvr;
	long unsigned int sent_at;
	union sctp_addr source;
	union sctp_addr dest;
	struct sctp_datamsg *msg;
	struct sctp_transport *transport;
	struct sk_buff *auth_chunk;
	__u16 rtt_in_progress: 1;
	__u16 has_tsn: 1;
	__u16 has_ssn: 1;
	__u16 singleton: 1;
	__u16 end_of_packet: 1;
	__u16 ecn_ce_done: 1;
	__u16 pdiscard: 1;
	__u16 tsn_gap_acked: 1;
	__u16 data_accepted: 1;
	__u16 auth: 1;
	__u16 has_asconf: 1;
	__u16 tsn_missing_report: 2;
	__u16 fast_retransmit: 2;
};

struct sctp_stream_interleave {
	__u16 data_chunk_len;
	__u16 ftsn_chunk_len;
	struct sctp_chunk * (*make_datafrag)(const struct sctp_association *, const struct sctp_sndrcvinfo *, int, __u8, gfp_t);
	void (*assign_number)(struct sctp_chunk *);
	bool (*validate_data)(struct sctp_chunk *);
	int (*ulpevent_data)(struct sctp_ulpq *, struct sctp_chunk *, gfp_t);
	int (*enqueue_event)(struct sctp_ulpq *, struct sctp_ulpevent *);
	void (*renege_events)(struct sctp_ulpq *, struct sctp_chunk *, gfp_t);
	void (*start_pd)(struct sctp_ulpq *, gfp_t);
	void (*abort_pd)(struct sctp_ulpq *, gfp_t);
	void (*generate_ftsn)(struct sctp_outq *, __u32);
	bool (*validate_ftsn)(struct sctp_chunk *);
	void (*report_ftsn)(struct sctp_ulpq *, __u32);
	void (*handle_ftsn)(struct sctp_ulpq *, struct sctp_chunk *);
};

struct sctp_bind_bucket {
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct hlist_node node;
	struct hlist_head owner;
	struct net *net;
};

struct sctp_bind_hashbucket {
	spinlock_t lock;
	struct hlist_head chain;
};

struct sctp_hashbucket {
	rwlock_t lock;
	struct hlist_head chain;
};

struct sctp_globals {
	struct list_head address_families;
	struct sctp_hashbucket *ep_hashtable;
	struct sctp_bind_hashbucket *port_hashtable;
	struct rhltable transport_hashtable;
	int ep_hashsize;
	int port_hashsize;
	__u16 max_instreams;
	__u16 max_outstreams;
	bool checksum_disable;
};

enum sctp_socket_type {
	SCTP_SOCKET_UDP = 0,
	SCTP_SOCKET_UDP_HIGH_BANDWIDTH = 1,
	SCTP_SOCKET_TCP = 2,
};

struct sctp_pf;

struct sctp_sock {
	struct inet_sock inet;
	enum sctp_socket_type type;
	struct sctp_pf *pf;
	struct crypto_shash *hmac;
	char *sctp_hmac_alg;
	struct sctp_endpoint *ep;
	struct sctp_bind_bucket *bind_hash;
	__u16 default_stream;
	__u32 default_ppid;
	__u16 default_flags;
	__u32 default_context;
	__u32 default_timetolive;
	__u32 default_rcv_context;
	int max_burst;
	__u32 hbinterval;
	__be16 udp_port;
	__be16 encap_port;
	__u16 pathmaxrxt;
	__u32 flowlabel;
	__u8 dscp;
	__u16 pf_retrans;
	__u16 ps_retrans;
	__u32 pathmtu;
	__u32 sackdelay;
	__u32 sackfreq;
	__u32 param_flags;
	__u32 default_ss;
	struct sctp_rtoinfo rtoinfo;
	struct sctp_paddrparams paddrparam;
	struct sctp_assocparams assocparams;
	__u16 subscribe;
	struct sctp_initmsg initmsg;
	int user_frag;
	__u32 autoclose;
	__u32 adaptation_ind;
	__u32 pd_point;
	__u16 nodelay: 1;
	__u16 pf_expose: 2;
	__u16 reuse: 1;
	__u16 disable_fragments: 1;
	__u16 v4mapped: 1;
	__u16 frag_interleave: 1;
	__u16 recvrcvinfo: 1;
	__u16 recvnxtinfo: 1;
	__u16 data_ready_signalled: 1;
	atomic_t pd_mode;
	struct sk_buff_head pd_lobby;
	struct list_head auto_asconf_list;
	int do_auto_asconf;
};

struct sctp_af;

struct sctp_pf {
	void (*event_msgname)(struct sctp_ulpevent *, char *, int *);
	void (*skb_msgname)(struct sk_buff *, char *, int *);
	int (*af_supported)(sa_family_t, struct sctp_sock *);
	int (*cmp_addr)(const union sctp_addr *, const union sctp_addr *, struct sctp_sock *);
	int (*bind_verify)(struct sctp_sock *, union sctp_addr *);
	int (*send_verify)(struct sctp_sock *, union sctp_addr *);
	int (*supported_addrs)(const struct sctp_sock *, __be16 *);
	struct sock * (*create_accept_sk)(struct sock *, struct sctp_association *, bool);
	int (*addr_to_user)(struct sctp_sock *, union sctp_addr *);
	void (*to_sk_saddr)(union sctp_addr *, struct sock *);
	void (*to_sk_daddr)(union sctp_addr *, struct sock *);
	void (*copy_ip_options)(struct sock *, struct sock *);
	struct sctp_af *af;
};

struct sctp_signed_cookie {
	__u8 signature[32];
	__u32 __pad;
	struct sctp_cookie c;
} __attribute__((packed));

union sctp_addr_param {
	struct sctp_paramhdr p;
	struct sctp_ipv4addr_param v4;
	struct sctp_ipv6addr_param v6;
};

struct sctp_sender_hb_info {
	struct sctp_paramhdr param_hdr;
	union sctp_addr daddr;
	long unsigned int sent_at;
	__u64 hb_nonce;
};

struct sctp_af {
	int (*sctp_xmit)(struct sk_buff *, struct sctp_transport *);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*get_dst)(struct sctp_transport *, union sctp_addr *, struct flowi *, struct sock *);
	void (*get_saddr)(struct sctp_sock *, struct sctp_transport *, struct flowi *);
	void (*copy_addrlist)(struct list_head *, struct net_device *);
	int (*cmp_addr)(const union sctp_addr *, const union sctp_addr *);
	void (*addr_copy)(union sctp_addr *, union sctp_addr *);
	void (*from_skb)(union sctp_addr *, struct sk_buff *, int);
	void (*from_sk)(union sctp_addr *, struct sock *);
	bool (*from_addr_param)(union sctp_addr *, union sctp_addr_param *, __be16, int);
	int (*to_addr_param)(const union sctp_addr *, union sctp_addr_param *);
	int (*addr_valid)(union sctp_addr *, struct sctp_sock *, const struct sk_buff *);
	enum sctp_scope (*scope)(union sctp_addr *);
	void (*inaddr_any)(union sctp_addr *, __be16);
	int (*is_any)(const union sctp_addr *);
	int (*available)(union sctp_addr *, struct sctp_sock *);
	int (*skb_iif)(const struct sk_buff *);
	int (*is_ce)(const struct sk_buff *);
	void (*seq_dump_addr)(struct seq_file *, union sctp_addr *);
	void (*ecn_capable)(struct sock *);
	__u16 net_header_len;
	int sockaddr_len;
	int (*ip_options_len)(struct sock *);
	sa_family_t sa_family;
	struct list_head list;
};

struct sctp_packet {
	__u16 source_port;
	__u16 destination_port;
	__u32 vtag;
	struct list_head chunk_list;
	size_t overhead;
	size_t size;
	size_t max_size;
	struct sctp_transport *transport;
	struct sctp_chunk *auth;
	u8 has_cookie_echo: 1;
	u8 has_sack: 1;
	u8 has_auth: 1;
	u8 has_data: 1;
	u8 ipfragok: 1;
};

struct sctp_transport {
	struct list_head transports;
	struct rhlist_head node;
	refcount_t refcnt;
	__u32 rto_pending: 1;
	__u32 hb_sent: 1;
	__u32 pmtu_pending: 1;
	__u32 dst_pending_confirm: 1;
	__u32 sack_generation: 1;
	u32 dst_cookie;
	struct flowi fl;
	union sctp_addr ipaddr;
	struct sctp_af *af_specific;
	struct sctp_association *asoc;
	long unsigned int rto;
	__u32 rtt;
	__u32 rttvar;
	__u32 srtt;
	__u32 cwnd;
	__u32 ssthresh;
	__u32 partial_bytes_acked;
	__u32 flight_size;
	__u32 burst_limited;
	struct dst_entry *dst;
	union sctp_addr saddr;
	long unsigned int hbinterval;
	long unsigned int sackdelay;
	__u32 sackfreq;
	atomic_t mtu_info;
	ktime_t last_time_heard;
	long unsigned int last_time_sent;
	long unsigned int last_time_ecne_reduced;
	__be16 encap_port;
	__u16 pathmaxrxt;
	__u32 flowlabel;
	__u8 dscp;
	__u16 pf_retrans;
	__u16 ps_retrans;
	__u32 pathmtu;
	__u32 param_flags;
	int init_sent_count;
	int state;
	short unsigned int error_count;
	struct timer_list T3_rtx_timer;
	struct timer_list hb_timer;
	struct timer_list proto_unreach_timer;
	struct timer_list reconf_timer;
	struct list_head transmitted;
	struct sctp_packet packet;
	struct list_head send_ready;
	struct {
		__u32 next_tsn_at_change;
		char changeover_active;
		char cycling_changeover;
		char cacc_saw_newack;
	} cacc;
	__u64 hb_nonce;
	struct callback_head rcu;
};

struct sctp_datamsg {
	struct list_head chunks;
	refcount_t refcnt;
	long unsigned int expires_at;
	int send_error;
	u8 send_failed: 1;
	u8 can_delay: 1;
	u8 abandoned: 1;
};

struct sctp_stream_priorities {
	struct list_head prio_sched;
	struct list_head active;
	struct sctp_stream_out_ext *next;
	__u16 prio;
};

struct sctp_stream_out_ext {
	__u64 abandoned_unsent[3];
	__u64 abandoned_sent[3];
	struct list_head outq;
	union {
		struct {
			struct list_head prio_list;
			struct sctp_stream_priorities *prio_head;
		};
		struct {
			struct list_head rr_list;
		};
	};
};

struct task_security_struct {
	u32 osid;
	u32 sid;
	u32 exec_sid;
	u32 create_sid;
	u32 keycreate_sid;
	u32 sockcreate_sid;
};

enum label_initialized {
	LABEL_INVALID = 0,
	LABEL_INITIALIZED = 1,
	LABEL_PENDING = 2,
};

struct inode_security_struct {
	struct inode *inode;
	struct list_head list;
	u32 task_sid;
	u32 sid;
	u16 sclass;
	unsigned char initialized;
	spinlock_t lock;
};

struct file_security_struct {
	u32 sid;
	u32 fown_sid;
	u32 isid;
	u32 pseqno;
};

struct superblock_security_struct {
	u32 sid;
	u32 def_sid;
	u32 mntpoint_sid;
	short unsigned int behavior;
	short unsigned int flags;
	struct mutex lock;
	struct list_head isec_head;
	spinlock_t isec_lock;
};

struct msg_security_struct {
	u32 sid;
};

struct ipc_security_struct {
	u16 sclass;
	u32 sid;
};

struct sk_security_struct {
	enum {
		NLBL_UNSET = 0,
		NLBL_REQUIRE = 1,
		NLBL_LABELED = 2,
		NLBL_REQSKB = 3,
		NLBL_CONNLABELED = 4,
	} nlbl_state;
	struct netlbl_lsm_secattr *nlbl_secattr;
	u32 sid;
	u32 peer_sid;
	u16 sclass;
	enum {
		SCTP_ASSOC_UNSET = 0,
		SCTP_ASSOC_SET = 1,
	} sctp_assoc_state;
};

struct tun_security_struct {
	u32 sid;
};

struct key_security_struct {
	u32 sid;
};

struct ib_security_struct {
	u32 sid;
};

struct bpf_security_struct {
	u32 sid;
};

struct perf_event_security_struct {
	u32 sid;
};

struct selinux_mnt_opts {
	const char *fscontext;
	const char *context;
	const char *rootcontext;
	const char *defcontext;
};

enum {
	Opt_error___2 = 4294967295,
	Opt_context = 0,
	Opt_defcontext = 1,
	Opt_fscontext = 2,
	Opt_rootcontext = 3,
	Opt_seclabel = 4,
};

struct selinux_policy_convert_data;

struct selinux_load_state {
	struct selinux_policy *policy;
	struct selinux_policy_convert_data *convert_data;
};

enum sel_inos {
	SEL_ROOT_INO = 2,
	SEL_LOAD = 3,
	SEL_ENFORCE = 4,
	SEL_CONTEXT = 5,
	SEL_ACCESS = 6,
	SEL_CREATE = 7,
	SEL_RELABEL = 8,
	SEL_USER = 9,
	SEL_POLICYVERS = 10,
	SEL_COMMIT_BOOLS = 11,
	SEL_MLS = 12,
	SEL_DISABLE = 13,
	SEL_MEMBER = 14,
	SEL_CHECKREQPROT = 15,
	SEL_COMPAT_NET = 16,
	SEL_REJECT_UNKNOWN = 17,
	SEL_DENY_UNKNOWN = 18,
	SEL_STATUS = 19,
	SEL_POLICY = 20,
	SEL_VALIDATE_TRANS = 21,
	SEL_INO_NEXT = 22,
};

struct selinux_fs_info {
	struct dentry *bool_dir;
	unsigned int bool_num;
	char **bool_pending_names;
	unsigned int *bool_pending_values;
	struct dentry *class_dir;
	long unsigned int last_class_ino;
	bool policy_opened;
	struct dentry *policycap_dir;
	long unsigned int last_ino;
	struct selinux_state *state;
	struct super_block *sb;
};

struct policy_load_memory {
	size_t len;
	void *data;
};

enum {
	SELNL_MSG_SETENFORCE = 16,
	SELNL_MSG_POLICYLOAD = 17,
	SELNL_MSG_MAX = 18,
};

enum selinux_nlgroups {
	SELNLGRP_NONE = 0,
	SELNLGRP_AVC = 1,
	__SELNLGRP_MAX = 2,
};

struct selnl_msg_setenforce {
	__s32 val;
};

struct selnl_msg_policyload {
	__u32 seqno;
};

enum {
	XFRM_MSG_BASE = 16,
	XFRM_MSG_NEWSA = 16,
	XFRM_MSG_DELSA = 17,
	XFRM_MSG_GETSA = 18,
	XFRM_MSG_NEWPOLICY = 19,
	XFRM_MSG_DELPOLICY = 20,
	XFRM_MSG_GETPOLICY = 21,
	XFRM_MSG_ALLOCSPI = 22,
	XFRM_MSG_ACQUIRE = 23,
	XFRM_MSG_EXPIRE = 24,
	XFRM_MSG_UPDPOLICY = 25,
	XFRM_MSG_UPDSA = 26,
	XFRM_MSG_POLEXPIRE = 27,
	XFRM_MSG_FLUSHSA = 28,
	XFRM_MSG_FLUSHPOLICY = 29,
	XFRM_MSG_NEWAE = 30,
	XFRM_MSG_GETAE = 31,
	XFRM_MSG_REPORT = 32,
	XFRM_MSG_MIGRATE = 33,
	XFRM_MSG_NEWSADINFO = 34,
	XFRM_MSG_GETSADINFO = 35,
	XFRM_MSG_NEWSPDINFO = 36,
	XFRM_MSG_GETSPDINFO = 37,
	XFRM_MSG_MAPPING = 38,
	__XFRM_MSG_MAX = 39,
};

enum {
	RTM_BASE = 16,
	RTM_NEWLINK = 16,
	RTM_DELLINK = 17,
	RTM_GETLINK = 18,
	RTM_SETLINK = 19,
	RTM_NEWADDR = 20,
	RTM_DELADDR = 21,
	RTM_GETADDR = 22,
	RTM_NEWROUTE = 24,
	RTM_DELROUTE = 25,
	RTM_GETROUTE = 26,
	RTM_NEWNEIGH = 28,
	RTM_DELNEIGH = 29,
	RTM_GETNEIGH = 30,
	RTM_NEWRULE = 32,
	RTM_DELRULE = 33,
	RTM_GETRULE = 34,
	RTM_NEWQDISC = 36,
	RTM_DELQDISC = 37,
	RTM_GETQDISC = 38,
	RTM_NEWTCLASS = 40,
	RTM_DELTCLASS = 41,
	RTM_GETTCLASS = 42,
	RTM_NEWTFILTER = 44,
	RTM_DELTFILTER = 45,
	RTM_GETTFILTER = 46,
	RTM_NEWACTION = 48,
	RTM_DELACTION = 49,
	RTM_GETACTION = 50,
	RTM_NEWPREFIX = 52,
	RTM_GETMULTICAST = 58,
	RTM_GETANYCAST = 62,
	RTM_NEWNEIGHTBL = 64,
	RTM_GETNEIGHTBL = 66,
	RTM_SETNEIGHTBL = 67,
	RTM_NEWNDUSEROPT = 68,
	RTM_NEWADDRLABEL = 72,
	RTM_DELADDRLABEL = 73,
	RTM_GETADDRLABEL = 74,
	RTM_GETDCB = 78,
	RTM_SETDCB = 79,
	RTM_NEWNETCONF = 80,
	RTM_DELNETCONF = 81,
	RTM_GETNETCONF = 82,
	RTM_NEWMDB = 84,
	RTM_DELMDB = 85,
	RTM_GETMDB = 86,
	RTM_NEWNSID = 88,
	RTM_DELNSID = 89,
	RTM_GETNSID = 90,
	RTM_NEWSTATS = 92,
	RTM_GETSTATS = 94,
	RTM_NEWCACHEREPORT = 96,
	RTM_NEWCHAIN = 100,
	RTM_DELCHAIN = 101,
	RTM_GETCHAIN = 102,
	RTM_NEWNEXTHOP = 104,
	RTM_DELNEXTHOP = 105,
	RTM_GETNEXTHOP = 106,
	RTM_NEWLINKPROP = 108,
	RTM_DELLINKPROP = 109,
	RTM_GETLINKPROP = 110,
	RTM_NEWVLAN = 112,
	RTM_DELVLAN = 113,
	RTM_GETVLAN = 114,
	RTM_NEWNEXTHOPBUCKET = 116,
	RTM_DELNEXTHOPBUCKET = 117,
	RTM_GETNEXTHOPBUCKET = 118,
	__RTM_MAX = 119,
};

struct nlmsg_perm {
	u16 nlmsg_type;
	u32 perm;
};

struct netif_security_struct {
	struct net *ns;
	int ifindex;
	u32 sid;
};

struct sel_netif {
	struct list_head list;
	struct netif_security_struct nsec;
	struct callback_head callback_head;
};

struct netnode_security_struct {
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} addr;
	u32 sid;
	u16 family;
};

struct sel_netnode_bkt {
	unsigned int size;
	struct list_head list;
};

struct sel_netnode {
	struct netnode_security_struct nsec;
	struct list_head list;
	struct callback_head rcu;
};

struct netport_security_struct {
	u32 sid;
	u16 port;
	u8 protocol;
};

struct sel_netport_bkt {
	int size;
	struct list_head list;
};

struct sel_netport {
	struct netport_security_struct psec;
	struct list_head list;
	struct callback_head rcu;
};

struct selinux_kernel_status {
	u32 version;
	u32 sequence;
	u32 enforcing;
	u32 policyload;
	u32 deny_unknown;
};

struct ebitmap_node {
	struct ebitmap_node *next;
	long unsigned int maps[6];
	u32 startbit;
};

struct ebitmap {
	struct ebitmap_node *node;
	u32 highbit;
};

struct policy_file {
	char *data;
	size_t len;
};

struct hashtab_node {
	void *key;
	void *datum;
	struct hashtab_node *next;
};

struct hashtab {
	struct hashtab_node **htable;
	u32 size;
	u32 nel;
};

struct hashtab_info {
	u32 slots_used;
	u32 max_chain_len;
};

struct hashtab_key_params {
	u32 (*hash)(const void *);
	int (*cmp)(const void *, const void *);
};

struct symtab {
	struct hashtab table;
	u32 nprim;
};

struct mls_level {
	u32 sens;
	struct ebitmap cat;
};

struct mls_range {
	struct mls_level level[2];
};

struct context {
	u32 user;
	u32 role;
	u32 type;
	u32 len;
	struct mls_range range;
	char *str;
};

struct sidtab_str_cache;

struct sidtab_entry {
	u32 sid;
	u32 hash;
	struct context context;
	struct sidtab_str_cache *cache;
	struct hlist_node list;
};

struct sidtab_str_cache {
	struct callback_head rcu_member;
	struct list_head lru_member;
	struct sidtab_entry *parent;
	u32 len;
	char str[0];
};

struct sidtab_node_inner;

struct sidtab_node_leaf;

union sidtab_entry_inner {
	struct sidtab_node_inner *ptr_inner;
	struct sidtab_node_leaf *ptr_leaf;
};

struct sidtab_node_inner {
	union sidtab_entry_inner entries[512];
};

struct sidtab_node_leaf {
	struct sidtab_entry entries[39];
};

struct sidtab_isid_entry {
	int set;
	struct sidtab_entry entry;
};

struct sidtab;

struct sidtab_convert_params {
	int (*func)(struct context *, struct context *, void *);
	void *args;
	struct sidtab *target;
};

struct sidtab {
	union sidtab_entry_inner roots[4];
	u32 count;
	struct sidtab_convert_params *convert;
	bool frozen;
	spinlock_t lock;
	u32 cache_free_slots;
	struct list_head cache_lru_list;
	spinlock_t cache_lock;
	struct sidtab_isid_entry isids[27];
	struct hlist_head context_to_sid[512];
};

struct avtab_key {
	u16 source_type;
	u16 target_type;
	u16 target_class;
	u16 specified;
};

struct avtab_extended_perms {
	u8 specified;
	u8 driver;
	struct extended_perms_data perms;
};

struct avtab_datum {
	union {
		u32 data;
		struct avtab_extended_perms *xperms;
	} u;
};

struct avtab_node {
	struct avtab_key key;
	struct avtab_datum datum;
	struct avtab_node *next;
};

struct avtab {
	struct avtab_node **htable;
	u32 nel;
	u32 nslot;
	u32 mask;
};

struct type_set;

struct constraint_expr {
	u32 expr_type;
	u32 attr;
	u32 op;
	struct ebitmap names;
	struct type_set *type_names;
	struct constraint_expr *next;
};

struct type_set {
	struct ebitmap types;
	struct ebitmap negset;
	u32 flags;
};

struct constraint_node {
	u32 permissions;
	struct constraint_expr *expr;
	struct constraint_node *next;
};

struct common_datum {
	u32 value;
	struct symtab permissions;
};

struct class_datum {
	u32 value;
	char *comkey;
	struct common_datum *comdatum;
	struct symtab permissions;
	struct constraint_node *constraints;
	struct constraint_node *validatetrans;
	char default_user;
	char default_role;
	char default_type;
	char default_range;
};

struct role_datum {
	u32 value;
	u32 bounds;
	struct ebitmap dominates;
	struct ebitmap types;
};

struct role_allow {
	u32 role;
	u32 new_role;
	struct role_allow *next;
};

struct type_datum {
	u32 value;
	u32 bounds;
	unsigned char primary;
	unsigned char attribute;
};

struct user_datum {
	u32 value;
	u32 bounds;
	struct ebitmap roles;
	struct mls_range range;
	struct mls_level dfltlevel;
};

struct cond_bool_datum {
	__u32 value;
	int state;
};

struct ocontext {
	union {
		char *name;
		struct {
			u8 protocol;
			u16 low_port;
			u16 high_port;
		} port;
		struct {
			u32 addr;
			u32 mask;
		} node;
		struct {
			u32 addr[4];
			u32 mask[4];
		} node6;
		struct {
			u64 subnet_prefix;
			u16 low_pkey;
			u16 high_pkey;
		} ibpkey;
		struct {
			char *dev_name;
			u8 port;
		} ibendport;
	} u;
	union {
		u32 sclass;
		u32 behavior;
	} v;
	struct context context[2];
	u32 sid[2];
	struct ocontext *next;
};

struct genfs {
	char *fstype;
	struct ocontext *head;
	struct genfs *next;
};

struct cond_node;

struct policydb {
	int mls_enabled;
	struct symtab symtab[8];
	char **sym_val_to_name[8];
	struct class_datum **class_val_to_struct;
	struct role_datum **role_val_to_struct;
	struct user_datum **user_val_to_struct;
	struct type_datum **type_val_to_struct;
	struct avtab te_avtab;
	struct hashtab role_tr;
	struct ebitmap filename_trans_ttypes;
	struct hashtab filename_trans;
	u32 compat_filename_trans_count;
	struct cond_bool_datum **bool_val_to_struct;
	struct avtab te_cond_avtab;
	struct cond_node *cond_list;
	u32 cond_list_len;
	struct role_allow *role_allow;
	struct ocontext *ocontexts[9];
	struct genfs *genfs;
	struct hashtab range_tr;
	struct ebitmap *type_attr_map_array;
	struct ebitmap policycaps;
	struct ebitmap permissive_map;
	size_t len;
	unsigned int policyvers;
	unsigned int reject_unknown: 1;
	unsigned int allow_unknown: 1;
	u16 process_class;
	u32 process_trans_perms;
};

struct selinux_mapping;

struct selinux_map {
	struct selinux_mapping *mapping;
	u16 size;
};

struct selinux_policy {
	struct sidtab *sidtab;
	struct policydb policydb;
	struct selinux_map map;
	u32 latest_granting;
};

struct perm_datum {
	u32 value;
};

struct role_trans_key {
	u32 role;
	u32 type;
	u32 tclass;
};

struct role_trans_datum {
	u32 new_role;
};

struct filename_trans_key {
	u32 ttype;
	u16 tclass;
	const char *name;
};

struct filename_trans_datum {
	struct ebitmap stypes;
	u32 otype;
	struct filename_trans_datum *next;
};

struct level_datum {
	struct mls_level *level;
	unsigned char isalias;
};

struct cat_datum {
	u32 value;
	unsigned char isalias;
};

struct range_trans {
	u32 source_type;
	u32 target_type;
	u32 target_class;
};

struct cond_expr_node;

struct cond_expr {
	struct cond_expr_node *nodes;
	u32 len;
};

struct cond_av_list {
	struct avtab_node **nodes;
	u32 len;
};

struct cond_node {
	int cur_state;
	struct cond_expr expr;
	struct cond_av_list true_list;
	struct cond_av_list false_list;
};

struct policy_data {
	struct policydb *p;
	void *fp;
};

struct cond_expr_node {
	u32 expr_type;
	u32 bool;
};

struct selinux_mapping {
	u16 value;
	unsigned int num_perms;
	u32 perms[32];
};

struct policydb_compat_info {
	int version;
	int sym_num;
	int ocon_num;
};

struct convert_context_args {
	struct selinux_state *state;
	struct policydb *oldp;
	struct policydb *newp;
};

struct selinux_policy_convert_data {
	struct convert_context_args args;
	struct sidtab_convert_params sidtab_params;
};

struct selinux_audit_rule {
	u32 au_seqno;
	struct context au_ctxt;
};

struct cond_insertf_data {
	struct policydb *p;
	struct avtab_node **dst;
	struct cond_av_list *other;
};

struct rt6key {
	struct in6_addr addr;
	int plen;
};

struct rtable;

struct fnhe_hash_bucket;

struct fib_nh_common {
	struct net_device *nhc_dev;
	int nhc_oif;
	unsigned char nhc_scope;
	u8 nhc_family;
	u8 nhc_gw_family;
	unsigned char nhc_flags;
	struct lwtunnel_state *nhc_lwtstate;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} nhc_gw;
	int nhc_weight;
	atomic_t nhc_upper_bound;
	struct rtable **nhc_pcpu_rth_output;
	struct rtable *nhc_rth_input;
	struct fnhe_hash_bucket *nhc_exceptions;
};

struct rt6_exception_bucket;

struct fib6_nh {
	struct fib_nh_common nh_common;
	long unsigned int last_probe;
	struct rt6_info **rt6i_pcpu;
	struct rt6_exception_bucket *rt6i_exception_bucket;
};

struct fib6_node;

struct nexthop;

struct fib6_info {
	struct fib6_table *fib6_table;
	struct fib6_info *fib6_next;
	struct fib6_node *fib6_node;
	union {
		struct list_head fib6_siblings;
		struct list_head nh_list;
	};
	unsigned int fib6_nsiblings;
	refcount_t fib6_ref;
	long unsigned int expires;
	struct dst_metrics *fib6_metrics;
	struct rt6key fib6_dst;
	u32 fib6_flags;
	struct rt6key fib6_src;
	struct rt6key fib6_prefsrc;
	u32 fib6_metric;
	u8 fib6_protocol;
	u8 fib6_type;
	u8 should_flush: 1;
	u8 dst_nocount: 1;
	u8 dst_nopolicy: 1;
	u8 fib6_destroying: 1;
	u8 offload: 1;
	u8 trap: 1;
	u8 offload_failed: 1;
	u8 unused: 1;
	struct callback_head rcu;
	struct nexthop *nh;
	struct fib6_nh fib6_nh[0];
};

struct uncached_list;

struct rt6_info {
	struct dst_entry dst;
	struct fib6_info *from;
	int sernum;
	struct rt6key rt6i_dst;
	struct rt6key rt6i_src;
	struct in6_addr rt6i_gateway;
	struct inet6_dev *rt6i_idev;
	u32 rt6i_flags;
	struct list_head rt6i_uncached;
	struct uncached_list *rt6i_uncached_list;
	short unsigned int rt6i_nfheader_len;
};

struct rt6_statistics {
	__u32 fib_nodes;
	__u32 fib_route_nodes;
	__u32 fib_rt_entries;
	__u32 fib_rt_cache;
	__u32 fib_discarded_routes;
	atomic_t fib_rt_alloc;
	atomic_t fib_rt_uncache;
};

struct fib6_node {
	struct fib6_node *parent;
	struct fib6_node *left;
	struct fib6_node *right;
	struct fib6_node *subtree;
	struct fib6_info *leaf;
	__u16 fn_bit;
	__u16 fn_flags;
	int fn_sernum;
	struct fib6_info *rr_ptr;
	struct callback_head rcu;
};

struct fib6_table {
	struct hlist_node tb6_hlist;
	u32 tb6_id;
	spinlock_t tb6_lock;
	struct fib6_node tb6_root;
	struct inet_peer_base tb6_peers;
	unsigned int flags;
	unsigned int fib_seq;
};

typedef union {
	__be32 a4;
	__be32 a6[4];
	struct in6_addr in6;
} xfrm_address_t;

struct xfrm_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u8 proto;
};

struct xfrm_selector {
	xfrm_address_t daddr;
	xfrm_address_t saddr;
	__be16 dport;
	__be16 dport_mask;
	__be16 sport;
	__be16 sport_mask;
	__u16 family;
	__u8 prefixlen_d;
	__u8 prefixlen_s;
	__u8 proto;
	int ifindex;
	__kernel_uid32_t user;
};

struct xfrm_lifetime_cfg {
	__u64 soft_byte_limit;
	__u64 hard_byte_limit;
	__u64 soft_packet_limit;
	__u64 hard_packet_limit;
	__u64 soft_add_expires_seconds;
	__u64 hard_add_expires_seconds;
	__u64 soft_use_expires_seconds;
	__u64 hard_use_expires_seconds;
};

struct xfrm_lifetime_cur {
	__u64 bytes;
	__u64 packets;
	__u64 add_time;
	__u64 use_time;
};

struct xfrm_replay_state {
	__u32 oseq;
	__u32 seq;
	__u32 bitmap;
};

struct xfrm_replay_state_esn {
	unsigned int bmp_len;
	__u32 oseq;
	__u32 seq;
	__u32 oseq_hi;
	__u32 seq_hi;
	__u32 replay_window;
	__u32 bmp[0];
};

struct xfrm_algo {
	char alg_name[64];
	unsigned int alg_key_len;
	char alg_key[0];
};

struct xfrm_algo_auth {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_trunc_len;
	char alg_key[0];
};

struct xfrm_algo_aead {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_icv_len;
	char alg_key[0];
};

struct xfrm_stats {
	__u32 replay_window;
	__u32 replay;
	__u32 integrity_failed;
};

enum {
	XFRM_POLICY_TYPE_MAIN = 0,
	XFRM_POLICY_TYPE_SUB = 1,
	XFRM_POLICY_TYPE_MAX = 2,
	XFRM_POLICY_TYPE_ANY = 255,
};

struct xfrm_encap_tmpl {
	__u16 encap_type;
	__be16 encap_sport;
	__be16 encap_dport;
	xfrm_address_t encap_oa;
};

enum xfrm_attr_type_t {
	XFRMA_UNSPEC = 0,
	XFRMA_ALG_AUTH = 1,
	XFRMA_ALG_CRYPT = 2,
	XFRMA_ALG_COMP = 3,
	XFRMA_ENCAP = 4,
	XFRMA_TMPL = 5,
	XFRMA_SA = 6,
	XFRMA_POLICY = 7,
	XFRMA_SEC_CTX = 8,
	XFRMA_LTIME_VAL = 9,
	XFRMA_REPLAY_VAL = 10,
	XFRMA_REPLAY_THRESH = 11,
	XFRMA_ETIMER_THRESH = 12,
	XFRMA_SRCADDR = 13,
	XFRMA_COADDR = 14,
	XFRMA_LASTUSED = 15,
	XFRMA_POLICY_TYPE = 16,
	XFRMA_MIGRATE = 17,
	XFRMA_ALG_AEAD = 18,
	XFRMA_KMADDRESS = 19,
	XFRMA_ALG_AUTH_TRUNC = 20,
	XFRMA_MARK = 21,
	XFRMA_TFCPAD = 22,
	XFRMA_REPLAY_ESN_VAL = 23,
	XFRMA_SA_EXTRA_FLAGS = 24,
	XFRMA_PROTO = 25,
	XFRMA_ADDRESS_FILTER = 26,
	XFRMA_PAD = 27,
	XFRMA_OFFLOAD_DEV = 28,
	XFRMA_SET_MARK = 29,
	XFRMA_SET_MARK_MASK = 30,
	XFRMA_IF_ID = 31,
	XFRMA_MTIMER_THRESH = 32,
	__XFRMA_MAX = 33,
};

struct xfrm_mark {
	__u32 v;
	__u32 m;
};

struct xfrm_address_filter {
	xfrm_address_t saddr;
	xfrm_address_t daddr;
	__u16 family;
	__u8 splen;
	__u8 dplen;
};

struct xfrm_state_walk {
	struct list_head all;
	u8 state;
	u8 dying;
	u8 proto;
	u32 seq;
	struct xfrm_address_filter *filter;
};

struct xfrm_state_offload {
	struct net_device *dev;
	struct net_device *real_dev;
	long unsigned int offload_handle;
	unsigned int num_exthdrs;
	u8 flags;
};

struct xfrm_mode {
	u8 encap;
	u8 family;
	u8 flags;
};

struct xfrm_replay;

struct xfrm_type;

struct xfrm_type_offload;

struct xfrm_state {
	possible_net_t xs_net;
	union {
		struct hlist_node gclist;
		struct hlist_node bydst;
	};
	struct hlist_node bysrc;
	struct hlist_node byspi;
	refcount_t refcnt;
	spinlock_t lock;
	struct xfrm_id id;
	struct xfrm_selector sel;
	struct xfrm_mark mark;
	u32 if_id;
	u32 tfcpad;
	u32 genid;
	struct xfrm_state_walk km;
	struct {
		u32 reqid;
		u8 mode;
		u8 replay_window;
		u8 aalgo;
		u8 ealgo;
		u8 calgo;
		u8 flags;
		u16 family;
		xfrm_address_t saddr;
		int header_len;
		int trailer_len;
		u32 extra_flags;
		struct xfrm_mark smark;
	} props;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_algo_auth *aalg;
	struct xfrm_algo *ealg;
	struct xfrm_algo *calg;
	struct xfrm_algo_aead *aead;
	const char *geniv;
	__be16 new_mapping_sport;
	u32 new_mapping;
	u32 mapping_maxage;
	struct xfrm_encap_tmpl *encap;
	struct sock *encap_sk;
	xfrm_address_t *coaddr;
	struct xfrm_state *tunnel;
	atomic_t tunnel_users;
	struct xfrm_replay_state replay;
	struct xfrm_replay_state_esn *replay_esn;
	struct xfrm_replay_state preplay;
	struct xfrm_replay_state_esn *preplay_esn;
	const struct xfrm_replay *repl;
	u32 xflags;
	u32 replay_maxage;
	u32 replay_maxdiff;
	struct timer_list rtimer;
	struct xfrm_stats stats;
	struct xfrm_lifetime_cur curlft;
	struct hrtimer mtimer;
	struct xfrm_state_offload xso;
	long int saved_tmo;
	time64_t lastused;
	struct page_frag xfrag;
	const struct xfrm_type *type;
	struct xfrm_mode inner_mode;
	struct xfrm_mode inner_mode_iaf;
	struct xfrm_mode outer_mode;
	const struct xfrm_type_offload *type_offload;
	struct xfrm_sec_ctx *security;
	void *data;
};

struct xfrm_policy_walk_entry {
	struct list_head all;
	u8 dead;
};

struct xfrm_policy_queue {
	struct sk_buff_head hold_queue;
	struct timer_list hold_timer;
	long unsigned int timeout;
};

struct xfrm_tmpl {
	struct xfrm_id id;
	xfrm_address_t saddr;
	short unsigned int encap_family;
	u32 reqid;
	u8 mode;
	u8 share;
	u8 optional;
	u8 allalgs;
	u32 aalgos;
	u32 ealgos;
	u32 calgos;
};

struct xfrm_policy {
	possible_net_t xp_net;
	struct hlist_node bydst;
	struct hlist_node byidx;
	rwlock_t lock;
	refcount_t refcnt;
	u32 pos;
	struct timer_list timer;
	atomic_t genid;
	u32 priority;
	u32 index;
	u32 if_id;
	struct xfrm_mark mark;
	struct xfrm_selector selector;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	struct xfrm_policy_walk_entry walk;
	struct xfrm_policy_queue polq;
	bool bydst_reinsert;
	u8 type;
	u8 action;
	u8 flags;
	u8 xfrm_nr;
	u16 family;
	struct xfrm_sec_ctx *security;
	struct xfrm_tmpl xfrm_vec[6];
	struct hlist_node bydst_inexact_list;
	struct callback_head rcu;
};

struct udp_hslot;

struct udp_table {
	struct udp_hslot *hash;
	struct udp_hslot *hash2;
	unsigned int mask;
	unsigned int log;
};

struct fib6_config {
	u32 fc_table;
	u32 fc_metric;
	int fc_dst_len;
	int fc_src_len;
	int fc_ifindex;
	u32 fc_flags;
	u32 fc_protocol;
	u16 fc_type;
	u16 fc_delete_all_nh: 1;
	u16 fc_ignore_dev_down: 1;
	u16 __unused: 14;
	u32 fc_nh_id;
	struct in6_addr fc_dst;
	struct in6_addr fc_src;
	struct in6_addr fc_prefsrc;
	struct in6_addr fc_gateway;
	long unsigned int fc_expires;
	struct nlattr *fc_mx;
	int fc_mx_len;
	int fc_mp_len;
	struct nlattr *fc_mp;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
	bool fc_is_fdb;
};

struct fib_nh_exception {
	struct fib_nh_exception *fnhe_next;
	int fnhe_genid;
	__be32 fnhe_daddr;
	u32 fnhe_pmtu;
	bool fnhe_mtu_locked;
	__be32 fnhe_gw;
	long unsigned int fnhe_expires;
	struct rtable *fnhe_rth_input;
	struct rtable *fnhe_rth_output;
	long unsigned int fnhe_stamp;
	struct callback_head rcu;
};

struct rtable {
	struct dst_entry dst;
	int rt_genid;
	unsigned int rt_flags;
	__u16 rt_type;
	__u8 rt_is_input;
	__u8 rt_uses_gateway;
	int rt_iif;
	u8 rt_gw_family;
	union {
		__be32 rt_gw4;
		struct in6_addr rt_gw6;
	};
	u32 rt_mtu_locked: 1;
	u32 rt_pmtu: 31;
	struct list_head rt_uncached;
	struct uncached_list *rt_uncached_list;
};

struct fnhe_hash_bucket {
	struct fib_nh_exception *chain;
};

struct rt6_exception_bucket {
	struct hlist_head chain;
	int depth;
};

struct xfrm_replay {
	void (*advance)(struct xfrm_state *, __be32);
	int (*check)(struct xfrm_state *, struct sk_buff *, __be32);
	int (*recheck)(struct xfrm_state *, struct sk_buff *, __be32);
	void (*notify)(struct xfrm_state *, int);
	int (*overflow)(struct xfrm_state *, struct sk_buff *);
};

struct xfrm_type {
	char *description;
	struct module *owner;
	u8 proto;
	u8 flags;
	int (*init_state)(struct xfrm_state *);
	void (*destructor)(struct xfrm_state *);
	int (*input)(struct xfrm_state *, struct sk_buff *);
	int (*output)(struct xfrm_state *, struct sk_buff *);
	int (*reject)(struct xfrm_state *, struct sk_buff *, const struct flowi *);
	int (*hdr_offset)(struct xfrm_state *, struct sk_buff *, u8 **);
};

struct xfrm_type_offload {
	char *description;
	struct module *owner;
	u8 proto;
	void (*encap)(struct xfrm_state *, struct sk_buff *);
	int (*input_tail)(struct xfrm_state *, struct sk_buff *);
	int (*xmit)(struct xfrm_state *, struct sk_buff *, netdev_features_t);
};

struct xfrm_dst {
	union {
		struct dst_entry dst;
		struct rtable rt;
		struct rt6_info rt6;
	} u;
	struct dst_entry *route;
	struct dst_entry *child;
	struct dst_entry *path;
	struct xfrm_policy *pols[2];
	int num_pols;
	int num_xfrms;
	u32 xfrm_genid;
	u32 policy_genid;
	u32 route_mtu_cached;
	u32 child_mtu_cached;
	u32 route_cookie;
	u32 path_cookie;
};

struct xfrm_offload {
	struct {
		__u32 low;
		__u32 hi;
	} seq;
	__u32 flags;
	__u32 status;
	__u8 proto;
};

struct sec_path {
	int len;
	int olen;
	struct xfrm_state *xvec[6];
	struct xfrm_offload ovec[1];
};

struct udp_hslot {
	struct hlist_head head;
	int count;
	spinlock_t lock;
};

struct pkey_security_struct {
	u64 subnet_prefix;
	u16 pkey;
	u32 sid;
};

struct sel_ib_pkey_bkt {
	int size;
	struct list_head list;
};

struct sel_ib_pkey {
	struct pkey_security_struct psec;
	struct list_head list;
	struct callback_head rcu;
};

struct smack_audit_data {
	const char *function;
	char *subject;
	char *object;
	char *request;
	int result;
};

struct smack_known {
	struct list_head list;
	struct hlist_node smk_hashed;
	char *smk_known;
	u32 smk_secid;
	struct netlbl_lsm_secattr smk_netlabel;
	struct list_head smk_rules;
	struct mutex smk_rules_lock;
};

struct superblock_smack {
	struct smack_known *smk_root;
	struct smack_known *smk_floor;
	struct smack_known *smk_hat;
	struct smack_known *smk_default;
	int smk_flags;
};

struct socket_smack {
	struct smack_known *smk_out;
	struct smack_known *smk_in;
	struct smack_known *smk_packet;
	int smk_state;
};

struct inode_smack {
	struct smack_known *smk_inode;
	struct smack_known *smk_task;
	struct smack_known *smk_mmap;
	int smk_flags;
};

struct task_smack {
	struct smack_known *smk_task;
	struct smack_known *smk_forked;
	struct list_head smk_rules;
	struct mutex smk_rules_lock;
	struct list_head smk_relabel;
};

struct smack_rule {
	struct list_head list;
	struct smack_known *smk_subject;
	struct smack_known *smk_object;
	int smk_access;
};

struct smk_net4addr {
	struct list_head list;
	struct in_addr smk_host;
	struct in_addr smk_mask;
	int smk_masks;
	struct smack_known *smk_label;
};

struct smk_net6addr {
	struct list_head list;
	struct in6_addr smk_host;
	struct in6_addr smk_mask;
	int smk_masks;
	struct smack_known *smk_label;
};

struct smack_known_list_elem {
	struct list_head list;
	struct smack_known *smk_label;
};

enum {
	Opt_error___3 = 4294967295,
	Opt_fsdefault = 0,
	Opt_fsfloor = 1,
	Opt_fshat = 2,
	Opt_fsroot = 3,
	Opt_fstransmute = 4,
};

struct smk_audit_info {
	struct common_audit_data a;
	struct smack_audit_data sad;
};

struct smack_mnt_opts {
	const char *fsdefault;
	const char *fsfloor;
	const char *fshat;
	const char *fsroot;
	const char *fstransmute;
};

struct netlbl_audit {
	struct lsmblob lsmdata;
	kuid_t loginuid;
	unsigned int sessionid;
};

struct cipso_v4_std_map_tbl {
	struct {
		u32 *cipso;
		u32 *local;
		u32 cipso_size;
		u32 local_size;
	} lvl;
	struct {
		u32 *cipso;
		u32 *local;
		u32 cipso_size;
		u32 local_size;
	} cat;
};

struct cipso_v4_doi {
	u32 doi;
	u32 type;
	union {
		struct cipso_v4_std_map_tbl *std;
	} map;
	u8 tags[5];
	refcount_t refcount;
	struct list_head list;
	struct callback_head rcu;
};

enum smk_inos {
	SMK_ROOT_INO = 2,
	SMK_LOAD = 3,
	SMK_CIPSO = 4,
	SMK_DOI = 5,
	SMK_DIRECT = 6,
	SMK_AMBIENT = 7,
	SMK_NET4ADDR = 8,
	SMK_ONLYCAP = 9,
	SMK_LOGGING = 10,
	SMK_LOAD_SELF = 11,
	SMK_ACCESSES = 12,
	SMK_MAPPED = 13,
	SMK_LOAD2 = 14,
	SMK_LOAD_SELF2 = 15,
	SMK_ACCESS2 = 16,
	SMK_CIPSO2 = 17,
	SMK_REVOKE_SUBJ = 18,
	SMK_CHANGE_RULE = 19,
	SMK_SYSLOG = 20,
	SMK_PTRACE = 21,
	SMK_NET6ADDR = 23,
	SMK_RELABEL_SELF = 24,
};

struct smack_parsed_rule {
	struct smack_known *smk_subject;
	struct smack_known *smk_object;
	int smk_access1;
	int smk_access2;
};

struct sockaddr_un {
	__kernel_sa_family_t sun_family;
	char sun_path[108];
};

struct unix_address {
	refcount_t refcnt;
	int len;
	unsigned int hash;
	struct sockaddr_un name[0];
};

struct scm_stat {
	atomic_t nr_fds;
};

struct unix_sock {
	struct sock sk;
	struct unix_address *addr;
	struct path path;
	struct mutex iolock;
	struct mutex bindlock;
	struct sock *peer;
	struct list_head link;
	atomic_long_t inflight;
	spinlock_t lock;
	long unsigned int gc_flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct socket_wq peer_wq;
	wait_queue_entry_t peer_wake;
	struct scm_stat scm_stat;
	long: 32;
	long: 64;
	long: 64;
};

enum tomoyo_conditions_index {
	TOMOYO_TASK_UID = 0,
	TOMOYO_TASK_EUID = 1,
	TOMOYO_TASK_SUID = 2,
	TOMOYO_TASK_FSUID = 3,
	TOMOYO_TASK_GID = 4,
	TOMOYO_TASK_EGID = 5,
	TOMOYO_TASK_SGID = 6,
	TOMOYO_TASK_FSGID = 7,
	TOMOYO_TASK_PID = 8,
	TOMOYO_TASK_PPID = 9,
	TOMOYO_EXEC_ARGC = 10,
	TOMOYO_EXEC_ENVC = 11,
	TOMOYO_TYPE_IS_SOCKET = 12,
	TOMOYO_TYPE_IS_SYMLINK = 13,
	TOMOYO_TYPE_IS_FILE = 14,
	TOMOYO_TYPE_IS_BLOCK_DEV = 15,
	TOMOYO_TYPE_IS_DIRECTORY = 16,
	TOMOYO_TYPE_IS_CHAR_DEV = 17,
	TOMOYO_TYPE_IS_FIFO = 18,
	TOMOYO_MODE_SETUID = 19,
	TOMOYO_MODE_SETGID = 20,
	TOMOYO_MODE_STICKY = 21,
	TOMOYO_MODE_OWNER_READ = 22,
	TOMOYO_MODE_OWNER_WRITE = 23,
	TOMOYO_MODE_OWNER_EXECUTE = 24,
	TOMOYO_MODE_GROUP_READ = 25,
	TOMOYO_MODE_GROUP_WRITE = 26,
	TOMOYO_MODE_GROUP_EXECUTE = 27,
	TOMOYO_MODE_OTHERS_READ = 28,
	TOMOYO_MODE_OTHERS_WRITE = 29,
	TOMOYO_MODE_OTHERS_EXECUTE = 30,
	TOMOYO_EXEC_REALPATH = 31,
	TOMOYO_SYMLINK_TARGET = 32,
	TOMOYO_PATH1_UID = 33,
	TOMOYO_PATH1_GID = 34,
	TOMOYO_PATH1_INO = 35,
	TOMOYO_PATH1_MAJOR = 36,
	TOMOYO_PATH1_MINOR = 37,
	TOMOYO_PATH1_PERM = 38,
	TOMOYO_PATH1_TYPE = 39,
	TOMOYO_PATH1_DEV_MAJOR = 40,
	TOMOYO_PATH1_DEV_MINOR = 41,
	TOMOYO_PATH2_UID = 42,
	TOMOYO_PATH2_GID = 43,
	TOMOYO_PATH2_INO = 44,
	TOMOYO_PATH2_MAJOR = 45,
	TOMOYO_PATH2_MINOR = 46,
	TOMOYO_PATH2_PERM = 47,
	TOMOYO_PATH2_TYPE = 48,
	TOMOYO_PATH2_DEV_MAJOR = 49,
	TOMOYO_PATH2_DEV_MINOR = 50,
	TOMOYO_PATH1_PARENT_UID = 51,
	TOMOYO_PATH1_PARENT_GID = 52,
	TOMOYO_PATH1_PARENT_INO = 53,
	TOMOYO_PATH1_PARENT_PERM = 54,
	TOMOYO_PATH2_PARENT_UID = 55,
	TOMOYO_PATH2_PARENT_GID = 56,
	TOMOYO_PATH2_PARENT_INO = 57,
	TOMOYO_PATH2_PARENT_PERM = 58,
	TOMOYO_MAX_CONDITION_KEYWORD = 59,
	TOMOYO_NUMBER_UNION = 60,
	TOMOYO_NAME_UNION = 61,
	TOMOYO_ARGV_ENTRY = 62,
	TOMOYO_ENVP_ENTRY = 63,
};

enum tomoyo_path_stat_index {
	TOMOYO_PATH1 = 0,
	TOMOYO_PATH1_PARENT = 1,
	TOMOYO_PATH2 = 2,
	TOMOYO_PATH2_PARENT = 3,
	TOMOYO_MAX_PATH_STAT = 4,
};

enum tomoyo_mode_index {
	TOMOYO_CONFIG_DISABLED = 0,
	TOMOYO_CONFIG_LEARNING = 1,
	TOMOYO_CONFIG_PERMISSIVE = 2,
	TOMOYO_CONFIG_ENFORCING = 3,
	TOMOYO_CONFIG_MAX_MODE = 4,
	TOMOYO_CONFIG_WANT_REJECT_LOG = 64,
	TOMOYO_CONFIG_WANT_GRANT_LOG = 128,
	TOMOYO_CONFIG_USE_DEFAULT = 255,
};

enum tomoyo_policy_id {
	TOMOYO_ID_GROUP = 0,
	TOMOYO_ID_ADDRESS_GROUP = 1,
	TOMOYO_ID_PATH_GROUP = 2,
	TOMOYO_ID_NUMBER_GROUP = 3,
	TOMOYO_ID_TRANSITION_CONTROL = 4,
	TOMOYO_ID_AGGREGATOR = 5,
	TOMOYO_ID_MANAGER = 6,
	TOMOYO_ID_CONDITION = 7,
	TOMOYO_ID_NAME = 8,
	TOMOYO_ID_ACL = 9,
	TOMOYO_ID_DOMAIN = 10,
	TOMOYO_MAX_POLICY = 11,
};

enum tomoyo_domain_info_flags_index {
	TOMOYO_DIF_QUOTA_WARNED = 0,
	TOMOYO_DIF_TRANSITION_FAILED = 1,
	TOMOYO_MAX_DOMAIN_INFO_FLAGS = 2,
};

enum tomoyo_grant_log {
	TOMOYO_GRANTLOG_AUTO = 0,
	TOMOYO_GRANTLOG_NO = 1,
	TOMOYO_GRANTLOG_YES = 2,
};

enum tomoyo_group_id {
	TOMOYO_PATH_GROUP = 0,
	TOMOYO_NUMBER_GROUP = 1,
	TOMOYO_ADDRESS_GROUP = 2,
	TOMOYO_MAX_GROUP = 3,
};

enum tomoyo_path_acl_index {
	TOMOYO_TYPE_EXECUTE = 0,
	TOMOYO_TYPE_READ = 1,
	TOMOYO_TYPE_WRITE = 2,
	TOMOYO_TYPE_APPEND = 3,
	TOMOYO_TYPE_UNLINK = 4,
	TOMOYO_TYPE_GETATTR = 5,
	TOMOYO_TYPE_RMDIR = 6,
	TOMOYO_TYPE_TRUNCATE = 7,
	TOMOYO_TYPE_SYMLINK = 8,
	TOMOYO_TYPE_CHROOT = 9,
	TOMOYO_TYPE_UMOUNT = 10,
	TOMOYO_MAX_PATH_OPERATION = 11,
};

enum tomoyo_memory_stat_type {
	TOMOYO_MEMORY_POLICY = 0,
	TOMOYO_MEMORY_AUDIT = 1,
	TOMOYO_MEMORY_QUERY = 2,
	TOMOYO_MAX_MEMORY_STAT = 3,
};

enum tomoyo_mkdev_acl_index {
	TOMOYO_TYPE_MKBLOCK = 0,
	TOMOYO_TYPE_MKCHAR = 1,
	TOMOYO_MAX_MKDEV_OPERATION = 2,
};

enum tomoyo_network_acl_index {
	TOMOYO_NETWORK_BIND = 0,
	TOMOYO_NETWORK_LISTEN = 1,
	TOMOYO_NETWORK_CONNECT = 2,
	TOMOYO_NETWORK_SEND = 3,
	TOMOYO_MAX_NETWORK_OPERATION = 4,
};

enum tomoyo_path2_acl_index {
	TOMOYO_TYPE_LINK = 0,
	TOMOYO_TYPE_RENAME = 1,
	TOMOYO_TYPE_PIVOT_ROOT = 2,
	TOMOYO_MAX_PATH2_OPERATION = 3,
};

enum tomoyo_path_number_acl_index {
	TOMOYO_TYPE_CREATE = 0,
	TOMOYO_TYPE_MKDIR = 1,
	TOMOYO_TYPE_MKFIFO = 2,
	TOMOYO_TYPE_MKSOCK = 3,
	TOMOYO_TYPE_IOCTL = 4,
	TOMOYO_TYPE_CHMOD = 5,
	TOMOYO_TYPE_CHOWN = 6,
	TOMOYO_TYPE_CHGRP = 7,
	TOMOYO_MAX_PATH_NUMBER_OPERATION = 8,
};

enum tomoyo_securityfs_interface_index {
	TOMOYO_DOMAINPOLICY = 0,
	TOMOYO_EXCEPTIONPOLICY = 1,
	TOMOYO_PROCESS_STATUS = 2,
	TOMOYO_STAT = 3,
	TOMOYO_AUDIT = 4,
	TOMOYO_VERSION = 5,
	TOMOYO_PROFILE = 6,
	TOMOYO_QUERY = 7,
	TOMOYO_MANAGER = 8,
};

enum tomoyo_mac_index {
	TOMOYO_MAC_FILE_EXECUTE = 0,
	TOMOYO_MAC_FILE_OPEN = 1,
	TOMOYO_MAC_FILE_CREATE = 2,
	TOMOYO_MAC_FILE_UNLINK = 3,
	TOMOYO_MAC_FILE_GETATTR = 4,
	TOMOYO_MAC_FILE_MKDIR = 5,
	TOMOYO_MAC_FILE_RMDIR = 6,
	TOMOYO_MAC_FILE_MKFIFO = 7,
	TOMOYO_MAC_FILE_MKSOCK = 8,
	TOMOYO_MAC_FILE_TRUNCATE = 9,
	TOMOYO_MAC_FILE_SYMLINK = 10,
	TOMOYO_MAC_FILE_MKBLOCK = 11,
	TOMOYO_MAC_FILE_MKCHAR = 12,
	TOMOYO_MAC_FILE_LINK = 13,
	TOMOYO_MAC_FILE_RENAME = 14,
	TOMOYO_MAC_FILE_CHMOD = 15,
	TOMOYO_MAC_FILE_CHOWN = 16,
	TOMOYO_MAC_FILE_CHGRP = 17,
	TOMOYO_MAC_FILE_IOCTL = 18,
	TOMOYO_MAC_FILE_CHROOT = 19,
	TOMOYO_MAC_FILE_MOUNT = 20,
	TOMOYO_MAC_FILE_UMOUNT = 21,
	TOMOYO_MAC_FILE_PIVOT_ROOT = 22,
	TOMOYO_MAC_NETWORK_INET_STREAM_BIND = 23,
	TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN = 24,
	TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT = 25,
	TOMOYO_MAC_NETWORK_INET_DGRAM_BIND = 26,
	TOMOYO_MAC_NETWORK_INET_DGRAM_SEND = 27,
	TOMOYO_MAC_NETWORK_INET_RAW_BIND = 28,
	TOMOYO_MAC_NETWORK_INET_RAW_SEND = 29,
	TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND = 30,
	TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN = 31,
	TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT = 32,
	TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND = 33,
	TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND = 34,
	TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND = 35,
	TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN = 36,
	TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT = 37,
	TOMOYO_MAC_ENVIRON = 38,
	TOMOYO_MAX_MAC_INDEX = 39,
};

enum tomoyo_mac_category_index {
	TOMOYO_MAC_CATEGORY_FILE = 0,
	TOMOYO_MAC_CATEGORY_NETWORK = 1,
	TOMOYO_MAC_CATEGORY_MISC = 2,
	TOMOYO_MAX_MAC_CATEGORY_INDEX = 3,
};

enum tomoyo_pref_index {
	TOMOYO_PREF_MAX_AUDIT_LOG = 0,
	TOMOYO_PREF_MAX_LEARNING_ENTRY = 1,
	TOMOYO_MAX_PREF = 2,
};

struct tomoyo_shared_acl_head {
	struct list_head list;
	atomic_t users;
} __attribute__((packed));

struct tomoyo_path_info {
	const char *name;
	u32 hash;
	u16 const_len;
	bool is_dir;
	bool is_patterned;
};

struct tomoyo_obj_info;

struct tomoyo_execve;

struct tomoyo_domain_info;

struct tomoyo_acl_info;

struct tomoyo_request_info {
	struct tomoyo_obj_info *obj;
	struct tomoyo_execve *ee;
	struct tomoyo_domain_info *domain;
	union {
		struct {
			const struct tomoyo_path_info *filename;
			const struct tomoyo_path_info *matched_path;
			u8 operation;
		} path;
		struct {
			const struct tomoyo_path_info *filename1;
			const struct tomoyo_path_info *filename2;
			u8 operation;
		} path2;
		struct {
			const struct tomoyo_path_info *filename;
			unsigned int mode;
			unsigned int major;
			unsigned int minor;
			u8 operation;
		} mkdev;
		struct {
			const struct tomoyo_path_info *filename;
			long unsigned int number;
			u8 operation;
		} path_number;
		struct {
			const struct tomoyo_path_info *name;
		} environ;
		struct {
			const __be32 *address;
			u16 port;
			u8 protocol;
			u8 operation;
			bool is_ipv6;
		} inet_network;
		struct {
			const struct tomoyo_path_info *address;
			u8 protocol;
			u8 operation;
		} unix_network;
		struct {
			const struct tomoyo_path_info *type;
			const struct tomoyo_path_info *dir;
			const struct tomoyo_path_info *dev;
			long unsigned int flags;
			int need_dev;
		} mount;
		struct {
			const struct tomoyo_path_info *domainname;
		} task;
	} param;
	struct tomoyo_acl_info *matched_acl;
	u8 param_type;
	bool granted;
	u8 retry;
	u8 profile;
	u8 mode;
	u8 type;
};

struct tomoyo_mini_stat {
	kuid_t uid;
	kgid_t gid;
	ino_t ino;
	umode_t mode;
	dev_t dev;
	dev_t rdev;
};

struct tomoyo_obj_info {
	bool validate_done;
	bool stat_valid[4];
	struct path path1;
	struct path path2;
	struct tomoyo_mini_stat stat[4];
	struct tomoyo_path_info *symlink_target;
};

struct tomoyo_page_dump {
	struct page *page;
	char *data;
};

struct tomoyo_execve {
	struct tomoyo_request_info r;
	struct tomoyo_obj_info obj;
	struct linux_binprm *bprm;
	const struct tomoyo_path_info *transition;
	struct tomoyo_page_dump dump;
	char *tmp;
};

struct tomoyo_policy_namespace;

struct tomoyo_domain_info {
	struct list_head list;
	struct list_head acl_info_list;
	const struct tomoyo_path_info *domainname;
	struct tomoyo_policy_namespace *ns;
	long unsigned int group[4];
	u8 profile;
	bool is_deleted;
	bool flags[2];
	atomic_t users;
};

struct tomoyo_condition;

struct tomoyo_acl_info {
	struct list_head list;
	struct tomoyo_condition *cond;
	s8 is_deleted;
	u8 type;
} __attribute__((packed));

struct tomoyo_condition {
	struct tomoyo_shared_acl_head head;
	u32 size;
	u16 condc;
	u16 numbers_count;
	u16 names_count;
	u16 argc;
	u16 envc;
	u8 grant_log;
	const struct tomoyo_path_info *transit;
};

struct tomoyo_profile;

struct tomoyo_policy_namespace {
	struct tomoyo_profile *profile_ptr[256];
	struct list_head group_list[3];
	struct list_head policy_list[11];
	struct list_head acl_group[256];
	struct list_head namespace_list;
	unsigned int profile_version;
	const char *name;
};

struct tomoyo_io_buffer {
	void (*read)(struct tomoyo_io_buffer *);
	int (*write)(struct tomoyo_io_buffer *);
	__poll_t (*poll)(struct file *, poll_table *);
	struct mutex io_sem;
	char *read_user_buf;
	size_t read_user_buf_avail;
	struct {
		struct list_head *ns;
		struct list_head *domain;
		struct list_head *group;
		struct list_head *acl;
		size_t avail;
		unsigned int step;
		unsigned int query_index;
		u16 index;
		u16 cond_index;
		u8 acl_group_index;
		u8 cond_step;
		u8 bit;
		u8 w_pos;
		bool eof;
		bool print_this_domain_only;
		bool print_transition_related_only;
		bool print_cond_part;
		const char *w[64];
	} r;
	struct {
		struct tomoyo_policy_namespace *ns;
		struct tomoyo_domain_info *domain;
		size_t avail;
		bool is_delete;
	} w;
	char *read_buf;
	size_t readbuf_size;
	char *write_buf;
	size_t writebuf_size;
	enum tomoyo_securityfs_interface_index type;
	u8 users;
	struct list_head list;
};

struct tomoyo_preference {
	unsigned int learning_max_entry;
	bool enforcing_verbose;
	bool learning_verbose;
	bool permissive_verbose;
};

struct tomoyo_profile {
	const struct tomoyo_path_info *comment;
	struct tomoyo_preference *learning;
	struct tomoyo_preference *permissive;
	struct tomoyo_preference *enforcing;
	struct tomoyo_preference preference;
	u8 default_config;
	u8 config[42];
	unsigned int pref[2];
};

struct tomoyo_time {
	u16 year;
	u8 month;
	u8 day;
	u8 hour;
	u8 min;
	u8 sec;
};

struct tomoyo_log {
	struct list_head list;
	char *log;
	int size;
};

enum tomoyo_value_type {
	TOMOYO_VALUE_TYPE_INVALID = 0,
	TOMOYO_VALUE_TYPE_DECIMAL = 1,
	TOMOYO_VALUE_TYPE_OCTAL = 2,
	TOMOYO_VALUE_TYPE_HEXADECIMAL = 3,
};

enum tomoyo_transition_type {
	TOMOYO_TRANSITION_CONTROL_NO_RESET = 0,
	TOMOYO_TRANSITION_CONTROL_RESET = 1,
	TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE = 2,
	TOMOYO_TRANSITION_CONTROL_INITIALIZE = 3,
	TOMOYO_TRANSITION_CONTROL_NO_KEEP = 4,
	TOMOYO_TRANSITION_CONTROL_KEEP = 5,
	TOMOYO_MAX_TRANSITION_TYPE = 6,
};

enum tomoyo_acl_entry_type_index {
	TOMOYO_TYPE_PATH_ACL = 0,
	TOMOYO_TYPE_PATH2_ACL = 1,
	TOMOYO_TYPE_PATH_NUMBER_ACL = 2,
	TOMOYO_TYPE_MKDEV_ACL = 3,
	TOMOYO_TYPE_MOUNT_ACL = 4,
	TOMOYO_TYPE_INET_ACL = 5,
	TOMOYO_TYPE_UNIX_ACL = 6,
	TOMOYO_TYPE_ENV_ACL = 7,
	TOMOYO_TYPE_MANUAL_TASK_ACL = 8,
};

enum tomoyo_policy_stat_type {
	TOMOYO_STAT_POLICY_UPDATES = 0,
	TOMOYO_STAT_POLICY_LEARNING = 1,
	TOMOYO_STAT_POLICY_PERMISSIVE = 2,
	TOMOYO_STAT_POLICY_ENFORCING = 3,
	TOMOYO_MAX_POLICY_STAT = 4,
};

struct tomoyo_acl_head {
	struct list_head list;
	s8 is_deleted;
} __attribute__((packed));

struct tomoyo_name {
	struct tomoyo_shared_acl_head head;
	struct tomoyo_path_info entry;
};

struct tomoyo_group;

struct tomoyo_name_union {
	const struct tomoyo_path_info *filename;
	struct tomoyo_group *group;
};

struct tomoyo_group {
	struct tomoyo_shared_acl_head head;
	const struct tomoyo_path_info *group_name;
	struct list_head member_list;
};

struct tomoyo_number_union {
	long unsigned int values[2];
	struct tomoyo_group *group;
	u8 value_type[2];
};

struct tomoyo_ipaddr_union {
	struct in6_addr ip[2];
	struct tomoyo_group *group;
	bool is_ipv6;
};

struct tomoyo_path_group {
	struct tomoyo_acl_head head;
	const struct tomoyo_path_info *member_name;
};

struct tomoyo_number_group {
	struct tomoyo_acl_head head;
	struct tomoyo_number_union number;
};

struct tomoyo_address_group {
	struct tomoyo_acl_head head;
	struct tomoyo_ipaddr_union address;
};

struct tomoyo_argv {
	long unsigned int index;
	const struct tomoyo_path_info *value;
	bool is_not;
};

struct tomoyo_envp {
	const struct tomoyo_path_info *name;
	const struct tomoyo_path_info *value;
	bool is_not;
};

struct tomoyo_condition_element {
	u8 left;
	u8 right;
	bool equals;
};

struct tomoyo_task_acl {
	struct tomoyo_acl_info head;
	const struct tomoyo_path_info *domainname;
};

struct tomoyo_path_acl {
	struct tomoyo_acl_info head;
	u16 perm;
	struct tomoyo_name_union name;
};

struct tomoyo_path_number_acl {
	struct tomoyo_acl_info head;
	u8 perm;
	struct tomoyo_name_union name;
	struct tomoyo_number_union number;
};

struct tomoyo_mkdev_acl {
	struct tomoyo_acl_info head;
	u8 perm;
	struct tomoyo_name_union name;
	struct tomoyo_number_union mode;
	struct tomoyo_number_union major;
	struct tomoyo_number_union minor;
};

struct tomoyo_path2_acl {
	struct tomoyo_acl_info head;
	u8 perm;
	struct tomoyo_name_union name1;
	struct tomoyo_name_union name2;
};

struct tomoyo_mount_acl {
	struct tomoyo_acl_info head;
	struct tomoyo_name_union dev_name;
	struct tomoyo_name_union dir_name;
	struct tomoyo_name_union fs_type;
	struct tomoyo_number_union flags;
};

struct tomoyo_env_acl {
	struct tomoyo_acl_info head;
	const struct tomoyo_path_info *env;
};

struct tomoyo_inet_acl {
	struct tomoyo_acl_info head;
	u8 protocol;
	u8 perm;
	struct tomoyo_ipaddr_union address;
	struct tomoyo_number_union port;
};

struct tomoyo_unix_acl {
	struct tomoyo_acl_info head;
	u8 protocol;
	u8 perm;
	struct tomoyo_name_union name;
};

struct tomoyo_acl_param {
	char *data;
	struct list_head *list;
	struct tomoyo_policy_namespace *ns;
	bool is_delete;
};

struct tomoyo_transition_control {
	struct tomoyo_acl_head head;
	u8 type;
	bool is_last_name;
	const struct tomoyo_path_info *domainname;
	const struct tomoyo_path_info *program;
};

struct tomoyo_aggregator {
	struct tomoyo_acl_head head;
	const struct tomoyo_path_info *original_name;
	const struct tomoyo_path_info *aggregated_name;
};

struct tomoyo_manager {
	struct tomoyo_acl_head head;
	const struct tomoyo_path_info *manager;
};

struct tomoyo_task {
	struct tomoyo_domain_info *domain_info;
	struct tomoyo_domain_info *old_domain_info;
};

struct tomoyo_query {
	struct list_head list;
	struct tomoyo_domain_info *domain;
	char *query;
	size_t query_len;
	unsigned int serial;
	u8 timer;
	u8 answer;
	u8 retry;
};

enum tomoyo_special_mount {
	TOMOYO_MOUNT_BIND = 0,
	TOMOYO_MOUNT_MOVE = 1,
	TOMOYO_MOUNT_REMOUNT = 2,
	TOMOYO_MOUNT_MAKE_UNBINDABLE = 3,
	TOMOYO_MOUNT_MAKE_PRIVATE = 4,
	TOMOYO_MOUNT_MAKE_SLAVE = 5,
	TOMOYO_MOUNT_MAKE_SHARED = 6,
	TOMOYO_MAX_SPECIAL_MOUNT = 7,
};

struct tomoyo_inet_addr_info {
	__be16 port;
	const __be32 *address;
	bool is_ipv6;
};

struct tomoyo_unix_addr_info {
	u8 *addr;
	unsigned int addr_len;
};

struct tomoyo_addr_info {
	u8 protocol;
	u8 operation;
	struct tomoyo_inet_addr_info inet;
	struct tomoyo_unix_addr_info unix0;
};

enum audit_mode {
	AUDIT_NORMAL = 0,
	AUDIT_QUIET_DENIED = 1,
	AUDIT_QUIET = 2,
	AUDIT_NOQUIET = 3,
	AUDIT_ALL = 4,
};

enum aa_sfs_type {
	AA_SFS_TYPE_BOOLEAN = 0,
	AA_SFS_TYPE_STRING = 1,
	AA_SFS_TYPE_U64 = 2,
	AA_SFS_TYPE_FOPS = 3,
	AA_SFS_TYPE_DIR = 4,
};

struct aa_sfs_entry {
	const char *name;
	struct dentry *dentry;
	umode_t mode;
	enum aa_sfs_type v_type;
	union {
		bool boolean;
		char *string;
		long unsigned int u64;
		struct aa_sfs_entry *files;
	} v;
	const struct file_operations *file_ops;
};

enum aafs_ns_type {
	AAFS_NS_DIR = 0,
	AAFS_NS_PROFS = 1,
	AAFS_NS_NS = 2,
	AAFS_NS_RAW_DATA = 3,
	AAFS_NS_LOAD = 4,
	AAFS_NS_REPLACE = 5,
	AAFS_NS_REMOVE = 6,
	AAFS_NS_REVISION = 7,
	AAFS_NS_COUNT = 8,
	AAFS_NS_MAX_COUNT = 9,
	AAFS_NS_SIZE = 10,
	AAFS_NS_MAX_SIZE = 11,
	AAFS_NS_OWNER = 12,
	AAFS_NS_SIZEOF = 13,
};

enum aafs_prof_type {
	AAFS_PROF_DIR = 0,
	AAFS_PROF_PROFS = 1,
	AAFS_PROF_NAME = 2,
	AAFS_PROF_MODE = 3,
	AAFS_PROF_ATTACH = 4,
	AAFS_PROF_HASH = 5,
	AAFS_PROF_RAW_DATA = 6,
	AAFS_PROF_RAW_HASH = 7,
	AAFS_PROF_RAW_ABI = 8,
	AAFS_PROF_SIZEOF = 9,
};

struct table_header {
	u16 td_id;
	u16 td_flags;
	u32 td_hilen;
	u32 td_lolen;
	char td_data[0];
};

struct aa_dfa {
	struct kref count;
	u16 flags;
	u32 max_oob;
	struct table_header *tables[8];
};

struct aa_policy {
	const char *name;
	char *hname;
	struct list_head list;
	struct list_head profiles;
};

struct aa_labelset {
	rwlock_t lock;
	struct rb_root root;
};

enum label_flags {
	FLAG_HAT = 1,
	FLAG_UNCONFINED = 2,
	FLAG_NULL = 4,
	FLAG_IX_ON_NAME_ERROR = 8,
	FLAG_IMMUTIBLE = 16,
	FLAG_USER_DEFINED = 32,
	FLAG_NO_LIST_REF = 64,
	FLAG_NS_COUNT = 128,
	FLAG_IN_TREE = 256,
	FLAG_PROFILE = 512,
	FLAG_EXPLICIT = 1024,
	FLAG_STALE = 2048,
	FLAG_RENAMED = 4096,
	FLAG_REVOKED = 8192,
};

struct aa_label;

struct aa_proxy {
	struct kref count;
	struct aa_label *label;
};

struct aa_profile;

struct aa_label {
	struct kref count;
	struct rb_node node;
	struct callback_head rcu;
	struct aa_proxy *proxy;
	char *hname;
	long int flags;
	u32 secid;
	int size;
	struct aa_profile *vec[0];
};

struct label_it {
	int i;
	int j;
};

struct aa_policydb {
	struct aa_dfa *dfa;
	unsigned int start[18];
};

struct aa_domain {
	int size;
	char **table;
};

struct aa_file_rules {
	unsigned int start;
	struct aa_dfa *dfa;
	struct aa_domain trans;
};

struct aa_caps {
	kernel_cap_t allow;
	kernel_cap_t audit;
	kernel_cap_t denied;
	kernel_cap_t quiet;
	kernel_cap_t kill;
	kernel_cap_t extended;
};

struct aa_rlimit {
	unsigned int mask;
	struct rlimit limits[16];
};

struct aa_ns;

struct aa_net_compat;

struct aa_secmark;

struct aa_loaddata;

struct aa_profile {
	struct aa_policy base;
	struct aa_profile *parent;
	struct aa_ns *ns;
	const char *rename;
	const char *attach;
	struct aa_dfa *xmatch;
	int xmatch_len;
	enum audit_mode audit;
	long int mode;
	u32 path_flags;
	const char *disconnected;
	int size;
	struct aa_policydb policy;
	struct aa_file_rules file;
	struct aa_caps caps;
	struct aa_net_compat *net_compat;
	int xattr_count;
	char **xattrs;
	struct aa_rlimit rlimits;
	int secmark_count;
	struct aa_secmark *secmark;
	struct aa_loaddata *rawdata;
	unsigned char *hash;
	char *dirname;
	struct dentry *dents[9];
	struct rhashtable *data;
	struct aa_label label;
};

struct aa_perms {
	u32 allow;
	u32 audit;
	u32 deny;
	u32 quiet;
	u32 kill;
	u32 stop;
	u32 complain;
	u32 cond;
	u32 hide;
	u32 prompt;
	u16 xindex;
};

struct path_cond {
	kuid_t uid;
	umode_t mode;
};

struct aa_net_compat {
	u16 allow[45];
	u16 audit[45];
	u16 quiet[45];
};

struct aa_secmark {
	u8 audit;
	u8 deny;
	u32 secid;
	char *label;
};

enum profile_mode {
	APPARMOR_ENFORCE = 0,
	APPARMOR_COMPLAIN = 1,
	APPARMOR_KILL = 2,
	APPARMOR_UNCONFINED = 3,
};

struct aa_data {
	char *key;
	u32 size;
	char *data;
	struct rhash_head head;
};

struct aa_ns_acct {
	int max_size;
	int max_count;
	int size;
	int count;
};

struct aa_ns {
	struct aa_policy base;
	struct aa_ns *parent;
	struct mutex lock;
	struct aa_ns_acct acct;
	struct aa_profile *unconfined;
	struct list_head sub_ns;
	atomic_t uniq_null;
	long int uniq_id;
	int level;
	long int revision;
	wait_queue_head_t wait;
	struct aa_labelset labels;
	struct list_head rawdata_list;
	struct dentry *dents[13];
};

struct aa_loaddata {
	struct kref count;
	struct list_head list;
	struct work_struct work;
	struct dentry *dents[6];
	struct aa_ns *ns;
	char *name;
	size_t size;
	size_t compressed_size;
	long int revision;
	int abi;
	unsigned char *hash;
	char *data;
};

enum {
	AAFS_LOADDATA_ABI = 0,
	AAFS_LOADDATA_REVISION = 1,
	AAFS_LOADDATA_HASH = 2,
	AAFS_LOADDATA_DATA = 3,
	AAFS_LOADDATA_COMPRESSED_SIZE = 4,
	AAFS_LOADDATA_DIR = 5,
	AAFS_LOADDATA_NDENTS = 6,
};

struct rawdata_f_data {
	struct aa_loaddata *loaddata;
};

struct aa_revision {
	struct aa_ns *ns;
	long int last_read;
};

struct multi_transaction {
	struct kref count;
	ssize_t size;
	char data[0];
};

struct apparmor_audit_data {
	int error;
	int type;
	const char *op;
	struct aa_label *label;
	const char *name;
	const char *info;
	u32 request;
	u32 denied;
	union {
		struct {
			struct aa_label *peer;
			union {
				struct {
					const char *target;
					kuid_t ouid;
				} fs;
				struct {
					int rlim;
					long unsigned int max;
				} rlim;
				struct {
					int signal;
					int unmappedsig;
				};
				struct {
					int type;
					int protocol;
					struct sock *peer_sk;
					void *addr;
					int addrlen;
				} net;
			};
		};
		struct {
			struct aa_profile *profile;
			const char *ns;
			long int pos;
		} iface;
		struct {
			const char *src_name;
			const char *type;
			const char *trans;
			const char *data;
			long unsigned int flags;
		} mnt;
	};
};

enum audit_type {
	AUDIT_APPARMOR_AUDIT = 0,
	AUDIT_APPARMOR_ALLOWED = 1,
	AUDIT_APPARMOR_DENIED = 2,
	AUDIT_APPARMOR_HINT = 3,
	AUDIT_APPARMOR_STATUS = 4,
	AUDIT_APPARMOR_ERROR = 5,
	AUDIT_APPARMOR_KILL = 6,
	AUDIT_APPARMOR_AUTO = 7,
};

struct aa_audit_rule {
	struct aa_label *label;
};

struct audit_cache {
	struct aa_profile *profile;
	kernel_cap_t caps;
};

struct aa_task_ctx {
	struct aa_label *nnp;
	struct aa_label *onexec;
	struct aa_label *previous;
	u64 token;
};

struct counted_str {
	struct kref count;
	char name[0];
};

struct match_workbuf {
	unsigned int count;
	unsigned int pos;
	unsigned int len;
	unsigned int size;
	unsigned int history[24];
};

enum path_flags {
	PATH_IS_DIR = 1,
	PATH_SOCK_COND = 2,
	PATH_CONNECT_PATH = 4,
	PATH_CHROOT_REL = 8,
	PATH_CHROOT_NSCONNECT = 16,
	PATH_DELEGATE_DELETED = 32768,
	PATH_MEDIATE_DELETED = 65536,
};

struct aa_load_ent {
	struct list_head list;
	struct aa_profile *new;
	struct aa_profile *old;
	struct aa_profile *rename;
	const char *ns_name;
};

enum aa_code {
	AA_U8 = 0,
	AA_U16 = 1,
	AA_U32 = 2,
	AA_U64 = 3,
	AA_NAME = 4,
	AA_STRING = 5,
	AA_BLOB = 6,
	AA_STRUCT = 7,
	AA_STRUCTEND = 8,
	AA_LIST = 9,
	AA_LISTEND = 10,
	AA_ARRAY = 11,
	AA_ARRAYEND = 12,
};

struct aa_ext {
	void *start;
	void *end;
	void *pos;
	u32 version;
};

struct aa_file_ctx {
	spinlock_t lock;
	struct aa_label *label;
	u32 allow;
};

struct aa_sk_ctx {
	struct aa_label *label;
	struct aa_label *peer;
	struct path path;
};

union aa_buffer {
	struct list_head list;
	char buffer[1];
};

struct ptrace_relation {
	struct task_struct *tracer;
	struct task_struct *tracee;
	bool invalid;
	struct list_head node;
	struct callback_head rcu;
};

struct access_report_info {
	struct callback_head work;
	const char *access;
	struct task_struct *target;
	struct task_struct *agent;
};

enum sid_policy_type {
	SIDPOL_DEFAULT = 0,
	SIDPOL_CONSTRAINED = 1,
	SIDPOL_ALLOWED = 2,
};

typedef union {
	kuid_t uid;
	kgid_t gid;
} kid_t;

enum setid_type {
	UID = 0,
	GID = 1,
};

struct setid_rule {
	struct hlist_node next;
	kid_t src_id;
	kid_t dst_id;
	enum setid_type type;
};

struct setid_ruleset {
	struct hlist_head rules[256];
	char *policy_str;
	struct callback_head rcu;
	enum setid_type type;
};

enum devcg_behavior {
	DEVCG_DEFAULT_NONE = 0,
	DEVCG_DEFAULT_ALLOW = 1,
	DEVCG_DEFAULT_DENY = 2,
};

struct dev_exception_item {
	u32 major;
	u32 minor;
	short int type;
	short int access;
	struct list_head list;
	struct callback_head rcu;
};

struct dev_cgroup {
	struct cgroup_subsys_state css;
	struct list_head exceptions;
	enum devcg_behavior behavior;
};

struct landlock_ruleset_attr {
	__u64 handled_access_fs;
};

enum landlock_rule_type {
	LANDLOCK_RULE_PATH_BENEATH = 1,
};

struct landlock_path_beneath_attr {
	__u64 allowed_access;
	__s32 parent_fd;
} __attribute__((packed));

struct landlock_hierarchy {
	struct landlock_hierarchy *parent;
	refcount_t usage;
};

struct landlock_ruleset {
	struct rb_root root;
	struct landlock_hierarchy *hierarchy;
	union {
		struct work_struct work_free;
		struct {
			struct mutex lock;
			refcount_t usage;
			u32 num_rules;
			u32 num_layers;
			u16 fs_access_masks[0];
		};
	};
};

struct landlock_cred_security {
	struct landlock_ruleset *domain;
};

struct landlock_object;

struct landlock_object_underops {
	void (*release)(struct landlock_object * const);
};

struct landlock_object {
	refcount_t usage;
	spinlock_t lock;
	void *underobj;
	union {
		struct callback_head rcu_free;
		const struct landlock_object_underops *underops;
	};
};

struct landlock_layer {
	u16 level;
	u16 access;
};

struct landlock_rule {
	struct rb_node node;
	struct landlock_object *object;
	u32 num_layers;
	struct landlock_layer layers[0];
};

struct landlock_inode_security {
	struct landlock_object *object;
};

struct landlock_superblock_security {
	atomic_long_t inode_refs;
};

enum integrity_status {
	INTEGRITY_PASS = 0,
	INTEGRITY_PASS_IMMUTABLE = 1,
	INTEGRITY_FAIL = 2,
	INTEGRITY_NOLABEL = 3,
	INTEGRITY_NOXATTRS = 4,
	INTEGRITY_UNKNOWN = 5,
};

struct ima_digest_data {
	u8 algo;
	u8 length;
	union {
		struct {
			u8 unused;
			u8 type;
		} sha1;
		struct {
			u8 type;
			u8 algo;
		} ng;
		u8 data[2];
	} xattr;
	u8 digest[0];
};

struct integrity_iint_cache {
	struct rb_node rb_node;
	struct mutex mutex;
	struct inode *inode;
	u64 version;
	long unsigned int flags;
	long unsigned int measured_pcrs;
	long unsigned int atomic_flags;
	enum integrity_status ima_file_status: 4;
	enum integrity_status ima_mmap_status: 4;
	enum integrity_status ima_bprm_status: 4;
	enum integrity_status ima_read_status: 4;
	enum integrity_status ima_creds_status: 4;
	enum integrity_status evm_status: 4;
	struct ima_digest_data *ima_hash;
};

struct modsig;

struct public_key {
	void *key;
	u32 keylen;
	enum OID algo;
	void *params;
	u32 paramlen;
	bool key_is_private;
	const char *id_type;
	const char *pkey_algo;
};

struct asymmetric_key_id;

struct public_key_signature {
	struct asymmetric_key_id *auth_ids[2];
	u8 *s;
	u8 *digest;
	u32 s_size;
	u32 digest_size;
	const char *pkey_algo;
	const char *hash_algo;
	const char *encoding;
	const void *data;
	unsigned int data_size;
};

struct asymmetric_key_id {
	short unsigned int len;
	unsigned char data[0];
};

enum asymmetric_payload_bits {
	asym_crypto = 0,
	asym_subtype = 1,
	asym_key_ids = 2,
	asym_auth = 3,
};

struct signature_v2_hdr {
	uint8_t type;
	uint8_t version;
	uint8_t hash_algo;
	__be32 keyid;
	__be16 sig_size;
	uint8_t sig[0];
} __attribute__((packed));

typedef struct {
	efi_guid_t signature_owner;
	u8 signature_data[0];
} efi_signature_data_t;

typedef struct {
	efi_guid_t signature_type;
	u32 signature_list_size;
	u32 signature_header_size;
	u32 signature_size;
	u8 signature_header[0];
} efi_signature_list_t;

typedef void (*efi_element_handler_t)(const char *, const void *, size_t);

struct efi_mokvar_table_entry {
	char name[256];
	u64 data_size;
	u8 data[0];
};

struct evm_ima_xattr_data {
	u8 type;
	u8 data[0];
};

enum ima_show_type {
	IMA_SHOW_BINARY = 0,
	IMA_SHOW_BINARY_NO_FIELD_LEN = 1,
	IMA_SHOW_BINARY_OLD_STRING_FMT = 2,
	IMA_SHOW_ASCII = 3,
};

struct ima_event_data {
	struct integrity_iint_cache *iint;
	struct file *file;
	const unsigned char *filename;
	struct evm_ima_xattr_data *xattr_value;
	int xattr_len;
	const struct modsig *modsig;
	const char *violation;
	const void *buf;
	int buf_len;
};

struct ima_field_data {
	u8 *data;
	u32 len;
};

struct ima_template_field {
	const char field_id[16];
	int (*field_init)(struct ima_event_data *, struct ima_field_data *);
	void (*field_show)(struct seq_file *, enum ima_show_type, struct ima_field_data *);
};

struct ima_template_desc {
	struct list_head list;
	char *name;
	char *fmt;
	int num_fields;
	const struct ima_template_field **fields;
};

struct ima_template_entry {
	int pcr;
	struct tpm_digest *digests;
	struct ima_template_desc *template_desc;
	u32 template_data_len;
	struct ima_field_data template_data[0];
};

struct ima_queue_entry {
	struct hlist_node hnext;
	struct list_head later;
	struct ima_template_entry *entry;
};

struct ima_h_table {
	atomic_long_t len;
	atomic_long_t violations;
	struct hlist_head queue[1024];
};

enum ima_fs_flags {
	IMA_FS_BUSY = 0,
};

enum evm_ima_xattr_type {
	IMA_XATTR_DIGEST = 1,
	EVM_XATTR_HMAC = 2,
	EVM_IMA_XATTR_DIGSIG = 3,
	IMA_XATTR_DIGEST_NG = 4,
	EVM_XATTR_PORTABLE_DIGSIG = 5,
	IMA_XATTR_LAST = 6,
};

enum ima_hooks {
	NONE = 0,
	FILE_CHECK = 1,
	MMAP_CHECK = 2,
	BPRM_CHECK = 3,
	CREDS_CHECK = 4,
	POST_SETATTR = 5,
	MODULE_CHECK = 6,
	FIRMWARE_CHECK = 7,
	KEXEC_KERNEL_CHECK = 8,
	KEXEC_INITRAMFS_CHECK = 9,
	POLICY_CHECK = 10,
	KEXEC_CMDLINE = 11,
	KEY_CHECK = 12,
	CRITICAL_DATA = 13,
	MAX_CHECK = 14,
};

enum tpm_pcrs {
	TPM_PCR0 = 0,
	TPM_PCR8 = 8,
	TPM_PCR10 = 10,
};

struct ima_algo_desc {
	struct crypto_shash *tfm;
	enum hash_algo algo;
};

enum lsm_rule_types {
	LSM_OBJ_USER = 0,
	LSM_OBJ_ROLE = 1,
	LSM_OBJ_TYPE = 2,
	LSM_SUBJ_USER = 3,
	LSM_SUBJ_ROLE = 4,
	LSM_SUBJ_TYPE = 5,
};

enum policy_types {
	ORIGINAL_TCB = 1,
	DEFAULT_TCB = 2,
};

enum policy_rule_list {
	IMA_DEFAULT_POLICY = 1,
	IMA_CUSTOM_POLICY = 2,
};

struct ima_rule_opt_list {
	size_t count;
	char *items[0];
};

struct ima_rule_entry {
	struct list_head list;
	int action;
	unsigned int flags;
	enum ima_hooks func;
	int mask;
	long unsigned int fsmagic;
	uuid_t fsuuid;
	kuid_t uid;
	kuid_t fowner;
	bool (*uid_op)(kuid_t, kuid_t);
	bool (*fowner_op)(kuid_t, kuid_t);
	int pcr;
	struct {
		void *rules[3];
		char *args_p;
		int type;
	} lsm[6];
	char *fsname;
	struct ima_rule_opt_list *keyrings;
	struct ima_rule_opt_list *label;
	struct ima_template_desc *template;
};

enum {
	Opt_measure = 0,
	Opt_dont_measure = 1,
	Opt_appraise = 2,
	Opt_dont_appraise = 3,
	Opt_audit = 4,
	Opt_hash___3 = 5,
	Opt_dont_hash = 6,
	Opt_obj_user = 7,
	Opt_obj_role = 8,
	Opt_obj_type = 9,
	Opt_subj_user = 10,
	Opt_subj_role = 11,
	Opt_subj_type = 12,
	Opt_func = 13,
	Opt_mask = 14,
	Opt_fsmagic = 15,
	Opt_fsname = 16,
	Opt_fsuuid = 17,
	Opt_uid_eq = 18,
	Opt_euid_eq = 19,
	Opt_fowner_eq = 20,
	Opt_uid_gt = 21,
	Opt_euid_gt = 22,
	Opt_fowner_gt = 23,
	Opt_uid_lt = 24,
	Opt_euid_lt = 25,
	Opt_fowner_lt = 26,
	Opt_appraise_type = 27,
	Opt_appraise_flag = 28,
	Opt_permit_directio = 29,
	Opt_pcr = 30,
	Opt_template = 31,
	Opt_keyrings = 32,
	Opt_label = 33,
	Opt_err___10 = 34,
};

struct ima_kexec_hdr {
	u16 version;
	u16 _reserved0;
	u32 _reserved1;
	u64 buffer_size;
	u64 count;
};

enum header_fields {
	HDR_PCR = 0,
	HDR_DIGEST = 1,
	HDR_TEMPLATE_NAME = 2,
	HDR_TEMPLATE_DATA = 3,
	HDR__LAST = 4,
};

enum data_formats {
	DATA_FMT_DIGEST = 0,
	DATA_FMT_DIGEST_WITH_ALGO = 1,
	DATA_FMT_STRING = 2,
	DATA_FMT_HEX = 3,
};

struct modsig___2 {
	struct pkcs7_message *pkcs7_msg;
	enum hash_algo hash_algo;
	const u8 *digest;
	u32 digest_size;
	int raw_pkcs7_len;
	u8 raw_pkcs7[0];
};

struct ima_key_entry {
	struct list_head list;
	void *payload;
	size_t payload_len;
	char *keyring_name;
};

struct evm_xattr {
	struct evm_ima_xattr_data data;
	u8 digest[20];
};

struct xattr_list {
	struct list_head list;
	char *name;
};

struct evm_digest {
	struct ima_digest_data hdr;
	char digest[64];
};

struct h_misc {
	long unsigned int ino;
	__u32 generation;
	uid_t uid;
	gid_t gid;
	umode_t mode;
};

enum {
	CRYPTO_MSG_ALG_REQUEST = 0,
	CRYPTO_MSG_ALG_REGISTER = 1,
	CRYPTO_MSG_ALG_LOADED = 2,
};

struct crypto_larval {
	struct crypto_alg alg;
	struct crypto_alg *adult;
	struct completion completion;
	u32 mask;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct crypto_cipher {
	struct crypto_tfm base;
};

enum {
	CRYPTOA_UNSPEC = 0,
	CRYPTOA_ALG = 1,
	CRYPTOA_TYPE = 2,
	CRYPTOA_U32 = 3,
	__CRYPTOA_MAX = 4,
};

struct crypto_attr_alg {
	char name[128];
};

struct crypto_attr_type {
	u32 type;
	u32 mask;
};

struct crypto_attr_u32 {
	u32 num;
};

struct rtattr {
	short unsigned int rta_len;
	short unsigned int rta_type;
};

struct crypto_queue {
	struct list_head list;
	struct list_head *backlog;
	unsigned int qlen;
	unsigned int max_qlen;
};

enum {
	NAPI_STATE_SCHED = 0,
	NAPI_STATE_MISSED = 1,
	NAPI_STATE_DISABLE = 2,
	NAPI_STATE_NPSVC = 3,
	NAPI_STATE_LISTED = 4,
	NAPI_STATE_NO_BUSY_POLL = 5,
	NAPI_STATE_IN_BUSY_POLL = 6,
	NAPI_STATE_PREFER_BUSY_POLL = 7,
	NAPI_STATE_THREADED = 8,
	NAPI_STATE_SCHED_THREADED = 9,
};

enum xps_map_type {
	XPS_CPUS = 0,
	XPS_RXQS = 1,
	XPS_MAPS_MAX = 2,
};

enum bpf_xdp_mode {
	XDP_MODE_SKB = 0,
	XDP_MODE_DRV = 1,
	XDP_MODE_HW = 2,
	__MAX_XDP_MODE = 3,
};

enum {
	NETIF_MSG_DRV_BIT = 0,
	NETIF_MSG_PROBE_BIT = 1,
	NETIF_MSG_LINK_BIT = 2,
	NETIF_MSG_TIMER_BIT = 3,
	NETIF_MSG_IFDOWN_BIT = 4,
	NETIF_MSG_IFUP_BIT = 5,
	NETIF_MSG_RX_ERR_BIT = 6,
	NETIF_MSG_TX_ERR_BIT = 7,
	NETIF_MSG_TX_QUEUED_BIT = 8,
	NETIF_MSG_INTR_BIT = 9,
	NETIF_MSG_TX_DONE_BIT = 10,
	NETIF_MSG_RX_STATUS_BIT = 11,
	NETIF_MSG_PKTDATA_BIT = 12,
	NETIF_MSG_HW_BIT = 13,
	NETIF_MSG_WOL_BIT = 14,
	NETIF_MSG_CLASS_COUNT = 15,
};

struct scatter_walk {
	struct scatterlist *sg;
	unsigned int offset;
};

struct aead_request {
	struct crypto_async_request base;
	unsigned int assoclen;
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_aead;

struct aead_alg {
	int (*setkey)(struct crypto_aead *, const u8 *, unsigned int);
	int (*setauthsize)(struct crypto_aead *, unsigned int);
	int (*encrypt)(struct aead_request *);
	int (*decrypt)(struct aead_request *);
	int (*init)(struct crypto_aead *);
	void (*exit)(struct crypto_aead *);
	unsigned int ivsize;
	unsigned int maxauthsize;
	unsigned int chunksize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct crypto_aead {
	unsigned int authsize;
	unsigned int reqsize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct aead_instance {
	void (*free)(struct aead_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[128];
			struct crypto_instance base;
		} s;
		struct aead_alg alg;
	};
};

struct crypto_aead_spawn {
	struct crypto_spawn base;
};

enum crypto_attr_type_t {
	CRYPTOCFGA_UNSPEC = 0,
	CRYPTOCFGA_PRIORITY_VAL = 1,
	CRYPTOCFGA_REPORT_LARVAL = 2,
	CRYPTOCFGA_REPORT_HASH = 3,
	CRYPTOCFGA_REPORT_BLKCIPHER = 4,
	CRYPTOCFGA_REPORT_AEAD = 5,
	CRYPTOCFGA_REPORT_COMPRESS = 6,
	CRYPTOCFGA_REPORT_RNG = 7,
	CRYPTOCFGA_REPORT_CIPHER = 8,
	CRYPTOCFGA_REPORT_AKCIPHER = 9,
	CRYPTOCFGA_REPORT_KPP = 10,
	CRYPTOCFGA_REPORT_ACOMP = 11,
	CRYPTOCFGA_STAT_LARVAL = 12,
	CRYPTOCFGA_STAT_HASH = 13,
	CRYPTOCFGA_STAT_BLKCIPHER = 14,
	CRYPTOCFGA_STAT_AEAD = 15,
	CRYPTOCFGA_STAT_COMPRESS = 16,
	CRYPTOCFGA_STAT_RNG = 17,
	CRYPTOCFGA_STAT_CIPHER = 18,
	CRYPTOCFGA_STAT_AKCIPHER = 19,
	CRYPTOCFGA_STAT_KPP = 20,
	CRYPTOCFGA_STAT_ACOMP = 21,
	__CRYPTOCFGA_MAX = 22,
};

struct crypto_report_aead {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int maxauthsize;
	unsigned int ivsize;
};

struct crypto_sync_skcipher;

struct aead_geniv_ctx {
	spinlock_t lock;
	struct crypto_aead *child;
	struct crypto_sync_skcipher *sknull;
	u8 salt[0];
};

struct crypto_rng;

struct rng_alg {
	int (*generate)(struct crypto_rng *, const u8 *, unsigned int, u8 *, unsigned int);
	int (*seed)(struct crypto_rng *, const u8 *, unsigned int);
	void (*set_ent)(struct crypto_rng *, const u8 *, unsigned int);
	unsigned int seedsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct crypto_rng {
	struct crypto_tfm base;
};

struct crypto_cipher_spawn {
	struct crypto_spawn base;
};

struct crypto_sync_skcipher {
	struct crypto_skcipher base;
};

struct skcipher_instance {
	void (*free)(struct skcipher_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[128];
			struct crypto_instance base;
		} s;
		struct skcipher_alg alg;
	};
};

struct crypto_skcipher_spawn {
	struct crypto_spawn base;
};

struct skcipher_walk {
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} src;
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} dst;
	struct scatter_walk in;
	unsigned int nbytes;
	struct scatter_walk out;
	unsigned int total;
	struct list_head buffers;
	u8 *page;
	u8 *buffer;
	u8 *oiv;
	void *iv;
	unsigned int ivsize;
	int flags;
	unsigned int blocksize;
	unsigned int stride;
	unsigned int alignmask;
};

struct skcipher_ctx_simple {
	struct crypto_cipher *cipher;
};

struct crypto_report_blkcipher {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
};

enum {
	SKCIPHER_WALK_PHYS = 1,
	SKCIPHER_WALK_SLOW = 2,
	SKCIPHER_WALK_COPY = 4,
	SKCIPHER_WALK_DIFF = 8,
	SKCIPHER_WALK_SLEEP = 16,
};

struct skcipher_walk_buffer {
	struct list_head entry;
	struct scatter_walk dst;
	unsigned int len;
	u8 *data;
	u8 buffer[0];
};

struct ahash_alg {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_ahash *);
	void (*exit_tfm)(struct crypto_ahash *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct hash_alg_common halg;
};

struct crypto_hash_walk {
	char *data;
	unsigned int offset;
	unsigned int alignmask;
	struct page *pg;
	unsigned int entrylen;
	unsigned int total;
	struct scatterlist *sg;
	unsigned int flags;
};

struct ahash_instance {
	void (*free)(struct ahash_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[256];
			struct crypto_instance base;
		} s;
		struct ahash_alg alg;
	};
};

struct crypto_ahash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_hash {
	char type[64];
	unsigned int blocksize;
	unsigned int digestsize;
};

struct ahash_request_priv {
	crypto_completion_t complete;
	void *data;
	u8 *result;
	u32 flags;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *ubuf[0];
};

struct shash_instance {
	void (*free)(struct shash_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[256];
			struct crypto_instance base;
		} s;
		struct shash_alg alg;
	};
};

struct crypto_shash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_akcipher {
	char type[64];
};

struct akcipher_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_akcipher {
	struct crypto_tfm base;
};

struct akcipher_alg {
	int (*sign)(struct akcipher_request *);
	int (*verify)(struct akcipher_request *);
	int (*encrypt)(struct akcipher_request *);
	int (*decrypt)(struct akcipher_request *);
	int (*set_pub_key)(struct crypto_akcipher *, const void *, unsigned int);
	int (*set_priv_key)(struct crypto_akcipher *, const void *, unsigned int);
	unsigned int (*max_size)(struct crypto_akcipher *);
	int (*init)(struct crypto_akcipher *);
	void (*exit)(struct crypto_akcipher *);
	unsigned int reqsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct akcipher_instance {
	void (*free)(struct akcipher_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[128];
			struct crypto_instance base;
		} s;
		struct akcipher_alg alg;
	};
};

struct crypto_akcipher_spawn {
	struct crypto_spawn base;
};

struct crypto_report_kpp {
	char type[64];
};

typedef long unsigned int mpi_limb_t;

struct gcry_mpi {
	int alloced;
	int nlimbs;
	int nbits;
	int sign;
	unsigned int flags;
	mpi_limb_t *d;
};

typedef struct gcry_mpi *MPI;

struct dh_ctx {
	MPI p;
	MPI q;
	MPI g;
	MPI xa;
};

enum {
	CRYPTO_KPP_SECRET_TYPE_UNKNOWN = 0,
	CRYPTO_KPP_SECRET_TYPE_DH = 1,
	CRYPTO_KPP_SECRET_TYPE_ECDH = 2,
};

struct kpp_secret {
	short unsigned int type;
	short unsigned int len;
};

enum rsapubkey_actions {
	ACT_rsa_get_e = 0,
	ACT_rsa_get_n = 1,
	NR__rsapubkey_actions = 2,
};

enum rsaprivkey_actions {
	ACT_rsa_get_d = 0,
	ACT_rsa_get_dp = 1,
	ACT_rsa_get_dq = 2,
	ACT_rsa_get_e___2 = 3,
	ACT_rsa_get_n___2 = 4,
	ACT_rsa_get_p = 5,
	ACT_rsa_get_q = 6,
	ACT_rsa_get_qinv = 7,
	NR__rsaprivkey_actions = 8,
};

struct rsa_key {
	const u8 *n;
	const u8 *e;
	const u8 *d;
	const u8 *p;
	const u8 *q;
	const u8 *dp;
	const u8 *dq;
	const u8 *qinv;
	size_t n_sz;
	size_t e_sz;
	size_t d_sz;
	size_t p_sz;
	size_t q_sz;
	size_t dp_sz;
	size_t dq_sz;
	size_t qinv_sz;
};

struct rsa_mpi_key {
	MPI n;
	MPI e;
	MPI d;
};

struct crypto_template___2;

struct asn1_decoder___2;

struct rsa_asn1_template {
	const char *name;
	const u8 *data;
	size_t size;
};

struct pkcs1pad_ctx {
	struct crypto_akcipher *child;
	unsigned int key_size;
};

struct pkcs1pad_inst_ctx {
	struct crypto_akcipher_spawn spawn;
	const struct rsa_asn1_template *digest_info;
};

struct pkcs1pad_request {
	struct scatterlist in_sg[2];
	struct scatterlist out_sg[1];
	uint8_t *in_buf;
	uint8_t *out_buf;
	long: 64;
	long: 64;
	struct akcipher_request child_req;
};

struct crypto_report_acomp {
	char type[64];
};

struct acomp_alg {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	int (*init)(struct crypto_acomp *);
	void (*exit)(struct crypto_acomp *);
	unsigned int reqsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct crypto_report_comp {
	char type[64];
};

struct crypto_scomp {
	struct crypto_tfm base;
};

struct scomp_alg {
	void * (*alloc_ctx)(struct crypto_scomp *);
	void (*free_ctx)(struct crypto_scomp *, void *);
	int (*compress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	int (*decompress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct scomp_scratch {
	spinlock_t lock;
	void *src;
	void *dst;
};

struct cryptomgr_param {
	struct rtattr *tb[34];
	struct {
		struct rtattr attr;
		struct crypto_attr_type data;
	} type;
	union {
		struct rtattr attr;
		struct {
			struct rtattr attr;
			struct crypto_attr_alg data;
		} alg;
		struct {
			struct rtattr attr;
			struct crypto_attr_u32 data;
		} nu32;
	} attrs[32];
	char template[128];
	struct crypto_larval *larval;
	u32 otype;
	u32 omask;
};

struct crypto_test_param {
	char driver[128];
	char alg[128];
	u32 type;
};

struct hmac_ctx {
	struct crypto_shash *hash;
};

struct md5_state {
	u32 hash[4];
	u32 block[16];
	u64 byte_count;
};

struct sha1_state {
	u32 state[5];
	u64 count;
	u8 buffer[64];
};

typedef void sha1_block_fn(struct sha1_state *, const u8 *, int);

struct sha256_state {
	u32 state[8];
	u64 count;
	u8 buf[64];
};

struct sha512_state {
	u64 state[8];
	u64 count[2];
	u8 buf[128];
};

typedef void sha512_block_fn(struct sha512_state *, const u8 *, int);

typedef struct {
	u64 a;
	u64 b;
} u128;

typedef struct {
	__be64 a;
	__be64 b;
} be128;

typedef struct {
	__le64 b;
	__le64 a;
} le128;

struct gf128mul_4k {
	be128 t[256];
};

struct gf128mul_64k {
	struct gf128mul_4k *t[16];
};

struct crypto_cts_ctx {
	struct crypto_skcipher *child;
};

struct crypto_cts_reqctx {
	struct scatterlist sg[2];
	unsigned int offset;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct skcipher_request subreq;
};

struct xts_tfm_ctx {
	struct crypto_skcipher *child;
	struct crypto_cipher *tweak;
};

struct xts_instance_ctx {
	struct crypto_skcipher_spawn spawn;
	char name[128];
};

struct xts_request_ctx {
	le128 t;
	struct scatterlist *tail;
	struct scatterlist sg[2];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct skcipher_request subreq;
};

struct crypto_rfc3686_ctx {
	struct crypto_skcipher *child;
	u8 nonce[4];
};

struct crypto_rfc3686_req_ctx {
	u8 iv[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct skcipher_request subreq;
};

struct gcm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn ghash;
};

struct crypto_gcm_ctx {
	struct crypto_skcipher *ctr;
	struct crypto_ahash *ghash;
};

struct crypto_rfc4106_ctx {
	struct crypto_aead *child;
	u8 nonce[4];
};

struct crypto_rfc4106_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct aead_request subreq;
};

struct crypto_rfc4543_instance_ctx {
	struct crypto_aead_spawn aead;
};

struct crypto_rfc4543_ctx {
	struct crypto_aead *child;
	struct crypto_sync_skcipher *null;
	u8 nonce[4];
};

struct crypto_rfc4543_req_ctx {
	struct aead_request subreq;
};

struct crypto_gcm_ghash_ctx {
	unsigned int cryptlen;
	struct scatterlist *src;
	int (*complete)(struct aead_request *, u32);
};

struct crypto_gcm_req_priv_ctx {
	u8 iv[16];
	u8 auth_tag[16];
	u8 iauth_tag[16];
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct scatterlist sg;
	struct crypto_gcm_ghash_ctx ghash_ctx;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	} u;
};

struct crypto_aes_ctx {
	u32 key_enc[60];
	u32 key_dec[60];
	u32 key_length;
};

struct deflate_ctx {
	struct z_stream_s comp_stream;
	struct z_stream_s decomp_stream;
};

struct chksum_ctx {
	u32 key;
};

struct chksum_desc_ctx {
	u32 crc;
};

struct chksum_desc_ctx___2 {
	__u16 crc;
};

struct lzo_ctx {
	void *lzo_comp_mem;
};

struct lzorle_ctx {
	void *lzorle_comp_mem;
};

struct crypto_report_rng {
	char type[64];
	unsigned int seedsize;
};

struct random_ready_callback {
	struct list_head list;
	void (*func)(struct random_ready_callback *);
	struct module *owner;
};

struct drbg_string {
	const unsigned char *buf;
	size_t len;
	struct list_head list;
};

typedef uint32_t drbg_flag_t;

struct drbg_core {
	drbg_flag_t flags;
	__u8 statelen;
	__u8 blocklen_bytes;
	char cra_name[128];
	char backend_cra_name[128];
};

struct drbg_state;

struct drbg_state_ops {
	int (*update)(struct drbg_state *, struct list_head *, int);
	int (*generate)(struct drbg_state *, unsigned char *, unsigned int, struct list_head *);
	int (*crypto_init)(struct drbg_state *);
	int (*crypto_fini)(struct drbg_state *);
};

struct drbg_state {
	struct mutex drbg_mutex;
	unsigned char *V;
	unsigned char *Vbuf;
	unsigned char *C;
	unsigned char *Cbuf;
	size_t reseed_ctr;
	size_t reseed_threshold;
	unsigned char *scratchpad;
	unsigned char *scratchpadbuf;
	void *priv_data;
	struct crypto_skcipher *ctr_handle;
	struct skcipher_request *ctr_req;
	__u8 *outscratchpadbuf;
	__u8 *outscratchpad;
	struct crypto_wait ctr_wait;
	struct scatterlist sg_in;
	struct scatterlist sg_out;
	bool seeded;
	bool pr;
	bool fips_primed;
	unsigned char *prev;
	struct work_struct seed_work;
	struct crypto_rng *jent;
	const struct drbg_state_ops *d_ops;
	const struct drbg_core *core;
	struct drbg_string test_data;
	struct random_ready_callback random_ready;
};

enum drbg_prefixes {
	DRBG_PREFIX0 = 0,
	DRBG_PREFIX1 = 1,
	DRBG_PREFIX2 = 2,
	DRBG_PREFIX3 = 3,
};

struct s {
	__be32 conv;
};

struct rand_data {
	__u64 data;
	__u64 old_data;
	__u64 prev_time;
	__u64 last_delta;
	__s64 last_delta2;
	unsigned int osr;
	unsigned char *mem;
	unsigned int memlocation;
	unsigned int memblocks;
	unsigned int memblocksize;
	unsigned int memaccessloops;
	int rct_count;
	unsigned int apt_observations;
	unsigned int apt_count;
	unsigned int apt_base;
	unsigned int apt_base_set: 1;
	unsigned int health_failure: 1;
};

struct rand_data___2;

struct jitterentropy {
	spinlock_t jent_lock;
	struct rand_data___2 *entropy_collector;
	unsigned int reset_cnt;
};

struct ghash_ctx {
	struct gf128mul_4k *gf128;
};

struct ghash_desc_ctx {
	u8 buffer[16];
	u32 bytes;
};

struct asymmetric_key_ids {
	void *id[2];
};

struct asymmetric_key_subtype___2 {
	struct module *owner;
	const char *name;
	short unsigned int name_len;
	void (*describe)(const struct key *, struct seq_file *);
	void (*destroy)(void *, void *);
	int (*query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*verify_signature)(const struct key *, const struct public_key_signature *);
};

struct asymmetric_key_parser {
	struct list_head link;
	struct module *owner;
	const char *name;
	int (*parse)(struct key_preparsed_payload *);
};

enum x509_actions {
	ACT_x509_extract_key_data = 0,
	ACT_x509_extract_name_segment = 1,
	ACT_x509_note_OID = 2,
	ACT_x509_note_issuer = 3,
	ACT_x509_note_not_after = 4,
	ACT_x509_note_not_before = 5,
	ACT_x509_note_params = 6,
	ACT_x509_note_pkey_algo = 7,
	ACT_x509_note_serial = 8,
	ACT_x509_note_signature = 9,
	ACT_x509_note_subject = 10,
	ACT_x509_note_tbs_certificate = 11,
	ACT_x509_process_extension = 12,
	NR__x509_actions = 13,
};

enum x509_akid_actions {
	ACT_x509_akid_note_kid = 0,
	ACT_x509_akid_note_name = 1,
	ACT_x509_akid_note_serial = 2,
	ACT_x509_extract_name_segment___2 = 3,
	ACT_x509_note_OID___2 = 4,
	NR__x509_akid_actions = 5,
};

struct x509_certificate {
	struct x509_certificate *next;
	struct x509_certificate *signer;
	struct public_key *pub;
	struct public_key_signature *sig;
	char *issuer;
	char *subject;
	struct asymmetric_key_id *id;
	struct asymmetric_key_id *skid;
	time64_t valid_from;
	time64_t valid_to;
	const void *tbs;
	unsigned int tbs_size;
	unsigned int raw_sig_size;
	const void *raw_sig;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_subject;
	unsigned int raw_subject_size;
	unsigned int raw_skid_size;
	const void *raw_skid;
	unsigned int index;
	bool seen;
	bool verified;
	bool self_signed;
	bool unsupported_key;
	bool unsupported_sig;
	bool blacklisted;
};

struct x509_parse_context {
	struct x509_certificate *cert;
	long unsigned int data;
	const void *cert_start;
	const void *key;
	size_t key_size;
	const void *params;
	size_t params_size;
	enum OID key_algo;
	enum OID last_oid;
	enum OID algo_oid;
	unsigned char nr_mpi;
	u8 o_size;
	u8 cn_size;
	u8 email_size;
	u16 o_offset;
	u16 cn_offset;
	u16 email_offset;
	unsigned int raw_akid_size;
	const void *raw_akid;
	const void *akid_raw_issuer;
	unsigned int akid_raw_issuer_size;
};

enum pkcs7_actions {
	ACT_pkcs7_check_content_type = 0,
	ACT_pkcs7_extract_cert = 1,
	ACT_pkcs7_note_OID = 2,
	ACT_pkcs7_note_certificate_list = 3,
	ACT_pkcs7_note_content = 4,
	ACT_pkcs7_note_data = 5,
	ACT_pkcs7_note_signed_info = 6,
	ACT_pkcs7_note_signeddata_version = 7,
	ACT_pkcs7_note_signerinfo_version = 8,
	ACT_pkcs7_sig_note_authenticated_attr = 9,
	ACT_pkcs7_sig_note_digest_algo = 10,
	ACT_pkcs7_sig_note_issuer = 11,
	ACT_pkcs7_sig_note_pkey_algo = 12,
	ACT_pkcs7_sig_note_serial = 13,
	ACT_pkcs7_sig_note_set_of_authattrs = 14,
	ACT_pkcs7_sig_note_signature = 15,
	ACT_pkcs7_sig_note_skid = 16,
	NR__pkcs7_actions = 17,
};

struct pkcs7_signed_info {
	struct pkcs7_signed_info *next;
	struct x509_certificate *signer;
	unsigned int index;
	bool unsupported_crypto;
	bool blacklisted;
	const void *msgdigest;
	unsigned int msgdigest_len;
	unsigned int authattrs_len;
	const void *authattrs;
	long unsigned int aa_set;
	time64_t signing_time;
	struct public_key_signature *sig;
};

struct pkcs7_message___2 {
	struct x509_certificate *certs;
	struct x509_certificate *crl;
	struct pkcs7_signed_info *signed_infos;
	u8 version;
	bool have_authattrs;
	enum OID data_type;
	size_t data_len;
	size_t data_hdrlen;
	const void *data;
};

struct pkcs7_parse_context {
	struct pkcs7_message___2 *msg;
	struct pkcs7_signed_info *sinfo;
	struct pkcs7_signed_info **ppsinfo;
	struct x509_certificate *certs;
	struct x509_certificate **ppcerts;
	long unsigned int data;
	enum OID last_oid;
	unsigned int x509_index;
	unsigned int sinfo_index;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_skid;
	unsigned int raw_skid_size;
	bool expect_skid;
};

struct mz_hdr {
	uint16_t magic;
	uint16_t lbsize;
	uint16_t blocks;
	uint16_t relocs;
	uint16_t hdrsize;
	uint16_t min_extra_pps;
	uint16_t max_extra_pps;
	uint16_t ss;
	uint16_t sp;
	uint16_t checksum;
	uint16_t ip;
	uint16_t cs;
	uint16_t reloc_table_offset;
	uint16_t overlay_num;
	uint16_t reserved0[4];
	uint16_t oem_id;
	uint16_t oem_info;
	uint16_t reserved1[10];
	uint32_t peaddr;
	char message[0];
};

struct pe_hdr {
	uint32_t magic;
	uint16_t machine;
	uint16_t sections;
	uint32_t timestamp;
	uint32_t symbol_table;
	uint32_t symbols;
	uint16_t opt_hdr_size;
	uint16_t flags;
};

struct pe32_opt_hdr {
	uint16_t magic;
	uint8_t ld_major;
	uint8_t ld_minor;
	uint32_t text_size;
	uint32_t data_size;
	uint32_t bss_size;
	uint32_t entry_point;
	uint32_t code_base;
	uint32_t data_base;
	uint32_t image_base;
	uint32_t section_align;
	uint32_t file_align;
	uint16_t os_major;
	uint16_t os_minor;
	uint16_t image_major;
	uint16_t image_minor;
	uint16_t subsys_major;
	uint16_t subsys_minor;
	uint32_t win32_version;
	uint32_t image_size;
	uint32_t header_size;
	uint32_t csum;
	uint16_t subsys;
	uint16_t dll_flags;
	uint32_t stack_size_req;
	uint32_t stack_size;
	uint32_t heap_size_req;
	uint32_t heap_size;
	uint32_t loader_flags;
	uint32_t data_dirs;
};

struct pe32plus_opt_hdr {
	uint16_t magic;
	uint8_t ld_major;
	uint8_t ld_minor;
	uint32_t text_size;
	uint32_t data_size;
	uint32_t bss_size;
	uint32_t entry_point;
	uint32_t code_base;
	uint64_t image_base;
	uint32_t section_align;
	uint32_t file_align;
	uint16_t os_major;
	uint16_t os_minor;
	uint16_t image_major;
	uint16_t image_minor;
	uint16_t subsys_major;
	uint16_t subsys_minor;
	uint32_t win32_version;
	uint32_t image_size;
	uint32_t header_size;
	uint32_t csum;
	uint16_t subsys;
	uint16_t dll_flags;
	uint64_t stack_size_req;
	uint64_t stack_size;
	uint64_t heap_size_req;
	uint64_t heap_size;
	uint32_t loader_flags;
	uint32_t data_dirs;
};

struct data_dirent {
	uint32_t virtual_address;
	uint32_t size;
};

struct data_directory {
	struct data_dirent exports;
	struct data_dirent imports;
	struct data_dirent resources;
	struct data_dirent exceptions;
	struct data_dirent certs;
	struct data_dirent base_relocations;
	struct data_dirent debug;
	struct data_dirent arch;
	struct data_dirent global_ptr;
	struct data_dirent tls;
	struct data_dirent load_config;
	struct data_dirent bound_imports;
	struct data_dirent import_addrs;
	struct data_dirent delay_imports;
	struct data_dirent clr_runtime_hdr;
	struct data_dirent reserved;
};

struct section_header {
	char name[8];
	uint32_t virtual_size;
	uint32_t virtual_address;
	uint32_t raw_data_size;
	uint32_t data_addr;
	uint32_t relocs;
	uint32_t line_numbers;
	uint16_t num_relocs;
	uint16_t num_lin_numbers;
	uint32_t flags;
};

struct win_certificate {
	uint32_t length;
	uint16_t revision;
	uint16_t cert_type;
};

struct pefile_context {
	unsigned int header_size;
	unsigned int image_checksum_offset;
	unsigned int cert_dirent_offset;
	unsigned int n_data_dirents;
	unsigned int n_sections;
	unsigned int certs_size;
	unsigned int sig_offset;
	unsigned int sig_len;
	const struct section_header *secs;
	const void *digest;
	unsigned int digest_len;
	const char *digest_algo;
};

enum mscode_actions {
	ACT_mscode_note_content_type = 0,
	ACT_mscode_note_digest = 1,
	ACT_mscode_note_digest_algo = 2,
	NR__mscode_actions = 3,
};

enum rq_qos_id {
	RQ_QOS_WBT = 0,
	RQ_QOS_LATENCY = 1,
	RQ_QOS_COST = 2,
};

struct rq_qos_ops;

struct rq_qos {
	struct rq_qos_ops *ops;
	struct request_queue *q;
	enum rq_qos_id id;
	struct rq_qos *next;
	struct dentry *debugfs_dir;
};

enum hctx_type {
	HCTX_TYPE_DEFAULT = 0,
	HCTX_TYPE_READ = 1,
	HCTX_TYPE_POLL = 2,
	HCTX_MAX_TYPES = 3,
};

struct rq_qos_ops {
	void (*throttle)(struct rq_qos *, struct bio *);
	void (*track)(struct rq_qos *, struct request *, struct bio *);
	void (*merge)(struct rq_qos *, struct request *, struct bio *);
	void (*issue)(struct rq_qos *, struct request *);
	void (*requeue)(struct rq_qos *, struct request *);
	void (*done)(struct rq_qos *, struct request *);
	void (*done_bio)(struct rq_qos *, struct bio *);
	void (*cleanup)(struct rq_qos *, struct bio *);
	void (*queue_depth_changed)(struct rq_qos *);
	void (*exit)(struct rq_qos *);
	const struct blk_mq_debugfs_attr *debugfs_attrs;
};

struct biovec_slab {
	int nr_vecs;
	char *name;
	struct kmem_cache *slab;
};

struct bio_slab {
	struct kmem_cache *slab;
	unsigned int slab_ref;
	unsigned int slab_size;
	char name[8];
};

enum {
	BLK_MQ_F_SHOULD_MERGE = 1,
	BLK_MQ_F_TAG_QUEUE_SHARED = 2,
	BLK_MQ_F_STACKING = 4,
	BLK_MQ_F_TAG_HCTX_SHARED = 8,
	BLK_MQ_F_BLOCKING = 32,
	BLK_MQ_F_NO_SCHED = 64,
	BLK_MQ_F_ALLOC_POLICY_START_BIT = 8,
	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
	BLK_MQ_S_STOPPED = 0,
	BLK_MQ_S_TAG_ACTIVE = 1,
	BLK_MQ_S_SCHED_RESTART = 2,
	BLK_MQ_S_INACTIVE = 3,
	BLK_MQ_MAX_DEPTH = 10240,
	BLK_MQ_CPU_WORK_BATCH = 8,
};

enum {
	WBT_RWQ_BG = 0,
	WBT_RWQ_KSWAPD = 1,
	WBT_RWQ_DISCARD = 2,
	WBT_NUM_RWQ = 3,
};

struct req_iterator {
	struct bvec_iter iter;
	struct bio *bio;
};

struct blk_plug_cb;

typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);

struct blk_plug_cb {
	struct list_head list;
	blk_plug_cb_fn callback;
	void *data;
};

enum {
	BLK_MQ_REQ_NOWAIT = 1,
	BLK_MQ_REQ_RESERVED = 2,
	BLK_MQ_REQ_PM = 4,
};

struct trace_event_raw_block_buffer {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	size_t size;
	char __data[0];
};

struct trace_event_raw_block_rq_requeue {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	unsigned int bytes;
	char rwbs[8];
	char comm[16];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_bio_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_bio {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_plug {
	struct trace_entry ent;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_unplug {
	struct trace_entry ent;
	int nr_rq;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_split {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	sector_t new_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_rq_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	unsigned int nr_bios;
	char rwbs[8];
	char __data[0];
};

struct trace_event_data_offsets_block_buffer {};

struct trace_event_data_offsets_block_rq_requeue {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq_complete {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq {
	u32 cmd;
};

struct trace_event_data_offsets_block_bio_complete {};

struct trace_event_data_offsets_block_bio {};

struct trace_event_data_offsets_block_plug {};

struct trace_event_data_offsets_block_unplug {};

struct trace_event_data_offsets_block_split {};

struct trace_event_data_offsets_block_bio_remap {};

struct trace_event_data_offsets_block_rq_remap {};

typedef void (*btf_trace_block_touch_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_dirty_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_rq_requeue)(void *, struct request *);

typedef void (*btf_trace_block_rq_complete)(void *, struct request *, int, unsigned int);

typedef void (*btf_trace_block_rq_insert)(void *, struct request *);

typedef void (*btf_trace_block_rq_issue)(void *, struct request *);

typedef void (*btf_trace_block_rq_merge)(void *, struct request *);

typedef void (*btf_trace_block_bio_complete)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_bio_bounce)(void *, struct bio *);

typedef void (*btf_trace_block_bio_backmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_frontmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_queue)(void *, struct bio *);

typedef void (*btf_trace_block_getrq)(void *, struct bio *);

typedef void (*btf_trace_block_plug)(void *, struct request_queue *);

typedef void (*btf_trace_block_unplug)(void *, struct request_queue *, unsigned int, bool);

typedef void (*btf_trace_block_split)(void *, struct bio *, unsigned int);

typedef void (*btf_trace_block_bio_remap)(void *, struct bio *, dev_t, sector_t);

typedef void (*btf_trace_block_rq_remap)(void *, struct request *, dev_t, sector_t);

enum {
	BLK_MQ_NO_TAG = 4294967295,
	BLK_MQ_TAG_MIN = 1,
	BLK_MQ_TAG_MAX = 4294967294,
};

struct queue_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct request_queue *, char *);
	ssize_t (*store)(struct request_queue *, const char *, size_t);
};

enum {
	REQ_FSEQ_PREFLUSH = 1,
	REQ_FSEQ_DATA = 2,
	REQ_FSEQ_POSTFLUSH = 4,
	REQ_FSEQ_DONE = 8,
	REQ_FSEQ_ACTIONS = 7,
	FLUSH_PENDING_TIMEOUT = 1250,
};

enum {
	ICQ_EXITED = 4,
	ICQ_DESTROYED = 8,
};

struct rq_map_data {
	struct page **pages;
	int page_order;
	int nr_entries;
	long unsigned int offset;
	int null_mapped;
	int from_user;
};

struct bio_map_data {
	bool is_our_pages: 1;
	bool is_null_mapped: 1;
	struct iov_iter iter;
	struct iovec iov[0];
};

enum bio_merge_status {
	BIO_MERGE_OK = 0,
	BIO_MERGE_NONE = 1,
	BIO_MERGE_FAILED = 2,
};

typedef bool (*sb_for_each_fn)(struct sbitmap *, unsigned int, void *);

enum {
	BLK_MQ_UNIQUE_TAG_BITS = 16,
	BLK_MQ_UNIQUE_TAG_MASK = 65535,
};

struct mq_inflight {
	struct block_device *part;
	unsigned int inflight[2];
};

struct flush_busy_ctx_data {
	struct blk_mq_hw_ctx *hctx;
	struct list_head *list;
};

struct dispatch_rq_data {
	struct blk_mq_hw_ctx *hctx;
	struct request *rq;
};

enum prep_dispatch {
	PREP_DISPATCH_OK = 0,
	PREP_DISPATCH_NO_TAG = 1,
	PREP_DISPATCH_NO_BUDGET = 2,
};

struct rq_iter_data {
	struct blk_mq_hw_ctx *hctx;
	bool has_rq;
};

struct blk_mq_qe_pair {
	struct list_head node;
	struct request_queue *q;
	struct elevator_type *type;
};

struct sbq_wait {
	struct sbitmap_queue *sbq;
	struct wait_queue_entry wait;
};

typedef bool busy_iter_fn(struct blk_mq_hw_ctx *, struct request *, void *, bool);

typedef bool busy_tag_iter_fn(struct request *, void *, bool);

struct bt_iter_data {
	struct blk_mq_hw_ctx *hctx;
	busy_iter_fn *fn;
	void *data;
	bool reserved;
};

struct bt_tags_iter_data {
	struct blk_mq_tags *tags;
	busy_tag_iter_fn *fn;
	void *data;
	unsigned int flags;
};

struct blk_queue_stats {
	struct list_head callbacks;
	spinlock_t lock;
	bool enable_accounting;
};

struct blk_mq_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_ctx *, char *);
	ssize_t (*store)(struct blk_mq_ctx *, const char *, size_t);
};

struct blk_mq_hw_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_hw_ctx *, char *);
	ssize_t (*store)(struct blk_mq_hw_ctx *, const char *, size_t);
};

typedef u32 compat_caddr_t;

struct hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	long unsigned int start;
};

struct blkpg_ioctl_arg {
	int op;
	int flags;
	int datalen;
	void *data;
};

struct blkpg_partition {
	long long int start;
	long long int length;
	int pno;
	char devname[64];
	char volname[64];
};

struct pr_reservation {
	__u64 key;
	__u32 type;
	__u32 flags;
};

struct pr_registration {
	__u64 old_key;
	__u64 new_key;
	__u32 flags;
	__u32 __pad;
};

struct pr_preempt {
	__u64 old_key;
	__u64 new_key;
	__u32 type;
	__u32 flags;
};

struct pr_clear {
	__u64 key;
	__u32 flags;
	__u32 __pad;
};

struct compat_blkpg_ioctl_arg {
	compat_int_t op;
	compat_int_t flags;
	compat_int_t datalen;
	compat_caddr_t data;
};

struct compat_hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	u32 start;
};

struct klist_node;

struct klist {
	spinlock_t k_lock;
	struct list_head k_list;
	void (*get)(struct klist_node *);
	void (*put)(struct klist_node *);
};

struct klist_node {
	void *n_klist;
	struct list_head n_node;
	struct kref n_ref;
};

struct klist_iter {
	struct klist *i_klist;
	struct klist_node *i_cur;
};

struct class_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

enum {
	DISK_EVENT_FLAG_POLL = 1,
	DISK_EVENT_FLAG_UEVENT = 2,
};

struct disk_events {
	struct list_head node;
	struct gendisk *disk;
	spinlock_t lock;
	struct mutex block_mutex;
	int block;
	unsigned int pending;
	unsigned int clearing;
	long int poll_msecs;
	struct delayed_work dwork;
};

struct badblocks {
	struct device *dev;
	int count;
	int unacked_exist;
	int shift;
	u64 *page;
	int changed;
	seqlock_t lock;
	sector_t sector;
	sector_t size;
};

struct blk_major_name {
	struct blk_major_name *next;
	int major;
	char name[16];
	void (*probe)(dev_t);
};

enum {
	IOPRIO_WHO_PROCESS = 1,
	IOPRIO_WHO_PGRP = 2,
	IOPRIO_WHO_USER = 3,
};

struct parsed_partitions {
	struct block_device *bdev;
	char name[32];
	struct {
		sector_t from;
		sector_t size;
		int flags;
		bool has_info;
		struct partition_meta_info info;
	} *parts;
	int next;
	int limit;
	bool access_beyond_eod;
	char *pp_buf;
};

typedef struct {
	struct page *v;
} Sector;

struct RigidDiskBlock {
	__u32 rdb_ID;
	__be32 rdb_SummedLongs;
	__s32 rdb_ChkSum;
	__u32 rdb_HostID;
	__be32 rdb_BlockBytes;
	__u32 rdb_Flags;
	__u32 rdb_BadBlockList;
	__be32 rdb_PartitionList;
	__u32 rdb_FileSysHeaderList;
	__u32 rdb_DriveInit;
	__u32 rdb_Reserved1[6];
	__u32 rdb_Cylinders;
	__u32 rdb_Sectors;
	__u32 rdb_Heads;
	__u32 rdb_Interleave;
	__u32 rdb_Park;
	__u32 rdb_Reserved2[3];
	__u32 rdb_WritePreComp;
	__u32 rdb_ReducedWrite;
	__u32 rdb_StepRate;
	__u32 rdb_Reserved3[5];
	__u32 rdb_RDBBlocksLo;
	__u32 rdb_RDBBlocksHi;
	__u32 rdb_LoCylinder;
	__u32 rdb_HiCylinder;
	__u32 rdb_CylBlocks;
	__u32 rdb_AutoParkSeconds;
	__u32 rdb_HighRDSKBlock;
	__u32 rdb_Reserved4;
	char rdb_DiskVendor[8];
	char rdb_DiskProduct[16];
	char rdb_DiskRevision[4];
	char rdb_ControllerVendor[8];
	char rdb_ControllerProduct[16];
	char rdb_ControllerRevision[4];
	__u32 rdb_Reserved5[10];
};

struct PartitionBlock {
	__be32 pb_ID;
	__be32 pb_SummedLongs;
	__s32 pb_ChkSum;
	__u32 pb_HostID;
	__be32 pb_Next;
	__u32 pb_Flags;
	__u32 pb_Reserved1[2];
	__u32 pb_DevFlags;
	__u8 pb_DriveName[32];
	__u32 pb_Reserved2[15];
	__be32 pb_Environment[17];
	__u32 pb_EReserved[15];
};

struct partition_info {
	u8 flg;
	char id[3];
	__be32 st;
	__be32 siz;
};

struct rootsector {
	char unused[342];
	struct partition_info icdpart[8];
	char unused2[12];
	u32 hd_siz;
	struct partition_info part[4];
	u32 bsl_st;
	u32 bsl_cnt;
	u16 checksum;
} __attribute__((packed));

struct lvm_rec {
	char lvm_id[4];
	char reserved4[16];
	__be32 lvmarea_len;
	__be32 vgda_len;
	__be32 vgda_psn[2];
	char reserved36[10];
	__be16 pp_size;
	char reserved46[12];
	__be16 version;
};

struct vgda {
	__be32 secs;
	__be32 usec;
	char reserved8[16];
	__be16 numlvs;
	__be16 maxlvs;
	__be16 pp_size;
	__be16 numpvs;
	__be16 total_vgdas;
	__be16 vgda_size;
};

struct lvd {
	__be16 lv_ix;
	__be16 res2;
	__be16 res4;
	__be16 maxsize;
	__be16 lv_state;
	__be16 mirror;
	__be16 mirror_policy;
	__be16 num_lps;
	__be16 res10[8];
};

struct lvname {
	char name[64];
};

struct ppe {
	__be16 lv_ix;
	short unsigned int res2;
	short unsigned int res4;
	__be16 lp_ix;
	short unsigned int res8[12];
};

struct pvd {
	char reserved0[16];
	__be16 pp_count;
	char reserved18[2];
	__be32 psn_part1;
	char reserved24[8];
	struct ppe ppe[1016];
};

struct lv_info {
	short unsigned int pps_per_lv;
	short unsigned int pps_found;
	unsigned char lv_is_contiguous;
};

struct cmdline_subpart {
	char name[32];
	sector_t from;
	sector_t size;
	int flags;
	struct cmdline_subpart *next_subpart;
};

struct cmdline_parts {
	char name[32];
	unsigned int nr_subparts;
	struct cmdline_subpart *subpart;
	struct cmdline_parts *next_parts;
};

struct mac_partition {
	__be16 signature;
	__be16 res1;
	__be32 map_count;
	__be32 start_block;
	__be32 block_count;
	char name[32];
	char type[32];
	__be32 data_start;
	__be32 data_count;
	__be32 status;
	__be32 boot_start;
	__be32 boot_size;
	__be32 boot_load;
	__be32 boot_load2;
	__be32 boot_entry;
	__be32 boot_entry2;
	__be32 boot_cksum;
	char processor[16];
};

struct mac_driver_desc {
	__be16 signature;
	__be16 block_size;
	__be32 block_count;
};

struct msdos_partition {
	u8 boot_ind;
	u8 head;
	u8 sector;
	u8 cyl;
	u8 sys_ind;
	u8 end_head;
	u8 end_sector;
	u8 end_cyl;
	__le32 start_sect;
	__le32 nr_sects;
};

struct frag {
	struct list_head list;
	u32 group;
	u8 num;
	u8 rec;
	u8 map;
	u8 data[0];
};

struct privhead {
	u16 ver_major;
	u16 ver_minor;
	u64 logical_disk_start;
	u64 logical_disk_size;
	u64 config_start;
	u64 config_size;
	uuid_t disk_id;
};

struct tocblock {
	u8 bitmap1_name[16];
	u64 bitmap1_start;
	u64 bitmap1_size;
	u8 bitmap2_name[16];
	u64 bitmap2_start;
	u64 bitmap2_size;
};

struct vmdb {
	u16 ver_major;
	u16 ver_minor;
	u32 vblk_size;
	u32 vblk_offset;
	u32 last_vblk_seq;
};

struct vblk_comp {
	u8 state[16];
	u64 parent_id;
	u8 type;
	u8 children;
	u16 chunksize;
};

struct vblk_dgrp {
	u8 disk_id[64];
};

struct vblk_disk {
	uuid_t disk_id;
	u8 alt_name[128];
};

struct vblk_part {
	u64 start;
	u64 size;
	u64 volume_offset;
	u64 parent_id;
	u64 disk_id;
	u8 partnum;
};

struct vblk_volu {
	u8 volume_type[16];
	u8 volume_state[16];
	u8 guid[16];
	u8 drive_hint[4];
	u64 size;
	u8 partition_type;
};

struct vblk {
	u8 name[64];
	u64 obj_id;
	u32 sequence;
	u8 flags;
	u8 type;
	union {
		struct vblk_comp comp;
		struct vblk_dgrp dgrp;
		struct vblk_disk disk;
		struct vblk_part part;
		struct vblk_volu volu;
	} vblk;
	struct list_head list;
};

struct ldmdb {
	struct privhead ph;
	struct tocblock toc;
	struct vmdb vm;
	struct list_head v_dgrp;
	struct list_head v_disk;
	struct list_head v_volu;
	struct list_head v_comp;
	struct list_head v_part;
};

enum msdos_sys_ind {
	DOS_EXTENDED_PARTITION = 5,
	LINUX_EXTENDED_PARTITION = 133,
	WIN98_EXTENDED_PARTITION = 15,
	LINUX_DATA_PARTITION = 131,
	LINUX_LVM_PARTITION = 142,
	LINUX_RAID_PARTITION = 253,
	SOLARIS_X86_PARTITION = 130,
	NEW_SOLARIS_X86_PARTITION = 191,
	DM6_AUX1PARTITION = 81,
	DM6_AUX3PARTITION = 83,
	DM6_PARTITION = 84,
	EZD_PARTITION = 85,
	FREEBSD_PARTITION = 165,
	OPENBSD_PARTITION = 166,
	NETBSD_PARTITION = 169,
	BSDI_PARTITION = 183,
	MINIX_PARTITION = 129,
	UNIXWARE_PARTITION = 99,
};

struct solaris_x86_slice {
	__le16 s_tag;
	__le16 s_flag;
	__le32 s_start;
	__le32 s_size;
};

struct solaris_x86_vtoc {
	unsigned int v_bootinfo[3];
	__le32 v_sanity;
	__le32 v_version;
	char v_volume[8];
	__le16 v_sectorsz;
	__le16 v_nparts;
	unsigned int v_reserved[10];
	struct solaris_x86_slice v_slice[16];
	unsigned int timestamp[16];
	char v_asciilabel[128];
};

struct bsd_partition {
	__le32 p_size;
	__le32 p_offset;
	__le32 p_fsize;
	__u8 p_fstype;
	__u8 p_frag;
	__le16 p_cpg;
};

struct bsd_disklabel {
	__le32 d_magic;
	__s16 d_type;
	__s16 d_subtype;
	char d_typename[16];
	char d_packname[16];
	__u32 d_secsize;
	__u32 d_nsectors;
	__u32 d_ntracks;
	__u32 d_ncylinders;
	__u32 d_secpercyl;
	__u32 d_secperunit;
	__u16 d_sparespertrack;
	__u16 d_sparespercyl;
	__u32 d_acylinders;
	__u16 d_rpm;
	__u16 d_interleave;
	__u16 d_trackskew;
	__u16 d_cylskew;
	__u32 d_headswitch;
	__u32 d_trkseek;
	__u32 d_flags;
	__u32 d_drivedata[5];
	__u32 d_spare[5];
	__le32 d_magic2;
	__le16 d_checksum;
	__le16 d_npartitions;
	__le32 d_bbsize;
	__le32 d_sbsize;
	struct bsd_partition d_partitions[16];
};

struct unixware_slice {
	__le16 s_label;
	__le16 s_flags;
	__le32 start_sect;
	__le32 nr_sects;
};

struct unixware_vtoc {
	__le32 v_magic;
	__le32 v_version;
	char v_name[8];
	__le16 v_nslices;
	__le16 v_unknown1;
	__le32 v_reserved[10];
	struct unixware_slice v_slice[16];
};

struct unixware_disklabel {
	__le32 d_type;
	__le32 d_magic;
	__le32 d_version;
	char d_serial[12];
	__le32 d_ncylinders;
	__le32 d_ntracks;
	__le32 d_nsectors;
	__le32 d_secsize;
	__le32 d_part_start;
	__le32 d_unknown1[12];
	__le32 d_alt_tbl;
	__le32 d_alt_len;
	__le32 d_phys_cyl;
	__le32 d_phys_trk;
	__le32 d_phys_sec;
	__le32 d_phys_bytes;
	__le32 d_unknown2;
	__le32 d_unknown3;
	__le32 d_pad[8];
	struct unixware_vtoc vtoc;
};

struct d_partition {
	__le32 p_size;
	__le32 p_offset;
	__le32 p_fsize;
	u8 p_fstype;
	u8 p_frag;
	__le16 p_cpg;
};

struct disklabel {
	__le32 d_magic;
	__le16 d_type;
	__le16 d_subtype;
	u8 d_typename[16];
	u8 d_packname[16];
	__le32 d_secsize;
	__le32 d_nsectors;
	__le32 d_ntracks;
	__le32 d_ncylinders;
	__le32 d_secpercyl;
	__le32 d_secprtunit;
	__le16 d_sparespertrack;
	__le16 d_sparespercyl;
	__le32 d_acylinders;
	__le16 d_rpm;
	__le16 d_interleave;
	__le16 d_trackskew;
	__le16 d_cylskew;
	__le32 d_headswitch;
	__le32 d_trkseek;
	__le32 d_flags;
	__le32 d_drivedata[5];
	__le32 d_spare[5];
	__le32 d_magic2;
	__le16 d_checksum;
	__le16 d_npartitions;
	__le32 d_bbsize;
	__le32 d_sbsize;
	struct d_partition d_partitions[18];
};

enum {
	LINUX_RAID_PARTITION___2 = 253,
};

struct sgi_volume {
	s8 name[8];
	__be32 block_num;
	__be32 num_bytes;
};

struct sgi_partition {
	__be32 num_blocks;
	__be32 first_block;
	__be32 type;
};

struct sgi_disklabel {
	__be32 magic_mushroom;
	__be16 root_part_num;
	__be16 swap_part_num;
	s8 boot_file[16];
	u8 _unused0[48];
	struct sgi_volume volume[15];
	struct sgi_partition partitions[16];
	__be32 csum;
	__be32 _unused1;
};

enum {
	SUN_WHOLE_DISK = 5,
	LINUX_RAID_PARTITION___3 = 253,
};

struct sun_info {
	__be16 id;
	__be16 flags;
};

struct sun_vtoc {
	__be32 version;
	char volume[8];
	__be16 nparts;
	struct sun_info infos[8];
	__be16 padding;
	__be32 bootinfo[3];
	__be32 sanity;
	__be32 reserved[10];
	__be32 timestamp[8];
};

struct sun_partition {
	__be32 start_cylinder;
	__be32 num_sectors;
};

struct sun_disklabel {
	unsigned char info[128];
	struct sun_vtoc vtoc;
	__be32 write_reinstruct;
	__be32 read_reinstruct;
	unsigned char spare[148];
	__be16 rspeed;
	__be16 pcylcount;
	__be16 sparecyl;
	__be16 obs1;
	__be16 obs2;
	__be16 ilfact;
	__be16 ncyl;
	__be16 nacyl;
	__be16 ntrks;
	__be16 nsect;
	__be16 obs3;
	__be16 obs4;
	struct sun_partition partitions[8];
	__be16 magic;
	__be16 csum;
};

struct pt_info {
	s32 pi_nblocks;
	u32 pi_blkoff;
};

struct ultrix_disklabel {
	s32 pt_magic;
	s32 pt_valid;
	struct pt_info pt_part[8];
};

struct _gpt_header {
	__le64 signature;
	__le32 revision;
	__le32 header_size;
	__le32 header_crc32;
	__le32 reserved1;
	__le64 my_lba;
	__le64 alternate_lba;
	__le64 first_usable_lba;
	__le64 last_usable_lba;
	efi_guid_t disk_guid;
	__le64 partition_entry_lba;
	__le32 num_partition_entries;
	__le32 sizeof_partition_entry;
	__le32 partition_entry_array_crc32;
} __attribute__((packed));

typedef struct _gpt_header gpt_header;

struct _gpt_entry_attributes {
	u64 required_to_function: 1;
	u64 reserved: 47;
	u64 type_guid_specific: 16;
};

typedef struct _gpt_entry_attributes gpt_entry_attributes;

struct _gpt_entry {
	efi_guid_t partition_type_guid;
	efi_guid_t unique_partition_guid;
	__le64 starting_lba;
	__le64 ending_lba;
	gpt_entry_attributes attributes;
	__le16 partition_name[36];
};

typedef struct _gpt_entry gpt_entry;

struct _gpt_mbr_record {
	u8 boot_indicator;
	u8 start_head;
	u8 start_sector;
	u8 start_track;
	u8 os_type;
	u8 end_head;
	u8 end_sector;
	u8 end_track;
	__le32 starting_lba;
	__le32 size_in_lba;
};

typedef struct _gpt_mbr_record gpt_mbr_record;

struct _legacy_mbr {
	u8 boot_code[440];
	__le32 unique_mbr_signature;
	__le16 unknown;
	gpt_mbr_record partition_record[4];
	__le16 signature;
} __attribute__((packed));

typedef struct _legacy_mbr legacy_mbr;

struct d_partition___2 {
	__le32 p_res;
	u8 p_fstype;
	u8 p_res2[3];
	__le32 p_offset;
	__le32 p_size;
};

struct disklabel___2 {
	u8 d_reserved[270];
	struct d_partition___2 d_partitions[2];
	u8 d_blank[208];
	__le16 d_magic;
} __attribute__((packed));

struct volumeid {
	u8 vid_unused[248];
	u8 vid_mac[8];
};

struct dkconfig {
	u8 ios_unused0[128];
	__be32 ios_slcblk;
	__be16 ios_slccnt;
	u8 ios_unused1[122];
};

struct dkblk0 {
	struct volumeid dk_vid;
	struct dkconfig dk_ios;
};

struct slice {
	__be32 nblocks;
	__be32 blkoff;
};

struct rq_wait {
	wait_queue_head_t wait;
	atomic_t inflight;
};

struct rq_depth {
	unsigned int max_depth;
	int scale_step;
	bool scaled_max;
	unsigned int queue_depth;
	unsigned int default_depth;
};

typedef bool acquire_inflight_cb_t(struct rq_wait *, void *);

typedef void cleanup_cb_t(struct rq_wait *, void *);

struct rq_qos_wait_data {
	struct wait_queue_entry wq;
	struct task_struct *task;
	struct rq_wait *rqw;
	acquire_inflight_cb_t *cb;
	void *private_data;
	bool got_token;
};

struct cdrom_device_ops;

struct cdrom_device_info {
	const struct cdrom_device_ops *ops;
	struct list_head list;
	struct gendisk *disk;
	void *handle;
	int mask;
	int speed;
	int capacity;
	unsigned int options: 30;
	unsigned int mc_flags: 2;
	unsigned int vfs_events;
	unsigned int ioctl_events;
	int use_count;
	char name[20];
	__u8 sanyo_slot: 2;
	__u8 keeplocked: 1;
	__u8 reserved: 5;
	int cdda_method;
	__u8 last_sense;
	__u8 media_written;
	short unsigned int mmc3_profile;
	int for_data;
	int (*exit)(struct cdrom_device_info *);
	int mrw_mode_page;
};

struct scsi_sense_hdr {
	u8 response_code;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	u8 byte4;
	u8 byte5;
	u8 byte6;
	u8 additional_length;
};

struct cdrom_msf0 {
	__u8 minute;
	__u8 second;
	__u8 frame;
};

union cdrom_addr {
	struct cdrom_msf0 msf;
	int lba;
};

struct cdrom_multisession {
	union cdrom_addr addr;
	__u8 xa_flag;
	__u8 addr_format;
};

struct cdrom_mcn {
	__u8 medium_catalog_number[14];
};

struct request_sense;

struct cdrom_generic_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct request_sense *sense;
	unsigned char data_direction;
	int quiet;
	int timeout;
	union {
		void *reserved[1];
		void *unused;
	};
};

struct request_sense {
	__u8 error_code: 7;
	__u8 valid: 1;
	__u8 segment_number;
	__u8 sense_key: 4;
	__u8 reserved2: 1;
	__u8 ili: 1;
	__u8 reserved1: 2;
	__u8 information[4];
	__u8 add_sense_len;
	__u8 command_info[4];
	__u8 asc;
	__u8 ascq;
	__u8 fruc;
	__u8 sks[3];
	__u8 asb[46];
};

struct packet_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct scsi_sense_hdr *sshdr;
	unsigned char data_direction;
	int quiet;
	int timeout;
	void *reserved[1];
};

struct cdrom_device_ops {
	int (*open)(struct cdrom_device_info *, int);
	void (*release)(struct cdrom_device_info *);
	int (*drive_status)(struct cdrom_device_info *, int);
	unsigned int (*check_events)(struct cdrom_device_info *, unsigned int, int);
	int (*tray_move)(struct cdrom_device_info *, int);
	int (*lock_door)(struct cdrom_device_info *, int);
	int (*select_speed)(struct cdrom_device_info *, int);
	int (*select_disc)(struct cdrom_device_info *, int);
	int (*get_last_session)(struct cdrom_device_info *, struct cdrom_multisession *);
	int (*get_mcn)(struct cdrom_device_info *, struct cdrom_mcn *);
	int (*reset)(struct cdrom_device_info *);
	int (*audio_ioctl)(struct cdrom_device_info *, unsigned int, void *);
	const int capability;
	int (*generic_packet)(struct cdrom_device_info *, struct packet_command *);
};

struct scsi_ioctl_command {
	unsigned int inlen;
	unsigned int outlen;
	unsigned char data[0];
};

enum scsi_device_event {
	SDEV_EVT_MEDIA_CHANGE = 1,
	SDEV_EVT_INQUIRY_CHANGE_REPORTED = 2,
	SDEV_EVT_CAPACITY_CHANGE_REPORTED = 3,
	SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED = 4,
	SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED = 5,
	SDEV_EVT_LUN_CHANGE_REPORTED = 6,
	SDEV_EVT_ALUA_STATE_CHANGE_REPORTED = 7,
	SDEV_EVT_POWER_ON_RESET_OCCURRED = 8,
	SDEV_EVT_FIRST = 1,
	SDEV_EVT_LAST = 8,
	SDEV_EVT_MAXBITS = 9,
};

struct scsi_request {
	unsigned char __cmd[16];
	unsigned char *cmd;
	short unsigned int cmd_len;
	int result;
	unsigned int sense_len;
	unsigned int resid_len;
	int retries;
	void *sense;
};

struct sg_io_hdr {
	int interface_id;
	int dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	unsigned int dxfer_len;
	void *dxferp;
	unsigned char *cmdp;
	void *sbp;
	unsigned int timeout;
	unsigned int flags;
	int pack_id;
	void *usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	int resid;
	unsigned int duration;
	unsigned int info;
};

struct compat_sg_io_hdr {
	compat_int_t interface_id;
	compat_int_t dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	compat_uint_t dxfer_len;
	compat_uint_t dxferp;
	compat_uptr_t cmdp;
	compat_uptr_t sbp;
	compat_uint_t timeout;
	compat_uint_t flags;
	compat_int_t pack_id;
	compat_uptr_t usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	compat_int_t resid;
	compat_uint_t duration;
	compat_uint_t info;
};

struct blk_cmd_filter {
	long unsigned int read_ok[4];
	long unsigned int write_ok[4];
};

struct compat_cdrom_generic_command {
	unsigned char cmd[12];
	compat_caddr_t buffer;
	compat_uint_t buflen;
	compat_int_t stat;
	compat_caddr_t sense;
	unsigned char data_direction;
	unsigned char pad[3];
	compat_int_t quiet;
	compat_int_t timeout;
	compat_caddr_t unused;
};

enum {
	OMAX_SB_LEN = 16,
};

struct bsg_device {
	struct request_queue *queue;
	spinlock_t lock;
	struct hlist_node dev_list;
	refcount_t ref_count;
	char name[20];
	int max_queue;
};

struct bsg_job;

typedef int bsg_job_fn(struct bsg_job *);

struct bsg_buffer {
	unsigned int payload_len;
	int sg_cnt;
	struct scatterlist *sg_list;
};

struct bsg_job {
	struct device *dev;
	struct kref kref;
	unsigned int timeout;
	void *request;
	void *reply;
	unsigned int request_len;
	unsigned int reply_len;
	struct bsg_buffer request_payload;
	struct bsg_buffer reply_payload;
	int result;
	unsigned int reply_payload_rcv_len;
	struct request *bidi_rq;
	struct bio *bidi_bio;
	void *dd_data;
};

typedef enum blk_eh_timer_return bsg_timeout_fn(struct request *);

struct bsg_set {
	struct blk_mq_tag_set tag_set;
	bsg_job_fn *job_fn;
	bsg_timeout_fn *timeout_fn;
};

typedef struct blkcg_policy_data *blkcg_pol_alloc_cpd_fn(gfp_t);

typedef void blkcg_pol_init_cpd_fn(struct blkcg_policy_data *);

typedef void blkcg_pol_free_cpd_fn(struct blkcg_policy_data *);

typedef void blkcg_pol_bind_cpd_fn(struct blkcg_policy_data *);

typedef struct blkg_policy_data *blkcg_pol_alloc_pd_fn(gfp_t, struct request_queue *, struct blkcg *);

typedef void blkcg_pol_init_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_online_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_offline_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_free_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_reset_pd_stats_fn(struct blkg_policy_data *);

typedef size_t blkcg_pol_stat_pd_fn(struct blkg_policy_data *, char *, size_t);

struct blkcg_policy {
	int plid;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	blkcg_pol_alloc_cpd_fn *cpd_alloc_fn;
	blkcg_pol_init_cpd_fn *cpd_init_fn;
	blkcg_pol_free_cpd_fn *cpd_free_fn;
	blkcg_pol_bind_cpd_fn *cpd_bind_fn;
	blkcg_pol_alloc_pd_fn *pd_alloc_fn;
	blkcg_pol_init_pd_fn *pd_init_fn;
	blkcg_pol_online_pd_fn *pd_online_fn;
	blkcg_pol_offline_pd_fn *pd_offline_fn;
	blkcg_pol_free_pd_fn *pd_free_fn;
	blkcg_pol_reset_pd_stats_fn *pd_reset_stats_fn;
	blkcg_pol_stat_pd_fn *pd_stat_fn;
};

struct blkg_conf_ctx {
	struct block_device *bdev;
	struct blkcg_gq *blkg;
	char *body;
};

enum blkg_rwstat_type {
	BLKG_RWSTAT_READ = 0,
	BLKG_RWSTAT_WRITE = 1,
	BLKG_RWSTAT_SYNC = 2,
	BLKG_RWSTAT_ASYNC = 3,
	BLKG_RWSTAT_DISCARD = 4,
	BLKG_RWSTAT_NR = 5,
	BLKG_RWSTAT_TOTAL = 5,
};

struct blkg_rwstat {
	struct percpu_counter cpu_cnt[5];
	atomic64_t aux_cnt[5];
};

struct blkg_rwstat_sample {
	u64 cnt[5];
};

struct throtl_service_queue {
	struct throtl_service_queue *parent_sq;
	struct list_head queued[2];
	unsigned int nr_queued[2];
	struct rb_root_cached pending_tree;
	unsigned int nr_pending;
	long unsigned int first_pending_disptime;
	struct timer_list pending_timer;
};

struct latency_bucket {
	long unsigned int total_latency;
	int samples;
};

struct avg_latency_bucket {
	long unsigned int latency;
	bool valid;
};

struct throtl_data {
	struct throtl_service_queue service_queue;
	struct request_queue *queue;
	unsigned int nr_queued[2];
	unsigned int throtl_slice;
	struct work_struct dispatch_work;
	unsigned int limit_index;
	bool limit_valid[2];
	long unsigned int low_upgrade_time;
	long unsigned int low_downgrade_time;
	unsigned int scale;
	struct latency_bucket tmp_buckets[18];
	struct avg_latency_bucket avg_buckets[18];
	struct latency_bucket *latency_buckets[2];
	long unsigned int last_calculate_time;
	long unsigned int filtered_latency;
	bool track_bio_latency;
};

struct throtl_grp;

struct throtl_qnode {
	struct list_head node;
	struct bio_list bios;
	struct throtl_grp *tg;
};

struct throtl_grp {
	struct blkg_policy_data pd;
	struct rb_node rb_node;
	struct throtl_data *td;
	struct throtl_service_queue service_queue;
	struct throtl_qnode qnode_on_self[2];
	struct throtl_qnode qnode_on_parent[2];
	long unsigned int disptime;
	unsigned int flags;
	bool has_rules[2];
	uint64_t bps[4];
	uint64_t bps_conf[4];
	unsigned int iops[4];
	unsigned int iops_conf[4];
	uint64_t bytes_disp[2];
	unsigned int io_disp[2];
	long unsigned int last_low_overflow_time[2];
	uint64_t last_bytes_disp[2];
	unsigned int last_io_disp[2];
	long unsigned int last_check_time;
	long unsigned int latency_target;
	long unsigned int latency_target_conf;
	long unsigned int slice_start[2];
	long unsigned int slice_end[2];
	long unsigned int last_finish_time;
	long unsigned int checked_last_finish_time;
	long unsigned int avg_idletime;
	long unsigned int idletime_threshold;
	long unsigned int idletime_threshold_conf;
	unsigned int bio_cnt;
	unsigned int bad_bio_cnt;
	long unsigned int bio_cnt_reset_time;
	atomic_t io_split_cnt[2];
	atomic_t last_io_split_cnt[2];
	struct blkg_rwstat stat_bytes;
	struct blkg_rwstat stat_ios;
};

enum tg_state_flags {
	THROTL_TG_PENDING = 1,
	THROTL_TG_WAS_EMPTY = 2,
};

enum {
	LIMIT_LOW = 0,
	LIMIT_MAX = 1,
	LIMIT_CNT = 2,
};

enum {
	MILLION = 1000000,
	MIN_PERIOD = 1000,
	MAX_PERIOD = 1000000,
	MARGIN_MIN_PCT = 10,
	MARGIN_LOW_PCT = 20,
	MARGIN_TARGET_PCT = 50,
	INUSE_ADJ_STEP_PCT = 25,
	TIMER_SLACK_PCT = 1,
	WEIGHT_ONE = 65536,
	VTIME_PER_SEC_SHIFT = 37,
	VTIME_PER_SEC = 0,
	VTIME_PER_USEC = 137438,
	VTIME_PER_NSEC = 137,
	VRATE_MIN_PPM = 10000,
	VRATE_MAX_PPM = 100000000,
	VRATE_MIN = 1374,
	VRATE_CLAMP_ADJ_PCT = 4,
	RQ_WAIT_BUSY_PCT = 5,
	UNBUSY_THR_PCT = 75,
	MIN_DELAY_THR_PCT = 500,
	MAX_DELAY_THR_PCT = 25000,
	MIN_DELAY = 250,
	MAX_DELAY = 250000,
	DFGV_USAGE_PCT = 50,
	DFGV_PERIOD = 100000,
	MAX_LAGGING_PERIODS = 10,
	AUTOP_CYCLE_NSEC = 1410065408,
	IOC_PAGE_SHIFT = 12,
	IOC_PAGE_SIZE = 4096,
	IOC_SECT_TO_PAGE_SHIFT = 3,
	LCOEF_RANDIO_PAGES = 4096,
};

enum ioc_running {
	IOC_IDLE = 0,
	IOC_RUNNING = 1,
	IOC_STOP = 2,
};

enum {
	QOS_ENABLE = 0,
	QOS_CTRL = 1,
	NR_QOS_CTRL_PARAMS = 2,
};

enum {
	QOS_RPPM = 0,
	QOS_RLAT = 1,
	QOS_WPPM = 2,
	QOS_WLAT = 3,
	QOS_MIN = 4,
	QOS_MAX = 5,
	NR_QOS_PARAMS = 6,
};

enum {
	COST_CTRL = 0,
	COST_MODEL = 1,
	NR_COST_CTRL_PARAMS = 2,
};

enum {
	I_LCOEF_RBPS = 0,
	I_LCOEF_RSEQIOPS = 1,
	I_LCOEF_RRANDIOPS = 2,
	I_LCOEF_WBPS = 3,
	I_LCOEF_WSEQIOPS = 4,
	I_LCOEF_WRANDIOPS = 5,
	NR_I_LCOEFS = 6,
};

enum {
	LCOEF_RPAGE = 0,
	LCOEF_RSEQIO = 1,
	LCOEF_RRANDIO = 2,
	LCOEF_WPAGE = 3,
	LCOEF_WSEQIO = 4,
	LCOEF_WRANDIO = 5,
	NR_LCOEFS = 6,
};

enum {
	AUTOP_INVALID = 0,
	AUTOP_HDD = 1,
	AUTOP_SSD_QD1 = 2,
	AUTOP_SSD_DFL = 3,
	AUTOP_SSD_FAST = 4,
};

struct ioc_params {
	u32 qos[6];
	u64 i_lcoefs[6];
	u64 lcoefs[6];
	u32 too_fast_vrate_pct;
	u32 too_slow_vrate_pct;
};

struct ioc_margins {
	s64 min;
	s64 low;
	s64 target;
};

struct ioc_missed {
	local_t nr_met;
	local_t nr_missed;
	u32 last_met;
	u32 last_missed;
};

struct ioc_pcpu_stat {
	struct ioc_missed missed[2];
	local64_t rq_wait_ns;
	u64 last_rq_wait_ns;
};

struct ioc {
	struct rq_qos rqos;
	bool enabled;
	struct ioc_params params;
	struct ioc_margins margins;
	u32 period_us;
	u32 timer_slack_ns;
	u64 vrate_min;
	u64 vrate_max;
	spinlock_t lock;
	struct timer_list timer;
	struct list_head active_iocgs;
	struct ioc_pcpu_stat *pcpu_stat;
	enum ioc_running running;
	atomic64_t vtime_rate;
	u64 vtime_base_rate;
	s64 vtime_err;
	seqcount_spinlock_t period_seqcount;
	u64 period_at;
	u64 period_at_vtime;
	atomic64_t cur_period;
	int busy_level;
	bool weights_updated;
	atomic_t hweight_gen;
	u64 dfgv_period_at;
	u64 dfgv_period_rem;
	u64 dfgv_usage_us_sum;
	u64 autop_too_fast_at;
	u64 autop_too_slow_at;
	int autop_idx;
	bool user_qos_params: 1;
	bool user_cost_model: 1;
};

struct iocg_pcpu_stat {
	local64_t abs_vusage;
};

struct iocg_stat {
	u64 usage_us;
	u64 wait_us;
	u64 indebt_us;
	u64 indelay_us;
};

struct ioc_gq {
	struct blkg_policy_data pd;
	struct ioc *ioc;
	u32 cfg_weight;
	u32 weight;
	u32 active;
	u32 inuse;
	u32 last_inuse;
	s64 saved_margin;
	sector_t cursor;
	atomic64_t vtime;
	atomic64_t done_vtime;
	u64 abs_vdebt;
	u64 delay;
	u64 delay_at;
	atomic64_t active_period;
	struct list_head active_list;
	u64 child_active_sum;
	u64 child_inuse_sum;
	u64 child_adjusted_sum;
	int hweight_gen;
	u32 hweight_active;
	u32 hweight_inuse;
	u32 hweight_donating;
	u32 hweight_after_donation;
	struct list_head walk_list;
	struct list_head surplus_list;
	struct wait_queue_head waitq;
	struct hrtimer waitq_timer;
	u64 activated_at;
	struct iocg_pcpu_stat *pcpu_stat;
	struct iocg_stat local_stat;
	struct iocg_stat desc_stat;
	struct iocg_stat last_stat;
	u64 last_stat_abs_vusage;
	u64 usage_delta_us;
	u64 wait_since;
	u64 indebt_since;
	u64 indelay_since;
	int level;
	struct ioc_gq *ancestors[0];
};

struct ioc_cgrp {
	struct blkcg_policy_data cpd;
	unsigned int dfl_weight;
};

struct ioc_now {
	u64 now_ns;
	u64 now;
	u64 vnow;
	u64 vrate;
};

struct iocg_wait {
	struct wait_queue_entry wait;
	struct bio *bio;
	u64 abs_cost;
	bool committed;
};

struct iocg_wake_ctx {
	struct ioc_gq *iocg;
	u32 hw_inuse;
	s64 vbudget;
};

struct trace_event_raw_iocost_iocg_state {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u32 __data_loc_cgroup;
	u64 now;
	u64 vnow;
	u64 vrate;
	u64 last_period;
	u64 cur_period;
	u64 vtime;
	u32 weight;
	u32 inuse;
	u64 hweight_active;
	u64 hweight_inuse;
	char __data[0];
};

struct trace_event_raw_iocg_inuse_update {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u32 __data_loc_cgroup;
	u64 now;
	u32 old_inuse;
	u32 new_inuse;
	u64 old_hweight_inuse;
	u64 new_hweight_inuse;
	char __data[0];
};

struct trace_event_raw_iocost_ioc_vrate_adj {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u64 old_vrate;
	u64 new_vrate;
	int busy_level;
	u32 read_missed_ppm;
	u32 write_missed_ppm;
	u32 rq_wait_pct;
	int nr_lagging;
	int nr_shortages;
	char __data[0];
};

struct trace_event_raw_iocost_iocg_forgive_debt {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u32 __data_loc_cgroup;
	u64 now;
	u64 vnow;
	u32 usage_pct;
	u64 old_debt;
	u64 new_debt;
	u64 old_delay;
	u64 new_delay;
	char __data[0];
};

struct trace_event_data_offsets_iocost_iocg_state {
	u32 devname;
	u32 cgroup;
};

struct trace_event_data_offsets_iocg_inuse_update {
	u32 devname;
	u32 cgroup;
};

struct trace_event_data_offsets_iocost_ioc_vrate_adj {
	u32 devname;
};

struct trace_event_data_offsets_iocost_iocg_forgive_debt {
	u32 devname;
	u32 cgroup;
};

typedef void (*btf_trace_iocost_iocg_activate)(void *, struct ioc_gq *, const char *, struct ioc_now *, u64, u64, u64);

typedef void (*btf_trace_iocost_iocg_idle)(void *, struct ioc_gq *, const char *, struct ioc_now *, u64, u64, u64);

typedef void (*btf_trace_iocost_inuse_shortage)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u32, u64, u64);

typedef void (*btf_trace_iocost_inuse_transfer)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u32, u64, u64);

typedef void (*btf_trace_iocost_inuse_adjust)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u32, u64, u64);

typedef void (*btf_trace_iocost_ioc_vrate_adj)(void *, struct ioc *, u64, u32 *, u32, int, int);

typedef void (*btf_trace_iocost_iocg_forgive_debt)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u64, u64, u64, u64);

struct deadline_data {
	struct rb_root sort_list[2];
	struct list_head fifo_list[2];
	struct request *next_rq[2];
	unsigned int batching;
	unsigned int starved;
	int fifo_expire[2];
	int fifo_batch;
	int writes_starved;
	int front_merges;
	spinlock_t lock;
	spinlock_t zone_lock;
	struct list_head dispatch;
};

enum bip_flags {
	BIP_BLOCK_INTEGRITY = 1,
	BIP_MAPPED_INTEGRITY = 2,
	BIP_CTRL_NOCHECK = 4,
	BIP_DISK_NOCHECK = 8,
	BIP_IP_CHECKSUM = 16,
};

enum blk_integrity_flags {
	BLK_INTEGRITY_VERIFY = 1,
	BLK_INTEGRITY_GENERATE = 2,
	BLK_INTEGRITY_DEVICE_CAPABLE = 4,
	BLK_INTEGRITY_IP_CHECKSUM = 8,
};

struct integrity_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_integrity *, char *);
	ssize_t (*store)(struct blk_integrity *, const char *, size_t);
};

enum t10_dif_type {
	T10_PI_TYPE0_PROTECTION = 0,
	T10_PI_TYPE1_PROTECTION = 1,
	T10_PI_TYPE2_PROTECTION = 2,
	T10_PI_TYPE3_PROTECTION = 3,
};

struct t10_pi_tuple {
	__be16 guard_tag;
	__be16 app_tag;
	__be32 ref_tag;
};

typedef __be16 csum_fn(void *, unsigned int);

struct virtio_device_id {
	__u32 device;
	__u32 vendor;
};

struct virtio_device;

struct virtqueue {
	struct list_head list;
	void (*callback)(struct virtqueue *);
	const char *name;
	struct virtio_device *vdev;
	unsigned int index;
	unsigned int num_free;
	void *priv;
};

struct vringh_config_ops;

struct virtio_config_ops;

struct virtio_device {
	int index;
	bool failed;
	bool config_enabled;
	bool config_change_pending;
	spinlock_t config_lock;
	spinlock_t vqs_list_lock;
	struct device dev;
	struct virtio_device_id id;
	const struct virtio_config_ops *config;
	const struct vringh_config_ops *vringh_config;
	struct list_head vqs;
	u64 features;
	void *priv;
};

typedef void vq_callback_t(struct virtqueue *);

struct virtio_shm_region;

struct virtio_config_ops {
	void (*get)(struct virtio_device *, unsigned int, void *, unsigned int);
	void (*set)(struct virtio_device *, unsigned int, const void *, unsigned int);
	u32 (*generation)(struct virtio_device *);
	u8 (*get_status)(struct virtio_device *);
	void (*set_status)(struct virtio_device *, u8);
	void (*reset)(struct virtio_device *);
	int (*find_vqs)(struct virtio_device *, unsigned int, struct virtqueue **, vq_callback_t **, const char * const *, const bool *, struct irq_affinity *);
	void (*del_vqs)(struct virtio_device *);
	u64 (*get_features)(struct virtio_device *);
	int (*finalize_features)(struct virtio_device *);
	const char * (*bus_name)(struct virtio_device *);
	int (*set_vq_affinity)(struct virtqueue *, const struct cpumask *);
	const struct cpumask * (*get_vq_affinity)(struct virtio_device *, int);
	bool (*get_shm_region)(struct virtio_device *, struct virtio_shm_region *, u8);
};

struct virtio_shm_region {
	u64 addr;
	u64 len;
};

struct irq_poll;

typedef int irq_poll_fn(struct irq_poll *, int);

struct irq_poll {
	struct list_head list;
	long unsigned int state;
	int weight;
	irq_poll_fn *poll;
};

struct dim_sample {
	ktime_t time;
	u32 pkt_ctr;
	u32 byte_ctr;
	u16 event_ctr;
	u32 comp_ctr;
};

struct dim_stats {
	int ppms;
	int bpms;
	int epms;
	int cpms;
	int cpe_ratio;
};

struct dim {
	u8 state;
	struct dim_stats prev_stats;
	struct dim_sample start_sample;
	struct dim_sample measuring_sample;
	struct work_struct work;
	void *priv;
	u8 profile_ix;
	u8 mode;
	u8 tune_state;
	u8 steps_right;
	u8 steps_left;
	u8 tired;
};

enum rdma_nl_counter_mode {
	RDMA_COUNTER_MODE_NONE = 0,
	RDMA_COUNTER_MODE_AUTO = 1,
	RDMA_COUNTER_MODE_MANUAL = 2,
	RDMA_COUNTER_MODE_MAX = 3,
};

enum rdma_nl_counter_mask {
	RDMA_COUNTER_MASK_QP_TYPE = 1,
	RDMA_COUNTER_MASK_PID = 2,
};

enum rdma_restrack_type {
	RDMA_RESTRACK_PD = 0,
	RDMA_RESTRACK_CQ = 1,
	RDMA_RESTRACK_QP = 2,
	RDMA_RESTRACK_CM_ID = 3,
	RDMA_RESTRACK_MR = 4,
	RDMA_RESTRACK_CTX = 5,
	RDMA_RESTRACK_COUNTER = 6,
	RDMA_RESTRACK_SRQ = 7,
	RDMA_RESTRACK_MAX = 8,
};

struct rdma_restrack_entry {
	bool valid;
	u8 no_track: 1;
	struct kref kref;
	struct completion comp;
	struct task_struct *task;
	const char *kern_name;
	enum rdma_restrack_type type;
	bool user;
	u32 id;
};

struct rdma_link_ops {
	struct list_head list;
	const char *type;
	int (*newlink)(const char *, struct net_device *);
};

struct auto_mode_param {
	int qp_type;
};

struct rdma_counter_mode {
	enum rdma_nl_counter_mode mode;
	enum rdma_nl_counter_mask mask;
	struct auto_mode_param param;
};

struct rdma_hw_stats;

struct rdma_port_counter {
	struct rdma_counter_mode mode;
	struct rdma_hw_stats *hstats;
	unsigned int num_counters;
	struct mutex lock;
};

struct rdma_hw_stats {
	struct mutex lock;
	long unsigned int timestamp;
	long unsigned int lifespan;
	const char * const *names;
	int num_counters;
	u64 value[0];
};

struct ib_device;

struct rdma_counter {
	struct rdma_restrack_entry res;
	struct ib_device *device;
	uint32_t id;
	struct kref kref;
	struct rdma_counter_mode mode;
	struct mutex lock;
	struct rdma_hw_stats *stats;
	u32 port;
};

enum rdma_driver_id {
	RDMA_DRIVER_UNKNOWN = 0,
	RDMA_DRIVER_MLX5 = 1,
	RDMA_DRIVER_MLX4 = 2,
	RDMA_DRIVER_CXGB3 = 3,
	RDMA_DRIVER_CXGB4 = 4,
	RDMA_DRIVER_MTHCA = 5,
	RDMA_DRIVER_BNXT_RE = 6,
	RDMA_DRIVER_OCRDMA = 7,
	RDMA_DRIVER_NES = 8,
	RDMA_DRIVER_I40IW = 9,
	RDMA_DRIVER_VMW_PVRDMA = 10,
	RDMA_DRIVER_QEDR = 11,
	RDMA_DRIVER_HNS = 12,
	RDMA_DRIVER_USNIC = 13,
	RDMA_DRIVER_RXE = 14,
	RDMA_DRIVER_HFI1 = 15,
	RDMA_DRIVER_QIB = 16,
	RDMA_DRIVER_EFA = 17,
	RDMA_DRIVER_SIW = 18,
};

enum ib_cq_notify_flags {
	IB_CQ_SOLICITED = 1,
	IB_CQ_NEXT_COMP = 2,
	IB_CQ_SOLICITED_MASK = 3,
	IB_CQ_REPORT_MISSED_EVENTS = 4,
};

struct ib_mad;

enum rdma_link_layer {
	IB_LINK_LAYER_UNSPECIFIED = 0,
	IB_LINK_LAYER_INFINIBAND = 1,
	IB_LINK_LAYER_ETHERNET = 2,
};

enum rdma_netdev_t {
	RDMA_NETDEV_OPA_VNIC = 0,
	RDMA_NETDEV_IPOIB = 1,
};

enum ib_srq_attr_mask {
	IB_SRQ_MAX_WR = 1,
	IB_SRQ_LIMIT = 2,
};

enum ib_mr_type {
	IB_MR_TYPE_MEM_REG = 0,
	IB_MR_TYPE_SG_GAPS = 1,
	IB_MR_TYPE_DM = 2,
	IB_MR_TYPE_USER = 3,
	IB_MR_TYPE_DMA = 4,
	IB_MR_TYPE_INTEGRITY = 5,
};

enum ib_uverbs_advise_mr_advice {
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH = 0,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE = 1,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT = 2,
};

struct uverbs_attr_bundle;

struct rdma_cm_id;

struct iw_cm_id;

struct iw_cm_conn_param;

struct ib_qp;

struct ib_send_wr;

struct ib_recv_wr;

struct ib_cq;

struct ib_wc;

struct ib_srq;

struct ib_grh;

struct ib_device_attr;

struct ib_udata;

struct ib_device_modify;

struct ib_port_attr;

struct ib_port_modify;

struct ib_port_immutable;

struct rdma_netdev_alloc_params;

struct ib_gid_attr;

struct ib_ucontext;

struct rdma_user_mmap_entry;

struct ib_pd;

struct ib_ah;

struct rdma_ah_init_attr;

struct rdma_ah_attr;

struct ib_srq_init_attr;

struct ib_srq_attr;

struct ib_qp_init_attr;

struct ib_qp_attr;

struct ib_cq_init_attr;

struct ib_mr;

struct ib_sge;

struct ib_mr_status;

struct ib_mw;

struct ib_xrcd;

struct ib_flow;

struct ib_flow_attr;

struct ib_flow_action;

struct ib_flow_action_attrs_esp;

struct ib_wq;

struct ib_wq_init_attr;

struct ib_wq_attr;

struct ib_rwq_ind_table;

struct ib_rwq_ind_table_init_attr;

struct ib_dm;

struct ib_dm_alloc_attr;

struct ib_dm_mr_attr;

struct ib_counters;

struct ib_counters_read_attr;

struct ib_device_ops {
	struct module *owner;
	enum rdma_driver_id driver_id;
	u32 uverbs_abi_ver;
	unsigned int uverbs_no_driver_id_binding: 1;
	int (*post_send)(struct ib_qp *, const struct ib_send_wr *, const struct ib_send_wr **);
	int (*post_recv)(struct ib_qp *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	void (*drain_rq)(struct ib_qp *);
	void (*drain_sq)(struct ib_qp *);
	int (*poll_cq)(struct ib_cq *, int, struct ib_wc *);
	int (*peek_cq)(struct ib_cq *, int);
	int (*req_notify_cq)(struct ib_cq *, enum ib_cq_notify_flags);
	int (*post_srq_recv)(struct ib_srq *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	int (*process_mad)(struct ib_device *, int, u32, const struct ib_wc *, const struct ib_grh *, const struct ib_mad *, struct ib_mad *, size_t *, u16 *);
	int (*query_device)(struct ib_device *, struct ib_device_attr *, struct ib_udata *);
	int (*modify_device)(struct ib_device *, int, struct ib_device_modify *);
	void (*get_dev_fw_str)(struct ib_device *, char *);
	const struct cpumask * (*get_vector_affinity)(struct ib_device *, int);
	int (*query_port)(struct ib_device *, u32, struct ib_port_attr *);
	int (*modify_port)(struct ib_device *, u32, int, struct ib_port_modify *);
	int (*get_port_immutable)(struct ib_device *, u32, struct ib_port_immutable *);
	enum rdma_link_layer (*get_link_layer)(struct ib_device *, u32);
	struct net_device * (*get_netdev)(struct ib_device *, u32);
	struct net_device * (*alloc_rdma_netdev)(struct ib_device *, u32, enum rdma_netdev_t, const char *, unsigned char, void (*)(struct net_device *));
	int (*rdma_netdev_get_params)(struct ib_device *, u32, enum rdma_netdev_t, struct rdma_netdev_alloc_params *);
	int (*query_gid)(struct ib_device *, u32, int, union ib_gid *);
	int (*add_gid)(const struct ib_gid_attr *, void **);
	int (*del_gid)(const struct ib_gid_attr *, void **);
	int (*query_pkey)(struct ib_device *, u32, u16, u16 *);
	int (*alloc_ucontext)(struct ib_ucontext *, struct ib_udata *);
	void (*dealloc_ucontext)(struct ib_ucontext *);
	int (*mmap)(struct ib_ucontext *, struct vm_area_struct *);
	void (*mmap_free)(struct rdma_user_mmap_entry *);
	void (*disassociate_ucontext)(struct ib_ucontext *);
	int (*alloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*dealloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*create_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*create_user_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*modify_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*query_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*destroy_ah)(struct ib_ah *, u32);
	int (*create_srq)(struct ib_srq *, struct ib_srq_init_attr *, struct ib_udata *);
	int (*modify_srq)(struct ib_srq *, struct ib_srq_attr *, enum ib_srq_attr_mask, struct ib_udata *);
	int (*query_srq)(struct ib_srq *, struct ib_srq_attr *);
	int (*destroy_srq)(struct ib_srq *, struct ib_udata *);
	struct ib_qp * (*create_qp)(struct ib_pd *, struct ib_qp_init_attr *, struct ib_udata *);
	int (*modify_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_udata *);
	int (*query_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_qp_init_attr *);
	int (*destroy_qp)(struct ib_qp *, struct ib_udata *);
	int (*create_cq)(struct ib_cq *, const struct ib_cq_init_attr *, struct ib_udata *);
	int (*modify_cq)(struct ib_cq *, u16, u16);
	int (*destroy_cq)(struct ib_cq *, struct ib_udata *);
	int (*resize_cq)(struct ib_cq *, int, struct ib_udata *);
	struct ib_mr * (*get_dma_mr)(struct ib_pd *, int);
	struct ib_mr * (*reg_user_mr)(struct ib_pd *, u64, u64, u64, int, struct ib_udata *);
	struct ib_mr * (*reg_user_mr_dmabuf)(struct ib_pd *, u64, u64, u64, int, int, struct ib_udata *);
	struct ib_mr * (*rereg_user_mr)(struct ib_mr *, int, u64, u64, u64, int, struct ib_pd *, struct ib_udata *);
	int (*dereg_mr)(struct ib_mr *, struct ib_udata *);
	struct ib_mr * (*alloc_mr)(struct ib_pd *, enum ib_mr_type, u32);
	struct ib_mr * (*alloc_mr_integrity)(struct ib_pd *, u32, u32);
	int (*advise_mr)(struct ib_pd *, enum ib_uverbs_advise_mr_advice, u32, struct ib_sge *, u32, struct uverbs_attr_bundle *);
	int (*map_mr_sg)(struct ib_mr *, struct scatterlist *, int, unsigned int *);
	int (*check_mr_status)(struct ib_mr *, u32, struct ib_mr_status *);
	int (*alloc_mw)(struct ib_mw *, struct ib_udata *);
	int (*dealloc_mw)(struct ib_mw *);
	int (*attach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*detach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*alloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	int (*dealloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	struct ib_flow * (*create_flow)(struct ib_qp *, struct ib_flow_attr *, struct ib_udata *);
	int (*destroy_flow)(struct ib_flow *);
	struct ib_flow_action * (*create_flow_action_esp)(struct ib_device *, const struct ib_flow_action_attrs_esp *, struct uverbs_attr_bundle *);
	int (*destroy_flow_action)(struct ib_flow_action *);
	int (*modify_flow_action_esp)(struct ib_flow_action *, const struct ib_flow_action_attrs_esp *, struct uverbs_attr_bundle *);
	int (*set_vf_link_state)(struct ib_device *, int, u32, int);
	int (*get_vf_config)(struct ib_device *, int, u32, struct ifla_vf_info *);
	int (*get_vf_stats)(struct ib_device *, int, u32, struct ifla_vf_stats *);
	int (*get_vf_guid)(struct ib_device *, int, u32, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*set_vf_guid)(struct ib_device *, int, u32, u64, int);
	struct ib_wq * (*create_wq)(struct ib_pd *, struct ib_wq_init_attr *, struct ib_udata *);
	int (*destroy_wq)(struct ib_wq *, struct ib_udata *);
	int (*modify_wq)(struct ib_wq *, struct ib_wq_attr *, u32, struct ib_udata *);
	int (*create_rwq_ind_table)(struct ib_rwq_ind_table *, struct ib_rwq_ind_table_init_attr *, struct ib_udata *);
	int (*destroy_rwq_ind_table)(struct ib_rwq_ind_table *);
	struct ib_dm * (*alloc_dm)(struct ib_device *, struct ib_ucontext *, struct ib_dm_alloc_attr *, struct uverbs_attr_bundle *);
	int (*dealloc_dm)(struct ib_dm *, struct uverbs_attr_bundle *);
	struct ib_mr * (*reg_dm_mr)(struct ib_pd *, struct ib_dm *, struct ib_dm_mr_attr *, struct uverbs_attr_bundle *);
	int (*create_counters)(struct ib_counters *, struct uverbs_attr_bundle *);
	int (*destroy_counters)(struct ib_counters *);
	int (*read_counters)(struct ib_counters *, struct ib_counters_read_attr *, struct uverbs_attr_bundle *);
	int (*map_mr_sg_pi)(struct ib_mr *, struct scatterlist *, int, unsigned int *, struct scatterlist *, int, unsigned int *);
	struct rdma_hw_stats * (*alloc_hw_stats)(struct ib_device *, u32);
	int (*get_hw_stats)(struct ib_device *, struct rdma_hw_stats *, u32, int);
	int (*init_port)(struct ib_device *, u32, struct kobject *);
	int (*fill_res_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_mr_entry_raw)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_cq_entry)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_cq_entry_raw)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_qp_entry)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_qp_entry_raw)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_cm_id_entry)(struct sk_buff *, struct rdma_cm_id *);
	int (*enable_driver)(struct ib_device *);
	void (*dealloc_driver)(struct ib_device *);
	void (*iw_add_ref)(struct ib_qp *);
	void (*iw_rem_ref)(struct ib_qp *);
	struct ib_qp * (*iw_get_qp)(struct ib_device *, int);
	int (*iw_connect)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_accept)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_reject)(struct iw_cm_id *, const void *, u8);
	int (*iw_create_listen)(struct iw_cm_id *, int);
	int (*iw_destroy_listen)(struct iw_cm_id *);
	int (*counter_bind_qp)(struct rdma_counter *, struct ib_qp *);
	int (*counter_unbind_qp)(struct ib_qp *);
	int (*counter_dealloc)(struct rdma_counter *);
	struct rdma_hw_stats * (*counter_alloc_stats)(struct rdma_counter *);
	int (*counter_update_stats)(struct rdma_counter *);
	int (*fill_stat_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*query_ucontext)(struct ib_ucontext *, struct uverbs_attr_bundle *);
	size_t size_ib_ah;
	size_t size_ib_counters;
	size_t size_ib_cq;
	size_t size_ib_mw;
	size_t size_ib_pd;
	size_t size_ib_rwq_ind_table;
	size_t size_ib_srq;
	size_t size_ib_ucontext;
	size_t size_ib_xrcd;
};

struct ib_core_device {
	struct device dev;
	possible_net_t rdma_net;
	struct kobject *ports_kobj;
	struct list_head port_list;
	struct ib_device *owner;
};

enum ib_atomic_cap {
	IB_ATOMIC_NONE = 0,
	IB_ATOMIC_HCA = 1,
	IB_ATOMIC_GLOB = 2,
};

struct ib_odp_caps {
	uint64_t general_caps;
	struct {
		uint32_t rc_odp_caps;
		uint32_t uc_odp_caps;
		uint32_t ud_odp_caps;
		uint32_t xrc_odp_caps;
	} per_transport_caps;
};

struct ib_rss_caps {
	u32 supported_qpts;
	u32 max_rwq_indirection_tables;
	u32 max_rwq_indirection_table_size;
};

struct ib_tm_caps {
	u32 max_rndv_hdr_size;
	u32 max_num_tags;
	u32 flags;
	u32 max_ops;
	u32 max_sge;
};

struct ib_cq_caps {
	u16 max_cq_moderation_count;
	u16 max_cq_moderation_period;
};

struct ib_device_attr {
	u64 fw_ver;
	__be64 sys_image_guid;
	u64 max_mr_size;
	u64 page_size_cap;
	u32 vendor_id;
	u32 vendor_part_id;
	u32 hw_ver;
	int max_qp;
	int max_qp_wr;
	u64 device_cap_flags;
	int max_send_sge;
	int max_recv_sge;
	int max_sge_rd;
	int max_cq;
	int max_cqe;
	int max_mr;
	int max_pd;
	int max_qp_rd_atom;
	int max_ee_rd_atom;
	int max_res_rd_atom;
	int max_qp_init_rd_atom;
	int max_ee_init_rd_atom;
	enum ib_atomic_cap atomic_cap;
	enum ib_atomic_cap masked_atomic_cap;
	int max_ee;
	int max_rdd;
	int max_mw;
	int max_raw_ipv6_qp;
	int max_raw_ethy_qp;
	int max_mcast_grp;
	int max_mcast_qp_attach;
	int max_total_mcast_qp_attach;
	int max_ah;
	int max_srq;
	int max_srq_wr;
	int max_srq_sge;
	unsigned int max_fast_reg_page_list_len;
	unsigned int max_pi_fast_reg_page_list_len;
	u16 max_pkeys;
	u8 local_ca_ack_delay;
	int sig_prot_cap;
	int sig_guard_cap;
	struct ib_odp_caps odp_caps;
	uint64_t timestamp_mask;
	uint64_t hca_core_clock;
	struct ib_rss_caps rss_caps;
	u32 max_wq_type_rq;
	u32 raw_packet_caps;
	struct ib_tm_caps tm_caps;
	struct ib_cq_caps cq_caps;
	u64 max_dm_size;
	u32 max_sgl_rd;
};

struct rdma_restrack_root;

struct uapi_definition;

struct ib_port_data;

struct ib_device {
	struct device *dma_device;
	struct ib_device_ops ops;
	char name[64];
	struct callback_head callback_head;
	struct list_head event_handler_list;
	struct rw_semaphore event_handler_rwsem;
	spinlock_t qp_open_list_lock;
	struct rw_semaphore client_data_rwsem;
	struct xarray client_data;
	struct mutex unregistration_lock;
	rwlock_t cache_lock;
	struct ib_port_data *port_data;
	int num_comp_vectors;
	union {
		struct device dev;
		struct ib_core_device coredev;
	};
	const struct attribute_group *groups[3];
	u64 uverbs_cmd_mask;
	char node_desc[64];
	__be64 node_guid;
	u32 local_dma_lkey;
	u16 is_switch: 1;
	u16 kverbs_provider: 1;
	u16 use_cq_dim: 1;
	u8 node_type;
	u32 phys_port_cnt;
	struct ib_device_attr attrs;
	struct attribute_group *hw_stats_ag;
	struct rdma_hw_stats *hw_stats;
	struct rdmacg_device cg_device;
	u32 index;
	spinlock_t cq_pools_lock;
	struct list_head cq_pools[3];
	struct rdma_restrack_root *res;
	const struct uapi_definition *driver_def;
	refcount_t refcount;
	struct completion unreg_completion;
	struct work_struct unregistration_work;
	const struct rdma_link_ops *link_ops;
	struct mutex compat_devs_mutex;
	struct xarray compat_devs;
	char iw_ifname[16];
	u32 iw_driver_flags;
	u32 lag_flags;
};

enum ib_signature_type {
	IB_SIG_TYPE_NONE = 0,
	IB_SIG_TYPE_T10_DIF = 1,
};

enum ib_t10_dif_bg_type {
	IB_T10DIF_CRC = 0,
	IB_T10DIF_CSUM = 1,
};

struct ib_t10_dif_domain {
	enum ib_t10_dif_bg_type bg_type;
	u16 pi_interval;
	u16 bg;
	u16 app_tag;
	u32 ref_tag;
	bool ref_remap;
	bool app_escape;
	bool ref_escape;
	u16 apptag_check_mask;
};

struct ib_sig_domain {
	enum ib_signature_type sig_type;
	union {
		struct ib_t10_dif_domain dif;
	} sig;
};

struct ib_sig_attrs {
	u8 check_mask;
	struct ib_sig_domain mem;
	struct ib_sig_domain wire;
	int meta_length;
};

enum ib_sig_err_type {
	IB_SIG_BAD_GUARD = 0,
	IB_SIG_BAD_REFTAG = 1,
	IB_SIG_BAD_APPTAG = 2,
};

struct ib_sig_err {
	enum ib_sig_err_type err_type;
	u32 expected;
	u32 actual;
	u64 sig_err_offset;
	u32 key;
};

enum ib_uverbs_flow_action_esp_keymat {
	IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM = 0,
};

struct ib_uverbs_flow_action_esp_keymat_aes_gcm {
	__u64 iv;
	__u32 iv_algo;
	__u32 salt;
	__u32 icv_len;
	__u32 key_len;
	__u32 aes_key[8];
};

enum ib_uverbs_flow_action_esp_replay {
	IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE = 0,
	IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP = 1,
};

struct ib_uverbs_flow_action_esp_replay_bmp {
	__u32 size;
};

enum ib_gid_type {
	IB_GID_TYPE_IB = 0,
	IB_GID_TYPE_ROCE = 1,
	IB_GID_TYPE_ROCE_UDP_ENCAP = 2,
	IB_GID_TYPE_SIZE = 3,
};

struct ib_gid_attr {
	struct net_device *ndev;
	struct ib_device *device;
	union ib_gid gid;
	enum ib_gid_type gid_type;
	u16 index;
	u32 port_num;
};

struct ib_cq_init_attr {
	unsigned int cqe;
	u32 comp_vector;
	u32 flags;
};

struct ib_dm_mr_attr {
	u64 length;
	u64 offset;
	u32 access_flags;
};

struct ib_dm_alloc_attr {
	u64 length;
	u32 alignment;
	u32 flags;
};

enum ib_mtu {
	IB_MTU_256 = 1,
	IB_MTU_512 = 2,
	IB_MTU_1024 = 3,
	IB_MTU_2048 = 4,
	IB_MTU_4096 = 5,
};

enum ib_port_state {
	IB_PORT_NOP = 0,
	IB_PORT_DOWN = 1,
	IB_PORT_INIT = 2,
	IB_PORT_ARMED = 3,
	IB_PORT_ACTIVE = 4,
	IB_PORT_ACTIVE_DEFER = 5,
};

struct ib_port_attr {
	u64 subnet_prefix;
	enum ib_port_state state;
	enum ib_mtu max_mtu;
	enum ib_mtu active_mtu;
	u32 phys_mtu;
	int gid_tbl_len;
	unsigned int ip_gids: 1;
	u32 port_cap_flags;
	u32 max_msg_sz;
	u32 bad_pkey_cntr;
	u32 qkey_viol_cntr;
	u16 pkey_tbl_len;
	u32 sm_lid;
	u32 lid;
	u8 lmc;
	u8 max_vl_num;
	u8 sm_sl;
	u8 subnet_timeout;
	u8 init_type_reply;
	u8 active_width;
	u16 active_speed;
	u8 phys_state;
	u16 port_cap_flags2;
};

struct ib_device_modify {
	u64 sys_image_guid;
	char node_desc[64];
};

struct ib_port_modify {
	u32 set_port_cap_mask;
	u32 clr_port_cap_mask;
	u8 init_type;
};

enum ib_event_type {
	IB_EVENT_CQ_ERR = 0,
	IB_EVENT_QP_FATAL = 1,
	IB_EVENT_QP_REQ_ERR = 2,
	IB_EVENT_QP_ACCESS_ERR = 3,
	IB_EVENT_COMM_EST = 4,
	IB_EVENT_SQ_DRAINED = 5,
	IB_EVENT_PATH_MIG = 6,
	IB_EVENT_PATH_MIG_ERR = 7,
	IB_EVENT_DEVICE_FATAL = 8,
	IB_EVENT_PORT_ACTIVE = 9,
	IB_EVENT_PORT_ERR = 10,
	IB_EVENT_LID_CHANGE = 11,
	IB_EVENT_PKEY_CHANGE = 12,
	IB_EVENT_SM_CHANGE = 13,
	IB_EVENT_SRQ_ERR = 14,
	IB_EVENT_SRQ_LIMIT_REACHED = 15,
	IB_EVENT_QP_LAST_WQE_REACHED = 16,
	IB_EVENT_CLIENT_REREGISTER = 17,
	IB_EVENT_GID_CHANGE = 18,
	IB_EVENT_WQ_FATAL = 19,
};

struct ib_ucq_object;

typedef void (*ib_comp_handler)(struct ib_cq *, void *);

struct ib_event;

struct ib_cq {
	struct ib_device *device;
	struct ib_ucq_object *uobject;
	ib_comp_handler comp_handler;
	void (*event_handler)(struct ib_event *, void *);
	void *cq_context;
	int cqe;
	unsigned int cqe_used;
	atomic_t usecnt;
	enum ib_poll_context poll_ctx;
	struct ib_wc *wc;
	struct list_head pool_entry;
	union {
		struct irq_poll iop;
		struct work_struct work;
	};
	struct workqueue_struct *comp_wq;
	struct dim *dim;
	ktime_t timestamp;
	u8 interrupt: 1;
	u8 shared: 1;
	unsigned int comp_vector;
	struct rdma_restrack_entry res;
};

struct ib_uqp_object;

enum ib_qp_type {
	IB_QPT_SMI = 0,
	IB_QPT_GSI = 1,
	IB_QPT_RC = 2,
	IB_QPT_UC = 3,
	IB_QPT_UD = 4,
	IB_QPT_RAW_IPV6 = 5,
	IB_QPT_RAW_ETHERTYPE = 6,
	IB_QPT_RAW_PACKET = 8,
	IB_QPT_XRC_INI = 9,
	IB_QPT_XRC_TGT = 10,
	IB_QPT_MAX = 11,
	IB_QPT_DRIVER = 255,
	IB_QPT_RESERVED1 = 4096,
	IB_QPT_RESERVED2 = 4097,
	IB_QPT_RESERVED3 = 4098,
	IB_QPT_RESERVED4 = 4099,
	IB_QPT_RESERVED5 = 4100,
	IB_QPT_RESERVED6 = 4101,
	IB_QPT_RESERVED7 = 4102,
	IB_QPT_RESERVED8 = 4103,
	IB_QPT_RESERVED9 = 4104,
	IB_QPT_RESERVED10 = 4105,
};

struct ib_qp_security;

struct ib_qp {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	spinlock_t mr_lock;
	int mrs_used;
	struct list_head rdma_mrs;
	struct list_head sig_mrs;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct list_head xrcd_list;
	atomic_t usecnt;
	struct list_head open_list;
	struct ib_qp *real_qp;
	struct ib_uqp_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	const struct ib_gid_attr *av_sgid_attr;
	const struct ib_gid_attr *alt_path_sgid_attr;
	u32 qp_num;
	u32 max_write_sge;
	u32 max_read_sge;
	enum ib_qp_type qp_type;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	struct ib_qp_security *qp_sec;
	u32 port;
	bool integrity_en;
	struct rdma_restrack_entry res;
	struct rdma_counter *counter;
};

struct ib_usrq_object;

enum ib_srq_type {
	IB_SRQT_BASIC = 0,
	IB_SRQT_XRC = 1,
	IB_SRQT_TM = 2,
};

struct ib_srq {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_usrq_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	enum ib_srq_type srq_type;
	atomic_t usecnt;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
				u32 srq_num;
			} xrc;
		};
	} ext;
	struct rdma_restrack_entry res;
};

struct ib_uwq_object;

enum ib_wq_state {
	IB_WQS_RESET = 0,
	IB_WQS_RDY = 1,
	IB_WQS_ERR = 2,
};

enum ib_wq_type {
	IB_WQT_RQ = 0,
};

struct ib_wq {
	struct ib_device *device;
	struct ib_uwq_object *uobject;
	void *wq_context;
	void (*event_handler)(struct ib_event *, void *);
	struct ib_pd *pd;
	struct ib_cq *cq;
	u32 wq_num;
	enum ib_wq_state state;
	enum ib_wq_type wq_type;
	atomic_t usecnt;
};

struct ib_event {
	struct ib_device *device;
	union {
		struct ib_cq *cq;
		struct ib_qp *qp;
		struct ib_srq *srq;
		struct ib_wq *wq;
		u32 port_num;
	} element;
	enum ib_event_type event;
};

struct ib_global_route {
	const struct ib_gid_attr *sgid_attr;
	union ib_gid dgid;
	u32 flow_label;
	u8 sgid_index;
	u8 hop_limit;
	u8 traffic_class;
};

struct ib_grh {
	__be32 version_tclass_flow;
	__be16 paylen;
	u8 next_hdr;
	u8 hop_limit;
	union ib_gid sgid;
	union ib_gid dgid;
};

struct ib_mr_status {
	u32 fail_status;
	struct ib_sig_err sig_err;
};

struct rdma_ah_init_attr {
	struct rdma_ah_attr *ah_attr;
	u32 flags;
	struct net_device *xmit_slave;
};

enum rdma_ah_attr_type {
	RDMA_AH_ATTR_TYPE_UNDEFINED = 0,
	RDMA_AH_ATTR_TYPE_IB = 1,
	RDMA_AH_ATTR_TYPE_ROCE = 2,
	RDMA_AH_ATTR_TYPE_OPA = 3,
};

struct ib_ah_attr {
	u16 dlid;
	u8 src_path_bits;
};

struct roce_ah_attr {
	u8 dmac[6];
};

struct opa_ah_attr {
	u32 dlid;
	u8 src_path_bits;
	bool make_grd;
};

struct rdma_ah_attr {
	struct ib_global_route grh;
	u8 sl;
	u8 static_rate;
	u32 port_num;
	u8 ah_flags;
	enum rdma_ah_attr_type type;
	union {
		struct ib_ah_attr ib;
		struct roce_ah_attr roce;
		struct opa_ah_attr opa;
	};
};

enum ib_wc_status {
	IB_WC_SUCCESS = 0,
	IB_WC_LOC_LEN_ERR = 1,
	IB_WC_LOC_QP_OP_ERR = 2,
	IB_WC_LOC_EEC_OP_ERR = 3,
	IB_WC_LOC_PROT_ERR = 4,
	IB_WC_WR_FLUSH_ERR = 5,
	IB_WC_MW_BIND_ERR = 6,
	IB_WC_BAD_RESP_ERR = 7,
	IB_WC_LOC_ACCESS_ERR = 8,
	IB_WC_REM_INV_REQ_ERR = 9,
	IB_WC_REM_ACCESS_ERR = 10,
	IB_WC_REM_OP_ERR = 11,
	IB_WC_RETRY_EXC_ERR = 12,
	IB_WC_RNR_RETRY_EXC_ERR = 13,
	IB_WC_LOC_RDD_VIOL_ERR = 14,
	IB_WC_REM_INV_RD_REQ_ERR = 15,
	IB_WC_REM_ABORT_ERR = 16,
	IB_WC_INV_EECN_ERR = 17,
	IB_WC_INV_EEC_STATE_ERR = 18,
	IB_WC_FATAL_ERR = 19,
	IB_WC_RESP_TIMEOUT_ERR = 20,
	IB_WC_GENERAL_ERR = 21,
};

enum ib_wc_opcode {
	IB_WC_SEND = 0,
	IB_WC_RDMA_WRITE = 1,
	IB_WC_RDMA_READ = 2,
	IB_WC_COMP_SWAP = 3,
	IB_WC_FETCH_ADD = 4,
	IB_WC_BIND_MW = 5,
	IB_WC_LOCAL_INV = 6,
	IB_WC_LSO = 7,
	IB_WC_REG_MR = 8,
	IB_WC_MASKED_COMP_SWAP = 9,
	IB_WC_MASKED_FETCH_ADD = 10,
	IB_WC_RECV = 128,
	IB_WC_RECV_RDMA_WITH_IMM = 129,
};

struct ib_cqe {
	void (*done)(struct ib_cq *, struct ib_wc *);
};

struct ib_wc {
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	enum ib_wc_status status;
	enum ib_wc_opcode opcode;
	u32 vendor_err;
	u32 byte_len;
	struct ib_qp *qp;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
	u32 src_qp;
	u32 slid;
	int wc_flags;
	u16 pkey_index;
	u8 sl;
	u8 dlid_path_bits;
	u32 port_num;
	u8 smac[6];
	u16 vlan_id;
	u8 network_hdr_type;
};

struct ib_srq_attr {
	u32 max_wr;
	u32 max_sge;
	u32 srq_limit;
};

struct ib_xrcd {
	struct ib_device *device;
	atomic_t usecnt;
	struct inode *inode;
	struct rw_semaphore tgt_qps_rwsem;
	struct xarray tgt_qps;
};

struct ib_srq_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	struct ib_srq_attr attr;
	enum ib_srq_type srq_type;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
			} xrc;
			struct {
				u32 max_num_tags;
			} tag_matching;
		};
	} ext;
};

struct ib_qp_cap {
	u32 max_send_wr;
	u32 max_recv_wr;
	u32 max_send_sge;
	u32 max_recv_sge;
	u32 max_inline_data;
	u32 max_rdma_ctxs;
};

enum ib_sig_type {
	IB_SIGNAL_ALL_WR = 0,
	IB_SIGNAL_REQ_WR = 1,
};

struct ib_qp_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct ib_qp_cap cap;
	enum ib_sig_type sq_sig_type;
	enum ib_qp_type qp_type;
	u32 create_flags;
	u32 port_num;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	u32 source_qpn;
};

struct ib_uobject;

struct ib_rwq_ind_table {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 ind_tbl_num;
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

enum ib_qp_state {
	IB_QPS_RESET = 0,
	IB_QPS_INIT = 1,
	IB_QPS_RTR = 2,
	IB_QPS_RTS = 3,
	IB_QPS_SQD = 4,
	IB_QPS_SQE = 5,
	IB_QPS_ERR = 6,
};

enum ib_mig_state {
	IB_MIG_MIGRATED = 0,
	IB_MIG_REARM = 1,
	IB_MIG_ARMED = 2,
};

enum ib_mw_type {
	IB_MW_TYPE_1 = 1,
	IB_MW_TYPE_2 = 2,
};

struct ib_qp_attr {
	enum ib_qp_state qp_state;
	enum ib_qp_state cur_qp_state;
	enum ib_mtu path_mtu;
	enum ib_mig_state path_mig_state;
	u32 qkey;
	u32 rq_psn;
	u32 sq_psn;
	u32 dest_qp_num;
	int qp_access_flags;
	struct ib_qp_cap cap;
	struct rdma_ah_attr ah_attr;
	struct rdma_ah_attr alt_ah_attr;
	u16 pkey_index;
	u16 alt_pkey_index;
	u8 en_sqd_async_notify;
	u8 sq_draining;
	u8 max_rd_atomic;
	u8 max_dest_rd_atomic;
	u8 min_rnr_timer;
	u32 port_num;
	u8 timeout;
	u8 retry_cnt;
	u8 rnr_retry;
	u32 alt_port_num;
	u8 alt_timeout;
	u32 rate_limit;
	struct net_device *xmit_slave;
};

enum ib_wr_opcode {
	IB_WR_RDMA_WRITE = 0,
	IB_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_WR_SEND = 2,
	IB_WR_SEND_WITH_IMM = 3,
	IB_WR_RDMA_READ = 4,
	IB_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_WR_BIND_MW = 8,
	IB_WR_LSO = 10,
	IB_WR_SEND_WITH_INV = 9,
	IB_WR_RDMA_READ_WITH_INV = 11,
	IB_WR_LOCAL_INV = 7,
	IB_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
	IB_WR_REG_MR = 32,
	IB_WR_REG_MR_INTEGRITY = 33,
	IB_WR_RESERVED1 = 240,
	IB_WR_RESERVED2 = 241,
	IB_WR_RESERVED3 = 242,
	IB_WR_RESERVED4 = 243,
	IB_WR_RESERVED5 = 244,
	IB_WR_RESERVED6 = 245,
	IB_WR_RESERVED7 = 246,
	IB_WR_RESERVED8 = 247,
	IB_WR_RESERVED9 = 248,
	IB_WR_RESERVED10 = 249,
};

struct ib_sge {
	u64 addr;
	u32 length;
	u32 lkey;
};

struct ib_send_wr {
	struct ib_send_wr *next;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
	enum ib_wr_opcode opcode;
	int send_flags;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
};

struct ib_ah {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	const struct ib_gid_attr *sgid_attr;
	enum rdma_ah_attr_type type;
};

struct ib_mr {
	struct ib_device *device;
	struct ib_pd *pd;
	u32 lkey;
	u32 rkey;
	u64 iova;
	u64 length;
	unsigned int page_size;
	enum ib_mr_type type;
	bool need_inval;
	union {
		struct ib_uobject *uobject;
		struct list_head qp_entry;
	};
	struct ib_dm *dm;
	struct ib_sig_attrs *sig_attrs;
	struct rdma_restrack_entry res;
};

struct ib_recv_wr {
	struct ib_recv_wr *next;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
};

struct ib_rdmacg_object {
	struct rdma_cgroup *cg;
};

struct ib_uverbs_file;

struct ib_ucontext {
	struct ib_device *device;
	struct ib_uverbs_file *ufile;
	struct ib_rdmacg_object cg_obj;
	struct rdma_restrack_entry res;
	struct xarray mmap_xa;
};

struct uverbs_api_object;

struct ib_uobject {
	u64 user_handle;
	struct ib_uverbs_file *ufile;
	struct ib_ucontext *context;
	void *object;
	struct list_head list;
	struct ib_rdmacg_object cg_obj;
	int id;
	struct kref ref;
	atomic_t usecnt;
	struct callback_head rcu;
	const struct uverbs_api_object *uapi_object;
};

struct ib_udata {
	const void *inbuf;
	void *outbuf;
	size_t inlen;
	size_t outlen;
};

struct ib_pd {
	u32 local_dma_lkey;
	u32 flags;
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 unsafe_global_rkey;
	struct ib_mr *__internal_mr;
	struct rdma_restrack_entry res;
};

struct ib_wq_init_attr {
	void *wq_context;
	enum ib_wq_type wq_type;
	u32 max_wr;
	u32 max_sge;
	struct ib_cq *cq;
	void (*event_handler)(struct ib_event *, void *);
	u32 create_flags;
};

struct ib_wq_attr {
	enum ib_wq_state wq_state;
	enum ib_wq_state curr_wq_state;
	u32 flags;
	u32 flags_mask;
};

struct ib_rwq_ind_table_init_attr {
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

enum port_pkey_state {
	IB_PORT_PKEY_NOT_VALID = 0,
	IB_PORT_PKEY_VALID = 1,
	IB_PORT_PKEY_LISTED = 2,
};

struct ib_port_pkey {
	enum port_pkey_state state;
	u16 pkey_index;
	u32 port_num;
	struct list_head qp_list;
	struct list_head to_error_list;
	struct ib_qp_security *sec;
};

struct ib_ports_pkeys;

struct ib_qp_security {
	struct ib_qp *qp;
	struct ib_device *dev;
	struct mutex mutex;
	struct ib_ports_pkeys *ports_pkeys;
	struct list_head shared_qp_list;
	void *security;
	bool destroying;
	atomic_t error_list_count;
	struct completion error_complete;
	int error_comps_pending;
};

struct ib_ports_pkeys {
	struct ib_port_pkey main;
	struct ib_port_pkey alt;
};

struct ib_dm {
	struct ib_device *device;
	u32 length;
	u32 flags;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

struct ib_mw {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	u32 rkey;
	enum ib_mw_type type;
};

enum ib_flow_attr_type {
	IB_FLOW_ATTR_NORMAL = 0,
	IB_FLOW_ATTR_ALL_DEFAULT = 1,
	IB_FLOW_ATTR_MC_DEFAULT = 2,
	IB_FLOW_ATTR_SNIFFER = 3,
};

enum ib_flow_spec_type {
	IB_FLOW_SPEC_ETH = 32,
	IB_FLOW_SPEC_IB = 34,
	IB_FLOW_SPEC_IPV4 = 48,
	IB_FLOW_SPEC_IPV6 = 49,
	IB_FLOW_SPEC_ESP = 52,
	IB_FLOW_SPEC_TCP = 64,
	IB_FLOW_SPEC_UDP = 65,
	IB_FLOW_SPEC_VXLAN_TUNNEL = 80,
	IB_FLOW_SPEC_GRE = 81,
	IB_FLOW_SPEC_MPLS = 96,
	IB_FLOW_SPEC_INNER = 256,
	IB_FLOW_SPEC_ACTION_TAG = 4096,
	IB_FLOW_SPEC_ACTION_DROP = 4097,
	IB_FLOW_SPEC_ACTION_HANDLE = 4098,
	IB_FLOW_SPEC_ACTION_COUNT = 4099,
};

struct ib_flow_eth_filter {
	u8 dst_mac[6];
	u8 src_mac[6];
	__be16 ether_type;
	__be16 vlan_tag;
	u8 real_sz[0];
};

struct ib_flow_spec_eth {
	u32 type;
	u16 size;
	struct ib_flow_eth_filter val;
	struct ib_flow_eth_filter mask;
};

struct ib_flow_ib_filter {
	__be16 dlid;
	__u8 sl;
	u8 real_sz[0];
};

struct ib_flow_spec_ib {
	u32 type;
	u16 size;
	struct ib_flow_ib_filter val;
	struct ib_flow_ib_filter mask;
};

struct ib_flow_ipv4_filter {
	__be32 src_ip;
	__be32 dst_ip;
	u8 proto;
	u8 tos;
	u8 ttl;
	u8 flags;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv4 {
	u32 type;
	u16 size;
	struct ib_flow_ipv4_filter val;
	struct ib_flow_ipv4_filter mask;
};

struct ib_flow_ipv6_filter {
	u8 src_ip[16];
	u8 dst_ip[16];
	__be32 flow_label;
	u8 next_hdr;
	u8 traffic_class;
	u8 hop_limit;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv6 {
	u32 type;
	u16 size;
	struct ib_flow_ipv6_filter val;
	struct ib_flow_ipv6_filter mask;
};

struct ib_flow_tcp_udp_filter {
	__be16 dst_port;
	__be16 src_port;
	u8 real_sz[0];
};

struct ib_flow_spec_tcp_udp {
	u32 type;
	u16 size;
	struct ib_flow_tcp_udp_filter val;
	struct ib_flow_tcp_udp_filter mask;
};

struct ib_flow_tunnel_filter {
	__be32 tunnel_id;
	u8 real_sz[0];
};

struct ib_flow_spec_tunnel {
	u32 type;
	u16 size;
	struct ib_flow_tunnel_filter val;
	struct ib_flow_tunnel_filter mask;
};

struct ib_flow_esp_filter {
	__be32 spi;
	__be32 seq;
	u8 real_sz[0];
};

struct ib_flow_spec_esp {
	u32 type;
	u16 size;
	struct ib_flow_esp_filter val;
	struct ib_flow_esp_filter mask;
};

struct ib_flow_gre_filter {
	__be16 c_ks_res0_ver;
	__be16 protocol;
	__be32 key;
	u8 real_sz[0];
};

struct ib_flow_spec_gre {
	u32 type;
	u16 size;
	struct ib_flow_gre_filter val;
	struct ib_flow_gre_filter mask;
};

struct ib_flow_mpls_filter {
	__be32 tag;
	u8 real_sz[0];
};

struct ib_flow_spec_mpls {
	u32 type;
	u16 size;
	struct ib_flow_mpls_filter val;
	struct ib_flow_mpls_filter mask;
};

struct ib_flow_spec_action_tag {
	enum ib_flow_spec_type type;
	u16 size;
	u32 tag_id;
};

struct ib_flow_spec_action_drop {
	enum ib_flow_spec_type type;
	u16 size;
};

struct ib_flow_spec_action_handle {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_flow_action *act;
};

enum ib_flow_action_type {
	IB_FLOW_ACTION_UNSPECIFIED = 0,
	IB_FLOW_ACTION_ESP = 1,
};

struct ib_flow_action {
	struct ib_device *device;
	struct ib_uobject *uobject;
	enum ib_flow_action_type type;
	atomic_t usecnt;
};

struct ib_flow_spec_action_count {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_counters *counters;
};

struct ib_counters {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

union ib_flow_spec {
	struct {
		u32 type;
		u16 size;
	};
	struct ib_flow_spec_eth eth;
	struct ib_flow_spec_ib ib;
	struct ib_flow_spec_ipv4 ipv4;
	struct ib_flow_spec_tcp_udp tcp_udp;
	struct ib_flow_spec_ipv6 ipv6;
	struct ib_flow_spec_tunnel tunnel;
	struct ib_flow_spec_esp esp;
	struct ib_flow_spec_gre gre;
	struct ib_flow_spec_mpls mpls;
	struct ib_flow_spec_action_tag flow_tag;
	struct ib_flow_spec_action_drop drop;
	struct ib_flow_spec_action_handle action;
	struct ib_flow_spec_action_count flow_count;
};

struct ib_flow_attr {
	enum ib_flow_attr_type type;
	u16 size;
	u16 priority;
	u32 flags;
	u8 num_of_specs;
	u32 port;
	union ib_flow_spec flows[0];
};

struct ib_flow {
	struct ib_qp *qp;
	struct ib_device *device;
	struct ib_uobject *uobject;
};

struct ib_flow_action_attrs_esp_keymats {
	enum ib_uverbs_flow_action_esp_keymat protocol;
	union {
		struct ib_uverbs_flow_action_esp_keymat_aes_gcm aes_gcm;
	} keymat;
};

struct ib_flow_action_attrs_esp_replays {
	enum ib_uverbs_flow_action_esp_replay protocol;
	union {
		struct ib_uverbs_flow_action_esp_replay_bmp bmp;
	} replay;
};

struct ib_flow_spec_list {
	struct ib_flow_spec_list *next;
	union ib_flow_spec spec;
};

struct ib_flow_action_attrs_esp {
	struct ib_flow_action_attrs_esp_keymats *keymat;
	struct ib_flow_action_attrs_esp_replays *replay;
	struct ib_flow_spec_list *encap;
	u32 esn;
	u32 spi;
	u32 seq;
	u32 tfc_pad;
	u64 flags;
	u64 hard_limit_pkts;
};

struct ib_pkey_cache;

struct ib_gid_table;

struct ib_port_cache {
	u64 subnet_prefix;
	struct ib_pkey_cache *pkey;
	struct ib_gid_table *gid;
	u8 lmc;
	enum ib_port_state port_state;
};

struct ib_port_immutable {
	int pkey_tbl_len;
	int gid_tbl_len;
	u32 core_cap_flags;
	u32 max_mad_size;
};

struct ib_port_data {
	struct ib_device *ib_dev;
	struct ib_port_immutable immutable;
	spinlock_t pkey_list_lock;
	struct list_head pkey_list;
	struct ib_port_cache cache;
	spinlock_t netdev_lock;
	struct net_device *netdev;
	struct hlist_node ndev_hash_link;
	struct rdma_port_counter port_counter;
	struct rdma_hw_stats *hw_stats;
};

struct rdma_netdev_alloc_params {
	size_t sizeof_priv;
	unsigned int txqs;
	unsigned int rxqs;
	void *param;
	int (*initialize_rdma_netdev)(struct ib_device *, u32, struct net_device *, void *);
};

struct ib_counters_read_attr {
	u64 *counters_buff;
	u32 ncounters;
	u32 flags;
};

struct rdma_user_mmap_entry {
	struct kref ref;
	struct ib_ucontext *ucontext;
	long unsigned int start_pgoff;
	size_t npages;
	bool driver_removed;
};

enum blk_zone_type {
	BLK_ZONE_TYPE_CONVENTIONAL = 1,
	BLK_ZONE_TYPE_SEQWRITE_REQ = 2,
	BLK_ZONE_TYPE_SEQWRITE_PREF = 3,
};

enum blk_zone_cond {
	BLK_ZONE_COND_NOT_WP = 0,
	BLK_ZONE_COND_EMPTY = 1,
	BLK_ZONE_COND_IMP_OPEN = 2,
	BLK_ZONE_COND_EXP_OPEN = 3,
	BLK_ZONE_COND_CLOSED = 4,
	BLK_ZONE_COND_READONLY = 13,
	BLK_ZONE_COND_FULL = 14,
	BLK_ZONE_COND_OFFLINE = 15,
};

enum blk_zone_report_flags {
	BLK_ZONE_REP_CAPACITY = 1,
};

struct blk_zone_report {
	__u64 sector;
	__u32 nr_zones;
	__u32 flags;
	struct blk_zone zones[0];
};

struct blk_zone_range {
	__u64 sector;
	__u64 nr_sectors;
};

struct zone_report_args {
	struct blk_zone *zones;
};

struct blk_revalidate_zone_args {
	struct gendisk *disk;
	long unsigned int *conv_zones_bitmap;
	long unsigned int *seq_zones_wlock;
	unsigned int nr_zones;
	sector_t zone_sectors;
	sector_t sector;
};

enum wbt_flags {
	WBT_TRACKED = 1,
	WBT_READ = 2,
	WBT_KSWAPD = 4,
	WBT_DISCARD = 8,
	WBT_NR_BITS = 4,
};

enum {
	WBT_STATE_ON_DEFAULT = 1,
	WBT_STATE_ON_MANUAL = 2,
	WBT_STATE_OFF_DEFAULT = 3,
};

struct rq_wb {
	unsigned int wb_background;
	unsigned int wb_normal;
	short int enable_state;
	unsigned int unknown_cnt;
	u64 win_nsec;
	u64 cur_win_nsec;
	struct blk_stat_callback *cb;
	u64 sync_issue;
	void *sync_cookie;
	unsigned int wc;
	long unsigned int last_issue;
	long unsigned int last_comp;
	long unsigned int min_lat_nsec;
	struct rq_qos rqos;
	struct rq_wait rq_wait[3];
	struct rq_depth rq_depth;
};

struct trace_event_raw_wbt_stat {
	struct trace_entry ent;
	char name[32];
	s64 rmean;
	u64 rmin;
	u64 rmax;
	s64 rnr_samples;
	s64 rtime;
	s64 wmean;
	u64 wmin;
	u64 wmax;
	s64 wnr_samples;
	s64 wtime;
	char __data[0];
};

struct trace_event_raw_wbt_lat {
	struct trace_entry ent;
	char name[32];
	long unsigned int lat;
	char __data[0];
};

struct trace_event_raw_wbt_step {
	struct trace_entry ent;
	char name[32];
	const char *msg;
	int step;
	long unsigned int window;
	unsigned int bg;
	unsigned int normal;
	unsigned int max;
	char __data[0];
};

struct trace_event_raw_wbt_timer {
	struct trace_entry ent;
	char name[32];
	unsigned int status;
	int step;
	unsigned int inflight;
	char __data[0];
};

struct trace_event_data_offsets_wbt_stat {};

struct trace_event_data_offsets_wbt_lat {};

struct trace_event_data_offsets_wbt_step {};

struct trace_event_data_offsets_wbt_timer {};

typedef void (*btf_trace_wbt_stat)(void *, struct backing_dev_info *, struct blk_rq_stat *);

typedef void (*btf_trace_wbt_lat)(void *, struct backing_dev_info *, long unsigned int);

typedef void (*btf_trace_wbt_step)(void *, struct backing_dev_info *, const char *, int, long unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_wbt_timer)(void *, struct backing_dev_info *, unsigned int, int, unsigned int);

enum {
	RWB_DEF_DEPTH = 16,
	RWB_WINDOW_NSEC = 100000000,
	RWB_MIN_WRITE_SAMPLES = 3,
	RWB_UNKNOWN_BUMP = 5,
};

enum {
	LAT_OK = 1,
	LAT_UNKNOWN = 2,
	LAT_UNKNOWN_WRITES = 3,
	LAT_EXCEEDED = 4,
};

struct wbt_wait_data {
	struct rq_wb *rwb;
	enum wbt_flags wb_acct;
	long unsigned int rw;
};

struct show_busy_params {
	struct seq_file *m;
	struct blk_mq_hw_ctx *hctx;
};

enum opal_mbr {
	OPAL_MBR_ENABLE = 0,
	OPAL_MBR_DISABLE = 1,
};

enum opal_mbr_done_flag {
	OPAL_MBR_NOT_DONE = 0,
	OPAL_MBR_DONE = 1,
};

enum opal_user {
	OPAL_ADMIN1 = 0,
	OPAL_USER1 = 1,
	OPAL_USER2 = 2,
	OPAL_USER3 = 3,
	OPAL_USER4 = 4,
	OPAL_USER5 = 5,
	OPAL_USER6 = 6,
	OPAL_USER7 = 7,
	OPAL_USER8 = 8,
	OPAL_USER9 = 9,
};

enum opal_lock_state {
	OPAL_RO = 1,
	OPAL_RW = 2,
	OPAL_LK = 4,
};

struct opal_key {
	__u8 lr;
	__u8 key_len;
	__u8 __align[6];
	__u8 key[256];
};

struct opal_lr_act {
	struct opal_key key;
	__u32 sum;
	__u8 num_lrs;
	__u8 lr[9];
	__u8 align[2];
};

struct opal_session_info {
	__u32 sum;
	__u32 who;
	struct opal_key opal_key;
};

struct opal_user_lr_setup {
	__u64 range_start;
	__u64 range_length;
	__u32 RLE;
	__u32 WLE;
	struct opal_session_info session;
};

struct opal_lock_unlock {
	struct opal_session_info session;
	__u32 l_state;
	__u8 __align[4];
};

struct opal_new_pw {
	struct opal_session_info session;
	struct opal_session_info new_user_pw;
};

struct opal_mbr_data {
	struct opal_key key;
	__u8 enable_disable;
	__u8 __align[7];
};

struct opal_mbr_done {
	struct opal_key key;
	__u8 done_flag;
	__u8 __align[7];
};

struct opal_shadow_mbr {
	struct opal_key key;
	const __u64 data;
	__u64 offset;
	__u64 size;
};

enum opal_table_ops {
	OPAL_READ_TABLE = 0,
	OPAL_WRITE_TABLE = 1,
};

struct opal_read_write_table {
	struct opal_key key;
	const __u64 data;
	const __u8 table_uid[8];
	__u64 offset;
	__u64 size;
	__u64 flags;
	__u64 priv;
};

typedef int sec_send_recv(void *, u16, u8, void *, size_t, bool);

enum {
	TCG_SECP_00 = 0,
	TCG_SECP_01 = 1,
};

enum opal_response_token {
	OPAL_DTA_TOKENID_BYTESTRING = 224,
	OPAL_DTA_TOKENID_SINT = 225,
	OPAL_DTA_TOKENID_UINT = 226,
	OPAL_DTA_TOKENID_TOKEN = 227,
	OPAL_DTA_TOKENID_INVALID = 0,
};

enum opal_uid {
	OPAL_SMUID_UID = 0,
	OPAL_THISSP_UID = 1,
	OPAL_ADMINSP_UID = 2,
	OPAL_LOCKINGSP_UID = 3,
	OPAL_ENTERPRISE_LOCKINGSP_UID = 4,
	OPAL_ANYBODY_UID = 5,
	OPAL_SID_UID = 6,
	OPAL_ADMIN1_UID = 7,
	OPAL_USER1_UID = 8,
	OPAL_USER2_UID = 9,
	OPAL_PSID_UID = 10,
	OPAL_ENTERPRISE_BANDMASTER0_UID = 11,
	OPAL_ENTERPRISE_ERASEMASTER_UID = 12,
	OPAL_TABLE_TABLE = 13,
	OPAL_LOCKINGRANGE_GLOBAL = 14,
	OPAL_LOCKINGRANGE_ACE_RDLOCKED = 15,
	OPAL_LOCKINGRANGE_ACE_WRLOCKED = 16,
	OPAL_MBRCONTROL = 17,
	OPAL_MBR = 18,
	OPAL_AUTHORITY_TABLE = 19,
	OPAL_C_PIN_TABLE = 20,
	OPAL_LOCKING_INFO_TABLE = 21,
	OPAL_ENTERPRISE_LOCKING_INFO_TABLE = 22,
	OPAL_DATASTORE = 23,
	OPAL_C_PIN_MSID = 24,
	OPAL_C_PIN_SID = 25,
	OPAL_C_PIN_ADMIN1 = 26,
	OPAL_HALF_UID_AUTHORITY_OBJ_REF = 27,
	OPAL_HALF_UID_BOOLEAN_ACE = 28,
	OPAL_UID_HEXFF = 29,
};

enum opal_method {
	OPAL_PROPERTIES = 0,
	OPAL_STARTSESSION = 1,
	OPAL_REVERT = 2,
	OPAL_ACTIVATE = 3,
	OPAL_EGET = 4,
	OPAL_ESET = 5,
	OPAL_NEXT = 6,
	OPAL_EAUTHENTICATE = 7,
	OPAL_GETACL = 8,
	OPAL_GENKEY = 9,
	OPAL_REVERTSP = 10,
	OPAL_GET = 11,
	OPAL_SET = 12,
	OPAL_AUTHENTICATE = 13,
	OPAL_RANDOM = 14,
	OPAL_ERASE = 15,
};

enum opal_token {
	OPAL_TRUE = 1,
	OPAL_FALSE = 0,
	OPAL_BOOLEAN_EXPR = 3,
	OPAL_TABLE = 0,
	OPAL_STARTROW = 1,
	OPAL_ENDROW = 2,
	OPAL_STARTCOLUMN = 3,
	OPAL_ENDCOLUMN = 4,
	OPAL_VALUES = 1,
	OPAL_TABLE_UID = 0,
	OPAL_TABLE_NAME = 1,
	OPAL_TABLE_COMMON = 2,
	OPAL_TABLE_TEMPLATE = 3,
	OPAL_TABLE_KIND = 4,
	OPAL_TABLE_COLUMN = 5,
	OPAL_TABLE_COLUMNS = 6,
	OPAL_TABLE_ROWS = 7,
	OPAL_TABLE_ROWS_FREE = 8,
	OPAL_TABLE_ROW_BYTES = 9,
	OPAL_TABLE_LASTID = 10,
	OPAL_TABLE_MIN = 11,
	OPAL_TABLE_MAX = 12,
	OPAL_PIN = 3,
	OPAL_RANGESTART = 3,
	OPAL_RANGELENGTH = 4,
	OPAL_READLOCKENABLED = 5,
	OPAL_WRITELOCKENABLED = 6,
	OPAL_READLOCKED = 7,
	OPAL_WRITELOCKED = 8,
	OPAL_ACTIVEKEY = 10,
	OPAL_LIFECYCLE = 6,
	OPAL_MAXRANGES = 4,
	OPAL_MBRENABLE = 1,
	OPAL_MBRDONE = 2,
	OPAL_HOSTPROPERTIES = 0,
	OPAL_STARTLIST = 240,
	OPAL_ENDLIST = 241,
	OPAL_STARTNAME = 242,
	OPAL_ENDNAME = 243,
	OPAL_CALL = 248,
	OPAL_ENDOFDATA = 249,
	OPAL_ENDOFSESSION = 250,
	OPAL_STARTTRANSACTON = 251,
	OPAL_ENDTRANSACTON = 252,
	OPAL_EMPTYATOM = 255,
	OPAL_WHERE = 0,
};

enum opal_parameter {
	OPAL_SUM_SET_LIST = 393216,
};

struct opal_compacket {
	__be32 reserved0;
	u8 extendedComID[4];
	__be32 outstandingData;
	__be32 minTransfer;
	__be32 length;
};

struct opal_packet {
	__be32 tsn;
	__be32 hsn;
	__be32 seq_number;
	__be16 reserved0;
	__be16 ack_type;
	__be32 acknowledgment;
	__be32 length;
};

struct opal_data_subpacket {
	u8 reserved0[6];
	__be16 kind;
	__be32 length;
};

struct opal_header {
	struct opal_compacket cp;
	struct opal_packet pkt;
	struct opal_data_subpacket subpkt;
};

struct d0_header {
	__be32 length;
	__be32 revision;
	__be32 reserved01;
	__be32 reserved02;
	u8 ignored[32];
};

struct d0_tper_features {
	u8 supported_features;
	u8 reserved01[3];
	__be32 reserved02;
	__be32 reserved03;
};

struct d0_locking_features {
	u8 supported_features;
	u8 reserved01[3];
	__be32 reserved02;
	__be32 reserved03;
};

struct d0_geometry_features {
	u8 header[4];
	u8 reserved01;
	u8 reserved02[7];
	__be32 logical_block_size;
	__be64 alignment_granularity;
	__be64 lowest_aligned_lba;
};

struct d0_opal_v100 {
	__be16 baseComID;
	__be16 numComIDs;
};

struct d0_single_user_mode {
	__be32 num_locking_objects;
	u8 reserved01;
	u8 reserved02;
	__be16 reserved03;
	__be32 reserved04;
};

struct d0_opal_v200 {
	__be16 baseComID;
	__be16 numComIDs;
	u8 range_crossing;
	u8 num_locking_admin_auth[2];
	u8 num_locking_user_auth[2];
	u8 initialPIN;
	u8 revertedPIN;
	u8 reserved01;
	__be32 reserved02;
};

struct d0_features {
	__be16 code;
	u8 r_version;
	u8 length;
	u8 features[0];
};

struct opal_dev;

struct opal_step {
	int (*fn)(struct opal_dev *, void *);
	void *data;
};

enum opal_atom_width {
	OPAL_WIDTH_TINY = 0,
	OPAL_WIDTH_SHORT = 1,
	OPAL_WIDTH_MEDIUM = 2,
	OPAL_WIDTH_LONG = 3,
	OPAL_WIDTH_TOKEN = 4,
};

struct opal_resp_tok {
	const u8 *pos;
	size_t len;
	enum opal_response_token type;
	enum opal_atom_width width;
	union {
		u64 u;
		s64 s;
	} stored;
};

struct parsed_resp {
	int num;
	struct opal_resp_tok toks[64];
};

struct opal_dev {
	bool supported;
	bool mbr_enabled;
	void *data;
	sec_send_recv *send_recv;
	struct mutex dev_lock;
	u16 comid;
	u32 hsn;
	u32 tsn;
	u64 align;
	u64 lowest_lba;
	size_t pos;
	u8 cmd[2048];
	u8 resp[2048];
	struct parsed_resp parsed;
	size_t prev_d_len;
	void *prev_data;
	struct list_head unlk_lst;
};

typedef int cont_fn(struct opal_dev *);

struct opal_suspend_data {
	struct opal_lock_unlock unlk;
	u8 lr;
	struct list_head node;
};

struct blk_ksm_keyslot {
	atomic_t slot_refs;
	struct list_head idle_slot_node;
	struct hlist_node hash_node;
	const struct blk_crypto_key *key;
	struct blk_keyslot_manager *ksm;
};

struct blk_ksm_ll_ops {
	int (*keyslot_program)(struct blk_keyslot_manager *, const struct blk_crypto_key *, unsigned int);
	int (*keyslot_evict)(struct blk_keyslot_manager *, const struct blk_crypto_key *, unsigned int);
};

struct blk_keyslot_manager {
	struct blk_ksm_ll_ops ksm_ll_ops;
	unsigned int max_dun_bytes_supported;
	unsigned int crypto_modes_supported[4];
	struct device *dev;
	unsigned int num_slots;
	struct rw_semaphore lock;
	wait_queue_head_t idle_slots_wait_queue;
	struct list_head idle_slots;
	spinlock_t idle_slots_lock;
	struct hlist_head *slot_hashtable;
	unsigned int log_slot_ht_size;
	struct blk_ksm_keyslot *slots;
};

struct bio_fallback_crypt_ctx {
	struct bio_crypt_ctx crypt_ctx;
	struct bvec_iter crypt_iter;
	union {
		struct {
			struct work_struct work;
			struct bio *bio;
		};
		struct {
			void *bi_private_orig;
			bio_end_io_t *bi_end_io_orig;
		};
	};
};

struct blk_crypto_keyslot {
	enum blk_crypto_mode_num crypto_mode;
	struct crypto_skcipher *tfms[4];
};

union blk_crypto_iv {
	__le64 dun[4];
	u8 bytes[32];
};

typedef void (*swap_func_t)(void *, void *, int);

typedef int (*cmp_r_func_t)(const void *, const void *, const void *);

struct siprand_state {
	long unsigned int v0;
	long unsigned int v1;
	long unsigned int v2;
	long unsigned int v3;
};

typedef __kernel_long_t __kernel_ptrdiff_t;

typedef __kernel_ptrdiff_t ptrdiff_t;

struct region {
	unsigned int start;
	unsigned int off;
	unsigned int group_len;
	unsigned int end;
	unsigned int nbits;
};

enum {
	REG_OP_ISFREE = 0,
	REG_OP_ALLOC = 1,
	REG_OP_RELEASE = 2,
};

typedef struct scatterlist *sg_alloc_fn(unsigned int, gfp_t);

typedef void sg_free_fn(struct scatterlist *, unsigned int);

struct sg_page_iter {
	struct scatterlist *sg;
	unsigned int sg_pgoffset;
	unsigned int __nents;
	int __pg_advance;
};

struct sg_dma_page_iter {
	struct sg_page_iter base;
};

struct sg_mapping_iter {
	struct page *page;
	void *addr;
	size_t length;
	size_t consumed;
	struct sg_page_iter piter;
	unsigned int __offset;
	unsigned int __remaining;
	unsigned int __flags;
};

typedef int (*list_cmp_func_t)(void *, const struct list_head *, const struct list_head *);

struct csum_state {
	__wsum csum;
	size_t off;
};

struct rhashtable_walker {
	struct list_head list;
	struct bucket_table *tbl;
};

struct rhashtable_iter {
	struct rhashtable *ht;
	struct rhash_head *p;
	struct rhlist_head *list;
	struct rhashtable_walker walker;
	unsigned int slot;
	unsigned int skip;
	bool end_of_table;
};

union nested_table {
	union nested_table *table;
	struct rhash_lock_head *bucket;
};

struct once_work {
	struct work_struct work;
	struct static_key_true *key;
	struct module *module;
};

struct genradix_iter {
	size_t offset;
	size_t pos;
};

struct genradix_node {
	union {
		struct genradix_node *children[512];
		u8 data[4096];
	};
};

struct reciprocal_value_adv {
	u32 m;
	u8 sh;
	u8 exp;
	bool is_wide_m;
};

enum devm_ioremap_type {
	DEVM_IOREMAP = 0,
	DEVM_IOREMAP_UC = 1,
	DEVM_IOREMAP_WC = 2,
	DEVM_IOREMAP_NP = 3,
};

struct pcim_iomap_devres {
	void *table[6];
};

struct btree_head {
	long unsigned int *node;
	mempool_t *mempool;
	int height;
};

struct btree_geo {
	int keylen;
	int no_pairs;
	int no_longs;
};

typedef void (*visitor128_t)(void *, long unsigned int, u64, u64, size_t);

typedef void (*visitorl_t)(void *, long unsigned int, long unsigned int, size_t);

typedef void (*visitor32_t)(void *, long unsigned int, u32, size_t);

typedef void (*visitor64_t)(void *, long unsigned int, u64, size_t);

enum assoc_array_walk_status {
	assoc_array_walk_tree_empty = 0,
	assoc_array_walk_found_terminal_node = 1,
	assoc_array_walk_found_wrong_shortcut = 2,
};

struct assoc_array_walk_result {
	struct {
		struct assoc_array_node *node;
		int level;
		int slot;
	} terminal_node;
	struct {
		struct assoc_array_shortcut *shortcut;
		int level;
		int sc_level;
		long unsigned int sc_segments;
		long unsigned int dissimilarity;
	} wrong_shortcut;
};

struct assoc_array_delete_collapse_context {
	struct assoc_array_node *node;
	const void *skip_leaf;
	int slot;
};

struct linear_range {
	unsigned int min;
	unsigned int min_sel;
	unsigned int max_sel;
	unsigned int step;
};

enum packing_op {
	PACK = 0,
	UNPACK = 1,
};

struct xxh32_state {
	uint32_t total_len_32;
	uint32_t large_len;
	uint32_t v1;
	uint32_t v2;
	uint32_t v3;
	uint32_t v4;
	uint32_t mem32[4];
	uint32_t memsize;
};

struct xxh64_state {
	uint64_t total_len;
	uint64_t v1;
	uint64_t v2;
	uint64_t v3;
	uint64_t v4;
	uint64_t mem64[4];
	uint32_t memsize;
};

struct gen_pool_chunk {
	struct list_head next_chunk;
	atomic_long_t avail;
	phys_addr_t phys_addr;
	void *owner;
	long unsigned int start_addr;
	long unsigned int end_addr;
	long unsigned int bits[0];
};

struct genpool_data_align {
	int align;
};

struct genpool_data_fixed {
	long unsigned int offset;
};

typedef z_stream *z_streamp;

typedef struct {
	unsigned char op;
	unsigned char bits;
	short unsigned int val;
} code;

typedef enum {
	HEAD = 0,
	FLAGS = 1,
	TIME = 2,
	OS = 3,
	EXLEN = 4,
	EXTRA = 5,
	NAME = 6,
	COMMENT = 7,
	HCRC = 8,
	DICTID = 9,
	DICT = 10,
	TYPE = 11,
	TYPEDO = 12,
	STORED = 13,
	COPY = 14,
	TABLE = 15,
	LENLENS = 16,
	CODELENS = 17,
	LEN = 18,
	LENEXT = 19,
	DIST = 20,
	DISTEXT = 21,
	MATCH = 22,
	LIT = 23,
	CHECK = 24,
	LENGTH = 25,
	DONE = 26,
	BAD = 27,
	MEM = 28,
	SYNC = 29,
} inflate_mode;

struct inflate_state {
	inflate_mode mode;
	int last;
	int wrap;
	int havedict;
	int flags;
	unsigned int dmax;
	long unsigned int check;
	long unsigned int total;
	unsigned int wbits;
	unsigned int wsize;
	unsigned int whave;
	unsigned int write;
	unsigned char *window;
	long unsigned int hold;
	unsigned int bits;
	unsigned int length;
	unsigned int offset;
	unsigned int extra;
	const code *lencode;
	const code *distcode;
	unsigned int lenbits;
	unsigned int distbits;
	unsigned int ncode;
	unsigned int nlen;
	unsigned int ndist;
	unsigned int have;
	code *next;
	short unsigned int lens[320];
	short unsigned int work[288];
	code codes[2048];
};

union uu {
	short unsigned int us;
	unsigned char b[2];
};

typedef unsigned int uInt;

struct inflate_workspace {
	struct inflate_state inflate_state;
	unsigned char working_window[32768];
};

typedef enum {
	CODES = 0,
	LENS = 1,
	DISTS = 2,
} codetype;

typedef unsigned char uch;

typedef short unsigned int ush;

typedef long unsigned int ulg;

struct ct_data_s {
	union {
		ush freq;
		ush code;
	} fc;
	union {
		ush dad;
		ush len;
	} dl;
};

typedef struct ct_data_s ct_data;

struct static_tree_desc_s {
	const ct_data *static_tree;
	const int *extra_bits;
	int extra_base;
	int elems;
	int max_length;
};

typedef struct static_tree_desc_s static_tree_desc;

struct tree_desc_s {
	ct_data *dyn_tree;
	int max_code;
	static_tree_desc *stat_desc;
};

typedef ush Pos;

typedef unsigned int IPos;

struct deflate_state {
	z_streamp strm;
	int status;
	Byte *pending_buf;
	ulg pending_buf_size;
	Byte *pending_out;
	int pending;
	int noheader;
	Byte data_type;
	Byte method;
	int last_flush;
	uInt w_size;
	uInt w_bits;
	uInt w_mask;
	Byte *window;
	ulg window_size;
	Pos *prev;
	Pos *head;
	uInt ins_h;
	uInt hash_size;
	uInt hash_bits;
	uInt hash_mask;
	uInt hash_shift;
	long int block_start;
	uInt match_length;
	IPos prev_match;
	int match_available;
	uInt strstart;
	uInt match_start;
	uInt lookahead;
	uInt prev_length;
	uInt max_chain_length;
	uInt max_lazy_match;
	int level;
	int strategy;
	uInt good_match;
	int nice_match;
	struct ct_data_s dyn_ltree[573];
	struct ct_data_s dyn_dtree[61];
	struct ct_data_s bl_tree[39];
	struct tree_desc_s l_desc;
	struct tree_desc_s d_desc;
	struct tree_desc_s bl_desc;
	ush bl_count[16];
	int heap[573];
	int heap_len;
	int heap_max;
	uch depth[573];
	uch *l_buf;
	uInt lit_bufsize;
	uInt last_lit;
	ush *d_buf;
	ulg opt_len;
	ulg static_len;
	ulg compressed_len;
	uInt matches;
	int last_eob_len;
	ush bi_buf;
	int bi_valid;
};

typedef struct deflate_state deflate_state;

typedef enum {
	need_more = 0,
	block_done = 1,
	finish_started = 2,
	finish_done = 3,
} block_state;

typedef block_state (*compress_func)(deflate_state *, int);

struct deflate_workspace {
	deflate_state deflate_memory;
	Byte *window_memory;
	Pos *prev_memory;
	Pos *head_memory;
	char *overlay_memory;
};

typedef struct deflate_workspace deflate_workspace;

struct config_s {
	ush good_length;
	ush max_lazy;
	ush nice_length;
	ush max_chain;
	compress_func func;
};

typedef struct config_s config;

typedef struct tree_desc_s tree_desc;

typedef struct {
	const uint8_t *externalDict;
	size_t extDictSize;
	const uint8_t *prefixEnd;
	size_t prefixSize;
} LZ4_streamDecode_t_internal;

typedef union {
	long long unsigned int table[4];
	LZ4_streamDecode_t_internal internal_donotuse;
} LZ4_streamDecode_t;

typedef uint8_t BYTE;

typedef uint16_t U16;

typedef uint32_t U32;

typedef uint64_t U64;

typedef uintptr_t uptrval;

typedef enum {
	noDict = 0,
	withPrefix64k = 1,
	usingExtDict = 2,
} dict_directive;

typedef enum {
	endOnOutputSize = 0,
	endOnInputSize = 1,
} endCondition_directive;

typedef enum {
	decode_full_block = 0,
	partial_decode = 1,
} earlyEnd_directive;

typedef struct {
	size_t bitContainer;
	unsigned int bitsConsumed;
	const char *ptr;
	const char *start;
} BIT_DStream_t;

typedef enum {
	BIT_DStream_unfinished = 0,
	BIT_DStream_endOfBuffer = 1,
	BIT_DStream_completed = 2,
	BIT_DStream_overflow = 3,
} BIT_DStream_status;

typedef U32 HUF_DTable;

typedef struct {
	BYTE maxTableLog;
	BYTE tableType;
	BYTE tableLog;
	BYTE reserved;
} DTableDesc;

typedef struct {
	BYTE byte;
	BYTE nbBits;
} HUF_DEltX2;

typedef struct {
	U16 sequence;
	BYTE nbBits;
	BYTE length;
} HUF_DEltX4;

typedef struct {
	BYTE symbol;
	BYTE weight;
} sortedSymbol_t;

typedef U32 rankValCol_t[13];

typedef struct {
	U32 tableTime;
	U32 decode256Time;
} algo_time_t;

typedef unsigned int FSE_DTable;

typedef struct {
	FSE_DTable LLTable[513];
	FSE_DTable OFTable[257];
	FSE_DTable MLTable[513];
	HUF_DTable hufTable[4097];
	U64 workspace[384];
	U32 rep[3];
} ZSTD_entropyTables_t;

typedef struct {
	long long unsigned int frameContentSize;
	unsigned int windowSize;
	unsigned int dictID;
	unsigned int checksumFlag;
} ZSTD_frameParams;

typedef enum {
	bt_raw = 0,
	bt_rle = 1,
	bt_compressed = 2,
	bt_reserved = 3,
} blockType_e;

typedef enum {
	ZSTDds_getFrameHeaderSize = 0,
	ZSTDds_decodeFrameHeader = 1,
	ZSTDds_decodeBlockHeader = 2,
	ZSTDds_decompressBlock = 3,
	ZSTDds_decompressLastBlock = 4,
	ZSTDds_checkChecksum = 5,
	ZSTDds_decodeSkippableHeader = 6,
	ZSTDds_skipFrame = 7,
} ZSTD_dStage;

typedef void * (*ZSTD_allocFunction)(void *, size_t);

typedef void (*ZSTD_freeFunction)(void *, void *);

typedef struct {
	ZSTD_allocFunction customAlloc;
	ZSTD_freeFunction customFree;
	void *opaque;
} ZSTD_customMem;

struct ZSTD_DCtx_s {
	const FSE_DTable *LLTptr;
	const FSE_DTable *MLTptr;
	const FSE_DTable *OFTptr;
	const HUF_DTable *HUFptr;
	ZSTD_entropyTables_t entropy;
	const void *previousDstEnd;
	const void *base;
	const void *vBase;
	const void *dictEnd;
	size_t expected;
	ZSTD_frameParams fParams;
	blockType_e bType;
	ZSTD_dStage stage;
	U32 litEntropy;
	U32 fseEntropy;
	struct xxh64_state xxhState;
	size_t headerSize;
	U32 dictID;
	const BYTE *litPtr;
	ZSTD_customMem customMem;
	size_t litSize;
	size_t rleSize;
	BYTE litBuffer[131080];
	BYTE headerBuffer[18];
};

typedef struct ZSTD_DCtx_s ZSTD_DCtx;

struct ZSTD_DDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictSize;
	ZSTD_entropyTables_t entropy;
	U32 dictID;
	U32 entropyPresent;
	ZSTD_customMem cMem;
};

typedef struct ZSTD_DDict_s ZSTD_DDict;

typedef enum {
	zdss_init = 0,
	zdss_loadHeader = 1,
	zdss_read = 2,
	zdss_load = 3,
	zdss_flush = 4,
} ZSTD_dStreamStage;

struct ZSTD_DStream_s___2 {
	ZSTD_DCtx *dctx;
	ZSTD_DDict *ddictLocal;
	const ZSTD_DDict *ddict;
	ZSTD_frameParams fParams;
	ZSTD_dStreamStage stage;
	char *inBuff;
	size_t inBuffSize;
	size_t inPos;
	size_t maxWindowSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outStart;
	size_t outEnd;
	size_t blockSize;
	BYTE headerBuffer[18];
	size_t lhSize;
	ZSTD_customMem customMem;
	void *legacyContext;
	U32 previousLegacyVersion;
	U32 legacyVersion;
	U32 hostageByte;
};

typedef struct ZSTD_DStream_s___2 ZSTD_DStream___2;

typedef enum {
	ZSTDnit_frameHeader = 0,
	ZSTDnit_blockHeader = 1,
	ZSTDnit_block = 2,
	ZSTDnit_lastBlock = 3,
	ZSTDnit_checksum = 4,
	ZSTDnit_skippableFrame = 5,
} ZSTD_nextInputType_e;

typedef int16_t S16;

typedef uintptr_t uPtrDiff;

typedef struct {
	size_t state;
	const void *table;
} FSE_DState_t;

typedef struct {
	U16 tableLog;
	U16 fastMode;
} FSE_DTableHeader;

typedef struct {
	short unsigned int newState;
	unsigned char symbol;
	unsigned char nbBits;
} FSE_decode_t;

typedef enum {
	set_basic = 0,
	set_rle = 1,
	set_compressed = 2,
	set_repeat = 3,
} symbolEncodingType_e;

typedef struct {
	blockType_e blockType;
	U32 lastBlock;
	U32 origSize;
} blockProperties_t;

typedef union {
	FSE_decode_t realData;
	U32 alignedBy4;
} FSE_decode_t4;

typedef struct {
	size_t litLength;
	size_t matchLength;
	size_t offset;
	const BYTE *match;
} seq_t;

typedef struct {
	BIT_DStream_t DStream;
	FSE_DState_t stateLL;
	FSE_DState_t stateOffb;
	FSE_DState_t stateML;
	size_t prevOffset[3];
	const BYTE *base;
	size_t pos;
	uPtrDiff gotoDict;
} seqState_t;

typedef struct {
	void *ptr;
	const void *end;
} ZSTD_stack;

typedef uint64_t vli_type;

enum xz_check {
	XZ_CHECK_NONE = 0,
	XZ_CHECK_CRC32 = 1,
	XZ_CHECK_CRC64 = 4,
	XZ_CHECK_SHA256 = 10,
};

struct xz_dec_hash {
	vli_type unpadded;
	vli_type uncompressed;
	uint32_t crc32;
};

struct xz_dec_lzma2;

struct xz_dec_bcj;

struct xz_dec___2 {
	enum {
		SEQ_STREAM_HEADER = 0,
		SEQ_BLOCK_START = 1,
		SEQ_BLOCK_HEADER = 2,
		SEQ_BLOCK_UNCOMPRESS = 3,
		SEQ_BLOCK_PADDING = 4,
		SEQ_BLOCK_CHECK = 5,
		SEQ_INDEX = 6,
		SEQ_INDEX_PADDING = 7,
		SEQ_INDEX_CRC32 = 8,
		SEQ_STREAM_FOOTER = 9,
	} sequence;
	uint32_t pos;
	vli_type vli;
	size_t in_start;
	size_t out_start;
	uint32_t crc32;
	enum xz_check check_type;
	enum xz_mode mode;
	bool allow_buf_error;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		uint32_t size;
	} block_header;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		vli_type count;
		struct xz_dec_hash hash;
	} block;
	struct {
		enum {
			SEQ_INDEX_COUNT = 0,
			SEQ_INDEX_UNPADDED = 1,
			SEQ_INDEX_UNCOMPRESSED = 2,
		} sequence;
		vli_type size;
		vli_type count;
		struct xz_dec_hash hash;
	} index;
	struct {
		size_t pos;
		size_t size;
		uint8_t buf[1024];
	} temp;
	struct xz_dec_lzma2 *lzma2;
	struct xz_dec_bcj *bcj;
	bool bcj_active;
};

enum lzma_state {
	STATE_LIT_LIT = 0,
	STATE_MATCH_LIT_LIT = 1,
	STATE_REP_LIT_LIT = 2,
	STATE_SHORTREP_LIT_LIT = 3,
	STATE_MATCH_LIT = 4,
	STATE_REP_LIT = 5,
	STATE_SHORTREP_LIT = 6,
	STATE_LIT_MATCH = 7,
	STATE_LIT_LONGREP = 8,
	STATE_LIT_SHORTREP = 9,
	STATE_NONLIT_MATCH = 10,
	STATE_NONLIT_REP = 11,
};

struct dictionary {
	uint8_t *buf;
	size_t start;
	size_t pos;
	size_t full;
	size_t limit;
	size_t end;
	uint32_t size;
	uint32_t size_max;
	uint32_t allocated;
	enum xz_mode mode;
};

struct rc_dec {
	uint32_t range;
	uint32_t code;
	uint32_t init_bytes_left;
	const uint8_t *in;
	size_t in_pos;
	size_t in_limit;
};

struct lzma_len_dec {
	uint16_t choice;
	uint16_t choice2;
	uint16_t low[128];
	uint16_t mid[128];
	uint16_t high[256];
};

struct lzma_dec {
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
	enum lzma_state state;
	uint32_t len;
	uint32_t lc;
	uint32_t literal_pos_mask;
	uint32_t pos_mask;
	uint16_t is_match[192];
	uint16_t is_rep[12];
	uint16_t is_rep0[12];
	uint16_t is_rep1[12];
	uint16_t is_rep2[12];
	uint16_t is_rep0_long[192];
	uint16_t dist_slot[256];
	uint16_t dist_special[114];
	uint16_t dist_align[16];
	struct lzma_len_dec match_len_dec;
	struct lzma_len_dec rep_len_dec;
	uint16_t literal[12288];
};

enum lzma2_seq {
	SEQ_CONTROL = 0,
	SEQ_UNCOMPRESSED_1 = 1,
	SEQ_UNCOMPRESSED_2 = 2,
	SEQ_COMPRESSED_0 = 3,
	SEQ_COMPRESSED_1 = 4,
	SEQ_PROPERTIES = 5,
	SEQ_LZMA_PREPARE = 6,
	SEQ_LZMA_RUN = 7,
	SEQ_COPY = 8,
};

struct lzma2_dec {
	enum lzma2_seq sequence;
	enum lzma2_seq next_sequence;
	uint32_t uncompressed;
	uint32_t compressed;
	bool need_dict_reset;
	bool need_props;
};

struct xz_dec_lzma2___2 {
	struct rc_dec rc;
	struct dictionary dict;
	struct lzma2_dec lzma2;
	struct lzma_dec lzma;
	struct {
		uint32_t size;
		uint8_t buf[63];
	} temp;
};

struct xz_dec_bcj___2 {
	enum {
		BCJ_X86 = 4,
		BCJ_POWERPC = 5,
		BCJ_IA64 = 6,
		BCJ_ARM = 7,
		BCJ_ARMTHUMB = 8,
		BCJ_SPARC = 9,
	} type;
	enum xz_ret ret;
	bool single_call;
	uint32_t pos;
	uint32_t x86_prev_mask;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
	struct {
		size_t filtered;
		size_t size;
		uint8_t buf[16];
	} temp;
};

struct ts_state {
	unsigned int offset;
	char cb[48];
};

struct ts_config;

struct ts_ops {
	const char *name;
	struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
	unsigned int (*find)(struct ts_config *, struct ts_state *);
	void (*destroy)(struct ts_config *);
	void * (*get_pattern)(struct ts_config *);
	unsigned int (*get_pattern_len)(struct ts_config *);
	struct module *owner;
	struct list_head list;
};

struct ts_config {
	struct ts_ops *ops;
	int flags;
	unsigned int (*get_next_block)(unsigned int, const u8 **, struct ts_config *, struct ts_state *);
	void (*finish)(struct ts_config *, struct ts_state *);
};

struct ts_linear_state {
	unsigned int len;
	const void *data;
};

struct ei_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
	int etype;
	void *priv;
};

struct ddebug_table {
	struct list_head link;
	const char *mod_name;
	unsigned int num_ddebugs;
	struct _ddebug *ddebugs;
};

struct ddebug_query {
	const char *filename;
	const char *module;
	const char *function;
	const char *format;
	unsigned int first_lineno;
	unsigned int last_lineno;
};

struct ddebug_iter {
	struct ddebug_table *table;
	unsigned int idx;
};

struct flag_settings {
	unsigned int flags;
	unsigned int mask;
};

struct flagsbuf {
	char buf[7];
};

struct nla_bitfield32 {
	__u32 value;
	__u32 selector;
};

enum nla_policy_validation {
	NLA_VALIDATE_NONE = 0,
	NLA_VALIDATE_RANGE = 1,
	NLA_VALIDATE_RANGE_WARN_TOO_LONG = 2,
	NLA_VALIDATE_MIN = 3,
	NLA_VALIDATE_MAX = 4,
	NLA_VALIDATE_MASK = 5,
	NLA_VALIDATE_RANGE_PTR = 6,
	NLA_VALIDATE_FUNCTION = 7,
};

enum netlink_validation {
	NL_VALIDATE_LIBERAL = 0,
	NL_VALIDATE_TRAILING = 1,
	NL_VALIDATE_MAXTYPE = 2,
	NL_VALIDATE_UNSPEC = 4,
	NL_VALIDATE_STRICT_ATTRS = 8,
	NL_VALIDATE_NESTED = 16,
};

struct cpu_rmap {
	struct kref refcount;
	u16 size;
	u16 used;
	void **obj;
	struct {
		u16 index;
		u16 dist;
	} near[0];
};

struct irq_glue {
	struct irq_affinity_notify notify;
	struct cpu_rmap *rmap;
	u16 index;
};

typedef mpi_limb_t *mpi_ptr_t;

typedef int mpi_size_t;

typedef mpi_limb_t UWtype;

typedef unsigned int UHWtype;

enum gcry_mpi_constants {
	MPI_C_ZERO = 0,
	MPI_C_ONE = 1,
	MPI_C_TWO = 2,
	MPI_C_THREE = 3,
	MPI_C_FOUR = 4,
	MPI_C_EIGHT = 5,
};

struct barrett_ctx_s;

typedef struct barrett_ctx_s *mpi_barrett_t;

struct gcry_mpi_point {
	MPI x;
	MPI y;
	MPI z;
};

typedef struct gcry_mpi_point *MPI_POINT;

enum gcry_mpi_ec_models {
	MPI_EC_WEIERSTRASS = 0,
	MPI_EC_MONTGOMERY = 1,
	MPI_EC_EDWARDS = 2,
};

enum ecc_dialects {
	ECC_DIALECT_STANDARD = 0,
	ECC_DIALECT_ED25519 = 1,
	ECC_DIALECT_SAFECURVE = 2,
};

struct mpi_ec_ctx {
	enum gcry_mpi_ec_models model;
	enum ecc_dialects dialect;
	int flags;
	unsigned int nbits;
	MPI p;
	MPI a;
	MPI b;
	MPI_POINT G;
	MPI n;
	unsigned int h;
	MPI_POINT Q;
	MPI d;
	const char *name;
	struct {
		struct {
			unsigned int a_is_pminus3: 1;
			unsigned int two_inv_p: 1;
		} valid;
		int a_is_pminus3;
		MPI two_inv_p;
		mpi_barrett_t p_barrett;
		MPI scratch[11];
	} t;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
};

struct field_table {
	const char *p;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
};

enum gcry_mpi_format {
	GCRYMPI_FMT_NONE = 0,
	GCRYMPI_FMT_STD = 1,
	GCRYMPI_FMT_PGP = 2,
	GCRYMPI_FMT_SSH = 3,
	GCRYMPI_FMT_HEX = 4,
	GCRYMPI_FMT_USG = 5,
	GCRYMPI_FMT_OPAQUE = 8,
};

struct barrett_ctx_s___2;

typedef struct barrett_ctx_s___2 *mpi_barrett_t___2;

struct barrett_ctx_s___2 {
	MPI m;
	int m_copied;
	int k;
	MPI y;
	MPI r1;
	MPI r2;
	MPI r3;
};

struct karatsuba_ctx {
	struct karatsuba_ctx *next;
	mpi_ptr_t tspace;
	mpi_size_t tspace_size;
	mpi_ptr_t tp;
	mpi_size_t tp_size;
};

typedef long int mpi_limb_signed_t;

enum dim_tune_state {
	DIM_PARKING_ON_TOP = 0,
	DIM_PARKING_TIRED = 1,
	DIM_GOING_RIGHT = 2,
	DIM_GOING_LEFT = 3,
};

struct dim_cq_moder {
	u16 usec;
	u16 pkts;
	u16 comps;
	u8 cq_period_mode;
};

enum dim_cq_period_mode {
	DIM_CQ_PERIOD_MODE_START_FROM_EQE = 0,
	DIM_CQ_PERIOD_MODE_START_FROM_CQE = 1,
	DIM_CQ_PERIOD_NUM_MODES = 2,
};

enum dim_state {
	DIM_START_MEASURE = 0,
	DIM_MEASURE_IN_PROGRESS = 1,
	DIM_APPLY_NEW_PROFILE = 2,
};

enum dim_stats_state {
	DIM_STATS_WORSE = 0,
	DIM_STATS_SAME = 1,
	DIM_STATS_BETTER = 2,
};

enum dim_step_result {
	DIM_STEPPED = 0,
	DIM_TOO_TIRED = 1,
	DIM_ON_EDGE = 2,
};

enum pubkey_algo {
	PUBKEY_ALGO_RSA = 0,
	PUBKEY_ALGO_MAX = 1,
};

struct pubkey_hdr {
	uint8_t version;
	uint32_t timestamp;
	uint8_t algo;
	uint8_t nmpi;
	char mpi[0];
} __attribute__((packed));

struct signature_hdr {
	uint8_t version;
	uint32_t timestamp;
	uint8_t algo;
	uint8_t hash;
	uint8_t keyid[8];
	uint8_t nmpi;
	char mpi[0];
} __attribute__((packed));

struct sg_splitter {
	struct scatterlist *in_sg0;
	int nents;
	off_t skip_sg0;
	unsigned int length_last_sg;
	struct scatterlist *out_sg;
};

struct sg_pool {
	size_t size;
	char *name;
	struct kmem_cache *slab;
	mempool_t *pool;
};

enum {
	IRQ_POLL_F_SCHED = 0,
	IRQ_POLL_F_DISABLE = 1,
};

struct font_desc {
	int idx;
	const char *name;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	const void *data;
	int pref;
};

struct font_data {
	unsigned int extra[4];
	const unsigned char data[0];
};

typedef u16 ucs2_char_t;

struct firmware {
	size_t size;
	const u8 *data;
	void *priv;
};

struct pldmfw_record {
	struct list_head entry;
	struct list_head descs;
	const u8 *version_string;
	u8 version_type;
	u8 version_len;
	u16 package_data_len;
	u32 device_update_flags;
	const u8 *package_data;
	long unsigned int *component_bitmap;
	u16 component_bitmap_len;
};

struct pldmfw_desc_tlv {
	struct list_head entry;
	const u8 *data;
	u16 type;
	u16 size;
};

struct pldmfw_component {
	struct list_head entry;
	u16 classification;
	u16 identifier;
	u16 options;
	u16 activation_method;
	u32 comparison_stamp;
	u32 component_size;
	const u8 *component_data;
	const u8 *version_string;
	u8 version_type;
	u8 version_len;
	u8 index;
};

struct pldmfw_ops;

struct pldmfw {
	const struct pldmfw_ops *ops;
	struct device *dev;
};

struct pldmfw_ops {
	bool (*match_record)(struct pldmfw *, struct pldmfw_record *);
	int (*send_package_data)(struct pldmfw *, const u8 *, u16);
	int (*send_component_table)(struct pldmfw *, struct pldmfw_component *, u8);
	int (*flash_component)(struct pldmfw *, struct pldmfw_component *);
	int (*finalize_update)(struct pldmfw *);
};

struct __pldm_timestamp {
	u8 b[13];
};

struct __pldm_header {
	uuid_t id;
	u8 revision;
	__le16 size;
	struct __pldm_timestamp release_date;
	__le16 component_bitmap_len;
	u8 version_type;
	u8 version_len;
	u8 version_string[0];
} __attribute__((packed));

struct __pldmfw_record_info {
	__le16 record_len;
	u8 descriptor_count;
	__le32 device_update_flags;
	u8 version_type;
	u8 version_len;
	__le16 package_data_len;
	u8 variable_record_data[0];
} __attribute__((packed));

struct __pldmfw_desc_tlv {
	__le16 type;
	__le16 size;
	u8 data[0];
};

struct __pldmfw_record_area {
	u8 record_count;
	u8 records[0];
};

struct __pldmfw_component_info {
	__le16 classification;
	__le16 identifier;
	__le32 comparison_stamp;
	__le16 options;
	__le16 activation_method;
	__le32 location_offset;
	__le32 size;
	u8 version_type;
	u8 version_len;
	u8 version_string[0];
} __attribute__((packed));

struct __pldmfw_component_area {
	__le16 component_image_count;
	u8 components[0];
};

struct pldmfw_priv {
	struct pldmfw *context;
	const struct firmware *fw;
	size_t offset;
	struct list_head records;
	struct list_head components;
	const struct __pldm_header *header;
	u16 total_header_size;
	u16 component_bitmap_len;
	u16 bitmap_size;
	u16 component_count;
	const u8 *component_start;
	const u8 *record_start;
	u8 record_count;
	u32 header_crc;
	struct pldmfw_record *matching_record;
};

struct pldm_pci_record_id {
	int vendor;
	int device;
	int subsystem_vendor;
	int subsystem_device;
};

typedef long unsigned int cycles_t;

struct compress_format {
	unsigned char magic[2];
	const char *name;
	decompress_fn decompressor;
};

struct group_data {
	int limit[21];
	int base[20];
	int permute[258];
	int minLen;
	int maxLen;
};

struct bunzip_data {
	int writeCopies;
	int writePos;
	int writeRunCountdown;
	int writeCount;
	int writeCurrent;
	long int (*fill)(void *, long unsigned int);
	long int inbufCount;
	long int inbufPos;
	unsigned char *inbuf;
	unsigned int inbufBitCount;
	unsigned int inbufBits;
	unsigned int crc32Table[256];
	unsigned int headerCRC;
	unsigned int totalCRC;
	unsigned int writeCRC;
	unsigned int *dbuf;
	unsigned int dbufSize;
	unsigned char selectors[32768];
	struct group_data groups[6];
	int io_error;
	int byteCount[256];
	unsigned char symToByte[256];
	unsigned char mtfSymbol[256];
};

struct rc {
	long int (*fill)(void *, long unsigned int);
	uint8_t *ptr;
	uint8_t *buffer;
	uint8_t *buffer_end;
	long int buffer_size;
	uint32_t code;
	uint32_t range;
	uint32_t bound;
	void (*error)(char *);
};

struct lzma_header {
	uint8_t pos;
	uint32_t dict_size;
	uint64_t dst_size;
} __attribute__((packed));

struct writer {
	uint8_t *buffer;
	uint8_t previous_byte;
	size_t buffer_pos;
	int bufsize;
	size_t global_pos;
	long int (*flush)(void *, long unsigned int);
	struct lzma_header *header;
};

struct cstate {
	int state;
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
};

struct ZSTD_DCtx_s___2;

typedef struct ZSTD_DCtx_s___2 ZSTD_DCtx___2;

struct cpio_data {
	void *data;
	size_t size;
	char name[18];
};

enum cpio_fields {
	C_MAGIC = 0,
	C_INO = 1,
	C_MODE = 2,
	C_UID = 3,
	C_GID = 4,
	C_NLINK = 5,
	C_MTIME = 6,
	C_FILESIZE = 7,
	C_MAJ = 8,
	C_MIN = 9,
	C_RMAJ = 10,
	C_RMIN = 11,
	C_NAMESIZE = 12,
	C_CHKSUM = 13,
	C_NFIELDS = 14,
};

enum {
	ASSUME_PERFECT = 255,
	ASSUME_VALID_DTB = 1,
	ASSUME_VALID_INPUT = 2,
	ASSUME_LATEST = 4,
	ASSUME_NO_ROLLBACK = 8,
	ASSUME_LIBFDT_ORDER = 16,
	ASSUME_LIBFDT_FLAWLESS = 32,
};

struct fdt_reserve_entry {
	fdt64_t address;
	fdt64_t size;
};

struct fdt_node_header {
	fdt32_t tag;
	char name[0];
};

struct fdt_property {
	fdt32_t tag;
	fdt32_t len;
	fdt32_t nameoff;
	char data[0];
};

struct fdt_errtabent {
	const char *str;
};

struct fprop_local_single {
	long unsigned int events;
	unsigned int period;
	raw_spinlock_t lock;
};

struct ida_bitmap {
	long unsigned int bitmap[16];
};

struct klist_waiter {
	struct list_head list;
	struct klist_node *node;
	struct task_struct *process;
	int woken;
};

struct uevent_sock {
	struct list_head list;
	struct sock *sk;
};

enum {
	LOGIC_PIO_INDIRECT = 0,
	LOGIC_PIO_CPU_MMIO = 1,
};

struct logic_pio_host_ops;

struct logic_pio_hwaddr {
	struct list_head list;
	struct fwnode_handle *fwnode;
	resource_size_t hw_start;
	resource_size_t io_start;
	resource_size_t size;
	long unsigned int flags;
	void *hostdata;
	const struct logic_pio_host_ops *ops;
};

struct logic_pio_host_ops {
	u32 (*in)(void *, long unsigned int, size_t);
	void (*out)(void *, long unsigned int, u32, size_t);
	u32 (*ins)(void *, long unsigned int, void *, size_t, unsigned int);
	void (*outs)(void *, long unsigned int, const void *, size_t, unsigned int);
};

struct radix_tree_preload {
	unsigned int nr;
	struct xa_node *nodes;
};

typedef struct {
	long unsigned int key[2];
} hsiphash_key_t;

struct clk_hw;

struct clk_rate_request {
	long unsigned int rate;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int best_parent_rate;
	struct clk_hw *best_parent_hw;
};

struct clk_core;

struct clk_init_data;

struct clk_hw {
	struct clk_core *core;
	struct clk *clk;
	const struct clk_init_data *init;
};

struct clk_duty {
	unsigned int num;
	unsigned int den;
};

struct clk_ops {
	int (*prepare)(struct clk_hw *);
	void (*unprepare)(struct clk_hw *);
	int (*is_prepared)(struct clk_hw *);
	void (*unprepare_unused)(struct clk_hw *);
	int (*enable)(struct clk_hw *);
	void (*disable)(struct clk_hw *);
	int (*is_enabled)(struct clk_hw *);
	void (*disable_unused)(struct clk_hw *);
	int (*save_context)(struct clk_hw *);
	void (*restore_context)(struct clk_hw *);
	long unsigned int (*recalc_rate)(struct clk_hw *, long unsigned int);
	long int (*round_rate)(struct clk_hw *, long unsigned int, long unsigned int *);
	int (*determine_rate)(struct clk_hw *, struct clk_rate_request *);
	int (*set_parent)(struct clk_hw *, u8);
	u8 (*get_parent)(struct clk_hw *);
	int (*set_rate)(struct clk_hw *, long unsigned int, long unsigned int);
	int (*set_rate_and_parent)(struct clk_hw *, long unsigned int, long unsigned int, u8);
	long unsigned int (*recalc_accuracy)(struct clk_hw *, long unsigned int);
	int (*get_phase)(struct clk_hw *);
	int (*set_phase)(struct clk_hw *, int);
	int (*get_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*set_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*init)(struct clk_hw *);
	void (*terminate)(struct clk_hw *);
	void (*debug_init)(struct clk_hw *, struct dentry *);
};

struct clk_parent_data {
	const struct clk_hw *hw;
	const char *fw_name;
	const char *name;
	int index;
};

struct clk_init_data {
	const char *name;
	const struct clk_ops *ops;
	const char * const *parent_names;
	const struct clk_parent_data *parent_data;
	const struct clk_hw **parent_hws;
	u8 num_parents;
	long unsigned int flags;
};

enum format_type {
	FORMAT_TYPE_NONE = 0,
	FORMAT_TYPE_WIDTH = 1,
	FORMAT_TYPE_PRECISION = 2,
	FORMAT_TYPE_CHAR = 3,
	FORMAT_TYPE_STR = 4,
	FORMAT_TYPE_PTR = 5,
	FORMAT_TYPE_PERCENT_CHAR = 6,
	FORMAT_TYPE_INVALID = 7,
	FORMAT_TYPE_LONG_LONG = 8,
	FORMAT_TYPE_ULONG = 9,
	FORMAT_TYPE_LONG = 10,
	FORMAT_TYPE_UBYTE = 11,
	FORMAT_TYPE_BYTE = 12,
	FORMAT_TYPE_USHORT = 13,
	FORMAT_TYPE_SHORT = 14,
	FORMAT_TYPE_UINT = 15,
	FORMAT_TYPE_INT = 16,
	FORMAT_TYPE_SIZE_T = 17,
	FORMAT_TYPE_PTRDIFF = 18,
};

struct printf_spec {
	unsigned int type: 8;
	int field_width: 24;
	unsigned int flags: 8;
	unsigned int base: 8;
	int precision: 16;
};

struct page_flags_fields {
	int width;
	int shift;
	int mask;
	const struct printf_spec *spec;
	const char *name;
};

struct minmax_sample {
	u32 t;
	u32 v;
};

struct minmax {
	struct minmax_sample s[3];
};

typedef int (*acpi_tbl_table_handler)(struct acpi_table_header *);

typedef int (*acpi_tbl_entry_handler)(union acpi_subtable_headers *, const long unsigned int);

struct acpi_probe_entry;

typedef bool (*acpi_probe_entry_validate_subtbl)(struct acpi_subtable_header *, struct acpi_probe_entry *);

struct acpi_probe_entry {
	__u8 id[5];
	__u8 type;
	acpi_probe_entry_validate_subtbl subtable_valid;
	union {
		acpi_tbl_table_handler probe_table;
		acpi_tbl_entry_handler probe_subtbl;
	};
	kernel_ulong_t driver_data;
};

typedef int (*of_irq_init_cb_t)(struct device_node *, struct device_node *);

typedef int (*of_init_fn_2)(struct device_node *, struct device_node *);

enum al_fic_state {
	AL_FIC_UNCONFIGURED = 0,
	AL_FIC_CONFIGURED_LEVEL = 1,
	AL_FIC_CONFIGURED_RISING_EDGE = 2,
};

struct al_fic {
	void *base;
	struct irq_domain *domain;
	const char *name;
	unsigned int parent_irq;
	enum al_fic_state state;
};

struct armctrl_ic {
	void *base;
	void *pending[3];
	void *enable[3];
	void *disable[3];
	struct irq_domain *domain;
};

struct bcm2836_arm_irqchip_intc {
	struct irq_domain *domain;
	void *base;
};

struct owl_sirq_params {
	bool reg_shared;
	u16 reg_offset[3];
};

struct owl_sirq_chip_data {
	const struct owl_sirq_params *params;
	void *base;
	raw_spinlock_t lock;
	u32 ext_irqs[3];
};

struct sun4i_irq_chip_data {
	void *irq_base;
	struct irq_domain *irq_domain;
	u32 enable_reg_offset;
	u32 mask_reg_offset;
};

struct sun6i_r_intc_variant {
	u32 first_mux_irq;
	u32 nr_mux_irqs;
	u32 mux_valid[4];
};

enum {
	SUNXI_SRC_TYPE_LEVEL_LOW = 0,
	SUNXI_SRC_TYPE_EDGE_FALLING = 1,
	SUNXI_SRC_TYPE_LEVEL_HIGH = 2,
	SUNXI_SRC_TYPE_EDGE_RISING = 3,
};

struct sunxi_sc_nmi_reg_offs {
	u32 ctrl;
	u32 pend;
	u32 enable;
};

struct acpi_madt_generic_distributor {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 gic_id;
	u64 base_address;
	u32 global_irq_base;
	u8 version;
	u8 reserved2[3];
};

enum acpi_madt_gic_version {
	ACPI_MADT_GIC_VERSION_NONE = 0,
	ACPI_MADT_GIC_VERSION_V1 = 1,
	ACPI_MADT_GIC_VERSION_V2 = 2,
	ACPI_MADT_GIC_VERSION_V3 = 3,
	ACPI_MADT_GIC_VERSION_V4 = 4,
	ACPI_MADT_GIC_VERSION_RESERVED = 5,
};

struct gic_quirk {
	const char *desc;
	const char *compatible;
	bool (*init)(void *);
	u32 iidr;
	u32 mask;
};

union gic_base {
	void *common_base;
	void **percpu_base;
};

struct gic_chip_data {
	struct irq_chip chip;
	union gic_base dist_base;
	union gic_base cpu_base;
	void *raw_dist_base;
	void *raw_cpu_base;
	u32 percpu_offset;
	u32 saved_spi_enable[32];
	u32 saved_spi_active[32];
	u32 saved_spi_conf[64];
	u32 saved_spi_target[255];
	u32 *saved_ppi_enable;
	u32 *saved_ppi_active;
	u32 *saved_ppi_conf;
	struct irq_domain *domain;
	unsigned int gic_irqs;
};

struct acpi_table_madt {
	struct acpi_table_header header;
	u32 address;
	u32 flags;
};

struct acpi_madt_generic_msi_frame {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 msi_frame_id;
	u64 base_address;
	u32 flags;
	u16 spi_count;
	u16 spi_base;
};

struct v2m_data {
	struct list_head entry;
	struct fwnode_handle *fwnode;
	struct resource res;
	void *base;
	u32 spi_start;
	u32 nr_spis;
	u32 spi_offset;
	long unsigned int *bm;
	u32 flags;
};

struct acpi_madt_generic_redistributor {
	struct acpi_subtable_header header;
	u16 reserved;
	u64 base_address;
	u32 length;
} __attribute__((packed));

struct rdists {
	struct {
		raw_spinlock_t rd_lock;
		void *rd_base;
		struct page *pend_page;
		phys_addr_t phys_base;
		bool lpi_enabled;
		cpumask_t *vpe_table_mask;
		void *vpe_l1_base;
	} *rdist;
	phys_addr_t prop_table_pa;
	void *prop_table_va;
	u64 flags;
	u32 gicd_typer;
	u32 gicd_typer2;
	bool has_vlpis;
	bool has_rvpeid;
	bool has_direct_lpi;
	bool has_vpend_valid_dirty;
};

struct partition_affinity {
	cpumask_t mask;
	void *partition_id;
};

struct redist_region {
	void *redist_base;
	phys_addr_t phys_base;
	bool single_redist;
};

struct partition_desc;

struct gic_chip_data___2 {
	struct fwnode_handle *fwnode;
	void *dist_base;
	struct redist_region *redist_regions;
	struct rdists rdists;
	struct irq_domain *domain;
	u64 redist_stride;
	u32 nr_redist_regions;
	u64 flags;
	bool has_rss;
	unsigned int ppi_nr;
	struct partition_desc **ppi_descs;
};

enum gic_intid_range {
	SGI_RANGE = 0,
	PPI_RANGE = 1,
	SPI_RANGE = 2,
	EPPI_RANGE = 3,
	ESPI_RANGE = 4,
	LPI_RANGE = 5,
	__INVALID_RANGE__ = 6,
};

struct mbi_range {
	u32 spi_start;
	u32 nr_spis;
	long unsigned int *bm;
};

struct acpi_madt_generic_translator {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 translation_id;
	u64 base_address;
	u32 reserved2;
} __attribute__((packed));

struct acpi_srat_gic_its_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u16 reserved;
	u32 its_id;
} __attribute__((packed));

enum its_vcpu_info_cmd_type {
	MAP_VLPI = 0,
	GET_VLPI = 1,
	PROP_UPDATE_VLPI = 2,
	PROP_UPDATE_AND_INV_VLPI = 3,
	SCHEDULE_VPE = 4,
	DESCHEDULE_VPE = 5,
	COMMIT_VPE = 6,
	INVALL_VPE = 7,
	PROP_UPDATE_VSGI = 8,
};

struct its_cmd_info {
	enum its_vcpu_info_cmd_type cmd_type;
	union {
		struct its_vlpi_map *map;
		u8 config;
		bool req_db;
		struct {
			bool g0en;
			bool g1en;
		};
		struct {
			u8 priority;
			bool group;
		};
	};
};

struct its_collection___2 {
	u64 target_address;
	u16 col_id;
};

struct its_baser {
	void *base;
	u64 val;
	u32 order;
	u32 psz;
};

struct its_cmd_block;

struct its_device___2;

struct its_node {
	raw_spinlock_t lock;
	struct mutex dev_alloc_lock;
	struct list_head entry;
	void *base;
	void *sgir_base;
	phys_addr_t phys_base;
	struct its_cmd_block *cmd_base;
	struct its_cmd_block *cmd_write;
	struct its_baser tables[8];
	struct its_collection___2 *collections;
	struct fwnode_handle *fwnode_handle;
	u64 (*get_msi_base)(struct its_device___2 *);
	u64 typer;
	u64 cbaser_save;
	u32 ctlr_save;
	u32 mpidr;
	struct list_head its_device_list;
	u64 flags;
	long unsigned int list_nr;
	int numa_node;
	unsigned int msi_domain_flags;
	u32 pre_its_base;
	int vlpi_redist_offset;
};

struct its_cmd_block {
	union {
		u64 raw_cmd[4];
		__le64 raw_cmd_le[4];
	};
};

struct event_lpi_map {
	long unsigned int *lpi_map;
	u16 *col_map;
	irq_hw_number_t lpi_base;
	int nr_lpis;
	raw_spinlock_t vlpi_lock;
	struct its_vm *vm;
	struct its_vlpi_map *vlpi_maps;
	int nr_vlpis;
};

struct its_device___2 {
	struct list_head entry;
	struct its_node *its;
	struct event_lpi_map event_map;
	void *itt;
	u32 nr_ites;
	u32 device_id;
	bool shared;
};

struct cpu_lpi_count {
	atomic_t managed;
	atomic_t unmanaged;
};

struct its_cmd_desc {
	union {
		struct {
			struct its_device___2 *dev;
			u32 event_id;
		} its_inv_cmd;
		struct {
			struct its_device___2 *dev;
			u32 event_id;
		} its_clear_cmd;
		struct {
			struct its_device___2 *dev;
			u32 event_id;
		} its_int_cmd;
		struct {
			struct its_device___2 *dev;
			int valid;
		} its_mapd_cmd;
		struct {
			struct its_collection___2 *col;
			int valid;
		} its_mapc_cmd;
		struct {
			struct its_device___2 *dev;
			u32 phys_id;
			u32 event_id;
		} its_mapti_cmd;
		struct {
			struct its_device___2 *dev;
			struct its_collection___2 *col;
			u32 event_id;
		} its_movi_cmd;
		struct {
			struct its_device___2 *dev;
			u32 event_id;
		} its_discard_cmd;
		struct {
			struct its_collection___2 *col;
		} its_invall_cmd;
		struct {
			struct its_vpe *vpe;
		} its_vinvall_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_collection___2 *col;
			bool valid;
		} its_vmapp_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_device___2 *dev;
			u32 virt_id;
			u32 event_id;
			bool db_enabled;
		} its_vmapti_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_device___2 *dev;
			u32 event_id;
			bool db_enabled;
		} its_vmovi_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_collection___2 *col;
			u16 seq_num;
			u16 its_list;
		} its_vmovp_cmd;
		struct {
			struct its_vpe *vpe;
		} its_invdb_cmd;
		struct {
			struct its_vpe *vpe;
			u8 sgi;
			u8 priority;
			bool enable;
			bool group;
			bool clear;
		} its_vsgi_cmd;
	};
};

typedef struct its_collection___2 * (*its_cmd_builder_t)(struct its_node *, struct its_cmd_block *, struct its_cmd_desc *);

typedef struct its_vpe * (*its_cmd_vbuilder_t)(struct its_node *, struct its_cmd_block *, struct its_cmd_desc *);

struct lpi_range {
	struct list_head entry;
	u32 base_id;
	u32 span;
};

struct its_srat_map {
	u32 numa_node;
	u32 its_id;
};

enum device_link_state {
	DL_STATE_NONE = 4294967295,
	DL_STATE_DORMANT = 0,
	DL_STATE_AVAILABLE = 1,
	DL_STATE_CONSUMER_PROBE = 2,
	DL_STATE_ACTIVE = 3,
	DL_STATE_SUPPLIER_UNBIND = 4,
};

struct device_link {
	struct device *supplier;
	struct list_head s_node;
	struct device *consumer;
	struct list_head c_node;
	struct device link_dev;
	enum device_link_state status;
	u32 flags;
	refcount_t rpm_active;
	struct kref kref;
	struct work_struct rm_work;
	bool supplier_preactivated;
};

struct fsl_mc_obj_desc {
	char type[16];
	int id;
	u16 vendor;
	u16 ver_major;
	u16 ver_minor;
	u8 irq_count;
	u8 region_count;
	u32 state;
	char label[16];
	u16 flags;
};

struct fsl_mc_io;

struct fsl_mc_device_irq;

struct fsl_mc_resource;

struct fsl_mc_device {
	struct device dev;
	u64 dma_mask;
	u16 flags;
	u32 icid;
	u16 mc_handle;
	struct fsl_mc_io *mc_io;
	struct fsl_mc_obj_desc obj_desc;
	struct resource *regions;
	struct fsl_mc_device_irq **irqs;
	struct fsl_mc_resource *resource;
	struct device_link *consumer_link;
	char *driver_override;
};

enum fsl_mc_pool_type {
	FSL_MC_POOL_DPMCP = 0,
	FSL_MC_POOL_DPBP = 1,
	FSL_MC_POOL_DPCON = 2,
	FSL_MC_POOL_IRQ = 3,
	FSL_MC_NUM_POOL_TYPES = 4,
};

struct fsl_mc_resource_pool;

struct fsl_mc_resource {
	enum fsl_mc_pool_type type;
	s32 id;
	void *data;
	struct fsl_mc_resource_pool *parent_pool;
	struct list_head node;
};

struct fsl_mc_device_irq {
	struct msi_desc *msi_desc;
	struct fsl_mc_device *mc_dev;
	u8 dev_irq_index;
	struct fsl_mc_resource resource;
};

struct fsl_mc_io {
	struct device *dev;
	u16 flags;
	u32 portal_size;
	phys_addr_t portal_phys_addr;
	void *portal_virt_addr;
	struct fsl_mc_device *dpmcp_dev;
	union {
		struct mutex mutex;
		raw_spinlock_t spinlock;
	};
};

struct partition_desc___2 {
	int nr_parts;
	struct partition_affinity *parts;
	struct irq_domain *domain;
	struct irq_desc *chained_desc;
	long unsigned int *bitmap;
	struct irq_domain_ops ops;
};

struct mbigen_device {
	struct platform_device *pdev;
	void *base;
};

struct irqc_priv;

struct irqc_irq {
	int hw_irq;
	int requested_irq;
	struct irqc_priv *p;
};

struct irqc_priv {
	void *iomem;
	void *cpu_int_base;
	struct irqc_irq irq[32];
	unsigned int number_of_irqs;
	struct device *dev;
	struct irq_chip_generic *gc;
	struct irq_domain *irq_domain;
	atomic_t wakeup_path;
};

struct xintc_irq_chip {
	void *base;
	struct irq_domain *root_domain;
	u32 intr_mask;
	u32 nr_irq;
};

struct bcm7038_l1_cpu;

struct bcm7038_l1_chip {
	raw_spinlock_t lock;
	unsigned int n_words;
	struct irq_domain *domain;
	struct bcm7038_l1_cpu *cpus[256];
	struct list_head list;
	u32 wake_mask[8];
	u32 irq_fwd_mask[8];
	u8 affinity[256];
};

struct bcm7038_l1_cpu {
	void *map_base;
	u32 mask_cache[0];
};

struct brcmstb_intc_init_params {
	irq_flow_handler_t handler;
	int cpu_status;
	int cpu_clear;
	int cpu_mask_status;
	int cpu_mask_set;
	int cpu_mask_clear;
};

struct brcmstb_l2_intc_data {
	struct irq_domain *domain;
	struct irq_chip_generic *gc;
	int status_offset;
	int mask_offset;
	bool can_wake;
	u32 saved_mask;
};

struct mtk_sysirq_chip_data {
	raw_spinlock_t lock;
	u32 nr_intpol_bases;
	void **intpol_bases;
	u32 *intpol_words;
	u8 *intpol_idx;
	u16 *which_word;
};

struct mtk_cirq_chip_data {
	void *base;
	unsigned int ext_irq_start;
	unsigned int ext_irq_end;
	struct irq_domain *domain;
};

struct gpcv2_irqchip_data {
	struct raw_spinlock rlock;
	void *gpc_base;
	u32 wakeup_sources[4];
	u32 saved_irq_mask[4];
	u32 cpu2wakeup;
};

struct mvebu_gicp_spi_range {
	unsigned int start;
	unsigned int count;
};

struct mvebu_gicp {
	struct mvebu_gicp_spi_range *spi_ranges;
	unsigned int spi_ranges_cnt;
	unsigned int spi_cnt;
	long unsigned int *spi_bitmap;
	spinlock_t spi_lock;
	struct resource *res;
	struct device *dev;
};

struct mvebu_icu_subset_data {
	unsigned int icu_group;
	unsigned int offset_set_ah;
	unsigned int offset_set_al;
	unsigned int offset_clr_ah;
	unsigned int offset_clr_al;
};

struct mvebu_icu {
	void *base;
	struct device *dev;
};

struct mvebu_icu_msi_data {
	struct mvebu_icu *icu;
	atomic_t initialized;
	const struct mvebu_icu_subset_data *subset_data;
};

struct mvebu_icu_irq_data {
	struct mvebu_icu *icu;
	unsigned int icu_group;
	unsigned int type;
};

struct odmi_data {
	struct resource res;
	void *base;
	unsigned int spi_base;
};

struct mvebu_pic {
	void *base;
	u32 parent_irq;
	struct irq_domain *domain;
	struct irq_chip irq_chip;
};

struct mvebu_sei_interrupt_range {
	u32 first;
	u32 size;
};

struct mvebu_sei_caps {
	struct mvebu_sei_interrupt_range ap_range;
	struct mvebu_sei_interrupt_range cp_range;
};

struct mvebu_sei {
	struct device *dev;
	void *base;
	struct resource *res;
	struct irq_domain *sei_domain;
	struct irq_domain *ap_domain;
	struct irq_domain *cp_domain;
	const struct mvebu_sei_caps *caps;
	struct mutex cp_msi_lock;
	long unsigned int cp_msi_bitmap[1];
	raw_spinlock_t mask_lock;
};

struct regmap;

struct ls_extirq_data {
	struct regmap *syscon;
	u32 intpcr;
	bool is_ls1021a_or_ls1043a;
	u32 nirq;
	struct irq_fwspec map[12];
};

struct ls_scfg_msi_cfg {
	u32 ibs_shift;
	u32 msir_irqs;
	u32 msir_base;
};

struct ls_scfg_msi;

struct ls_scfg_msir {
	struct ls_scfg_msi *msi_data;
	unsigned int index;
	unsigned int gic_irq;
	unsigned int bit_start;
	unsigned int bit_end;
	unsigned int srs;
	void *reg;
};

struct ls_scfg_msi {
	spinlock_t lock;
	struct platform_device *pdev;
	struct irq_domain *parent;
	struct irq_domain *msi_domain;
	void *regs;
	phys_addr_t msiir_addr;
	struct ls_scfg_msi_cfg *cfg;
	u32 msir_num;
	struct ls_scfg_msir *msir;
	u32 irqs_num;
	long unsigned int *used;
};

struct acpi_resource_irq {
	u8 descriptor_length;
	u8 triggering;
	u8 polarity;
	u8 shareable;
	u8 wake_capable;
	u8 interrupt_count;
	u8 interrupts[1];
};

struct acpi_resource_dma {
	u8 type;
	u8 bus_master;
	u8 transfer;
	u8 channel_count;
	u8 channels[1];
};

struct acpi_resource_start_dependent {
	u8 descriptor_length;
	u8 compatibility_priority;
	u8 performance_robustness;
};

struct acpi_resource_io {
	u8 io_decode;
	u8 alignment;
	u8 address_length;
	u16 minimum;
	u16 maximum;
} __attribute__((packed));

struct acpi_resource_fixed_io {
	u16 address;
	u8 address_length;
} __attribute__((packed));

struct acpi_resource_fixed_dma {
	u16 request_lines;
	u16 channels;
	u8 width;
} __attribute__((packed));

struct acpi_resource_vendor {
	u16 byte_length;
	u8 byte_data[1];
} __attribute__((packed));

struct acpi_resource_vendor_typed {
	u16 byte_length;
	u8 uuid_subtype;
	u8 uuid[16];
	u8 byte_data[1];
};

struct acpi_resource_end_tag {
	u8 checksum;
};

struct acpi_resource_memory24 {
	u8 write_protect;
	u16 minimum;
	u16 maximum;
	u16 alignment;
	u16 address_length;
} __attribute__((packed));

struct acpi_resource_memory32 {
	u8 write_protect;
	u32 minimum;
	u32 maximum;
	u32 alignment;
	u32 address_length;
} __attribute__((packed));

struct acpi_resource_fixed_memory32 {
	u8 write_protect;
	u32 address;
	u32 address_length;
} __attribute__((packed));

struct acpi_memory_attribute {
	u8 write_protect;
	u8 caching;
	u8 range_type;
	u8 translation;
};

struct acpi_io_attribute {
	u8 range_type;
	u8 translation;
	u8 translation_type;
	u8 reserved1;
};

union acpi_resource_attribute {
	struct acpi_memory_attribute mem;
	struct acpi_io_attribute io;
	u8 type_specific;
};

struct acpi_resource_label {
	u16 string_length;
	char *string_ptr;
} __attribute__((packed));

struct acpi_resource_source {
	u8 index;
	u16 string_length;
	char *string_ptr;
} __attribute__((packed));

struct acpi_address16_attribute {
	u16 granularity;
	u16 minimum;
	u16 maximum;
	u16 translation_offset;
	u16 address_length;
};

struct acpi_address32_attribute {
	u32 granularity;
	u32 minimum;
	u32 maximum;
	u32 translation_offset;
	u32 address_length;
};

struct acpi_address64_attribute {
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
};

struct acpi_resource_address {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
};

struct acpi_resource_address16 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address16_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address32 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address32_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address64 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address64_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_extended_address64 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	u8 revision_ID;
	struct acpi_address64_attribute address;
	u64 type_specific;
} __attribute__((packed));

struct acpi_resource_extended_irq {
	u8 producer_consumer;
	u8 triggering;
	u8 polarity;
	u8 shareable;
	u8 wake_capable;
	u8 interrupt_count;
	struct acpi_resource_source resource_source;
	u32 interrupts[1];
} __attribute__((packed));

struct acpi_resource_generic_register {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct acpi_resource_gpio {
	u8 revision_id;
	u8 connection_type;
	u8 producer_consumer;
	u8 pin_config;
	u8 shareable;
	u8 wake_capable;
	u8 io_restriction;
	u8 triggering;
	u8 polarity;
	u16 drive_strength;
	u16 debounce_timeout;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_common_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_i2c_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 access_mode;
	u16 slave_address;
	u32 connection_speed;
} __attribute__((packed));

struct acpi_resource_spi_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 wire_mode;
	u8 device_polarity;
	u8 data_bit_length;
	u8 clock_phase;
	u8 clock_polarity;
	u16 device_selection;
	u32 connection_speed;
} __attribute__((packed));

struct acpi_resource_uart_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 endian;
	u8 data_bits;
	u8 stop_bits;
	u8 flow_control;
	u8 parity;
	u8 lines_enabled;
	u16 rx_fifo_size;
	u16 tx_fifo_size;
	u32 default_baud_rate;
} __attribute__((packed));

struct acpi_resource_csi2_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 local_port_instance;
	u8 phy_type;
} __attribute__((packed));

struct acpi_resource_pin_function {
	u8 revision_id;
	u8 pin_config;
	u8 shareable;
	u16 function_number;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_config {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group {
	u8 revision_id;
	u8 producer_consumer;
	u16 pin_table_length;
	u16 vendor_length;
	u16 *pin_table;
	struct acpi_resource_label resource_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group_function {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u16 function_number;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	struct acpi_resource_label resource_source_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group_config {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	struct acpi_resource_label resource_source_label;
	u8 *vendor_data;
} __attribute__((packed));

union acpi_resource_data {
	struct acpi_resource_irq irq;
	struct acpi_resource_dma dma;
	struct acpi_resource_start_dependent start_dpf;
	struct acpi_resource_io io;
	struct acpi_resource_fixed_io fixed_io;
	struct acpi_resource_fixed_dma fixed_dma;
	struct acpi_resource_vendor vendor;
	struct acpi_resource_vendor_typed vendor_typed;
	struct acpi_resource_end_tag end_tag;
	struct acpi_resource_memory24 memory24;
	struct acpi_resource_memory32 memory32;
	struct acpi_resource_fixed_memory32 fixed_memory32;
	struct acpi_resource_address16 address16;
	struct acpi_resource_address32 address32;
	struct acpi_resource_address64 address64;
	struct acpi_resource_extended_address64 ext_address64;
	struct acpi_resource_extended_irq extended_irq;
	struct acpi_resource_generic_register generic_reg;
	struct acpi_resource_gpio gpio;
	struct acpi_resource_i2c_serialbus i2c_serial_bus;
	struct acpi_resource_spi_serialbus spi_serial_bus;
	struct acpi_resource_uart_serialbus uart_serial_bus;
	struct acpi_resource_csi2_serialbus csi2_serial_bus;
	struct acpi_resource_common_serialbus common_serial_bus;
	struct acpi_resource_pin_function pin_function;
	struct acpi_resource_pin_config pin_config;
	struct acpi_resource_pin_group pin_group;
	struct acpi_resource_pin_group_function pin_group_function;
	struct acpi_resource_pin_group_config pin_group_config;
	struct acpi_resource_address address;
};

struct acpi_resource {
	u32 type;
	u32 length;
	union acpi_resource_data data;
} __attribute__((packed));

struct combiner_reg {
	void *addr;
	long unsigned int enabled;
};

struct combiner {
	struct irq_domain *domain;
	int parent_irq;
	u32 nirqs;
	u32 nregs;
	struct combiner_reg regs[0];
};

struct get_registers_context {
	struct device *dev;
	struct combiner *combiner;
	int err;
};

struct exiu_irq_data {
	void *base;
	u32 spi_base;
};

struct meson_gpio_irq_controller;

struct irq_ctl_ops {
	void (*gpio_irq_sel_pin)(struct meson_gpio_irq_controller *, unsigned int, long unsigned int);
	void (*gpio_irq_init)(struct meson_gpio_irq_controller *);
};

struct meson_gpio_irq_params;

struct meson_gpio_irq_controller {
	const struct meson_gpio_irq_params *params;
	void *base;
	u32 channel_irqs[8];
	long unsigned int channel_map[1];
	spinlock_t lock;
};

struct meson_gpio_irq_params {
	unsigned int nr_hwirq;
	bool support_edge_both;
	unsigned int edge_both_offset;
	unsigned int edge_single_offset;
	unsigned int pol_low_offset;
	unsigned int pin_sel_mask;
	struct irq_ctl_ops ops;
};

struct pdc_pin_region {
	u32 pin_base;
	u32 parent_base;
	u32 cnt;
};

enum pdc_irq_config_bits {
	PDC_LEVEL_LOW = 0,
	PDC_EDGE_FALLING = 2,
	PDC_LEVEL_HIGH = 4,
	PDC_EDGE_RISING = 6,
	PDC_EDGE_DUAL = 7,
};

struct irqsteer_data {
	void *regs;
	struct clk *ipg_clk;
	int irq[8];
	int irq_count;
	raw_spinlock_t lock;
	int reg_num;
	int channel;
	struct irq_domain *domain;
	u32 *saved_reg;
};

struct intmux_irqchip_data {
	struct irq_chip chip;
	u32 saved_reg;
	int chanidx;
	int irq;
	struct irq_domain *domain;
};

struct intmux_data {
	raw_spinlock_t lock;
	void *regs;
	struct clk *ipg_clk;
	int channum;
	struct intmux_irqchip_data irqchip_data[0];
};

struct ti_sci_version_info {
	u8 abi_major;
	u8 abi_minor;
	u16 firmware_revision;
	char firmware_description[32];
};

struct ti_sci_handle;

struct ti_sci_core_ops {
	int (*reboot_device)(const struct ti_sci_handle *);
};

struct ti_sci_dev_ops {
	int (*get_device)(const struct ti_sci_handle *, u32);
	int (*get_device_exclusive)(const struct ti_sci_handle *, u32);
	int (*idle_device)(const struct ti_sci_handle *, u32);
	int (*idle_device_exclusive)(const struct ti_sci_handle *, u32);
	int (*put_device)(const struct ti_sci_handle *, u32);
	int (*is_valid)(const struct ti_sci_handle *, u32);
	int (*get_context_loss_count)(const struct ti_sci_handle *, u32, u32 *);
	int (*is_idle)(const struct ti_sci_handle *, u32, bool *);
	int (*is_stop)(const struct ti_sci_handle *, u32, bool *, bool *);
	int (*is_on)(const struct ti_sci_handle *, u32, bool *, bool *);
	int (*is_transitioning)(const struct ti_sci_handle *, u32, bool *);
	int (*set_device_resets)(const struct ti_sci_handle *, u32, u32);
	int (*get_device_resets)(const struct ti_sci_handle *, u32, u32 *);
};

struct ti_sci_clk_ops {
	int (*get_clock)(const struct ti_sci_handle *, u32, u32, bool, bool, bool);
	int (*idle_clock)(const struct ti_sci_handle *, u32, u32);
	int (*put_clock)(const struct ti_sci_handle *, u32, u32);
	int (*is_auto)(const struct ti_sci_handle *, u32, u32, bool *);
	int (*is_on)(const struct ti_sci_handle *, u32, u32, bool *, bool *);
	int (*is_off)(const struct ti_sci_handle *, u32, u32, bool *, bool *);
	int (*set_parent)(const struct ti_sci_handle *, u32, u32, u32);
	int (*get_parent)(const struct ti_sci_handle *, u32, u32, u32 *);
	int (*get_num_parents)(const struct ti_sci_handle *, u32, u32, u32 *);
	int (*get_best_match_freq)(const struct ti_sci_handle *, u32, u32, u64, u64, u64, u64 *);
	int (*set_freq)(const struct ti_sci_handle *, u32, u32, u64, u64, u64);
	int (*get_freq)(const struct ti_sci_handle *, u32, u32, u64 *);
};

struct ti_sci_resource_desc;

struct ti_sci_rm_core_ops {
	int (*get_range)(const struct ti_sci_handle *, u32, u8, struct ti_sci_resource_desc *);
	int (*get_range_from_shost)(const struct ti_sci_handle *, u32, u8, u8, struct ti_sci_resource_desc *);
};

struct ti_sci_rm_irq_ops {
	int (*set_irq)(const struct ti_sci_handle *, u16, u16, u16, u16);
	int (*set_event_map)(const struct ti_sci_handle *, u16, u16, u16, u16, u16, u8);
	int (*free_irq)(const struct ti_sci_handle *, u16, u16, u16, u16);
	int (*free_event_map)(const struct ti_sci_handle *, u16, u16, u16, u16, u16, u8);
};

struct ti_sci_msg_rm_ring_cfg;

struct ti_sci_rm_ringacc_ops {
	int (*set_cfg)(const struct ti_sci_handle *, const struct ti_sci_msg_rm_ring_cfg *);
};

struct ti_sci_rm_psil_ops {
	int (*pair)(const struct ti_sci_handle *, u32, u32, u32);
	int (*unpair)(const struct ti_sci_handle *, u32, u32, u32);
};

struct ti_sci_msg_rm_udmap_tx_ch_cfg;

struct ti_sci_msg_rm_udmap_rx_ch_cfg;

struct ti_sci_msg_rm_udmap_flow_cfg;

struct ti_sci_rm_udmap_ops {
	int (*tx_ch_cfg)(const struct ti_sci_handle *, const struct ti_sci_msg_rm_udmap_tx_ch_cfg *);
	int (*rx_ch_cfg)(const struct ti_sci_handle *, const struct ti_sci_msg_rm_udmap_rx_ch_cfg *);
	int (*rx_flow_cfg)(const struct ti_sci_handle *, const struct ti_sci_msg_rm_udmap_flow_cfg *);
};

struct ti_sci_proc_ops {
	int (*request)(const struct ti_sci_handle *, u8);
	int (*release)(const struct ti_sci_handle *, u8);
	int (*handover)(const struct ti_sci_handle *, u8, u8);
	int (*set_config)(const struct ti_sci_handle *, u8, u64, u32, u32);
	int (*set_control)(const struct ti_sci_handle *, u8, u32, u32);
	int (*get_status)(const struct ti_sci_handle *, u8, u64 *, u32 *, u32 *, u32 *);
};

struct ti_sci_ops {
	struct ti_sci_core_ops core_ops;
	struct ti_sci_dev_ops dev_ops;
	struct ti_sci_clk_ops clk_ops;
	struct ti_sci_rm_core_ops rm_core_ops;
	struct ti_sci_rm_irq_ops rm_irq_ops;
	struct ti_sci_rm_ringacc_ops rm_ring_ops;
	struct ti_sci_rm_psil_ops rm_psil_ops;
	struct ti_sci_rm_udmap_ops rm_udmap_ops;
	struct ti_sci_proc_ops proc_ops;
};

struct ti_sci_handle {
	struct ti_sci_version_info version;
	struct ti_sci_ops ops;
};

struct ti_sci_resource_desc {
	u16 start;
	u16 num;
	u16 start_sec;
	u16 num_sec;
	long unsigned int *res_map;
};

struct ti_sci_msg_rm_ring_cfg {
	u32 valid_params;
	u16 nav_id;
	u16 index;
	u32 addr_lo;
	u32 addr_hi;
	u32 count;
	u8 mode;
	u8 size;
	u8 order_id;
	u16 virtid;
	u8 asel;
};

struct ti_sci_msg_rm_udmap_tx_ch_cfg {
	u32 valid_params;
	u16 nav_id;
	u16 index;
	u8 tx_pause_on_err;
	u8 tx_filt_einfo;
	u8 tx_filt_pswords;
	u8 tx_atype;
	u8 tx_chan_type;
	u8 tx_supr_tdpkt;
	u16 tx_fetch_size;
	u8 tx_credit_count;
	u16 txcq_qnum;
	u8 tx_priority;
	u8 tx_qos;
	u8 tx_orderid;
	u16 fdepth;
	u8 tx_sched_priority;
	u8 tx_burst_size;
	u8 tx_tdtype;
	u8 extended_ch_type;
};

struct ti_sci_msg_rm_udmap_rx_ch_cfg {
	u32 valid_params;
	u16 nav_id;
	u16 index;
	u16 rx_fetch_size;
	u16 rxcq_qnum;
	u8 rx_priority;
	u8 rx_qos;
	u8 rx_orderid;
	u8 rx_sched_priority;
	u16 flowid_start;
	u16 flowid_cnt;
	u8 rx_pause_on_err;
	u8 rx_atype;
	u8 rx_chan_type;
	u8 rx_ignore_short;
	u8 rx_ignore_long;
	u8 rx_burst_size;
};

struct ti_sci_msg_rm_udmap_flow_cfg {
	u32 valid_params;
	u16 nav_id;
	u16 flow_index;
	u8 rx_einfo_present;
	u8 rx_psinfo_present;
	u8 rx_error_handling;
	u8 rx_desc_type;
	u16 rx_sop_offset;
	u16 rx_dest_qnum;
	u8 rx_src_tag_hi;
	u8 rx_src_tag_lo;
	u8 rx_dest_tag_hi;
	u8 rx_dest_tag_lo;
	u8 rx_src_tag_hi_sel;
	u8 rx_src_tag_lo_sel;
	u8 rx_dest_tag_hi_sel;
	u8 rx_dest_tag_lo_sel;
	u16 rx_fdq0_sz0_qnum;
	u16 rx_fdq1_qnum;
	u16 rx_fdq2_qnum;
	u16 rx_fdq3_qnum;
	u8 rx_ps_location;
};

struct ti_sci_resource {
	u16 sets;
	raw_spinlock_t lock;
	struct ti_sci_resource_desc *desc;
};

struct ti_sci_intr_irq_domain {
	const struct ti_sci_handle *sci;
	struct ti_sci_resource *out_irqs;
	struct device *dev;
	u32 ti_sci_id;
	u32 type;
};

struct of_phandle_iterator {
	const char *cells_name;
	int cell_count;
	const struct device_node *parent;
	const __be32 *list_end;
	const __be32 *phandle_end;
	const __be32 *cur;
	uint32_t cur_count;
	phandle phandle;
	struct device_node *node;
};

struct ti_sci_inta_event_desc {
	u16 global_event;
	u32 hwirq;
	u8 vint_bit;
};

struct ti_sci_inta_vint_desc {
	struct irq_domain *domain;
	struct list_head list;
	long unsigned int event_map[1];
	struct ti_sci_inta_event_desc events[64];
	unsigned int parent_virq;
	u16 vint_id;
};

struct ti_sci_inta_irq_domain {
	const struct ti_sci_handle *sci;
	struct ti_sci_resource *vint;
	struct ti_sci_resource *global_event;
	struct list_head vint_list;
	struct mutex vint_mutex;
	void *base;
	struct platform_device *pdev;
	u32 ti_sci_id;
	int unmapped_cnt;
	u16 *unmapped_dev_ids;
};

struct mst_intc_chip_data {
	raw_spinlock_t lock;
	unsigned int irq_start;
	unsigned int nr_irqs;
	void *base;
	bool no_eoi;
	struct list_head entry;
	u16 saved_polarity_conf[4];
};

struct of_dev_auxdata {
	char *compatible;
	resource_size_t phys_addr;
	char *name;
	void *platform_data;
};

struct plat_serial8250_port {
	long unsigned int iobase;
	void *membase;
	resource_size_t mapbase;
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	void *private_data;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char hub6;
	unsigned char has_sysrq;
	upf_t flags;
	unsigned int type;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
};

struct lpc_cycle_para {
	unsigned int opflags;
	unsigned int csize;
};

struct hisi_lpc_dev {
	spinlock_t cycle_lock;
	void *membase;
	struct logic_pio_hwaddr *io_host;
};

struct hisi_lpc_acpi_cell {
	const char *hid;
	const char *name;
	void *pdata;
	size_t pdata_size;
};

enum {
	ARB_TIMER = 0,
	ARB_BP_CAP_CLR = 1,
	ARB_BP_CAP_HI_ADDR = 2,
	ARB_BP_CAP_ADDR = 3,
	ARB_BP_CAP_STATUS = 4,
	ARB_BP_CAP_MASTER = 5,
	ARB_ERR_CAP_CLR = 6,
	ARB_ERR_CAP_HI_ADDR = 7,
	ARB_ERR_CAP_ADDR = 8,
	ARB_ERR_CAP_STATUS = 9,
	ARB_ERR_CAP_MASTER = 10,
};

struct brcmstb_gisb_arb_device {
	void *base;
	const int *gisb_offsets;
	bool big_endian;
	struct mutex lock;
	struct list_head next;
	u32 valid_mask;
	const char *master_names[32];
	u32 saved_timeout;
};

struct bus_attribute {
	struct attribute attr;
	ssize_t (*show)(struct bus_type *, char *);
	ssize_t (*store)(struct bus_type *, const char *, size_t);
};

struct fsl_mc_device_id {
	__u16 vendor;
	const char obj_type[16];
};

enum dev_dma_attr {
	DEV_DMA_NOT_SUPPORTED = 0,
	DEV_DMA_NON_COHERENT = 1,
	DEV_DMA_COHERENT = 2,
};

struct fsl_mc_command {
	__le64 header;
	__le64 params[7];
};

struct fsl_mc_driver {
	struct device_driver driver;
	const struct fsl_mc_device_id *match_id_table;
	int (*probe)(struct fsl_mc_device *);
	int (*remove)(struct fsl_mc_device *);
	void (*shutdown)(struct fsl_mc_device *);
	int (*suspend)(struct fsl_mc_device *, pm_message_t);
	int (*resume)(struct fsl_mc_device *);
};

struct fsl_mc_bus;

struct fsl_mc_resource_pool {
	enum fsl_mc_pool_type type;
	int max_count;
	int free_count;
	struct mutex mutex;
	struct list_head free_list;
	struct fsl_mc_bus *mc_bus;
};

struct mc_cmd_header {
	u8 src_id;
	u8 flags_hw;
	u8 status;
	u8 flags_sw;
	__le16 token;
	__le16 cmd_id;
};

enum mc_cmd_status {
	MC_CMD_STATUS_OK = 0,
	MC_CMD_STATUS_READY = 1,
	MC_CMD_STATUS_AUTH_ERR = 3,
	MC_CMD_STATUS_NO_PRIVILEGE = 4,
	MC_CMD_STATUS_DMA_ERR = 5,
	MC_CMD_STATUS_CONFIG_ERR = 6,
	MC_CMD_STATUS_TIMEOUT = 7,
	MC_CMD_STATUS_NO_RESOURCE = 8,
	MC_CMD_STATUS_NO_MEMORY = 9,
	MC_CMD_STATUS_BUSY = 10,
	MC_CMD_STATUS_UNSUPPORTED_OP = 11,
	MC_CMD_STATUS_INVALID_STATE = 12,
};

struct fsl_mc_version {
	u32 major;
	u32 minor;
	u32 revision;
};

struct dpmng_rsp_get_version {
	__le32 revision;
	__le32 version_major;
	__le32 version_minor;
};

struct dprc_attributes {
	int container_id;
	u32 icid;
	int portal_id;
	u64 options;
};

enum dprc_region_type {
	DPRC_REGION_TYPE_MC_PORTAL = 0,
	DPRC_REGION_TYPE_QBMAN_PORTAL = 1,
	DPRC_REGION_TYPE_QBMAN_MEM_BACKED_PORTAL = 2,
};

struct dprc_region_desc {
	u32 base_offset;
	u32 size;
	u32 flags;
	enum dprc_region_type type;
	u64 base_address;
};

struct dprc_endpoint {
	char type[16];
	int id;
	u16 if_id;
};

struct fsl_mc_uapi {
	struct miscdevice misc;
	struct device *device;
	struct mutex mutex;
	u32 local_instance_in_use;
	struct fsl_mc_io *static_mc_io;
};

struct fsl_mc_bus {
	struct fsl_mc_device mc_dev;
	struct fsl_mc_resource_pool resource_pools[4];
	struct fsl_mc_device_irq *irq_resources;
	struct mutex scan_mutex;
	struct dprc_attributes dprc_attr;
	struct fsl_mc_uapi uapi_misc;
	int irq_enabled;
};

struct fsl_mc_addr_translation_range;

struct fsl_mc {
	struct fsl_mc_device *root_mc_bus_dev;
	u8 num_translation_ranges;
	struct fsl_mc_addr_translation_range *translation_ranges;
	void *fsl_mc_regs;
};

struct fsl_mc_addr_translation_range {
	enum dprc_region_type mc_region_type;
	u64 start_mc_offset;
	u64 end_mc_offset;
	phys_addr_t start_phys_addr;
};

struct dpbp_attr {
	int id;
	u16 bpid;
};

struct dpbp_cmd_open {
	__le32 dpbp_id;
};

struct dpbp_rsp_get_attributes {
	__le16 pad;
	__le16 bpid;
	__le32 id;
	__le16 version_major;
	__le16 version_minor;
};

struct dpcon_attr {
	int id;
	u16 qbman_ch_id;
	u8 num_priorities;
};

struct dpcon_notification_cfg {
	int dpio_id;
	u8 priority;
	u64 user_ctx;
};

struct dpcon_cmd_open {
	__le32 dpcon_id;
};

struct dpcon_rsp_get_attr {
	__le32 id;
	__le16 qbman_ch_id;
	u8 num_priorities;
	u8 pad;
};

struct dpcon_cmd_set_notification {
	__le32 dpio_id;
	u8 priority;
	u8 pad[3];
	__le64 user_ctx;
};

struct mc_rsp_create {
	__le32 object_id;
};

struct mc_rsp_api_ver {
	__le16 major_ver;
	__le16 minor_ver;
};

struct dprc_cmd_open {
	__le32 container_id;
};

struct dprc_cmd_reset_container {
	__le32 child_container_id;
	__le32 options;
};

struct dprc_cmd_set_irq {
	__le32 irq_val;
	u8 irq_index;
	u8 pad[3];
	__le64 irq_addr;
	__le32 irq_num;
};

struct dprc_cmd_set_irq_enable {
	u8 enable;
	u8 pad[3];
	u8 irq_index;
};

struct dprc_cmd_set_irq_mask {
	__le32 mask;
	u8 irq_index;
};

struct dprc_cmd_get_irq_status {
	__le32 status;
	u8 irq_index;
};

struct dprc_rsp_get_irq_status {
	__le32 status;
};

struct dprc_cmd_clear_irq_status {
	__le32 status;
	u8 irq_index;
};

struct dprc_rsp_get_attributes {
	__le32 container_id;
	__le32 icid;
	__le32 options;
	__le32 portal_id;
};

struct dprc_rsp_get_obj_count {
	__le32 pad;
	__le32 obj_count;
};

struct dprc_cmd_get_obj {
	__le32 obj_index;
};

struct dprc_rsp_get_obj {
	__le32 pad0;
	__le32 id;
	__le16 vendor;
	u8 irq_count;
	u8 region_count;
	__le32 state;
	__le16 version_major;
	__le16 version_minor;
	__le16 flags;
	__le16 pad1;
	u8 type[16];
	u8 label[16];
};

struct dprc_cmd_get_obj_region {
	__le32 obj_id;
	__le16 pad0;
	u8 region_index;
	u8 pad1;
	__le64 pad2[2];
	u8 obj_type[16];
};

struct dprc_rsp_get_obj_region {
	__le64 pad0;
	__le64 base_offset;
	__le32 size;
	u8 type;
	u8 pad2[3];
	__le32 flags;
	__le32 pad3;
	__le64 base_addr;
};

struct dprc_cmd_set_obj_irq {
	__le32 irq_val;
	u8 irq_index;
	u8 pad[3];
	__le64 irq_addr;
	__le32 irq_num;
	__le32 obj_id;
	u8 obj_type[16];
};

struct dprc_cmd_get_connection {
	__le32 ep1_id;
	__le16 ep1_interface_id;
	u8 pad[2];
	u8 ep1_type[16];
};

struct dprc_rsp_get_connection {
	__le64 pad[3];
	__le32 ep2_id;
	__le16 ep2_interface_id;
	__le16 pad1;
	u8 ep2_type[16];
	__le32 state;
};

struct dprc_irq_cfg {
	phys_addr_t paddr;
	u32 val;
	int irq_num;
};

struct fsl_mc_child_objs {
	int child_count;
	struct fsl_mc_obj_desc *child_array;
};

struct dpmcp_cmd_open {
	__le32 dpmcp_id;
};

struct uapi_priv_data {
	struct fsl_mc_uapi *uapi;
	struct fsl_mc_io *mc_io;
};

struct fsl_mc_cmd_desc {
	u16 cmdid_value;
	u16 cmdid_mask;
	int size;
	bool token;
	int flags;
};

enum fsl_mc_cmd_index {
	DPDBG_DUMP = 0,
	DPDBG_SET = 1,
	DPRC_GET_CONTAINER_ID = 2,
	DPRC_CREATE_CONT = 3,
	DPRC_DESTROY_CONT = 4,
	DPRC_ASSIGN = 5,
	DPRC_UNASSIGN = 6,
	DPRC_GET_OBJ_COUNT = 7,
	DPRC_GET_OBJ = 8,
	DPRC_GET_RES_COUNT = 9,
	DPRC_GET_RES_IDS = 10,
	DPRC_SET_OBJ_LABEL = 11,
	DPRC_SET_LOCKED = 12,
	DPRC_CONNECT = 13,
	DPRC_DISCONNECT = 14,
	DPRC_GET_POOL = 15,
	DPRC_GET_POOL_COUNT = 16,
	DPRC_GET_CONNECTION = 17,
	DPCI_GET_LINK_STATE = 18,
	DPCI_GET_PEER_ATTR = 19,
	DPAIOP_GET_SL_VERSION = 20,
	DPAIOP_GET_STATE = 21,
	DPMNG_GET_VERSION = 22,
	DPSECI_GET_TX_QUEUE = 23,
	DPMAC_GET_COUNTER = 24,
	DPMAC_GET_MAC_ADDR = 25,
	DPNI_SET_PRIM_MAC = 26,
	DPNI_GET_PRIM_MAC = 27,
	DPNI_GET_STATISTICS = 28,
	DPNI_GET_LINK_STATE = 29,
	DPNI_GET_MAX_FRAME_LENGTH = 30,
	DPSW_GET_TAILDROP = 31,
	DPSW_SET_TAILDROP = 32,
	DPSW_IF_GET_COUNTER = 33,
	DPSW_IF_GET_MAX_FRAME_LENGTH = 34,
	DPDMUX_GET_COUNTER = 35,
	DPDMUX_IF_GET_MAX_FRAME_LENGTH = 36,
	GET_ATTR = 37,
	GET_IRQ_MASK = 38,
	GET_IRQ_STATUS = 39,
	CLOSE = 40,
	OPEN = 41,
	GET_API_VERSION = 42,
	DESTROY = 43,
	CREATE = 44,
};

struct imx_weim_devtype {
	unsigned int cs_count;
	unsigned int cs_regs_count;
	unsigned int cs_stride;
	unsigned int wcr_offset;
	unsigned int wcr_bcm;
};

struct cs_timing {
	bool is_applied;
	u32 regs[6];
};

struct cs_timing_state {
	struct cs_timing cs[6];
};

struct cs_data {
	u32 enable_mask;
	u16 slow_cfg;
	u16 fast_cfg;
};

struct ebi2_xmem_prop {
	const char *prop;
	u32 max;
	bool slowreg;
	u16 shift;
};

enum regcache_type {
	REGCACHE_NONE = 0,
	REGCACHE_RBTREE = 1,
	REGCACHE_COMPRESSED = 2,
	REGCACHE_FLAT = 3,
};

struct reg_default {
	unsigned int reg;
	unsigned int def;
};

enum regmap_endian {
	REGMAP_ENDIAN_DEFAULT = 0,
	REGMAP_ENDIAN_BIG = 1,
	REGMAP_ENDIAN_LITTLE = 2,
	REGMAP_ENDIAN_NATIVE = 3,
};

struct regmap_range {
	unsigned int range_min;
	unsigned int range_max;
};

struct regmap_access_table {
	const struct regmap_range *yes_ranges;
	unsigned int n_yes_ranges;
	const struct regmap_range *no_ranges;
	unsigned int n_no_ranges;
};

typedef void (*regmap_lock)(void *);

typedef void (*regmap_unlock)(void *);

struct regmap_range_cfg;

struct regmap_config {
	const char *name;
	int reg_bits;
	int reg_stride;
	int pad_bits;
	int val_bits;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	bool disable_locking;
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	bool fast_io;
	unsigned int max_register;
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	const struct reg_default *reg_defaults;
	unsigned int num_reg_defaults;
	enum regcache_type cache_type;
	const void *reg_defaults_raw;
	unsigned int num_reg_defaults_raw;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	bool zero_flag_mask;
	bool use_single_read;
	bool use_single_write;
	bool use_relaxed_mmio;
	bool can_multi_write;
	enum regmap_endian reg_format_endian;
	enum regmap_endian val_format_endian;
	const struct regmap_range_cfg *ranges;
	unsigned int num_ranges;
	bool use_hwlock;
	unsigned int hwlock_id;
	unsigned int hwlock_mode;
	bool can_sleep;
};

struct regmap_range_cfg {
	const char *name;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct vexpress_syscfg {
	struct device *dev;
	void *base;
	struct list_head funcs;
};

struct vexpress_syscfg_func {
	struct list_head list;
	struct vexpress_syscfg *syscfg;
	struct regmap *regmap;
	int num_templates;
	u32 template[0];
};

struct vexpress_config_bridge_ops {
	struct regmap * (*regmap_init)(struct device *, void *);
	void (*regmap_exit)(struct regmap *, void *);
};

struct vexpress_config_bridge {
	struct vexpress_config_bridge_ops *ops;
	void *context;
};

struct phy_configure_opts_dp {
	unsigned int link_rate;
	unsigned int lanes;
	unsigned int voltage[4];
	unsigned int pre[4];
	u8 ssc: 1;
	u8 set_rate: 1;
	u8 set_lanes: 1;
	u8 set_voltages: 1;
};

struct phy_configure_opts_mipi_dphy {
	unsigned int clk_miss;
	unsigned int clk_post;
	unsigned int clk_pre;
	unsigned int clk_prepare;
	unsigned int clk_settle;
	unsigned int clk_term_en;
	unsigned int clk_trail;
	unsigned int clk_zero;
	unsigned int d_term_en;
	unsigned int eot;
	unsigned int hs_exit;
	unsigned int hs_prepare;
	unsigned int hs_settle;
	unsigned int hs_skip;
	unsigned int hs_trail;
	unsigned int hs_zero;
	unsigned int init;
	unsigned int lpx;
	unsigned int ta_get;
	unsigned int ta_go;
	unsigned int ta_sure;
	unsigned int wakeup;
	long unsigned int hs_clk_rate;
	long unsigned int lp_clk_rate;
	unsigned char lanes;
};

enum phy_mode {
	PHY_MODE_INVALID = 0,
	PHY_MODE_USB_HOST = 1,
	PHY_MODE_USB_HOST_LS = 2,
	PHY_MODE_USB_HOST_FS = 3,
	PHY_MODE_USB_HOST_HS = 4,
	PHY_MODE_USB_HOST_SS = 5,
	PHY_MODE_USB_DEVICE = 6,
	PHY_MODE_USB_DEVICE_LS = 7,
	PHY_MODE_USB_DEVICE_FS = 8,
	PHY_MODE_USB_DEVICE_HS = 9,
	PHY_MODE_USB_DEVICE_SS = 10,
	PHY_MODE_USB_OTG = 11,
	PHY_MODE_UFS_HS_A = 12,
	PHY_MODE_UFS_HS_B = 13,
	PHY_MODE_PCIE = 14,
	PHY_MODE_ETHERNET = 15,
	PHY_MODE_MIPI_DPHY = 16,
	PHY_MODE_SATA = 17,
	PHY_MODE_LVDS = 18,
	PHY_MODE_DP = 19,
};

enum phy_media {
	PHY_MEDIA_DEFAULT = 0,
	PHY_MEDIA_SR = 1,
	PHY_MEDIA_DAC = 2,
};

union phy_configure_opts {
	struct phy_configure_opts_mipi_dphy mipi_dphy;
	struct phy_configure_opts_dp dp;
};

struct phy;

struct phy_ops {
	int (*init)(struct phy *);
	int (*exit)(struct phy *);
	int (*power_on)(struct phy *);
	int (*power_off)(struct phy *);
	int (*set_mode)(struct phy *, enum phy_mode, int);
	int (*set_media)(struct phy *, enum phy_media);
	int (*set_speed)(struct phy *, int);
	int (*configure)(struct phy *, union phy_configure_opts *);
	int (*validate)(struct phy *, enum phy_mode, int, union phy_configure_opts *);
	int (*reset)(struct phy *);
	int (*calibrate)(struct phy *);
	void (*release)(struct phy *);
	struct module *owner;
};

struct phy_attrs {
	u32 bus_width;
	u32 max_link_rate;
	enum phy_mode mode;
};

struct regulator;

struct phy {
	struct device dev;
	int id;
	const struct phy_ops *ops;
	struct mutex mutex;
	int init_count;
	int power_count;
	struct phy_attrs attrs;
	struct regulator *pwr;
};

struct phy_provider {
	struct device *dev;
	struct device_node *children;
	struct module *owner;
	struct list_head list;
	struct phy * (*of_xlate)(struct device *, struct of_phandle_args *);
};

struct phy_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct phy *phy;
};

enum cmu_type_t {
	REF_CMU = 0,
	PHY_CMU = 1,
};

enum clk_type_t {
	CLK_EXT_DIFF = 0,
	CLK_INT_DIFF = 1,
	CLK_INT_SING = 2,
};

enum xgene_phy_mode {
	MODE_SATA = 0,
	MODE_SGMII = 1,
	MODE_PCIE = 2,
	MODE_USB = 3,
	MODE_XFI = 4,
	MODE_MAX = 5,
};

struct xgene_sata_override_param {
	u32 speed[2];
	u32 txspeed[3];
	u32 txboostgain[6];
	u32 txeyetuning[6];
	u32 txeyedirection[6];
	u32 txamplitude[6];
	u32 txprecursor_cn1[6];
	u32 txprecursor_cn2[6];
	u32 txpostcursor_cp1[6];
};

struct xgene_phy_ctx {
	struct device *dev;
	struct phy *phy;
	enum xgene_phy_mode mode;
	enum clk_type_t clk_type;
	void *sds_base;
	struct clk *clk;
	struct xgene_sata_override_param sata_param;
};

struct reset_control;

struct phy_axg_pcie_priv {
	struct phy *phy;
	struct phy *analog;
	struct regmap *regmap;
	struct reset_control *reset;
};

struct phy_axg_mipi_pcie_analog_priv {
	struct phy *phy;
	struct regmap *regmap;
	bool dsi_configured;
	bool dsi_enabled;
	bool powered;
	struct phy_configure_opts_mipi_dphy config;
};

struct mii_bus;

struct mdio_device {
	struct device dev;
	struct mii_bus *bus;
	char modalias[32];
	int (*bus_match)(struct device *, struct device_driver *);
	void (*device_free)(struct mdio_device *);
	void (*device_remove)(struct mdio_device *);
	int addr;
	int flags;
	struct gpio_desc *reset_gpio;
	struct reset_control *reset_ctrl;
	unsigned int reset_assert_delay;
	unsigned int reset_deassert_delay;
};

struct phy_c45_device_ids {
	u32 devices_in_package;
	u32 mmds_present;
	u32 device_ids[32];
};

enum phy_state {
	PHY_DOWN = 0,
	PHY_READY = 1,
	PHY_HALTED = 2,
	PHY_UP = 3,
	PHY_RUNNING = 4,
	PHY_NOLINK = 5,
	PHY_CABLETEST = 6,
};

typedef enum {
	PHY_INTERFACE_MODE_NA = 0,
	PHY_INTERFACE_MODE_INTERNAL = 1,
	PHY_INTERFACE_MODE_MII = 2,
	PHY_INTERFACE_MODE_GMII = 3,
	PHY_INTERFACE_MODE_SGMII = 4,
	PHY_INTERFACE_MODE_TBI = 5,
	PHY_INTERFACE_MODE_REVMII = 6,
	PHY_INTERFACE_MODE_RMII = 7,
	PHY_INTERFACE_MODE_RGMII = 8,
	PHY_INTERFACE_MODE_RGMII_ID = 9,
	PHY_INTERFACE_MODE_RGMII_RXID = 10,
	PHY_INTERFACE_MODE_RGMII_TXID = 11,
	PHY_INTERFACE_MODE_RTBI = 12,
	PHY_INTERFACE_MODE_SMII = 13,
	PHY_INTERFACE_MODE_XGMII = 14,
	PHY_INTERFACE_MODE_XLGMII = 15,
	PHY_INTERFACE_MODE_MOCA = 16,
	PHY_INTERFACE_MODE_QSGMII = 17,
	PHY_INTERFACE_MODE_TRGMII = 18,
	PHY_INTERFACE_MODE_100BASEX = 19,
	PHY_INTERFACE_MODE_1000BASEX = 20,
	PHY_INTERFACE_MODE_2500BASEX = 21,
	PHY_INTERFACE_MODE_5GBASER = 22,
	PHY_INTERFACE_MODE_RXAUI = 23,
	PHY_INTERFACE_MODE_XAUI = 24,
	PHY_INTERFACE_MODE_10GBASER = 25,
	PHY_INTERFACE_MODE_USXGMII = 26,
	PHY_INTERFACE_MODE_10GKR = 27,
	PHY_INTERFACE_MODE_MAX = 28,
} phy_interface_t;

struct phylink;

struct phy_driver;

struct phy_led_trigger;

struct phy_package_shared;

struct mii_timestamper;

struct phy_device {
	struct mdio_device mdio;
	struct phy_driver *drv;
	u32 phy_id;
	struct phy_c45_device_ids c45_ids;
	unsigned int is_c45: 1;
	unsigned int is_internal: 1;
	unsigned int is_pseudo_fixed_link: 1;
	unsigned int is_gigabit_capable: 1;
	unsigned int has_fixups: 1;
	unsigned int suspended: 1;
	unsigned int suspended_by_mdio_bus: 1;
	unsigned int sysfs_links: 1;
	unsigned int loopback_enabled: 1;
	unsigned int downshifted_rate: 1;
	unsigned int is_on_sfp_module: 1;
	unsigned int mac_managed_pm: 1;
	unsigned int autoneg: 1;
	unsigned int link: 1;
	unsigned int autoneg_complete: 1;
	unsigned int interrupts: 1;
	enum phy_state state;
	u32 dev_flags;
	phy_interface_t interface;
	int speed;
	int duplex;
	int port;
	int pause;
	int asym_pause;
	u8 master_slave_get;
	u8 master_slave_set;
	u8 master_slave_state;
	long unsigned int supported[2];
	long unsigned int advertising[2];
	long unsigned int lp_advertising[2];
	long unsigned int adv_old[2];
	u32 eee_broken_modes;
	struct phy_led_trigger *phy_led_triggers;
	unsigned int phy_num_led_triggers;
	struct phy_led_trigger *last_triggered;
	struct phy_led_trigger *led_link_trigger;
	int irq;
	void *priv;
	struct phy_package_shared *shared;
	struct sk_buff *skb;
	void *ehdr;
	struct nlattr *nest;
	struct delayed_work state_queue;
	struct mutex lock;
	bool sfp_bus_attached;
	struct sfp_bus *sfp_bus;
	struct phylink *phylink;
	struct net_device *attached_dev;
	struct mii_timestamper *mii_ts;
	u8 mdix;
	u8 mdix_ctrl;
	void (*phy_link_change)(struct phy_device *, bool);
	void (*adjust_link)(struct net_device *);
	const struct macsec_ops *macsec_ops;
};

struct phy_tdr_config {
	u32 first;
	u32 last;
	u32 step;
	s8 pair;
};

struct mdio_bus_stats {
	u64_stats_t transfers;
	u64_stats_t errors;
	u64_stats_t writes;
	u64_stats_t reads;
	struct u64_stats_sync syncp;
};

struct mii_bus {
	struct module *owner;
	const char *name;
	char id[61];
	void *priv;
	int (*read)(struct mii_bus *, int, int);
	int (*write)(struct mii_bus *, int, int, u16);
	int (*reset)(struct mii_bus *);
	struct mdio_bus_stats stats[32];
	struct mutex mdio_lock;
	struct device *parent;
	enum {
		MDIOBUS_ALLOCATED = 1,
		MDIOBUS_REGISTERED = 2,
		MDIOBUS_UNREGISTERED = 3,
		MDIOBUS_RELEASED = 4,
	} state;
	struct device dev;
	struct mdio_device *mdio_map[32];
	u32 phy_mask;
	u32 phy_ignore_ta_mask;
	int irq[32];
	int reset_delay_us;
	int reset_post_delay_us;
	struct gpio_desc *reset_gpiod;
	enum {
		MDIOBUS_NO_CAP = 0,
		MDIOBUS_C22 = 1,
		MDIOBUS_C45 = 2,
		MDIOBUS_C22_C45 = 3,
	} probe_capabilities;
	struct mutex shared_lock;
	struct phy_package_shared *shared[32];
};

struct mdio_driver_common {
	struct device_driver driver;
	int flags;
};

struct mdio_driver {
	struct mdio_driver_common mdiodrv;
	int (*probe)(struct mdio_device *);
	void (*remove)(struct mdio_device *);
	void (*shutdown)(struct mdio_device *);
};

struct mii_timestamper {
	bool (*rxtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	void (*txtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	int (*hwtstamp)(struct mii_timestamper *, struct ifreq *);
	void (*link_state)(struct mii_timestamper *, struct phy_device *);
	int (*ts_info)(struct mii_timestamper *, struct ethtool_ts_info *);
	struct device *device;
};

struct phy_package_shared {
	int addr;
	refcount_t refcnt;
	long unsigned int flags;
	size_t priv_size;
	void *priv;
};

struct phy_driver {
	struct mdio_driver_common mdiodrv;
	u32 phy_id;
	char *name;
	u32 phy_id_mask;
	const long unsigned int * const features;
	u32 flags;
	const void *driver_data;
	int (*soft_reset)(struct phy_device *);
	int (*config_init)(struct phy_device *);
	int (*probe)(struct phy_device *);
	int (*get_features)(struct phy_device *);
	int (*suspend)(struct phy_device *);
	int (*resume)(struct phy_device *);
	int (*config_aneg)(struct phy_device *);
	int (*aneg_done)(struct phy_device *);
	int (*read_status)(struct phy_device *);
	int (*config_intr)(struct phy_device *);
	irqreturn_t (*handle_interrupt)(struct phy_device *);
	void (*remove)(struct phy_device *);
	int (*match_phy_device)(struct phy_device *);
	int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*link_change_notify)(struct phy_device *);
	int (*read_mmd)(struct phy_device *, int, u16);
	int (*write_mmd)(struct phy_device *, int, u16, u16);
	int (*read_page)(struct phy_device *);
	int (*write_page)(struct phy_device *, int);
	int (*module_info)(struct phy_device *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *);
	int (*cable_test_start)(struct phy_device *);
	int (*cable_test_tdr_start)(struct phy_device *, const struct phy_tdr_config *);
	int (*cable_test_get_status)(struct phy_device *, bool *);
	int (*get_sset_count)(struct phy_device *);
	void (*get_strings)(struct phy_device *, u8 *);
	void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *);
	int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, const void *);
	int (*set_loopback)(struct phy_device *, bool);
	int (*get_sqi)(struct phy_device *);
	int (*get_sqi_max)(struct phy_device *);
};

enum brcm_sata_phy_version {
	BRCM_SATA_PHY_STB_16NM = 0,
	BRCM_SATA_PHY_STB_28NM = 1,
	BRCM_SATA_PHY_STB_40NM = 2,
	BRCM_SATA_PHY_IPROC_NS2 = 3,
	BRCM_SATA_PHY_IPROC_NSP = 4,
	BRCM_SATA_PHY_IPROC_SR = 5,
	BRCM_SATA_PHY_DSL_28NM = 6,
};

enum brcm_sata_phy_rxaeq_mode {
	RXAEQ_MODE_OFF = 0,
	RXAEQ_MODE_AUTO = 1,
	RXAEQ_MODE_MANUAL = 2,
};

struct brcm_sata_phy;

struct brcm_sata_port {
	int portnum;
	struct phy *phy;
	struct brcm_sata_phy *phy_priv;
	bool ssc_en;
	enum brcm_sata_phy_rxaeq_mode rxaeq_mode;
	u32 rxaeq_val;
	u32 tx_amplitude_val;
};

struct brcm_sata_phy {
	struct device *dev;
	void *phy_base;
	void *ctrl_base;
	enum brcm_sata_phy_version version;
	struct brcm_sata_port phys[2];
};

enum sata_phy_regs {
	BLOCK0_REG_BANK = 0,
	BLOCK0_XGXSSTATUS = 129,
	BLOCK0_XGXSSTATUS_PLL_LOCK = 4096,
	BLOCK0_SPARE = 141,
	BLOCK0_SPARE_OOB_CLK_SEL_MASK = 3,
	BLOCK0_SPARE_OOB_CLK_SEL_REFBY2 = 1,
	BLOCK1_REG_BANK = 16,
	BLOCK1_TEST_TX = 131,
	BLOCK1_TEST_TX_AMP_SHIFT = 12,
	PLL_REG_BANK_0 = 80,
	PLL_REG_BANK_0_PLLCONTROL_0 = 129,
	PLLCONTROL_0_FREQ_DET_RESTART = 8192,
	PLLCONTROL_0_FREQ_MONITOR = 4096,
	PLLCONTROL_0_SEQ_START = 32768,
	PLL_CAP_CHARGE_TIME = 131,
	PLL_VCO_CAL_THRESH = 132,
	PLL_CAP_CONTROL = 133,
	PLL_FREQ_DET_TIME = 134,
	PLL_ACTRL2 = 139,
	PLL_ACTRL2_SELDIV_MASK = 31,
	PLL_ACTRL2_SELDIV_SHIFT = 9,
	PLL_ACTRL6 = 134,
	PLL1_REG_BANK = 96,
	PLL1_ACTRL2 = 130,
	PLL1_ACTRL3 = 131,
	PLL1_ACTRL4 = 132,
	PLL1_ACTRL5 = 133,
	PLL1_ACTRL6 = 134,
	PLL1_ACTRL7 = 135,
	PLL1_ACTRL8 = 136,
	TX_REG_BANK = 112,
	TX_ACTRL0 = 128,
	TX_ACTRL0_TXPOL_FLIP = 64,
	TX_ACTRL5 = 133,
	TX_ACTRL5_SSC_EN = 2048,
	AEQRX_REG_BANK_0 = 208,
	AEQ_CONTROL1 = 129,
	AEQ_CONTROL1_ENABLE = 4,
	AEQ_CONTROL1_FREEZE = 8,
	AEQ_FRC_EQ = 131,
	AEQ_FRC_EQ_FORCE = 1,
	AEQ_FRC_EQ_FORCE_VAL = 2,
	AEQ_RFZ_FRC_VAL = 256,
	AEQRX_REG_BANK_1 = 224,
	AEQRX_SLCAL0_CTRL0 = 130,
	AEQRX_SLCAL1_CTRL0 = 134,
	OOB_REG_BANK = 336,
	OOB1_REG_BANK = 352,
	OOB_CTRL1 = 128,
	OOB_CTRL1_BURST_MAX_MASK = 15,
	OOB_CTRL1_BURST_MAX_SHIFT = 12,
	OOB_CTRL1_BURST_MIN_MASK = 15,
	OOB_CTRL1_BURST_MIN_SHIFT = 8,
	OOB_CTRL1_WAKE_IDLE_MAX_MASK = 15,
	OOB_CTRL1_WAKE_IDLE_MAX_SHIFT = 4,
	OOB_CTRL1_WAKE_IDLE_MIN_MASK = 15,
	OOB_CTRL1_WAKE_IDLE_MIN_SHIFT = 0,
	OOB_CTRL2 = 129,
	OOB_CTRL2_SEL_ENA_SHIFT = 15,
	OOB_CTRL2_SEL_ENA_RC_SHIFT = 14,
	OOB_CTRL2_RESET_IDLE_MAX_MASK = 63,
	OOB_CTRL2_RESET_IDLE_MAX_SHIFT = 8,
	OOB_CTRL2_BURST_CNT_MASK = 3,
	OOB_CTRL2_BURST_CNT_SHIFT = 6,
	OOB_CTRL2_RESET_IDLE_MIN_MASK = 63,
	OOB_CTRL2_RESET_IDLE_MIN_SHIFT = 0,
	TXPMD_REG_BANK = 416,
	TXPMD_CONTROL1 = 129,
	TXPMD_CONTROL1_TX_SSC_EN_FRC = 1,
	TXPMD_CONTROL1_TX_SSC_EN_FRC_VAL = 2,
	TXPMD_TX_FREQ_CTRL_CONTROL1 = 130,
	TXPMD_TX_FREQ_CTRL_CONTROL2 = 131,
	TXPMD_TX_FREQ_CTRL_CONTROL2_FMIN_MASK = 1023,
	TXPMD_TX_FREQ_CTRL_CONTROL3 = 132,
	TXPMD_TX_FREQ_CTRL_CONTROL3_FMAX_MASK = 1023,
	RXPMD_REG_BANK = 448,
	RXPMD_RX_CDR_CONTROL1 = 129,
	RXPMD_RX_PPM_VAL_MASK = 511,
	RXPMD_RXPMD_EN_FRC = 4096,
	RXPMD_RXPMD_EN_FRC_VAL = 8192,
	RXPMD_RX_CDR_CDR_PROP_BW = 130,
	RXPMD_G_CDR_PROP_BW_MASK = 7,
	RXPMD_G1_CDR_PROP_BW_SHIFT = 0,
	RXPMD_G2_CDR_PROP_BW_SHIFT = 3,
	RXPMD_G3_CDR_PROB_BW_SHIFT = 6,
	RXPMD_RX_CDR_CDR_ACQ_INTEG_BW = 131,
	RXPMD_G_CDR_ACQ_INT_BW_MASK = 7,
	RXPMD_G1_CDR_ACQ_INT_BW_SHIFT = 0,
	RXPMD_G2_CDR_ACQ_INT_BW_SHIFT = 3,
	RXPMD_G3_CDR_ACQ_INT_BW_SHIFT = 6,
	RXPMD_RX_CDR_CDR_LOCK_INTEG_BW = 132,
	RXPMD_G_CDR_LOCK_INT_BW_MASK = 7,
	RXPMD_G1_CDR_LOCK_INT_BW_SHIFT = 0,
	RXPMD_G2_CDR_LOCK_INT_BW_SHIFT = 3,
	RXPMD_G3_CDR_LOCK_INT_BW_SHIFT = 6,
	RXPMD_RX_FREQ_MON_CONTROL1 = 135,
	RXPMD_MON_CORRECT_EN = 256,
	RXPMD_MON_MARGIN_VAL_MASK = 255,
};

enum sata_phy_ctrl_regs {
	PHY_CTRL_1 = 0,
	PHY_CTRL_1_RESET = 1,
};

struct pinctrl;

struct pinctrl_state;

struct dev_pin_info {
	struct pinctrl *p;
	struct pinctrl_state *default_state;
	struct pinctrl_state *init_state;
	struct pinctrl_state *sleep_state;
	struct pinctrl_state *idle_state;
};

struct pinctrl {
	struct list_head node;
	struct device *dev;
	struct list_head states;
	struct pinctrl_state *state;
	struct list_head dt_maps;
	struct kref users;
};

struct pinctrl_state {
	struct list_head node;
	const char *name;
	struct list_head settings;
};

struct pinctrl_pin_desc {
	unsigned int number;
	const char *name;
	void *drv_data;
};

struct gpio_chip;

struct pinctrl_gpio_range {
	struct list_head node;
	const char *name;
	unsigned int id;
	unsigned int base;
	unsigned int pin_base;
	unsigned int npins;
	const unsigned int *pins;
	struct gpio_chip *gc;
};

struct gpio_irq_chip {
	struct irq_chip *chip;
	struct irq_domain *domain;
	const struct irq_domain_ops *domain_ops;
	struct fwnode_handle *fwnode;
	struct irq_domain *parent_domain;
	int (*child_to_parent_hwirq)(struct gpio_chip *, unsigned int, unsigned int, unsigned int *, unsigned int *);
	void * (*populate_parent_alloc_arg)(struct gpio_chip *, unsigned int, unsigned int);
	unsigned int (*child_offset_to_irq)(struct gpio_chip *, unsigned int);
	struct irq_domain_ops child_irq_domain_ops;
	irq_flow_handler_t handler;
	unsigned int default_type;
	struct lock_class_key *lock_key;
	struct lock_class_key *request_key;
	irq_flow_handler_t parent_handler;
	void *parent_handler_data;
	unsigned int num_parents;
	unsigned int *parents;
	unsigned int *map;
	bool threaded;
	int (*init_hw)(struct gpio_chip *);
	void (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
	long unsigned int *valid_mask;
	unsigned int first;
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
};

struct gpio_device;

struct gpio_chip {
	const char *label;
	struct gpio_device *gpiodev;
	struct device *parent;
	struct module *owner;
	int (*request)(struct gpio_chip *, unsigned int);
	void (*free)(struct gpio_chip *, unsigned int);
	int (*get_direction)(struct gpio_chip *, unsigned int);
	int (*direction_input)(struct gpio_chip *, unsigned int);
	int (*direction_output)(struct gpio_chip *, unsigned int, int);
	int (*get)(struct gpio_chip *, unsigned int);
	int (*get_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
	void (*set)(struct gpio_chip *, unsigned int, int);
	void (*set_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
	int (*set_config)(struct gpio_chip *, unsigned int, long unsigned int);
	int (*to_irq)(struct gpio_chip *, unsigned int);
	void (*dbg_show)(struct seq_file *, struct gpio_chip *);
	int (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
	int (*add_pin_ranges)(struct gpio_chip *);
	int base;
	u16 ngpio;
	const char * const *names;
	bool can_sleep;
	long unsigned int (*read_reg)(void *);
	void (*write_reg)(void *, long unsigned int);
	bool be_bits;
	void *reg_dat;
	void *reg_set;
	void *reg_clr;
	void *reg_dir_out;
	void *reg_dir_in;
	bool bgpio_dir_unreadable;
	int bgpio_bits;
	spinlock_t bgpio_lock;
	long unsigned int bgpio_data;
	long unsigned int bgpio_dir;
	struct gpio_irq_chip irq;
	long unsigned int *valid_mask;
	struct device_node *of_node;
	unsigned int of_gpio_n_cells;
	int (*of_xlate)(struct gpio_chip *, const struct of_phandle_args *, u32 *);
};

struct pinctrl_dev;

struct pinctrl_map;

struct pinctrl_ops {
	int (*get_groups_count)(struct pinctrl_dev *);
	const char * (*get_group_name)(struct pinctrl_dev *, unsigned int);
	int (*get_group_pins)(struct pinctrl_dev *, unsigned int, const unsigned int **, unsigned int *);
	void (*pin_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	int (*dt_node_to_map)(struct pinctrl_dev *, struct device_node *, struct pinctrl_map **, unsigned int *);
	void (*dt_free_map)(struct pinctrl_dev *, struct pinctrl_map *, unsigned int);
};

struct pinctrl_desc;

struct pinctrl_dev {
	struct list_head node;
	struct pinctrl_desc *desc;
	struct xarray pin_desc_tree;
	struct xarray pin_group_tree;
	unsigned int num_groups;
	struct xarray pin_function_tree;
	unsigned int num_functions;
	struct list_head gpio_ranges;
	struct device *dev;
	struct module *owner;
	void *driver_data;
	struct pinctrl *p;
	struct pinctrl_state *hog_default;
	struct pinctrl_state *hog_sleep;
	struct mutex mutex;
	struct dentry *device_root;
};

enum pinctrl_map_type {
	PIN_MAP_TYPE_INVALID = 0,
	PIN_MAP_TYPE_DUMMY_STATE = 1,
	PIN_MAP_TYPE_MUX_GROUP = 2,
	PIN_MAP_TYPE_CONFIGS_PIN = 3,
	PIN_MAP_TYPE_CONFIGS_GROUP = 4,
};

struct pinctrl_map_mux {
	const char *group;
	const char *function;
};

struct pinctrl_map_configs {
	const char *group_or_pin;
	long unsigned int *configs;
	unsigned int num_configs;
};

struct pinctrl_map {
	const char *dev_name;
	const char *name;
	enum pinctrl_map_type type;
	const char *ctrl_dev_name;
	union {
		struct pinctrl_map_mux mux;
		struct pinctrl_map_configs configs;
	} data;
};

struct pinmux_ops;

struct pinconf_ops;

struct pinconf_generic_params;

struct pin_config_item;

struct pinctrl_desc {
	const char *name;
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct pinctrl_ops *pctlops;
	const struct pinmux_ops *pmxops;
	const struct pinconf_ops *confops;
	struct module *owner;
	unsigned int num_custom_params;
	const struct pinconf_generic_params *custom_params;
	const struct pin_config_item *custom_conf_items;
	bool link_consumers;
};

struct pinmux_ops {
	int (*request)(struct pinctrl_dev *, unsigned int);
	int (*free)(struct pinctrl_dev *, unsigned int);
	int (*get_functions_count)(struct pinctrl_dev *);
	const char * (*get_function_name)(struct pinctrl_dev *, unsigned int);
	int (*get_function_groups)(struct pinctrl_dev *, unsigned int, const char * const **, unsigned int *);
	int (*set_mux)(struct pinctrl_dev *, unsigned int, unsigned int);
	int (*gpio_request_enable)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int);
	void (*gpio_disable_free)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int);
	int (*gpio_set_direction)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int, bool);
	bool strict;
};

struct pinconf_ops {
	bool is_generic;
	int (*pin_config_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*pin_config_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	int (*pin_config_group_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*pin_config_group_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	void (*pin_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	void (*pin_config_group_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	void (*pin_config_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, long unsigned int);
};

enum pin_config_param {
	PIN_CONFIG_BIAS_BUS_HOLD = 0,
	PIN_CONFIG_BIAS_DISABLE = 1,
	PIN_CONFIG_BIAS_HIGH_IMPEDANCE = 2,
	PIN_CONFIG_BIAS_PULL_DOWN = 3,
	PIN_CONFIG_BIAS_PULL_PIN_DEFAULT = 4,
	PIN_CONFIG_BIAS_PULL_UP = 5,
	PIN_CONFIG_DRIVE_OPEN_DRAIN = 6,
	PIN_CONFIG_DRIVE_OPEN_SOURCE = 7,
	PIN_CONFIG_DRIVE_PUSH_PULL = 8,
	PIN_CONFIG_DRIVE_STRENGTH = 9,
	PIN_CONFIG_DRIVE_STRENGTH_UA = 10,
	PIN_CONFIG_INPUT_DEBOUNCE = 11,
	PIN_CONFIG_INPUT_ENABLE = 12,
	PIN_CONFIG_INPUT_SCHMITT = 13,
	PIN_CONFIG_INPUT_SCHMITT_ENABLE = 14,
	PIN_CONFIG_MODE_LOW_POWER = 15,
	PIN_CONFIG_MODE_PWM = 16,
	PIN_CONFIG_OUTPUT_ENABLE = 17,
	PIN_CONFIG_OUTPUT = 18,
	PIN_CONFIG_PERSIST_STATE = 19,
	PIN_CONFIG_POWER_SOURCE = 20,
	PIN_CONFIG_SLEEP_HARDWARE_STATE = 21,
	PIN_CONFIG_SLEW_RATE = 22,
	PIN_CONFIG_SKEW_DELAY = 23,
	PIN_CONFIG_END = 127,
	PIN_CONFIG_MAX = 255,
};

struct pinconf_generic_params {
	const char * const property;
	enum pin_config_param param;
	u32 default_value;
};

struct pin_config_item {
	const enum pin_config_param param;
	const char * const display;
	const char * const format;
	bool has_arg;
};

struct gpio_desc___2;

struct gpio_device {
	int id;
	struct device dev;
	struct cdev chrdev;
	struct device *mockdev;
	struct module *owner;
	struct gpio_chip *chip;
	struct gpio_desc___2 *descs;
	int base;
	u16 ngpio;
	const char *label;
	void *data;
	struct list_head list;
	struct blocking_notifier_head notifier;
	struct list_head pin_ranges;
};

struct gpio_desc___2 {
	struct gpio_device *gdev;
	long unsigned int flags;
	const char *label;
	const char *name;
	struct device_node *hog;
	unsigned int debounce_period_us;
};

struct pinctrl_setting_mux {
	unsigned int group;
	unsigned int func;
};

struct pinctrl_setting_configs {
	unsigned int group_or_pin;
	long unsigned int *configs;
	unsigned int num_configs;
};

struct pinctrl_setting {
	struct list_head node;
	enum pinctrl_map_type type;
	struct pinctrl_dev *pctldev;
	const char *dev_name;
	union {
		struct pinctrl_setting_mux mux;
		struct pinctrl_setting_configs configs;
	} data;
};

struct pin_desc {
	struct pinctrl_dev *pctldev;
	const char *name;
	bool dynamic_name;
	void *drv_data;
	unsigned int mux_usecount;
	const char *mux_owner;
	const struct pinctrl_setting_mux *mux_setting;
	const char *gpio_owner;
};

struct pinctrl_maps {
	struct list_head node;
	const struct pinctrl_map *maps;
	unsigned int num_maps;
};

struct group_desc {
	const char *name;
	int *pins;
	int num_pins;
	void *data;
};

struct pctldev;

struct function_desc {
	const char *name;
	const char **group_names;
	int num_group_names;
	void *data;
};

struct pinctrl_dt_map {
	struct list_head node;
	struct pinctrl_dev *pctldev;
	struct pinctrl_map *map;
	unsigned int num_maps;
};

struct regmap_irq_chip_data;

struct as3722 {
	struct device *dev;
	struct regmap *regmap;
	int chip_irq;
	long unsigned int irq_flags;
	bool en_intern_int_pullup;
	bool en_intern_i2c_pullup;
	bool en_ac_ok_pwr_on;
	struct regmap_irq_chip_data *irq_data;
};

struct as3722_pin_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
	int mux_option;
};

struct as3722_gpio_pin_control {
	unsigned int mode_prop;
	int io_function;
};

struct as3722_pingroup {
	const char *name;
	const unsigned int pins[1];
	unsigned int npins;
};

struct as3722_pctrl_info {
	struct device *dev;
	struct pinctrl_dev *pctl;
	struct as3722 *as3722;
	struct gpio_chip gpio_chip;
	int pins_current_opt[8];
	const struct as3722_pin_function *functions;
	unsigned int num_functions;
	const struct as3722_pingroup *pin_groups;
	int num_pin_groups;
	const struct pinctrl_pin_desc *pins;
	unsigned int num_pins;
	struct as3722_gpio_pin_control gpio_control[8];
};

enum as3722_pinmux_option {
	AS3722_PINMUX_GPIO = 0,
	AS3722_PINMUX_INTERRUPT_OUT = 1,
	AS3722_PINMUX_VSUB_VBAT_UNDEB_LOW_OUT = 2,
	AS3722_PINMUX_GPIO_INTERRUPT = 3,
	AS3722_PINMUX_PWM_INPUT = 4,
	AS3722_PINMUX_VOLTAGE_IN_STBY = 5,
	AS3722_PINMUX_OC_PG_SD0 = 6,
	AS3722_PINMUX_PG_OUT = 7,
	AS3722_PINMUX_CLK32K_OUT = 8,
	AS3722_PINMUX_WATCHDOG_INPUT = 9,
	AS3722_PINMUX_SOFT_RESET_IN = 11,
	AS3722_PINMUX_PWM_OUTPUT = 12,
	AS3722_PINMUX_VSUB_VBAT_LOW_DEB_OUT = 13,
	AS3722_PINMUX_OC_PG_SD6 = 14,
};

struct amd_pingroup {
	const char *name;
	const unsigned int *pins;
	unsigned int npins;
};

struct amd_gpio {
	raw_spinlock_t lock;
	void *base;
	const struct amd_pingroup *groups;
	u32 ngroups;
	struct pinctrl_dev *pctrl;
	struct gpio_chip gc;
	unsigned int hwbank_num;
	struct resource *res;
	struct platform_device *pdev;
	u32 *saved_regs;
	int irq;
};

struct bm1880_pctrl_group;

struct bm1880_pinmux_function;

struct bm1880_pinconf_data;

struct bm1880_pinctrl {
	void *base;
	struct pinctrl_dev *pctrldev;
	const struct bm1880_pctrl_group *groups;
	unsigned int ngroups;
	const struct bm1880_pinmux_function *funcs;
	unsigned int nfuncs;
	const struct bm1880_pinconf_data *pinconf;
};

struct bm1880_pctrl_group {
	const char *name;
	const unsigned int *pins;
	const unsigned int npins;
};

struct bm1880_pinmux_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
	u32 mux_val;
	u32 mux;
	u8 mux_shift;
};

struct bm1880_pinconf_data {
	u32 drv_bits;
};

enum bm1880_pinmux_functions {
	F_nand = 0,
	F_spi = 1,
	F_emmc = 2,
	F_sdio = 3,
	F_eth0 = 4,
	F_pwm0 = 5,
	F_pwm1 = 6,
	F_pwm2 = 7,
	F_pwm3 = 8,
	F_pwm4 = 9,
	F_pwm5 = 10,
	F_pwm6 = 11,
	F_pwm7 = 12,
	F_pwm8 = 13,
	F_pwm9 = 14,
	F_pwm10 = 15,
	F_pwm11 = 16,
	F_pwm12 = 17,
	F_pwm13 = 18,
	F_pwm14 = 19,
	F_pwm15 = 20,
	F_pwm16 = 21,
	F_pwm17 = 22,
	F_pwm18 = 23,
	F_pwm19 = 24,
	F_pwm20 = 25,
	F_pwm21 = 26,
	F_pwm22 = 27,
	F_pwm23 = 28,
	F_pwm24 = 29,
	F_pwm25 = 30,
	F_pwm26 = 31,
	F_pwm27 = 32,
	F_pwm28 = 33,
	F_pwm29 = 34,
	F_pwm30 = 35,
	F_pwm31 = 36,
	F_pwm32 = 37,
	F_pwm33 = 38,
	F_pwm34 = 39,
	F_pwm35 = 40,
	F_pwm36 = 41,
	F_pwm37 = 42,
	F_i2c0 = 43,
	F_i2c1 = 44,
	F_i2c2 = 45,
	F_i2c3 = 46,
	F_i2c4 = 47,
	F_uart0 = 48,
	F_uart1 = 49,
	F_uart2 = 50,
	F_uart3 = 51,
	F_uart4 = 52,
	F_uart5 = 53,
	F_uart6 = 54,
	F_uart7 = 55,
	F_uart8 = 56,
	F_uart9 = 57,
	F_uart10 = 58,
	F_uart11 = 59,
	F_uart12 = 60,
	F_uart13 = 61,
	F_uart14 = 62,
	F_uart15 = 63,
	F_gpio0 = 64,
	F_gpio1 = 65,
	F_gpio2 = 66,
	F_gpio3 = 67,
	F_gpio4 = 68,
	F_gpio5 = 69,
	F_gpio6 = 70,
	F_gpio7 = 71,
	F_gpio8 = 72,
	F_gpio9 = 73,
	F_gpio10 = 74,
	F_gpio11 = 75,
	F_gpio12 = 76,
	F_gpio13 = 77,
	F_gpio14 = 78,
	F_gpio15 = 79,
	F_gpio16 = 80,
	F_gpio17 = 81,
	F_gpio18 = 82,
	F_gpio19 = 83,
	F_gpio20 = 84,
	F_gpio21 = 85,
	F_gpio22 = 86,
	F_gpio23 = 87,
	F_gpio24 = 88,
	F_gpio25 = 89,
	F_gpio26 = 90,
	F_gpio27 = 91,
	F_gpio28 = 92,
	F_gpio29 = 93,
	F_gpio30 = 94,
	F_gpio31 = 95,
	F_gpio32 = 96,
	F_gpio33 = 97,
	F_gpio34 = 98,
	F_gpio35 = 99,
	F_gpio36 = 100,
	F_gpio37 = 101,
	F_gpio38 = 102,
	F_gpio39 = 103,
	F_gpio40 = 104,
	F_gpio41 = 105,
	F_gpio42 = 106,
	F_gpio43 = 107,
	F_gpio44 = 108,
	F_gpio45 = 109,
	F_gpio46 = 110,
	F_gpio47 = 111,
	F_gpio48 = 112,
	F_gpio49 = 113,
	F_gpio50 = 114,
	F_gpio51 = 115,
	F_gpio52 = 116,
	F_gpio53 = 117,
	F_gpio54 = 118,
	F_gpio55 = 119,
	F_gpio56 = 120,
	F_gpio57 = 121,
	F_gpio58 = 122,
	F_gpio59 = 123,
	F_gpio60 = 124,
	F_gpio61 = 125,
	F_gpio62 = 126,
	F_gpio63 = 127,
	F_gpio64 = 128,
	F_gpio65 = 129,
	F_gpio66 = 130,
	F_gpio67 = 131,
	F_eth1 = 132,
	F_i2s0 = 133,
	F_i2s0_mclkin = 134,
	F_i2s1 = 135,
	F_i2s1_mclkin = 136,
	F_spi0 = 137,
	F_max = 138,
};

struct meson_pmx_group {
	const char *name;
	const unsigned int *pins;
	unsigned int num_pins;
	const void *data;
};

struct meson_pmx_func {
	const char *name;
	const char * const *groups;
	unsigned int num_groups;
};

struct meson_reg_desc {
	unsigned int reg;
	unsigned int bit;
};

enum meson_reg_type {
	REG_PULLEN = 0,
	REG_PULL = 1,
	REG_DIR = 2,
	REG_OUT = 3,
	REG_IN = 4,
	REG_DS = 5,
	NUM_REG = 6,
};

enum meson_pinconf_drv {
	MESON_PINCONF_DRV_500UA = 0,
	MESON_PINCONF_DRV_2500UA = 1,
	MESON_PINCONF_DRV_3000UA = 2,
	MESON_PINCONF_DRV_4000UA = 3,
};

struct meson_bank {
	const char *name;
	unsigned int first;
	unsigned int last;
	int irq_first;
	int irq_last;
	struct meson_reg_desc regs[6];
};

struct meson_pinctrl;

struct meson_pinctrl_data {
	const char *name;
	const struct pinctrl_pin_desc *pins;
	struct meson_pmx_group *groups;
	struct meson_pmx_func *funcs;
	unsigned int num_pins;
	unsigned int num_groups;
	unsigned int num_funcs;
	struct meson_bank *banks;
	unsigned int num_banks;
	const struct pinmux_ops *pmx_ops;
	void *pmx_data;
	int (*parse_dt)(struct meson_pinctrl *);
};

struct meson_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pcdev;
	struct pinctrl_desc desc;
	struct meson_pinctrl_data *data;
	struct regmap *reg_mux;
	struct regmap *reg_pullen;
	struct regmap *reg_pull;
	struct regmap *reg_gpio;
	struct regmap *reg_ds;
	struct gpio_chip chip;
	struct device_node *of_node;
};

struct meson8_pmx_data {
	bool is_gpio;
	unsigned int reg;
	unsigned int bit;
};

struct meson_pmx_bank {
	const char *name;
	unsigned int first;
	unsigned int last;
	unsigned int reg;
	unsigned int offset;
};

struct meson_axg_pmx_data {
	struct meson_pmx_bank *pmx_banks;
	unsigned int num_pmx_banks;
};

struct meson_pmx_axg_data {
	unsigned int func;
};

struct extcon_dev;

struct regulator_dev;

struct regulator_ops {
	int (*list_voltage)(struct regulator_dev *, unsigned int);
	int (*set_voltage)(struct regulator_dev *, int, int, unsigned int *);
	int (*map_voltage)(struct regulator_dev *, int, int);
	int (*set_voltage_sel)(struct regulator_dev *, unsigned int);
	int (*get_voltage)(struct regulator_dev *);
	int (*get_voltage_sel)(struct regulator_dev *);
	int (*set_current_limit)(struct regulator_dev *, int, int);
	int (*get_current_limit)(struct regulator_dev *);
	int (*set_input_current_limit)(struct regulator_dev *, int);
	int (*set_over_current_protection)(struct regulator_dev *);
	int (*set_active_discharge)(struct regulator_dev *, bool);
	int (*enable)(struct regulator_dev *);
	int (*disable)(struct regulator_dev *);
	int (*is_enabled)(struct regulator_dev *);
	int (*set_mode)(struct regulator_dev *, unsigned int);
	unsigned int (*get_mode)(struct regulator_dev *);
	int (*get_error_flags)(struct regulator_dev *, unsigned int *);
	int (*enable_time)(struct regulator_dev *);
	int (*set_ramp_delay)(struct regulator_dev *, int);
	int (*set_voltage_time)(struct regulator_dev *, int, int);
	int (*set_voltage_time_sel)(struct regulator_dev *, unsigned int, unsigned int);
	int (*set_soft_start)(struct regulator_dev *);
	int (*get_status)(struct regulator_dev *);
	unsigned int (*get_optimum_mode)(struct regulator_dev *, int, int, int);
	int (*set_load)(struct regulator_dev *, int);
	int (*set_bypass)(struct regulator_dev *, bool);
	int (*get_bypass)(struct regulator_dev *, bool *);
	int (*set_suspend_voltage)(struct regulator_dev *, int);
	int (*set_suspend_enable)(struct regulator_dev *);
	int (*set_suspend_disable)(struct regulator_dev *);
	int (*set_suspend_mode)(struct regulator_dev *, unsigned int);
	int (*resume)(struct regulator_dev *);
	int (*set_pull_down)(struct regulator_dev *);
};

struct regulator_coupler;

struct coupling_desc {
	struct regulator_dev **coupled_rdevs;
	struct regulator_coupler *coupler;
	int n_resolved;
	int n_coupled;
};

struct regulator_desc;

struct regulation_constraints;

struct regulator_enable_gpio;

struct regulator_dev {
	const struct regulator_desc *desc;
	int exclusive;
	u32 use_count;
	u32 open_count;
	u32 bypass_count;
	struct list_head list;
	struct list_head consumer_list;
	struct coupling_desc coupling_desc;
	struct blocking_notifier_head notifier;
	struct ww_mutex mutex;
	struct task_struct *mutex_owner;
	int ref_cnt;
	struct module *owner;
	struct device dev;
	struct regulation_constraints *constraints;
	struct regulator *supply;
	const char *supply_name;
	struct regmap *regmap;
	struct delayed_work disable_work;
	void *reg_data;
	struct dentry *debugfs;
	struct regulator_enable_gpio *ena_pin;
	unsigned int ena_gpio_state: 1;
	unsigned int is_switch: 1;
	ktime_t last_off;
};

enum regulator_type {
	REGULATOR_VOLTAGE = 0,
	REGULATOR_CURRENT = 1,
};

struct regulator_config;

struct regulator_desc {
	const char *name;
	const char *supply_name;
	const char *of_match;
	bool of_match_full_name;
	const char *regulators_node;
	int (*of_parse_cb)(struct device_node *, const struct regulator_desc *, struct regulator_config *);
	int id;
	unsigned int continuous_voltage_range: 1;
	unsigned int n_voltages;
	unsigned int n_current_limits;
	const struct regulator_ops *ops;
	int irq;
	enum regulator_type type;
	struct module *owner;
	unsigned int min_uV;
	unsigned int uV_step;
	unsigned int linear_min_sel;
	int fixed_uV;
	unsigned int ramp_delay;
	int min_dropout_uV;
	const struct linear_range *linear_ranges;
	const unsigned int *linear_range_selectors;
	int n_linear_ranges;
	const unsigned int *volt_table;
	const unsigned int *curr_table;
	unsigned int vsel_range_reg;
	unsigned int vsel_range_mask;
	unsigned int vsel_reg;
	unsigned int vsel_mask;
	unsigned int vsel_step;
	unsigned int csel_reg;
	unsigned int csel_mask;
	unsigned int apply_reg;
	unsigned int apply_bit;
	unsigned int enable_reg;
	unsigned int enable_mask;
	unsigned int enable_val;
	unsigned int disable_val;
	bool enable_is_inverted;
	unsigned int bypass_reg;
	unsigned int bypass_mask;
	unsigned int bypass_val_on;
	unsigned int bypass_val_off;
	unsigned int active_discharge_on;
	unsigned int active_discharge_off;
	unsigned int active_discharge_mask;
	unsigned int active_discharge_reg;
	unsigned int soft_start_reg;
	unsigned int soft_start_mask;
	unsigned int soft_start_val_on;
	unsigned int pull_down_reg;
	unsigned int pull_down_mask;
	unsigned int pull_down_val_on;
	unsigned int ramp_reg;
	unsigned int ramp_mask;
	const unsigned int *ramp_delay_table;
	unsigned int n_ramp_values;
	unsigned int enable_time;
	unsigned int off_on_delay;
	unsigned int poll_enabled_time;
	unsigned int (*of_map_mode)(unsigned int);
};

struct regulator_init_data;

struct regulator_config {
	struct device *dev;
	const struct regulator_init_data *init_data;
	void *driver_data;
	struct device_node *of_node;
	struct regmap *regmap;
	struct gpio_desc *ena_gpiod;
};

struct regulator_state {
	int uV;
	int min_uV;
	int max_uV;
	unsigned int mode;
	int enabled;
	bool changeable;
};

struct regulation_constraints {
	const char *name;
	int min_uV;
	int max_uV;
	int uV_offset;
	int min_uA;
	int max_uA;
	int ilim_uA;
	int system_load;
	u32 *max_spread;
	int max_uV_step;
	unsigned int valid_modes_mask;
	unsigned int valid_ops_mask;
	int input_uV;
	struct regulator_state state_disk;
	struct regulator_state state_mem;
	struct regulator_state state_standby;
	suspend_state_t initial_state;
	unsigned int initial_mode;
	unsigned int ramp_delay;
	unsigned int settling_time;
	unsigned int settling_time_up;
	unsigned int settling_time_down;
	unsigned int enable_time;
	unsigned int active_discharge;
	unsigned int always_on: 1;
	unsigned int boot_on: 1;
	unsigned int apply_uV: 1;
	unsigned int ramp_disable: 1;
	unsigned int soft_start: 1;
	unsigned int pull_down: 1;
	unsigned int over_current_protection: 1;
};

struct regulator_consumer_supply;

struct regulator_init_data {
	const char *supply_regulator;
	struct regulation_constraints constraints;
	int num_consumer_supplies;
	struct regulator_consumer_supply *consumer_supplies;
	int (*regulator_init)(void *);
	void *driver_data;
};

enum palmas_usb_state {
	PALMAS_USB_STATE_DISCONNECT = 0,
	PALMAS_USB_STATE_VBUS = 1,
	PALMAS_USB_STATE_ID = 2,
};

struct palmas_gpadc;

struct i2c_client;

struct palmas_pmic_driver_data;

struct palmas_pmic;

struct palmas_resource;

struct palmas_usb;

struct palmas {
	struct device *dev;
	struct i2c_client *i2c_clients[3];
	struct regmap *regmap[3];
	int id;
	unsigned int features;
	int irq;
	u32 irq_mask;
	struct mutex irq_lock;
	struct regmap_irq_chip_data *irq_data;
	struct palmas_pmic_driver_data *pmic_ddata;
	struct palmas_pmic *pmic;
	struct palmas_gpadc *gpadc;
	struct palmas_resource *resource;
	struct palmas_usb *usb;
	u8 gpio_muxed;
	u8 led_muxed;
	u8 pwm_muxed;
};

struct of_regulator_match;

struct palmas_regs_info;

struct palmas_sleep_requestor_info;

struct palmas_pmic_platform_data;

struct palmas_pmic_driver_data {
	int smps_start;
	int smps_end;
	int ldo_begin;
	int ldo_end;
	int max_reg;
	bool has_regen3;
	struct palmas_regs_info *palmas_regs_info;
	struct of_regulator_match *palmas_matches;
	struct palmas_sleep_requestor_info *sleep_req_info;
	int (*smps_register)(struct palmas_pmic *, struct palmas_pmic_driver_data *, struct palmas_pmic_platform_data *, const char *, struct regulator_config);
	int (*ldo_register)(struct palmas_pmic *, struct palmas_pmic_driver_data *, struct palmas_pmic_platform_data *, const char *, struct regulator_config);
};

struct palmas_pmic {
	struct palmas *palmas;
	struct device *dev;
	struct regulator_desc desc[27];
	struct mutex mutex;
	int smps123;
	int smps457;
	int smps12;
	int range[10];
	unsigned int ramp_delay[10];
	unsigned int current_reg_mode[10];
};

struct palmas_resource {
	struct palmas *palmas;
	struct device *dev;
};

struct palmas_usb {
	struct palmas *palmas;
	struct device *dev;
	struct extcon_dev *edev;
	int id_otg_irq;
	int id_irq;
	int vbus_otg_irq;
	int vbus_irq;
	int gpio_id_irq;
	int gpio_vbus_irq;
	struct gpio_desc *id_gpiod;
	struct gpio_desc *vbus_gpiod;
	long unsigned int sw_debounce_jiffies;
	struct delayed_work wq_detectid;
	enum palmas_usb_state linkstat;
	int wakeup;
	bool enable_vbus_detection;
	bool enable_id_detection;
	bool enable_gpio_id_detection;
	bool enable_gpio_vbus_detection;
};

struct palmas_sleep_requestor_info {
	int id;
	int reg_offset;
	int bit_pos;
};

struct palmas_regs_info {
	char *name;
	char *sname;
	u8 vsel_addr;
	u8 ctrl_addr;
	u8 tstep_addr;
	int sleep_id;
};

struct palmas_reg_init;

struct palmas_pmic_platform_data {
	struct regulator_init_data *reg_data[27];
	struct palmas_reg_init *reg_init[27];
	int ldo6_vibrator;
	bool enable_ldo8_tracking;
};

struct palmas_reg_init {
	int warm_reset;
	int roof_floor;
	int mode_sleep;
	u8 vsel;
};

enum palmas_regulators {
	PALMAS_REG_SMPS12 = 0,
	PALMAS_REG_SMPS123 = 1,
	PALMAS_REG_SMPS3 = 2,
	PALMAS_REG_SMPS45 = 3,
	PALMAS_REG_SMPS457 = 4,
	PALMAS_REG_SMPS6 = 5,
	PALMAS_REG_SMPS7 = 6,
	PALMAS_REG_SMPS8 = 7,
	PALMAS_REG_SMPS9 = 8,
	PALMAS_REG_SMPS10_OUT2 = 9,
	PALMAS_REG_SMPS10_OUT1 = 10,
	PALMAS_REG_LDO1 = 11,
	PALMAS_REG_LDO2 = 12,
	PALMAS_REG_LDO3 = 13,
	PALMAS_REG_LDO4 = 14,
	PALMAS_REG_LDO5 = 15,
	PALMAS_REG_LDO6 = 16,
	PALMAS_REG_LDO7 = 17,
	PALMAS_REG_LDO8 = 18,
	PALMAS_REG_LDO9 = 19,
	PALMAS_REG_LDOLN = 20,
	PALMAS_REG_LDOUSB = 21,
	PALMAS_REG_REGEN1 = 22,
	PALMAS_REG_REGEN2 = 23,
	PALMAS_REG_REGEN3 = 24,
	PALMAS_REG_SYSEN1 = 25,
	PALMAS_REG_SYSEN2 = 26,
	PALMAS_NUM_REGS = 27,
};

struct palmas_pin_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
};

struct palmas_pingroup;

struct palmas_pctrl_chip_info {
	struct device *dev;
	struct pinctrl_dev *pctl;
	struct palmas *palmas;
	int pins_current_opt[26];
	const struct palmas_pin_function *functions;
	unsigned int num_functions;
	const struct palmas_pingroup *pin_groups;
	int num_pin_groups;
	const struct pinctrl_pin_desc *pins;
	unsigned int num_pins;
};

struct palmas_pin_info;

struct palmas_pingroup {
	const char *name;
	const unsigned int pins[1];
	unsigned int npins;
	unsigned int mux_reg_base;
	unsigned int mux_reg_add;
	unsigned int mux_reg_mask;
	unsigned int mux_bit_shift;
	const struct palmas_pin_info *opt[4];
};

enum palmas_pinmux {
	PALMAS_PINMUX_OPTION0 = 0,
	PALMAS_PINMUX_OPTION1 = 1,
	PALMAS_PINMUX_OPTION2 = 2,
	PALMAS_PINMUX_OPTION3 = 3,
	PALMAS_PINMUX_GPIO = 4,
	PALMAS_PINMUX_LED = 5,
	PALMAS_PINMUX_PWM = 6,
	PALMAS_PINMUX_REGEN = 7,
	PALMAS_PINMUX_SYSEN = 8,
	PALMAS_PINMUX_CLK32KGAUDIO = 9,
	PALMAS_PINMUX_ID = 10,
	PALMAS_PINMUX_VBUS_DET = 11,
	PALMAS_PINMUX_CHRG_DET = 12,
	PALMAS_PINMUX_VAC = 13,
	PALMAS_PINMUX_VACOK = 14,
	PALMAS_PINMUX_POWERGOOD = 15,
	PALMAS_PINMUX_USB_PSEL = 16,
	PALMAS_PINMUX_MSECURE = 17,
	PALMAS_PINMUX_PWRHOLD = 18,
	PALMAS_PINMUX_INT = 19,
	PALMAS_PINMUX_NRESWARM = 20,
	PALMAS_PINMUX_SIMRSTO = 21,
	PALMAS_PINMUX_SIMRSTI = 22,
	PALMAS_PINMUX_LOW_VBAT = 23,
	PALMAS_PINMUX_WIRELESS_CHRG1 = 24,
	PALMAS_PINMUX_RCM = 25,
	PALMAS_PINMUX_PWRDOWN = 26,
	PALMAS_PINMUX_GPADC_START = 27,
	PALMAS_PINMUX_RESET_IN = 28,
	PALMAS_PINMUX_NSLEEP = 29,
	PALMAS_PINMUX_ENABLE = 30,
	PALMAS_PINMUX_NA = 65535,
};

struct palmas_pins_pullup_dn_info {
	int pullup_dn_reg_base;
	int pullup_dn_reg_add;
	int pullup_dn_mask;
	int normal_val;
	int pull_up_val;
	int pull_dn_val;
};

struct palmas_pins_od_info {
	int od_reg_base;
	int od_reg_add;
	int od_mask;
	int od_enable;
	int od_disable;
};

struct palmas_pin_info {
	enum palmas_pinmux mux_opt;
	const struct palmas_pins_pullup_dn_info *pud_info;
	const struct palmas_pins_od_info *od_info;
};

struct palmas_pinctrl_data {
	const struct palmas_pingroup *pin_groups;
	int num_pin_groups;
};

enum rockchip_pinctrl_type {
	PX30 = 0,
	RV1108 = 1,
	RK2928 = 2,
	RK3066B = 3,
	RK3128 = 4,
	RK3188 = 5,
	RK3288 = 6,
	RK3308 = 7,
	RK3368 = 8,
	RK3399 = 9,
	RK3568 = 10,
};

struct rockchip_iomux {
	int type;
	int offset;
};

enum rockchip_pin_drv_type {
	DRV_TYPE_IO_DEFAULT = 0,
	DRV_TYPE_IO_1V8_OR_3V0 = 1,
	DRV_TYPE_IO_1V8_ONLY = 2,
	DRV_TYPE_IO_1V8_3V0_AUTO = 3,
	DRV_TYPE_IO_3V3_ONLY = 4,
	DRV_TYPE_MAX = 5,
};

enum rockchip_pin_pull_type {
	PULL_TYPE_IO_DEFAULT = 0,
	PULL_TYPE_IO_1V8_ONLY = 1,
	PULL_TYPE_MAX = 2,
};

struct rockchip_drv {
	enum rockchip_pin_drv_type drv_type;
	int offset;
};

struct rockchip_pinctrl;

struct rockchip_pin_bank {
	void *reg_base;
	struct regmap *regmap_pull;
	struct clk *clk;
	int irq;
	u32 saved_masks;
	u32 pin_base;
	u8 nr_pins;
	char *name;
	u8 bank_num;
	struct rockchip_iomux iomux[4];
	struct rockchip_drv drv[4];
	enum rockchip_pin_pull_type pull_type[4];
	bool valid;
	struct device_node *of_node;
	struct rockchip_pinctrl *drvdata;
	struct irq_domain *domain;
	struct gpio_chip gpio_chip;
	struct pinctrl_gpio_range grange;
	raw_spinlock_t slock;
	u32 toggle_edge_mode;
	u32 recalced_mask;
	u32 route_mask;
};

struct rockchip_pin_ctrl;

struct rockchip_pin_group;

struct rockchip_pmx_func;

struct rockchip_pinctrl {
	struct regmap *regmap_base;
	int reg_size;
	struct regmap *regmap_pull;
	struct regmap *regmap_pmu;
	struct device *dev;
	struct rockchip_pin_ctrl *ctrl;
	struct pinctrl_desc pctl;
	struct pinctrl_dev *pctl_dev;
	struct rockchip_pin_group *groups;
	unsigned int ngroups;
	struct rockchip_pmx_func *functions;
	unsigned int nfunctions;
};

struct rockchip_mux_recalced_data {
	u8 num;
	u8 pin;
	u32 reg;
	u8 bit;
	u8 mask;
};

enum rockchip_mux_route_location {
	ROCKCHIP_ROUTE_SAME = 0,
	ROCKCHIP_ROUTE_PMU = 1,
	ROCKCHIP_ROUTE_GRF = 2,
};

struct rockchip_mux_route_data {
	u8 bank_num;
	u8 pin;
	u8 func;
	enum rockchip_mux_route_location route_location;
	u32 route_offset;
	u32 route_val;
};

struct rockchip_pin_ctrl {
	struct rockchip_pin_bank *pin_banks;
	u32 nr_banks;
	u32 nr_pins;
	char *label;
	enum rockchip_pinctrl_type type;
	int grf_mux_offset;
	int pmu_mux_offset;
	int grf_drv_offset;
	int pmu_drv_offset;
	struct rockchip_mux_recalced_data *iomux_recalced;
	u32 niomux_recalced;
	struct rockchip_mux_route_data *iomux_routes;
	u32 niomux_routes;
	void (*pull_calc_reg)(struct rockchip_pin_bank *, int, struct regmap **, int *, u8 *);
	void (*drv_calc_reg)(struct rockchip_pin_bank *, int, struct regmap **, int *, u8 *);
	int (*schmitt_calc_reg)(struct rockchip_pin_bank *, int, struct regmap **, int *, u8 *);
};

struct rockchip_pin_config {
	unsigned int func;
	long unsigned int *configs;
	unsigned int nconfigs;
};

struct rockchip_pin_group {
	const char *name;
	unsigned int npins;
	unsigned int *pins;
	struct rockchip_pin_config *data;
};

struct rockchip_pmx_func {
	const char *name;
	const char **groups;
	u8 ngroups;
};

struct pcs_pdata {
	int irq;
	void (*rearm)();
};

struct pcs_func_vals {
	void *reg;
	unsigned int val;
	unsigned int mask;
};

struct pcs_conf_vals {
	enum pin_config_param param;
	unsigned int val;
	unsigned int enable;
	unsigned int disable;
	unsigned int mask;
};

struct pcs_conf_type {
	const char *name;
	enum pin_config_param param;
};

struct pcs_function {
	const char *name;
	struct pcs_func_vals *vals;
	unsigned int nvals;
	const char **pgnames;
	int npgnames;
	struct pcs_conf_vals *conf;
	int nconfs;
	struct list_head node;
};

struct pcs_gpiofunc_range {
	unsigned int offset;
	unsigned int npins;
	unsigned int gpiofunc;
	struct list_head node;
};

struct pcs_data {
	struct pinctrl_pin_desc *pa;
	int cur;
};

struct pcs_soc_data {
	unsigned int flags;
	int irq;
	unsigned int irq_enable_mask;
	unsigned int irq_status_mask;
	void (*rearm)();
};

struct pcs_device {
	struct resource *res;
	void *base;
	void *saved_vals;
	unsigned int size;
	struct device *dev;
	struct device_node *np;
	struct pinctrl_dev *pctl;
	unsigned int flags;
	struct property *missing_nr_pinctrl_cells;
	struct pcs_soc_data socdata;
	raw_spinlock_t lock;
	struct mutex mutex;
	unsigned int width;
	unsigned int fmask;
	unsigned int fshift;
	unsigned int foff;
	unsigned int fmax;
	bool bits_per_mux;
	unsigned int bits_per_pin;
	struct pcs_data pins;
	struct list_head gpiofuncs;
	struct list_head irqs;
	struct irq_chip chip;
	struct irq_domain *domain;
	struct pinctrl_desc desc;
	unsigned int (*read)(void *);
	void (*write)(unsigned int, void *);
};

struct pcs_interrupt {
	void *reg;
	irq_hw_number_t hwirq;
	unsigned int irq;
	struct list_head node;
};

struct i2c_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct software_node {
	const char *name;
	const struct software_node *parent;
	const struct property_entry *properties;
};

struct i2c_msg {
	__u16 addr;
	__u16 flags;
	__u16 len;
	__u8 *buf;
};

union i2c_smbus_data {
	__u8 byte;
	__u16 word;
	__u8 block[34];
};

enum i2c_slave_event {
	I2C_SLAVE_READ_REQUESTED = 0,
	I2C_SLAVE_WRITE_REQUESTED = 1,
	I2C_SLAVE_READ_PROCESSED = 2,
	I2C_SLAVE_WRITE_RECEIVED = 3,
	I2C_SLAVE_STOP = 4,
};

typedef int (*i2c_slave_cb_t)(struct i2c_client *, enum i2c_slave_event, u8 *);

struct i2c_adapter;

struct i2c_client {
	short unsigned int flags;
	short unsigned int addr;
	char name[20];
	struct i2c_adapter *adapter;
	struct device dev;
	int init_irq;
	int irq;
	struct list_head detected;
	i2c_slave_cb_t slave_cb;
	void *devres_group_id;
};

enum i2c_alert_protocol {
	I2C_PROTOCOL_SMBUS_ALERT = 0,
	I2C_PROTOCOL_SMBUS_HOST_NOTIFY = 1,
};

struct i2c_board_info;

struct i2c_driver {
	unsigned int class;
	int (*probe)(struct i2c_client *, const struct i2c_device_id *);
	int (*remove)(struct i2c_client *);
	int (*probe_new)(struct i2c_client *);
	void (*shutdown)(struct i2c_client *);
	void (*alert)(struct i2c_client *, enum i2c_alert_protocol, unsigned int);
	int (*command)(struct i2c_client *, unsigned int, void *);
	struct device_driver driver;
	const struct i2c_device_id *id_table;
	int (*detect)(struct i2c_client *, struct i2c_board_info *);
	const short unsigned int *address_list;
	struct list_head clients;
};

struct i2c_board_info {
	char type[20];
	short unsigned int flags;
	short unsigned int addr;
	const char *dev_name;
	void *platform_data;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	const struct software_node *swnode;
	const struct resource *resources;
	unsigned int num_resources;
	int irq;
};

struct i2c_algorithm;

struct i2c_lock_operations;

struct i2c_bus_recovery_info;

struct i2c_adapter_quirks;

struct i2c_adapter {
	struct module *owner;
	unsigned int class;
	const struct i2c_algorithm *algo;
	void *algo_data;
	const struct i2c_lock_operations *lock_ops;
	struct rt_mutex bus_lock;
	struct rt_mutex mux_lock;
	int timeout;
	int retries;
	struct device dev;
	long unsigned int locked_flags;
	int nr;
	char name[48];
	struct completion dev_released;
	struct mutex userspace_clients_lock;
	struct list_head userspace_clients;
	struct i2c_bus_recovery_info *bus_recovery_info;
	const struct i2c_adapter_quirks *quirks;
	struct irq_domain *host_notify_domain;
};

struct i2c_algorithm {
	int (*master_xfer)(struct i2c_adapter *, struct i2c_msg *, int);
	int (*master_xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int);
	int (*smbus_xfer)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	int (*smbus_xfer_atomic)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	u32 (*functionality)(struct i2c_adapter *);
	int (*reg_slave)(struct i2c_client *);
	int (*unreg_slave)(struct i2c_client *);
};

struct i2c_lock_operations {
	void (*lock_bus)(struct i2c_adapter *, unsigned int);
	int (*trylock_bus)(struct i2c_adapter *, unsigned int);
	void (*unlock_bus)(struct i2c_adapter *, unsigned int);
};

struct i2c_bus_recovery_info {
	int (*recover_bus)(struct i2c_adapter *);
	int (*get_scl)(struct i2c_adapter *);
	void (*set_scl)(struct i2c_adapter *, int);
	int (*get_sda)(struct i2c_adapter *);
	void (*set_sda)(struct i2c_adapter *, int);
	int (*get_bus_free)(struct i2c_adapter *);
	void (*prepare_recovery)(struct i2c_adapter *);
	void (*unprepare_recovery)(struct i2c_adapter *);
	struct gpio_desc *scl_gpiod;
	struct gpio_desc *sda_gpiod;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_gpio;
};

struct i2c_adapter_quirks {
	u64 flags;
	int max_num_msgs;
	u16 max_write_len;
	u16 max_read_len;
	u16 max_comb_1st_msg_len;
	u16 max_comb_2nd_msg_len;
};

enum {
	SX150X_123 = 0,
	SX150X_456 = 1,
	SX150X_789 = 2,
};

enum {
	SX150X_789_REG_MISC_AUTOCLEAR_OFF = 1,
	SX150X_MAX_REGISTER = 173,
	SX150X_IRQ_TYPE_EDGE_RISING = 1,
	SX150X_IRQ_TYPE_EDGE_FALLING = 2,
	SX150X_789_RESET_KEY1 = 18,
	SX150X_789_RESET_KEY2 = 52,
};

struct sx150x_123_pri {
	u8 reg_pld_mode;
	u8 reg_pld_table0;
	u8 reg_pld_table1;
	u8 reg_pld_table2;
	u8 reg_pld_table3;
	u8 reg_pld_table4;
	u8 reg_advanced;
};

struct sx150x_456_pri {
	u8 reg_pld_mode;
	u8 reg_pld_table0;
	u8 reg_pld_table1;
	u8 reg_pld_table2;
	u8 reg_pld_table3;
	u8 reg_pld_table4;
	u8 reg_advanced;
};

struct sx150x_789_pri {
	u8 reg_drain;
	u8 reg_polarity;
	u8 reg_clock;
	u8 reg_misc;
	u8 reg_reset;
	u8 ngpios;
};

struct sx150x_device_data {
	u8 model;
	u8 reg_pullup;
	u8 reg_pulldn;
	u8 reg_dir;
	u8 reg_data;
	u8 reg_irq_mask;
	u8 reg_irq_src;
	u8 reg_sense;
	u8 ngpios;
	union {
		struct sx150x_123_pri x123;
		struct sx150x_456_pri x456;
		struct sx150x_789_pri x789;
	} pri;
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
};

struct sx150x_pinctrl {
	struct device *dev;
	struct i2c_client *client;
	struct pinctrl_dev *pctldev;
	struct pinctrl_desc pinctrl_desc;
	struct gpio_chip gpio;
	struct irq_chip irq_chip;
	struct regmap *regmap;
	struct {
		u32 sense;
		u32 masked;
	} irq;
	struct mutex lock;
	const struct sx150x_device_data *data;
};

enum {
	PINCONF_BIAS = 0,
	PINCONF_SCHMITT = 1,
	PINCONF_DRIVE_STRENGTH = 2,
};

enum {
	FUNC_NONE = 0,
	FUNC_GPIO = 1,
	FUNC_IRQ0 = 2,
	FUNC_IRQ0_IN = 3,
	FUNC_IRQ0_OUT = 4,
	FUNC_IRQ1 = 5,
	FUNC_IRQ1_IN = 6,
	FUNC_IRQ1_OUT = 7,
	FUNC_EXT_IRQ = 8,
	FUNC_MIIM = 9,
	FUNC_PHY_LED = 10,
	FUNC_PCI_WAKE = 11,
	FUNC_MD = 12,
	FUNC_PTP0 = 13,
	FUNC_PTP1 = 14,
	FUNC_PTP2 = 15,
	FUNC_PTP3 = 16,
	FUNC_PWM = 17,
	FUNC_RECO_CLK = 18,
	FUNC_SFP = 19,
	FUNC_SG0 = 20,
	FUNC_SG1 = 21,
	FUNC_SG2 = 22,
	FUNC_SI = 23,
	FUNC_SI2 = 24,
	FUNC_TACHO = 25,
	FUNC_TWI = 26,
	FUNC_TWI2 = 27,
	FUNC_TWI3 = 28,
	FUNC_TWI_SCL_M = 29,
	FUNC_UART = 30,
	FUNC_UART2 = 31,
	FUNC_UART3 = 32,
	FUNC_PLL_STAT = 33,
	FUNC_EMMC = 34,
	FUNC_REF_CLK = 35,
	FUNC_RCVRD_CLK = 36,
	FUNC_MAX = 37,
};

struct ocelot_pmx_func {
	const char **groups;
	unsigned int ngroups;
};

struct ocelot_pin_caps {
	unsigned int pin;
	unsigned char functions[4];
};

struct ocelot_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctl;
	struct gpio_chip gpio_chip;
	struct regmap *map;
	void *pincfg;
	struct pinctrl_desc *desc;
	struct ocelot_pmx_func func[37];
	u8 stride;
};

enum {
	REG_INPUT_DATA = 0,
	REG_PORT_CONFIG = 1,
	REG_PORT_ENABLE = 2,
	REG_SIO_CONFIG = 3,
	REG_SIO_CLOCK = 4,
	REG_INT_POLARITY = 5,
	REG_INT_TRIGGER = 6,
	REG_INT_ACK = 7,
	REG_INT_ENABLE = 8,
	REG_INT_IDENT = 9,
	MAXREG = 10,
};

enum {
	SGPIO_ARCH_LUTON = 0,
	SGPIO_ARCH_OCELOT = 1,
	SGPIO_ARCH_SPARX5 = 2,
};

enum {
	SGPIO_FLAGS_HAS_IRQ = 1,
};

struct sgpio_properties {
	int arch;
	int flags;
	u8 regoff[10];
};

struct sgpio_priv;

struct sgpio_bank {
	struct sgpio_priv *priv;
	bool is_input;
	struct gpio_chip gpio;
	struct pinctrl_desc pctl_desc;
};

struct sgpio_priv {
	struct device *dev;
	struct sgpio_bank in;
	struct sgpio_bank out;
	u32 bitcount;
	u32 ports;
	u32 clock;
	u32 *regs;
	const struct sgpio_properties *properties;
};

struct sgpio_port_addr {
	u8 port;
	u8 bit;
};

enum owl_pinconf_drv {
	OWL_PINCONF_DRV_2MA = 0,
	OWL_PINCONF_DRV_4MA = 1,
	OWL_PINCONF_DRV_8MA = 2,
	OWL_PINCONF_DRV_12MA = 3,
};

struct owl_pullctl {
	int reg;
	unsigned int shift;
	unsigned int width;
};

struct owl_st {
	int reg;
	unsigned int shift;
	unsigned int width;
};

struct owl_pingroup {
	const char *name;
	unsigned int *pads;
	unsigned int npads;
	unsigned int *funcs;
	unsigned int nfuncs;
	int mfpctl_reg;
	unsigned int mfpctl_shift;
	unsigned int mfpctl_width;
	int drv_reg;
	unsigned int drv_shift;
	unsigned int drv_width;
	int sr_reg;
	unsigned int sr_shift;
	unsigned int sr_width;
};

struct owl_padinfo {
	int pad;
	struct owl_pullctl *pullctl;
	struct owl_st *st;
};

struct owl_pinmux_func {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
};

struct owl_gpio_port {
	unsigned int offset;
	unsigned int pins;
	unsigned int outen;
	unsigned int inen;
	unsigned int dat;
	unsigned int intc_ctl;
	unsigned int intc_pd;
	unsigned int intc_msk;
	unsigned int intc_type;
	u8 shared_ctl_offset;
};

struct owl_pinctrl_soc_data {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct owl_pinmux_func *functions;
	unsigned int nfunctions;
	const struct owl_pingroup *groups;
	unsigned int ngroups;
	const struct owl_padinfo *padinfo;
	unsigned int ngpios;
	const struct owl_gpio_port *ports;
	unsigned int nports;
	int (*padctl_val2arg)(const struct owl_padinfo *, unsigned int, u32 *);
	int (*padctl_arg2val)(const struct owl_padinfo *, unsigned int, u32 *);
};

struct owl_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctrldev;
	struct gpio_chip chip;
	raw_spinlock_t lock;
	struct clk *clk;
	const struct owl_pinctrl_soc_data *soc;
	void *base;
	struct irq_chip irq_chip;
	unsigned int num_irq;
	unsigned int *irq;
};

enum s700_pinmux_functions {
	S700_MUX_NOR = 0,
	S700_MUX_ETH_RGMII = 1,
	S700_MUX_ETH_SGMII = 2,
	S700_MUX_SPI0 = 3,
	S700_MUX_SPI1 = 4,
	S700_MUX_SPI2 = 5,
	S700_MUX_SPI3 = 6,
	S700_MUX_SENS0 = 7,
	S700_MUX_SENS1 = 8,
	S700_MUX_UART0 = 9,
	S700_MUX_UART1 = 10,
	S700_MUX_UART2 = 11,
	S700_MUX_UART3 = 12,
	S700_MUX_UART4 = 13,
	S700_MUX_UART5 = 14,
	S700_MUX_UART6 = 15,
	S700_MUX_I2S0 = 16,
	S700_MUX_I2S1 = 17,
	S700_MUX_PCM1 = 18,
	S700_MUX_PCM0 = 19,
	S700_MUX_KS = 20,
	S700_MUX_JTAG = 21,
	S700_MUX_PWM0 = 22,
	S700_MUX_PWM1 = 23,
	S700_MUX_PWM2 = 24,
	S700_MUX_PWM3 = 25,
	S700_MUX_PWM4 = 26,
	S700_MUX_PWM5 = 27,
	S700_MUX_P0 = 28,
	S700_MUX_SD0 = 29,
	S700_MUX_SD1 = 30,
	S700_MUX_SD2 = 31,
	S700_MUX_I2C0 = 32,
	S700_MUX_I2C1 = 33,
	S700_MUX_I2C2 = 34,
	S700_MUX_I2C3 = 35,
	S700_MUX_DSI = 36,
	S700_MUX_LVDS = 37,
	S700_MUX_USB30 = 38,
	S700_MUX_CLKO_25M = 39,
	S700_MUX_MIPI_CSI = 40,
	S700_MUX_NAND = 41,
	S700_MUX_SPDIF = 42,
	S700_MUX_SIRQ0 = 43,
	S700_MUX_SIRQ1 = 44,
	S700_MUX_SIRQ2 = 45,
	S700_MUX_BT = 46,
	S700_MUX_LCD0 = 47,
	S700_MUX_RESERVED = 48,
};

enum s700_pinconf_pull {
	OWL_PINCONF_PULL_DOWN = 0,
	OWL_PINCONF_PULL_UP = 1,
};

enum s900_pinmux_functions {
	S900_MUX_ERAM = 0,
	S900_MUX_ETH_RMII = 1,
	S900_MUX_ETH_SMII = 2,
	S900_MUX_SPI0 = 3,
	S900_MUX_SPI1 = 4,
	S900_MUX_SPI2 = 5,
	S900_MUX_SPI3 = 6,
	S900_MUX_SENS0 = 7,
	S900_MUX_UART0 = 8,
	S900_MUX_UART1 = 9,
	S900_MUX_UART2 = 10,
	S900_MUX_UART3 = 11,
	S900_MUX_UART4 = 12,
	S900_MUX_UART5 = 13,
	S900_MUX_UART6 = 14,
	S900_MUX_I2S0 = 15,
	S900_MUX_I2S1 = 16,
	S900_MUX_PCM0 = 17,
	S900_MUX_PCM1 = 18,
	S900_MUX_JTAG = 19,
	S900_MUX_PWM0 = 20,
	S900_MUX_PWM1 = 21,
	S900_MUX_PWM2 = 22,
	S900_MUX_PWM3 = 23,
	S900_MUX_PWM4 = 24,
	S900_MUX_PWM5 = 25,
	S900_MUX_SD0 = 26,
	S900_MUX_SD1 = 27,
	S900_MUX_SD2 = 28,
	S900_MUX_SD3 = 29,
	S900_MUX_I2C0 = 30,
	S900_MUX_I2C1 = 31,
	S900_MUX_I2C2 = 32,
	S900_MUX_I2C3 = 33,
	S900_MUX_I2C4 = 34,
	S900_MUX_I2C5 = 35,
	S900_MUX_LVDS = 36,
	S900_MUX_USB20 = 37,
	S900_MUX_USB30 = 38,
	S900_MUX_GPU = 39,
	S900_MUX_MIPI_CSI0 = 40,
	S900_MUX_MIPI_CSI1 = 41,
	S900_MUX_MIPI_DSI = 42,
	S900_MUX_NAND0 = 43,
	S900_MUX_NAND1 = 44,
	S900_MUX_SPDIF = 45,
	S900_MUX_SIRQ0 = 46,
	S900_MUX_SIRQ1 = 47,
	S900_MUX_SIRQ2 = 48,
	S900_MUX_AUX_START = 49,
	S900_MUX_MAX = 50,
	S900_MUX_RESERVED = 51,
};

enum s900_pinconf_pull {
	OWL_PINCONF_PULL_HIZ = 0,
	OWL_PINCONF_PULL_DOWN___2 = 1,
	OWL_PINCONF_PULL_UP___2 = 2,
	OWL_PINCONF_PULL_HOLD = 3,
};

struct bcm2835_pinctrl {
	struct device *dev;
	void *base;
	int *wake_irq;
	long unsigned int enabled_irq_map[2];
	unsigned int irq_type[58];
	struct pinctrl_dev *pctl_dev;
	struct gpio_chip gpio_chip;
	struct pinctrl_desc pctl_desc;
	struct pinctrl_gpio_range gpio_range;
	raw_spinlock_t irq_lock[2];
};

enum bcm2835_fsel {
	BCM2835_FSEL_COUNT = 8,
	BCM2835_FSEL_MASK = 7,
};

struct bcm_plat_data {
	const struct gpio_chip *gpio_chip;
	const struct pinctrl_desc *pctl_desc;
	const struct pinctrl_gpio_range *gpio_range;
};

enum iproc_pinconf_param {
	IPROC_PINCONF_DRIVE_STRENGTH = 0,
	IPROC_PINCONF_BIAS_DISABLE = 1,
	IPROC_PINCONF_BIAS_PULL_UP = 2,
	IPROC_PINCONF_BIAS_PULL_DOWN = 3,
	IPROC_PINCON_MAX = 4,
};

enum iproc_pinconf_ctrl_type {
	IOCTRL_TYPE_AON = 1,
	IOCTRL_TYPE_CDRU = 2,
	IOCTRL_TYPE_INVALID = 3,
};

struct iproc_gpio {
	struct device *dev;
	void *base;
	void *io_ctrl;
	enum iproc_pinconf_ctrl_type io_ctrl_type;
	raw_spinlock_t lock;
	struct irq_chip irqchip;
	struct gpio_chip gc;
	unsigned int num_banks;
	bool pinmux_is_supported;
	enum pin_config_param *pinconf_disable;
	unsigned int nr_pinconf_disable;
	struct pinctrl_dev *pctl;
	struct pinctrl_desc pctldesc;
};

struct ns2_mux {
	unsigned int base;
	unsigned int offset;
	unsigned int shift;
	unsigned int mask;
	unsigned int alt;
};

struct ns2_mux_log {
	struct ns2_mux mux;
	bool is_configured;
};

struct ns2_pin_group {
	const char *name;
	const unsigned int *pins;
	const unsigned int num_pins;
	const struct ns2_mux mux;
};

struct ns2_pin_function {
	const char *name;
	const char * const *groups;
	const unsigned int num_groups;
};

struct ns2_pinctrl {
	struct pinctrl_dev *pctl;
	struct device *dev;
	void *base0;
	void *base1;
	void *pinconf_base;
	const struct ns2_pin_group *groups;
	unsigned int num_groups;
	const struct ns2_pin_function *functions;
	unsigned int num_functions;
	struct ns2_mux_log *mux_log;
	spinlock_t lock;
};

struct ns2_pinconf {
	unsigned int base;
	unsigned int offset;
	unsigned int src_shift;
	unsigned int input_en;
	unsigned int pull_shift;
	unsigned int drive_shift;
};

struct ns2_pin {
	unsigned int pin;
	char *name;
	struct ns2_pinconf pin_conf;
};

struct berlin_desc_function {
	const char *name;
	u8 muxval;
};

struct berlin_desc_group {
	const char *name;
	u8 offset;
	u8 bit_width;
	u8 lsb;
	struct berlin_desc_function *functions;
};

struct berlin_pinctrl_desc {
	const struct berlin_desc_group *groups;
	unsigned int ngroups;
};

struct berlin_pinctrl_function {
	const char *name;
	const char **groups;
	unsigned int ngroups;
};

struct berlin_pinctrl {
	struct regmap *regmap;
	struct device *dev;
	const struct berlin_pinctrl_desc *desc;
	struct berlin_pinctrl_function *functions;
	unsigned int nfunctions;
	struct pinctrl_dev *pctrl_dev;
};

struct imx_pin_mmio {
	unsigned int mux_mode;
	u16 input_reg;
	unsigned int input_val;
	long unsigned int config;
};

struct imx_pin_scu {
	unsigned int mux_mode;
	long unsigned int config;
};

struct imx_pin {
	unsigned int pin;
	union {
		struct imx_pin_mmio mmio;
		struct imx_pin_scu scu;
	} conf;
};

struct imx_pin_reg {
	s16 mux_reg;
	s16 conf_reg;
};

struct imx_cfg_params_decode {
	enum pin_config_param param;
	u32 mask;
	u8 shift;
	bool invert;
};

struct imx_pinctrl_soc_info;

struct imx_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctl;
	void *base;
	void *input_sel_base;
	const struct imx_pinctrl_soc_info *info;
	struct imx_pin_reg *pin_regs;
	unsigned int group_index;
	struct mutex mutex;
};

struct imx_pinctrl_soc_info {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	unsigned int flags;
	const char *gpr_compatible;
	unsigned int mux_mask;
	u8 mux_shift;
	bool generic_pinconf;
	const struct pinconf_generic_params *custom_params;
	unsigned int num_custom_params;
	const struct imx_cfg_params_decode *decodes;
	unsigned int num_decodes;
	void (*fixup)(long unsigned int *, unsigned int, u32 *);
	int (*gpio_set_direction)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int, bool);
	int (*imx_pinconf_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*imx_pinconf_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	void (*imx_pinctrl_parse_pin)(struct imx_pinctrl *, unsigned int *, struct imx_pin *, const __be32 **);
};

enum imx_sc_rpc_svc {
	IMX_SC_RPC_SVC_UNKNOWN = 0,
	IMX_SC_RPC_SVC_RETURN = 1,
	IMX_SC_RPC_SVC_PM = 2,
	IMX_SC_RPC_SVC_RM = 3,
	IMX_SC_RPC_SVC_TIMER = 5,
	IMX_SC_RPC_SVC_PAD = 6,
	IMX_SC_RPC_SVC_MISC = 7,
	IMX_SC_RPC_SVC_IRQ = 8,
};

struct imx_sc_rpc_msg {
	uint8_t ver;
	uint8_t size;
	uint8_t svc;
	uint8_t func;
};

enum pad_func_e {
	IMX_SC_PAD_FUNC_SET = 15,
	IMX_SC_PAD_FUNC_GET = 16,
};

struct imx_sc_msg_req_pad_set {
	struct imx_sc_rpc_msg hdr;
	u32 val;
	u16 pad;
};

struct imx_sc_msg_req_pad_get {
	struct imx_sc_rpc_msg hdr;
	u16 pad;
	short: 16;
};

struct imx_sc_msg_resp_pad_get {
	struct imx_sc_rpc_msg hdr;
	u32 val;
};

struct imx_sc_ipc;

enum imx8mm_pads {
	MX8MM_PAD_RESERVE0 = 0,
	MX8MM_PAD_RESERVE1 = 1,
	MX8MM_PAD_RESERVE2 = 2,
	MX8MM_PAD_RESERVE3 = 3,
	MX8MM_PAD_RESERVE4 = 4,
	MX8MM_PAD_RESERVE5 = 5,
	MX8MM_PAD_RESERVE6 = 6,
	MX8MM_PAD_RESERVE7 = 7,
	MX8MM_PAD_RESERVE8 = 8,
	MX8MM_PAD_RESERVE9 = 9,
	MX8MM_IOMUXC_GPIO1_IO00 = 10,
	MX8MM_IOMUXC_GPIO1_IO01 = 11,
	MX8MM_IOMUXC_GPIO1_IO02 = 12,
	MX8MM_IOMUXC_GPIO1_IO03 = 13,
	MX8MM_IOMUXC_GPIO1_IO04 = 14,
	MX8MM_IOMUXC_GPIO1_IO05 = 15,
	MX8MM_IOMUXC_GPIO1_IO06 = 16,
	MX8MM_IOMUXC_GPIO1_IO07 = 17,
	MX8MM_IOMUXC_GPIO1_IO08 = 18,
	MX8MM_IOMUXC_GPIO1_IO09 = 19,
	MX8MM_IOMUXC_GPIO1_IO10 = 20,
	MX8MM_IOMUXC_GPIO1_IO11 = 21,
	MX8MM_IOMUXC_GPIO1_IO12 = 22,
	MX8MM_IOMUXC_GPIO1_IO13 = 23,
	MX8MM_IOMUXC_GPIO1_IO14 = 24,
	MX8MM_IOMUXC_GPIO1_IO15 = 25,
	MX8MM_IOMUXC_ENET_MDC = 26,
	MX8MM_IOMUXC_ENET_MDIO = 27,
	MX8MM_IOMUXC_ENET_TD3 = 28,
	MX8MM_IOMUXC_ENET_TD2 = 29,
	MX8MM_IOMUXC_ENET_TD1 = 30,
	MX8MM_IOMUXC_ENET_TD0 = 31,
	MX8MM_IOMUXC_ENET_TX_CTL = 32,
	MX8MM_IOMUXC_ENET_TXC = 33,
	MX8MM_IOMUXC_ENET_RX_CTL = 34,
	MX8MM_IOMUXC_ENET_RXC = 35,
	MX8MM_IOMUXC_ENET_RD0 = 36,
	MX8MM_IOMUXC_ENET_RD1 = 37,
	MX8MM_IOMUXC_ENET_RD2 = 38,
	MX8MM_IOMUXC_ENET_RD3 = 39,
	MX8MM_IOMUXC_SD1_CLK = 40,
	MX8MM_IOMUXC_SD1_CMD = 41,
	MX8MM_IOMUXC_SD1_DATA0 = 42,
	MX8MM_IOMUXC_SD1_DATA1 = 43,
	MX8MM_IOMUXC_SD1_DATA2 = 44,
	MX8MM_IOMUXC_SD1_DATA3 = 45,
	MX8MM_IOMUXC_SD1_DATA4 = 46,
	MX8MM_IOMUXC_SD1_DATA5 = 47,
	MX8MM_IOMUXC_SD1_DATA6 = 48,
	MX8MM_IOMUXC_SD1_DATA7 = 49,
	MX8MM_IOMUXC_SD1_RESET_B = 50,
	MX8MM_IOMUXC_SD1_STROBE = 51,
	MX8MM_IOMUXC_SD2_CD_B = 52,
	MX8MM_IOMUXC_SD2_CLK = 53,
	MX8MM_IOMUXC_SD2_CMD = 54,
	MX8MM_IOMUXC_SD2_DATA0 = 55,
	MX8MM_IOMUXC_SD2_DATA1 = 56,
	MX8MM_IOMUXC_SD2_DATA2 = 57,
	MX8MM_IOMUXC_SD2_DATA3 = 58,
	MX8MM_IOMUXC_SD2_RESET_B = 59,
	MX8MM_IOMUXC_SD2_WP = 60,
	MX8MM_IOMUXC_NAND_ALE = 61,
	MX8MM_IOMUXC_NAND_CE0 = 62,
	MX8MM_IOMUXC_NAND_CE1 = 63,
	MX8MM_IOMUXC_NAND_CE2 = 64,
	MX8MM_IOMUXC_NAND_CE3 = 65,
	MX8MM_IOMUXC_NAND_CLE = 66,
	MX8MM_IOMUXC_NAND_DATA00 = 67,
	MX8MM_IOMUXC_NAND_DATA01 = 68,
	MX8MM_IOMUXC_NAND_DATA02 = 69,
	MX8MM_IOMUXC_NAND_DATA03 = 70,
	MX8MM_IOMUXC_NAND_DATA04 = 71,
	MX8MM_IOMUXC_NAND_DATA05 = 72,
	MX8MM_IOMUXC_NAND_DATA06 = 73,
	MX8MM_IOMUXC_NAND_DATA07 = 74,
	MX8MM_IOMUXC_NAND_DQS = 75,
	MX8MM_IOMUXC_NAND_RE_B = 76,
	MX8MM_IOMUXC_NAND_READY_B = 77,
	MX8MM_IOMUXC_NAND_WE_B = 78,
	MX8MM_IOMUXC_NAND_WP_B = 79,
	MX8MM_IOMUXC_SAI5_RXFS = 80,
	MX8MM_IOMUXC_SAI5_RXC = 81,
	MX8MM_IOMUXC_SAI5_RXD0 = 82,
	MX8MM_IOMUXC_SAI5_RXD1 = 83,
	MX8MM_IOMUXC_SAI5_RXD2 = 84,
	MX8MM_IOMUXC_SAI5_RXD3 = 85,
	MX8MM_IOMUXC_SAI5_MCLK = 86,
	MX8MM_IOMUXC_SAI1_RXFS = 87,
	MX8MM_IOMUXC_SAI1_RXC = 88,
	MX8MM_IOMUXC_SAI1_RXD0 = 89,
	MX8MM_IOMUXC_SAI1_RXD1 = 90,
	MX8MM_IOMUXC_SAI1_RXD2 = 91,
	MX8MM_IOMUXC_SAI1_RXD3 = 92,
	MX8MM_IOMUXC_SAI1_RXD4 = 93,
	MX8MM_IOMUXC_SAI1_RXD5 = 94,
	MX8MM_IOMUXC_SAI1_RXD6 = 95,
	MX8MM_IOMUXC_SAI1_RXD7 = 96,
	MX8MM_IOMUXC_SAI1_TXFS = 97,
	MX8MM_IOMUXC_SAI1_TXC = 98,
	MX8MM_IOMUXC_SAI1_TXD0 = 99,
	MX8MM_IOMUXC_SAI1_TXD1 = 100,
	MX8MM_IOMUXC_SAI1_TXD2 = 101,
	MX8MM_IOMUXC_SAI1_TXD3 = 102,
	MX8MM_IOMUXC_SAI1_TXD4 = 103,
	MX8MM_IOMUXC_SAI1_TXD5 = 104,
	MX8MM_IOMUXC_SAI1_TXD6 = 105,
	MX8MM_IOMUXC_SAI1_TXD7 = 106,
	MX8MM_IOMUXC_SAI1_MCLK = 107,
	MX8MM_IOMUXC_SAI2_RXFS = 108,
	MX8MM_IOMUXC_SAI2_RXC = 109,
	MX8MM_IOMUXC_SAI2_RXD0 = 110,
	MX8MM_IOMUXC_SAI2_TXFS = 111,
	MX8MM_IOMUXC_SAI2_TXC = 112,
	MX8MM_IOMUXC_SAI2_TXD0 = 113,
	MX8MM_IOMUXC_SAI2_MCLK = 114,
	MX8MM_IOMUXC_SAI3_RXFS = 115,
	MX8MM_IOMUXC_SAI3_RXC = 116,
	MX8MM_IOMUXC_SAI3_RXD = 117,
	MX8MM_IOMUXC_SAI3_TXFS = 118,
	MX8MM_IOMUXC_SAI3_TXC = 119,
	MX8MM_IOMUXC_SAI3_TXD = 120,
	MX8MM_IOMUXC_SAI3_MCLK = 121,
	MX8MM_IOMUXC_SPDIF_TX = 122,
	MX8MM_IOMUXC_SPDIF_RX = 123,
	MX8MM_IOMUXC_SPDIF_EXT_CLK = 124,
	MX8MM_IOMUXC_ECSPI1_SCLK = 125,
	MX8MM_IOMUXC_ECSPI1_MOSI = 126,
	MX8MM_IOMUXC_ECSPI1_MISO = 127,
	MX8MM_IOMUXC_ECSPI1_SS0 = 128,
	MX8MM_IOMUXC_ECSPI2_SCLK = 129,
	MX8MM_IOMUXC_ECSPI2_MOSI = 130,
	MX8MM_IOMUXC_ECSPI2_MISO = 131,
	MX8MM_IOMUXC_ECSPI2_SS0 = 132,
	MX8MM_IOMUXC_I2C1_SCL = 133,
	MX8MM_IOMUXC_I2C1_SDA = 134,
	MX8MM_IOMUXC_I2C2_SCL = 135,
	MX8MM_IOMUXC_I2C2_SDA = 136,
	MX8MM_IOMUXC_I2C3_SCL = 137,
	MX8MM_IOMUXC_I2C3_SDA = 138,
	MX8MM_IOMUXC_I2C4_SCL = 139,
	MX8MM_IOMUXC_I2C4_SDA = 140,
	MX8MM_IOMUXC_UART1_RXD = 141,
	MX8MM_IOMUXC_UART1_TXD = 142,
	MX8MM_IOMUXC_UART2_RXD = 143,
	MX8MM_IOMUXC_UART2_TXD = 144,
	MX8MM_IOMUXC_UART3_RXD = 145,
	MX8MM_IOMUXC_UART3_TXD = 146,
	MX8MM_IOMUXC_UART4_RXD = 147,
	MX8MM_IOMUXC_UART4_TXD = 148,
};

enum imx8mn_pads {
	MX8MN_PAD_RESERVE0 = 0,
	MX8MN_PAD_RESERVE1 = 1,
	MX8MN_PAD_RESERVE2 = 2,
	MX8MN_PAD_RESERVE3 = 3,
	MX8MN_PAD_RESERVE4 = 4,
	MX8MN_PAD_RESERVE5 = 5,
	MX8MN_PAD_RESERVE6 = 6,
	MX8MN_PAD_RESERVE7 = 7,
	MX8MN_IOMUXC_BOOT_MODE2 = 8,
	MX8MN_IOMUXC_BOOT_MODE3 = 9,
	MX8MN_IOMUXC_GPIO1_IO00 = 10,
	MX8MN_IOMUXC_GPIO1_IO01 = 11,
	MX8MN_IOMUXC_GPIO1_IO02 = 12,
	MX8MN_IOMUXC_GPIO1_IO03 = 13,
	MX8MN_IOMUXC_GPIO1_IO04 = 14,
	MX8MN_IOMUXC_GPIO1_IO05 = 15,
	MX8MN_IOMUXC_GPIO1_IO06 = 16,
	MX8MN_IOMUXC_GPIO1_IO07 = 17,
	MX8MN_IOMUXC_GPIO1_IO08 = 18,
	MX8MN_IOMUXC_GPIO1_IO09 = 19,
	MX8MN_IOMUXC_GPIO1_IO10 = 20,
	MX8MN_IOMUXC_GPIO1_IO11 = 21,
	MX8MN_IOMUXC_GPIO1_IO12 = 22,
	MX8MN_IOMUXC_GPIO1_IO13 = 23,
	MX8MN_IOMUXC_GPIO1_IO14 = 24,
	MX8MN_IOMUXC_GPIO1_IO15 = 25,
	MX8MN_IOMUXC_ENET_MDC = 26,
	MX8MN_IOMUXC_ENET_MDIO = 27,
	MX8MN_IOMUXC_ENET_TD3 = 28,
	MX8MN_IOMUXC_ENET_TD2 = 29,
	MX8MN_IOMUXC_ENET_TD1 = 30,
	MX8MN_IOMUXC_ENET_TD0 = 31,
	MX8MN_IOMUXC_ENET_TX_CTL = 32,
	MX8MN_IOMUXC_ENET_TXC = 33,
	MX8MN_IOMUXC_ENET_RX_CTL = 34,
	MX8MN_IOMUXC_ENET_RXC = 35,
	MX8MN_IOMUXC_ENET_RD0 = 36,
	MX8MN_IOMUXC_ENET_RD1 = 37,
	MX8MN_IOMUXC_ENET_RD2 = 38,
	MX8MN_IOMUXC_ENET_RD3 = 39,
	MX8MN_IOMUXC_SD1_CLK = 40,
	MX8MN_IOMUXC_SD1_CMD = 41,
	MX8MN_IOMUXC_SD1_DATA0 = 42,
	MX8MN_IOMUXC_SD1_DATA1 = 43,
	MX8MN_IOMUXC_SD1_DATA2 = 44,
	MX8MN_IOMUXC_SD1_DATA3 = 45,
	MX8MN_IOMUXC_SD1_DATA4 = 46,
	MX8MN_IOMUXC_SD1_DATA5 = 47,
	MX8MN_IOMUXC_SD1_DATA6 = 48,
	MX8MN_IOMUXC_SD1_DATA7 = 49,
	MX8MN_IOMUXC_SD1_RESET_B = 50,
	MX8MN_IOMUXC_SD1_STROBE = 51,
	MX8MN_IOMUXC_SD2_CD_B = 52,
	MX8MN_IOMUXC_SD2_CLK = 53,
	MX8MN_IOMUXC_SD2_CMD = 54,
	MX8MN_IOMUXC_SD2_DATA0 = 55,
	MX8MN_IOMUXC_SD2_DATA1 = 56,
	MX8MN_IOMUXC_SD2_DATA2 = 57,
	MX8MN_IOMUXC_SD2_DATA3 = 58,
	MX8MN_IOMUXC_SD2_RESET_B = 59,
	MX8MN_IOMUXC_SD2_WP = 60,
	MX8MN_IOMUXC_NAND_ALE = 61,
	MX8MN_IOMUXC_NAND_CE0 = 62,
	MX8MN_IOMUXC_NAND_CE1 = 63,
	MX8MN_IOMUXC_NAND_CE2 = 64,
	MX8MN_IOMUXC_NAND_CE3 = 65,
	MX8MN_IOMUXC_NAND_CLE = 66,
	MX8MN_IOMUXC_NAND_DATA00 = 67,
	MX8MN_IOMUXC_NAND_DATA01 = 68,
	MX8MN_IOMUXC_NAND_DATA02 = 69,
	MX8MN_IOMUXC_NAND_DATA03 = 70,
	MX8MN_IOMUXC_NAND_DATA04 = 71,
	MX8MN_IOMUXC_NAND_DATA05 = 72,
	MX8MN_IOMUXC_NAND_DATA06 = 73,
	MX8MN_IOMUXC_NAND_DATA07 = 74,
	MX8MN_IOMUXC_NAND_DQS = 75,
	MX8MN_IOMUXC_NAND_RE_B = 76,
	MX8MN_IOMUXC_NAND_READY_B = 77,
	MX8MN_IOMUXC_NAND_WE_B = 78,
	MX8MN_IOMUXC_NAND_WP_B = 79,
	MX8MN_IOMUXC_SAI5_RXFS = 80,
	MX8MN_IOMUXC_SAI5_RXC = 81,
	MX8MN_IOMUXC_SAI5_RXD0 = 82,
	MX8MN_IOMUXC_SAI5_RXD1 = 83,
	MX8MN_IOMUXC_SAI5_RXD2 = 84,
	MX8MN_IOMUXC_SAI5_RXD3 = 85,
	MX8MN_IOMUXC_SAI5_MCLK = 86,
	MX8MN_IOMUXC_SAI1_RXFS = 87,
	MX8MN_IOMUXC_SAI1_RXC = 88,
	MX8MN_IOMUXC_SAI1_RXD0 = 89,
	MX8MN_IOMUXC_SAI1_RXD1 = 90,
	MX8MN_IOMUXC_SAI1_RXD2 = 91,
	MX8MN_IOMUXC_SAI1_RXD3 = 92,
	MX8MN_IOMUXC_SAI1_RXD4 = 93,
	MX8MN_IOMUXC_SAI1_RXD5 = 94,
	MX8MN_IOMUXC_SAI1_RXD6 = 95,
	MX8MN_IOMUXC_SAI1_RXD7 = 96,
	MX8MN_IOMUXC_SAI1_TXFS = 97,
	MX8MN_IOMUXC_SAI1_TXC = 98,
	MX8MN_IOMUXC_SAI1_TXD0 = 99,
	MX8MN_IOMUXC_SAI1_TXD1 = 100,
	MX8MN_IOMUXC_SAI1_TXD2 = 101,
	MX8MN_IOMUXC_SAI1_TXD3 = 102,
	MX8MN_IOMUXC_SAI1_TXD4 = 103,
	MX8MN_IOMUXC_SAI1_TXD5 = 104,
	MX8MN_IOMUXC_SAI1_TXD6 = 105,
	MX8MN_IOMUXC_SAI1_TXD7 = 106,
	MX8MN_IOMUXC_SAI1_MCLK = 107,
	MX8MN_IOMUXC_SAI2_RXFS = 108,
	MX8MN_IOMUXC_SAI2_RXC = 109,
	MX8MN_IOMUXC_SAI2_RXD0 = 110,
	MX8MN_IOMUXC_SAI2_TXFS = 111,
	MX8MN_IOMUXC_SAI2_TXC = 112,
	MX8MN_IOMUXC_SAI2_TXD0 = 113,
	MX8MN_IOMUXC_SAI2_MCLK = 114,
	MX8MN_IOMUXC_SAI3_RXFS = 115,
	MX8MN_IOMUXC_SAI3_RXC = 116,
	MX8MN_IOMUXC_SAI3_RXD = 117,
	MX8MN_IOMUXC_SAI3_TXFS = 118,
	MX8MN_IOMUXC_SAI3_TXC = 119,
	MX8MN_IOMUXC_SAI3_TXD = 120,
	MX8MN_IOMUXC_SAI3_MCLK = 121,
	MX8MN_IOMUXC_SPDIF_TX = 122,
	MX8MN_IOMUXC_SPDIF_RX = 123,
	MX8MN_IOMUXC_SPDIF_EXT_CLK = 124,
	MX8MN_IOMUXC_ECSPI1_SCLK = 125,
	MX8MN_IOMUXC_ECSPI1_MOSI = 126,
	MX8MN_IOMUXC_ECSPI1_MISO = 127,
	MX8MN_IOMUXC_ECSPI1_SS0 = 128,
	MX8MN_IOMUXC_ECSPI2_SCLK = 129,
	MX8MN_IOMUXC_ECSPI2_MOSI = 130,
	MX8MN_IOMUXC_ECSPI2_MISO = 131,
	MX8MN_IOMUXC_ECSPI2_SS0 = 132,
	MX8MN_IOMUXC_I2C1_SCL = 133,
	MX8MN_IOMUXC_I2C1_SDA = 134,
	MX8MN_IOMUXC_I2C2_SCL = 135,
	MX8MN_IOMUXC_I2C2_SDA = 136,
	MX8MN_IOMUXC_I2C3_SCL = 137,
	MX8MN_IOMUXC_I2C3_SDA = 138,
	MX8MN_IOMUXC_I2C4_SCL = 139,
	MX8MN_IOMUXC_I2C4_SDA = 140,
	MX8MN_IOMUXC_UART1_RXD = 141,
	MX8MN_IOMUXC_UART1_TXD = 142,
	MX8MN_IOMUXC_UART2_RXD = 143,
	MX8MN_IOMUXC_UART2_TXD = 144,
	MX8MN_IOMUXC_UART3_RXD = 145,
	MX8MN_IOMUXC_UART3_TXD = 146,
	MX8MN_IOMUXC_UART4_RXD = 147,
	MX8MN_IOMUXC_UART4_TXD = 148,
};

enum imx8mp_pads {
	MX8MP_IOMUXC_RESERVE0 = 0,
	MX8MP_IOMUXC_RESERVE1 = 1,
	MX8MP_IOMUXC_RESERVE2 = 2,
	MX8MP_IOMUXC_RESERVE3 = 3,
	MX8MP_IOMUXC_RESERVE4 = 4,
	MX8MP_IOMUXC_GPIO1_IO00 = 5,
	MX8MP_IOMUXC_GPIO1_IO01 = 6,
	MX8MP_IOMUXC_GPIO1_IO02 = 7,
	MX8MP_IOMUXC_GPIO1_IO03 = 8,
	MX8MP_IOMUXC_GPIO1_IO04 = 9,
	MX8MP_IOMUXC_GPIO1_IO05 = 10,
	MX8MP_IOMUXC_GPIO1_IO06 = 11,
	MX8MP_IOMUXC_GPIO1_IO07 = 12,
	MX8MP_IOMUXC_GPIO1_IO08 = 13,
	MX8MP_IOMUXC_GPIO1_IO09 = 14,
	MX8MP_IOMUXC_GPIO1_IO10 = 15,
	MX8MP_IOMUXC_GPIO1_IO11 = 16,
	MX8MP_IOMUXC_GPIO1_IO12 = 17,
	MX8MP_IOMUXC_GPIO1_IO13 = 18,
	MX8MP_IOMUXC_GPIO1_IO14 = 19,
	MX8MP_IOMUXC_GPIO1_IO15 = 20,
	MX8MP_IOMUXC_ENET_MDC = 21,
	MX8MP_IOMUXC_ENET_MDIO = 22,
	MX8MP_IOMUXC_ENET_TD3 = 23,
	MX8MP_IOMUXC_ENET_TD2 = 24,
	MX8MP_IOMUXC_ENET_TD1 = 25,
	MX8MP_IOMUXC_ENET_TD0 = 26,
	MX8MP_IOMUXC_ENET_TX_CTL = 27,
	MX8MP_IOMUXC_ENET_TXC = 28,
	MX8MP_IOMUXC_ENET_RX_CTL = 29,
	MX8MP_IOMUXC_ENET_RXC = 30,
	MX8MP_IOMUXC_ENET_RD0 = 31,
	MX8MP_IOMUXC_ENET_RD1 = 32,
	MX8MP_IOMUXC_ENET_RD2 = 33,
	MX8MP_IOMUXC_ENET_RD3 = 34,
	MX8MP_IOMUXC_SD1_CLK = 35,
	MX8MP_IOMUXC_SD1_CMD = 36,
	MX8MP_IOMUXC_SD1_DATA0 = 37,
	MX8MP_IOMUXC_SD1_DATA1 = 38,
	MX8MP_IOMUXC_SD1_DATA2 = 39,
	MX8MP_IOMUXC_SD1_DATA3 = 40,
	MX8MP_IOMUXC_SD1_DATA4 = 41,
	MX8MP_IOMUXC_SD1_DATA5 = 42,
	MX8MP_IOMUXC_SD1_DATA6 = 43,
	MX8MP_IOMUXC_SD1_DATA7 = 44,
	MX8MP_IOMUXC_SD1_RESET_B = 45,
	MX8MP_IOMUXC_SD1_STROBE = 46,
	MX8MP_IOMUXC_SD2_CD_B = 47,
	MX8MP_IOMUXC_SD2_CLK = 48,
	MX8MP_IOMUXC_SD2_CMD = 49,
	MX8MP_IOMUXC_SD2_DATA0 = 50,
	MX8MP_IOMUXC_SD2_DATA1 = 51,
	MX8MP_IOMUXC_SD2_DATA2 = 52,
	MX8MP_IOMUXC_SD2_DATA3 = 53,
	MX8MP_IOMUXC_SD2_RESET_B = 54,
	MX8MP_IOMUXC_SD2_WP = 55,
	MX8MP_IOMUXC_NAND_ALE = 56,
	MX8MP_IOMUXC_NAND_CE0_B = 57,
	MX8MP_IOMUXC_NAND_CE1_B = 58,
	MX8MP_IOMUXC_NAND_CE2_B = 59,
	MX8MP_IOMUXC_NAND_CE3_B = 60,
	MX8MP_IOMUXC_NAND_CLE = 61,
	MX8MP_IOMUXC_NAND_DATA00 = 62,
	MX8MP_IOMUXC_NAND_DATA01 = 63,
	MX8MP_IOMUXC_NAND_DATA02 = 64,
	MX8MP_IOMUXC_NAND_DATA03 = 65,
	MX8MP_IOMUXC_NAND_DATA04 = 66,
	MX8MP_IOMUXC_NAND_DATA05 = 67,
	MX8MP_IOMUXC_NAND_DATA06 = 68,
	MX8MP_IOMUXC_NAND_DATA07 = 69,
	MX8MP_IOMUXC_NAND_DQS = 70,
	MX8MP_IOMUXC_NAND_RE_B = 71,
	MX8MP_IOMUXC_NAND_READY_B = 72,
	MX8MP_IOMUXC_NAND_WE_B = 73,
	MX8MP_IOMUXC_NAND_WP_B = 74,
	MX8MP_IOMUXC_SAI5_RXFS = 75,
	MX8MP_IOMUXC_SAI5_RXC = 76,
	MX8MP_IOMUXC_SAI5_RXD0 = 77,
	MX8MP_IOMUXC_SAI5_RXD1 = 78,
	MX8MP_IOMUXC_SAI5_RXD2 = 79,
	MX8MP_IOMUXC_SAI5_RXD3 = 80,
	MX8MP_IOMUXC_SAI5_MCLK = 81,
	MX8MP_IOMUXC_SAI1_RXFS = 82,
	MX8MP_IOMUXC_SAI1_RXC = 83,
	MX8MP_IOMUXC_SAI1_RXD0 = 84,
	MX8MP_IOMUXC_SAI1_RXD1 = 85,
	MX8MP_IOMUXC_SAI1_RXD2 = 86,
	MX8MP_IOMUXC_SAI1_RXD3 = 87,
	MX8MP_IOMUXC_SAI1_RXD4 = 88,
	MX8MP_IOMUXC_SAI1_RXD5 = 89,
	MX8MP_IOMUXC_SAI1_RXD6 = 90,
	MX8MP_IOMUXC_SAI1_RXD7 = 91,
	MX8MP_IOMUXC_SAI1_TXFS = 92,
	MX8MP_IOMUXC_SAI1_TXC = 93,
	MX8MP_IOMUXC_SAI1_TXD0 = 94,
	MX8MP_IOMUXC_SAI1_TXD1 = 95,
	MX8MP_IOMUXC_SAI1_TXD2 = 96,
	MX8MP_IOMUXC_SAI1_TXD3 = 97,
	MX8MP_IOMUXC_SAI1_TXD4 = 98,
	MX8MP_IOMUXC_SAI1_TXD5 = 99,
	MX8MP_IOMUXC_SAI1_TXD6 = 100,
	MX8MP_IOMUXC_SAI1_TXD7 = 101,
	MX8MP_IOMUXC_SAI1_MCLK = 102,
	MX8MP_IOMUXC_SAI2_RXFS = 103,
	MX8MP_IOMUXC_SAI2_RXC = 104,
	MX8MP_IOMUXC_SAI2_RXD0 = 105,
	MX8MP_IOMUXC_SAI2_TXFS = 106,
	MX8MP_IOMUXC_SAI2_TXC = 107,
	MX8MP_IOMUXC_SAI2_TXD0 = 108,
	MX8MP_IOMUXC_SAI2_MCLK = 109,
	MX8MP_IOMUXC_SAI3_RXFS = 110,
	MX8MP_IOMUXC_SAI3_RXC = 111,
	MX8MP_IOMUXC_SAI3_RXD = 112,
	MX8MP_IOMUXC_SAI3_TXFS = 113,
	MX8MP_IOMUXC_SAI3_TXC = 114,
	MX8MP_IOMUXC_SAI3_TXD = 115,
	MX8MP_IOMUXC_SAI3_MCLK = 116,
	MX8MP_IOMUXC_SPDIF_TX = 117,
	MX8MP_IOMUXC_SPDIF_RX = 118,
	MX8MP_IOMUXC_SPDIF_EXT_CLK = 119,
	MX8MP_IOMUXC_ECSPI1_SCLK = 120,
	MX8MP_IOMUXC_ECSPI1_MOSI = 121,
	MX8MP_IOMUXC_ECSPI1_MISO = 122,
	MX8MP_IOMUXC_ECSPI1_SS0 = 123,
	MX8MP_IOMUXC_ECSPI2_SCLK = 124,
	MX8MP_IOMUXC_ECSPI2_MOSI = 125,
	MX8MP_IOMUXC_ECSPI2_MISO = 126,
	MX8MP_IOMUXC_ECSPI2_SS0 = 127,
	MX8MP_IOMUXC_I2C1_SCL = 128,
	MX8MP_IOMUXC_I2C1_SDA = 129,
	MX8MP_IOMUXC_I2C2_SCL = 130,
	MX8MP_IOMUXC_I2C2_SDA = 131,
	MX8MP_IOMUXC_I2C3_SCL = 132,
	MX8MP_IOMUXC_I2C3_SDA = 133,
	MX8MP_IOMUXC_I2C4_SCL = 134,
	MX8MP_IOMUXC_I2C4_SDA = 135,
	MX8MP_IOMUXC_UART1_RXD = 136,
	MX8MP_IOMUXC_UART1_TXD = 137,
	MX8MP_IOMUXC_UART2_RXD = 138,
	MX8MP_IOMUXC_UART2_TXD = 139,
	MX8MP_IOMUXC_UART3_RXD = 140,
	MX8MP_IOMUXC_UART3_TXD = 141,
	MX8MP_IOMUXC_UART4_RXD = 142,
	MX8MP_IOMUXC_UART4_TXD = 143,
	MX8MP_IOMUXC_HDMI_DDC_SCL = 144,
	MX8MP_IOMUXC_HDMI_DDC_SDA = 145,
	MX8MP_IOMUXC_HDMI_CEC = 146,
	MX8MP_IOMUXC_HDMI_HPD = 147,
};

enum imx8mq_pads {
	MX8MQ_PAD_RESERVE0 = 0,
	MX8MQ_PAD_RESERVE1 = 1,
	MX8MQ_PAD_RESERVE2 = 2,
	MX8MQ_PAD_RESERVE3 = 3,
	MX8MQ_PAD_RESERVE4 = 4,
	MX8MQ_IOMUXC_PMIC_STBY_REQ_CCMSRCGPCMIX = 5,
	MX8MQ_IOMUXC_PMIC_ON_REQ_SNVSMIX = 6,
	MX8MQ_IOMUXC_ONOFF_SNVSMIX = 7,
	MX8MQ_IOMUXC_POR_B_SNVSMIX = 8,
	MX8MQ_IOMUXC_RTC_RESET_B_SNVSMIX = 9,
	MX8MQ_IOMUXC_GPIO1_IO00 = 10,
	MX8MQ_IOMUXC_GPIO1_IO01 = 11,
	MX8MQ_IOMUXC_GPIO1_IO02 = 12,
	MX8MQ_IOMUXC_GPIO1_IO03 = 13,
	MX8MQ_IOMUXC_GPIO1_IO04 = 14,
	MX8MQ_IOMUXC_GPIO1_IO05 = 15,
	MX8MQ_IOMUXC_GPIO1_IO06 = 16,
	MX8MQ_IOMUXC_GPIO1_IO07 = 17,
	MX8MQ_IOMUXC_GPIO1_IO08 = 18,
	MX8MQ_IOMUXC_GPIO1_IO09 = 19,
	MX8MQ_IOMUXC_GPIO1_IO10 = 20,
	MX8MQ_IOMUXC_GPIO1_IO11 = 21,
	MX8MQ_IOMUXC_GPIO1_IO12 = 22,
	MX8MQ_IOMUXC_GPIO1_IO13 = 23,
	MX8MQ_IOMUXC_GPIO1_IO14 = 24,
	MX8MQ_IOMUXC_GPIO1_IO15 = 25,
	MX8MQ_IOMUXC_ENET_MDC = 26,
	MX8MQ_IOMUXC_ENET_MDIO = 27,
	MX8MQ_IOMUXC_ENET_TD3 = 28,
	MX8MQ_IOMUXC_ENET_TD2 = 29,
	MX8MQ_IOMUXC_ENET_TD1 = 30,
	MX8MQ_IOMUXC_ENET_TD0 = 31,
	MX8MQ_IOMUXC_ENET_TX_CTL = 32,
	MX8MQ_IOMUXC_ENET_TXC = 33,
	MX8MQ_IOMUXC_ENET_RX_CTL = 34,
	MX8MQ_IOMUXC_ENET_RXC = 35,
	MX8MQ_IOMUXC_ENET_RD0 = 36,
	MX8MQ_IOMUXC_ENET_RD1 = 37,
	MX8MQ_IOMUXC_ENET_RD2 = 38,
	MX8MQ_IOMUXC_ENET_RD3 = 39,
	MX8MQ_IOMUXC_SD1_CLK = 40,
	MX8MQ_IOMUXC_SD1_CMD = 41,
	MX8MQ_IOMUXC_SD1_DATA0 = 42,
	MX8MQ_IOMUXC_SD1_DATA1 = 43,
	MX8MQ_IOMUXC_SD1_DATA2 = 44,
	MX8MQ_IOMUXC_SD1_DATA3 = 45,
	MX8MQ_IOMUXC_SD1_DATA4 = 46,
	MX8MQ_IOMUXC_SD1_DATA5 = 47,
	MX8MQ_IOMUXC_SD1_DATA6 = 48,
	MX8MQ_IOMUXC_SD1_DATA7 = 49,
	MX8MQ_IOMUXC_SD1_RESET_B = 50,
	MX8MQ_IOMUXC_SD1_STROBE = 51,
	MX8MQ_IOMUXC_SD2_CD_B = 52,
	MX8MQ_IOMUXC_SD2_CLK = 53,
	MX8MQ_IOMUXC_SD2_CMD = 54,
	MX8MQ_IOMUXC_SD2_DATA0 = 55,
	MX8MQ_IOMUXC_SD2_DATA1 = 56,
	MX8MQ_IOMUXC_SD2_DATA2 = 57,
	MX8MQ_IOMUXC_SD2_DATA3 = 58,
	MX8MQ_IOMUXC_SD2_RESET_B = 59,
	MX8MQ_IOMUXC_SD2_WP = 60,
	MX8MQ_IOMUXC_NAND_ALE = 61,
	MX8MQ_IOMUXC_NAND_CE0_B = 62,
	MX8MQ_IOMUXC_NAND_CE1_B = 63,
	MX8MQ_IOMUXC_NAND_CE2_B = 64,
	MX8MQ_IOMUXC_NAND_CE3_B = 65,
	MX8MQ_IOMUXC_NAND_CLE = 66,
	MX8MQ_IOMUXC_NAND_DATA00 = 67,
	MX8MQ_IOMUXC_NAND_DATA01 = 68,
	MX8MQ_IOMUXC_NAND_DATA02 = 69,
	MX8MQ_IOMUXC_NAND_DATA03 = 70,
	MX8MQ_IOMUXC_NAND_DATA04 = 71,
	MX8MQ_IOMUXC_NAND_DATA05 = 72,
	MX8MQ_IOMUXC_NAND_DATA06 = 73,
	MX8MQ_IOMUXC_NAND_DATA07 = 74,
	MX8MQ_IOMUXC_NAND_DQS = 75,
	MX8MQ_IOMUXC_NAND_RE_B = 76,
	MX8MQ_IOMUXC_NAND_READY_B = 77,
	MX8MQ_IOMUXC_NAND_WE_B = 78,
	MX8MQ_IOMUXC_NAND_WP_B = 79,
	MX8MQ_IOMUXC_SAI5_RXFS = 80,
	MX8MQ_IOMUXC_SAI5_RXC = 81,
	MX8MQ_IOMUXC_SAI5_RXD0 = 82,
	MX8MQ_IOMUXC_SAI5_RXD1 = 83,
	MX8MQ_IOMUXC_SAI5_RXD2 = 84,
	MX8MQ_IOMUXC_SAI5_RXD3 = 85,
	MX8MQ_IOMUXC_SAI5_MCLK = 86,
	MX8MQ_IOMUXC_SAI1_RXFS = 87,
	MX8MQ_IOMUXC_SAI1_RXC = 88,
	MX8MQ_IOMUXC_SAI1_RXD0 = 89,
	MX8MQ_IOMUXC_SAI1_RXD1 = 90,
	MX8MQ_IOMUXC_SAI1_RXD2 = 91,
	MX8MQ_IOMUXC_SAI1_RXD3 = 92,
	MX8MQ_IOMUXC_SAI1_RXD4 = 93,
	MX8MQ_IOMUXC_SAI1_RXD5 = 94,
	MX8MQ_IOMUXC_SAI1_RXD6 = 95,
	MX8MQ_IOMUXC_SAI1_RXD7 = 96,
	MX8MQ_IOMUXC_SAI1_TXFS = 97,
	MX8MQ_IOMUXC_SAI1_TXC = 98,
	MX8MQ_IOMUXC_SAI1_TXD0 = 99,
	MX8MQ_IOMUXC_SAI1_TXD1 = 100,
	MX8MQ_IOMUXC_SAI1_TXD2 = 101,
	MX8MQ_IOMUXC_SAI1_TXD3 = 102,
	MX8MQ_IOMUXC_SAI1_TXD4 = 103,
	MX8MQ_IOMUXC_SAI1_TXD5 = 104,
	MX8MQ_IOMUXC_SAI1_TXD6 = 105,
	MX8MQ_IOMUXC_SAI1_TXD7 = 106,
	MX8MQ_IOMUXC_SAI1_MCLK = 107,
	MX8MQ_IOMUXC_SAI2_RXFS = 108,
	MX8MQ_IOMUXC_SAI2_RXC = 109,
	MX8MQ_IOMUXC_SAI2_RXD0 = 110,
	MX8MQ_IOMUXC_SAI2_TXFS = 111,
	MX8MQ_IOMUXC_SAI2_TXC = 112,
	MX8MQ_IOMUXC_SAI2_TXD0 = 113,
	MX8MQ_IOMUXC_SAI2_MCLK = 114,
	MX8MQ_IOMUXC_SAI3_RXFS = 115,
	MX8MQ_IOMUXC_SAI3_RXC = 116,
	MX8MQ_IOMUXC_SAI3_RXD = 117,
	MX8MQ_IOMUXC_SAI3_TXFS = 118,
	MX8MQ_IOMUXC_SAI3_TXC = 119,
	MX8MQ_IOMUXC_SAI3_TXD = 120,
	MX8MQ_IOMUXC_SAI3_MCLK = 121,
	MX8MQ_IOMUXC_SPDIF_TX = 122,
	MX8MQ_IOMUXC_SPDIF_RX = 123,
	MX8MQ_IOMUXC_SPDIF_EXT_CLK = 124,
	MX8MQ_IOMUXC_ECSPI1_SCLK = 125,
	MX8MQ_IOMUXC_ECSPI1_MOSI = 126,
	MX8MQ_IOMUXC_ECSPI1_MISO = 127,
	MX8MQ_IOMUXC_ECSPI1_SS0 = 128,
	MX8MQ_IOMUXC_ECSPI2_SCLK = 129,
	MX8MQ_IOMUXC_ECSPI2_MOSI = 130,
	MX8MQ_IOMUXC_ECSPI2_MISO = 131,
	MX8MQ_IOMUXC_ECSPI2_SS0 = 132,
	MX8MQ_IOMUXC_I2C1_SCL = 133,
	MX8MQ_IOMUXC_I2C1_SDA = 134,
	MX8MQ_IOMUXC_I2C2_SCL = 135,
	MX8MQ_IOMUXC_I2C2_SDA = 136,
	MX8MQ_IOMUXC_I2C3_SCL = 137,
	MX8MQ_IOMUXC_I2C3_SDA = 138,
	MX8MQ_IOMUXC_I2C4_SCL = 139,
	MX8MQ_IOMUXC_I2C4_SDA = 140,
	MX8MQ_IOMUXC_UART1_RXD = 141,
	MX8MQ_IOMUXC_UART1_TXD = 142,
	MX8MQ_IOMUXC_UART2_RXD = 143,
	MX8MQ_IOMUXC_UART2_TXD = 144,
	MX8MQ_IOMUXC_UART3_RXD = 145,
	MX8MQ_IOMUXC_UART3_TXD = 146,
	MX8MQ_IOMUXC_UART4_RXD = 147,
	MX8MQ_IOMUXC_UART4_TXD = 148,
};

struct mvebu_mpp_ctrl_data {
	union {
		void *base;
		struct {
			struct regmap *map;
			u32 offset;
		} regmap;
	};
};

struct mvebu_mpp_ctrl {
	const char *name;
	u8 pid;
	u8 npins;
	unsigned int *pins;
	int (*mpp_get)(struct mvebu_mpp_ctrl_data *, unsigned int, long unsigned int *);
	int (*mpp_set)(struct mvebu_mpp_ctrl_data *, unsigned int, long unsigned int);
	int (*mpp_gpio_req)(struct mvebu_mpp_ctrl_data *, unsigned int);
	int (*mpp_gpio_dir)(struct mvebu_mpp_ctrl_data *, unsigned int, bool);
};

struct mvebu_mpp_ctrl_setting {
	u8 val;
	const char *name;
	const char *subname;
	u8 variant;
	u8 flags;
};

struct mvebu_mpp_mode {
	u8 pid;
	struct mvebu_mpp_ctrl_setting *settings;
};

struct mvebu_pinctrl_soc_info {
	u8 variant;
	const struct mvebu_mpp_ctrl *controls;
	struct mvebu_mpp_ctrl_data *control_data;
	int ncontrols;
	struct mvebu_mpp_mode *modes;
	int nmodes;
	struct pinctrl_gpio_range *gpioranges;
	int ngpioranges;
};

struct mvebu_pinctrl_function {
	const char *name;
	const char **groups;
	unsigned int num_groups;
};

struct mvebu_pinctrl_group {
	const char *name;
	const struct mvebu_mpp_ctrl *ctrl;
	struct mvebu_mpp_ctrl_data *data;
	struct mvebu_mpp_ctrl_setting *settings;
	unsigned int num_settings;
	unsigned int gid;
	unsigned int *pins;
	unsigned int npins;
};

struct mvebu_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctldev;
	struct pinctrl_desc desc;
	struct mvebu_pinctrl_group *groups;
	unsigned int num_groups;
	struct mvebu_pinctrl_function *functions;
	unsigned int num_functions;
	u8 variant;
};

enum {
	V_ARMADA_7K = 1,
	V_ARMADA_8K_CPM = 2,
	V_ARMADA_8K_CPS = 4,
	V_CP115_STANDALONE = 8,
	V_ARMADA_7K_8K_CPM = 3,
	V_ARMADA_7K_8K_CPS = 5,
};

struct armada_37xx_pin_group {
	const char *name;
	unsigned int start_pin;
	unsigned int npins;
	u32 reg_mask;
	u32 val[3];
	unsigned int extra_pin;
	unsigned int extra_npins;
	const char *funcs[3];
	unsigned int *pins;
};

struct armada_37xx_pin_data {
	u8 nr_pins;
	char *name;
	struct armada_37xx_pin_group *groups;
	int ngroups;
};

struct armada_37xx_pmx_func {
	const char *name;
	const char **groups;
	unsigned int ngroups;
};

struct armada_37xx_pm_state {
	u32 out_en_l;
	u32 out_en_h;
	u32 out_val_l;
	u32 out_val_h;
	u32 irq_en_l;
	u32 irq_en_h;
	u32 irq_pol_l;
	u32 irq_pol_h;
	u32 selection;
};

struct armada_37xx_pinctrl {
	struct regmap *regmap;
	void *base;
	const struct armada_37xx_pin_data *data;
	struct device *dev;
	struct gpio_chip gpio_chip;
	struct irq_chip irq_chip;
	spinlock_t irq_lock;
	struct pinctrl_desc pctl;
	struct pinctrl_dev *pctl_dev;
	struct armada_37xx_pin_group *groups;
	unsigned int ngroups;
	struct armada_37xx_pmx_func *funcs;
	unsigned int nfuncs;
	struct armada_37xx_pm_state pm;
};

struct msm_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
};

struct msm_pingroup {
	const char *name;
	const unsigned int *pins;
	unsigned int npins;
	unsigned int *funcs;
	unsigned int nfuncs;
	u32 ctl_reg;
	u32 io_reg;
	u32 intr_cfg_reg;
	u32 intr_status_reg;
	u32 intr_target_reg;
	unsigned int tile: 2;
	unsigned int mux_bit: 5;
	unsigned int pull_bit: 5;
	unsigned int drv_bit: 5;
	unsigned int od_bit: 5;
	unsigned int oe_bit: 5;
	unsigned int in_bit: 5;
	unsigned int out_bit: 5;
	unsigned int intr_enable_bit: 5;
	unsigned int intr_status_bit: 5;
	unsigned int intr_ack_high: 1;
	unsigned int intr_target_bit: 5;
	unsigned int intr_target_kpss_val: 5;
	unsigned int intr_raw_status_bit: 5;
	char: 1;
	unsigned int intr_polarity_bit: 5;
	unsigned int intr_detection_bit: 5;
	unsigned int intr_detection_width: 5;
};

struct msm_gpio_wakeirq_map {
	unsigned int gpio;
	unsigned int wakeirq;
};

struct msm_pinctrl_soc_data {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct msm_function *functions;
	unsigned int nfunctions;
	const struct msm_pingroup *groups;
	unsigned int ngroups;
	unsigned int ngpios;
	bool pull_no_keeper;
	const char * const *tiles;
	unsigned int ntiles;
	const int *reserved_gpios;
	const struct msm_gpio_wakeirq_map *wakeirq_map;
	unsigned int nwakeirq_map;
	bool wakeirq_dual_edge_errata;
	unsigned int gpio_func;
};

struct msm_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctrl;
	struct gpio_chip chip;
	struct pinctrl_desc desc;
	struct notifier_block restart_nb;
	struct irq_chip irq_chip;
	int irq;
	bool intr_target_use_scm;
	raw_spinlock_t lock;
	long unsigned int dual_edge_irqs[5];
	long unsigned int enabled_irqs[5];
	long unsigned int skip_wake_irqs[5];
	long unsigned int disabled_for_mux[5];
	const struct msm_pinctrl_soc_data *soc;
	void *regs[4];
	u32 phys_base[4];
};

struct soc_device_attribute {
	const char *machine;
	const char *family;
	const char *revision;
	const char *serial_number;
	const char *soc_id;
	const void *data;
	const struct attribute_group *custom_attr_group;
};

enum {
	PINMUX_TYPE_NONE = 0,
	PINMUX_TYPE_FUNCTION = 1,
	PINMUX_TYPE_GPIO = 2,
	PINMUX_TYPE_OUTPUT = 3,
	PINMUX_TYPE_INPUT = 4,
};

struct sh_pfc_pin {
	const char *name;
	unsigned int configs;
	u16 pin;
	u16 enum_id;
};

struct sh_pfc_pin_group {
	const char *name;
	const unsigned int *pins;
	const unsigned int *mux;
	unsigned int nr_pins;
};

struct sh_pfc_function {
	const char *name;
	const char * const *groups;
	unsigned int nr_groups;
};

struct pinmux_cfg_reg {
	u32 reg;
	u8 reg_width;
	u8 field_width;
	const u16 *enum_ids;
	const u8 *var_field_width;
};

struct pinmux_drive_reg_field {
	u16 pin;
	u8 offset;
	u8 size;
};

struct pinmux_drive_reg {
	u32 reg;
	const struct pinmux_drive_reg_field fields[8];
};

struct pinmux_bias_reg {
	u32 puen;
	u32 pud;
	const u16 pins[32];
};

struct pinmux_ioctrl_reg {
	u32 reg;
};

struct pinmux_data_reg {
	u32 reg;
	u8 reg_width;
	const u16 *enum_ids;
};

struct pinmux_range {
	u16 begin;
	u16 end;
	u16 force;
};

struct sh_pfc_window {
	phys_addr_t phys;
	void *virt;
	long unsigned int size;
};

struct sh_pfc_chip;

struct sh_pfc_soc_info;

struct sh_pfc_pin_range;

struct sh_pfc {
	struct device *dev;
	const struct sh_pfc_soc_info *info;
	spinlock_t lock;
	unsigned int num_windows;
	struct sh_pfc_window *windows;
	unsigned int num_irqs;
	unsigned int *irqs;
	struct sh_pfc_pin_range *ranges;
	unsigned int nr_ranges;
	unsigned int nr_gpio_pins;
	struct sh_pfc_chip *gpio;
	u32 *saved_regs;
};

struct sh_pfc_soc_operations;

struct sh_pfc_soc_info {
	const char *name;
	const struct sh_pfc_soc_operations *ops;
	struct pinmux_range function;
	const struct sh_pfc_pin *pins;
	unsigned int nr_pins;
	const struct sh_pfc_pin_group *groups;
	unsigned int nr_groups;
	const struct sh_pfc_function *functions;
	unsigned int nr_functions;
	const struct pinmux_cfg_reg *cfg_regs;
	const struct pinmux_drive_reg *drive_regs;
	const struct pinmux_bias_reg *bias_regs;
	const struct pinmux_ioctrl_reg *ioctrl_regs;
	const struct pinmux_data_reg *data_regs;
	const u16 *pinmux_data;
	unsigned int pinmux_data_size;
	u32 unlock_reg;
};

struct sh_pfc_pin_range {
	u16 start;
	u16 end;
};

struct sh_pfc_soc_operations {
	int (*init)(struct sh_pfc *);
	unsigned int (*get_bias)(struct sh_pfc *, unsigned int);
	void (*set_bias)(struct sh_pfc *, unsigned int, unsigned int);
	int (*pin_to_pocctrl)(struct sh_pfc *, unsigned int, u32 *);
	void * (*pin_to_portcr)(struct sh_pfc *, unsigned int);
};

struct sh_pfc_pin_config {
	u16 gpio_enabled: 1;
	u16 mux_mark: 15;
};

struct sh_pfc_pinctrl {
	struct pinctrl_dev *pctl;
	struct pinctrl_desc pctl_desc;
	struct sh_pfc *pfc;
	struct pinctrl_pin_desc *pins;
	struct sh_pfc_pin_config *configs;
	const char *func_prop_name;
	const char *groups_prop_name;
	const char *pins_prop_name;
};

union vin_data16 {
	unsigned int data16[16];
	unsigned int data12[12];
	unsigned int data10[10];
	unsigned int data8[8];
};

union vin_data {
	unsigned int data24[24];
	unsigned int data20[20];
	unsigned int data16[16];
	unsigned int data12[12];
	unsigned int data10[10];
	unsigned int data8[8];
	unsigned int data4[4];
};

enum {
	PINMUX_RESERVED = 0,
	PINMUX_DATA_BEGIN = 1,
	GP_0_0_DATA = 2,
	GP_0_1_DATA = 3,
	GP_0_2_DATA = 4,
	GP_0_3_DATA = 5,
	GP_0_4_DATA = 6,
	GP_0_5_DATA = 7,
	GP_0_6_DATA = 8,
	GP_0_7_DATA = 9,
	GP_0_8_DATA = 10,
	GP_0_9_DATA = 11,
	GP_0_10_DATA = 12,
	GP_0_11_DATA = 13,
	GP_0_12_DATA = 14,
	GP_0_13_DATA = 15,
	GP_0_14_DATA = 16,
	GP_0_15_DATA = 17,
	GP_1_0_DATA = 18,
	GP_1_1_DATA = 19,
	GP_1_2_DATA = 20,
	GP_1_3_DATA = 21,
	GP_1_4_DATA = 22,
	GP_1_5_DATA = 23,
	GP_1_6_DATA = 24,
	GP_1_7_DATA = 25,
	GP_1_8_DATA = 26,
	GP_1_9_DATA = 27,
	GP_1_10_DATA = 28,
	GP_1_11_DATA = 29,
	GP_1_12_DATA = 30,
	GP_1_13_DATA = 31,
	GP_1_14_DATA = 32,
	GP_1_15_DATA = 33,
	GP_1_16_DATA = 34,
	GP_1_17_DATA = 35,
	GP_1_18_DATA = 36,
	GP_1_19_DATA = 37,
	GP_1_20_DATA = 38,
	GP_1_21_DATA = 39,
	GP_1_22_DATA = 40,
	GP_1_23_DATA = 41,
	GP_1_24_DATA = 42,
	GP_1_25_DATA = 43,
	GP_1_26_DATA = 44,
	GP_1_27_DATA = 45,
	GP_1_28_DATA = 46,
	GP_2_0_DATA = 47,
	GP_2_1_DATA = 48,
	GP_2_2_DATA = 49,
	GP_2_3_DATA = 50,
	GP_2_4_DATA = 51,
	GP_2_5_DATA = 52,
	GP_2_6_DATA = 53,
	GP_2_7_DATA = 54,
	GP_2_8_DATA = 55,
	GP_2_9_DATA = 56,
	GP_2_10_DATA = 57,
	GP_2_11_DATA = 58,
	GP_2_12_DATA = 59,
	GP_2_13_DATA = 60,
	GP_2_14_DATA = 61,
	GP_3_0_DATA = 62,
	GP_3_1_DATA = 63,
	GP_3_2_DATA = 64,
	GP_3_3_DATA = 65,
	GP_3_4_DATA = 66,
	GP_3_5_DATA = 67,
	GP_3_6_DATA = 68,
	GP_3_7_DATA = 69,
	GP_3_8_DATA = 70,
	GP_3_9_DATA = 71,
	GP_3_10_DATA = 72,
	GP_3_11_DATA = 73,
	GP_3_12_DATA = 74,
	GP_3_13_DATA = 75,
	GP_3_14_DATA = 76,
	GP_3_15_DATA = 77,
	GP_4_0_DATA = 78,
	GP_4_1_DATA = 79,
	GP_4_2_DATA = 80,
	GP_4_3_DATA = 81,
	GP_4_4_DATA = 82,
	GP_4_5_DATA = 83,
	GP_4_6_DATA = 84,
	GP_4_7_DATA = 85,
	GP_4_8_DATA = 86,
	GP_4_9_DATA = 87,
	GP_4_10_DATA = 88,
	GP_4_11_DATA = 89,
	GP_4_12_DATA = 90,
	GP_4_13_DATA = 91,
	GP_4_14_DATA = 92,
	GP_4_15_DATA = 93,
	GP_4_16_DATA = 94,
	GP_4_17_DATA = 95,
	GP_5_0_DATA = 96,
	GP_5_1_DATA = 97,
	GP_5_2_DATA = 98,
	GP_5_3_DATA = 99,
	GP_5_4_DATA = 100,
	GP_5_5_DATA = 101,
	GP_5_6_DATA = 102,
	GP_5_7_DATA = 103,
	GP_5_8_DATA = 104,
	GP_5_9_DATA = 105,
	GP_5_10_DATA = 106,
	GP_5_11_DATA = 107,
	GP_5_12_DATA = 108,
	GP_5_13_DATA = 109,
	GP_5_14_DATA = 110,
	GP_5_15_DATA = 111,
	GP_5_16_DATA = 112,
	GP_5_17_DATA = 113,
	GP_5_18_DATA = 114,
	GP_5_19_DATA = 115,
	GP_5_20_DATA = 116,
	GP_5_21_DATA = 117,
	GP_5_22_DATA = 118,
	GP_5_23_DATA = 119,
	GP_5_24_DATA = 120,
	GP_5_25_DATA = 121,
	GP_6_0_DATA = 122,
	GP_6_1_DATA = 123,
	GP_6_2_DATA = 124,
	GP_6_3_DATA = 125,
	GP_6_4_DATA = 126,
	GP_6_5_DATA = 127,
	GP_6_6_DATA = 128,
	GP_6_7_DATA = 129,
	GP_6_8_DATA = 130,
	GP_6_9_DATA = 131,
	GP_6_10_DATA = 132,
	GP_6_11_DATA = 133,
	GP_6_12_DATA = 134,
	GP_6_13_DATA = 135,
	GP_6_14_DATA = 136,
	GP_6_15_DATA = 137,
	GP_6_16_DATA = 138,
	GP_6_17_DATA = 139,
	GP_6_18_DATA = 140,
	GP_6_19_DATA = 141,
	GP_6_20_DATA = 142,
	GP_6_21_DATA = 143,
	GP_6_22_DATA = 144,
	GP_6_23_DATA = 145,
	GP_6_24_DATA = 146,
	GP_6_25_DATA = 147,
	GP_6_26_DATA = 148,
	GP_6_27_DATA = 149,
	GP_6_28_DATA = 150,
	GP_6_29_DATA = 151,
	GP_6_30_DATA = 152,
	GP_6_31_DATA = 153,
	GP_7_0_DATA = 154,
	GP_7_1_DATA = 155,
	GP_7_2_DATA = 156,
	GP_7_3_DATA = 157,
	PINMUX_DATA_END = 158,
	PINMUX_FUNCTION_BEGIN = 159,
	GP_0_0_FN = 160,
	GP_0_1_FN = 161,
	GP_0_2_FN = 162,
	GP_0_3_FN = 163,
	GP_0_4_FN = 164,
	GP_0_5_FN = 165,
	GP_0_6_FN = 166,
	GP_0_7_FN = 167,
	GP_0_8_FN = 168,
	GP_0_9_FN = 169,
	GP_0_10_FN = 170,
	GP_0_11_FN = 171,
	GP_0_12_FN = 172,
	GP_0_13_FN = 173,
	GP_0_14_FN = 174,
	GP_0_15_FN = 175,
	GP_1_0_FN = 176,
	GP_1_1_FN = 177,
	GP_1_2_FN = 178,
	GP_1_3_FN = 179,
	GP_1_4_FN = 180,
	GP_1_5_FN = 181,
	GP_1_6_FN = 182,
	GP_1_7_FN = 183,
	GP_1_8_FN = 184,
	GP_1_9_FN = 185,
	GP_1_10_FN = 186,
	GP_1_11_FN = 187,
	GP_1_12_FN = 188,
	GP_1_13_FN = 189,
	GP_1_14_FN = 190,
	GP_1_15_FN = 191,
	GP_1_16_FN = 192,
	GP_1_17_FN = 193,
	GP_1_18_FN = 194,
	GP_1_19_FN = 195,
	GP_1_20_FN = 196,
	GP_1_21_FN = 197,
	GP_1_22_FN = 198,
	GP_1_23_FN = 199,
	GP_1_24_FN = 200,
	GP_1_25_FN = 201,
	GP_1_26_FN = 202,
	GP_1_27_FN = 203,
	GP_1_28_FN = 204,
	GP_2_0_FN = 205,
	GP_2_1_FN = 206,
	GP_2_2_FN = 207,
	GP_2_3_FN = 208,
	GP_2_4_FN = 209,
	GP_2_5_FN = 210,
	GP_2_6_FN = 211,
	GP_2_7_FN = 212,
	GP_2_8_FN = 213,
	GP_2_9_FN = 214,
	GP_2_10_FN = 215,
	GP_2_11_FN = 216,
	GP_2_12_FN = 217,
	GP_2_13_FN = 218,
	GP_2_14_FN = 219,
	GP_3_0_FN = 220,
	GP_3_1_FN = 221,
	GP_3_2_FN = 222,
	GP_3_3_FN = 223,
	GP_3_4_FN = 224,
	GP_3_5_FN = 225,
	GP_3_6_FN = 226,
	GP_3_7_FN = 227,
	GP_3_8_FN = 228,
	GP_3_9_FN = 229,
	GP_3_10_FN = 230,
	GP_3_11_FN = 231,
	GP_3_12_FN = 232,
	GP_3_13_FN = 233,
	GP_3_14_FN = 234,
	GP_3_15_FN = 235,
	GP_4_0_FN = 236,
	GP_4_1_FN = 237,
	GP_4_2_FN = 238,
	GP_4_3_FN = 239,
	GP_4_4_FN = 240,
	GP_4_5_FN = 241,
	GP_4_6_FN = 242,
	GP_4_7_FN = 243,
	GP_4_8_FN = 244,
	GP_4_9_FN = 245,
	GP_4_10_FN = 246,
	GP_4_11_FN = 247,
	GP_4_12_FN = 248,
	GP_4_13_FN = 249,
	GP_4_14_FN = 250,
	GP_4_15_FN = 251,
	GP_4_16_FN = 252,
	GP_4_17_FN = 253,
	GP_5_0_FN = 254,
	GP_5_1_FN = 255,
	GP_5_2_FN = 256,
	GP_5_3_FN = 257,
	GP_5_4_FN = 258,
	GP_5_5_FN = 259,
	GP_5_6_FN = 260,
	GP_5_7_FN = 261,
	GP_5_8_FN = 262,
	GP_5_9_FN = 263,
	GP_5_10_FN = 264,
	GP_5_11_FN = 265,
	GP_5_12_FN = 266,
	GP_5_13_FN = 267,
	GP_5_14_FN = 268,
	GP_5_15_FN = 269,
	GP_5_16_FN = 270,
	GP_5_17_FN = 271,
	GP_5_18_FN = 272,
	GP_5_19_FN = 273,
	GP_5_20_FN = 274,
	GP_5_21_FN = 275,
	GP_5_22_FN = 276,
	GP_5_23_FN = 277,
	GP_5_24_FN = 278,
	GP_5_25_FN = 279,
	GP_6_0_FN = 280,
	GP_6_1_FN = 281,
	GP_6_2_FN = 282,
	GP_6_3_FN = 283,
	GP_6_4_FN = 284,
	GP_6_5_FN = 285,
	GP_6_6_FN = 286,
	GP_6_7_FN = 287,
	GP_6_8_FN = 288,
	GP_6_9_FN = 289,
	GP_6_10_FN = 290,
	GP_6_11_FN = 291,
	GP_6_12_FN = 292,
	GP_6_13_FN = 293,
	GP_6_14_FN = 294,
	GP_6_15_FN = 295,
	GP_6_16_FN = 296,
	GP_6_17_FN = 297,
	GP_6_18_FN = 298,
	GP_6_19_FN = 299,
	GP_6_20_FN = 300,
	GP_6_21_FN = 301,
	GP_6_22_FN = 302,
	GP_6_23_FN = 303,
	GP_6_24_FN = 304,
	GP_6_25_FN = 305,
	GP_6_26_FN = 306,
	GP_6_27_FN = 307,
	GP_6_28_FN = 308,
	GP_6_29_FN = 309,
	GP_6_30_FN = 310,
	GP_6_31_FN = 311,
	GP_7_0_FN = 312,
	GP_7_1_FN = 313,
	GP_7_2_FN = 314,
	GP_7_3_FN = 315,
	FN_CLKOUT = 316,
	FN_MSIOF0_RXD = 317,
	FN_MSIOF0_TXD = 318,
	FN_MSIOF0_SCK = 319,
	FN_SSI_SDATA5 = 320,
	FN_SSI_WS5 = 321,
	FN_SSI_SCK5 = 322,
	FN_GP7_03 = 323,
	FN_GP7_02 = 324,
	FN_AVS2 = 325,
	FN_AVS1 = 326,
	FN_IP0_3_0 = 327,
	FN_AVB_MDC = 328,
	FN_MSIOF2_SS2_C = 329,
	FN_IP1_3_0 = 330,
	FN_IRQ2 = 331,
	FN_QCPV_QDE = 332,
	FN_DU_EXODDF_DU_ODDF_DISP_CDE = 333,
	FN_VI4_DATA2_B = 334,
	FN_MSIOF3_SYNC_E = 335,
	FN_PWM3_B = 336,
	FN_IP2_3_0 = 337,
	FN_A1 = 338,
	FN_LCDOUT17 = 339,
	FN_MSIOF3_TXD_B = 340,
	FN_VI4_DATA9 = 341,
	FN_DU_DB1 = 342,
	FN_PWM4_A = 343,
	FN_IP3_3_0 = 344,
	FN_A9 = 345,
	FN_MSIOF2_SCK_A = 346,
	FN_CTS4_N_B = 347,
	FN_VI5_VSYNC_N = 348,
	FN_IP0_7_4 = 349,
	FN_AVB_MAGIC = 350,
	FN_MSIOF2_SS1_C = 351,
	FN_SCK4_A = 352,
	FN_IP1_7_4 = 353,
	FN_IRQ3 = 354,
	FN_QSTVB_QVE = 355,
	FN_DU_DOTCLKOUT1 = 356,
	FN_VI4_DATA3_B = 357,
	FN_MSIOF3_SCK_E = 358,
	FN_PWM4_B = 359,
	FN_IP2_7_4 = 360,
	FN_A2 = 361,
	FN_LCDOUT18 = 362,
	FN_MSIOF3_SCK_B = 363,
	FN_VI4_DATA10 = 364,
	FN_DU_DB2 = 365,
	FN_PWM5_A = 366,
	FN_IP3_7_4 = 367,
	FN_A10 = 368,
	FN_MSIOF2_RXD_A = 369,
	FN_RTS4_N_B = 370,
	FN_VI5_HSYNC_N = 371,
	FN_IP0_11_8 = 372,
	FN_AVB_PHY_INT = 373,
	FN_MSIOF2_SYNC_C = 374,
	FN_RX4_A = 375,
	FN_IP1_11_8 = 376,
	FN_IRQ4 = 377,
	FN_QSTH_QHS = 378,
	FN_DU_EXHSYNC_DU_HSYNC = 379,
	FN_VI4_DATA4_B = 380,
	FN_MSIOF3_RXD_E = 381,
	FN_PWM5_B = 382,
	FN_IP2_11_8 = 383,
	FN_A3 = 384,
	FN_LCDOUT19 = 385,
	FN_MSIOF3_RXD_B = 386,
	FN_VI4_DATA11 = 387,
	FN_DU_DB3 = 388,
	FN_PWM6_A = 389,
	FN_IP3_11_8 = 390,
	FN_A11 = 391,
	FN_TX3_B = 392,
	FN_MSIOF2_TXD_A = 393,
	FN_HTX4_B = 394,
	FN_HSCK4 = 395,
	FN_VI5_FIELD = 396,
	FN_SCL6_A = 397,
	FN_AVB_AVTP_CAPTURE_B = 398,
	FN_PWM2_B = 399,
	FN_IP0_15_12 = 400,
	FN_AVB_LINK = 401,
	FN_MSIOF2_SCK_C = 402,
	FN_TX4_A = 403,
	FN_IP1_15_12 = 404,
	FN_IRQ5 = 405,
	FN_QSTB_QHE = 406,
	FN_DU_EXVSYNC_DU_VSYNC = 407,
	FN_VI4_DATA5_B = 408,
	FN_MSIOF3_TXD_E = 409,
	FN_PWM6_B = 410,
	FN_IP2_15_12 = 411,
	FN_A4 = 412,
	FN_LCDOUT20 = 413,
	FN_MSIOF3_SS1_B = 414,
	FN_VI4_DATA12 = 415,
	FN_VI5_DATA12 = 416,
	FN_DU_DB4 = 417,
	FN_IP3_15_12 = 418,
	FN_A12 = 419,
	FN_LCDOUT12 = 420,
	FN_MSIOF3_SCK_C = 421,
	FN_HRX4_A = 422,
	FN_VI5_DATA8 = 423,
	FN_DU_DG4 = 424,
	FN_IP0_19_16 = 425,
	FN_AVB_AVTP_MATCH_A = 426,
	FN_MSIOF2_RXD_C = 427,
	FN_CTS4_N_A = 428,
	FN_IP1_19_16 = 429,
	FN_PWM0 = 430,
	FN_AVB_AVTP_PPS = 431,
	FN_VI4_DATA6_B = 432,
	FN_IECLK_B = 433,
	FN_IP2_19_16 = 434,
	FN_A5 = 435,
	FN_LCDOUT21 = 436,
	FN_MSIOF3_SS2_B = 437,
	FN_SCK4_B = 438,
	FN_VI4_DATA13 = 439,
	FN_VI5_DATA13 = 440,
	FN_DU_DB5 = 441,
	FN_IP3_19_16 = 442,
	FN_A13 = 443,
	FN_LCDOUT13 = 444,
	FN_MSIOF3_SYNC_C = 445,
	FN_HTX4_A = 446,
	FN_VI5_DATA9 = 447,
	FN_DU_DG5 = 448,
	FN_IP0_23_20 = 449,
	FN_AVB_AVTP_CAPTURE_A = 450,
	FN_MSIOF2_TXD_C = 451,
	FN_RTS4_N_A = 452,
	FN_IP1_23_20 = 453,
	FN_PWM1_A = 454,
	FN_HRX3_D = 455,
	FN_VI4_DATA7_B = 456,
	FN_IERX_B = 457,
	FN_IP2_23_20 = 458,
	FN_A6 = 459,
	FN_LCDOUT22 = 460,
	FN_MSIOF2_SS1_A = 461,
	FN_RX4_B = 462,
	FN_VI4_DATA14 = 463,
	FN_VI5_DATA14 = 464,
	FN_DU_DB6 = 465,
	FN_IP3_23_20 = 466,
	FN_A14 = 467,
	FN_LCDOUT14 = 468,
	FN_MSIOF3_RXD_C = 469,
	FN_HCTS4_N = 470,
	FN_VI5_DATA10 = 471,
	FN_DU_DG6 = 472,
	FN_IP0_27_24 = 473,
	FN_IRQ0 = 474,
	FN_QPOLB = 475,
	FN_DU_CDE = 476,
	FN_VI4_DATA0_B = 477,
	FN_CAN0_TX_B = 478,
	FN_CANFD0_TX_B = 479,
	FN_MSIOF3_SS2_E = 480,
	FN_IP1_27_24 = 481,
	FN_PWM2_A = 482,
	FN_HTX3_D = 483,
	FN_IETX_B = 484,
	FN_IP2_27_24 = 485,
	FN_A7 = 486,
	FN_LCDOUT23 = 487,
	FN_MSIOF2_SS2_A = 488,
	FN_TX4_B = 489,
	FN_VI4_DATA15 = 490,
	FN_VI5_DATA15 = 491,
	FN_DU_DB7 = 492,
	FN_IP3_27_24 = 493,
	FN_A15 = 494,
	FN_LCDOUT15 = 495,
	FN_MSIOF3_TXD_C = 496,
	FN_HRTS4_N = 497,
	FN_VI5_DATA11 = 498,
	FN_DU_DG7 = 499,
	FN_IP0_31_28 = 500,
	FN_IRQ1 = 501,
	FN_QPOLA = 502,
	FN_DU_DISP = 503,
	FN_VI4_DATA1_B = 504,
	FN_CAN0_RX_B = 505,
	FN_CANFD0_RX_B = 506,
	FN_MSIOF3_SS1_E = 507,
	FN_IP1_31_28 = 508,
	FN_A0 = 509,
	FN_LCDOUT16 = 510,
	FN_MSIOF3_SYNC_B = 511,
	FN_VI4_DATA8 = 512,
	FN_DU_DB0 = 513,
	FN_PWM3_A = 514,
	FN_IP2_31_28 = 515,
	FN_A8 = 516,
	FN_RX3_B = 517,
	FN_MSIOF2_SYNC_A = 518,
	FN_HRX4_B = 519,
	FN_SDA6_A = 520,
	FN_AVB_AVTP_MATCH_B = 521,
	FN_PWM1_B = 522,
	FN_IP3_31_28 = 523,
	FN_A16 = 524,
	FN_LCDOUT8 = 525,
	FN_VI4_FIELD = 526,
	FN_DU_DG0 = 527,
	FN_IP4_3_0 = 528,
	FN_A17 = 529,
	FN_LCDOUT9 = 530,
	FN_VI4_VSYNC_N = 531,
	FN_DU_DG1 = 532,
	FN_IP5_3_0 = 533,
	FN_WE0_N = 534,
	FN_MSIOF3_TXD_D = 535,
	FN_CTS3_N = 536,
	FN_HCTS3_N = 537,
	FN_SCL6_B = 538,
	FN_CAN_CLK = 539,
	FN_IECLK_A = 540,
	FN_IP6_3_0 = 541,
	FN_D5 = 542,
	FN_MSIOF2_SYNC_B = 543,
	FN_VI4_DATA21 = 544,
	FN_VI5_DATA5 = 545,
	FN_IP7_3_0 = 546,
	FN_D13 = 547,
	FN_LCDOUT5 = 548,
	FN_MSIOF2_SS2_D = 549,
	FN_TX4_C = 550,
	FN_VI4_DATA5_A = 551,
	FN_DU_DR5 = 552,
	FN_IP4_7_4 = 553,
	FN_A18 = 554,
	FN_LCDOUT10 = 555,
	FN_VI4_HSYNC_N = 556,
	FN_DU_DG2 = 557,
	FN_IP5_7_4 = 558,
	FN_WE1_N = 559,
	FN_MSIOF3_SS1_D = 560,
	FN_RTS3_N = 561,
	FN_HRTS3_N = 562,
	FN_SDA6_B = 563,
	FN_CAN1_RX = 564,
	FN_CANFD1_RX = 565,
	FN_IERX_A = 566,
	FN_IP6_7_4 = 567,
	FN_D6 = 568,
	FN_MSIOF2_RXD_B = 569,
	FN_VI4_DATA22 = 570,
	FN_VI5_DATA6 = 571,
	FN_IP7_7_4 = 572,
	FN_D14 = 573,
	FN_LCDOUT6 = 574,
	FN_MSIOF3_SS1_A = 575,
	FN_HRX3_C = 576,
	FN_VI4_DATA6_A = 577,
	FN_DU_DR6 = 578,
	FN_SCL6_C = 579,
	FN_IP4_11_8 = 580,
	FN_A19 = 581,
	FN_LCDOUT11 = 582,
	FN_VI4_CLKENB = 583,
	FN_DU_DG3 = 584,
	FN_IP5_11_8 = 585,
	FN_EX_WAIT0_A = 586,
	FN_QCLK = 587,
	FN_VI4_CLK = 588,
	FN_DU_DOTCLKOUT0 = 589,
	FN_IP6_11_8 = 590,
	FN_D7 = 591,
	FN_MSIOF2_TXD_B = 592,
	FN_VI4_DATA23 = 593,
	FN_VI5_DATA7 = 594,
	FN_IP7_11_8 = 595,
	FN_D15 = 596,
	FN_LCDOUT7 = 597,
	FN_MSIOF3_SS2_A = 598,
	FN_HTX3_C = 599,
	FN_VI4_DATA7_A = 600,
	FN_DU_DR7 = 601,
	FN_SDA6_C = 602,
	FN_IP4_15_12 = 603,
	FN_CS0_N = 604,
	FN_VI5_CLKENB = 605,
	FN_IP5_15_12 = 606,
	FN_D0 = 607,
	FN_MSIOF2_SS1_B = 608,
	FN_MSIOF3_SCK_A = 609,
	FN_VI4_DATA16 = 610,
	FN_VI5_DATA0 = 611,
	FN_IP6_15_12 = 612,
	FN_D8 = 613,
	FN_LCDOUT0 = 614,
	FN_MSIOF2_SCK_D = 615,
	FN_SCK4_C = 616,
	FN_VI4_DATA0_A = 617,
	FN_DU_DR0 = 618,
	FN_IP4_19_16 = 619,
	FN_CS1_N = 620,
	FN_VI5_CLK = 621,
	FN_EX_WAIT0_B = 622,
	FN_IP5_19_16 = 623,
	FN_D1 = 624,
	FN_MSIOF2_SS2_B = 625,
	FN_MSIOF3_SYNC_A = 626,
	FN_VI4_DATA17 = 627,
	FN_VI5_DATA1 = 628,
	FN_IP6_19_16 = 629,
	FN_D9 = 630,
	FN_LCDOUT1 = 631,
	FN_MSIOF2_SYNC_D = 632,
	FN_VI4_DATA1_A = 633,
	FN_DU_DR1 = 634,
	FN_IP7_19_16 = 635,
	FN_SD0_CLK = 636,
	FN_MSIOF1_SCK_E = 637,
	FN_STP_OPWM_0_B = 638,
	FN_IP4_23_20 = 639,
	FN_BS_N = 640,
	FN_QSTVA_QVS = 641,
	FN_MSIOF3_SCK_D = 642,
	FN_SCK3 = 643,
	FN_HSCK3 = 644,
	FN_CAN1_TX = 645,
	FN_CANFD1_TX = 646,
	FN_IETX_A = 647,
	FN_IP5_23_20 = 648,
	FN_D2 = 649,
	FN_MSIOF3_RXD_A = 650,
	FN_VI4_DATA18 = 651,
	FN_VI5_DATA2 = 652,
	FN_IP6_23_20 = 653,
	FN_D10 = 654,
	FN_LCDOUT2 = 655,
	FN_MSIOF2_RXD_D = 656,
	FN_HRX3_B = 657,
	FN_VI4_DATA2_A = 658,
	FN_CTS4_N_C = 659,
	FN_DU_DR2 = 660,
	FN_IP7_23_20 = 661,
	FN_SD0_CMD = 662,
	FN_MSIOF1_SYNC_E = 663,
	FN_STP_IVCXO27_0_B = 664,
	FN_IP4_27_24 = 665,
	FN_RD_N = 666,
	FN_MSIOF3_SYNC_D = 667,
	FN_RX3_A = 668,
	FN_HRX3_A = 669,
	FN_CAN0_TX_A = 670,
	FN_CANFD0_TX_A = 671,
	FN_IP5_27_24 = 672,
	FN_D3 = 673,
	FN_MSIOF3_TXD_A = 674,
	FN_VI4_DATA19 = 675,
	FN_VI5_DATA3 = 676,
	FN_IP6_27_24 = 677,
	FN_D11 = 678,
	FN_LCDOUT3 = 679,
	FN_MSIOF2_TXD_D = 680,
	FN_HTX3_B = 681,
	FN_VI4_DATA3_A = 682,
	FN_RTS4_N_C = 683,
	FN_DU_DR3 = 684,
	FN_IP7_27_24 = 685,
	FN_SD0_DAT0 = 686,
	FN_MSIOF1_RXD_E = 687,
	FN_TS_SCK0_B = 688,
	FN_STP_ISCLK_0_B = 689,
	FN_IP4_31_28 = 690,
	FN_RD_WR_N = 691,
	FN_MSIOF3_RXD_D = 692,
	FN_TX3_A = 693,
	FN_HTX3_A = 694,
	FN_CAN0_RX_A = 695,
	FN_CANFD0_RX_A = 696,
	FN_IP5_31_28 = 697,
	FN_D4 = 698,
	FN_MSIOF2_SCK_B = 699,
	FN_VI4_DATA20 = 700,
	FN_VI5_DATA4 = 701,
	FN_IP6_31_28 = 702,
	FN_D12 = 703,
	FN_LCDOUT4 = 704,
	FN_MSIOF2_SS1_D = 705,
	FN_RX4_C = 706,
	FN_VI4_DATA4_A = 707,
	FN_DU_DR4 = 708,
	FN_IP7_31_28 = 709,
	FN_SD0_DAT1 = 710,
	FN_MSIOF1_TXD_E = 711,
	FN_TS_SPSYNC0_B = 712,
	FN_STP_ISSYNC_0_B = 713,
	FN_IP8_3_0 = 714,
	FN_SD0_DAT2 = 715,
	FN_MSIOF1_SS1_E = 716,
	FN_TS_SDAT0_B = 717,
	FN_STP_ISD_0_B = 718,
	FN_IP9_3_0 = 719,
	FN_SD2_CLK = 720,
	FN_NFDATA8 = 721,
	FN_IP10_3_0 = 722,
	FN_SD3_CMD = 723,
	FN_NFRE_N = 724,
	FN_IP11_3_0 = 725,
	FN_SD3_DAT7 = 726,
	FN_SD3_WP = 727,
	FN_NFDATA7 = 728,
	FN_IP8_7_4 = 729,
	FN_SD0_DAT3 = 730,
	FN_MSIOF1_SS2_E = 731,
	FN_TS_SDEN0_B = 732,
	FN_STP_ISEN_0_B = 733,
	FN_IP9_7_4 = 734,
	FN_SD2_CMD = 735,
	FN_NFDATA9 = 736,
	FN_IP10_7_4 = 737,
	FN_SD3_DAT0 = 738,
	FN_NFDATA0 = 739,
	FN_IP11_7_4 = 740,
	FN_SD3_DS = 741,
	FN_NFCLE = 742,
	FN_IP8_11_8 = 743,
	FN_SD1_CLK = 744,
	FN_MSIOF1_SCK_G = 745,
	FN_SIM0_CLK_A = 746,
	FN_IP9_11_8 = 747,
	FN_SD2_DAT0 = 748,
	FN_NFDATA10 = 749,
	FN_IP10_11_8 = 750,
	FN_SD3_DAT1 = 751,
	FN_NFDATA1 = 752,
	FN_IP11_11_8 = 753,
	FN_SD0_CD = 754,
	FN_NFDATA14_A = 755,
	FN_SCL2_B = 756,
	FN_SIM0_RST_A = 757,
	FN_IP8_15_12 = 758,
	FN_SD1_CMD = 759,
	FN_MSIOF1_SYNC_G = 760,
	FN_NFCE_N_B = 761,
	FN_SIM0_D_A = 762,
	FN_STP_IVCXO27_1_B = 763,
	FN_IP9_15_12 = 764,
	FN_SD2_DAT1 = 765,
	FN_NFDATA11 = 766,
	FN_IP10_15_12 = 767,
	FN_SD3_DAT2 = 768,
	FN_NFDATA2 = 769,
	FN_IP11_15_12 = 770,
	FN_SD0_WP = 771,
	FN_NFDATA15_A = 772,
	FN_SDA2_B = 773,
	FN_IP8_19_16 = 774,
	FN_SD1_DAT0 = 775,
	FN_SD2_DAT4 = 776,
	FN_MSIOF1_RXD_G = 777,
	FN_NFWP_N_B = 778,
	FN_TS_SCK1_B = 779,
	FN_STP_ISCLK_1_B = 780,
	FN_IP9_19_16 = 781,
	FN_SD2_DAT2 = 782,
	FN_NFDATA12 = 783,
	FN_IP10_19_16 = 784,
	FN_SD3_DAT3 = 785,
	FN_NFDATA3 = 786,
	FN_IP11_19_16 = 787,
	FN_SD1_CD = 788,
	FN_NFRB_N_A = 789,
	FN_SIM0_CLK_B = 790,
	FN_IP8_23_20 = 791,
	FN_SD1_DAT1 = 792,
	FN_SD2_DAT5 = 793,
	FN_MSIOF1_TXD_G = 794,
	FN_NFDATA14_B = 795,
	FN_TS_SPSYNC1_B = 796,
	FN_STP_ISSYNC_1_B = 797,
	FN_IP9_23_20 = 798,
	FN_SD2_DAT3 = 799,
	FN_NFDATA13 = 800,
	FN_IP10_23_20 = 801,
	FN_SD3_DAT4 = 802,
	FN_SD2_CD_A = 803,
	FN_NFDATA4 = 804,
	FN_IP11_23_20 = 805,
	FN_SD1_WP = 806,
	FN_NFCE_N_A = 807,
	FN_SIM0_D_B = 808,
	FN_IP8_27_24 = 809,
	FN_SD1_DAT2 = 810,
	FN_SD2_DAT6 = 811,
	FN_MSIOF1_SS1_G = 812,
	FN_NFDATA15_B = 813,
	FN_TS_SDAT1_B = 814,
	FN_STP_ISD_1_B = 815,
	FN_IP9_27_24 = 816,
	FN_SD2_DS = 817,
	FN_NFALE = 818,
	FN_IP10_27_24 = 819,
	FN_SD3_DAT5 = 820,
	FN_SD2_WP_A = 821,
	FN_NFDATA5 = 822,
	FN_IP11_27_24 = 823,
	FN_SCK0 = 824,
	FN_HSCK1_B = 825,
	FN_MSIOF1_SS2_B = 826,
	FN_AUDIO_CLKC_B = 827,
	FN_SDA2_A = 828,
	FN_SIM0_RST_B = 829,
	FN_STP_OPWM_0_C = 830,
	FN_RIF0_CLK_B = 831,
	FN_ADICHS2 = 832,
	FN_SCK5_B = 833,
	FN_IP8_31_28 = 834,
	FN_SD1_DAT3 = 835,
	FN_SD2_DAT7 = 836,
	FN_MSIOF1_SS2_G = 837,
	FN_NFRB_N_B = 838,
	FN_TS_SDEN1_B = 839,
	FN_STP_ISEN_1_B = 840,
	FN_IP9_31_28 = 841,
	FN_SD3_CLK = 842,
	FN_NFWE_N = 843,
	FN_IP10_31_28 = 844,
	FN_SD3_DAT6 = 845,
	FN_SD3_CD = 846,
	FN_NFDATA6 = 847,
	FN_IP11_31_28 = 848,
	FN_RX0 = 849,
	FN_HRX1_B = 850,
	FN_TS_SCK0_C = 851,
	FN_STP_ISCLK_0_C = 852,
	FN_RIF0_D0_B = 853,
	FN_IP12_3_0 = 854,
	FN_TX0 = 855,
	FN_HTX1_B = 856,
	FN_TS_SPSYNC0_C = 857,
	FN_STP_ISSYNC_0_C = 858,
	FN_RIF0_D1_B = 859,
	FN_IP13_3_0 = 860,
	FN_TX2_A = 861,
	FN_SD2_CD_B = 862,
	FN_SCL1_A = 863,
	FN_FMCLK_A = 864,
	FN_RIF1_D1_C = 865,
	FN_FSO_CFE_0_N = 866,
	FN_IP14_3_0 = 867,
	FN_MSIOF0_SS1 = 868,
	FN_RX5_A = 869,
	FN_NFWP_N_A = 870,
	FN_AUDIO_CLKA_C = 871,
	FN_SSI_SCK2_A = 872,
	FN_STP_IVCXO27_0_C = 873,
	FN_AUDIO_CLKOUT3_A = 874,
	FN_TCLK1_B = 875,
	FN_IP15_3_0 = 876,
	FN_SSI_SDATA1_A = 877,
	FN_IP12_7_4 = 878,
	FN_CTS0_N = 879,
	FN_HCTS1_N_B = 880,
	FN_MSIOF1_SYNC_B = 881,
	FN_TS_SPSYNC1_C = 882,
	FN_STP_ISSYNC_1_C = 883,
	FN_RIF1_SYNC_B = 884,
	FN_AUDIO_CLKOUT_C = 885,
	FN_ADICS_SAMP = 886,
	FN_IP13_7_4 = 887,
	FN_RX2_A = 888,
	FN_SD2_WP_B = 889,
	FN_SDA1_A = 890,
	FN_FMIN_A = 891,
	FN_RIF1_SYNC_C = 892,
	FN_FSO_CFE_1_N = 893,
	FN_IP14_7_4 = 894,
	FN_MSIOF0_SS2 = 895,
	FN_TX5_A = 896,
	FN_MSIOF1_SS2_D = 897,
	FN_AUDIO_CLKC_A = 898,
	FN_SSI_WS2_A = 899,
	FN_STP_OPWM_0_D = 900,
	FN_AUDIO_CLKOUT_D = 901,
	FN_SPEEDIN_B = 902,
	FN_IP15_7_4 = 903,
	FN_SSI_SDATA2_A = 904,
	FN_SSI_SCK1_B = 905,
	FN_IP12_11_8 = 906,
	FN_RTS0_N = 907,
	FN_HRTS1_N_B = 908,
	FN_MSIOF1_SS1_B = 909,
	FN_AUDIO_CLKA_B = 910,
	FN_SCL2_A = 911,
	FN_STP_IVCXO27_1_C = 912,
	FN_RIF0_SYNC_B = 913,
	FN_ADICHS1 = 914,
	FN_IP13_11_8 = 915,
	FN_HSCK0 = 916,
	FN_MSIOF1_SCK_D = 917,
	FN_AUDIO_CLKB_A = 918,
	FN_SSI_SDATA1_B = 919,
	FN_TS_SCK0_D = 920,
	FN_STP_ISCLK_0_D = 921,
	FN_RIF0_CLK_C = 922,
	FN_RX5_B = 923,
	FN_IP14_11_8 = 924,
	FN_MLB_CLK = 925,
	FN_MSIOF1_SCK_F = 926,
	FN_SCL1_B = 927,
	FN_IP15_11_8 = 928,
	FN_SSI_SCK349 = 929,
	FN_MSIOF1_SS1_A = 930,
	FN_STP_OPWM_0_A = 931,
	FN_IP12_15_12 = 932,
	FN_RX1_A = 933,
	FN_HRX1_A = 934,
	FN_TS_SDAT0_C = 935,
	FN_STP_ISD_0_C = 936,
	FN_RIF1_CLK_C = 937,
	FN_IP13_15_12 = 938,
	FN_HRX0 = 939,
	FN_MSIOF1_RXD_D = 940,
	FN_SSI_SDATA2_B = 941,
	FN_TS_SDEN0_D = 942,
	FN_STP_ISEN_0_D = 943,
	FN_RIF0_D0_C = 944,
	FN_IP14_15_12 = 945,
	FN_MLB_SIG = 946,
	FN_RX1_B = 947,
	FN_MSIOF1_SYNC_F = 948,
	FN_SDA1_B = 949,
	FN_IP15_15_12 = 950,
	FN_SSI_WS349 = 951,
	FN_HCTS2_N_A = 952,
	FN_MSIOF1_SS2_A = 953,
	FN_STP_IVCXO27_0_A = 954,
	FN_IP12_19_16 = 955,
	FN_TX1_A = 956,
	FN_HTX1_A = 957,
	FN_TS_SDEN0_C = 958,
	FN_STP_ISEN_0_C = 959,
	FN_RIF1_D0_C = 960,
	FN_IP13_19_16 = 961,
	FN_HTX0 = 962,
	FN_MSIOF1_TXD_D = 963,
	FN_SSI_SDATA9_B = 964,
	FN_TS_SDAT0_D = 965,
	FN_STP_ISD_0_D = 966,
	FN_RIF0_D1_C = 967,
	FN_IP14_19_16 = 968,
	FN_MLB_DAT = 969,
	FN_TX1_B = 970,
	FN_MSIOF1_RXD_F = 971,
	FN_IP15_19_16 = 972,
	FN_SSI_SDATA3 = 973,
	FN_HRTS2_N_A = 974,
	FN_MSIOF1_TXD_A = 975,
	FN_TS_SCK0_A = 976,
	FN_STP_ISCLK_0_A = 977,
	FN_RIF0_D1_A = 978,
	FN_RIF2_D0_A = 979,
	FN_IP12_23_20 = 980,
	FN_CTS1_N = 981,
	FN_HCTS1_N_A = 982,
	FN_MSIOF1_RXD_B = 983,
	FN_TS_SDEN1_C = 984,
	FN_STP_ISEN_1_C = 985,
	FN_RIF1_D0_B = 986,
	FN_ADIDATA = 987,
	FN_IP13_23_20 = 988,
	FN_HCTS0_N = 989,
	FN_RX2_B = 990,
	FN_MSIOF1_SYNC_D = 991,
	FN_SSI_SCK9_A = 992,
	FN_TS_SPSYNC0_D = 993,
	FN_STP_ISSYNC_0_D = 994,
	FN_RIF0_SYNC_C = 995,
	FN_AUDIO_CLKOUT1_A = 996,
	FN_IP14_23_20 = 997,
	FN_SSI_SCK01239 = 998,
	FN_MSIOF1_TXD_F = 999,
	FN_IP15_23_20 = 1000,
	FN_SSI_SCK4 = 1001,
	FN_HRX2_A = 1002,
	FN_MSIOF1_SCK_A = 1003,
	FN_TS_SDAT0_A = 1004,
	FN_STP_ISD_0_A = 1005,
	FN_RIF0_CLK_A = 1006,
	FN_RIF2_CLK_A = 1007,
	FN_IP12_27_24 = 1008,
	FN_RTS1_N = 1009,
	FN_HRTS1_N_A = 1010,
	FN_MSIOF1_TXD_B = 1011,
	FN_TS_SDAT1_C = 1012,
	FN_STP_ISD_1_C = 1013,
	FN_RIF1_D1_B = 1014,
	FN_ADICHS0 = 1015,
	FN_IP13_27_24 = 1016,
	FN_HRTS0_N = 1017,
	FN_TX2_B = 1018,
	FN_MSIOF1_SS1_D = 1019,
	FN_SSI_WS9_A = 1020,
	FN_STP_IVCXO27_0_D = 1021,
	FN_BPFCLK_A = 1022,
	FN_AUDIO_CLKOUT2_A = 1023,
	FN_IP14_27_24 = 1024,
	FN_SSI_WS01239 = 1025,
	FN_MSIOF1_SS1_F = 1026,
	FN_IP15_27_24 = 1027,
	FN_SSI_WS4 = 1028,
	FN_HTX2_A = 1029,
	FN_MSIOF1_SYNC_A = 1030,
	FN_TS_SDEN0_A = 1031,
	FN_STP_ISEN_0_A = 1032,
	FN_RIF0_SYNC_A = 1033,
	FN_RIF2_SYNC_A = 1034,
	FN_IP12_31_28 = 1035,
	FN_SCK2 = 1036,
	FN_SCIF_CLK_B = 1037,
	FN_MSIOF1_SCK_B = 1038,
	FN_TS_SCK1_C = 1039,
	FN_STP_ISCLK_1_C = 1040,
	FN_RIF1_CLK_B = 1041,
	FN_ADICLK = 1042,
	FN_IP13_31_28 = 1043,
	FN_MSIOF0_SYNC = 1044,
	FN_AUDIO_CLKOUT_A = 1045,
	FN_TX5_B = 1046,
	FN_BPFCLK_D = 1047,
	FN_IP14_31_28 = 1048,
	FN_SSI_SDATA0 = 1049,
	FN_MSIOF1_SS2_F = 1050,
	FN_IP15_31_28 = 1051,
	FN_SSI_SDATA4 = 1052,
	FN_HSCK2_A = 1053,
	FN_MSIOF1_RXD_A = 1054,
	FN_TS_SPSYNC0_A = 1055,
	FN_STP_ISSYNC_0_A = 1056,
	FN_RIF0_D0_A = 1057,
	FN_RIF2_D1_A = 1058,
	FN_IP16_3_0 = 1059,
	FN_SSI_SCK6 = 1060,
	FN_SIM0_RST_D = 1061,
	FN_IP17_3_0 = 1062,
	FN_AUDIO_CLKA_A = 1063,
	FN_IP18_3_0 = 1064,
	FN_GP6_30 = 1065,
	FN_AUDIO_CLKOUT2_B = 1066,
	FN_SSI_SCK9_B = 1067,
	FN_TS_SDEN0_E = 1068,
	FN_STP_ISEN_0_E = 1069,
	FN_RIF2_D0_B = 1070,
	FN_TPU0TO2 = 1071,
	FN_FMCLK_C = 1072,
	FN_FMCLK_D = 1073,
	FN_IP16_7_4 = 1074,
	FN_SSI_WS6 = 1075,
	FN_SIM0_D_D = 1076,
	FN_IP17_7_4 = 1077,
	FN_AUDIO_CLKB_B = 1078,
	FN_SCIF_CLK_A = 1079,
	FN_STP_IVCXO27_1_D = 1080,
	FN_REMOCON_A = 1081,
	FN_TCLK1_A = 1082,
	FN_IP18_7_4 = 1083,
	FN_GP6_31 = 1084,
	FN_AUDIO_CLKOUT3_B = 1085,
	FN_SSI_WS9_B = 1086,
	FN_TS_SPSYNC0_E = 1087,
	FN_STP_ISSYNC_0_E = 1088,
	FN_RIF2_D1_B = 1089,
	FN_TPU0TO3 = 1090,
	FN_FMIN_C = 1091,
	FN_FMIN_D = 1092,
	FN_IP16_11_8 = 1093,
	FN_SSI_SDATA6 = 1094,
	FN_SIM0_CLK_D = 1095,
	FN_IP17_11_8 = 1096,
	FN_USB0_PWEN = 1097,
	FN_SIM0_RST_C = 1098,
	FN_TS_SCK1_D = 1099,
	FN_STP_ISCLK_1_D = 1100,
	FN_BPFCLK_B = 1101,
	FN_RIF3_CLK_B = 1102,
	FN_HSCK2_C = 1103,
	FN_IP16_15_12 = 1104,
	FN_SSI_SCK78 = 1105,
	FN_HRX2_B = 1106,
	FN_MSIOF1_SCK_C = 1107,
	FN_TS_SCK1_A = 1108,
	FN_STP_ISCLK_1_A = 1109,
	FN_RIF1_CLK_A = 1110,
	FN_RIF3_CLK_A = 1111,
	FN_IP17_15_12 = 1112,
	FN_USB0_OVC = 1113,
	FN_SIM0_D_C = 1114,
	FN_TS_SDAT1_D = 1115,
	FN_STP_ISD_1_D = 1116,
	FN_RIF3_SYNC_B = 1117,
	FN_HRX2_C = 1118,
	FN_IP16_19_16 = 1119,
	FN_SSI_WS78 = 1120,
	FN_HTX2_B = 1121,
	FN_MSIOF1_SYNC_C = 1122,
	FN_TS_SDAT1_A = 1123,
	FN_STP_ISD_1_A = 1124,
	FN_RIF1_SYNC_A = 1125,
	FN_RIF3_SYNC_A = 1126,
	FN_IP17_19_16 = 1127,
	FN_USB1_PWEN = 1128,
	FN_SIM0_CLK_C = 1129,
	FN_SSI_SCK1_A = 1130,
	FN_TS_SCK0_E = 1131,
	FN_STP_ISCLK_0_E = 1132,
	FN_FMCLK_B = 1133,
	FN_RIF2_CLK_B = 1134,
	FN_SPEEDIN_A = 1135,
	FN_HTX2_C = 1136,
	FN_IP16_23_20 = 1137,
	FN_SSI_SDATA7 = 1138,
	FN_HCTS2_N_B = 1139,
	FN_MSIOF1_RXD_C = 1140,
	FN_TS_SDEN1_A = 1141,
	FN_STP_ISEN_1_A = 1142,
	FN_RIF1_D0_A = 1143,
	FN_RIF3_D0_A = 1144,
	FN_TCLK2_A = 1145,
	FN_IP17_23_20 = 1146,
	FN_USB1_OVC = 1147,
	FN_MSIOF1_SS2_C = 1148,
	FN_SSI_WS1_A = 1149,
	FN_TS_SDAT0_E = 1150,
	FN_STP_ISD_0_E = 1151,
	FN_FMIN_B = 1152,
	FN_RIF2_SYNC_B = 1153,
	FN_REMOCON_B = 1154,
	FN_HCTS2_N_C = 1155,
	FN_IP16_27_24 = 1156,
	FN_SSI_SDATA8 = 1157,
	FN_HRTS2_N_B = 1158,
	FN_MSIOF1_TXD_C = 1159,
	FN_TS_SPSYNC1_A = 1160,
	FN_STP_ISSYNC_1_A = 1161,
	FN_RIF1_D1_A = 1162,
	FN_RIF3_D1_A = 1163,
	FN_IP17_27_24 = 1164,
	FN_USB30_PWEN = 1165,
	FN_AUDIO_CLKOUT_B = 1166,
	FN_SSI_SCK2_B = 1167,
	FN_TS_SDEN1_D = 1168,
	FN_STP_ISEN_1_D = 1169,
	FN_STP_OPWM_0_E = 1170,
	FN_RIF3_D0_B = 1171,
	FN_TCLK2_B = 1172,
	FN_TPU0TO0 = 1173,
	FN_BPFCLK_C = 1174,
	FN_HRTS2_N_C = 1175,
	FN_IP16_31_28 = 1176,
	FN_SSI_SDATA9_A = 1177,
	FN_HSCK2_B = 1178,
	FN_MSIOF1_SS1_C = 1179,
	FN_HSCK1_A = 1180,
	FN_SSI_WS1_B = 1181,
	FN_SCK1 = 1182,
	FN_STP_IVCXO27_1_A = 1183,
	FN_SCK5_A = 1184,
	FN_IP17_31_28 = 1185,
	FN_USB30_OVC = 1186,
	FN_AUDIO_CLKOUT1_B = 1187,
	FN_SSI_WS2_B = 1188,
	FN_TS_SPSYNC1_D = 1189,
	FN_STP_ISSYNC_1_D = 1190,
	FN_STP_IVCXO27_0_E = 1191,
	FN_RIF3_D1_B = 1192,
	FN_FSO_TOE_N = 1193,
	FN_TPU0TO1 = 1194,
	FN_SEL_MSIOF3_0 = 1195,
	FN_SEL_MSIOF3_1 = 1196,
	FN_SEL_MSIOF3_2 = 1197,
	FN_SEL_MSIOF3_3 = 1198,
	FN_SEL_MSIOF3_4 = 1199,
	FN_SEL_TSIF1_0 = 1200,
	FN_SEL_TSIF1_1 = 1201,
	FN_SEL_TSIF1_2 = 1202,
	FN_SEL_TSIF1_3 = 1203,
	FN_I2C_SEL_5_0 = 1204,
	FN_I2C_SEL_5_1 = 1205,
	FN_I2C_SEL_3_0 = 1206,
	FN_I2C_SEL_3_1 = 1207,
	FN_SEL_TSIF0_0 = 1208,
	FN_SEL_TSIF0_1 = 1209,
	FN_SEL_TSIF0_2 = 1210,
	FN_SEL_TSIF0_3 = 1211,
	FN_SEL_TSIF0_4 = 1212,
	FN_I2C_SEL_0_0 = 1213,
	FN_I2C_SEL_0_1 = 1214,
	FN_SEL_MSIOF2_0 = 1215,
	FN_SEL_MSIOF2_1 = 1216,
	FN_SEL_MSIOF2_2 = 1217,
	FN_SEL_MSIOF2_3 = 1218,
	FN_SEL_FM_0 = 1219,
	FN_SEL_FM_1 = 1220,
	FN_SEL_FM_2 = 1221,
	FN_SEL_FM_3 = 1222,
	FN_SEL_MSIOF1_0 = 1223,
	FN_SEL_MSIOF1_1 = 1224,
	FN_SEL_MSIOF1_2 = 1225,
	FN_SEL_MSIOF1_3 = 1226,
	FN_SEL_MSIOF1_4 = 1227,
	FN_SEL_MSIOF1_5 = 1228,
	FN_SEL_MSIOF1_6 = 1229,
	FN_SEL_TIMER_TMU_0 = 1230,
	FN_SEL_TIMER_TMU_1 = 1231,
	FN_SEL_SCIF5_0 = 1232,
	FN_SEL_SCIF5_1 = 1233,
	FN_SEL_SSP1_1_0 = 1234,
	FN_SEL_SSP1_1_1 = 1235,
	FN_SEL_SSP1_1_2 = 1236,
	FN_SEL_SSP1_1_3 = 1237,
	FN_SEL_I2C6_0 = 1238,
	FN_SEL_I2C6_1 = 1239,
	FN_SEL_I2C6_2 = 1240,
	FN_SEL_LBSC_0 = 1241,
	FN_SEL_LBSC_1 = 1242,
	FN_SEL_SSP1_0_0 = 1243,
	FN_SEL_SSP1_0_1 = 1244,
	FN_SEL_SSP1_0_2 = 1245,
	FN_SEL_SSP1_0_3 = 1246,
	FN_SEL_SSP1_0_4 = 1247,
	FN_SEL_IEBUS_0 = 1248,
	FN_SEL_IEBUS_1 = 1249,
	FN_SEL_NDF_0 = 1250,
	FN_SEL_NDF_1 = 1251,
	FN_SEL_I2C2_0 = 1252,
	FN_SEL_I2C2_1 = 1253,
	FN_SEL_SSI2_0 = 1254,
	FN_SEL_SSI2_1 = 1255,
	FN_SEL_I2C1_0 = 1256,
	FN_SEL_I2C1_1 = 1257,
	FN_SEL_SSI1_0 = 1258,
	FN_SEL_SSI1_1 = 1259,
	FN_SEL_SSI9_0 = 1260,
	FN_SEL_SSI9_1 = 1261,
	FN_SEL_HSCIF4_0 = 1262,
	FN_SEL_HSCIF4_1 = 1263,
	FN_SEL_SPEED_PULSE_0 = 1264,
	FN_SEL_SPEED_PULSE_1 = 1265,
	FN_SEL_TIMER_TMU2_0 = 1266,
	FN_SEL_TIMER_TMU2_1 = 1267,
	FN_SEL_HSCIF3_0 = 1268,
	FN_SEL_HSCIF3_1 = 1269,
	FN_SEL_HSCIF3_2 = 1270,
	FN_SEL_HSCIF3_3 = 1271,
	FN_SEL_SIMCARD_0 = 1272,
	FN_SEL_SIMCARD_1 = 1273,
	FN_SEL_SIMCARD_2 = 1274,
	FN_SEL_SIMCARD_3 = 1275,
	FN_SEL_ADGB_0 = 1276,
	FN_SEL_ADGB_1 = 1277,
	FN_SEL_ADGC_0 = 1278,
	FN_SEL_ADGC_1 = 1279,
	FN_SEL_HSCIF1_0 = 1280,
	FN_SEL_HSCIF1_1 = 1281,
	FN_SEL_SDHI2_0 = 1282,
	FN_SEL_SDHI2_1 = 1283,
	FN_SEL_SCIF4_0 = 1284,
	FN_SEL_SCIF4_1 = 1285,
	FN_SEL_SCIF4_2 = 1286,
	FN_SEL_HSCIF2_0 = 1287,
	FN_SEL_HSCIF2_1 = 1288,
	FN_SEL_HSCIF2_2 = 1289,
	FN_SEL_SCIF3_0 = 1290,
	FN_SEL_SCIF3_1 = 1291,
	FN_SEL_ETHERAVB_0 = 1292,
	FN_SEL_ETHERAVB_1 = 1293,
	FN_SEL_SCIF2_0 = 1294,
	FN_SEL_SCIF2_1 = 1295,
	FN_SEL_DRIF3_0 = 1296,
	FN_SEL_DRIF3_1 = 1297,
	FN_SEL_SCIF1_0 = 1298,
	FN_SEL_SCIF1_1 = 1299,
	FN_SEL_DRIF2_0 = 1300,
	FN_SEL_DRIF2_1 = 1301,
	FN_SEL_SCIF_0 = 1302,
	FN_SEL_SCIF_1 = 1303,
	FN_SEL_DRIF1_0 = 1304,
	FN_SEL_DRIF1_1 = 1305,
	FN_SEL_DRIF1_2 = 1306,
	FN_SEL_REMOCON_0 = 1307,
	FN_SEL_REMOCON_1 = 1308,
	FN_SEL_DRIF0_0 = 1309,
	FN_SEL_DRIF0_1 = 1310,
	FN_SEL_DRIF0_2 = 1311,
	FN_SEL_RCAN0_0 = 1312,
	FN_SEL_RCAN0_1 = 1313,
	FN_SEL_CANFD0_0 = 1314,
	FN_SEL_CANFD0_1 = 1315,
	FN_SEL_PWM6_0 = 1316,
	FN_SEL_PWM6_1 = 1317,
	FN_SEL_ADGA_0 = 1318,
	FN_SEL_ADGA_1 = 1319,
	FN_SEL_ADGA_2 = 1320,
	FN_SEL_ADGA_3 = 1321,
	FN_SEL_PWM5_0 = 1322,
	FN_SEL_PWM5_1 = 1323,
	FN_SEL_PWM4_0 = 1324,
	FN_SEL_PWM4_1 = 1325,
	FN_SEL_PWM3_0 = 1326,
	FN_SEL_PWM3_1 = 1327,
	FN_SEL_PWM2_0 = 1328,
	FN_SEL_PWM2_1 = 1329,
	FN_SEL_PWM1_0 = 1330,
	FN_SEL_PWM1_1 = 1331,
	FN_SEL_VIN4_0 = 1332,
	FN_SEL_VIN4_1 = 1333,
	PINMUX_FUNCTION_END = 1334,
	PINMUX_MARK_BEGIN = 1335,
	CLKOUT_MARK = 1336,
	MSIOF0_RXD_MARK = 1337,
	MSIOF0_TXD_MARK = 1338,
	MSIOF0_SCK_MARK = 1339,
	SSI_SDATA5_MARK = 1340,
	SSI_WS5_MARK = 1341,
	SSI_SCK5_MARK = 1342,
	GP7_03_MARK = 1343,
	GP7_02_MARK = 1344,
	AVS2_MARK = 1345,
	AVS1_MARK = 1346,
	IP0_3_0_MARK = 1347,
	AVB_MDC_MARK = 1348,
	MSIOF2_SS2_C_MARK = 1349,
	IP1_3_0_MARK = 1350,
	IRQ2_MARK = 1351,
	QCPV_QDE_MARK = 1352,
	DU_EXODDF_DU_ODDF_DISP_CDE_MARK = 1353,
	VI4_DATA2_B_MARK = 1354,
	MSIOF3_SYNC_E_MARK = 1355,
	PWM3_B_MARK = 1356,
	IP2_3_0_MARK = 1357,
	A1_MARK = 1358,
	LCDOUT17_MARK = 1359,
	MSIOF3_TXD_B_MARK = 1360,
	VI4_DATA9_MARK = 1361,
	DU_DB1_MARK = 1362,
	PWM4_A_MARK = 1363,
	IP3_3_0_MARK = 1364,
	A9_MARK = 1365,
	MSIOF2_SCK_A_MARK = 1366,
	CTS4_N_B_MARK = 1367,
	VI5_VSYNC_N_MARK = 1368,
	IP0_7_4_MARK = 1369,
	AVB_MAGIC_MARK = 1370,
	MSIOF2_SS1_C_MARK = 1371,
	SCK4_A_MARK = 1372,
	IP1_7_4_MARK = 1373,
	IRQ3_MARK = 1374,
	QSTVB_QVE_MARK = 1375,
	DU_DOTCLKOUT1_MARK = 1376,
	VI4_DATA3_B_MARK = 1377,
	MSIOF3_SCK_E_MARK = 1378,
	PWM4_B_MARK = 1379,
	IP2_7_4_MARK = 1380,
	A2_MARK = 1381,
	LCDOUT18_MARK = 1382,
	MSIOF3_SCK_B_MARK = 1383,
	VI4_DATA10_MARK = 1384,
	DU_DB2_MARK = 1385,
	PWM5_A_MARK = 1386,
	IP3_7_4_MARK = 1387,
	A10_MARK = 1388,
	MSIOF2_RXD_A_MARK = 1389,
	RTS4_N_B_MARK = 1390,
	VI5_HSYNC_N_MARK = 1391,
	IP0_11_8_MARK = 1392,
	AVB_PHY_INT_MARK = 1393,
	MSIOF2_SYNC_C_MARK = 1394,
	RX4_A_MARK = 1395,
	IP1_11_8_MARK = 1396,
	IRQ4_MARK = 1397,
	QSTH_QHS_MARK = 1398,
	DU_EXHSYNC_DU_HSYNC_MARK = 1399,
	VI4_DATA4_B_MARK = 1400,
	MSIOF3_RXD_E_MARK = 1401,
	PWM5_B_MARK = 1402,
	IP2_11_8_MARK = 1403,
	A3_MARK = 1404,
	LCDOUT19_MARK = 1405,
	MSIOF3_RXD_B_MARK = 1406,
	VI4_DATA11_MARK = 1407,
	DU_DB3_MARK = 1408,
	PWM6_A_MARK = 1409,
	IP3_11_8_MARK = 1410,
	A11_MARK = 1411,
	TX3_B_MARK = 1412,
	MSIOF2_TXD_A_MARK = 1413,
	HTX4_B_MARK = 1414,
	HSCK4_MARK = 1415,
	VI5_FIELD_MARK = 1416,
	SCL6_A_MARK = 1417,
	AVB_AVTP_CAPTURE_B_MARK = 1418,
	PWM2_B_MARK = 1419,
	IP0_15_12_MARK = 1420,
	AVB_LINK_MARK = 1421,
	MSIOF2_SCK_C_MARK = 1422,
	TX4_A_MARK = 1423,
	IP1_15_12_MARK = 1424,
	IRQ5_MARK = 1425,
	QSTB_QHE_MARK = 1426,
	DU_EXVSYNC_DU_VSYNC_MARK = 1427,
	VI4_DATA5_B_MARK = 1428,
	MSIOF3_TXD_E_MARK = 1429,
	PWM6_B_MARK = 1430,
	IP2_15_12_MARK = 1431,
	A4_MARK = 1432,
	LCDOUT20_MARK = 1433,
	MSIOF3_SS1_B_MARK = 1434,
	VI4_DATA12_MARK = 1435,
	VI5_DATA12_MARK = 1436,
	DU_DB4_MARK = 1437,
	IP3_15_12_MARK = 1438,
	A12_MARK = 1439,
	LCDOUT12_MARK = 1440,
	MSIOF3_SCK_C_MARK = 1441,
	HRX4_A_MARK = 1442,
	VI5_DATA8_MARK = 1443,
	DU_DG4_MARK = 1444,
	IP0_19_16_MARK = 1445,
	AVB_AVTP_MATCH_A_MARK = 1446,
	MSIOF2_RXD_C_MARK = 1447,
	CTS4_N_A_MARK = 1448,
	IP1_19_16_MARK = 1449,
	PWM0_MARK = 1450,
	AVB_AVTP_PPS_MARK = 1451,
	VI4_DATA6_B_MARK = 1452,
	IECLK_B_MARK = 1453,
	IP2_19_16_MARK = 1454,
	A5_MARK = 1455,
	LCDOUT21_MARK = 1456,
	MSIOF3_SS2_B_MARK = 1457,
	SCK4_B_MARK = 1458,
	VI4_DATA13_MARK = 1459,
	VI5_DATA13_MARK = 1460,
	DU_DB5_MARK = 1461,
	IP3_19_16_MARK = 1462,
	A13_MARK = 1463,
	LCDOUT13_MARK = 1464,
	MSIOF3_SYNC_C_MARK = 1465,
	HTX4_A_MARK = 1466,
	VI5_DATA9_MARK = 1467,
	DU_DG5_MARK = 1468,
	IP0_23_20_MARK = 1469,
	AVB_AVTP_CAPTURE_A_MARK = 1470,
	MSIOF2_TXD_C_MARK = 1471,
	RTS4_N_A_MARK = 1472,
	IP1_23_20_MARK = 1473,
	PWM1_A_MARK = 1474,
	HRX3_D_MARK = 1475,
	VI4_DATA7_B_MARK = 1476,
	IERX_B_MARK = 1477,
	IP2_23_20_MARK = 1478,
	A6_MARK = 1479,
	LCDOUT22_MARK = 1480,
	MSIOF2_SS1_A_MARK = 1481,
	RX4_B_MARK = 1482,
	VI4_DATA14_MARK = 1483,
	VI5_DATA14_MARK = 1484,
	DU_DB6_MARK = 1485,
	IP3_23_20_MARK = 1486,
	A14_MARK = 1487,
	LCDOUT14_MARK = 1488,
	MSIOF3_RXD_C_MARK = 1489,
	HCTS4_N_MARK = 1490,
	VI5_DATA10_MARK = 1491,
	DU_DG6_MARK = 1492,
	IP0_27_24_MARK = 1493,
	IRQ0_MARK = 1494,
	QPOLB_MARK = 1495,
	DU_CDE_MARK = 1496,
	VI4_DATA0_B_MARK = 1497,
	CAN0_TX_B_MARK = 1498,
	CANFD0_TX_B_MARK = 1499,
	MSIOF3_SS2_E_MARK = 1500,
	IP1_27_24_MARK = 1501,
	PWM2_A_MARK = 1502,
	HTX3_D_MARK = 1503,
	IETX_B_MARK = 1504,
	IP2_27_24_MARK = 1505,
	A7_MARK = 1506,
	LCDOUT23_MARK = 1507,
	MSIOF2_SS2_A_MARK = 1508,
	TX4_B_MARK = 1509,
	VI4_DATA15_MARK = 1510,
	VI5_DATA15_MARK = 1511,
	DU_DB7_MARK = 1512,
	IP3_27_24_MARK = 1513,
	A15_MARK = 1514,
	LCDOUT15_MARK = 1515,
	MSIOF3_TXD_C_MARK = 1516,
	HRTS4_N_MARK = 1517,
	VI5_DATA11_MARK = 1518,
	DU_DG7_MARK = 1519,
	IP0_31_28_MARK = 1520,
	IRQ1_MARK = 1521,
	QPOLA_MARK = 1522,
	DU_DISP_MARK = 1523,
	VI4_DATA1_B_MARK = 1524,
	CAN0_RX_B_MARK = 1525,
	CANFD0_RX_B_MARK = 1526,
	MSIOF3_SS1_E_MARK = 1527,
	IP1_31_28_MARK = 1528,
	A0_MARK = 1529,
	LCDOUT16_MARK = 1530,
	MSIOF3_SYNC_B_MARK = 1531,
	VI4_DATA8_MARK = 1532,
	DU_DB0_MARK = 1533,
	PWM3_A_MARK = 1534,
	IP2_31_28_MARK = 1535,
	A8_MARK = 1536,
	RX3_B_MARK = 1537,
	MSIOF2_SYNC_A_MARK = 1538,
	HRX4_B_MARK = 1539,
	SDA6_A_MARK = 1540,
	AVB_AVTP_MATCH_B_MARK = 1541,
	PWM1_B_MARK = 1542,
	IP3_31_28_MARK = 1543,
	A16_MARK = 1544,
	LCDOUT8_MARK = 1545,
	VI4_FIELD_MARK = 1546,
	DU_DG0_MARK = 1547,
	IP4_3_0_MARK = 1548,
	A17_MARK = 1549,
	LCDOUT9_MARK = 1550,
	VI4_VSYNC_N_MARK = 1551,
	DU_DG1_MARK = 1552,
	IP5_3_0_MARK = 1553,
	WE0_N_MARK = 1554,
	MSIOF3_TXD_D_MARK = 1555,
	CTS3_N_MARK = 1556,
	HCTS3_N_MARK = 1557,
	SCL6_B_MARK = 1558,
	CAN_CLK_MARK = 1559,
	IECLK_A_MARK = 1560,
	IP6_3_0_MARK = 1561,
	D5_MARK = 1562,
	MSIOF2_SYNC_B_MARK = 1563,
	VI4_DATA21_MARK = 1564,
	VI5_DATA5_MARK = 1565,
	IP7_3_0_MARK = 1566,
	D13_MARK = 1567,
	LCDOUT5_MARK = 1568,
	MSIOF2_SS2_D_MARK = 1569,
	TX4_C_MARK = 1570,
	VI4_DATA5_A_MARK = 1571,
	DU_DR5_MARK = 1572,
	IP4_7_4_MARK = 1573,
	A18_MARK = 1574,
	LCDOUT10_MARK = 1575,
	VI4_HSYNC_N_MARK = 1576,
	DU_DG2_MARK = 1577,
	IP5_7_4_MARK = 1578,
	WE1_N_MARK = 1579,
	MSIOF3_SS1_D_MARK = 1580,
	RTS3_N_MARK = 1581,
	HRTS3_N_MARK = 1582,
	SDA6_B_MARK = 1583,
	CAN1_RX_MARK = 1584,
	CANFD1_RX_MARK = 1585,
	IERX_A_MARK = 1586,
	IP6_7_4_MARK = 1587,
	D6_MARK = 1588,
	MSIOF2_RXD_B_MARK = 1589,
	VI4_DATA22_MARK = 1590,
	VI5_DATA6_MARK = 1591,
	IP7_7_4_MARK = 1592,
	D14_MARK = 1593,
	LCDOUT6_MARK = 1594,
	MSIOF3_SS1_A_MARK = 1595,
	HRX3_C_MARK = 1596,
	VI4_DATA6_A_MARK = 1597,
	DU_DR6_MARK = 1598,
	SCL6_C_MARK = 1599,
	IP4_11_8_MARK = 1600,
	A19_MARK = 1601,
	LCDOUT11_MARK = 1602,
	VI4_CLKENB_MARK = 1603,
	DU_DG3_MARK = 1604,
	IP5_11_8_MARK = 1605,
	EX_WAIT0_A_MARK = 1606,
	QCLK_MARK = 1607,
	VI4_CLK_MARK = 1608,
	DU_DOTCLKOUT0_MARK = 1609,
	IP6_11_8_MARK = 1610,
	D7_MARK = 1611,
	MSIOF2_TXD_B_MARK = 1612,
	VI4_DATA23_MARK = 1613,
	VI5_DATA7_MARK = 1614,
	IP7_11_8_MARK = 1615,
	D15_MARK = 1616,
	LCDOUT7_MARK = 1617,
	MSIOF3_SS2_A_MARK = 1618,
	HTX3_C_MARK = 1619,
	VI4_DATA7_A_MARK = 1620,
	DU_DR7_MARK = 1621,
	SDA6_C_MARK = 1622,
	IP4_15_12_MARK = 1623,
	CS0_N_MARK = 1624,
	VI5_CLKENB_MARK = 1625,
	IP5_15_12_MARK = 1626,
	D0_MARK = 1627,
	MSIOF2_SS1_B_MARK = 1628,
	MSIOF3_SCK_A_MARK = 1629,
	VI4_DATA16_MARK = 1630,
	VI5_DATA0_MARK = 1631,
	IP6_15_12_MARK = 1632,
	D8_MARK = 1633,
	LCDOUT0_MARK = 1634,
	MSIOF2_SCK_D_MARK = 1635,
	SCK4_C_MARK = 1636,
	VI4_DATA0_A_MARK = 1637,
	DU_DR0_MARK = 1638,
	IP4_19_16_MARK = 1639,
	CS1_N_MARK = 1640,
	VI5_CLK_MARK = 1641,
	EX_WAIT0_B_MARK = 1642,
	IP5_19_16_MARK = 1643,
	D1_MARK = 1644,
	MSIOF2_SS2_B_MARK = 1645,
	MSIOF3_SYNC_A_MARK = 1646,
	VI4_DATA17_MARK = 1647,
	VI5_DATA1_MARK = 1648,
	IP6_19_16_MARK = 1649,
	D9_MARK = 1650,
	LCDOUT1_MARK = 1651,
	MSIOF2_SYNC_D_MARK = 1652,
	VI4_DATA1_A_MARK = 1653,
	DU_DR1_MARK = 1654,
	IP7_19_16_MARK = 1655,
	SD0_CLK_MARK = 1656,
	MSIOF1_SCK_E_MARK = 1657,
	STP_OPWM_0_B_MARK = 1658,
	IP4_23_20_MARK = 1659,
	BS_N_MARK = 1660,
	QSTVA_QVS_MARK = 1661,
	MSIOF3_SCK_D_MARK = 1662,
	SCK3_MARK = 1663,
	HSCK3_MARK = 1664,
	CAN1_TX_MARK = 1665,
	CANFD1_TX_MARK = 1666,
	IETX_A_MARK = 1667,
	IP5_23_20_MARK = 1668,
	D2_MARK = 1669,
	MSIOF3_RXD_A_MARK = 1670,
	VI4_DATA18_MARK = 1671,
	VI5_DATA2_MARK = 1672,
	IP6_23_20_MARK = 1673,
	D10_MARK = 1674,
	LCDOUT2_MARK = 1675,
	MSIOF2_RXD_D_MARK = 1676,
	HRX3_B_MARK = 1677,
	VI4_DATA2_A_MARK = 1678,
	CTS4_N_C_MARK = 1679,
	DU_DR2_MARK = 1680,
	IP7_23_20_MARK = 1681,
	SD0_CMD_MARK = 1682,
	MSIOF1_SYNC_E_MARK = 1683,
	STP_IVCXO27_0_B_MARK = 1684,
	IP4_27_24_MARK = 1685,
	RD_N_MARK = 1686,
	MSIOF3_SYNC_D_MARK = 1687,
	RX3_A_MARK = 1688,
	HRX3_A_MARK = 1689,
	CAN0_TX_A_MARK = 1690,
	CANFD0_TX_A_MARK = 1691,
	IP5_27_24_MARK = 1692,
	D3_MARK = 1693,
	MSIOF3_TXD_A_MARK = 1694,
	VI4_DATA19_MARK = 1695,
	VI5_DATA3_MARK = 1696,
	IP6_27_24_MARK = 1697,
	D11_MARK = 1698,
	LCDOUT3_MARK = 1699,
	MSIOF2_TXD_D_MARK = 1700,
	HTX3_B_MARK = 1701,
	VI4_DATA3_A_MARK = 1702,
	RTS4_N_C_MARK = 1703,
	DU_DR3_MARK = 1704,
	IP7_27_24_MARK = 1705,
	SD0_DAT0_MARK = 1706,
	MSIOF1_RXD_E_MARK = 1707,
	TS_SCK0_B_MARK = 1708,
	STP_ISCLK_0_B_MARK = 1709,
	IP4_31_28_MARK = 1710,
	RD_WR_N_MARK = 1711,
	MSIOF3_RXD_D_MARK = 1712,
	TX3_A_MARK = 1713,
	HTX3_A_MARK = 1714,
	CAN0_RX_A_MARK = 1715,
	CANFD0_RX_A_MARK = 1716,
	IP5_31_28_MARK = 1717,
	D4_MARK = 1718,
	MSIOF2_SCK_B_MARK = 1719,
	VI4_DATA20_MARK = 1720,
	VI5_DATA4_MARK = 1721,
	IP6_31_28_MARK = 1722,
	D12_MARK = 1723,
	LCDOUT4_MARK = 1724,
	MSIOF2_SS1_D_MARK = 1725,
	RX4_C_MARK = 1726,
	VI4_DATA4_A_MARK = 1727,
	DU_DR4_MARK = 1728,
	IP7_31_28_MARK = 1729,
	SD0_DAT1_MARK = 1730,
	MSIOF1_TXD_E_MARK = 1731,
	TS_SPSYNC0_B_MARK = 1732,
	STP_ISSYNC_0_B_MARK = 1733,
	IP8_3_0_MARK = 1734,
	SD0_DAT2_MARK = 1735,
	MSIOF1_SS1_E_MARK = 1736,
	TS_SDAT0_B_MARK = 1737,
	STP_ISD_0_B_MARK = 1738,
	IP9_3_0_MARK = 1739,
	SD2_CLK_MARK = 1740,
	NFDATA8_MARK = 1741,
	IP10_3_0_MARK = 1742,
	SD3_CMD_MARK = 1743,
	NFRE_N_MARK = 1744,
	IP11_3_0_MARK = 1745,
	SD3_DAT7_MARK = 1746,
	SD3_WP_MARK = 1747,
	NFDATA7_MARK = 1748,
	IP8_7_4_MARK = 1749,
	SD0_DAT3_MARK = 1750,
	MSIOF1_SS2_E_MARK = 1751,
	TS_SDEN0_B_MARK = 1752,
	STP_ISEN_0_B_MARK = 1753,
	IP9_7_4_MARK = 1754,
	SD2_CMD_MARK = 1755,
	NFDATA9_MARK = 1756,
	IP10_7_4_MARK = 1757,
	SD3_DAT0_MARK = 1758,
	NFDATA0_MARK = 1759,
	IP11_7_4_MARK = 1760,
	SD3_DS_MARK = 1761,
	NFCLE_MARK = 1762,
	IP8_11_8_MARK = 1763,
	SD1_CLK_MARK = 1764,
	MSIOF1_SCK_G_MARK = 1765,
	SIM0_CLK_A_MARK = 1766,
	IP9_11_8_MARK = 1767,
	SD2_DAT0_MARK = 1768,
	NFDATA10_MARK = 1769,
	IP10_11_8_MARK = 1770,
	SD3_DAT1_MARK = 1771,
	NFDATA1_MARK = 1772,
	IP11_11_8_MARK = 1773,
	SD0_CD_MARK = 1774,
	NFDATA14_A_MARK = 1775,
	SCL2_B_MARK = 1776,
	SIM0_RST_A_MARK = 1777,
	IP8_15_12_MARK = 1778,
	SD1_CMD_MARK = 1779,
	MSIOF1_SYNC_G_MARK = 1780,
	NFCE_N_B_MARK = 1781,
	SIM0_D_A_MARK = 1782,
	STP_IVCXO27_1_B_MARK = 1783,
	IP9_15_12_MARK = 1784,
	SD2_DAT1_MARK = 1785,
	NFDATA11_MARK = 1786,
	IP10_15_12_MARK = 1787,
	SD3_DAT2_MARK = 1788,
	NFDATA2_MARK = 1789,
	IP11_15_12_MARK = 1790,
	SD0_WP_MARK = 1791,
	NFDATA15_A_MARK = 1792,
	SDA2_B_MARK = 1793,
	IP8_19_16_MARK = 1794,
	SD1_DAT0_MARK = 1795,
	SD2_DAT4_MARK = 1796,
	MSIOF1_RXD_G_MARK = 1797,
	NFWP_N_B_MARK = 1798,
	TS_SCK1_B_MARK = 1799,
	STP_ISCLK_1_B_MARK = 1800,
	IP9_19_16_MARK = 1801,
	SD2_DAT2_MARK = 1802,
	NFDATA12_MARK = 1803,
	IP10_19_16_MARK = 1804,
	SD3_DAT3_MARK = 1805,
	NFDATA3_MARK = 1806,
	IP11_19_16_MARK = 1807,
	SD1_CD_MARK = 1808,
	NFRB_N_A_MARK = 1809,
	SIM0_CLK_B_MARK = 1810,
	IP8_23_20_MARK = 1811,
	SD1_DAT1_MARK = 1812,
	SD2_DAT5_MARK = 1813,
	MSIOF1_TXD_G_MARK = 1814,
	NFDATA14_B_MARK = 1815,
	TS_SPSYNC1_B_MARK = 1816,
	STP_ISSYNC_1_B_MARK = 1817,
	IP9_23_20_MARK = 1818,
	SD2_DAT3_MARK = 1819,
	NFDATA13_MARK = 1820,
	IP10_23_20_MARK = 1821,
	SD3_DAT4_MARK = 1822,
	SD2_CD_A_MARK = 1823,
	NFDATA4_MARK = 1824,
	IP11_23_20_MARK = 1825,
	SD1_WP_MARK = 1826,
	NFCE_N_A_MARK = 1827,
	SIM0_D_B_MARK = 1828,
	IP8_27_24_MARK = 1829,
	SD1_DAT2_MARK = 1830,
	SD2_DAT6_MARK = 1831,
	MSIOF1_SS1_G_MARK = 1832,
	NFDATA15_B_MARK = 1833,
	TS_SDAT1_B_MARK = 1834,
	STP_ISD_1_B_MARK = 1835,
	IP9_27_24_MARK = 1836,
	SD2_DS_MARK = 1837,
	NFALE_MARK = 1838,
	IP10_27_24_MARK = 1839,
	SD3_DAT5_MARK = 1840,
	SD2_WP_A_MARK = 1841,
	NFDATA5_MARK = 1842,
	IP11_27_24_MARK = 1843,
	SCK0_MARK = 1844,
	HSCK1_B_MARK = 1845,
	MSIOF1_SS2_B_MARK = 1846,
	AUDIO_CLKC_B_MARK = 1847,
	SDA2_A_MARK = 1848,
	SIM0_RST_B_MARK = 1849,
	STP_OPWM_0_C_MARK = 1850,
	RIF0_CLK_B_MARK = 1851,
	ADICHS2_MARK = 1852,
	SCK5_B_MARK = 1853,
	IP8_31_28_MARK = 1854,
	SD1_DAT3_MARK = 1855,
	SD2_DAT7_MARK = 1856,
	MSIOF1_SS2_G_MARK = 1857,
	NFRB_N_B_MARK = 1858,
	TS_SDEN1_B_MARK = 1859,
	STP_ISEN_1_B_MARK = 1860,
	IP9_31_28_MARK = 1861,
	SD3_CLK_MARK = 1862,
	NFWE_N_MARK = 1863,
	IP10_31_28_MARK = 1864,
	SD3_DAT6_MARK = 1865,
	SD3_CD_MARK = 1866,
	NFDATA6_MARK = 1867,
	IP11_31_28_MARK = 1868,
	RX0_MARK = 1869,
	HRX1_B_MARK = 1870,
	TS_SCK0_C_MARK = 1871,
	STP_ISCLK_0_C_MARK = 1872,
	RIF0_D0_B_MARK = 1873,
	IP12_3_0_MARK = 1874,
	TX0_MARK = 1875,
	HTX1_B_MARK = 1876,
	TS_SPSYNC0_C_MARK = 1877,
	STP_ISSYNC_0_C_MARK = 1878,
	RIF0_D1_B_MARK = 1879,
	IP13_3_0_MARK = 1880,
	TX2_A_MARK = 1881,
	SD2_CD_B_MARK = 1882,
	SCL1_A_MARK = 1883,
	FMCLK_A_MARK = 1884,
	RIF1_D1_C_MARK = 1885,
	FSO_CFE_0_N_MARK = 1886,
	IP14_3_0_MARK = 1887,
	MSIOF0_SS1_MARK = 1888,
	RX5_A_MARK = 1889,
	NFWP_N_A_MARK = 1890,
	AUDIO_CLKA_C_MARK = 1891,
	SSI_SCK2_A_MARK = 1892,
	STP_IVCXO27_0_C_MARK = 1893,
	AUDIO_CLKOUT3_A_MARK = 1894,
	TCLK1_B_MARK = 1895,
	IP15_3_0_MARK = 1896,
	SSI_SDATA1_A_MARK = 1897,
	IP12_7_4_MARK = 1898,
	CTS0_N_MARK = 1899,
	HCTS1_N_B_MARK = 1900,
	MSIOF1_SYNC_B_MARK = 1901,
	TS_SPSYNC1_C_MARK = 1902,
	STP_ISSYNC_1_C_MARK = 1903,
	RIF1_SYNC_B_MARK = 1904,
	AUDIO_CLKOUT_C_MARK = 1905,
	ADICS_SAMP_MARK = 1906,
	IP13_7_4_MARK = 1907,
	RX2_A_MARK = 1908,
	SD2_WP_B_MARK = 1909,
	SDA1_A_MARK = 1910,
	FMIN_A_MARK = 1911,
	RIF1_SYNC_C_MARK = 1912,
	FSO_CFE_1_N_MARK = 1913,
	IP14_7_4_MARK = 1914,
	MSIOF0_SS2_MARK = 1915,
	TX5_A_MARK = 1916,
	MSIOF1_SS2_D_MARK = 1917,
	AUDIO_CLKC_A_MARK = 1918,
	SSI_WS2_A_MARK = 1919,
	STP_OPWM_0_D_MARK = 1920,
	AUDIO_CLKOUT_D_MARK = 1921,
	SPEEDIN_B_MARK = 1922,
	IP15_7_4_MARK = 1923,
	SSI_SDATA2_A_MARK = 1924,
	SSI_SCK1_B_MARK = 1925,
	IP12_11_8_MARK = 1926,
	RTS0_N_MARK = 1927,
	HRTS1_N_B_MARK = 1928,
	MSIOF1_SS1_B_MARK = 1929,
	AUDIO_CLKA_B_MARK = 1930,
	SCL2_A_MARK = 1931,
	STP_IVCXO27_1_C_MARK = 1932,
	RIF0_SYNC_B_MARK = 1933,
	ADICHS1_MARK = 1934,
	IP13_11_8_MARK = 1935,
	HSCK0_MARK = 1936,
	MSIOF1_SCK_D_MARK = 1937,
	AUDIO_CLKB_A_MARK = 1938,
	SSI_SDATA1_B_MARK = 1939,
	TS_SCK0_D_MARK = 1940,
	STP_ISCLK_0_D_MARK = 1941,
	RIF0_CLK_C_MARK = 1942,
	RX5_B_MARK = 1943,
	IP14_11_8_MARK = 1944,
	MLB_CLK_MARK = 1945,
	MSIOF1_SCK_F_MARK = 1946,
	SCL1_B_MARK = 1947,
	IP15_11_8_MARK = 1948,
	SSI_SCK349_MARK = 1949,
	MSIOF1_SS1_A_MARK = 1950,
	STP_OPWM_0_A_MARK = 1951,
	IP12_15_12_MARK = 1952,
	RX1_A_MARK = 1953,
	HRX1_A_MARK = 1954,
	TS_SDAT0_C_MARK = 1955,
	STP_ISD_0_C_MARK = 1956,
	RIF1_CLK_C_MARK = 1957,
	IP13_15_12_MARK = 1958,
	HRX0_MARK = 1959,
	MSIOF1_RXD_D_MARK = 1960,
	SSI_SDATA2_B_MARK = 1961,
	TS_SDEN0_D_MARK = 1962,
	STP_ISEN_0_D_MARK = 1963,
	RIF0_D0_C_MARK = 1964,
	IP14_15_12_MARK = 1965,
	MLB_SIG_MARK = 1966,
	RX1_B_MARK = 1967,
	MSIOF1_SYNC_F_MARK = 1968,
	SDA1_B_MARK = 1969,
	IP15_15_12_MARK = 1970,
	SSI_WS349_MARK = 1971,
	HCTS2_N_A_MARK = 1972,
	MSIOF1_SS2_A_MARK = 1973,
	STP_IVCXO27_0_A_MARK = 1974,
	IP12_19_16_MARK = 1975,
	TX1_A_MARK = 1976,
	HTX1_A_MARK = 1977,
	TS_SDEN0_C_MARK = 1978,
	STP_ISEN_0_C_MARK = 1979,
	RIF1_D0_C_MARK = 1980,
	IP13_19_16_MARK = 1981,
	HTX0_MARK = 1982,
	MSIOF1_TXD_D_MARK = 1983,
	SSI_SDATA9_B_MARK = 1984,
	TS_SDAT0_D_MARK = 1985,
	STP_ISD_0_D_MARK = 1986,
	RIF0_D1_C_MARK = 1987,
	IP14_19_16_MARK = 1988,
	MLB_DAT_MARK = 1989,
	TX1_B_MARK = 1990,
	MSIOF1_RXD_F_MARK = 1991,
	IP15_19_16_MARK = 1992,
	SSI_SDATA3_MARK = 1993,
	HRTS2_N_A_MARK = 1994,
	MSIOF1_TXD_A_MARK = 1995,
	TS_SCK0_A_MARK = 1996,
	STP_ISCLK_0_A_MARK = 1997,
	RIF0_D1_A_MARK = 1998,
	RIF2_D0_A_MARK = 1999,
	IP12_23_20_MARK = 2000,
	CTS1_N_MARK = 2001,
	HCTS1_N_A_MARK = 2002,
	MSIOF1_RXD_B_MARK = 2003,
	TS_SDEN1_C_MARK = 2004,
	STP_ISEN_1_C_MARK = 2005,
	RIF1_D0_B_MARK = 2006,
	ADIDATA_MARK = 2007,
	IP13_23_20_MARK = 2008,
	HCTS0_N_MARK = 2009,
	RX2_B_MARK = 2010,
	MSIOF1_SYNC_D_MARK = 2011,
	SSI_SCK9_A_MARK = 2012,
	TS_SPSYNC0_D_MARK = 2013,
	STP_ISSYNC_0_D_MARK = 2014,
	RIF0_SYNC_C_MARK = 2015,
	AUDIO_CLKOUT1_A_MARK = 2016,
	IP14_23_20_MARK = 2017,
	SSI_SCK01239_MARK = 2018,
	MSIOF1_TXD_F_MARK = 2019,
	IP15_23_20_MARK = 2020,
	SSI_SCK4_MARK = 2021,
	HRX2_A_MARK = 2022,
	MSIOF1_SCK_A_MARK = 2023,
	TS_SDAT0_A_MARK = 2024,
	STP_ISD_0_A_MARK = 2025,
	RIF0_CLK_A_MARK = 2026,
	RIF2_CLK_A_MARK = 2027,
	IP12_27_24_MARK = 2028,
	RTS1_N_MARK = 2029,
	HRTS1_N_A_MARK = 2030,
	MSIOF1_TXD_B_MARK = 2031,
	TS_SDAT1_C_MARK = 2032,
	STP_ISD_1_C_MARK = 2033,
	RIF1_D1_B_MARK = 2034,
	ADICHS0_MARK = 2035,
	IP13_27_24_MARK = 2036,
	HRTS0_N_MARK = 2037,
	TX2_B_MARK = 2038,
	MSIOF1_SS1_D_MARK = 2039,
	SSI_WS9_A_MARK = 2040,
	STP_IVCXO27_0_D_MARK = 2041,
	BPFCLK_A_MARK = 2042,
	AUDIO_CLKOUT2_A_MARK = 2043,
	IP14_27_24_MARK = 2044,
	SSI_WS01239_MARK = 2045,
	MSIOF1_SS1_F_MARK = 2046,
	IP15_27_24_MARK = 2047,
	SSI_WS4_MARK = 2048,
	HTX2_A_MARK = 2049,
	MSIOF1_SYNC_A_MARK = 2050,
	TS_SDEN0_A_MARK = 2051,
	STP_ISEN_0_A_MARK = 2052,
	RIF0_SYNC_A_MARK = 2053,
	RIF2_SYNC_A_MARK = 2054,
	IP12_31_28_MARK = 2055,
	SCK2_MARK = 2056,
	SCIF_CLK_B_MARK = 2057,
	MSIOF1_SCK_B_MARK = 2058,
	TS_SCK1_C_MARK = 2059,
	STP_ISCLK_1_C_MARK = 2060,
	RIF1_CLK_B_MARK = 2061,
	ADICLK_MARK = 2062,
	IP13_31_28_MARK = 2063,
	MSIOF0_SYNC_MARK = 2064,
	AUDIO_CLKOUT_A_MARK = 2065,
	TX5_B_MARK = 2066,
	BPFCLK_D_MARK = 2067,
	IP14_31_28_MARK = 2068,
	SSI_SDATA0_MARK = 2069,
	MSIOF1_SS2_F_MARK = 2070,
	IP15_31_28_MARK = 2071,
	SSI_SDATA4_MARK = 2072,
	HSCK2_A_MARK = 2073,
	MSIOF1_RXD_A_MARK = 2074,
	TS_SPSYNC0_A_MARK = 2075,
	STP_ISSYNC_0_A_MARK = 2076,
	RIF0_D0_A_MARK = 2077,
	RIF2_D1_A_MARK = 2078,
	IP16_3_0_MARK = 2079,
	SSI_SCK6_MARK = 2080,
	SIM0_RST_D_MARK = 2081,
	IP17_3_0_MARK = 2082,
	AUDIO_CLKA_A_MARK = 2083,
	IP18_3_0_MARK = 2084,
	GP6_30_MARK = 2085,
	AUDIO_CLKOUT2_B_MARK = 2086,
	SSI_SCK9_B_MARK = 2087,
	TS_SDEN0_E_MARK = 2088,
	STP_ISEN_0_E_MARK = 2089,
	RIF2_D0_B_MARK = 2090,
	TPU0TO2_MARK = 2091,
	FMCLK_C_MARK = 2092,
	FMCLK_D_MARK = 2093,
	IP16_7_4_MARK = 2094,
	SSI_WS6_MARK = 2095,
	SIM0_D_D_MARK = 2096,
	IP17_7_4_MARK = 2097,
	AUDIO_CLKB_B_MARK = 2098,
	SCIF_CLK_A_MARK = 2099,
	STP_IVCXO27_1_D_MARK = 2100,
	REMOCON_A_MARK = 2101,
	TCLK1_A_MARK = 2102,
	IP18_7_4_MARK = 2103,
	GP6_31_MARK = 2104,
	AUDIO_CLKOUT3_B_MARK = 2105,
	SSI_WS9_B_MARK = 2106,
	TS_SPSYNC0_E_MARK = 2107,
	STP_ISSYNC_0_E_MARK = 2108,
	RIF2_D1_B_MARK = 2109,
	TPU0TO3_MARK = 2110,
	FMIN_C_MARK = 2111,
	FMIN_D_MARK = 2112,
	IP16_11_8_MARK = 2113,
	SSI_SDATA6_MARK = 2114,
	SIM0_CLK_D_MARK = 2115,
	IP17_11_8_MARK = 2116,
	USB0_PWEN_MARK = 2117,
	SIM0_RST_C_MARK = 2118,
	TS_SCK1_D_MARK = 2119,
	STP_ISCLK_1_D_MARK = 2120,
	BPFCLK_B_MARK = 2121,
	RIF3_CLK_B_MARK = 2122,
	HSCK2_C_MARK = 2123,
	IP16_15_12_MARK = 2124,
	SSI_SCK78_MARK = 2125,
	HRX2_B_MARK = 2126,
	MSIOF1_SCK_C_MARK = 2127,
	TS_SCK1_A_MARK = 2128,
	STP_ISCLK_1_A_MARK = 2129,
	RIF1_CLK_A_MARK = 2130,
	RIF3_CLK_A_MARK = 2131,
	IP17_15_12_MARK = 2132,
	USB0_OVC_MARK = 2133,
	SIM0_D_C_MARK = 2134,
	TS_SDAT1_D_MARK = 2135,
	STP_ISD_1_D_MARK = 2136,
	RIF3_SYNC_B_MARK = 2137,
	HRX2_C_MARK = 2138,
	IP16_19_16_MARK = 2139,
	SSI_WS78_MARK = 2140,
	HTX2_B_MARK = 2141,
	MSIOF1_SYNC_C_MARK = 2142,
	TS_SDAT1_A_MARK = 2143,
	STP_ISD_1_A_MARK = 2144,
	RIF1_SYNC_A_MARK = 2145,
	RIF3_SYNC_A_MARK = 2146,
	IP17_19_16_MARK = 2147,
	USB1_PWEN_MARK = 2148,
	SIM0_CLK_C_MARK = 2149,
	SSI_SCK1_A_MARK = 2150,
	TS_SCK0_E_MARK = 2151,
	STP_ISCLK_0_E_MARK = 2152,
	FMCLK_B_MARK = 2153,
	RIF2_CLK_B_MARK = 2154,
	SPEEDIN_A_MARK = 2155,
	HTX2_C_MARK = 2156,
	IP16_23_20_MARK = 2157,
	SSI_SDATA7_MARK = 2158,
	HCTS2_N_B_MARK = 2159,
	MSIOF1_RXD_C_MARK = 2160,
	TS_SDEN1_A_MARK = 2161,
	STP_ISEN_1_A_MARK = 2162,
	RIF1_D0_A_MARK = 2163,
	RIF3_D0_A_MARK = 2164,
	TCLK2_A_MARK = 2165,
	IP17_23_20_MARK = 2166,
	USB1_OVC_MARK = 2167,
	MSIOF1_SS2_C_MARK = 2168,
	SSI_WS1_A_MARK = 2169,
	TS_SDAT0_E_MARK = 2170,
	STP_ISD_0_E_MARK = 2171,
	FMIN_B_MARK = 2172,
	RIF2_SYNC_B_MARK = 2173,
	REMOCON_B_MARK = 2174,
	HCTS2_N_C_MARK = 2175,
	IP16_27_24_MARK = 2176,
	SSI_SDATA8_MARK = 2177,
	HRTS2_N_B_MARK = 2178,
	MSIOF1_TXD_C_MARK = 2179,
	TS_SPSYNC1_A_MARK = 2180,
	STP_ISSYNC_1_A_MARK = 2181,
	RIF1_D1_A_MARK = 2182,
	RIF3_D1_A_MARK = 2183,
	IP17_27_24_MARK = 2184,
	USB30_PWEN_MARK = 2185,
	AUDIO_CLKOUT_B_MARK = 2186,
	SSI_SCK2_B_MARK = 2187,
	TS_SDEN1_D_MARK = 2188,
	STP_ISEN_1_D_MARK = 2189,
	STP_OPWM_0_E_MARK = 2190,
	RIF3_D0_B_MARK = 2191,
	TCLK2_B_MARK = 2192,
	TPU0TO0_MARK = 2193,
	BPFCLK_C_MARK = 2194,
	HRTS2_N_C_MARK = 2195,
	IP16_31_28_MARK = 2196,
	SSI_SDATA9_A_MARK = 2197,
	HSCK2_B_MARK = 2198,
	MSIOF1_SS1_C_MARK = 2199,
	HSCK1_A_MARK = 2200,
	SSI_WS1_B_MARK = 2201,
	SCK1_MARK = 2202,
	STP_IVCXO27_1_A_MARK = 2203,
	SCK5_A_MARK = 2204,
	IP17_31_28_MARK = 2205,
	USB30_OVC_MARK = 2206,
	AUDIO_CLKOUT1_B_MARK = 2207,
	SSI_WS2_B_MARK = 2208,
	TS_SPSYNC1_D_MARK = 2209,
	STP_ISSYNC_1_D_MARK = 2210,
	STP_IVCXO27_0_E_MARK = 2211,
	RIF3_D1_B_MARK = 2212,
	FSO_TOE_N_MARK = 2213,
	TPU0TO1_MARK = 2214,
	SEL_MSIOF3_0_MARK = 2215,
	SEL_MSIOF3_1_MARK = 2216,
	SEL_MSIOF3_2_MARK = 2217,
	SEL_MSIOF3_3_MARK = 2218,
	SEL_MSIOF3_4_MARK = 2219,
	SEL_TSIF1_0_MARK = 2220,
	SEL_TSIF1_1_MARK = 2221,
	SEL_TSIF1_2_MARK = 2222,
	SEL_TSIF1_3_MARK = 2223,
	I2C_SEL_5_0_MARK = 2224,
	I2C_SEL_5_1_MARK = 2225,
	I2C_SEL_3_0_MARK = 2226,
	I2C_SEL_3_1_MARK = 2227,
	SEL_TSIF0_0_MARK = 2228,
	SEL_TSIF0_1_MARK = 2229,
	SEL_TSIF0_2_MARK = 2230,
	SEL_TSIF0_3_MARK = 2231,
	SEL_TSIF0_4_MARK = 2232,
	I2C_SEL_0_0_MARK = 2233,
	I2C_SEL_0_1_MARK = 2234,
	SEL_MSIOF2_0_MARK = 2235,
	SEL_MSIOF2_1_MARK = 2236,
	SEL_MSIOF2_2_MARK = 2237,
	SEL_MSIOF2_3_MARK = 2238,
	SEL_FM_0_MARK = 2239,
	SEL_FM_1_MARK = 2240,
	SEL_FM_2_MARK = 2241,
	SEL_FM_3_MARK = 2242,
	SEL_MSIOF1_0_MARK = 2243,
	SEL_MSIOF1_1_MARK = 2244,
	SEL_MSIOF1_2_MARK = 2245,
	SEL_MSIOF1_3_MARK = 2246,
	SEL_MSIOF1_4_MARK = 2247,
	SEL_MSIOF1_5_MARK = 2248,
	SEL_MSIOF1_6_MARK = 2249,
	SEL_TIMER_TMU_0_MARK = 2250,
	SEL_TIMER_TMU_1_MARK = 2251,
	SEL_SCIF5_0_MARK = 2252,
	SEL_SCIF5_1_MARK = 2253,
	SEL_SSP1_1_0_MARK = 2254,
	SEL_SSP1_1_1_MARK = 2255,
	SEL_SSP1_1_2_MARK = 2256,
	SEL_SSP1_1_3_MARK = 2257,
	SEL_I2C6_0_MARK = 2258,
	SEL_I2C6_1_MARK = 2259,
	SEL_I2C6_2_MARK = 2260,
	SEL_LBSC_0_MARK = 2261,
	SEL_LBSC_1_MARK = 2262,
	SEL_SSP1_0_0_MARK = 2263,
	SEL_SSP1_0_1_MARK = 2264,
	SEL_SSP1_0_2_MARK = 2265,
	SEL_SSP1_0_3_MARK = 2266,
	SEL_SSP1_0_4_MARK = 2267,
	SEL_IEBUS_0_MARK = 2268,
	SEL_IEBUS_1_MARK = 2269,
	SEL_NDF_0_MARK = 2270,
	SEL_NDF_1_MARK = 2271,
	SEL_I2C2_0_MARK = 2272,
	SEL_I2C2_1_MARK = 2273,
	SEL_SSI2_0_MARK = 2274,
	SEL_SSI2_1_MARK = 2275,
	SEL_I2C1_0_MARK = 2276,
	SEL_I2C1_1_MARK = 2277,
	SEL_SSI1_0_MARK = 2278,
	SEL_SSI1_1_MARK = 2279,
	SEL_SSI9_0_MARK = 2280,
	SEL_SSI9_1_MARK = 2281,
	SEL_HSCIF4_0_MARK = 2282,
	SEL_HSCIF4_1_MARK = 2283,
	SEL_SPEED_PULSE_0_MARK = 2284,
	SEL_SPEED_PULSE_1_MARK = 2285,
	SEL_TIMER_TMU2_0_MARK = 2286,
	SEL_TIMER_TMU2_1_MARK = 2287,
	SEL_HSCIF3_0_MARK = 2288,
	SEL_HSCIF3_1_MARK = 2289,
	SEL_HSCIF3_2_MARK = 2290,
	SEL_HSCIF3_3_MARK = 2291,
	SEL_SIMCARD_0_MARK = 2292,
	SEL_SIMCARD_1_MARK = 2293,
	SEL_SIMCARD_2_MARK = 2294,
	SEL_SIMCARD_3_MARK = 2295,
	SEL_ADGB_0_MARK = 2296,
	SEL_ADGB_1_MARK = 2297,
	SEL_ADGC_0_MARK = 2298,
	SEL_ADGC_1_MARK = 2299,
	SEL_HSCIF1_0_MARK = 2300,
	SEL_HSCIF1_1_MARK = 2301,
	SEL_SDHI2_0_MARK = 2302,
	SEL_SDHI2_1_MARK = 2303,
	SEL_SCIF4_0_MARK = 2304,
	SEL_SCIF4_1_MARK = 2305,
	SEL_SCIF4_2_MARK = 2306,
	SEL_HSCIF2_0_MARK = 2307,
	SEL_HSCIF2_1_MARK = 2308,
	SEL_HSCIF2_2_MARK = 2309,
	SEL_SCIF3_0_MARK = 2310,
	SEL_SCIF3_1_MARK = 2311,
	SEL_ETHERAVB_0_MARK = 2312,
	SEL_ETHERAVB_1_MARK = 2313,
	SEL_SCIF2_0_MARK = 2314,
	SEL_SCIF2_1_MARK = 2315,
	SEL_DRIF3_0_MARK = 2316,
	SEL_DRIF3_1_MARK = 2317,
	SEL_SCIF1_0_MARK = 2318,
	SEL_SCIF1_1_MARK = 2319,
	SEL_DRIF2_0_MARK = 2320,
	SEL_DRIF2_1_MARK = 2321,
	SEL_SCIF_0_MARK = 2322,
	SEL_SCIF_1_MARK = 2323,
	SEL_DRIF1_0_MARK = 2324,
	SEL_DRIF1_1_MARK = 2325,
	SEL_DRIF1_2_MARK = 2326,
	SEL_REMOCON_0_MARK = 2327,
	SEL_REMOCON_1_MARK = 2328,
	SEL_DRIF0_0_MARK = 2329,
	SEL_DRIF0_1_MARK = 2330,
	SEL_DRIF0_2_MARK = 2331,
	SEL_RCAN0_0_MARK = 2332,
	SEL_RCAN0_1_MARK = 2333,
	SEL_CANFD0_0_MARK = 2334,
	SEL_CANFD0_1_MARK = 2335,
	SEL_PWM6_0_MARK = 2336,
	SEL_PWM6_1_MARK = 2337,
	SEL_ADGA_0_MARK = 2338,
	SEL_ADGA_1_MARK = 2339,
	SEL_ADGA_2_MARK = 2340,
	SEL_ADGA_3_MARK = 2341,
	SEL_PWM5_0_MARK = 2342,
	SEL_PWM5_1_MARK = 2343,
	SEL_PWM4_0_MARK = 2344,
	SEL_PWM4_1_MARK = 2345,
	SEL_PWM3_0_MARK = 2346,
	SEL_PWM3_1_MARK = 2347,
	SEL_PWM2_0_MARK = 2348,
	SEL_PWM2_1_MARK = 2349,
	SEL_PWM1_0_MARK = 2350,
	SEL_PWM1_1_MARK = 2351,
	SEL_VIN4_0_MARK = 2352,
	SEL_VIN4_1_MARK = 2353,
	QSPI0_SPCLK_MARK = 2354,
	QSPI0_SSL_MARK = 2355,
	QSPI0_MOSI_IO0_MARK = 2356,
	QSPI0_MISO_IO1_MARK = 2357,
	QSPI0_IO2_MARK = 2358,
	QSPI0_IO3_MARK = 2359,
	QSPI1_SPCLK_MARK = 2360,
	QSPI1_SSL_MARK = 2361,
	QSPI1_MOSI_IO0_MARK = 2362,
	QSPI1_MISO_IO1_MARK = 2363,
	QSPI1_IO2_MARK = 2364,
	QSPI1_IO3_MARK = 2365,
	RPC_INT_MARK = 2366,
	RPC_WP_MARK = 2367,
	RPC_RESET_MARK = 2368,
	AVB_TX_CTL_MARK = 2369,
	AVB_TXC_MARK = 2370,
	AVB_TD0_MARK = 2371,
	AVB_TD1_MARK = 2372,
	AVB_TD2_MARK = 2373,
	AVB_TD3_MARK = 2374,
	AVB_RX_CTL_MARK = 2375,
	AVB_RXC_MARK = 2376,
	AVB_RD0_MARK = 2377,
	AVB_RD1_MARK = 2378,
	AVB_RD2_MARK = 2379,
	AVB_RD3_MARK = 2380,
	AVB_TXCREFCLK_MARK = 2381,
	AVB_MDIO_MARK = 2382,
	PRESETOUT_MARK = 2383,
	DU_DOTCLKIN0_MARK = 2384,
	DU_DOTCLKIN1_MARK = 2385,
	DU_DOTCLKIN2_MARK = 2386,
	TMS_MARK = 2387,
	TDO_MARK = 2388,
	ASEBRK_MARK = 2389,
	MLB_REF_MARK = 2390,
	TDI_MARK = 2391,
	TCK_MARK = 2392,
	TRST_MARK = 2393,
	EXTALR_MARK = 2394,
	SCL0_MARK = 2395,
	SDA0_MARK = 2396,
	SCL3_MARK = 2397,
	SDA3_MARK = 2398,
	SCL5_MARK = 2399,
	SDA5_MARK = 2400,
	PINMUX_MARK_END = 2401,
};

enum {
	GP_LAST = 227,
	PIN_ASEBRK = 228,
	PIN_AVB_MDIO = 229,
	PIN_AVB_RD0 = 230,
	PIN_AVB_RD1 = 231,
	PIN_AVB_RD2 = 232,
	PIN_AVB_RD3 = 233,
	PIN_AVB_RXC = 234,
	PIN_AVB_RX_CTL = 235,
	PIN_AVB_TD0 = 236,
	PIN_AVB_TD1 = 237,
	PIN_AVB_TD2 = 238,
	PIN_AVB_TD3 = 239,
	PIN_AVB_TXC = 240,
	PIN_AVB_TXCREFCLK = 241,
	PIN_AVB_TX_CTL = 242,
	PIN_DU_DOTCLKIN0 = 243,
	PIN_DU_DOTCLKIN1 = 244,
	PIN_DU_DOTCLKIN2 = 245,
	PIN_EXTALR = 246,
	PIN_FSCLKST = 247,
	PIN_MLB_REF = 248,
	PIN_PRESETOUT_N = 249,
	PIN_QSPI0_IO2 = 250,
	PIN_QSPI0_IO3 = 251,
	PIN_QSPI0_MISO_IO1 = 252,
	PIN_QSPI0_MOSI_IO0 = 253,
	PIN_QSPI0_SPCLK = 254,
	PIN_QSPI0_SSL = 255,
	PIN_QSPI1_IO2 = 256,
	PIN_QSPI1_IO3 = 257,
	PIN_QSPI1_MISO_IO1 = 258,
	PIN_QSPI1_MOSI_IO0 = 259,
	PIN_QSPI1_SPCLK = 260,
	PIN_QSPI1_SSL = 261,
	PIN_PRESET_N = 262,
	PIN_RPC_INT_N = 263,
	PIN_RPC_RESET_N = 264,
	PIN_RPC_WP_N = 265,
	PIN_TCK = 266,
	PIN_TDI = 267,
	PIN_TDO = 268,
	PIN_TMS = 269,
	PIN_TRST_N = 270,
};

enum ioctrl_regs {
	POCCTRL = 0,
	TDSELCTRL = 1,
};

enum {
	PINMUX_RESERVED___2 = 0,
	PINMUX_DATA_BEGIN___2 = 1,
	GP_0_0_DATA___2 = 2,
	GP_0_1_DATA___2 = 3,
	GP_0_2_DATA___2 = 4,
	GP_0_3_DATA___2 = 5,
	GP_0_4_DATA___2 = 6,
	GP_0_5_DATA___2 = 7,
	GP_0_6_DATA___2 = 8,
	GP_0_7_DATA___2 = 9,
	GP_0_8_DATA___2 = 10,
	GP_0_9_DATA___2 = 11,
	GP_0_10_DATA___2 = 12,
	GP_0_11_DATA___2 = 13,
	GP_0_12_DATA___2 = 14,
	GP_0_13_DATA___2 = 15,
	GP_0_14_DATA___2 = 16,
	GP_0_15_DATA___2 = 17,
	GP_1_0_DATA___2 = 18,
	GP_1_1_DATA___2 = 19,
	GP_1_2_DATA___2 = 20,
	GP_1_3_DATA___2 = 21,
	GP_1_4_DATA___2 = 22,
	GP_1_5_DATA___2 = 23,
	GP_1_6_DATA___2 = 24,
	GP_1_7_DATA___2 = 25,
	GP_1_8_DATA___2 = 26,
	GP_1_9_DATA___2 = 27,
	GP_1_10_DATA___2 = 28,
	GP_1_11_DATA___2 = 29,
	GP_1_12_DATA___2 = 30,
	GP_1_13_DATA___2 = 31,
	GP_1_14_DATA___2 = 32,
	GP_1_15_DATA___2 = 33,
	GP_1_16_DATA___2 = 34,
	GP_1_17_DATA___2 = 35,
	GP_1_18_DATA___2 = 36,
	GP_1_19_DATA___2 = 37,
	GP_1_20_DATA___2 = 38,
	GP_1_21_DATA___2 = 39,
	GP_1_22_DATA___2 = 40,
	GP_1_23_DATA___2 = 41,
	GP_1_24_DATA___2 = 42,
	GP_1_25_DATA___2 = 43,
	GP_1_26_DATA___2 = 44,
	GP_1_27_DATA___2 = 45,
	GP_1_28_DATA___2 = 46,
	GP_2_0_DATA___2 = 47,
	GP_2_1_DATA___2 = 48,
	GP_2_2_DATA___2 = 49,
	GP_2_3_DATA___2 = 50,
	GP_2_4_DATA___2 = 51,
	GP_2_5_DATA___2 = 52,
	GP_2_6_DATA___2 = 53,
	GP_2_7_DATA___2 = 54,
	GP_2_8_DATA___2 = 55,
	GP_2_9_DATA___2 = 56,
	GP_2_10_DATA___2 = 57,
	GP_2_11_DATA___2 = 58,
	GP_2_12_DATA___2 = 59,
	GP_2_13_DATA___2 = 60,
	GP_2_14_DATA___2 = 61,
	GP_3_0_DATA___2 = 62,
	GP_3_1_DATA___2 = 63,
	GP_3_2_DATA___2 = 64,
	GP_3_3_DATA___2 = 65,
	GP_3_4_DATA___2 = 66,
	GP_3_5_DATA___2 = 67,
	GP_3_6_DATA___2 = 68,
	GP_3_7_DATA___2 = 69,
	GP_3_8_DATA___2 = 70,
	GP_3_9_DATA___2 = 71,
	GP_3_10_DATA___2 = 72,
	GP_3_11_DATA___2 = 73,
	GP_3_12_DATA___2 = 74,
	GP_3_13_DATA___2 = 75,
	GP_3_14_DATA___2 = 76,
	GP_3_15_DATA___2 = 77,
	GP_4_0_DATA___2 = 78,
	GP_4_1_DATA___2 = 79,
	GP_4_2_DATA___2 = 80,
	GP_4_3_DATA___2 = 81,
	GP_4_4_DATA___2 = 82,
	GP_4_5_DATA___2 = 83,
	GP_4_6_DATA___2 = 84,
	GP_4_7_DATA___2 = 85,
	GP_4_8_DATA___2 = 86,
	GP_4_9_DATA___2 = 87,
	GP_4_10_DATA___2 = 88,
	GP_4_11_DATA___2 = 89,
	GP_4_12_DATA___2 = 90,
	GP_4_13_DATA___2 = 91,
	GP_4_14_DATA___2 = 92,
	GP_4_15_DATA___2 = 93,
	GP_4_16_DATA___2 = 94,
	GP_4_17_DATA___2 = 95,
	GP_5_0_DATA___2 = 96,
	GP_5_1_DATA___2 = 97,
	GP_5_2_DATA___2 = 98,
	GP_5_3_DATA___2 = 99,
	GP_5_4_DATA___2 = 100,
	GP_5_5_DATA___2 = 101,
	GP_5_6_DATA___2 = 102,
	GP_5_7_DATA___2 = 103,
	GP_5_8_DATA___2 = 104,
	GP_5_9_DATA___2 = 105,
	GP_5_10_DATA___2 = 106,
	GP_5_11_DATA___2 = 107,
	GP_5_12_DATA___2 = 108,
	GP_5_13_DATA___2 = 109,
	GP_5_14_DATA___2 = 110,
	GP_5_15_DATA___2 = 111,
	GP_5_16_DATA___2 = 112,
	GP_5_17_DATA___2 = 113,
	GP_5_18_DATA___2 = 114,
	GP_5_19_DATA___2 = 115,
	GP_5_20_DATA___2 = 116,
	GP_5_21_DATA___2 = 117,
	GP_5_22_DATA___2 = 118,
	GP_5_23_DATA___2 = 119,
	GP_5_24_DATA___2 = 120,
	GP_5_25_DATA___2 = 121,
	GP_6_0_DATA___2 = 122,
	GP_6_1_DATA___2 = 123,
	GP_6_2_DATA___2 = 124,
	GP_6_3_DATA___2 = 125,
	GP_6_4_DATA___2 = 126,
	GP_6_5_DATA___2 = 127,
	GP_6_6_DATA___2 = 128,
	GP_6_7_DATA___2 = 129,
	GP_6_8_DATA___2 = 130,
	GP_6_9_DATA___2 = 131,
	GP_6_10_DATA___2 = 132,
	GP_6_11_DATA___2 = 133,
	GP_6_12_DATA___2 = 134,
	GP_6_13_DATA___2 = 135,
	GP_6_14_DATA___2 = 136,
	GP_6_15_DATA___2 = 137,
	GP_6_16_DATA___2 = 138,
	GP_6_17_DATA___2 = 139,
	GP_6_18_DATA___2 = 140,
	GP_6_19_DATA___2 = 141,
	GP_6_20_DATA___2 = 142,
	GP_6_21_DATA___2 = 143,
	GP_6_22_DATA___2 = 144,
	GP_6_23_DATA___2 = 145,
	GP_6_24_DATA___2 = 146,
	GP_6_25_DATA___2 = 147,
	GP_6_26_DATA___2 = 148,
	GP_6_27_DATA___2 = 149,
	GP_6_28_DATA___2 = 150,
	GP_6_29_DATA___2 = 151,
	GP_6_30_DATA___2 = 152,
	GP_6_31_DATA___2 = 153,
	GP_7_0_DATA___2 = 154,
	GP_7_1_DATA___2 = 155,
	GP_7_2_DATA___2 = 156,
	GP_7_3_DATA___2 = 157,
	PINMUX_DATA_END___2 = 158,
	PINMUX_FUNCTION_BEGIN___2 = 159,
	GP_0_0_FN___2 = 160,
	GP_0_1_FN___2 = 161,
	GP_0_2_FN___2 = 162,
	GP_0_3_FN___2 = 163,
	GP_0_4_FN___2 = 164,
	GP_0_5_FN___2 = 165,
	GP_0_6_FN___2 = 166,
	GP_0_7_FN___2 = 167,
	GP_0_8_FN___2 = 168,
	GP_0_9_FN___2 = 169,
	GP_0_10_FN___2 = 170,
	GP_0_11_FN___2 = 171,
	GP_0_12_FN___2 = 172,
	GP_0_13_FN___2 = 173,
	GP_0_14_FN___2 = 174,
	GP_0_15_FN___2 = 175,
	GP_1_0_FN___2 = 176,
	GP_1_1_FN___2 = 177,
	GP_1_2_FN___2 = 178,
	GP_1_3_FN___2 = 179,
	GP_1_4_FN___2 = 180,
	GP_1_5_FN___2 = 181,
	GP_1_6_FN___2 = 182,
	GP_1_7_FN___2 = 183,
	GP_1_8_FN___2 = 184,
	GP_1_9_FN___2 = 185,
	GP_1_10_FN___2 = 186,
	GP_1_11_FN___2 = 187,
	GP_1_12_FN___2 = 188,
	GP_1_13_FN___2 = 189,
	GP_1_14_FN___2 = 190,
	GP_1_15_FN___2 = 191,
	GP_1_16_FN___2 = 192,
	GP_1_17_FN___2 = 193,
	GP_1_18_FN___2 = 194,
	GP_1_19_FN___2 = 195,
	GP_1_20_FN___2 = 196,
	GP_1_21_FN___2 = 197,
	GP_1_22_FN___2 = 198,
	GP_1_23_FN___2 = 199,
	GP_1_24_FN___2 = 200,
	GP_1_25_FN___2 = 201,
	GP_1_26_FN___2 = 202,
	GP_1_27_FN___2 = 203,
	GP_1_28_FN___2 = 204,
	GP_2_0_FN___2 = 205,
	GP_2_1_FN___2 = 206,
	GP_2_2_FN___2 = 207,
	GP_2_3_FN___2 = 208,
	GP_2_4_FN___2 = 209,
	GP_2_5_FN___2 = 210,
	GP_2_6_FN___2 = 211,
	GP_2_7_FN___2 = 212,
	GP_2_8_FN___2 = 213,
	GP_2_9_FN___2 = 214,
	GP_2_10_FN___2 = 215,
	GP_2_11_FN___2 = 216,
	GP_2_12_FN___2 = 217,
	GP_2_13_FN___2 = 218,
	GP_2_14_FN___2 = 219,
	GP_3_0_FN___2 = 220,
	GP_3_1_FN___2 = 221,
	GP_3_2_FN___2 = 222,
	GP_3_3_FN___2 = 223,
	GP_3_4_FN___2 = 224,
	GP_3_5_FN___2 = 225,
	GP_3_6_FN___2 = 226,
	GP_3_7_FN___2 = 227,
	GP_3_8_FN___2 = 228,
	GP_3_9_FN___2 = 229,
	GP_3_10_FN___2 = 230,
	GP_3_11_FN___2 = 231,
	GP_3_12_FN___2 = 232,
	GP_3_13_FN___2 = 233,
	GP_3_14_FN___2 = 234,
	GP_3_15_FN___2 = 235,
	GP_4_0_FN___2 = 236,
	GP_4_1_FN___2 = 237,
	GP_4_2_FN___2 = 238,
	GP_4_3_FN___2 = 239,
	GP_4_4_FN___2 = 240,
	GP_4_5_FN___2 = 241,
	GP_4_6_FN___2 = 242,
	GP_4_7_FN___2 = 243,
	GP_4_8_FN___2 = 244,
	GP_4_9_FN___2 = 245,
	GP_4_10_FN___2 = 246,
	GP_4_11_FN___2 = 247,
	GP_4_12_FN___2 = 248,
	GP_4_13_FN___2 = 249,
	GP_4_14_FN___2 = 250,
	GP_4_15_FN___2 = 251,
	GP_4_16_FN___2 = 252,
	GP_4_17_FN___2 = 253,
	GP_5_0_FN___2 = 254,
	GP_5_1_FN___2 = 255,
	GP_5_2_FN___2 = 256,
	GP_5_3_FN___2 = 257,
	GP_5_4_FN___2 = 258,
	GP_5_5_FN___2 = 259,
	GP_5_6_FN___2 = 260,
	GP_5_7_FN___2 = 261,
	GP_5_8_FN___2 = 262,
	GP_5_9_FN___2 = 263,
	GP_5_10_FN___2 = 264,
	GP_5_11_FN___2 = 265,
	GP_5_12_FN___2 = 266,
	GP_5_13_FN___2 = 267,
	GP_5_14_FN___2 = 268,
	GP_5_15_FN___2 = 269,
	GP_5_16_FN___2 = 270,
	GP_5_17_FN___2 = 271,
	GP_5_18_FN___2 = 272,
	GP_5_19_FN___2 = 273,
	GP_5_20_FN___2 = 274,
	GP_5_21_FN___2 = 275,
	GP_5_22_FN___2 = 276,
	GP_5_23_FN___2 = 277,
	GP_5_24_FN___2 = 278,
	GP_5_25_FN___2 = 279,
	GP_6_0_FN___2 = 280,
	GP_6_1_FN___2 = 281,
	GP_6_2_FN___2 = 282,
	GP_6_3_FN___2 = 283,
	GP_6_4_FN___2 = 284,
	GP_6_5_FN___2 = 285,
	GP_6_6_FN___2 = 286,
	GP_6_7_FN___2 = 287,
	GP_6_8_FN___2 = 288,
	GP_6_9_FN___2 = 289,
	GP_6_10_FN___2 = 290,
	GP_6_11_FN___2 = 291,
	GP_6_12_FN___2 = 292,
	GP_6_13_FN___2 = 293,
	GP_6_14_FN___2 = 294,
	GP_6_15_FN___2 = 295,
	GP_6_16_FN___2 = 296,
	GP_6_17_FN___2 = 297,
	GP_6_18_FN___2 = 298,
	GP_6_19_FN___2 = 299,
	GP_6_20_FN___2 = 300,
	GP_6_21_FN___2 = 301,
	GP_6_22_FN___2 = 302,
	GP_6_23_FN___2 = 303,
	GP_6_24_FN___2 = 304,
	GP_6_25_FN___2 = 305,
	GP_6_26_FN___2 = 306,
	GP_6_27_FN___2 = 307,
	GP_6_28_FN___2 = 308,
	GP_6_29_FN___2 = 309,
	GP_6_30_FN___2 = 310,
	GP_6_31_FN___2 = 311,
	GP_7_0_FN___2 = 312,
	GP_7_1_FN___2 = 313,
	GP_7_2_FN___2 = 314,
	GP_7_3_FN___2 = 315,
	FN_CLKOUT___2 = 316,
	FN_MSIOF0_RXD___2 = 317,
	FN_MSIOF0_TXD___2 = 318,
	FN_MSIOF0_SCK___2 = 319,
	FN_SSI_SDATA5___2 = 320,
	FN_SSI_WS5___2 = 321,
	FN_SSI_SCK5___2 = 322,
	FN_GP7_03___2 = 323,
	FN_GP7_02___2 = 324,
	FN_AVS2___2 = 325,
	FN_AVS1___2 = 326,
	FN_IP0_3_0___2 = 327,
	FN_AVB_MDC___2 = 328,
	FN_MSIOF2_SS2_C___2 = 329,
	FN_IP1_3_0___2 = 330,
	FN_IRQ2___2 = 331,
	FN_QCPV_QDE___2 = 332,
	FN_DU_EXODDF_DU_ODDF_DISP_CDE___2 = 333,
	FN_VI4_DATA2_B___2 = 334,
	FN_MSIOF3_SYNC_E___2 = 335,
	FN_PWM3_B___2 = 336,
	FN_IP2_3_0___2 = 337,
	FN_A1___2 = 338,
	FN_LCDOUT17___2 = 339,
	FN_MSIOF3_TXD_B___2 = 340,
	FN_VI4_DATA9___2 = 341,
	FN_DU_DB1___2 = 342,
	FN_PWM4_A___2 = 343,
	FN_IP3_3_0___2 = 344,
	FN_A9___2 = 345,
	FN_MSIOF2_SCK_A___2 = 346,
	FN_CTS4_N_B___2 = 347,
	FN_VI5_VSYNC_N___2 = 348,
	FN_IP0_7_4___2 = 349,
	FN_AVB_MAGIC___2 = 350,
	FN_MSIOF2_SS1_C___2 = 351,
	FN_SCK4_A___2 = 352,
	FN_IP1_7_4___2 = 353,
	FN_IRQ3___2 = 354,
	FN_QSTVB_QVE___2 = 355,
	FN_DU_DOTCLKOUT1___2 = 356,
	FN_VI4_DATA3_B___2 = 357,
	FN_MSIOF3_SCK_E___2 = 358,
	FN_PWM4_B___2 = 359,
	FN_IP2_7_4___2 = 360,
	FN_A2___2 = 361,
	FN_LCDOUT18___2 = 362,
	FN_MSIOF3_SCK_B___2 = 363,
	FN_VI4_DATA10___2 = 364,
	FN_DU_DB2___2 = 365,
	FN_PWM5_A___2 = 366,
	FN_IP3_7_4___2 = 367,
	FN_A10___2 = 368,
	FN_MSIOF2_RXD_A___2 = 369,
	FN_RTS4_N_B___2 = 370,
	FN_VI5_HSYNC_N___2 = 371,
	FN_IP0_11_8___2 = 372,
	FN_AVB_PHY_INT___2 = 373,
	FN_MSIOF2_SYNC_C___2 = 374,
	FN_RX4_A___2 = 375,
	FN_IP1_11_8___2 = 376,
	FN_IRQ4___2 = 377,
	FN_QSTH_QHS___2 = 378,
	FN_DU_EXHSYNC_DU_HSYNC___2 = 379,
	FN_VI4_DATA4_B___2 = 380,
	FN_MSIOF3_RXD_E___2 = 381,
	FN_PWM5_B___2 = 382,
	FN_IP2_11_8___2 = 383,
	FN_A3___2 = 384,
	FN_LCDOUT19___2 = 385,
	FN_MSIOF3_RXD_B___2 = 386,
	FN_VI4_DATA11___2 = 387,
	FN_DU_DB3___2 = 388,
	FN_PWM6_A___2 = 389,
	FN_IP3_11_8___2 = 390,
	FN_A11___2 = 391,
	FN_TX3_B___2 = 392,
	FN_MSIOF2_TXD_A___2 = 393,
	FN_HTX4_B___2 = 394,
	FN_HSCK4___2 = 395,
	FN_VI5_FIELD___2 = 396,
	FN_SCL6_A___2 = 397,
	FN_AVB_AVTP_CAPTURE_B___2 = 398,
	FN_PWM2_B___2 = 399,
	FN_IP0_15_12___2 = 400,
	FN_AVB_LINK___2 = 401,
	FN_MSIOF2_SCK_C___2 = 402,
	FN_TX4_A___2 = 403,
	FN_IP1_15_12___2 = 404,
	FN_IRQ5___2 = 405,
	FN_QSTB_QHE___2 = 406,
	FN_DU_EXVSYNC_DU_VSYNC___2 = 407,
	FN_VI4_DATA5_B___2 = 408,
	FN_FSCLKST2_N_B = 409,
	FN_MSIOF3_TXD_E___2 = 410,
	FN_PWM6_B___2 = 411,
	FN_IP2_15_12___2 = 412,
	FN_A4___2 = 413,
	FN_LCDOUT20___2 = 414,
	FN_MSIOF3_SS1_B___2 = 415,
	FN_VI4_DATA12___2 = 416,
	FN_VI5_DATA12___2 = 417,
	FN_DU_DB4___2 = 418,
	FN_IP3_15_12___2 = 419,
	FN_A12___2 = 420,
	FN_LCDOUT12___2 = 421,
	FN_MSIOF3_SCK_C___2 = 422,
	FN_HRX4_A___2 = 423,
	FN_VI5_DATA8___2 = 424,
	FN_DU_DG4___2 = 425,
	FN_IP0_19_16___2 = 426,
	FN_AVB_AVTP_MATCH_A___2 = 427,
	FN_MSIOF2_RXD_C___2 = 428,
	FN_CTS4_N_A___2 = 429,
	FN_FSCLKST2_N_A = 430,
	FN_IP1_19_16___2 = 431,
	FN_PWM0___2 = 432,
	FN_AVB_AVTP_PPS___2 = 433,
	FN_VI4_DATA6_B___2 = 434,
	FN_IECLK_B___2 = 435,
	FN_IP2_19_16___2 = 436,
	FN_A5___2 = 437,
	FN_LCDOUT21___2 = 438,
	FN_MSIOF3_SS2_B___2 = 439,
	FN_SCK4_B___2 = 440,
	FN_VI4_DATA13___2 = 441,
	FN_VI5_DATA13___2 = 442,
	FN_DU_DB5___2 = 443,
	FN_IP3_19_16___2 = 444,
	FN_A13___2 = 445,
	FN_LCDOUT13___2 = 446,
	FN_MSIOF3_SYNC_C___2 = 447,
	FN_HTX4_A___2 = 448,
	FN_VI5_DATA9___2 = 449,
	FN_DU_DG5___2 = 450,
	FN_IP0_23_20___2 = 451,
	FN_AVB_AVTP_CAPTURE_A___2 = 452,
	FN_MSIOF2_TXD_C___2 = 453,
	FN_RTS4_N_A___2 = 454,
	FN_IP1_23_20___2 = 455,
	FN_PWM1_A___2 = 456,
	FN_HRX3_D___2 = 457,
	FN_VI4_DATA7_B___2 = 458,
	FN_IERX_B___2 = 459,
	FN_IP2_23_20___2 = 460,
	FN_A6___2 = 461,
	FN_LCDOUT22___2 = 462,
	FN_MSIOF2_SS1_A___2 = 463,
	FN_RX4_B___2 = 464,
	FN_VI4_DATA14___2 = 465,
	FN_VI5_DATA14___2 = 466,
	FN_DU_DB6___2 = 467,
	FN_IP3_23_20___2 = 468,
	FN_A14___2 = 469,
	FN_LCDOUT14___2 = 470,
	FN_MSIOF3_RXD_C___2 = 471,
	FN_HCTS4_N___2 = 472,
	FN_VI5_DATA10___2 = 473,
	FN_DU_DG6___2 = 474,
	FN_IP0_27_24___2 = 475,
	FN_IRQ0___2 = 476,
	FN_QPOLB___2 = 477,
	FN_DU_CDE___2 = 478,
	FN_VI4_DATA0_B___2 = 479,
	FN_CAN0_TX_B___2 = 480,
	FN_CANFD0_TX_B___2 = 481,
	FN_MSIOF3_SS2_E___2 = 482,
	FN_IP1_27_24___2 = 483,
	FN_PWM2_A___2 = 484,
	FN_HTX3_D___2 = 485,
	FN_IETX_B___2 = 486,
	FN_IP2_27_24___2 = 487,
	FN_A7___2 = 488,
	FN_LCDOUT23___2 = 489,
	FN_MSIOF2_SS2_A___2 = 490,
	FN_TX4_B___2 = 491,
	FN_VI4_DATA15___2 = 492,
	FN_VI5_DATA15___2 = 493,
	FN_DU_DB7___2 = 494,
	FN_IP3_27_24___2 = 495,
	FN_A15___2 = 496,
	FN_LCDOUT15___2 = 497,
	FN_MSIOF3_TXD_C___2 = 498,
	FN_HRTS4_N___2 = 499,
	FN_VI5_DATA11___2 = 500,
	FN_DU_DG7___2 = 501,
	FN_IP0_31_28___2 = 502,
	FN_IRQ1___2 = 503,
	FN_QPOLA___2 = 504,
	FN_DU_DISP___2 = 505,
	FN_VI4_DATA1_B___2 = 506,
	FN_CAN0_RX_B___2 = 507,
	FN_CANFD0_RX_B___2 = 508,
	FN_MSIOF3_SS1_E___2 = 509,
	FN_IP1_31_28___2 = 510,
	FN_A0___2 = 511,
	FN_LCDOUT16___2 = 512,
	FN_MSIOF3_SYNC_B___2 = 513,
	FN_VI4_DATA8___2 = 514,
	FN_DU_DB0___2 = 515,
	FN_PWM3_A___2 = 516,
	FN_IP2_31_28___2 = 517,
	FN_A8___2 = 518,
	FN_RX3_B___2 = 519,
	FN_MSIOF2_SYNC_A___2 = 520,
	FN_HRX4_B___2 = 521,
	FN_SDA6_A___2 = 522,
	FN_AVB_AVTP_MATCH_B___2 = 523,
	FN_PWM1_B___2 = 524,
	FN_IP3_31_28___2 = 525,
	FN_A16___2 = 526,
	FN_LCDOUT8___2 = 527,
	FN_VI4_FIELD___2 = 528,
	FN_DU_DG0___2 = 529,
	FN_IP4_3_0___2 = 530,
	FN_A17___2 = 531,
	FN_LCDOUT9___2 = 532,
	FN_VI4_VSYNC_N___2 = 533,
	FN_DU_DG1___2 = 534,
	FN_IP5_3_0___2 = 535,
	FN_WE0_N___2 = 536,
	FN_MSIOF3_TXD_D___2 = 537,
	FN_CTS3_N___2 = 538,
	FN_HCTS3_N___2 = 539,
	FN_SCL6_B___2 = 540,
	FN_CAN_CLK___2 = 541,
	FN_IECLK_A___2 = 542,
	FN_IP6_3_0___2 = 543,
	FN_D5___2 = 544,
	FN_MSIOF2_SYNC_B___2 = 545,
	FN_VI4_DATA21___2 = 546,
	FN_VI5_DATA5___2 = 547,
	FN_IP7_3_0___2 = 548,
	FN_D13___2 = 549,
	FN_LCDOUT5___2 = 550,
	FN_MSIOF2_SS2_D___2 = 551,
	FN_TX4_C___2 = 552,
	FN_VI4_DATA5_A___2 = 553,
	FN_DU_DR5___2 = 554,
	FN_IP4_7_4___2 = 555,
	FN_A18___2 = 556,
	FN_LCDOUT10___2 = 557,
	FN_VI4_HSYNC_N___2 = 558,
	FN_DU_DG2___2 = 559,
	FN_IP5_7_4___2 = 560,
	FN_WE1_N___2 = 561,
	FN_MSIOF3_SS1_D___2 = 562,
	FN_RTS3_N___2 = 563,
	FN_HRTS3_N___2 = 564,
	FN_SDA6_B___2 = 565,
	FN_CAN1_RX___2 = 566,
	FN_CANFD1_RX___2 = 567,
	FN_IERX_A___2 = 568,
	FN_IP6_7_4___2 = 569,
	FN_D6___2 = 570,
	FN_MSIOF2_RXD_B___2 = 571,
	FN_VI4_DATA22___2 = 572,
	FN_VI5_DATA6___2 = 573,
	FN_IP7_7_4___2 = 574,
	FN_D14___2 = 575,
	FN_LCDOUT6___2 = 576,
	FN_MSIOF3_SS1_A___2 = 577,
	FN_HRX3_C___2 = 578,
	FN_VI4_DATA6_A___2 = 579,
	FN_DU_DR6___2 = 580,
	FN_SCL6_C___2 = 581,
	FN_IP4_11_8___2 = 582,
	FN_A19___2 = 583,
	FN_LCDOUT11___2 = 584,
	FN_VI4_CLKENB___2 = 585,
	FN_DU_DG3___2 = 586,
	FN_IP5_11_8___2 = 587,
	FN_EX_WAIT0_A___2 = 588,
	FN_QCLK___2 = 589,
	FN_VI4_CLK___2 = 590,
	FN_DU_DOTCLKOUT0___2 = 591,
	FN_IP6_11_8___2 = 592,
	FN_D7___2 = 593,
	FN_MSIOF2_TXD_B___2 = 594,
	FN_VI4_DATA23___2 = 595,
	FN_VI5_DATA7___2 = 596,
	FN_IP7_11_8___2 = 597,
	FN_D15___2 = 598,
	FN_LCDOUT7___2 = 599,
	FN_MSIOF3_SS2_A___2 = 600,
	FN_HTX3_C___2 = 601,
	FN_VI4_DATA7_A___2 = 602,
	FN_DU_DR7___2 = 603,
	FN_SDA6_C___2 = 604,
	FN_IP4_15_12___2 = 605,
	FN_CS0_N___2 = 606,
	FN_VI5_CLKENB___2 = 607,
	FN_IP5_15_12___2 = 608,
	FN_D0___2 = 609,
	FN_MSIOF2_SS1_B___2 = 610,
	FN_MSIOF3_SCK_A___2 = 611,
	FN_VI4_DATA16___2 = 612,
	FN_VI5_DATA0___2 = 613,
	FN_IP6_15_12___2 = 614,
	FN_D8___2 = 615,
	FN_LCDOUT0___2 = 616,
	FN_MSIOF2_SCK_D___2 = 617,
	FN_SCK4_C___2 = 618,
	FN_VI4_DATA0_A___2 = 619,
	FN_DU_DR0___2 = 620,
	FN_IP4_19_16___2 = 621,
	FN_CS1_N___2 = 622,
	FN_VI5_CLK___2 = 623,
	FN_EX_WAIT0_B___2 = 624,
	FN_IP5_19_16___2 = 625,
	FN_D1___2 = 626,
	FN_MSIOF2_SS2_B___2 = 627,
	FN_MSIOF3_SYNC_A___2 = 628,
	FN_VI4_DATA17___2 = 629,
	FN_VI5_DATA1___2 = 630,
	FN_IP6_19_16___2 = 631,
	FN_D9___2 = 632,
	FN_LCDOUT1___2 = 633,
	FN_MSIOF2_SYNC_D___2 = 634,
	FN_VI4_DATA1_A___2 = 635,
	FN_DU_DR1___2 = 636,
	FN_IP7_19_16___2 = 637,
	FN_SD0_CLK___2 = 638,
	FN_MSIOF1_SCK_E___2 = 639,
	FN_STP_OPWM_0_B___2 = 640,
	FN_IP4_23_20___2 = 641,
	FN_BS_N___2 = 642,
	FN_QSTVA_QVS___2 = 643,
	FN_MSIOF3_SCK_D___2 = 644,
	FN_SCK3___2 = 645,
	FN_HSCK3___2 = 646,
	FN_CAN1_TX___2 = 647,
	FN_CANFD1_TX___2 = 648,
	FN_IETX_A___2 = 649,
	FN_IP5_23_20___2 = 650,
	FN_D2___2 = 651,
	FN_MSIOF3_RXD_A___2 = 652,
	FN_VI4_DATA18___2 = 653,
	FN_VI5_DATA2___2 = 654,
	FN_IP6_23_20___2 = 655,
	FN_D10___2 = 656,
	FN_LCDOUT2___2 = 657,
	FN_MSIOF2_RXD_D___2 = 658,
	FN_HRX3_B___2 = 659,
	FN_VI4_DATA2_A___2 = 660,
	FN_CTS4_N_C___2 = 661,
	FN_DU_DR2___2 = 662,
	FN_IP7_23_20___2 = 663,
	FN_SD0_CMD___2 = 664,
	FN_MSIOF1_SYNC_E___2 = 665,
	FN_STP_IVCXO27_0_B___2 = 666,
	FN_IP4_27_24___2 = 667,
	FN_RD_N___2 = 668,
	FN_MSIOF3_SYNC_D___2 = 669,
	FN_RX3_A___2 = 670,
	FN_HRX3_A___2 = 671,
	FN_CAN0_TX_A___2 = 672,
	FN_CANFD0_TX_A___2 = 673,
	FN_IP5_27_24___2 = 674,
	FN_D3___2 = 675,
	FN_MSIOF3_TXD_A___2 = 676,
	FN_VI4_DATA19___2 = 677,
	FN_VI5_DATA3___2 = 678,
	FN_IP6_27_24___2 = 679,
	FN_D11___2 = 680,
	FN_LCDOUT3___2 = 681,
	FN_MSIOF2_TXD_D___2 = 682,
	FN_HTX3_B___2 = 683,
	FN_VI4_DATA3_A___2 = 684,
	FN_RTS4_N_C___2 = 685,
	FN_DU_DR3___2 = 686,
	FN_IP7_27_24___2 = 687,
	FN_SD0_DAT0___2 = 688,
	FN_MSIOF1_RXD_E___2 = 689,
	FN_TS_SCK0_B___2 = 690,
	FN_STP_ISCLK_0_B___2 = 691,
	FN_IP4_31_28___2 = 692,
	FN_RD_WR_N___2 = 693,
	FN_MSIOF3_RXD_D___2 = 694,
	FN_TX3_A___2 = 695,
	FN_HTX3_A___2 = 696,
	FN_CAN0_RX_A___2 = 697,
	FN_CANFD0_RX_A___2 = 698,
	FN_IP5_31_28___2 = 699,
	FN_D4___2 = 700,
	FN_MSIOF2_SCK_B___2 = 701,
	FN_VI4_DATA20___2 = 702,
	FN_VI5_DATA4___2 = 703,
	FN_IP6_31_28___2 = 704,
	FN_D12___2 = 705,
	FN_LCDOUT4___2 = 706,
	FN_MSIOF2_SS1_D___2 = 707,
	FN_RX4_C___2 = 708,
	FN_VI4_DATA4_A___2 = 709,
	FN_DU_DR4___2 = 710,
	FN_IP7_31_28___2 = 711,
	FN_SD0_DAT1___2 = 712,
	FN_MSIOF1_TXD_E___2 = 713,
	FN_TS_SPSYNC0_B___2 = 714,
	FN_STP_ISSYNC_0_B___2 = 715,
	FN_IP8_3_0___2 = 716,
	FN_SD0_DAT2___2 = 717,
	FN_MSIOF1_SS1_E___2 = 718,
	FN_TS_SDAT0_B___2 = 719,
	FN_STP_ISD_0_B___2 = 720,
	FN_IP9_3_0___2 = 721,
	FN_SD2_CLK___2 = 722,
	FN_NFDATA8___2 = 723,
	FN_IP10_3_0___2 = 724,
	FN_SD3_CMD___2 = 725,
	FN_NFRE_N___2 = 726,
	FN_IP11_3_0___2 = 727,
	FN_SD3_DAT7___2 = 728,
	FN_SD3_WP___2 = 729,
	FN_NFDATA7___2 = 730,
	FN_IP8_7_4___2 = 731,
	FN_SD0_DAT3___2 = 732,
	FN_MSIOF1_SS2_E___2 = 733,
	FN_TS_SDEN0_B___2 = 734,
	FN_STP_ISEN_0_B___2 = 735,
	FN_IP9_7_4___2 = 736,
	FN_SD2_CMD___2 = 737,
	FN_NFDATA9___2 = 738,
	FN_IP10_7_4___2 = 739,
	FN_SD3_DAT0___2 = 740,
	FN_NFDATA0___2 = 741,
	FN_IP11_7_4___2 = 742,
	FN_SD3_DS___2 = 743,
	FN_NFCLE___2 = 744,
	FN_IP8_11_8___2 = 745,
	FN_SD1_CLK___2 = 746,
	FN_MSIOF1_SCK_G___2 = 747,
	FN_SIM0_CLK_A___2 = 748,
	FN_IP9_11_8___2 = 749,
	FN_SD2_DAT0___2 = 750,
	FN_NFDATA10___2 = 751,
	FN_IP10_11_8___2 = 752,
	FN_SD3_DAT1___2 = 753,
	FN_NFDATA1___2 = 754,
	FN_IP11_11_8___2 = 755,
	FN_SD0_CD___2 = 756,
	FN_NFDATA14_A___2 = 757,
	FN_SCL2_B___2 = 758,
	FN_SIM0_RST_A___2 = 759,
	FN_IP8_15_12___2 = 760,
	FN_SD1_CMD___2 = 761,
	FN_MSIOF1_SYNC_G___2 = 762,
	FN_NFCE_N_B___2 = 763,
	FN_SIM0_D_A___2 = 764,
	FN_STP_IVCXO27_1_B___2 = 765,
	FN_IP9_15_12___2 = 766,
	FN_SD2_DAT1___2 = 767,
	FN_NFDATA11___2 = 768,
	FN_IP10_15_12___2 = 769,
	FN_SD3_DAT2___2 = 770,
	FN_NFDATA2___2 = 771,
	FN_IP11_15_12___2 = 772,
	FN_SD0_WP___2 = 773,
	FN_NFDATA15_A___2 = 774,
	FN_SDA2_B___2 = 775,
	FN_IP8_19_16___2 = 776,
	FN_SD1_DAT0___2 = 777,
	FN_SD2_DAT4___2 = 778,
	FN_MSIOF1_RXD_G___2 = 779,
	FN_NFWP_N_B___2 = 780,
	FN_TS_SCK1_B___2 = 781,
	FN_STP_ISCLK_1_B___2 = 782,
	FN_IP9_19_16___2 = 783,
	FN_SD2_DAT2___2 = 784,
	FN_NFDATA12___2 = 785,
	FN_IP10_19_16___2 = 786,
	FN_SD3_DAT3___2 = 787,
	FN_NFDATA3___2 = 788,
	FN_IP11_19_16___2 = 789,
	FN_SD1_CD___2 = 790,
	FN_NFRB_N_A___2 = 791,
	FN_SIM0_CLK_B___2 = 792,
	FN_IP8_23_20___2 = 793,
	FN_SD1_DAT1___2 = 794,
	FN_SD2_DAT5___2 = 795,
	FN_MSIOF1_TXD_G___2 = 796,
	FN_NFDATA14_B___2 = 797,
	FN_TS_SPSYNC1_B___2 = 798,
	FN_STP_ISSYNC_1_B___2 = 799,
	FN_IP9_23_20___2 = 800,
	FN_SD2_DAT3___2 = 801,
	FN_NFDATA13___2 = 802,
	FN_IP10_23_20___2 = 803,
	FN_SD3_DAT4___2 = 804,
	FN_SD2_CD_A___2 = 805,
	FN_NFDATA4___2 = 806,
	FN_IP11_23_20___2 = 807,
	FN_SD1_WP___2 = 808,
	FN_NFCE_N_A___2 = 809,
	FN_SIM0_D_B___2 = 810,
	FN_IP8_27_24___2 = 811,
	FN_SD1_DAT2___2 = 812,
	FN_SD2_DAT6___2 = 813,
	FN_MSIOF1_SS1_G___2 = 814,
	FN_NFDATA15_B___2 = 815,
	FN_TS_SDAT1_B___2 = 816,
	FN_STP_ISD_1_B___2 = 817,
	FN_IP9_27_24___2 = 818,
	FN_SD2_DS___2 = 819,
	FN_NFALE___2 = 820,
	FN_SATA_DEVSLP_B = 821,
	FN_IP10_27_24___2 = 822,
	FN_SD3_DAT5___2 = 823,
	FN_SD2_WP_A___2 = 824,
	FN_NFDATA5___2 = 825,
	FN_IP11_27_24___2 = 826,
	FN_SCK0___2 = 827,
	FN_HSCK1_B___2 = 828,
	FN_MSIOF1_SS2_B___2 = 829,
	FN_AUDIO_CLKC_B___2 = 830,
	FN_SDA2_A___2 = 831,
	FN_SIM0_RST_B___2 = 832,
	FN_STP_OPWM_0_C___2 = 833,
	FN_RIF0_CLK_B___2 = 834,
	FN_ADICHS2___2 = 835,
	FN_SCK5_B___2 = 836,
	FN_IP8_31_28___2 = 837,
	FN_SD1_DAT3___2 = 838,
	FN_SD2_DAT7___2 = 839,
	FN_MSIOF1_SS2_G___2 = 840,
	FN_NFRB_N_B___2 = 841,
	FN_TS_SDEN1_B___2 = 842,
	FN_STP_ISEN_1_B___2 = 843,
	FN_IP9_31_28___2 = 844,
	FN_SD3_CLK___2 = 845,
	FN_NFWE_N___2 = 846,
	FN_IP10_31_28___2 = 847,
	FN_SD3_DAT6___2 = 848,
	FN_SD3_CD___2 = 849,
	FN_NFDATA6___2 = 850,
	FN_IP11_31_28___2 = 851,
	FN_RX0___2 = 852,
	FN_HRX1_B___2 = 853,
	FN_TS_SCK0_C___2 = 854,
	FN_STP_ISCLK_0_C___2 = 855,
	FN_RIF0_D0_B___2 = 856,
	FN_IP12_3_0___2 = 857,
	FN_TX0___2 = 858,
	FN_HTX1_B___2 = 859,
	FN_TS_SPSYNC0_C___2 = 860,
	FN_STP_ISSYNC_0_C___2 = 861,
	FN_RIF0_D1_B___2 = 862,
	FN_IP13_3_0___2 = 863,
	FN_TX2_A___2 = 864,
	FN_SD2_CD_B___2 = 865,
	FN_SCL1_A___2 = 866,
	FN_FMCLK_A___2 = 867,
	FN_RIF1_D1_C___2 = 868,
	FN_FSO_CFE_0_N___2 = 869,
	FN_IP14_3_0___2 = 870,
	FN_MSIOF0_SS1___2 = 871,
	FN_RX5_A___2 = 872,
	FN_NFWP_N_A___2 = 873,
	FN_AUDIO_CLKA_C___2 = 874,
	FN_SSI_SCK2_A___2 = 875,
	FN_STP_IVCXO27_0_C___2 = 876,
	FN_AUDIO_CLKOUT3_A___2 = 877,
	FN_TCLK1_B___2 = 878,
	FN_IP15_3_0___2 = 879,
	FN_SSI_SDATA1_A___2 = 880,
	FN_IP12_7_4___2 = 881,
	FN_CTS0_N___2 = 882,
	FN_HCTS1_N_B___2 = 883,
	FN_MSIOF1_SYNC_B___2 = 884,
	FN_TS_SPSYNC1_C___2 = 885,
	FN_STP_ISSYNC_1_C___2 = 886,
	FN_RIF1_SYNC_B___2 = 887,
	FN_AUDIO_CLKOUT_C___2 = 888,
	FN_ADICS_SAMP___2 = 889,
	FN_IP13_7_4___2 = 890,
	FN_RX2_A___2 = 891,
	FN_SD2_WP_B___2 = 892,
	FN_SDA1_A___2 = 893,
	FN_FMIN_A___2 = 894,
	FN_RIF1_SYNC_C___2 = 895,
	FN_FSO_CFE_1_N___2 = 896,
	FN_IP14_7_4___2 = 897,
	FN_MSIOF0_SS2___2 = 898,
	FN_TX5_A___2 = 899,
	FN_MSIOF1_SS2_D___2 = 900,
	FN_AUDIO_CLKC_A___2 = 901,
	FN_SSI_WS2_A___2 = 902,
	FN_STP_OPWM_0_D___2 = 903,
	FN_AUDIO_CLKOUT_D___2 = 904,
	FN_SPEEDIN_B___2 = 905,
	FN_IP15_7_4___2 = 906,
	FN_SSI_SDATA2_A___2 = 907,
	FN_SSI_SCK1_B___2 = 908,
	FN_IP12_11_8___2 = 909,
	FN_RTS0_N___2 = 910,
	FN_HRTS1_N_B___2 = 911,
	FN_MSIOF1_SS1_B___2 = 912,
	FN_AUDIO_CLKA_B___2 = 913,
	FN_SCL2_A___2 = 914,
	FN_STP_IVCXO27_1_C___2 = 915,
	FN_RIF0_SYNC_B___2 = 916,
	FN_ADICHS1___2 = 917,
	FN_IP13_11_8___2 = 918,
	FN_HSCK0___2 = 919,
	FN_MSIOF1_SCK_D___2 = 920,
	FN_AUDIO_CLKB_A___2 = 921,
	FN_SSI_SDATA1_B___2 = 922,
	FN_TS_SCK0_D___2 = 923,
	FN_STP_ISCLK_0_D___2 = 924,
	FN_RIF0_CLK_C___2 = 925,
	FN_RX5_B___2 = 926,
	FN_IP14_11_8___2 = 927,
	FN_MLB_CLK___2 = 928,
	FN_MSIOF1_SCK_F___2 = 929,
	FN_SCL1_B___2 = 930,
	FN_IP15_11_8___2 = 931,
	FN_SSI_SCK349___2 = 932,
	FN_MSIOF1_SS1_A___2 = 933,
	FN_STP_OPWM_0_A___2 = 934,
	FN_IP12_15_12___2 = 935,
	FN_RX1_A___2 = 936,
	FN_HRX1_A___2 = 937,
	FN_TS_SDAT0_C___2 = 938,
	FN_STP_ISD_0_C___2 = 939,
	FN_RIF1_CLK_C___2 = 940,
	FN_IP13_15_12___2 = 941,
	FN_HRX0___2 = 942,
	FN_MSIOF1_RXD_D___2 = 943,
	FN_SSI_SDATA2_B___2 = 944,
	FN_TS_SDEN0_D___2 = 945,
	FN_STP_ISEN_0_D___2 = 946,
	FN_RIF0_D0_C___2 = 947,
	FN_IP14_15_12___2 = 948,
	FN_MLB_SIG___2 = 949,
	FN_RX1_B___2 = 950,
	FN_MSIOF1_SYNC_F___2 = 951,
	FN_SDA1_B___2 = 952,
	FN_IP15_15_12___2 = 953,
	FN_SSI_WS349___2 = 954,
	FN_HCTS2_N_A___2 = 955,
	FN_MSIOF1_SS2_A___2 = 956,
	FN_STP_IVCXO27_0_A___2 = 957,
	FN_IP12_19_16___2 = 958,
	FN_TX1_A___2 = 959,
	FN_HTX1_A___2 = 960,
	FN_TS_SDEN0_C___2 = 961,
	FN_STP_ISEN_0_C___2 = 962,
	FN_RIF1_D0_C___2 = 963,
	FN_IP13_19_16___2 = 964,
	FN_HTX0___2 = 965,
	FN_MSIOF1_TXD_D___2 = 966,
	FN_SSI_SDATA9_B___2 = 967,
	FN_TS_SDAT0_D___2 = 968,
	FN_STP_ISD_0_D___2 = 969,
	FN_RIF0_D1_C___2 = 970,
	FN_IP14_19_16___2 = 971,
	FN_MLB_DAT___2 = 972,
	FN_TX1_B___2 = 973,
	FN_MSIOF1_RXD_F___2 = 974,
	FN_IP15_19_16___2 = 975,
	FN_SSI_SDATA3___2 = 976,
	FN_HRTS2_N_A___2 = 977,
	FN_MSIOF1_TXD_A___2 = 978,
	FN_TS_SCK0_A___2 = 979,
	FN_STP_ISCLK_0_A___2 = 980,
	FN_RIF0_D1_A___2 = 981,
	FN_RIF2_D0_A___2 = 982,
	FN_IP12_23_20___2 = 983,
	FN_CTS1_N___2 = 984,
	FN_HCTS1_N_A___2 = 985,
	FN_MSIOF1_RXD_B___2 = 986,
	FN_TS_SDEN1_C___2 = 987,
	FN_STP_ISEN_1_C___2 = 988,
	FN_RIF1_D0_B___2 = 989,
	FN_ADIDATA___2 = 990,
	FN_IP13_23_20___2 = 991,
	FN_HCTS0_N___2 = 992,
	FN_RX2_B___2 = 993,
	FN_MSIOF1_SYNC_D___2 = 994,
	FN_SSI_SCK9_A___2 = 995,
	FN_TS_SPSYNC0_D___2 = 996,
	FN_STP_ISSYNC_0_D___2 = 997,
	FN_RIF0_SYNC_C___2 = 998,
	FN_AUDIO_CLKOUT1_A___2 = 999,
	FN_IP14_23_20___2 = 1000,
	FN_SSI_SCK01239___2 = 1001,
	FN_MSIOF1_TXD_F___2 = 1002,
	FN_IP15_23_20___2 = 1003,
	FN_SSI_SCK4___2 = 1004,
	FN_HRX2_A___2 = 1005,
	FN_MSIOF1_SCK_A___2 = 1006,
	FN_TS_SDAT0_A___2 = 1007,
	FN_STP_ISD_0_A___2 = 1008,
	FN_RIF0_CLK_A___2 = 1009,
	FN_RIF2_CLK_A___2 = 1010,
	FN_IP12_27_24___2 = 1011,
	FN_RTS1_N___2 = 1012,
	FN_HRTS1_N_A___2 = 1013,
	FN_MSIOF1_TXD_B___2 = 1014,
	FN_TS_SDAT1_C___2 = 1015,
	FN_STP_ISD_1_C___2 = 1016,
	FN_RIF1_D1_B___2 = 1017,
	FN_ADICHS0___2 = 1018,
	FN_IP13_27_24___2 = 1019,
	FN_HRTS0_N___2 = 1020,
	FN_TX2_B___2 = 1021,
	FN_MSIOF1_SS1_D___2 = 1022,
	FN_SSI_WS9_A___2 = 1023,
	FN_STP_IVCXO27_0_D___2 = 1024,
	FN_BPFCLK_A___2 = 1025,
	FN_AUDIO_CLKOUT2_A___2 = 1026,
	FN_IP14_27_24___2 = 1027,
	FN_SSI_WS01239___2 = 1028,
	FN_MSIOF1_SS1_F___2 = 1029,
	FN_IP15_27_24___2 = 1030,
	FN_SSI_WS4___2 = 1031,
	FN_HTX2_A___2 = 1032,
	FN_MSIOF1_SYNC_A___2 = 1033,
	FN_TS_SDEN0_A___2 = 1034,
	FN_STP_ISEN_0_A___2 = 1035,
	FN_RIF0_SYNC_A___2 = 1036,
	FN_RIF2_SYNC_A___2 = 1037,
	FN_IP12_31_28___2 = 1038,
	FN_SCK2___2 = 1039,
	FN_SCIF_CLK_B___2 = 1040,
	FN_MSIOF1_SCK_B___2 = 1041,
	FN_TS_SCK1_C___2 = 1042,
	FN_STP_ISCLK_1_C___2 = 1043,
	FN_RIF1_CLK_B___2 = 1044,
	FN_ADICLK___2 = 1045,
	FN_IP13_31_28___2 = 1046,
	FN_MSIOF0_SYNC___2 = 1047,
	FN_AUDIO_CLKOUT_A___2 = 1048,
	FN_TX5_B___2 = 1049,
	FN_BPFCLK_D___2 = 1050,
	FN_IP14_31_28___2 = 1051,
	FN_SSI_SDATA0___2 = 1052,
	FN_MSIOF1_SS2_F___2 = 1053,
	FN_IP15_31_28___2 = 1054,
	FN_SSI_SDATA4___2 = 1055,
	FN_HSCK2_A___2 = 1056,
	FN_MSIOF1_RXD_A___2 = 1057,
	FN_TS_SPSYNC0_A___2 = 1058,
	FN_STP_ISSYNC_0_A___2 = 1059,
	FN_RIF0_D0_A___2 = 1060,
	FN_RIF2_D1_A___2 = 1061,
	FN_IP16_3_0___2 = 1062,
	FN_SSI_SCK6___2 = 1063,
	FN_SIM0_RST_D___2 = 1064,
	FN_IP17_3_0___2 = 1065,
	FN_AUDIO_CLKA_A___2 = 1066,
	FN_IP18_3_0___2 = 1067,
	FN_GP6_30___2 = 1068,
	FN_AUDIO_CLKOUT2_B___2 = 1069,
	FN_SSI_SCK9_B___2 = 1070,
	FN_TS_SDEN0_E___2 = 1071,
	FN_STP_ISEN_0_E___2 = 1072,
	FN_RIF2_D0_B___2 = 1073,
	FN_TPU0TO2___2 = 1074,
	FN_FMCLK_C___2 = 1075,
	FN_FMCLK_D___2 = 1076,
	FN_IP16_7_4___2 = 1077,
	FN_SSI_WS6___2 = 1078,
	FN_SIM0_D_D___2 = 1079,
	FN_IP17_7_4___2 = 1080,
	FN_AUDIO_CLKB_B___2 = 1081,
	FN_SCIF_CLK_A___2 = 1082,
	FN_STP_IVCXO27_1_D___2 = 1083,
	FN_REMOCON_A___2 = 1084,
	FN_TCLK1_A___2 = 1085,
	FN_IP18_7_4___2 = 1086,
	FN_GP6_31___2 = 1087,
	FN_AUDIO_CLKOUT3_B___2 = 1088,
	FN_SSI_WS9_B___2 = 1089,
	FN_TS_SPSYNC0_E___2 = 1090,
	FN_STP_ISSYNC_0_E___2 = 1091,
	FN_RIF2_D1_B___2 = 1092,
	FN_TPU0TO3___2 = 1093,
	FN_FMIN_C___2 = 1094,
	FN_FMIN_D___2 = 1095,
	FN_IP16_11_8___2 = 1096,
	FN_SSI_SDATA6___2 = 1097,
	FN_SIM0_CLK_D___2 = 1098,
	FN_SATA_DEVSLP_A = 1099,
	FN_IP17_11_8___2 = 1100,
	FN_USB0_PWEN___2 = 1101,
	FN_SIM0_RST_C___2 = 1102,
	FN_TS_SCK1_D___2 = 1103,
	FN_STP_ISCLK_1_D___2 = 1104,
	FN_BPFCLK_B___2 = 1105,
	FN_RIF3_CLK_B___2 = 1106,
	FN_HSCK2_C___2 = 1107,
	FN_IP16_15_12___2 = 1108,
	FN_SSI_SCK78___2 = 1109,
	FN_HRX2_B___2 = 1110,
	FN_MSIOF1_SCK_C___2 = 1111,
	FN_TS_SCK1_A___2 = 1112,
	FN_STP_ISCLK_1_A___2 = 1113,
	FN_RIF1_CLK_A___2 = 1114,
	FN_RIF3_CLK_A___2 = 1115,
	FN_IP17_15_12___2 = 1116,
	FN_USB0_OVC___2 = 1117,
	FN_SIM0_D_C___2 = 1118,
	FN_TS_SDAT1_D___2 = 1119,
	FN_STP_ISD_1_D___2 = 1120,
	FN_RIF3_SYNC_B___2 = 1121,
	FN_HRX2_C___2 = 1122,
	FN_IP16_19_16___2 = 1123,
	FN_SSI_WS78___2 = 1124,
	FN_HTX2_B___2 = 1125,
	FN_MSIOF1_SYNC_C___2 = 1126,
	FN_TS_SDAT1_A___2 = 1127,
	FN_STP_ISD_1_A___2 = 1128,
	FN_RIF1_SYNC_A___2 = 1129,
	FN_RIF3_SYNC_A___2 = 1130,
	FN_IP17_19_16___2 = 1131,
	FN_USB1_PWEN___2 = 1132,
	FN_SIM0_CLK_C___2 = 1133,
	FN_SSI_SCK1_A___2 = 1134,
	FN_TS_SCK0_E___2 = 1135,
	FN_STP_ISCLK_0_E___2 = 1136,
	FN_FMCLK_B___2 = 1137,
	FN_RIF2_CLK_B___2 = 1138,
	FN_SPEEDIN_A___2 = 1139,
	FN_HTX2_C___2 = 1140,
	FN_IP16_23_20___2 = 1141,
	FN_SSI_SDATA7___2 = 1142,
	FN_HCTS2_N_B___2 = 1143,
	FN_MSIOF1_RXD_C___2 = 1144,
	FN_TS_SDEN1_A___2 = 1145,
	FN_STP_ISEN_1_A___2 = 1146,
	FN_RIF1_D0_A___2 = 1147,
	FN_RIF3_D0_A___2 = 1148,
	FN_TCLK2_A___2 = 1149,
	FN_IP17_23_20___2 = 1150,
	FN_USB1_OVC___2 = 1151,
	FN_MSIOF1_SS2_C___2 = 1152,
	FN_SSI_WS1_A___2 = 1153,
	FN_TS_SDAT0_E___2 = 1154,
	FN_STP_ISD_0_E___2 = 1155,
	FN_FMIN_B___2 = 1156,
	FN_RIF2_SYNC_B___2 = 1157,
	FN_REMOCON_B___2 = 1158,
	FN_HCTS2_N_C___2 = 1159,
	FN_IP16_27_24___2 = 1160,
	FN_SSI_SDATA8___2 = 1161,
	FN_HRTS2_N_B___2 = 1162,
	FN_MSIOF1_TXD_C___2 = 1163,
	FN_TS_SPSYNC1_A___2 = 1164,
	FN_STP_ISSYNC_1_A___2 = 1165,
	FN_RIF1_D1_A___2 = 1166,
	FN_RIF3_D1_A___2 = 1167,
	FN_IP17_27_24___2 = 1168,
	FN_USB30_PWEN___2 = 1169,
	FN_AUDIO_CLKOUT_B___2 = 1170,
	FN_SSI_SCK2_B___2 = 1171,
	FN_TS_SDEN1_D___2 = 1172,
	FN_STP_ISEN_1_D___2 = 1173,
	FN_STP_OPWM_0_E___2 = 1174,
	FN_RIF3_D0_B___2 = 1175,
	FN_TCLK2_B___2 = 1176,
	FN_TPU0TO0___2 = 1177,
	FN_BPFCLK_C___2 = 1178,
	FN_HRTS2_N_C___2 = 1179,
	FN_IP16_31_28___2 = 1180,
	FN_SSI_SDATA9_A___2 = 1181,
	FN_HSCK2_B___2 = 1182,
	FN_MSIOF1_SS1_C___2 = 1183,
	FN_HSCK1_A___2 = 1184,
	FN_SSI_WS1_B___2 = 1185,
	FN_SCK1___2 = 1186,
	FN_STP_IVCXO27_1_A___2 = 1187,
	FN_SCK5_A___2 = 1188,
	FN_IP17_31_28___2 = 1189,
	FN_USB30_OVC___2 = 1190,
	FN_AUDIO_CLKOUT1_B___2 = 1191,
	FN_SSI_WS2_B___2 = 1192,
	FN_TS_SPSYNC1_D___2 = 1193,
	FN_STP_ISSYNC_1_D___2 = 1194,
	FN_STP_IVCXO27_0_E___2 = 1195,
	FN_RIF3_D1_B___2 = 1196,
	FN_FSO_TOE_N___2 = 1197,
	FN_TPU0TO1___2 = 1198,
	FN_SEL_MSIOF3_0___2 = 1199,
	FN_SEL_MSIOF3_1___2 = 1200,
	FN_SEL_MSIOF3_2___2 = 1201,
	FN_SEL_MSIOF3_3___2 = 1202,
	FN_SEL_MSIOF3_4___2 = 1203,
	FN_SEL_TSIF1_0___2 = 1204,
	FN_SEL_TSIF1_1___2 = 1205,
	FN_SEL_TSIF1_2___2 = 1206,
	FN_SEL_TSIF1_3___2 = 1207,
	FN_I2C_SEL_5_0___2 = 1208,
	FN_I2C_SEL_5_1___2 = 1209,
	FN_I2C_SEL_3_0___2 = 1210,
	FN_I2C_SEL_3_1___2 = 1211,
	FN_SEL_TSIF0_0___2 = 1212,
	FN_SEL_TSIF0_1___2 = 1213,
	FN_SEL_TSIF0_2___2 = 1214,
	FN_SEL_TSIF0_3___2 = 1215,
	FN_SEL_TSIF0_4___2 = 1216,
	FN_I2C_SEL_0_0___2 = 1217,
	FN_I2C_SEL_0_1___2 = 1218,
	FN_SEL_MSIOF2_0___2 = 1219,
	FN_SEL_MSIOF2_1___2 = 1220,
	FN_SEL_MSIOF2_2___2 = 1221,
	FN_SEL_MSIOF2_3___2 = 1222,
	FN_SEL_FM_0___2 = 1223,
	FN_SEL_FM_1___2 = 1224,
	FN_SEL_FM_2___2 = 1225,
	FN_SEL_FM_3___2 = 1226,
	FN_SEL_MSIOF1_0___2 = 1227,
	FN_SEL_MSIOF1_1___2 = 1228,
	FN_SEL_MSIOF1_2___2 = 1229,
	FN_SEL_MSIOF1_3___2 = 1230,
	FN_SEL_MSIOF1_4___2 = 1231,
	FN_SEL_MSIOF1_5___2 = 1232,
	FN_SEL_MSIOF1_6___2 = 1233,
	FN_SEL_TIMER_TMU_0___2 = 1234,
	FN_SEL_TIMER_TMU_1___2 = 1235,
	FN_SEL_SCIF5_0___2 = 1236,
	FN_SEL_SCIF5_1___2 = 1237,
	FN_SEL_SSP1_1_0___2 = 1238,
	FN_SEL_SSP1_1_1___2 = 1239,
	FN_SEL_SSP1_1_2___2 = 1240,
	FN_SEL_SSP1_1_3___2 = 1241,
	FN_SEL_I2C6_0___2 = 1242,
	FN_SEL_I2C6_1___2 = 1243,
	FN_SEL_I2C6_2___2 = 1244,
	FN_SEL_LBSC_0___2 = 1245,
	FN_SEL_LBSC_1___2 = 1246,
	FN_SEL_SSP1_0_0___2 = 1247,
	FN_SEL_SSP1_0_1___2 = 1248,
	FN_SEL_SSP1_0_2___2 = 1249,
	FN_SEL_SSP1_0_3___2 = 1250,
	FN_SEL_SSP1_0_4___2 = 1251,
	FN_SEL_IEBUS_0___2 = 1252,
	FN_SEL_IEBUS_1___2 = 1253,
	FN_SEL_NDF_0___2 = 1254,
	FN_SEL_NDF_1___2 = 1255,
	FN_SEL_I2C2_0___2 = 1256,
	FN_SEL_I2C2_1___2 = 1257,
	FN_SEL_SSI2_0___2 = 1258,
	FN_SEL_SSI2_1___2 = 1259,
	FN_SEL_I2C1_0___2 = 1260,
	FN_SEL_I2C1_1___2 = 1261,
	FN_SEL_SSI1_0___2 = 1262,
	FN_SEL_SSI1_1___2 = 1263,
	FN_SEL_SSI9_0___2 = 1264,
	FN_SEL_SSI9_1___2 = 1265,
	FN_SEL_HSCIF4_0___2 = 1266,
	FN_SEL_HSCIF4_1___2 = 1267,
	FN_SEL_SPEED_PULSE_0___2 = 1268,
	FN_SEL_SPEED_PULSE_1___2 = 1269,
	FN_SEL_TIMER_TMU2_0___2 = 1270,
	FN_SEL_TIMER_TMU2_1___2 = 1271,
	FN_SEL_HSCIF3_0___2 = 1272,
	FN_SEL_HSCIF3_1___2 = 1273,
	FN_SEL_HSCIF3_2___2 = 1274,
	FN_SEL_HSCIF3_3___2 = 1275,
	FN_SEL_SIMCARD_0___2 = 1276,
	FN_SEL_SIMCARD_1___2 = 1277,
	FN_SEL_SIMCARD_2___2 = 1278,
	FN_SEL_SIMCARD_3___2 = 1279,
	FN_SEL_ADGB_0___2 = 1280,
	FN_SEL_ADGB_1___2 = 1281,
	FN_SEL_ADGC_0___2 = 1282,
	FN_SEL_ADGC_1___2 = 1283,
	FN_SEL_HSCIF1_0___2 = 1284,
	FN_SEL_HSCIF1_1___2 = 1285,
	FN_SEL_SDHI2_0___2 = 1286,
	FN_SEL_SDHI2_1___2 = 1287,
	FN_SEL_SCIF4_0___2 = 1288,
	FN_SEL_SCIF4_1___2 = 1289,
	FN_SEL_SCIF4_2___2 = 1290,
	FN_SEL_HSCIF2_0___2 = 1291,
	FN_SEL_HSCIF2_1___2 = 1292,
	FN_SEL_HSCIF2_2___2 = 1293,
	FN_SEL_SCIF3_0___2 = 1294,
	FN_SEL_SCIF3_1___2 = 1295,
	FN_SEL_ETHERAVB_0___2 = 1296,
	FN_SEL_ETHERAVB_1___2 = 1297,
	FN_SEL_SCIF2_0___2 = 1298,
	FN_SEL_SCIF2_1___2 = 1299,
	FN_SEL_DRIF3_0___2 = 1300,
	FN_SEL_DRIF3_1___2 = 1301,
	FN_SEL_SCIF1_0___2 = 1302,
	FN_SEL_SCIF1_1___2 = 1303,
	FN_SEL_DRIF2_0___2 = 1304,
	FN_SEL_DRIF2_1___2 = 1305,
	FN_SEL_SCIF_0___2 = 1306,
	FN_SEL_SCIF_1___2 = 1307,
	FN_SEL_DRIF1_0___2 = 1308,
	FN_SEL_DRIF1_1___2 = 1309,
	FN_SEL_DRIF1_2___2 = 1310,
	FN_SEL_REMOCON_0___2 = 1311,
	FN_SEL_REMOCON_1___2 = 1312,
	FN_SEL_DRIF0_0___2 = 1313,
	FN_SEL_DRIF0_1___2 = 1314,
	FN_SEL_DRIF0_2___2 = 1315,
	FN_SEL_RCAN0_0___2 = 1316,
	FN_SEL_RCAN0_1___2 = 1317,
	FN_SEL_CANFD0_0___2 = 1318,
	FN_SEL_CANFD0_1___2 = 1319,
	FN_SEL_PWM6_0___2 = 1320,
	FN_SEL_PWM6_1___2 = 1321,
	FN_SEL_ADGA_0___2 = 1322,
	FN_SEL_ADGA_1___2 = 1323,
	FN_SEL_ADGA_2___2 = 1324,
	FN_SEL_ADGA_3___2 = 1325,
	FN_SEL_PWM5_0___2 = 1326,
	FN_SEL_PWM5_1___2 = 1327,
	FN_SEL_PWM4_0___2 = 1328,
	FN_SEL_PWM4_1___2 = 1329,
	FN_SEL_PWM3_0___2 = 1330,
	FN_SEL_PWM3_1___2 = 1331,
	FN_SEL_PWM2_0___2 = 1332,
	FN_SEL_PWM2_1___2 = 1333,
	FN_SEL_PWM1_0___2 = 1334,
	FN_SEL_PWM1_1___2 = 1335,
	FN_SEL_VIN4_0___2 = 1336,
	FN_SEL_VIN4_1___2 = 1337,
	PINMUX_FUNCTION_END___2 = 1338,
	PINMUX_MARK_BEGIN___2 = 1339,
	CLKOUT_MARK___2 = 1340,
	MSIOF0_RXD_MARK___2 = 1341,
	MSIOF0_TXD_MARK___2 = 1342,
	MSIOF0_SCK_MARK___2 = 1343,
	SSI_SDATA5_MARK___2 = 1344,
	SSI_WS5_MARK___2 = 1345,
	SSI_SCK5_MARK___2 = 1346,
	GP7_03_MARK___2 = 1347,
	GP7_02_MARK___2 = 1348,
	AVS2_MARK___2 = 1349,
	AVS1_MARK___2 = 1350,
	IP0_3_0_MARK___2 = 1351,
	AVB_MDC_MARK___2 = 1352,
	MSIOF2_SS2_C_MARK___2 = 1353,
	IP1_3_0_MARK___2 = 1354,
	IRQ2_MARK___2 = 1355,
	QCPV_QDE_MARK___2 = 1356,
	DU_EXODDF_DU_ODDF_DISP_CDE_MARK___2 = 1357,
	VI4_DATA2_B_MARK___2 = 1358,
	MSIOF3_SYNC_E_MARK___2 = 1359,
	PWM3_B_MARK___2 = 1360,
	IP2_3_0_MARK___2 = 1361,
	A1_MARK___2 = 1362,
	LCDOUT17_MARK___2 = 1363,
	MSIOF3_TXD_B_MARK___2 = 1364,
	VI4_DATA9_MARK___2 = 1365,
	DU_DB1_MARK___2 = 1366,
	PWM4_A_MARK___2 = 1367,
	IP3_3_0_MARK___2 = 1368,
	A9_MARK___2 = 1369,
	MSIOF2_SCK_A_MARK___2 = 1370,
	CTS4_N_B_MARK___2 = 1371,
	VI5_VSYNC_N_MARK___2 = 1372,
	IP0_7_4_MARK___2 = 1373,
	AVB_MAGIC_MARK___2 = 1374,
	MSIOF2_SS1_C_MARK___2 = 1375,
	SCK4_A_MARK___2 = 1376,
	IP1_7_4_MARK___2 = 1377,
	IRQ3_MARK___2 = 1378,
	QSTVB_QVE_MARK___2 = 1379,
	DU_DOTCLKOUT1_MARK___2 = 1380,
	VI4_DATA3_B_MARK___2 = 1381,
	MSIOF3_SCK_E_MARK___2 = 1382,
	PWM4_B_MARK___2 = 1383,
	IP2_7_4_MARK___2 = 1384,
	A2_MARK___2 = 1385,
	LCDOUT18_MARK___2 = 1386,
	MSIOF3_SCK_B_MARK___2 = 1387,
	VI4_DATA10_MARK___2 = 1388,
	DU_DB2_MARK___2 = 1389,
	PWM5_A_MARK___2 = 1390,
	IP3_7_4_MARK___2 = 1391,
	A10_MARK___2 = 1392,
	MSIOF2_RXD_A_MARK___2 = 1393,
	RTS4_N_B_MARK___2 = 1394,
	VI5_HSYNC_N_MARK___2 = 1395,
	IP0_11_8_MARK___2 = 1396,
	AVB_PHY_INT_MARK___2 = 1397,
	MSIOF2_SYNC_C_MARK___2 = 1398,
	RX4_A_MARK___2 = 1399,
	IP1_11_8_MARK___2 = 1400,
	IRQ4_MARK___2 = 1401,
	QSTH_QHS_MARK___2 = 1402,
	DU_EXHSYNC_DU_HSYNC_MARK___2 = 1403,
	VI4_DATA4_B_MARK___2 = 1404,
	MSIOF3_RXD_E_MARK___2 = 1405,
	PWM5_B_MARK___2 = 1406,
	IP2_11_8_MARK___2 = 1407,
	A3_MARK___2 = 1408,
	LCDOUT19_MARK___2 = 1409,
	MSIOF3_RXD_B_MARK___2 = 1410,
	VI4_DATA11_MARK___2 = 1411,
	DU_DB3_MARK___2 = 1412,
	PWM6_A_MARK___2 = 1413,
	IP3_11_8_MARK___2 = 1414,
	A11_MARK___2 = 1415,
	TX3_B_MARK___2 = 1416,
	MSIOF2_TXD_A_MARK___2 = 1417,
	HTX4_B_MARK___2 = 1418,
	HSCK4_MARK___2 = 1419,
	VI5_FIELD_MARK___2 = 1420,
	SCL6_A_MARK___2 = 1421,
	AVB_AVTP_CAPTURE_B_MARK___2 = 1422,
	PWM2_B_MARK___2 = 1423,
	IP0_15_12_MARK___2 = 1424,
	AVB_LINK_MARK___2 = 1425,
	MSIOF2_SCK_C_MARK___2 = 1426,
	TX4_A_MARK___2 = 1427,
	IP1_15_12_MARK___2 = 1428,
	IRQ5_MARK___2 = 1429,
	QSTB_QHE_MARK___2 = 1430,
	DU_EXVSYNC_DU_VSYNC_MARK___2 = 1431,
	VI4_DATA5_B_MARK___2 = 1432,
	FSCLKST2_N_B_MARK = 1433,
	MSIOF3_TXD_E_MARK___2 = 1434,
	PWM6_B_MARK___2 = 1435,
	IP2_15_12_MARK___2 = 1436,
	A4_MARK___2 = 1437,
	LCDOUT20_MARK___2 = 1438,
	MSIOF3_SS1_B_MARK___2 = 1439,
	VI4_DATA12_MARK___2 = 1440,
	VI5_DATA12_MARK___2 = 1441,
	DU_DB4_MARK___2 = 1442,
	IP3_15_12_MARK___2 = 1443,
	A12_MARK___2 = 1444,
	LCDOUT12_MARK___2 = 1445,
	MSIOF3_SCK_C_MARK___2 = 1446,
	HRX4_A_MARK___2 = 1447,
	VI5_DATA8_MARK___2 = 1448,
	DU_DG4_MARK___2 = 1449,
	IP0_19_16_MARK___2 = 1450,
	AVB_AVTP_MATCH_A_MARK___2 = 1451,
	MSIOF2_RXD_C_MARK___2 = 1452,
	CTS4_N_A_MARK___2 = 1453,
	FSCLKST2_N_A_MARK = 1454,
	IP1_19_16_MARK___2 = 1455,
	PWM0_MARK___2 = 1456,
	AVB_AVTP_PPS_MARK___2 = 1457,
	VI4_DATA6_B_MARK___2 = 1458,
	IECLK_B_MARK___2 = 1459,
	IP2_19_16_MARK___2 = 1460,
	A5_MARK___2 = 1461,
	LCDOUT21_MARK___2 = 1462,
	MSIOF3_SS2_B_MARK___2 = 1463,
	SCK4_B_MARK___2 = 1464,
	VI4_DATA13_MARK___2 = 1465,
	VI5_DATA13_MARK___2 = 1466,
	DU_DB5_MARK___2 = 1467,
	IP3_19_16_MARK___2 = 1468,
	A13_MARK___2 = 1469,
	LCDOUT13_MARK___2 = 1470,
	MSIOF3_SYNC_C_MARK___2 = 1471,
	HTX4_A_MARK___2 = 1472,
	VI5_DATA9_MARK___2 = 1473,
	DU_DG5_MARK___2 = 1474,
	IP0_23_20_MARK___2 = 1475,
	AVB_AVTP_CAPTURE_A_MARK___2 = 1476,
	MSIOF2_TXD_C_MARK___2 = 1477,
	RTS4_N_A_MARK___2 = 1478,
	IP1_23_20_MARK___2 = 1479,
	PWM1_A_MARK___2 = 1480,
	HRX3_D_MARK___2 = 1481,
	VI4_DATA7_B_MARK___2 = 1482,
	IERX_B_MARK___2 = 1483,
	IP2_23_20_MARK___2 = 1484,
	A6_MARK___2 = 1485,
	LCDOUT22_MARK___2 = 1486,
	MSIOF2_SS1_A_MARK___2 = 1487,
	RX4_B_MARK___2 = 1488,
	VI4_DATA14_MARK___2 = 1489,
	VI5_DATA14_MARK___2 = 1490,
	DU_DB6_MARK___2 = 1491,
	IP3_23_20_MARK___2 = 1492,
	A14_MARK___2 = 1493,
	LCDOUT14_MARK___2 = 1494,
	MSIOF3_RXD_C_MARK___2 = 1495,
	HCTS4_N_MARK___2 = 1496,
	VI5_DATA10_MARK___2 = 1497,
	DU_DG6_MARK___2 = 1498,
	IP0_27_24_MARK___2 = 1499,
	IRQ0_MARK___2 = 1500,
	QPOLB_MARK___2 = 1501,
	DU_CDE_MARK___2 = 1502,
	VI4_DATA0_B_MARK___2 = 1503,
	CAN0_TX_B_MARK___2 = 1504,
	CANFD0_TX_B_MARK___2 = 1505,
	MSIOF3_SS2_E_MARK___2 = 1506,
	IP1_27_24_MARK___2 = 1507,
	PWM2_A_MARK___2 = 1508,
	HTX3_D_MARK___2 = 1509,
	IETX_B_MARK___2 = 1510,
	IP2_27_24_MARK___2 = 1511,
	A7_MARK___2 = 1512,
	LCDOUT23_MARK___2 = 1513,
	MSIOF2_SS2_A_MARK___2 = 1514,
	TX4_B_MARK___2 = 1515,
	VI4_DATA15_MARK___2 = 1516,
	VI5_DATA15_MARK___2 = 1517,
	DU_DB7_MARK___2 = 1518,
	IP3_27_24_MARK___2 = 1519,
	A15_MARK___2 = 1520,
	LCDOUT15_MARK___2 = 1521,
	MSIOF3_TXD_C_MARK___2 = 1522,
	HRTS4_N_MARK___2 = 1523,
	VI5_DATA11_MARK___2 = 1524,
	DU_DG7_MARK___2 = 1525,
	IP0_31_28_MARK___2 = 1526,
	IRQ1_MARK___2 = 1527,
	QPOLA_MARK___2 = 1528,
	DU_DISP_MARK___2 = 1529,
	VI4_DATA1_B_MARK___2 = 1530,
	CAN0_RX_B_MARK___2 = 1531,
	CANFD0_RX_B_MARK___2 = 1532,
	MSIOF3_SS1_E_MARK___2 = 1533,
	IP1_31_28_MARK___2 = 1534,
	A0_MARK___2 = 1535,
	LCDOUT16_MARK___2 = 1536,
	MSIOF3_SYNC_B_MARK___2 = 1537,
	VI4_DATA8_MARK___2 = 1538,
	DU_DB0_MARK___2 = 1539,
	PWM3_A_MARK___2 = 1540,
	IP2_31_28_MARK___2 = 1541,
	A8_MARK___2 = 1542,
	RX3_B_MARK___2 = 1543,
	MSIOF2_SYNC_A_MARK___2 = 1544,
	HRX4_B_MARK___2 = 1545,
	SDA6_A_MARK___2 = 1546,
	AVB_AVTP_MATCH_B_MARK___2 = 1547,
	PWM1_B_MARK___2 = 1548,
	IP3_31_28_MARK___2 = 1549,
	A16_MARK___2 = 1550,
	LCDOUT8_MARK___2 = 1551,
	VI4_FIELD_MARK___2 = 1552,
	DU_DG0_MARK___2 = 1553,
	IP4_3_0_MARK___2 = 1554,
	A17_MARK___2 = 1555,
	LCDOUT9_MARK___2 = 1556,
	VI4_VSYNC_N_MARK___2 = 1557,
	DU_DG1_MARK___2 = 1558,
	IP5_3_0_MARK___2 = 1559,
	WE0_N_MARK___2 = 1560,
	MSIOF3_TXD_D_MARK___2 = 1561,
	CTS3_N_MARK___2 = 1562,
	HCTS3_N_MARK___2 = 1563,
	SCL6_B_MARK___2 = 1564,
	CAN_CLK_MARK___2 = 1565,
	IECLK_A_MARK___2 = 1566,
	IP6_3_0_MARK___2 = 1567,
	D5_MARK___2 = 1568,
	MSIOF2_SYNC_B_MARK___2 = 1569,
	VI4_DATA21_MARK___2 = 1570,
	VI5_DATA5_MARK___2 = 1571,
	IP7_3_0_MARK___2 = 1572,
	D13_MARK___2 = 1573,
	LCDOUT5_MARK___2 = 1574,
	MSIOF2_SS2_D_MARK___2 = 1575,
	TX4_C_MARK___2 = 1576,
	VI4_DATA5_A_MARK___2 = 1577,
	DU_DR5_MARK___2 = 1578,
	IP4_7_4_MARK___2 = 1579,
	A18_MARK___2 = 1580,
	LCDOUT10_MARK___2 = 1581,
	VI4_HSYNC_N_MARK___2 = 1582,
	DU_DG2_MARK___2 = 1583,
	IP5_7_4_MARK___2 = 1584,
	WE1_N_MARK___2 = 1585,
	MSIOF3_SS1_D_MARK___2 = 1586,
	RTS3_N_MARK___2 = 1587,
	HRTS3_N_MARK___2 = 1588,
	SDA6_B_MARK___2 = 1589,
	CAN1_RX_MARK___2 = 1590,
	CANFD1_RX_MARK___2 = 1591,
	IERX_A_MARK___2 = 1592,
	IP6_7_4_MARK___2 = 1593,
	D6_MARK___2 = 1594,
	MSIOF2_RXD_B_MARK___2 = 1595,
	VI4_DATA22_MARK___2 = 1596,
	VI5_DATA6_MARK___2 = 1597,
	IP7_7_4_MARK___2 = 1598,
	D14_MARK___2 = 1599,
	LCDOUT6_MARK___2 = 1600,
	MSIOF3_SS1_A_MARK___2 = 1601,
	HRX3_C_MARK___2 = 1602,
	VI4_DATA6_A_MARK___2 = 1603,
	DU_DR6_MARK___2 = 1604,
	SCL6_C_MARK___2 = 1605,
	IP4_11_8_MARK___2 = 1606,
	A19_MARK___2 = 1607,
	LCDOUT11_MARK___2 = 1608,
	VI4_CLKENB_MARK___2 = 1609,
	DU_DG3_MARK___2 = 1610,
	IP5_11_8_MARK___2 = 1611,
	EX_WAIT0_A_MARK___2 = 1612,
	QCLK_MARK___2 = 1613,
	VI4_CLK_MARK___2 = 1614,
	DU_DOTCLKOUT0_MARK___2 = 1615,
	IP6_11_8_MARK___2 = 1616,
	D7_MARK___2 = 1617,
	MSIOF2_TXD_B_MARK___2 = 1618,
	VI4_DATA23_MARK___2 = 1619,
	VI5_DATA7_MARK___2 = 1620,
	IP7_11_8_MARK___2 = 1621,
	D15_MARK___2 = 1622,
	LCDOUT7_MARK___2 = 1623,
	MSIOF3_SS2_A_MARK___2 = 1624,
	HTX3_C_MARK___2 = 1625,
	VI4_DATA7_A_MARK___2 = 1626,
	DU_DR7_MARK___2 = 1627,
	SDA6_C_MARK___2 = 1628,
	IP4_15_12_MARK___2 = 1629,
	CS0_N_MARK___2 = 1630,
	VI5_CLKENB_MARK___2 = 1631,
	IP5_15_12_MARK___2 = 1632,
	D0_MARK___2 = 1633,
	MSIOF2_SS1_B_MARK___2 = 1634,
	MSIOF3_SCK_A_MARK___2 = 1635,
	VI4_DATA16_MARK___2 = 1636,
	VI5_DATA0_MARK___2 = 1637,
	IP6_15_12_MARK___2 = 1638,
	D8_MARK___2 = 1639,
	LCDOUT0_MARK___2 = 1640,
	MSIOF2_SCK_D_MARK___2 = 1641,
	SCK4_C_MARK___2 = 1642,
	VI4_DATA0_A_MARK___2 = 1643,
	DU_DR0_MARK___2 = 1644,
	IP4_19_16_MARK___2 = 1645,
	CS1_N_MARK___2 = 1646,
	VI5_CLK_MARK___2 = 1647,
	EX_WAIT0_B_MARK___2 = 1648,
	IP5_19_16_MARK___2 = 1649,
	D1_MARK___2 = 1650,
	MSIOF2_SS2_B_MARK___2 = 1651,
	MSIOF3_SYNC_A_MARK___2 = 1652,
	VI4_DATA17_MARK___2 = 1653,
	VI5_DATA1_MARK___2 = 1654,
	IP6_19_16_MARK___2 = 1655,
	D9_MARK___2 = 1656,
	LCDOUT1_MARK___2 = 1657,
	MSIOF2_SYNC_D_MARK___2 = 1658,
	VI4_DATA1_A_MARK___2 = 1659,
	DU_DR1_MARK___2 = 1660,
	IP7_19_16_MARK___2 = 1661,
	SD0_CLK_MARK___2 = 1662,
	MSIOF1_SCK_E_MARK___2 = 1663,
	STP_OPWM_0_B_MARK___2 = 1664,
	IP4_23_20_MARK___2 = 1665,
	BS_N_MARK___2 = 1666,
	QSTVA_QVS_MARK___2 = 1667,
	MSIOF3_SCK_D_MARK___2 = 1668,
	SCK3_MARK___2 = 1669,
	HSCK3_MARK___2 = 1670,
	CAN1_TX_MARK___2 = 1671,
	CANFD1_TX_MARK___2 = 1672,
	IETX_A_MARK___2 = 1673,
	IP5_23_20_MARK___2 = 1674,
	D2_MARK___2 = 1675,
	MSIOF3_RXD_A_MARK___2 = 1676,
	VI4_DATA18_MARK___2 = 1677,
	VI5_DATA2_MARK___2 = 1678,
	IP6_23_20_MARK___2 = 1679,
	D10_MARK___2 = 1680,
	LCDOUT2_MARK___2 = 1681,
	MSIOF2_RXD_D_MARK___2 = 1682,
	HRX3_B_MARK___2 = 1683,
	VI4_DATA2_A_MARK___2 = 1684,
	CTS4_N_C_MARK___2 = 1685,
	DU_DR2_MARK___2 = 1686,
	IP7_23_20_MARK___2 = 1687,
	SD0_CMD_MARK___2 = 1688,
	MSIOF1_SYNC_E_MARK___2 = 1689,
	STP_IVCXO27_0_B_MARK___2 = 1690,
	IP4_27_24_MARK___2 = 1691,
	RD_N_MARK___2 = 1692,
	MSIOF3_SYNC_D_MARK___2 = 1693,
	RX3_A_MARK___2 = 1694,
	HRX3_A_MARK___2 = 1695,
	CAN0_TX_A_MARK___2 = 1696,
	CANFD0_TX_A_MARK___2 = 1697,
	IP5_27_24_MARK___2 = 1698,
	D3_MARK___2 = 1699,
	MSIOF3_TXD_A_MARK___2 = 1700,
	VI4_DATA19_MARK___2 = 1701,
	VI5_DATA3_MARK___2 = 1702,
	IP6_27_24_MARK___2 = 1703,
	D11_MARK___2 = 1704,
	LCDOUT3_MARK___2 = 1705,
	MSIOF2_TXD_D_MARK___2 = 1706,
	HTX3_B_MARK___2 = 1707,
	VI4_DATA3_A_MARK___2 = 1708,
	RTS4_N_C_MARK___2 = 1709,
	DU_DR3_MARK___2 = 1710,
	IP7_27_24_MARK___2 = 1711,
	SD0_DAT0_MARK___2 = 1712,
	MSIOF1_RXD_E_MARK___2 = 1713,
	TS_SCK0_B_MARK___2 = 1714,
	STP_ISCLK_0_B_MARK___2 = 1715,
	IP4_31_28_MARK___2 = 1716,
	RD_WR_N_MARK___2 = 1717,
	MSIOF3_RXD_D_MARK___2 = 1718,
	TX3_A_MARK___2 = 1719,
	HTX3_A_MARK___2 = 1720,
	CAN0_RX_A_MARK___2 = 1721,
	CANFD0_RX_A_MARK___2 = 1722,
	IP5_31_28_MARK___2 = 1723,
	D4_MARK___2 = 1724,
	MSIOF2_SCK_B_MARK___2 = 1725,
	VI4_DATA20_MARK___2 = 1726,
	VI5_DATA4_MARK___2 = 1727,
	IP6_31_28_MARK___2 = 1728,
	D12_MARK___2 = 1729,
	LCDOUT4_MARK___2 = 1730,
	MSIOF2_SS1_D_MARK___2 = 1731,
	RX4_C_MARK___2 = 1732,
	VI4_DATA4_A_MARK___2 = 1733,
	DU_DR4_MARK___2 = 1734,
	IP7_31_28_MARK___2 = 1735,
	SD0_DAT1_MARK___2 = 1736,
	MSIOF1_TXD_E_MARK___2 = 1737,
	TS_SPSYNC0_B_MARK___2 = 1738,
	STP_ISSYNC_0_B_MARK___2 = 1739,
	IP8_3_0_MARK___2 = 1740,
	SD0_DAT2_MARK___2 = 1741,
	MSIOF1_SS1_E_MARK___2 = 1742,
	TS_SDAT0_B_MARK___2 = 1743,
	STP_ISD_0_B_MARK___2 = 1744,
	IP9_3_0_MARK___2 = 1745,
	SD2_CLK_MARK___2 = 1746,
	NFDATA8_MARK___2 = 1747,
	IP10_3_0_MARK___2 = 1748,
	SD3_CMD_MARK___2 = 1749,
	NFRE_N_MARK___2 = 1750,
	IP11_3_0_MARK___2 = 1751,
	SD3_DAT7_MARK___2 = 1752,
	SD3_WP_MARK___2 = 1753,
	NFDATA7_MARK___2 = 1754,
	IP8_7_4_MARK___2 = 1755,
	SD0_DAT3_MARK___2 = 1756,
	MSIOF1_SS2_E_MARK___2 = 1757,
	TS_SDEN0_B_MARK___2 = 1758,
	STP_ISEN_0_B_MARK___2 = 1759,
	IP9_7_4_MARK___2 = 1760,
	SD2_CMD_MARK___2 = 1761,
	NFDATA9_MARK___2 = 1762,
	IP10_7_4_MARK___2 = 1763,
	SD3_DAT0_MARK___2 = 1764,
	NFDATA0_MARK___2 = 1765,
	IP11_7_4_MARK___2 = 1766,
	SD3_DS_MARK___2 = 1767,
	NFCLE_MARK___2 = 1768,
	IP8_11_8_MARK___2 = 1769,
	SD1_CLK_MARK___2 = 1770,
	MSIOF1_SCK_G_MARK___2 = 1771,
	SIM0_CLK_A_MARK___2 = 1772,
	IP9_11_8_MARK___2 = 1773,
	SD2_DAT0_MARK___2 = 1774,
	NFDATA10_MARK___2 = 1775,
	IP10_11_8_MARK___2 = 1776,
	SD3_DAT1_MARK___2 = 1777,
	NFDATA1_MARK___2 = 1778,
	IP11_11_8_MARK___2 = 1779,
	SD0_CD_MARK___2 = 1780,
	NFDATA14_A_MARK___2 = 1781,
	SCL2_B_MARK___2 = 1782,
	SIM0_RST_A_MARK___2 = 1783,
	IP8_15_12_MARK___2 = 1784,
	SD1_CMD_MARK___2 = 1785,
	MSIOF1_SYNC_G_MARK___2 = 1786,
	NFCE_N_B_MARK___2 = 1787,
	SIM0_D_A_MARK___2 = 1788,
	STP_IVCXO27_1_B_MARK___2 = 1789,
	IP9_15_12_MARK___2 = 1790,
	SD2_DAT1_MARK___2 = 1791,
	NFDATA11_MARK___2 = 1792,
	IP10_15_12_MARK___2 = 1793,
	SD3_DAT2_MARK___2 = 1794,
	NFDATA2_MARK___2 = 1795,
	IP11_15_12_MARK___2 = 1796,
	SD0_WP_MARK___2 = 1797,
	NFDATA15_A_MARK___2 = 1798,
	SDA2_B_MARK___2 = 1799,
	IP8_19_16_MARK___2 = 1800,
	SD1_DAT0_MARK___2 = 1801,
	SD2_DAT4_MARK___2 = 1802,
	MSIOF1_RXD_G_MARK___2 = 1803,
	NFWP_N_B_MARK___2 = 1804,
	TS_SCK1_B_MARK___2 = 1805,
	STP_ISCLK_1_B_MARK___2 = 1806,
	IP9_19_16_MARK___2 = 1807,
	SD2_DAT2_MARK___2 = 1808,
	NFDATA12_MARK___2 = 1809,
	IP10_19_16_MARK___2 = 1810,
	SD3_DAT3_MARK___2 = 1811,
	NFDATA3_MARK___2 = 1812,
	IP11_19_16_MARK___2 = 1813,
	SD1_CD_MARK___2 = 1814,
	NFRB_N_A_MARK___2 = 1815,
	SIM0_CLK_B_MARK___2 = 1816,
	IP8_23_20_MARK___2 = 1817,
	SD1_DAT1_MARK___2 = 1818,
	SD2_DAT5_MARK___2 = 1819,
	MSIOF1_TXD_G_MARK___2 = 1820,
	NFDATA14_B_MARK___2 = 1821,
	TS_SPSYNC1_B_MARK___2 = 1822,
	STP_ISSYNC_1_B_MARK___2 = 1823,
	IP9_23_20_MARK___2 = 1824,
	SD2_DAT3_MARK___2 = 1825,
	NFDATA13_MARK___2 = 1826,
	IP10_23_20_MARK___2 = 1827,
	SD3_DAT4_MARK___2 = 1828,
	SD2_CD_A_MARK___2 = 1829,
	NFDATA4_MARK___2 = 1830,
	IP11_23_20_MARK___2 = 1831,
	SD1_WP_MARK___2 = 1832,
	NFCE_N_A_MARK___2 = 1833,
	SIM0_D_B_MARK___2 = 1834,
	IP8_27_24_MARK___2 = 1835,
	SD1_DAT2_MARK___2 = 1836,
	SD2_DAT6_MARK___2 = 1837,
	MSIOF1_SS1_G_MARK___2 = 1838,
	NFDATA15_B_MARK___2 = 1839,
	TS_SDAT1_B_MARK___2 = 1840,
	STP_ISD_1_B_MARK___2 = 1841,
	IP9_27_24_MARK___2 = 1842,
	SD2_DS_MARK___2 = 1843,
	NFALE_MARK___2 = 1844,
	SATA_DEVSLP_B_MARK = 1845,
	IP10_27_24_MARK___2 = 1846,
	SD3_DAT5_MARK___2 = 1847,
	SD2_WP_A_MARK___2 = 1848,
	NFDATA5_MARK___2 = 1849,
	IP11_27_24_MARK___2 = 1850,
	SCK0_MARK___2 = 1851,
	HSCK1_B_MARK___2 = 1852,
	MSIOF1_SS2_B_MARK___2 = 1853,
	AUDIO_CLKC_B_MARK___2 = 1854,
	SDA2_A_MARK___2 = 1855,
	SIM0_RST_B_MARK___2 = 1856,
	STP_OPWM_0_C_MARK___2 = 1857,
	RIF0_CLK_B_MARK___2 = 1858,
	ADICHS2_MARK___2 = 1859,
	SCK5_B_MARK___2 = 1860,
	IP8_31_28_MARK___2 = 1861,
	SD1_DAT3_MARK___2 = 1862,
	SD2_DAT7_MARK___2 = 1863,
	MSIOF1_SS2_G_MARK___2 = 1864,
	NFRB_N_B_MARK___2 = 1865,
	TS_SDEN1_B_MARK___2 = 1866,
	STP_ISEN_1_B_MARK___2 = 1867,
	IP9_31_28_MARK___2 = 1868,
	SD3_CLK_MARK___2 = 1869,
	NFWE_N_MARK___2 = 1870,
	IP10_31_28_MARK___2 = 1871,
	SD3_DAT6_MARK___2 = 1872,
	SD3_CD_MARK___2 = 1873,
	NFDATA6_MARK___2 = 1874,
	IP11_31_28_MARK___2 = 1875,
	RX0_MARK___2 = 1876,
	HRX1_B_MARK___2 = 1877,
	TS_SCK0_C_MARK___2 = 1878,
	STP_ISCLK_0_C_MARK___2 = 1879,
	RIF0_D0_B_MARK___2 = 1880,
	IP12_3_0_MARK___2 = 1881,
	TX0_MARK___2 = 1882,
	HTX1_B_MARK___2 = 1883,
	TS_SPSYNC0_C_MARK___2 = 1884,
	STP_ISSYNC_0_C_MARK___2 = 1885,
	RIF0_D1_B_MARK___2 = 1886,
	IP13_3_0_MARK___2 = 1887,
	TX2_A_MARK___2 = 1888,
	SD2_CD_B_MARK___2 = 1889,
	SCL1_A_MARK___2 = 1890,
	FMCLK_A_MARK___2 = 1891,
	RIF1_D1_C_MARK___2 = 1892,
	FSO_CFE_0_N_MARK___2 = 1893,
	IP14_3_0_MARK___2 = 1894,
	MSIOF0_SS1_MARK___2 = 1895,
	RX5_A_MARK___2 = 1896,
	NFWP_N_A_MARK___2 = 1897,
	AUDIO_CLKA_C_MARK___2 = 1898,
	SSI_SCK2_A_MARK___2 = 1899,
	STP_IVCXO27_0_C_MARK___2 = 1900,
	AUDIO_CLKOUT3_A_MARK___2 = 1901,
	TCLK1_B_MARK___2 = 1902,
	IP15_3_0_MARK___2 = 1903,
	SSI_SDATA1_A_MARK___2 = 1904,
	IP12_7_4_MARK___2 = 1905,
	CTS0_N_MARK___2 = 1906,
	HCTS1_N_B_MARK___2 = 1907,
	MSIOF1_SYNC_B_MARK___2 = 1908,
	TS_SPSYNC1_C_MARK___2 = 1909,
	STP_ISSYNC_1_C_MARK___2 = 1910,
	RIF1_SYNC_B_MARK___2 = 1911,
	AUDIO_CLKOUT_C_MARK___2 = 1912,
	ADICS_SAMP_MARK___2 = 1913,
	IP13_7_4_MARK___2 = 1914,
	RX2_A_MARK___2 = 1915,
	SD2_WP_B_MARK___2 = 1916,
	SDA1_A_MARK___2 = 1917,
	FMIN_A_MARK___2 = 1918,
	RIF1_SYNC_C_MARK___2 = 1919,
	FSO_CFE_1_N_MARK___2 = 1920,
	IP14_7_4_MARK___2 = 1921,
	MSIOF0_SS2_MARK___2 = 1922,
	TX5_A_MARK___2 = 1923,
	MSIOF1_SS2_D_MARK___2 = 1924,
	AUDIO_CLKC_A_MARK___2 = 1925,
	SSI_WS2_A_MARK___2 = 1926,
	STP_OPWM_0_D_MARK___2 = 1927,
	AUDIO_CLKOUT_D_MARK___2 = 1928,
	SPEEDIN_B_MARK___2 = 1929,
	IP15_7_4_MARK___2 = 1930,
	SSI_SDATA2_A_MARK___2 = 1931,
	SSI_SCK1_B_MARK___2 = 1932,
	IP12_11_8_MARK___2 = 1933,
	RTS0_N_MARK___2 = 1934,
	HRTS1_N_B_MARK___2 = 1935,
	MSIOF1_SS1_B_MARK___2 = 1936,
	AUDIO_CLKA_B_MARK___2 = 1937,
	SCL2_A_MARK___2 = 1938,
	STP_IVCXO27_1_C_MARK___2 = 1939,
	RIF0_SYNC_B_MARK___2 = 1940,
	ADICHS1_MARK___2 = 1941,
	IP13_11_8_MARK___2 = 1942,
	HSCK0_MARK___2 = 1943,
	MSIOF1_SCK_D_MARK___2 = 1944,
	AUDIO_CLKB_A_MARK___2 = 1945,
	SSI_SDATA1_B_MARK___2 = 1946,
	TS_SCK0_D_MARK___2 = 1947,
	STP_ISCLK_0_D_MARK___2 = 1948,
	RIF0_CLK_C_MARK___2 = 1949,
	RX5_B_MARK___2 = 1950,
	IP14_11_8_MARK___2 = 1951,
	MLB_CLK_MARK___2 = 1952,
	MSIOF1_SCK_F_MARK___2 = 1953,
	SCL1_B_MARK___2 = 1954,
	IP15_11_8_MARK___2 = 1955,
	SSI_SCK349_MARK___2 = 1956,
	MSIOF1_SS1_A_MARK___2 = 1957,
	STP_OPWM_0_A_MARK___2 = 1958,
	IP12_15_12_MARK___2 = 1959,
	RX1_A_MARK___2 = 1960,
	HRX1_A_MARK___2 = 1961,
	TS_SDAT0_C_MARK___2 = 1962,
	STP_ISD_0_C_MARK___2 = 1963,
	RIF1_CLK_C_MARK___2 = 1964,
	IP13_15_12_MARK___2 = 1965,
	HRX0_MARK___2 = 1966,
	MSIOF1_RXD_D_MARK___2 = 1967,
	SSI_SDATA2_B_MARK___2 = 1968,
	TS_SDEN0_D_MARK___2 = 1969,
	STP_ISEN_0_D_MARK___2 = 1970,
	RIF0_D0_C_MARK___2 = 1971,
	IP14_15_12_MARK___2 = 1972,
	MLB_SIG_MARK___2 = 1973,
	RX1_B_MARK___2 = 1974,
	MSIOF1_SYNC_F_MARK___2 = 1975,
	SDA1_B_MARK___2 = 1976,
	IP15_15_12_MARK___2 = 1977,
	SSI_WS349_MARK___2 = 1978,
	HCTS2_N_A_MARK___2 = 1979,
	MSIOF1_SS2_A_MARK___2 = 1980,
	STP_IVCXO27_0_A_MARK___2 = 1981,
	IP12_19_16_MARK___2 = 1982,
	TX1_A_MARK___2 = 1983,
	HTX1_A_MARK___2 = 1984,
	TS_SDEN0_C_MARK___2 = 1985,
	STP_ISEN_0_C_MARK___2 = 1986,
	RIF1_D0_C_MARK___2 = 1987,
	IP13_19_16_MARK___2 = 1988,
	HTX0_MARK___2 = 1989,
	MSIOF1_TXD_D_MARK___2 = 1990,
	SSI_SDATA9_B_MARK___2 = 1991,
	TS_SDAT0_D_MARK___2 = 1992,
	STP_ISD_0_D_MARK___2 = 1993,
	RIF0_D1_C_MARK___2 = 1994,
	IP14_19_16_MARK___2 = 1995,
	MLB_DAT_MARK___2 = 1996,
	TX1_B_MARK___2 = 1997,
	MSIOF1_RXD_F_MARK___2 = 1998,
	IP15_19_16_MARK___2 = 1999,
	SSI_SDATA3_MARK___2 = 2000,
	HRTS2_N_A_MARK___2 = 2001,
	MSIOF1_TXD_A_MARK___2 = 2002,
	TS_SCK0_A_MARK___2 = 2003,
	STP_ISCLK_0_A_MARK___2 = 2004,
	RIF0_D1_A_MARK___2 = 2005,
	RIF2_D0_A_MARK___2 = 2006,
	IP12_23_20_MARK___2 = 2007,
	CTS1_N_MARK___2 = 2008,
	HCTS1_N_A_MARK___2 = 2009,
	MSIOF1_RXD_B_MARK___2 = 2010,
	TS_SDEN1_C_MARK___2 = 2011,
	STP_ISEN_1_C_MARK___2 = 2012,
	RIF1_D0_B_MARK___2 = 2013,
	ADIDATA_MARK___2 = 2014,
	IP13_23_20_MARK___2 = 2015,
	HCTS0_N_MARK___2 = 2016,
	RX2_B_MARK___2 = 2017,
	MSIOF1_SYNC_D_MARK___2 = 2018,
	SSI_SCK9_A_MARK___2 = 2019,
	TS_SPSYNC0_D_MARK___2 = 2020,
	STP_ISSYNC_0_D_MARK___2 = 2021,
	RIF0_SYNC_C_MARK___2 = 2022,
	AUDIO_CLKOUT1_A_MARK___2 = 2023,
	IP14_23_20_MARK___2 = 2024,
	SSI_SCK01239_MARK___2 = 2025,
	MSIOF1_TXD_F_MARK___2 = 2026,
	IP15_23_20_MARK___2 = 2027,
	SSI_SCK4_MARK___2 = 2028,
	HRX2_A_MARK___2 = 2029,
	MSIOF1_SCK_A_MARK___2 = 2030,
	TS_SDAT0_A_MARK___2 = 2031,
	STP_ISD_0_A_MARK___2 = 2032,
	RIF0_CLK_A_MARK___2 = 2033,
	RIF2_CLK_A_MARK___2 = 2034,
	IP12_27_24_MARK___2 = 2035,
	RTS1_N_MARK___2 = 2036,
	HRTS1_N_A_MARK___2 = 2037,
	MSIOF1_TXD_B_MARK___2 = 2038,
	TS_SDAT1_C_MARK___2 = 2039,
	STP_ISD_1_C_MARK___2 = 2040,
	RIF1_D1_B_MARK___2 = 2041,
	ADICHS0_MARK___2 = 2042,
	IP13_27_24_MARK___2 = 2043,
	HRTS0_N_MARK___2 = 2044,
	TX2_B_MARK___2 = 2045,
	MSIOF1_SS1_D_MARK___2 = 2046,
	SSI_WS9_A_MARK___2 = 2047,
	STP_IVCXO27_0_D_MARK___2 = 2048,
	BPFCLK_A_MARK___2 = 2049,
	AUDIO_CLKOUT2_A_MARK___2 = 2050,
	IP14_27_24_MARK___2 = 2051,
	SSI_WS01239_MARK___2 = 2052,
	MSIOF1_SS1_F_MARK___2 = 2053,
	IP15_27_24_MARK___2 = 2054,
	SSI_WS4_MARK___2 = 2055,
	HTX2_A_MARK___2 = 2056,
	MSIOF1_SYNC_A_MARK___2 = 2057,
	TS_SDEN0_A_MARK___2 = 2058,
	STP_ISEN_0_A_MARK___2 = 2059,
	RIF0_SYNC_A_MARK___2 = 2060,
	RIF2_SYNC_A_MARK___2 = 2061,
	IP12_31_28_MARK___2 = 2062,
	SCK2_MARK___2 = 2063,
	SCIF_CLK_B_MARK___2 = 2064,
	MSIOF1_SCK_B_MARK___2 = 2065,
	TS_SCK1_C_MARK___2 = 2066,
	STP_ISCLK_1_C_MARK___2 = 2067,
	RIF1_CLK_B_MARK___2 = 2068,
	ADICLK_MARK___2 = 2069,
	IP13_31_28_MARK___2 = 2070,
	MSIOF0_SYNC_MARK___2 = 2071,
	AUDIO_CLKOUT_A_MARK___2 = 2072,
	TX5_B_MARK___2 = 2073,
	BPFCLK_D_MARK___2 = 2074,
	IP14_31_28_MARK___2 = 2075,
	SSI_SDATA0_MARK___2 = 2076,
	MSIOF1_SS2_F_MARK___2 = 2077,
	IP15_31_28_MARK___2 = 2078,
	SSI_SDATA4_MARK___2 = 2079,
	HSCK2_A_MARK___2 = 2080,
	MSIOF1_RXD_A_MARK___2 = 2081,
	TS_SPSYNC0_A_MARK___2 = 2082,
	STP_ISSYNC_0_A_MARK___2 = 2083,
	RIF0_D0_A_MARK___2 = 2084,
	RIF2_D1_A_MARK___2 = 2085,
	IP16_3_0_MARK___2 = 2086,
	SSI_SCK6_MARK___2 = 2087,
	SIM0_RST_D_MARK___2 = 2088,
	IP17_3_0_MARK___2 = 2089,
	AUDIO_CLKA_A_MARK___2 = 2090,
	IP18_3_0_MARK___2 = 2091,
	GP6_30_MARK___2 = 2092,
	AUDIO_CLKOUT2_B_MARK___2 = 2093,
	SSI_SCK9_B_MARK___2 = 2094,
	TS_SDEN0_E_MARK___2 = 2095,
	STP_ISEN_0_E_MARK___2 = 2096,
	RIF2_D0_B_MARK___2 = 2097,
	TPU0TO2_MARK___2 = 2098,
	FMCLK_C_MARK___2 = 2099,
	FMCLK_D_MARK___2 = 2100,
	IP16_7_4_MARK___2 = 2101,
	SSI_WS6_MARK___2 = 2102,
	SIM0_D_D_MARK___2 = 2103,
	IP17_7_4_MARK___2 = 2104,
	AUDIO_CLKB_B_MARK___2 = 2105,
	SCIF_CLK_A_MARK___2 = 2106,
	STP_IVCXO27_1_D_MARK___2 = 2107,
	REMOCON_A_MARK___2 = 2108,
	TCLK1_A_MARK___2 = 2109,
	IP18_7_4_MARK___2 = 2110,
	GP6_31_MARK___2 = 2111,
	AUDIO_CLKOUT3_B_MARK___2 = 2112,
	SSI_WS9_B_MARK___2 = 2113,
	TS_SPSYNC0_E_MARK___2 = 2114,
	STP_ISSYNC_0_E_MARK___2 = 2115,
	RIF2_D1_B_MARK___2 = 2116,
	TPU0TO3_MARK___2 = 2117,
	FMIN_C_MARK___2 = 2118,
	FMIN_D_MARK___2 = 2119,
	IP16_11_8_MARK___2 = 2120,
	SSI_SDATA6_MARK___2 = 2121,
	SIM0_CLK_D_MARK___2 = 2122,
	SATA_DEVSLP_A_MARK = 2123,
	IP17_11_8_MARK___2 = 2124,
	USB0_PWEN_MARK___2 = 2125,
	SIM0_RST_C_MARK___2 = 2126,
	TS_SCK1_D_MARK___2 = 2127,
	STP_ISCLK_1_D_MARK___2 = 2128,
	BPFCLK_B_MARK___2 = 2129,
	RIF3_CLK_B_MARK___2 = 2130,
	HSCK2_C_MARK___2 = 2131,
	IP16_15_12_MARK___2 = 2132,
	SSI_SCK78_MARK___2 = 2133,
	HRX2_B_MARK___2 = 2134,
	MSIOF1_SCK_C_MARK___2 = 2135,
	TS_SCK1_A_MARK___2 = 2136,
	STP_ISCLK_1_A_MARK___2 = 2137,
	RIF1_CLK_A_MARK___2 = 2138,
	RIF3_CLK_A_MARK___2 = 2139,
	IP17_15_12_MARK___2 = 2140,
	USB0_OVC_MARK___2 = 2141,
	SIM0_D_C_MARK___2 = 2142,
	TS_SDAT1_D_MARK___2 = 2143,
	STP_ISD_1_D_MARK___2 = 2144,
	RIF3_SYNC_B_MARK___2 = 2145,
	HRX2_C_MARK___2 = 2146,
	IP16_19_16_MARK___2 = 2147,
	SSI_WS78_MARK___2 = 2148,
	HTX2_B_MARK___2 = 2149,
	MSIOF1_SYNC_C_MARK___2 = 2150,
	TS_SDAT1_A_MARK___2 = 2151,
	STP_ISD_1_A_MARK___2 = 2152,
	RIF1_SYNC_A_MARK___2 = 2153,
	RIF3_SYNC_A_MARK___2 = 2154,
	IP17_19_16_MARK___2 = 2155,
	USB1_PWEN_MARK___2 = 2156,
	SIM0_CLK_C_MARK___2 = 2157,
	SSI_SCK1_A_MARK___2 = 2158,
	TS_SCK0_E_MARK___2 = 2159,
	STP_ISCLK_0_E_MARK___2 = 2160,
	FMCLK_B_MARK___2 = 2161,
	RIF2_CLK_B_MARK___2 = 2162,
	SPEEDIN_A_MARK___2 = 2163,
	HTX2_C_MARK___2 = 2164,
	IP16_23_20_MARK___2 = 2165,
	SSI_SDATA7_MARK___2 = 2166,
	HCTS2_N_B_MARK___2 = 2167,
	MSIOF1_RXD_C_MARK___2 = 2168,
	TS_SDEN1_A_MARK___2 = 2169,
	STP_ISEN_1_A_MARK___2 = 2170,
	RIF1_D0_A_MARK___2 = 2171,
	RIF3_D0_A_MARK___2 = 2172,
	TCLK2_A_MARK___2 = 2173,
	IP17_23_20_MARK___2 = 2174,
	USB1_OVC_MARK___2 = 2175,
	MSIOF1_SS2_C_MARK___2 = 2176,
	SSI_WS1_A_MARK___2 = 2177,
	TS_SDAT0_E_MARK___2 = 2178,
	STP_ISD_0_E_MARK___2 = 2179,
	FMIN_B_MARK___2 = 2180,
	RIF2_SYNC_B_MARK___2 = 2181,
	REMOCON_B_MARK___2 = 2182,
	HCTS2_N_C_MARK___2 = 2183,
	IP16_27_24_MARK___2 = 2184,
	SSI_SDATA8_MARK___2 = 2185,
	HRTS2_N_B_MARK___2 = 2186,
	MSIOF1_TXD_C_MARK___2 = 2187,
	TS_SPSYNC1_A_MARK___2 = 2188,
	STP_ISSYNC_1_A_MARK___2 = 2189,
	RIF1_D1_A_MARK___2 = 2190,
	RIF3_D1_A_MARK___2 = 2191,
	IP17_27_24_MARK___2 = 2192,
	USB30_PWEN_MARK___2 = 2193,
	AUDIO_CLKOUT_B_MARK___2 = 2194,
	SSI_SCK2_B_MARK___2 = 2195,
	TS_SDEN1_D_MARK___2 = 2196,
	STP_ISEN_1_D_MARK___2 = 2197,
	STP_OPWM_0_E_MARK___2 = 2198,
	RIF3_D0_B_MARK___2 = 2199,
	TCLK2_B_MARK___2 = 2200,
	TPU0TO0_MARK___2 = 2201,
	BPFCLK_C_MARK___2 = 2202,
	HRTS2_N_C_MARK___2 = 2203,
	IP16_31_28_MARK___2 = 2204,
	SSI_SDATA9_A_MARK___2 = 2205,
	HSCK2_B_MARK___2 = 2206,
	MSIOF1_SS1_C_MARK___2 = 2207,
	HSCK1_A_MARK___2 = 2208,
	SSI_WS1_B_MARK___2 = 2209,
	SCK1_MARK___2 = 2210,
	STP_IVCXO27_1_A_MARK___2 = 2211,
	SCK5_A_MARK___2 = 2212,
	IP17_31_28_MARK___2 = 2213,
	USB30_OVC_MARK___2 = 2214,
	AUDIO_CLKOUT1_B_MARK___2 = 2215,
	SSI_WS2_B_MARK___2 = 2216,
	TS_SPSYNC1_D_MARK___2 = 2217,
	STP_ISSYNC_1_D_MARK___2 = 2218,
	STP_IVCXO27_0_E_MARK___2 = 2219,
	RIF3_D1_B_MARK___2 = 2220,
	FSO_TOE_N_MARK___2 = 2221,
	TPU0TO1_MARK___2 = 2222,
	SEL_MSIOF3_0_MARK___2 = 2223,
	SEL_MSIOF3_1_MARK___2 = 2224,
	SEL_MSIOF3_2_MARK___2 = 2225,
	SEL_MSIOF3_3_MARK___2 = 2226,
	SEL_MSIOF3_4_MARK___2 = 2227,
	SEL_TSIF1_0_MARK___2 = 2228,
	SEL_TSIF1_1_MARK___2 = 2229,
	SEL_TSIF1_2_MARK___2 = 2230,
	SEL_TSIF1_3_MARK___2 = 2231,
	I2C_SEL_5_0_MARK___2 = 2232,
	I2C_SEL_5_1_MARK___2 = 2233,
	I2C_SEL_3_0_MARK___2 = 2234,
	I2C_SEL_3_1_MARK___2 = 2235,
	SEL_TSIF0_0_MARK___2 = 2236,
	SEL_TSIF0_1_MARK___2 = 2237,
	SEL_TSIF0_2_MARK___2 = 2238,
	SEL_TSIF0_3_MARK___2 = 2239,
	SEL_TSIF0_4_MARK___2 = 2240,
	I2C_SEL_0_0_MARK___2 = 2241,
	I2C_SEL_0_1_MARK___2 = 2242,
	SEL_MSIOF2_0_MARK___2 = 2243,
	SEL_MSIOF2_1_MARK___2 = 2244,
	SEL_MSIOF2_2_MARK___2 = 2245,
	SEL_MSIOF2_3_MARK___2 = 2246,
	SEL_FM_0_MARK___2 = 2247,
	SEL_FM_1_MARK___2 = 2248,
	SEL_FM_2_MARK___2 = 2249,
	SEL_FM_3_MARK___2 = 2250,
	SEL_MSIOF1_0_MARK___2 = 2251,
	SEL_MSIOF1_1_MARK___2 = 2252,
	SEL_MSIOF1_2_MARK___2 = 2253,
	SEL_MSIOF1_3_MARK___2 = 2254,
	SEL_MSIOF1_4_MARK___2 = 2255,
	SEL_MSIOF1_5_MARK___2 = 2256,
	SEL_MSIOF1_6_MARK___2 = 2257,
	SEL_TIMER_TMU_0_MARK___2 = 2258,
	SEL_TIMER_TMU_1_MARK___2 = 2259,
	SEL_SCIF5_0_MARK___2 = 2260,
	SEL_SCIF5_1_MARK___2 = 2261,
	SEL_SSP1_1_0_MARK___2 = 2262,
	SEL_SSP1_1_1_MARK___2 = 2263,
	SEL_SSP1_1_2_MARK___2 = 2264,
	SEL_SSP1_1_3_MARK___2 = 2265,
	SEL_I2C6_0_MARK___2 = 2266,
	SEL_I2C6_1_MARK___2 = 2267,
	SEL_I2C6_2_MARK___2 = 2268,
	SEL_LBSC_0_MARK___2 = 2269,
	SEL_LBSC_1_MARK___2 = 2270,
	SEL_SSP1_0_0_MARK___2 = 2271,
	SEL_SSP1_0_1_MARK___2 = 2272,
	SEL_SSP1_0_2_MARK___2 = 2273,
	SEL_SSP1_0_3_MARK___2 = 2274,
	SEL_SSP1_0_4_MARK___2 = 2275,
	SEL_IEBUS_0_MARK___2 = 2276,
	SEL_IEBUS_1_MARK___2 = 2277,
	SEL_NDF_0_MARK___2 = 2278,
	SEL_NDF_1_MARK___2 = 2279,
	SEL_I2C2_0_MARK___2 = 2280,
	SEL_I2C2_1_MARK___2 = 2281,
	SEL_SSI2_0_MARK___2 = 2282,
	SEL_SSI2_1_MARK___2 = 2283,
	SEL_I2C1_0_MARK___2 = 2284,
	SEL_I2C1_1_MARK___2 = 2285,
	SEL_SSI1_0_MARK___2 = 2286,
	SEL_SSI1_1_MARK___2 = 2287,
	SEL_SSI9_0_MARK___2 = 2288,
	SEL_SSI9_1_MARK___2 = 2289,
	SEL_HSCIF4_0_MARK___2 = 2290,
	SEL_HSCIF4_1_MARK___2 = 2291,
	SEL_SPEED_PULSE_0_MARK___2 = 2292,
	SEL_SPEED_PULSE_1_MARK___2 = 2293,
	SEL_TIMER_TMU2_0_MARK___2 = 2294,
	SEL_TIMER_TMU2_1_MARK___2 = 2295,
	SEL_HSCIF3_0_MARK___2 = 2296,
	SEL_HSCIF3_1_MARK___2 = 2297,
	SEL_HSCIF3_2_MARK___2 = 2298,
	SEL_HSCIF3_3_MARK___2 = 2299,
	SEL_SIMCARD_0_MARK___2 = 2300,
	SEL_SIMCARD_1_MARK___2 = 2301,
	SEL_SIMCARD_2_MARK___2 = 2302,
	SEL_SIMCARD_3_MARK___2 = 2303,
	SEL_ADGB_0_MARK___2 = 2304,
	SEL_ADGB_1_MARK___2 = 2305,
	SEL_ADGC_0_MARK___2 = 2306,
	SEL_ADGC_1_MARK___2 = 2307,
	SEL_HSCIF1_0_MARK___2 = 2308,
	SEL_HSCIF1_1_MARK___2 = 2309,
	SEL_SDHI2_0_MARK___2 = 2310,
	SEL_SDHI2_1_MARK___2 = 2311,
	SEL_SCIF4_0_MARK___2 = 2312,
	SEL_SCIF4_1_MARK___2 = 2313,
	SEL_SCIF4_2_MARK___2 = 2314,
	SEL_HSCIF2_0_MARK___2 = 2315,
	SEL_HSCIF2_1_MARK___2 = 2316,
	SEL_HSCIF2_2_MARK___2 = 2317,
	SEL_SCIF3_0_MARK___2 = 2318,
	SEL_SCIF3_1_MARK___2 = 2319,
	SEL_ETHERAVB_0_MARK___2 = 2320,
	SEL_ETHERAVB_1_MARK___2 = 2321,
	SEL_SCIF2_0_MARK___2 = 2322,
	SEL_SCIF2_1_MARK___2 = 2323,
	SEL_DRIF3_0_MARK___2 = 2324,
	SEL_DRIF3_1_MARK___2 = 2325,
	SEL_SCIF1_0_MARK___2 = 2326,
	SEL_SCIF1_1_MARK___2 = 2327,
	SEL_DRIF2_0_MARK___2 = 2328,
	SEL_DRIF2_1_MARK___2 = 2329,
	SEL_SCIF_0_MARK___2 = 2330,
	SEL_SCIF_1_MARK___2 = 2331,
	SEL_DRIF1_0_MARK___2 = 2332,
	SEL_DRIF1_1_MARK___2 = 2333,
	SEL_DRIF1_2_MARK___2 = 2334,
	SEL_REMOCON_0_MARK___2 = 2335,
	SEL_REMOCON_1_MARK___2 = 2336,
	SEL_DRIF0_0_MARK___2 = 2337,
	SEL_DRIF0_1_MARK___2 = 2338,
	SEL_DRIF0_2_MARK___2 = 2339,
	SEL_RCAN0_0_MARK___2 = 2340,
	SEL_RCAN0_1_MARK___2 = 2341,
	SEL_CANFD0_0_MARK___2 = 2342,
	SEL_CANFD0_1_MARK___2 = 2343,
	SEL_PWM6_0_MARK___2 = 2344,
	SEL_PWM6_1_MARK___2 = 2345,
	SEL_ADGA_0_MARK___2 = 2346,
	SEL_ADGA_1_MARK___2 = 2347,
	SEL_ADGA_2_MARK___2 = 2348,
	SEL_ADGA_3_MARK___2 = 2349,
	SEL_PWM5_0_MARK___2 = 2350,
	SEL_PWM5_1_MARK___2 = 2351,
	SEL_PWM4_0_MARK___2 = 2352,
	SEL_PWM4_1_MARK___2 = 2353,
	SEL_PWM3_0_MARK___2 = 2354,
	SEL_PWM3_1_MARK___2 = 2355,
	SEL_PWM2_0_MARK___2 = 2356,
	SEL_PWM2_1_MARK___2 = 2357,
	SEL_PWM1_0_MARK___2 = 2358,
	SEL_PWM1_1_MARK___2 = 2359,
	SEL_VIN4_0_MARK___2 = 2360,
	SEL_VIN4_1_MARK___2 = 2361,
	QSPI0_SPCLK_MARK___2 = 2362,
	QSPI0_SSL_MARK___2 = 2363,
	QSPI0_MOSI_IO0_MARK___2 = 2364,
	QSPI0_MISO_IO1_MARK___2 = 2365,
	QSPI0_IO2_MARK___2 = 2366,
	QSPI0_IO3_MARK___2 = 2367,
	QSPI1_SPCLK_MARK___2 = 2368,
	QSPI1_SSL_MARK___2 = 2369,
	QSPI1_MOSI_IO0_MARK___2 = 2370,
	QSPI1_MISO_IO1_MARK___2 = 2371,
	QSPI1_IO2_MARK___2 = 2372,
	QSPI1_IO3_MARK___2 = 2373,
	RPC_INT_MARK___2 = 2374,
	RPC_WP_MARK___2 = 2375,
	RPC_RESET_MARK___2 = 2376,
	AVB_TX_CTL_MARK___2 = 2377,
	AVB_TXC_MARK___2 = 2378,
	AVB_TD0_MARK___2 = 2379,
	AVB_TD1_MARK___2 = 2380,
	AVB_TD2_MARK___2 = 2381,
	AVB_TD3_MARK___2 = 2382,
	AVB_RX_CTL_MARK___2 = 2383,
	AVB_RXC_MARK___2 = 2384,
	AVB_RD0_MARK___2 = 2385,
	AVB_RD1_MARK___2 = 2386,
	AVB_RD2_MARK___2 = 2387,
	AVB_RD3_MARK___2 = 2388,
	AVB_TXCREFCLK_MARK___2 = 2389,
	AVB_MDIO_MARK___2 = 2390,
	PRESETOUT_MARK___2 = 2391,
	DU_DOTCLKIN0_MARK___2 = 2392,
	DU_DOTCLKIN1_MARK___2 = 2393,
	DU_DOTCLKIN3_MARK = 2394,
	TMS_MARK___2 = 2395,
	TDO_MARK___2 = 2396,
	ASEBRK_MARK___2 = 2397,
	MLB_REF_MARK___2 = 2398,
	TDI_MARK___2 = 2399,
	TCK_MARK___2 = 2400,
	TRST_MARK___2 = 2401,
	EXTALR_MARK___2 = 2402,
	SCL0_MARK___2 = 2403,
	SDA0_MARK___2 = 2404,
	SCL3_MARK___2 = 2405,
	SDA3_MARK___2 = 2406,
	SCL5_MARK___2 = 2407,
	SDA5_MARK___2 = 2408,
	PINMUX_MARK_END___2 = 2409,
};

enum {
	GP_LAST___2 = 227,
	PIN_ASEBRK___2 = 228,
	PIN_AVB_MDIO___2 = 229,
	PIN_AVB_RD0___2 = 230,
	PIN_AVB_RD1___2 = 231,
	PIN_AVB_RD2___2 = 232,
	PIN_AVB_RD3___2 = 233,
	PIN_AVB_RXC___2 = 234,
	PIN_AVB_RX_CTL___2 = 235,
	PIN_AVB_TD0___2 = 236,
	PIN_AVB_TD1___2 = 237,
	PIN_AVB_TD2___2 = 238,
	PIN_AVB_TD3___2 = 239,
	PIN_AVB_TXC___2 = 240,
	PIN_AVB_TXCREFCLK___2 = 241,
	PIN_AVB_TX_CTL___2 = 242,
	PIN_DU_DOTCLKIN0___2 = 243,
	PIN_DU_DOTCLKIN1___2 = 244,
	PIN_DU_DOTCLKIN3 = 245,
	PIN_EXTALR___2 = 246,
	PIN_FSCLKST___2 = 247,
	PIN_MLB_REF___2 = 248,
	PIN_PRESETOUT_N___2 = 249,
	PIN_QSPI0_IO2___2 = 250,
	PIN_QSPI0_IO3___2 = 251,
	PIN_QSPI0_MISO_IO1___2 = 252,
	PIN_QSPI0_MOSI_IO0___2 = 253,
	PIN_QSPI0_SPCLK___2 = 254,
	PIN_QSPI0_SSL___2 = 255,
	PIN_QSPI1_IO2___2 = 256,
	PIN_QSPI1_IO3___2 = 257,
	PIN_QSPI1_MISO_IO1___2 = 258,
	PIN_QSPI1_MOSI_IO0___2 = 259,
	PIN_QSPI1_SPCLK___2 = 260,
	PIN_QSPI1_SSL___2 = 261,
	PIN_RPC_INT_N___2 = 262,
	PIN_RPC_RESET_N___2 = 263,
	PIN_RPC_WP_N___2 = 264,
	PIN_TCK___2 = 265,
	PIN_TDI___2 = 266,
	PIN_TDO___2 = 267,
	PIN_TMS___2 = 268,
	PIN_TRST_N___2 = 269,
};

enum {
	PINMUX_RESERVED___3 = 0,
	PINMUX_DATA_BEGIN___3 = 1,
	GP_0_0_DATA___3 = 2,
	GP_0_1_DATA___3 = 3,
	GP_0_2_DATA___3 = 4,
	GP_0_3_DATA___3 = 5,
	GP_0_4_DATA___3 = 6,
	GP_0_5_DATA___3 = 7,
	GP_0_6_DATA___3 = 8,
	GP_0_7_DATA___3 = 9,
	GP_0_8_DATA___3 = 10,
	GP_0_9_DATA___3 = 11,
	GP_0_10_DATA___3 = 12,
	GP_0_11_DATA___3 = 13,
	GP_0_12_DATA___3 = 14,
	GP_0_13_DATA___3 = 15,
	GP_0_14_DATA___3 = 16,
	GP_0_15_DATA___3 = 17,
	GP_0_16_DATA = 18,
	GP_0_17_DATA = 19,
	GP_1_0_DATA___3 = 20,
	GP_1_1_DATA___3 = 21,
	GP_1_2_DATA___3 = 22,
	GP_1_3_DATA___3 = 23,
	GP_1_4_DATA___3 = 24,
	GP_1_5_DATA___3 = 25,
	GP_1_6_DATA___3 = 26,
	GP_1_7_DATA___3 = 27,
	GP_1_8_DATA___3 = 28,
	GP_1_9_DATA___3 = 29,
	GP_1_10_DATA___3 = 30,
	GP_1_11_DATA___3 = 31,
	GP_1_12_DATA___3 = 32,
	GP_1_13_DATA___3 = 33,
	GP_1_14_DATA___3 = 34,
	GP_1_15_DATA___3 = 35,
	GP_1_16_DATA___3 = 36,
	GP_1_17_DATA___3 = 37,
	GP_1_18_DATA___3 = 38,
	GP_1_19_DATA___3 = 39,
	GP_1_20_DATA___3 = 40,
	GP_1_21_DATA___3 = 41,
	GP_1_22_DATA___3 = 42,
	GP_2_0_DATA___3 = 43,
	GP_2_1_DATA___3 = 44,
	GP_2_2_DATA___3 = 45,
	GP_2_3_DATA___3 = 46,
	GP_2_4_DATA___3 = 47,
	GP_2_5_DATA___3 = 48,
	GP_2_6_DATA___3 = 49,
	GP_2_7_DATA___3 = 50,
	GP_2_8_DATA___3 = 51,
	GP_2_9_DATA___3 = 52,
	GP_2_10_DATA___3 = 53,
	GP_2_11_DATA___3 = 54,
	GP_2_12_DATA___3 = 55,
	GP_2_13_DATA___3 = 56,
	GP_2_14_DATA___3 = 57,
	GP_2_15_DATA = 58,
	GP_2_16_DATA = 59,
	GP_2_17_DATA = 60,
	GP_2_18_DATA = 61,
	GP_2_19_DATA = 62,
	GP_2_20_DATA = 63,
	GP_2_21_DATA = 64,
	GP_2_22_DATA = 65,
	GP_2_23_DATA = 66,
	GP_2_24_DATA = 67,
	GP_2_25_DATA = 68,
	GP_3_0_DATA___3 = 69,
	GP_3_1_DATA___3 = 70,
	GP_3_2_DATA___3 = 71,
	GP_3_3_DATA___3 = 72,
	GP_3_4_DATA___3 = 73,
	GP_3_5_DATA___3 = 74,
	GP_3_6_DATA___3 = 75,
	GP_3_7_DATA___3 = 76,
	GP_3_8_DATA___3 = 77,
	GP_3_9_DATA___3 = 78,
	GP_3_10_DATA___3 = 79,
	GP_3_11_DATA___3 = 80,
	GP_3_12_DATA___3 = 81,
	GP_3_13_DATA___3 = 82,
	GP_3_14_DATA___3 = 83,
	GP_3_15_DATA___3 = 84,
	GP_4_0_DATA___3 = 85,
	GP_4_1_DATA___3 = 86,
	GP_4_2_DATA___3 = 87,
	GP_4_3_DATA___3 = 88,
	GP_4_4_DATA___3 = 89,
	GP_4_5_DATA___3 = 90,
	GP_4_6_DATA___3 = 91,
	GP_4_7_DATA___3 = 92,
	GP_4_8_DATA___3 = 93,
	GP_4_9_DATA___3 = 94,
	GP_4_10_DATA___3 = 95,
	GP_5_0_DATA___3 = 96,
	GP_5_1_DATA___3 = 97,
	GP_5_2_DATA___3 = 98,
	GP_5_3_DATA___3 = 99,
	GP_5_4_DATA___3 = 100,
	GP_5_5_DATA___3 = 101,
	GP_5_6_DATA___3 = 102,
	GP_5_7_DATA___3 = 103,
	GP_5_8_DATA___3 = 104,
	GP_5_9_DATA___3 = 105,
	GP_5_10_DATA___3 = 106,
	GP_5_11_DATA___3 = 107,
	GP_5_12_DATA___3 = 108,
	GP_5_13_DATA___3 = 109,
	GP_5_14_DATA___3 = 110,
	GP_5_15_DATA___3 = 111,
	GP_5_16_DATA___3 = 112,
	GP_5_17_DATA___3 = 113,
	GP_5_18_DATA___3 = 114,
	GP_5_19_DATA___3 = 115,
	GP_6_0_DATA___3 = 116,
	GP_6_1_DATA___3 = 117,
	GP_6_2_DATA___3 = 118,
	GP_6_3_DATA___3 = 119,
	GP_6_4_DATA___3 = 120,
	GP_6_5_DATA___3 = 121,
	GP_6_6_DATA___3 = 122,
	GP_6_7_DATA___3 = 123,
	GP_6_8_DATA___3 = 124,
	GP_6_9_DATA___3 = 125,
	GP_6_10_DATA___3 = 126,
	GP_6_11_DATA___3 = 127,
	GP_6_12_DATA___3 = 128,
	GP_6_13_DATA___3 = 129,
	GP_6_14_DATA___3 = 130,
	GP_6_15_DATA___3 = 131,
	GP_6_16_DATA___3 = 132,
	GP_6_17_DATA___3 = 133,
	PINMUX_DATA_END___3 = 134,
	PINMUX_FUNCTION_BEGIN___3 = 135,
	GP_0_0_FN___3 = 136,
	GP_0_1_FN___3 = 137,
	GP_0_2_FN___3 = 138,
	GP_0_3_FN___3 = 139,
	GP_0_4_FN___3 = 140,
	GP_0_5_FN___3 = 141,
	GP_0_6_FN___3 = 142,
	GP_0_7_FN___3 = 143,
	GP_0_8_FN___3 = 144,
	GP_0_9_FN___3 = 145,
	GP_0_10_FN___3 = 146,
	GP_0_11_FN___3 = 147,
	GP_0_12_FN___3 = 148,
	GP_0_13_FN___3 = 149,
	GP_0_14_FN___3 = 150,
	GP_0_15_FN___3 = 151,
	GP_0_16_FN = 152,
	GP_0_17_FN = 153,
	GP_1_0_FN___3 = 154,
	GP_1_1_FN___3 = 155,
	GP_1_2_FN___3 = 156,
	GP_1_3_FN___3 = 157,
	GP_1_4_FN___3 = 158,
	GP_1_5_FN___3 = 159,
	GP_1_6_FN___3 = 160,
	GP_1_7_FN___3 = 161,
	GP_1_8_FN___3 = 162,
	GP_1_9_FN___3 = 163,
	GP_1_10_FN___3 = 164,
	GP_1_11_FN___3 = 165,
	GP_1_12_FN___3 = 166,
	GP_1_13_FN___3 = 167,
	GP_1_14_FN___3 = 168,
	GP_1_15_FN___3 = 169,
	GP_1_16_FN___3 = 170,
	GP_1_17_FN___3 = 171,
	GP_1_18_FN___3 = 172,
	GP_1_19_FN___3 = 173,
	GP_1_20_FN___3 = 174,
	GP_1_21_FN___3 = 175,
	GP_1_22_FN___3 = 176,
	GP_2_0_FN___3 = 177,
	GP_2_1_FN___3 = 178,
	GP_2_2_FN___3 = 179,
	GP_2_3_FN___3 = 180,
	GP_2_4_FN___3 = 181,
	GP_2_5_FN___3 = 182,
	GP_2_6_FN___3 = 183,
	GP_2_7_FN___3 = 184,
	GP_2_8_FN___3 = 185,
	GP_2_9_FN___3 = 186,
	GP_2_10_FN___3 = 187,
	GP_2_11_FN___3 = 188,
	GP_2_12_FN___3 = 189,
	GP_2_13_FN___3 = 190,
	GP_2_14_FN___3 = 191,
	GP_2_15_FN = 192,
	GP_2_16_FN = 193,
	GP_2_17_FN = 194,
	GP_2_18_FN = 195,
	GP_2_19_FN = 196,
	GP_2_20_FN = 197,
	GP_2_21_FN = 198,
	GP_2_22_FN = 199,
	GP_2_23_FN = 200,
	GP_2_24_FN = 201,
	GP_2_25_FN = 202,
	GP_3_0_FN___3 = 203,
	GP_3_1_FN___3 = 204,
	GP_3_2_FN___3 = 205,
	GP_3_3_FN___3 = 206,
	GP_3_4_FN___3 = 207,
	GP_3_5_FN___3 = 208,
	GP_3_6_FN___3 = 209,
	GP_3_7_FN___3 = 210,
	GP_3_8_FN___3 = 211,
	GP_3_9_FN___3 = 212,
	GP_3_10_FN___3 = 213,
	GP_3_11_FN___3 = 214,
	GP_3_12_FN___3 = 215,
	GP_3_13_FN___3 = 216,
	GP_3_14_FN___3 = 217,
	GP_3_15_FN___3 = 218,
	GP_4_0_FN___3 = 219,
	GP_4_1_FN___3 = 220,
	GP_4_2_FN___3 = 221,
	GP_4_3_FN___3 = 222,
	GP_4_4_FN___3 = 223,
	GP_4_5_FN___3 = 224,
	GP_4_6_FN___3 = 225,
	GP_4_7_FN___3 = 226,
	GP_4_8_FN___3 = 227,
	GP_4_9_FN___3 = 228,
	GP_4_10_FN___3 = 229,
	GP_5_0_FN___3 = 230,
	GP_5_1_FN___3 = 231,
	GP_5_2_FN___3 = 232,
	GP_5_3_FN___3 = 233,
	GP_5_4_FN___3 = 234,
	GP_5_5_FN___3 = 235,
	GP_5_6_FN___3 = 236,
	GP_5_7_FN___3 = 237,
	GP_5_8_FN___3 = 238,
	GP_5_9_FN___3 = 239,
	GP_5_10_FN___3 = 240,
	GP_5_11_FN___3 = 241,
	GP_5_12_FN___3 = 242,
	GP_5_13_FN___3 = 243,
	GP_5_14_FN___3 = 244,
	GP_5_15_FN___3 = 245,
	GP_5_16_FN___3 = 246,
	GP_5_17_FN___3 = 247,
	GP_5_18_FN___3 = 248,
	GP_5_19_FN___3 = 249,
	GP_6_0_FN___3 = 250,
	GP_6_1_FN___3 = 251,
	GP_6_2_FN___3 = 252,
	GP_6_3_FN___3 = 253,
	GP_6_4_FN___3 = 254,
	GP_6_5_FN___3 = 255,
	GP_6_6_FN___3 = 256,
	GP_6_7_FN___3 = 257,
	GP_6_8_FN___3 = 258,
	GP_6_9_FN___3 = 259,
	GP_6_10_FN___3 = 260,
	GP_6_11_FN___3 = 261,
	GP_6_12_FN___3 = 262,
	GP_6_13_FN___3 = 263,
	GP_6_14_FN___3 = 264,
	GP_6_15_FN___3 = 265,
	GP_6_16_FN___3 = 266,
	GP_6_17_FN___3 = 267,
	FN_AVB_PHY_INT___3 = 268,
	FN_CLKOUT___3 = 269,
	FN_AVB_RD3 = 270,
	FN_AVB_RXC = 271,
	FN_AVB_RX_CTL = 272,
	FN_QSPI0_SSL = 273,
	FN_IP0_3_0___3 = 274,
	FN_QSPI0_SPCLK = 275,
	FN_HSCK4_A = 276,
	FN_IP1_3_0___3 = 277,
	FN_QSPI1_IO2 = 278,
	FN_RIF2_D1_A___3 = 279,
	FN_HTX3_C___3 = 280,
	FN_VI4_DATA3_A___3 = 281,
	FN_IP2_3_0___3 = 282,
	FN_AVB_TXCREFCLK = 283,
	FN_IP3_3_0___3 = 284,
	FN_A1___3 = 285,
	FN_IRQ1___3 = 286,
	FN_PWM3_A___3 = 287,
	FN_DU_DOTCLKIN1 = 288,
	FN_VI5_DATA0_A = 289,
	FN_DU_DISP_CDE = 290,
	FN_SDA6_B___3 = 291,
	FN_IETX = 292,
	FN_QCPV_QDE___3 = 293,
	FN_IP0_7_4___3 = 294,
	FN_QSPI0_MOSI_IO0 = 295,
	FN_HCTS4_N_A = 296,
	FN_IP1_7_4___3 = 297,
	FN_QSPI1_IO3 = 298,
	FN_RIF3_CLK_A___3 = 299,
	FN_HRX3_C___3 = 300,
	FN_VI4_DATA4_A___3 = 301,
	FN_IP2_7_4___3 = 302,
	FN_AVB_MDIO = 303,
	FN_IP3_7_4___3 = 304,
	FN_A2___3 = 305,
	FN_IRQ2___3 = 306,
	FN_AVB_AVTP_PPS___3 = 307,
	FN_VI4_CLKENB___3 = 308,
	FN_VI5_DATA1_A = 309,
	FN_DU_DISP___3 = 310,
	FN_SCL6_B___3 = 311,
	FN_QSTVB_QVE___3 = 312,
	FN_IP0_11_8___3 = 313,
	FN_QSPI0_MISO_IO1 = 314,
	FN_HRTS4_N_A = 315,
	FN_IP1_11_8___3 = 316,
	FN_QSPI1_SSL = 317,
	FN_RIF3_SYNC_A___3 = 318,
	FN_HSCK3_C = 319,
	FN_VI4_DATA5_A___3 = 320,
	FN_IP2_11_8___3 = 321,
	FN_AVB_MDC___3 = 322,
	FN_IP3_11_8___3 = 323,
	FN_A3___3 = 324,
	FN_CTS4_N_A___3 = 325,
	FN_PWM4_A___3 = 326,
	FN_VI4_DATA12___3 = 327,
	FN_DU_DOTCLKOUT0___3 = 328,
	FN_HTX3_D___3 = 329,
	FN_IECLK = 330,
	FN_LCDOUT12___3 = 331,
	FN_IP0_15_12___3 = 332,
	FN_QSPI0_IO2 = 333,
	FN_HTX4_A___3 = 334,
	FN_IP1_15_12___3 = 335,
	FN_RPC_INT_N = 336,
	FN_RIF3_D0_A___3 = 337,
	FN_HCTS3_N_C = 338,
	FN_VI4_DATA6_A___3 = 339,
	FN_IP2_15_12___3 = 340,
	FN_BS_N___3 = 341,
	FN_PWM0_A = 342,
	FN_AVB_MAGIC___3 = 343,
	FN_VI4_CLK___3 = 344,
	FN_TX3_C = 345,
	FN_VI5_CLK_B = 346,
	FN_IP3_15_12___3 = 347,
	FN_A4___3 = 348,
	FN_RTS4_N_A___3 = 349,
	FN_MSIOF3_SYNC_B___3 = 350,
	FN_VI4_DATA8___3 = 351,
	FN_PWM2_B___3 = 352,
	FN_DU_DG4___3 = 353,
	FN_RIF2_CLK_B___3 = 354,
	FN_IP0_19_16___3 = 355,
	FN_QSPI0_IO3 = 356,
	FN_HRX4_A___3 = 357,
	FN_IP1_19_16___3 = 358,
	FN_RPC_RESET_N = 359,
	FN_RIF3_D1_A___3 = 360,
	FN_HRTS3_N_C = 361,
	FN_VI4_DATA7_A___3 = 362,
	FN_IP2_19_16___3 = 363,
	FN_RD_N___3 = 364,
	FN_PWM1_A___3 = 365,
	FN_AVB_LINK___3 = 366,
	FN_VI4_FIELD___3 = 367,
	FN_RX3_C = 368,
	FN_FSCLKST2_N_A___2 = 369,
	FN_VI5_DATA0_B = 370,
	FN_IP3_19_16___3 = 371,
	FN_A5___3 = 372,
	FN_SCK4_A___3 = 373,
	FN_MSIOF3_SCK_B___3 = 374,
	FN_VI4_DATA9___3 = 375,
	FN_PWM3_B___3 = 376,
	FN_RIF2_SYNC_B___3 = 377,
	FN_QPOLA___3 = 378,
	FN_IP0_23_20___3 = 379,
	FN_QSPI1_SPCLK = 380,
	FN_RIF2_CLK_A___3 = 381,
	FN_HSCK4_B = 382,
	FN_VI4_DATA0_A___3 = 383,
	FN_IP1_23_20___3 = 384,
	FN_AVB_RD0 = 385,
	FN_IP2_23_20___3 = 386,
	FN_RD_WR_N___3 = 387,
	FN_SCL7_A = 388,
	FN_AVB_AVTP_MATCH = 389,
	FN_VI4_VSYNC_N___3 = 390,
	FN_TX5_B___3 = 391,
	FN_SCK3_C = 392,
	FN_PWM5_A___3 = 393,
	FN_IP3_23_20___3 = 394,
	FN_A6___3 = 395,
	FN_RX4_A___3 = 396,
	FN_MSIOF3_RXD_B___3 = 397,
	FN_VI4_DATA10___3 = 398,
	FN_RIF2_D0_B___3 = 399,
	FN_IP0_27_24___3 = 400,
	FN_QSPI1_MOSI_IO0 = 401,
	FN_RIF2_SYNC_A___3 = 402,
	FN_HTX4_B___3 = 403,
	FN_VI4_DATA1_A___3 = 404,
	FN_IP1_27_24___3 = 405,
	FN_AVB_RD1 = 406,
	FN_IP2_27_24___3 = 407,
	FN_EX_WAIT0 = 408,
	FN_SDA7_A = 409,
	FN_AVB_AVTP_CAPTURE = 410,
	FN_VI4_HSYNC_N___3 = 411,
	FN_RX5_B___3 = 412,
	FN_PWM6_A___3 = 413,
	FN_IP3_27_24___3 = 414,
	FN_A7___3 = 415,
	FN_TX4_A___3 = 416,
	FN_MSIOF3_TXD_B___3 = 417,
	FN_VI4_DATA11___3 = 418,
	FN_RIF2_D1_B___3 = 419,
	FN_IP0_31_28___3 = 420,
	FN_QSPI1_MISO_IO1 = 421,
	FN_RIF2_D0_A___3 = 422,
	FN_HRX4_B___3 = 423,
	FN_VI4_DATA2_A___3 = 424,
	FN_IP1_31_28___3 = 425,
	FN_AVB_RD2 = 426,
	FN_IP2_31_28___3 = 427,
	FN_A0___3 = 428,
	FN_IRQ0___3 = 429,
	FN_PWM2_A___3 = 430,
	FN_MSIOF3_SS1_B___3 = 431,
	FN_VI5_CLK_A = 432,
	FN_DU_CDE___3 = 433,
	FN_HRX3_D___3 = 434,
	FN_IERX = 435,
	FN_QSTB_QHE___3 = 436,
	FN_IP3_31_28___3 = 437,
	FN_A8___3 = 438,
	FN_SDA6_A___3 = 439,
	FN_RX3_B___3 = 440,
	FN_HRX4_C = 441,
	FN_VI5_HSYNC_N_A = 442,
	FN_DU_HSYNC = 443,
	FN_VI4_DATA0_B___3 = 444,
	FN_QSTH_QHS___3 = 445,
	FN_IP4_3_0___3 = 446,
	FN_A9___3 = 447,
	FN_TX5_A___3 = 448,
	FN_IRQ3___3 = 449,
	FN_VI4_DATA16___3 = 450,
	FN_VI5_VSYNC_N_A = 451,
	FN_DU_DG7___3 = 452,
	FN_LCDOUT15___3 = 453,
	FN_IP5_3_0___3 = 454,
	FN_A17___3 = 455,
	FN_MSIOF1_RXD = 456,
	FN_VI4_DATA20___3 = 457,
	FN_VI5_DATA6_A = 458,
	FN_DU_DB6___3 = 459,
	FN_LCDOUT6___3 = 460,
	FN_IP6_3_0___3 = 461,
	FN_D3___3 = 462,
	FN_MSIOF3_TXD_A___3 = 463,
	FN_TX5_C = 464,
	FN_VI5_DATA15_A = 465,
	FN_DU_DR4___3 = 466,
	FN_TX4_C___3 = 467,
	FN_LCDOUT20___3 = 468,
	FN_IP7_3_0___3 = 469,
	FN_D11___3 = 470,
	FN_MSIOF2_TXD_A___3 = 471,
	FN_VI5_DATA11_A = 472,
	FN_DU_DG2___3 = 473,
	FN_RIF3_D1_B___3 = 474,
	FN_HRTS3_N_E = 475,
	FN_LCDOUT10___3 = 476,
	FN_IP4_7_4___3 = 477,
	FN_A10___3 = 478,
	FN_IRQ4___3 = 479,
	FN_MSIOF2_SYNC_B___3 = 480,
	FN_VI4_DATA13___3 = 481,
	FN_VI5_FIELD_A = 482,
	FN_DU_DG5___3 = 483,
	FN_FSCLKST2_N_B___2 = 484,
	FN_LCDOUT13___3 = 485,
	FN_IP5_7_4___3 = 486,
	FN_A18___3 = 487,
	FN_MSIOF1_TXD = 488,
	FN_VI4_DATA21___3 = 489,
	FN_VI5_DATA7_A = 490,
	FN_DU_DB0___3 = 491,
	FN_HRX4_E = 492,
	FN_LCDOUT0___3 = 493,
	FN_IP6_7_4___3 = 494,
	FN_D4___3 = 495,
	FN_CANFD1_TX___3 = 496,
	FN_HSCK3_B = 497,
	FN_CAN1_TX___3 = 498,
	FN_RTS3_N_A = 499,
	FN_MSIOF3_SS2_A___3 = 500,
	FN_VI5_DATA1_B = 501,
	FN_IP7_7_4___3 = 502,
	FN_D12___3 = 503,
	FN_CANFD0_TX = 504,
	FN_TX4_B___3 = 505,
	FN_CAN0_TX = 506,
	FN_VI5_DATA8_A = 507,
	FN_VI5_DATA3_B = 508,
	FN_IP4_11_8___3 = 509,
	FN_A11___3 = 510,
	FN_SCL6_A___3 = 511,
	FN_TX3_B___3 = 512,
	FN_HTX4_C = 513,
	FN_DU_VSYNC = 514,
	FN_VI4_DATA1_B___3 = 515,
	FN_QSTVA_QVS___3 = 516,
	FN_IP5_11_8___3 = 517,
	FN_A19___3 = 518,
	FN_MSIOF1_SCK = 519,
	FN_VI4_DATA22___3 = 520,
	FN_VI5_DATA2_A = 521,
	FN_DU_DB1___3 = 522,
	FN_HTX4_E = 523,
	FN_LCDOUT1___3 = 524,
	FN_IP6_11_8___3 = 525,
	FN_D5___3 = 526,
	FN_RX3_A___3 = 527,
	FN_HRX3_B___3 = 528,
	FN_DU_DR5___3 = 529,
	FN_VI4_DATA4_B___3 = 530,
	FN_LCDOUT21___3 = 531,
	FN_IP7_11_8___3 = 532,
	FN_D13___3 = 533,
	FN_CANFD0_RX = 534,
	FN_RX4_B___3 = 535,
	FN_CAN0_RX = 536,
	FN_VI5_DATA9_A = 537,
	FN_SCL7_B = 538,
	FN_VI5_DATA4_B = 539,
	FN_IP4_15_12___3 = 540,
	FN_A12___3 = 541,
	FN_RX5_A___3 = 542,
	FN_MSIOF2_SS2_B___3 = 543,
	FN_VI4_DATA17___3 = 544,
	FN_VI5_DATA3_A = 545,
	FN_DU_DG6___3 = 546,
	FN_LCDOUT14___3 = 547,
	FN_IP5_15_12___3 = 548,
	FN_CS0_N___3 = 549,
	FN_SCL5 = 550,
	FN_DU_DR0___3 = 551,
	FN_VI4_DATA2_B___3 = 552,
	FN_LCDOUT16___3 = 553,
	FN_IP6_15_12___3 = 554,
	FN_D6___3 = 555,
	FN_TX3_A___3 = 556,
	FN_HTX3_B___3 = 557,
	FN_DU_DR6___3 = 558,
	FN_VI4_DATA5_B___3 = 559,
	FN_LCDOUT22___3 = 560,
	FN_IP7_15_12 = 561,
	FN_D14___3 = 562,
	FN_CAN_CLK___3 = 563,
	FN_HRX3_A___3 = 564,
	FN_MSIOF2_SS2_A___3 = 565,
	FN_SDA7_B = 566,
	FN_VI5_DATA5_B = 567,
	FN_IP4_19_16___3 = 568,
	FN_A13___3 = 569,
	FN_SCK5_A___3 = 570,
	FN_MSIOF2_SCK_B___3 = 571,
	FN_VI4_DATA14___3 = 572,
	FN_HRX4_D = 573,
	FN_DU_DB2___3 = 574,
	FN_LCDOUT2___3 = 575,
	FN_IP5_19_16___3 = 576,
	FN_WE0_N___3 = 577,
	FN_SDA5 = 578,
	FN_DU_DR1___3 = 579,
	FN_VI4_DATA3_B___3 = 580,
	FN_LCDOUT17___3 = 581,
	FN_IP6_19_16___3 = 582,
	FN_D7___3 = 583,
	FN_CANFD1_RX___3 = 584,
	FN_IRQ5___3 = 585,
	FN_CAN1_RX___3 = 586,
	FN_CTS3_N_A = 587,
	FN_VI5_DATA2_B = 588,
	FN_IP7_19_16___3 = 589,
	FN_D15___3 = 590,
	FN_MSIOF2_SS1_A___3 = 591,
	FN_HTX3_A___3 = 592,
	FN_MSIOF3_SS1_A___3 = 593,
	FN_DU_DG3___3 = 594,
	FN_LCDOUT11___3 = 595,
	FN_IP4_23_20___3 = 596,
	FN_A14___3 = 597,
	FN_MSIOF1_SS1 = 598,
	FN_MSIOF2_RXD_B___3 = 599,
	FN_VI4_DATA15___3 = 600,
	FN_HTX4_D = 601,
	FN_DU_DB3___3 = 602,
	FN_LCDOUT3___3 = 603,
	FN_IP5_23_20___3 = 604,
	FN_D0___3 = 605,
	FN_MSIOF3_SCK_A___3 = 606,
	FN_DU_DR2___3 = 607,
	FN_CTS4_N_C___3 = 608,
	FN_LCDOUT18___3 = 609,
	FN_IP6_23_20___3 = 610,
	FN_D8___3 = 611,
	FN_MSIOF2_SCK_A___3 = 612,
	FN_SCK4_B___3 = 613,
	FN_VI5_DATA12_A = 614,
	FN_DU_DR7___3 = 615,
	FN_RIF3_CLK_B___3 = 616,
	FN_HCTS3_N_E = 617,
	FN_LCDOUT23___3 = 618,
	FN_IP7_23_20___3 = 619,
	FN_SCL4 = 620,
	FN_CS1_N_A26 = 621,
	FN_DU_DOTCLKIN0 = 622,
	FN_VI4_DATA6_B___3 = 623,
	FN_VI5_DATA6_B = 624,
	FN_QCLK___3 = 625,
	FN_IP4_27_24___3 = 626,
	FN_A15___3 = 627,
	FN_MSIOF1_SS2 = 628,
	FN_MSIOF2_TXD_B___3 = 629,
	FN_VI4_DATA18___3 = 630,
	FN_VI5_DATA4_A = 631,
	FN_DU_DB4___3 = 632,
	FN_LCDOUT4___3 = 633,
	FN_IP5_27_24___3 = 634,
	FN_D1___3 = 635,
	FN_MSIOF3_SYNC_A___3 = 636,
	FN_SCK3_A = 637,
	FN_VI4_DATA23___3 = 638,
	FN_VI5_CLKENB_A = 639,
	FN_DU_DB7___3 = 640,
	FN_RTS4_N_C___3 = 641,
	FN_LCDOUT7___3 = 642,
	FN_IP6_27_24___3 = 643,
	FN_D9___3 = 644,
	FN_MSIOF2_SYNC_A___3 = 645,
	FN_VI5_DATA10_A = 646,
	FN_DU_DG0___3 = 647,
	FN_RIF3_SYNC_B___3 = 648,
	FN_HRX3_E = 649,
	FN_LCDOUT8___3 = 650,
	FN_IP7_27_24___3 = 651,
	FN_SDA4 = 652,
	FN_WE1_N___3 = 653,
	FN_VI4_DATA7_B___3 = 654,
	FN_VI5_DATA7_B = 655,
	FN_QPOLB___3 = 656,
	FN_IP4_31_28___3 = 657,
	FN_A16___3 = 658,
	FN_MSIOF1_SYNC = 659,
	FN_MSIOF2_SS1_B___3 = 660,
	FN_VI4_DATA19___3 = 661,
	FN_VI5_DATA5_A = 662,
	FN_DU_DB5___3 = 663,
	FN_LCDOUT5___3 = 664,
	FN_IP5_31_28___3 = 665,
	FN_D2___3 = 666,
	FN_MSIOF3_RXD_A___3 = 667,
	FN_RX5_C = 668,
	FN_VI5_DATA14_A = 669,
	FN_DU_DR3___3 = 670,
	FN_RX4_C___3 = 671,
	FN_LCDOUT19___3 = 672,
	FN_IP6_31_28___3 = 673,
	FN_D10___3 = 674,
	FN_MSIOF2_RXD_A___3 = 675,
	FN_VI5_DATA13_A = 676,
	FN_DU_DG1___3 = 677,
	FN_RIF3_D0_B___3 = 678,
	FN_HTX3_E = 679,
	FN_LCDOUT9___3 = 680,
	FN_IP7_31_28___3 = 681,
	FN_SD0_CLK___3 = 682,
	FN_NFDATA8___3 = 683,
	FN_SCL1_C = 684,
	FN_HSCK1_B___3 = 685,
	FN_SDA2_E = 686,
	FN_FMCLK_B___3 = 687,
	FN_IP8_3_0___3 = 688,
	FN_SD0_CMD___3 = 689,
	FN_NFDATA9___3 = 690,
	FN_HRX1_B___3 = 691,
	FN_SPEEDIN_B___3 = 692,
	FN_IP9_3_0___3 = 693,
	FN_SD1_DAT1___3 = 694,
	FN_NFCE_N_B___3 = 695,
	FN_IP10_3_0___3 = 696,
	FN_SD3_DAT3___3 = 697,
	FN_NFDATA3___3 = 698,
	FN_IP11_3_0___3 = 699,
	FN_SD1_CD___3 = 700,
	FN_NFCE_N_A___3 = 701,
	FN_SSI_SCK1 = 702,
	FN_RIF0_D1_B___3 = 703,
	FN_TS_SDEN0 = 704,
	FN_IP8_7_4___3 = 705,
	FN_SD0_DAT0___3 = 706,
	FN_NFDATA10___3 = 707,
	FN_HTX1_B___3 = 708,
	FN_REMOCON_B___3 = 709,
	FN_IP9_7_4___3 = 710,
	FN_SD1_DAT2___3 = 711,
	FN_NFALE_B = 712,
	FN_IP10_7_4___3 = 713,
	FN_SD3_DAT4___3 = 714,
	FN_NFDATA4___3 = 715,
	FN_IP11_7_4___3 = 716,
	FN_SD1_WP___3 = 717,
	FN_NFWP_N_A___3 = 718,
	FN_SSI_WS1 = 719,
	FN_RIF0_SYNC_B___3 = 720,
	FN_TS_SPSYNC0 = 721,
	FN_IP8_11_8___3 = 722,
	FN_SD0_DAT1___3 = 723,
	FN_NFDATA11___3 = 724,
	FN_SDA2_C = 725,
	FN_HCTS1_N_B___3 = 726,
	FN_FMIN_B___3 = 727,
	FN_IP9_11_8___3 = 728,
	FN_SD1_DAT3___3 = 729,
	FN_NFRB_N_B___3 = 730,
	FN_IP10_11_8___3 = 731,
	FN_SD3_DAT5___3 = 732,
	FN_NFDATA5___3 = 733,
	FN_IP11_11_8___3 = 734,
	FN_RX0_A = 735,
	FN_HRX1_A___3 = 736,
	FN_SSI_SCK2_A___3 = 737,
	FN_RIF1_SYNC = 738,
	FN_TS_SCK1 = 739,
	FN_IP8_15_12___3 = 740,
	FN_SD0_DAT2___3 = 741,
	FN_NFDATA12___3 = 742,
	FN_SCL2_C = 743,
	FN_HRTS1_N_B___3 = 744,
	FN_BPFCLK_B___3 = 745,
	FN_IP9_15_12___3 = 746,
	FN_SD3_CLK___3 = 747,
	FN_NFWE_N___3 = 748,
	FN_IP10_15_12___3 = 749,
	FN_SD3_DAT6___3 = 750,
	FN_NFDATA6___3 = 751,
	FN_IP11_15_12___3 = 752,
	FN_TX0_A = 753,
	FN_HTX1_A___3 = 754,
	FN_SSI_WS2_A___3 = 755,
	FN_RIF1_D0 = 756,
	FN_TS_SDAT1 = 757,
	FN_IP8_19_16___3 = 758,
	FN_SD0_DAT3___3 = 759,
	FN_NFDATA13___3 = 760,
	FN_SDA1_C = 761,
	FN_SCL2_E = 762,
	FN_SPEEDIN_C = 763,
	FN_REMOCON_C = 764,
	FN_IP9_19_16___3 = 765,
	FN_SD3_CMD___3 = 766,
	FN_NFRE_N___3 = 767,
	FN_IP10_19_16___3 = 768,
	FN_SD3_DAT7___3 = 769,
	FN_NFDATA7___3 = 770,
	FN_IP11_19_16___3 = 771,
	FN_CTS0_N_A = 772,
	FN_NFDATA14_A___3 = 773,
	FN_AUDIO_CLKOUT_A___3 = 774,
	FN_RIF1_D1 = 775,
	FN_SCIF_CLK_A___3 = 776,
	FN_FMCLK_A___3 = 777,
	FN_IP8_23_20___3 = 778,
	FN_SD1_CLK___3 = 779,
	FN_NFDATA14_B___3 = 780,
	FN_IP9_23_20___3 = 781,
	FN_SD3_DAT0___3 = 782,
	FN_NFDATA0___3 = 783,
	FN_IP10_23_20___3 = 784,
	FN_SD3_DS___3 = 785,
	FN_NFCLE___3 = 786,
	FN_IP11_23_20___3 = 787,
	FN_RTS0_N_A = 788,
	FN_NFDATA15_A___3 = 789,
	FN_AUDIO_CLKOUT1_A___3 = 790,
	FN_RIF1_CLK = 791,
	FN_SCL2_A___3 = 792,
	FN_FMIN_A___3 = 793,
	FN_IP8_27_24___3 = 794,
	FN_SD1_CMD___3 = 795,
	FN_NFDATA15_B___3 = 796,
	FN_IP9_27_24___3 = 797,
	FN_SD3_DAT1___3 = 798,
	FN_NFDATA1___3 = 799,
	FN_IP10_27_24___3 = 800,
	FN_SD0_CD___3 = 801,
	FN_NFALE_A = 802,
	FN_SD3_CD___3 = 803,
	FN_RIF0_CLK_B___3 = 804,
	FN_SCL2_B___3 = 805,
	FN_TCLK1_A___3 = 806,
	FN_SSI_SCK2_B___3 = 807,
	FN_TS_SCK0 = 808,
	FN_IP11_27_24___3 = 809,
	FN_SCK0_A = 810,
	FN_HSCK1_A___3 = 811,
	FN_USB3HS0_ID = 812,
	FN_RTS1_N___3 = 813,
	FN_SDA2_A___3 = 814,
	FN_FMCLK_C___3 = 815,
	FN_USB0_ID = 816,
	FN_IP8_31_28___3 = 817,
	FN_SD1_DAT0___3 = 818,
	FN_NFWP_N_B___3 = 819,
	FN_IP9_31_28___3 = 820,
	FN_SD3_DAT2___3 = 821,
	FN_NFDATA2___3 = 822,
	FN_IP10_31_28___3 = 823,
	FN_SD0_WP___3 = 824,
	FN_NFRB_N_A___3 = 825,
	FN_SD3_WP___3 = 826,
	FN_RIF0_D0_B___3 = 827,
	FN_SDA2_B___3 = 828,
	FN_TCLK2_A___3 = 829,
	FN_SSI_WS2_B___3 = 830,
	FN_TS_SDAT0 = 831,
	FN_IP11_31_28___3 = 832,
	FN_RX1 = 833,
	FN_HRX2_B___3 = 834,
	FN_SSI_SCK9_B___3 = 835,
	FN_AUDIO_CLKOUT1_B___3 = 836,
	FN_IP12_3_0___3 = 837,
	FN_TX1 = 838,
	FN_HTX2_B___3 = 839,
	FN_SSI_WS9_B___3 = 840,
	FN_AUDIO_CLKOUT3_B___3 = 841,
	FN_IP13_3_0___3 = 842,
	FN_MSIOF0_SS1___3 = 843,
	FN_HRX2_A___3 = 844,
	FN_SSI_SCK4___3 = 845,
	FN_HCTS0_N_A = 846,
	FN_BPFCLK_C___3 = 847,
	FN_SPEEDIN_A___3 = 848,
	FN_IP14_3_0___3 = 849,
	FN_SSI_SDATA0___3 = 850,
	FN_IP15_3_0___3 = 851,
	FN_SSI_WS5___3 = 852,
	FN_HTX0_B = 853,
	FN_USB0_OVC_B = 854,
	FN_SDA2_D = 855,
	FN_IP12_7_4___3 = 856,
	FN_SCK2_A = 857,
	FN_HSCK0_A = 858,
	FN_AUDIO_CLKB_A___3 = 859,
	FN_CTS1_N___3 = 860,
	FN_RIF0_CLK_A___3 = 861,
	FN_REMOCON_A___3 = 862,
	FN_SCIF_CLK_B___3 = 863,
	FN_IP13_7_4___3 = 864,
	FN_MSIOF0_SS2___3 = 865,
	FN_HTX2_A___3 = 866,
	FN_SSI_WS4___3 = 867,
	FN_HRTS0_N_A = 868,
	FN_FMIN_C___3 = 869,
	FN_BPFCLK_A___3 = 870,
	FN_IP14_7_4___3 = 871,
	FN_SSI_SDATA1 = 872,
	FN_AUDIO_CLKC_B___3 = 873,
	FN_PWM0_B = 874,
	FN_IP15_7_4___3 = 875,
	FN_SSI_SDATA5___3 = 876,
	FN_HSCK0_B = 877,
	FN_AUDIO_CLKB_C = 878,
	FN_TPU0TO0___3 = 879,
	FN_IP12_11_8___3 = 880,
	FN_TX2_A___3 = 881,
	FN_HRX0_A = 882,
	FN_AUDIO_CLKOUT2_A___3 = 883,
	FN_SCL1_A___3 = 884,
	FN_FSO_CFE_0_N_A = 885,
	FN_TS_SDEN1 = 886,
	FN_IP13_11_8___3 = 887,
	FN_SSI_SDATA9 = 888,
	FN_AUDIO_CLKC_A___3 = 889,
	FN_SCK1___3 = 890,
	FN_IP14_11_8___3 = 891,
	FN_SSI_SDATA2 = 892,
	FN_AUDIO_CLKOUT2_B___3 = 893,
	FN_SSI_SCK9_A___3 = 894,
	FN_PWM1_B___3 = 895,
	FN_IP15_11_8___3 = 896,
	FN_SSI_SCK6___3 = 897,
	FN_HSCK2_A___3 = 898,
	FN_AUDIO_CLKC_C = 899,
	FN_TPU0TO1___3 = 900,
	FN_FSO_CFE_0_N_B = 901,
	FN_SIM0_RST_B___3 = 902,
	FN_IP12_15_12___3 = 903,
	FN_RX2_A___3 = 904,
	FN_HTX0_A = 905,
	FN_AUDIO_CLKOUT3_A___3 = 906,
	FN_SDA1_A___3 = 907,
	FN_FSO_CFE_1_N_A = 908,
	FN_TS_SPSYNC1 = 909,
	FN_IP13_15_12___3 = 910,
	FN_MLB_CLK___3 = 911,
	FN_RX0_B = 912,
	FN_RIF0_D0_A___3 = 913,
	FN_SCL1_B___3 = 914,
	FN_TCLK1_B___3 = 915,
	FN_SIM0_RST_A___3 = 916,
	FN_IP14_15_12___3 = 917,
	FN_SSI_SCK349___3 = 918,
	FN_PWM2_C = 919,
	FN_IP15_15_12___3 = 920,
	FN_SSI_WS6___3 = 921,
	FN_HCTS2_N_A___3 = 922,
	FN_AUDIO_CLKOUT2_C = 923,
	FN_TPU0TO2___3 = 924,
	FN_SDA1_D = 925,
	FN_FSO_CFE_1_N_B = 926,
	FN_SIM0_D_B___3 = 927,
	FN_IP12_19_16___3 = 928,
	FN_MSIOF0_SCK___3 = 929,
	FN_SSI_SCK78___3 = 930,
	FN_IP13_19_16___3 = 931,
	FN_MLB_SIG___3 = 932,
	FN_SCK0_B = 933,
	FN_RIF0_D1_A___3 = 934,
	FN_SDA1_B___3 = 935,
	FN_TCLK2_B___3 = 936,
	FN_SIM0_D_A___3 = 937,
	FN_IP14_19_16___3 = 938,
	FN_SSI_WS349___3 = 939,
	FN_PWM3_C = 940,
	FN_IP15_19_16___3 = 941,
	FN_SSI_SDATA6___3 = 942,
	FN_HRTS2_N_A___3 = 943,
	FN_AUDIO_CLKOUT3_C = 944,
	FN_TPU0TO3___3 = 945,
	FN_SCL1_D = 946,
	FN_FSO_TOE_N_B = 947,
	FN_SIM0_CLK_B___3 = 948,
	FN_IP12_23_20___3 = 949,
	FN_MSIOF0_RXD___3 = 950,
	FN_SSI_WS78___3 = 951,
	FN_TX2_B___3 = 952,
	FN_IP13_23_20___3 = 953,
	FN_MLB_DAT___3 = 954,
	FN_TX0_B = 955,
	FN_RIF0_SYNC_A___3 = 956,
	FN_SIM0_CLK_A___3 = 957,
	FN_IP14_23_20___3 = 958,
	FN_SSI_SDATA3___3 = 959,
	FN_AUDIO_CLKOUT1_C = 960,
	FN_AUDIO_CLKB_B___3 = 961,
	FN_PWM4_B___3 = 962,
	FN_IP15_23_20___3 = 963,
	FN_AUDIO_CLKA = 964,
	FN_IP12_27_24___3 = 965,
	FN_MSIOF0_TXD___3 = 966,
	FN_SSI_SDATA7___3 = 967,
	FN_RX2_B___3 = 968,
	FN_IP13_27_24___3 = 969,
	FN_SSI_SCK01239___3 = 970,
	FN_IP14_27_24___3 = 971,
	FN_SSI_SDATA4___3 = 972,
	FN_SSI_WS9_A___3 = 973,
	FN_PWM5_B___3 = 974,
	FN_IP15_27_24___3 = 975,
	FN_USB30_PWEN___3 = 976,
	FN_USB0_PWEN_A = 977,
	FN_IP12_31_28___3 = 978,
	FN_MSIOF0_SYNC___3 = 979,
	FN_AUDIO_CLKOUT_B___3 = 980,
	FN_SSI_SDATA8___3 = 981,
	FN_IP13_31_28___3 = 982,
	FN_SSI_WS01239___3 = 983,
	FN_IP14_31_28___3 = 984,
	FN_SSI_SCK5___3 = 985,
	FN_HRX0_B = 986,
	FN_USB0_PWEN_B = 987,
	FN_SCL2_D = 988,
	FN_PWM6_B___3 = 989,
	FN_IP15_31_28___3 = 990,
	FN_USB30_OVC___3 = 991,
	FN_USB0_OVC_A = 992,
	FN_FSO_TOE_N_A = 993,
	FN_SEL_SIMCARD_0___3 = 994,
	FN_SEL_SIMCARD_1___3 = 995,
	FN_SEL_ADGB_0___3 = 996,
	FN_SEL_ADGB_2 = 997,
	FN_SEL_ADGB_1___3 = 998,
	FN_SEL_SSI2_0___3 = 999,
	FN_SEL_SSI2_1___3 = 1000,
	FN_SEL_TIMER_TMU_0___3 = 1001,
	FN_SEL_TIMER_TMU_1___3 = 1002,
	FN_SEL_DRIF0_0___3 = 1003,
	FN_SEL_DRIF0_1___3 = 1004,
	FN_SEL_USB_20_CH0_0 = 1005,
	FN_SEL_USB_20_CH0_1 = 1006,
	FN_SEL_FM_0___3 = 1007,
	FN_SEL_FM_2___3 = 1008,
	FN_SEL_FM_1___3 = 1009,
	FN_SEL_DRIF2_0___3 = 1010,
	FN_SEL_DRIF2_1___3 = 1011,
	FN_SEL_FSO_0 = 1012,
	FN_SEL_FSO_1 = 1013,
	FN_SEL_DRIF3_0___3 = 1014,
	FN_SEL_DRIF3_1___3 = 1015,
	FN_SEL_HSCIF0_0 = 1016,
	FN_SEL_HSCIF0_1 = 1017,
	FN_SEL_HSCIF3_0___3 = 1018,
	FN_SEL_HSCIF3_4 = 1019,
	FN_SEL_HSCIF3_2___3 = 1020,
	FN_SEL_HSCIF3_1___3 = 1021,
	FN_SEL_HSCIF3_3___3 = 1022,
	FN_SEL_HSCIF1_0___3 = 1023,
	FN_SEL_HSCIF1_1___3 = 1024,
	FN_SEL_HSCIF2_0___3 = 1025,
	FN_SEL_HSCIF2_1___3 = 1026,
	FN_SEL_I2C1_0___3 = 1027,
	FN_SEL_I2C1_2 = 1028,
	FN_SEL_I2C1_1___3 = 1029,
	FN_SEL_I2C1_3 = 1030,
	FN_SEL_HSCIF4_0___3 = 1031,
	FN_SEL_HSCIF4_4 = 1032,
	FN_SEL_HSCIF4_2 = 1033,
	FN_SEL_HSCIF4_1___3 = 1034,
	FN_SEL_HSCIF4_3 = 1035,
	FN_SEL_I2C2_0___3 = 1036,
	FN_SEL_I2C2_4 = 1037,
	FN_SEL_I2C2_2 = 1038,
	FN_SEL_I2C2_1___3 = 1039,
	FN_SEL_I2C2_3 = 1040,
	FN_SEL_I2C6_0___3 = 1041,
	FN_SEL_I2C6_1___3 = 1042,
	FN_SEL_I2C7_0 = 1043,
	FN_SEL_I2C7_1 = 1044,
	FN_SEL_NDF_0___3 = 1045,
	FN_SEL_NDF_1___3 = 1046,
	FN_SEL_MSIOF2_0___3 = 1047,
	FN_SEL_MSIOF2_1___3 = 1048,
	FN_SEL_PWM0_0 = 1049,
	FN_SEL_PWM0_1 = 1050,
	FN_SEL_MSIOF3_0___3 = 1051,
	FN_SEL_MSIOF3_1___3 = 1052,
	FN_SEL_PWM1_0___3 = 1053,
	FN_SEL_PWM1_1___3 = 1054,
	FN_SEL_SCIF3_0___3 = 1055,
	FN_SEL_SCIF3_2 = 1056,
	FN_SEL_SCIF3_1___3 = 1057,
	FN_SEL_PWM2_0___3 = 1058,
	FN_SEL_PWM2_2 = 1059,
	FN_SEL_PWM2_1___3 = 1060,
	FN_SEL_SCIF4_0___3 = 1061,
	FN_SEL_SCIF4_2___3 = 1062,
	FN_SEL_SCIF4_1___3 = 1063,
	FN_SEL_PWM3_0___3 = 1064,
	FN_SEL_PWM3_2 = 1065,
	FN_SEL_PWM3_1___3 = 1066,
	FN_SEL_SCIF5_0___3 = 1067,
	FN_SEL_SCIF5_2 = 1068,
	FN_SEL_SCIF5_1___3 = 1069,
	FN_SEL_PWM4_0___3 = 1070,
	FN_SEL_PWM4_1___3 = 1071,
	FN_SEL_PWM5_0___3 = 1072,
	FN_SEL_PWM5_1___3 = 1073,
	FN_SEL_VIN4_0___3 = 1074,
	FN_SEL_VIN4_1___3 = 1075,
	FN_SEL_PWM6_0___3 = 1076,
	FN_SEL_PWM6_1___3 = 1077,
	FN_SEL_VIN5_0 = 1078,
	FN_SEL_VIN5_1 = 1079,
	FN_SEL_REMOCON_0___3 = 1080,
	FN_SEL_REMOCON_2 = 1081,
	FN_SEL_REMOCON_1___3 = 1082,
	FN_SEL_ADGC_0___3 = 1083,
	FN_SEL_ADGC_2 = 1084,
	FN_SEL_ADGC_1___3 = 1085,
	FN_SEL_SCIF_0___3 = 1086,
	FN_SEL_SCIF_1___3 = 1087,
	FN_SEL_SSI9_0___3 = 1088,
	FN_SEL_SSI9_1___3 = 1089,
	FN_SEL_SCIF0_0 = 1090,
	FN_SEL_SCIF0_1 = 1091,
	FN_SEL_SCIF2_0___3 = 1092,
	FN_SEL_SCIF2_1___3 = 1093,
	FN_SEL_SPEED_PULSE_IF_0 = 1094,
	FN_SEL_SPEED_PULSE_IF_2 = 1095,
	FN_SEL_SPEED_PULSE_IF_1 = 1096,
	PINMUX_FUNCTION_END___3 = 1097,
	PINMUX_MARK_BEGIN___3 = 1098,
	AVB_PHY_INT_MARK___3 = 1099,
	CLKOUT_MARK___3 = 1100,
	AVB_RD3_MARK___3 = 1101,
	AVB_RXC_MARK___3 = 1102,
	AVB_RX_CTL_MARK___3 = 1103,
	QSPI0_SSL_MARK___3 = 1104,
	IP0_3_0_MARK___3 = 1105,
	QSPI0_SPCLK_MARK___3 = 1106,
	HSCK4_A_MARK = 1107,
	IP1_3_0_MARK___3 = 1108,
	QSPI1_IO2_MARK___3 = 1109,
	RIF2_D1_A_MARK___3 = 1110,
	HTX3_C_MARK___3 = 1111,
	VI4_DATA3_A_MARK___3 = 1112,
	IP2_3_0_MARK___3 = 1113,
	AVB_TXCREFCLK_MARK___3 = 1114,
	IP3_3_0_MARK___3 = 1115,
	A1_MARK___3 = 1116,
	IRQ1_MARK___3 = 1117,
	PWM3_A_MARK___3 = 1118,
	DU_DOTCLKIN1_MARK___3 = 1119,
	VI5_DATA0_A_MARK = 1120,
	DU_DISP_CDE_MARK = 1121,
	SDA6_B_MARK___3 = 1122,
	IETX_MARK = 1123,
	QCPV_QDE_MARK___3 = 1124,
	IP0_7_4_MARK___3 = 1125,
	QSPI0_MOSI_IO0_MARK___3 = 1126,
	HCTS4_N_A_MARK = 1127,
	IP1_7_4_MARK___3 = 1128,
	QSPI1_IO3_MARK___3 = 1129,
	RIF3_CLK_A_MARK___3 = 1130,
	HRX3_C_MARK___3 = 1131,
	VI4_DATA4_A_MARK___3 = 1132,
	IP2_7_4_MARK___3 = 1133,
	AVB_MDIO_MARK___3 = 1134,
	IP3_7_4_MARK___3 = 1135,
	A2_MARK___3 = 1136,
	IRQ2_MARK___3 = 1137,
	AVB_AVTP_PPS_MARK___3 = 1138,
	VI4_CLKENB_MARK___3 = 1139,
	VI5_DATA1_A_MARK = 1140,
	DU_DISP_MARK___3 = 1141,
	SCL6_B_MARK___3 = 1142,
	QSTVB_QVE_MARK___3 = 1143,
	IP0_11_8_MARK___3 = 1144,
	QSPI0_MISO_IO1_MARK___3 = 1145,
	HRTS4_N_A_MARK = 1146,
	IP1_11_8_MARK___3 = 1147,
	QSPI1_SSL_MARK___3 = 1148,
	RIF3_SYNC_A_MARK___3 = 1149,
	HSCK3_C_MARK = 1150,
	VI4_DATA5_A_MARK___3 = 1151,
	IP2_11_8_MARK___3 = 1152,
	AVB_MDC_MARK___3 = 1153,
	IP3_11_8_MARK___3 = 1154,
	A3_MARK___3 = 1155,
	CTS4_N_A_MARK___3 = 1156,
	PWM4_A_MARK___3 = 1157,
	VI4_DATA12_MARK___3 = 1158,
	DU_DOTCLKOUT0_MARK___3 = 1159,
	HTX3_D_MARK___3 = 1160,
	IECLK_MARK = 1161,
	LCDOUT12_MARK___3 = 1162,
	IP0_15_12_MARK___3 = 1163,
	QSPI0_IO2_MARK___3 = 1164,
	HTX4_A_MARK___3 = 1165,
	IP1_15_12_MARK___3 = 1166,
	RPC_INT_N_MARK = 1167,
	RIF3_D0_A_MARK___3 = 1168,
	HCTS3_N_C_MARK = 1169,
	VI4_DATA6_A_MARK___3 = 1170,
	IP2_15_12_MARK___3 = 1171,
	BS_N_MARK___3 = 1172,
	PWM0_A_MARK = 1173,
	AVB_MAGIC_MARK___3 = 1174,
	VI4_CLK_MARK___3 = 1175,
	TX3_C_MARK = 1176,
	VI5_CLK_B_MARK = 1177,
	IP3_15_12_MARK___3 = 1178,
	A4_MARK___3 = 1179,
	RTS4_N_A_MARK___3 = 1180,
	MSIOF3_SYNC_B_MARK___3 = 1181,
	VI4_DATA8_MARK___3 = 1182,
	PWM2_B_MARK___3 = 1183,
	DU_DG4_MARK___3 = 1184,
	RIF2_CLK_B_MARK___3 = 1185,
	IP0_19_16_MARK___3 = 1186,
	QSPI0_IO3_MARK___3 = 1187,
	HRX4_A_MARK___3 = 1188,
	IP1_19_16_MARK___3 = 1189,
	RPC_RESET_N_MARK = 1190,
	RIF3_D1_A_MARK___3 = 1191,
	HRTS3_N_C_MARK = 1192,
	VI4_DATA7_A_MARK___3 = 1193,
	IP2_19_16_MARK___3 = 1194,
	RD_N_MARK___3 = 1195,
	PWM1_A_MARK___3 = 1196,
	AVB_LINK_MARK___3 = 1197,
	VI4_FIELD_MARK___3 = 1198,
	RX3_C_MARK = 1199,
	FSCLKST2_N_A_MARK___2 = 1200,
	VI5_DATA0_B_MARK = 1201,
	IP3_19_16_MARK___3 = 1202,
	A5_MARK___3 = 1203,
	SCK4_A_MARK___3 = 1204,
	MSIOF3_SCK_B_MARK___3 = 1205,
	VI4_DATA9_MARK___3 = 1206,
	PWM3_B_MARK___3 = 1207,
	RIF2_SYNC_B_MARK___3 = 1208,
	QPOLA_MARK___3 = 1209,
	IP0_23_20_MARK___3 = 1210,
	QSPI1_SPCLK_MARK___3 = 1211,
	RIF2_CLK_A_MARK___3 = 1212,
	HSCK4_B_MARK = 1213,
	VI4_DATA0_A_MARK___3 = 1214,
	IP1_23_20_MARK___3 = 1215,
	AVB_RD0_MARK___3 = 1216,
	IP2_23_20_MARK___3 = 1217,
	RD_WR_N_MARK___3 = 1218,
	SCL7_A_MARK = 1219,
	AVB_AVTP_MATCH_MARK = 1220,
	VI4_VSYNC_N_MARK___3 = 1221,
	TX5_B_MARK___3 = 1222,
	SCK3_C_MARK = 1223,
	PWM5_A_MARK___3 = 1224,
	IP3_23_20_MARK___3 = 1225,
	A6_MARK___3 = 1226,
	RX4_A_MARK___3 = 1227,
	MSIOF3_RXD_B_MARK___3 = 1228,
	VI4_DATA10_MARK___3 = 1229,
	RIF2_D0_B_MARK___3 = 1230,
	IP0_27_24_MARK___3 = 1231,
	QSPI1_MOSI_IO0_MARK___3 = 1232,
	RIF2_SYNC_A_MARK___3 = 1233,
	HTX4_B_MARK___3 = 1234,
	VI4_DATA1_A_MARK___3 = 1235,
	IP1_27_24_MARK___3 = 1236,
	AVB_RD1_MARK___3 = 1237,
	IP2_27_24_MARK___3 = 1238,
	EX_WAIT0_MARK = 1239,
	SDA7_A_MARK = 1240,
	AVB_AVTP_CAPTURE_MARK = 1241,
	VI4_HSYNC_N_MARK___3 = 1242,
	RX5_B_MARK___3 = 1243,
	PWM6_A_MARK___3 = 1244,
	IP3_27_24_MARK___3 = 1245,
	A7_MARK___3 = 1246,
	TX4_A_MARK___3 = 1247,
	MSIOF3_TXD_B_MARK___3 = 1248,
	VI4_DATA11_MARK___3 = 1249,
	RIF2_D1_B_MARK___3 = 1250,
	IP0_31_28_MARK___3 = 1251,
	QSPI1_MISO_IO1_MARK___3 = 1252,
	RIF2_D0_A_MARK___3 = 1253,
	HRX4_B_MARK___3 = 1254,
	VI4_DATA2_A_MARK___3 = 1255,
	IP1_31_28_MARK___3 = 1256,
	AVB_RD2_MARK___3 = 1257,
	IP2_31_28_MARK___3 = 1258,
	A0_MARK___3 = 1259,
	IRQ0_MARK___3 = 1260,
	PWM2_A_MARK___3 = 1261,
	MSIOF3_SS1_B_MARK___3 = 1262,
	VI5_CLK_A_MARK = 1263,
	DU_CDE_MARK___3 = 1264,
	HRX3_D_MARK___3 = 1265,
	IERX_MARK = 1266,
	QSTB_QHE_MARK___3 = 1267,
	IP3_31_28_MARK___3 = 1268,
	A8_MARK___3 = 1269,
	SDA6_A_MARK___3 = 1270,
	RX3_B_MARK___3 = 1271,
	HRX4_C_MARK = 1272,
	VI5_HSYNC_N_A_MARK = 1273,
	DU_HSYNC_MARK = 1274,
	VI4_DATA0_B_MARK___3 = 1275,
	QSTH_QHS_MARK___3 = 1276,
	IP4_3_0_MARK___3 = 1277,
	A9_MARK___3 = 1278,
	TX5_A_MARK___3 = 1279,
	IRQ3_MARK___3 = 1280,
	VI4_DATA16_MARK___3 = 1281,
	VI5_VSYNC_N_A_MARK = 1282,
	DU_DG7_MARK___3 = 1283,
	LCDOUT15_MARK___3 = 1284,
	IP5_3_0_MARK___3 = 1285,
	A17_MARK___3 = 1286,
	MSIOF1_RXD_MARK = 1287,
	VI4_DATA20_MARK___3 = 1288,
	VI5_DATA6_A_MARK = 1289,
	DU_DB6_MARK___3 = 1290,
	LCDOUT6_MARK___3 = 1291,
	IP6_3_0_MARK___3 = 1292,
	D3_MARK___3 = 1293,
	MSIOF3_TXD_A_MARK___3 = 1294,
	TX5_C_MARK = 1295,
	VI5_DATA15_A_MARK = 1296,
	DU_DR4_MARK___3 = 1297,
	TX4_C_MARK___3 = 1298,
	LCDOUT20_MARK___3 = 1299,
	IP7_3_0_MARK___3 = 1300,
	D11_MARK___3 = 1301,
	MSIOF2_TXD_A_MARK___3 = 1302,
	VI5_DATA11_A_MARK = 1303,
	DU_DG2_MARK___3 = 1304,
	RIF3_D1_B_MARK___3 = 1305,
	HRTS3_N_E_MARK = 1306,
	LCDOUT10_MARK___3 = 1307,
	IP4_7_4_MARK___3 = 1308,
	A10_MARK___3 = 1309,
	IRQ4_MARK___3 = 1310,
	MSIOF2_SYNC_B_MARK___3 = 1311,
	VI4_DATA13_MARK___3 = 1312,
	VI5_FIELD_A_MARK = 1313,
	DU_DG5_MARK___3 = 1314,
	FSCLKST2_N_B_MARK___2 = 1315,
	LCDOUT13_MARK___3 = 1316,
	IP5_7_4_MARK___3 = 1317,
	A18_MARK___3 = 1318,
	MSIOF1_TXD_MARK = 1319,
	VI4_DATA21_MARK___3 = 1320,
	VI5_DATA7_A_MARK = 1321,
	DU_DB0_MARK___3 = 1322,
	HRX4_E_MARK = 1323,
	LCDOUT0_MARK___3 = 1324,
	IP6_7_4_MARK___3 = 1325,
	D4_MARK___3 = 1326,
	CANFD1_TX_MARK___3 = 1327,
	HSCK3_B_MARK = 1328,
	CAN1_TX_MARK___3 = 1329,
	RTS3_N_A_MARK = 1330,
	MSIOF3_SS2_A_MARK___3 = 1331,
	VI5_DATA1_B_MARK = 1332,
	IP7_7_4_MARK___3 = 1333,
	D12_MARK___3 = 1334,
	CANFD0_TX_MARK = 1335,
	TX4_B_MARK___3 = 1336,
	CAN0_TX_MARK = 1337,
	VI5_DATA8_A_MARK = 1338,
	VI5_DATA3_B_MARK = 1339,
	IP4_11_8_MARK___3 = 1340,
	A11_MARK___3 = 1341,
	SCL6_A_MARK___3 = 1342,
	TX3_B_MARK___3 = 1343,
	HTX4_C_MARK = 1344,
	DU_VSYNC_MARK = 1345,
	VI4_DATA1_B_MARK___3 = 1346,
	QSTVA_QVS_MARK___3 = 1347,
	IP5_11_8_MARK___3 = 1348,
	A19_MARK___3 = 1349,
	MSIOF1_SCK_MARK = 1350,
	VI4_DATA22_MARK___3 = 1351,
	VI5_DATA2_A_MARK = 1352,
	DU_DB1_MARK___3 = 1353,
	HTX4_E_MARK = 1354,
	LCDOUT1_MARK___3 = 1355,
	IP6_11_8_MARK___3 = 1356,
	D5_MARK___3 = 1357,
	RX3_A_MARK___3 = 1358,
	HRX3_B_MARK___3 = 1359,
	DU_DR5_MARK___3 = 1360,
	VI4_DATA4_B_MARK___3 = 1361,
	LCDOUT21_MARK___3 = 1362,
	IP7_11_8_MARK___3 = 1363,
	D13_MARK___3 = 1364,
	CANFD0_RX_MARK = 1365,
	RX4_B_MARK___3 = 1366,
	CAN0_RX_MARK = 1367,
	VI5_DATA9_A_MARK = 1368,
	SCL7_B_MARK = 1369,
	VI5_DATA4_B_MARK = 1370,
	IP4_15_12_MARK___3 = 1371,
	A12_MARK___3 = 1372,
	RX5_A_MARK___3 = 1373,
	MSIOF2_SS2_B_MARK___3 = 1374,
	VI4_DATA17_MARK___3 = 1375,
	VI5_DATA3_A_MARK = 1376,
	DU_DG6_MARK___3 = 1377,
	LCDOUT14_MARK___3 = 1378,
	IP5_15_12_MARK___3 = 1379,
	CS0_N_MARK___3 = 1380,
	SCL5_MARK___3 = 1381,
	DU_DR0_MARK___3 = 1382,
	VI4_DATA2_B_MARK___3 = 1383,
	LCDOUT16_MARK___3 = 1384,
	IP6_15_12_MARK___3 = 1385,
	D6_MARK___3 = 1386,
	TX3_A_MARK___3 = 1387,
	HTX3_B_MARK___3 = 1388,
	DU_DR6_MARK___3 = 1389,
	VI4_DATA5_B_MARK___3 = 1390,
	LCDOUT22_MARK___3 = 1391,
	IP7_15_12_MARK = 1392,
	D14_MARK___3 = 1393,
	CAN_CLK_MARK___3 = 1394,
	HRX3_A_MARK___3 = 1395,
	MSIOF2_SS2_A_MARK___3 = 1396,
	SDA7_B_MARK = 1397,
	VI5_DATA5_B_MARK = 1398,
	IP4_19_16_MARK___3 = 1399,
	A13_MARK___3 = 1400,
	SCK5_A_MARK___3 = 1401,
	MSIOF2_SCK_B_MARK___3 = 1402,
	VI4_DATA14_MARK___3 = 1403,
	HRX4_D_MARK = 1404,
	DU_DB2_MARK___3 = 1405,
	LCDOUT2_MARK___3 = 1406,
	IP5_19_16_MARK___3 = 1407,
	WE0_N_MARK___3 = 1408,
	SDA5_MARK___3 = 1409,
	DU_DR1_MARK___3 = 1410,
	VI4_DATA3_B_MARK___3 = 1411,
	LCDOUT17_MARK___3 = 1412,
	IP6_19_16_MARK___3 = 1413,
	D7_MARK___3 = 1414,
	CANFD1_RX_MARK___3 = 1415,
	IRQ5_MARK___3 = 1416,
	CAN1_RX_MARK___3 = 1417,
	CTS3_N_A_MARK = 1418,
	VI5_DATA2_B_MARK = 1419,
	IP7_19_16_MARK___3 = 1420,
	D15_MARK___3 = 1421,
	MSIOF2_SS1_A_MARK___3 = 1422,
	HTX3_A_MARK___3 = 1423,
	MSIOF3_SS1_A_MARK___3 = 1424,
	DU_DG3_MARK___3 = 1425,
	LCDOUT11_MARK___3 = 1426,
	IP4_23_20_MARK___3 = 1427,
	A14_MARK___3 = 1428,
	MSIOF1_SS1_MARK = 1429,
	MSIOF2_RXD_B_MARK___3 = 1430,
	VI4_DATA15_MARK___3 = 1431,
	HTX4_D_MARK = 1432,
	DU_DB3_MARK___3 = 1433,
	LCDOUT3_MARK___3 = 1434,
	IP5_23_20_MARK___3 = 1435,
	D0_MARK___3 = 1436,
	MSIOF3_SCK_A_MARK___3 = 1437,
	DU_DR2_MARK___3 = 1438,
	CTS4_N_C_MARK___3 = 1439,
	LCDOUT18_MARK___3 = 1440,
	IP6_23_20_MARK___3 = 1441,
	D8_MARK___3 = 1442,
	MSIOF2_SCK_A_MARK___3 = 1443,
	SCK4_B_MARK___3 = 1444,
	VI5_DATA12_A_MARK = 1445,
	DU_DR7_MARK___3 = 1446,
	RIF3_CLK_B_MARK___3 = 1447,
	HCTS3_N_E_MARK = 1448,
	LCDOUT23_MARK___3 = 1449,
	IP7_23_20_MARK___3 = 1450,
	SCL4_MARK = 1451,
	CS1_N_A26_MARK = 1452,
	DU_DOTCLKIN0_MARK___3 = 1453,
	VI4_DATA6_B_MARK___3 = 1454,
	VI5_DATA6_B_MARK = 1455,
	QCLK_MARK___3 = 1456,
	IP4_27_24_MARK___3 = 1457,
	A15_MARK___3 = 1458,
	MSIOF1_SS2_MARK = 1459,
	MSIOF2_TXD_B_MARK___3 = 1460,
	VI4_DATA18_MARK___3 = 1461,
	VI5_DATA4_A_MARK = 1462,
	DU_DB4_MARK___3 = 1463,
	LCDOUT4_MARK___3 = 1464,
	IP5_27_24_MARK___3 = 1465,
	D1_MARK___3 = 1466,
	MSIOF3_SYNC_A_MARK___3 = 1467,
	SCK3_A_MARK = 1468,
	VI4_DATA23_MARK___3 = 1469,
	VI5_CLKENB_A_MARK = 1470,
	DU_DB7_MARK___3 = 1471,
	RTS4_N_C_MARK___3 = 1472,
	LCDOUT7_MARK___3 = 1473,
	IP6_27_24_MARK___3 = 1474,
	D9_MARK___3 = 1475,
	MSIOF2_SYNC_A_MARK___3 = 1476,
	VI5_DATA10_A_MARK = 1477,
	DU_DG0_MARK___3 = 1478,
	RIF3_SYNC_B_MARK___3 = 1479,
	HRX3_E_MARK = 1480,
	LCDOUT8_MARK___3 = 1481,
	IP7_27_24_MARK___3 = 1482,
	SDA4_MARK = 1483,
	WE1_N_MARK___3 = 1484,
	VI4_DATA7_B_MARK___3 = 1485,
	VI5_DATA7_B_MARK = 1486,
	QPOLB_MARK___3 = 1487,
	IP4_31_28_MARK___3 = 1488,
	A16_MARK___3 = 1489,
	MSIOF1_SYNC_MARK = 1490,
	MSIOF2_SS1_B_MARK___3 = 1491,
	VI4_DATA19_MARK___3 = 1492,
	VI5_DATA5_A_MARK = 1493,
	DU_DB5_MARK___3 = 1494,
	LCDOUT5_MARK___3 = 1495,
	IP5_31_28_MARK___3 = 1496,
	D2_MARK___3 = 1497,
	MSIOF3_RXD_A_MARK___3 = 1498,
	RX5_C_MARK = 1499,
	VI5_DATA14_A_MARK = 1500,
	DU_DR3_MARK___3 = 1501,
	RX4_C_MARK___3 = 1502,
	LCDOUT19_MARK___3 = 1503,
	IP6_31_28_MARK___3 = 1504,
	D10_MARK___3 = 1505,
	MSIOF2_RXD_A_MARK___3 = 1506,
	VI5_DATA13_A_MARK = 1507,
	DU_DG1_MARK___3 = 1508,
	RIF3_D0_B_MARK___3 = 1509,
	HTX3_E_MARK = 1510,
	LCDOUT9_MARK___3 = 1511,
	IP7_31_28_MARK___3 = 1512,
	SD0_CLK_MARK___3 = 1513,
	NFDATA8_MARK___3 = 1514,
	SCL1_C_MARK = 1515,
	HSCK1_B_MARK___3 = 1516,
	SDA2_E_MARK = 1517,
	FMCLK_B_MARK___3 = 1518,
	IP8_3_0_MARK___3 = 1519,
	SD0_CMD_MARK___3 = 1520,
	NFDATA9_MARK___3 = 1521,
	HRX1_B_MARK___3 = 1522,
	SPEEDIN_B_MARK___3 = 1523,
	IP9_3_0_MARK___3 = 1524,
	SD1_DAT1_MARK___3 = 1525,
	NFCE_N_B_MARK___3 = 1526,
	IP10_3_0_MARK___3 = 1527,
	SD3_DAT3_MARK___3 = 1528,
	NFDATA3_MARK___3 = 1529,
	IP11_3_0_MARK___3 = 1530,
	SD1_CD_MARK___3 = 1531,
	NFCE_N_A_MARK___3 = 1532,
	SSI_SCK1_MARK = 1533,
	RIF0_D1_B_MARK___3 = 1534,
	TS_SDEN0_MARK = 1535,
	IP8_7_4_MARK___3 = 1536,
	SD0_DAT0_MARK___3 = 1537,
	NFDATA10_MARK___3 = 1538,
	HTX1_B_MARK___3 = 1539,
	REMOCON_B_MARK___3 = 1540,
	IP9_7_4_MARK___3 = 1541,
	SD1_DAT2_MARK___3 = 1542,
	NFALE_B_MARK = 1543,
	IP10_7_4_MARK___3 = 1544,
	SD3_DAT4_MARK___3 = 1545,
	NFDATA4_MARK___3 = 1546,
	IP11_7_4_MARK___3 = 1547,
	SD1_WP_MARK___3 = 1548,
	NFWP_N_A_MARK___3 = 1549,
	SSI_WS1_MARK = 1550,
	RIF0_SYNC_B_MARK___3 = 1551,
	TS_SPSYNC0_MARK = 1552,
	IP8_11_8_MARK___3 = 1553,
	SD0_DAT1_MARK___3 = 1554,
	NFDATA11_MARK___3 = 1555,
	SDA2_C_MARK = 1556,
	HCTS1_N_B_MARK___3 = 1557,
	FMIN_B_MARK___3 = 1558,
	IP9_11_8_MARK___3 = 1559,
	SD1_DAT3_MARK___3 = 1560,
	NFRB_N_B_MARK___3 = 1561,
	IP10_11_8_MARK___3 = 1562,
	SD3_DAT5_MARK___3 = 1563,
	NFDATA5_MARK___3 = 1564,
	IP11_11_8_MARK___3 = 1565,
	RX0_A_MARK = 1566,
	HRX1_A_MARK___3 = 1567,
	SSI_SCK2_A_MARK___3 = 1568,
	RIF1_SYNC_MARK = 1569,
	TS_SCK1_MARK = 1570,
	IP8_15_12_MARK___3 = 1571,
	SD0_DAT2_MARK___3 = 1572,
	NFDATA12_MARK___3 = 1573,
	SCL2_C_MARK = 1574,
	HRTS1_N_B_MARK___3 = 1575,
	BPFCLK_B_MARK___3 = 1576,
	IP9_15_12_MARK___3 = 1577,
	SD3_CLK_MARK___3 = 1578,
	NFWE_N_MARK___3 = 1579,
	IP10_15_12_MARK___3 = 1580,
	SD3_DAT6_MARK___3 = 1581,
	NFDATA6_MARK___3 = 1582,
	IP11_15_12_MARK___3 = 1583,
	TX0_A_MARK = 1584,
	HTX1_A_MARK___3 = 1585,
	SSI_WS2_A_MARK___3 = 1586,
	RIF1_D0_MARK = 1587,
	TS_SDAT1_MARK = 1588,
	IP8_19_16_MARK___3 = 1589,
	SD0_DAT3_MARK___3 = 1590,
	NFDATA13_MARK___3 = 1591,
	SDA1_C_MARK = 1592,
	SCL2_E_MARK = 1593,
	SPEEDIN_C_MARK = 1594,
	REMOCON_C_MARK = 1595,
	IP9_19_16_MARK___3 = 1596,
	SD3_CMD_MARK___3 = 1597,
	NFRE_N_MARK___3 = 1598,
	IP10_19_16_MARK___3 = 1599,
	SD3_DAT7_MARK___3 = 1600,
	NFDATA7_MARK___3 = 1601,
	IP11_19_16_MARK___3 = 1602,
	CTS0_N_A_MARK = 1603,
	NFDATA14_A_MARK___3 = 1604,
	AUDIO_CLKOUT_A_MARK___3 = 1605,
	RIF1_D1_MARK = 1606,
	SCIF_CLK_A_MARK___3 = 1607,
	FMCLK_A_MARK___3 = 1608,
	IP8_23_20_MARK___3 = 1609,
	SD1_CLK_MARK___3 = 1610,
	NFDATA14_B_MARK___3 = 1611,
	IP9_23_20_MARK___3 = 1612,
	SD3_DAT0_MARK___3 = 1613,
	NFDATA0_MARK___3 = 1614,
	IP10_23_20_MARK___3 = 1615,
	SD3_DS_MARK___3 = 1616,
	NFCLE_MARK___3 = 1617,
	IP11_23_20_MARK___3 = 1618,
	RTS0_N_A_MARK = 1619,
	NFDATA15_A_MARK___3 = 1620,
	AUDIO_CLKOUT1_A_MARK___3 = 1621,
	RIF1_CLK_MARK = 1622,
	SCL2_A_MARK___3 = 1623,
	FMIN_A_MARK___3 = 1624,
	IP8_27_24_MARK___3 = 1625,
	SD1_CMD_MARK___3 = 1626,
	NFDATA15_B_MARK___3 = 1627,
	IP9_27_24_MARK___3 = 1628,
	SD3_DAT1_MARK___3 = 1629,
	NFDATA1_MARK___3 = 1630,
	IP10_27_24_MARK___3 = 1631,
	SD0_CD_MARK___3 = 1632,
	NFALE_A_MARK = 1633,
	SD3_CD_MARK___3 = 1634,
	RIF0_CLK_B_MARK___3 = 1635,
	SCL2_B_MARK___3 = 1636,
	TCLK1_A_MARK___3 = 1637,
	SSI_SCK2_B_MARK___3 = 1638,
	TS_SCK0_MARK = 1639,
	IP11_27_24_MARK___3 = 1640,
	SCK0_A_MARK = 1641,
	HSCK1_A_MARK___3 = 1642,
	USB3HS0_ID_MARK = 1643,
	RTS1_N_MARK___3 = 1644,
	SDA2_A_MARK___3 = 1645,
	FMCLK_C_MARK___3 = 1646,
	USB0_ID_MARK = 1647,
	IP8_31_28_MARK___3 = 1648,
	SD1_DAT0_MARK___3 = 1649,
	NFWP_N_B_MARK___3 = 1650,
	IP9_31_28_MARK___3 = 1651,
	SD3_DAT2_MARK___3 = 1652,
	NFDATA2_MARK___3 = 1653,
	IP10_31_28_MARK___3 = 1654,
	SD0_WP_MARK___3 = 1655,
	NFRB_N_A_MARK___3 = 1656,
	SD3_WP_MARK___3 = 1657,
	RIF0_D0_B_MARK___3 = 1658,
	SDA2_B_MARK___3 = 1659,
	TCLK2_A_MARK___3 = 1660,
	SSI_WS2_B_MARK___3 = 1661,
	TS_SDAT0_MARK = 1662,
	IP11_31_28_MARK___3 = 1663,
	RX1_MARK = 1664,
	HRX2_B_MARK___3 = 1665,
	SSI_SCK9_B_MARK___3 = 1666,
	AUDIO_CLKOUT1_B_MARK___3 = 1667,
	IP12_3_0_MARK___3 = 1668,
	TX1_MARK = 1669,
	HTX2_B_MARK___3 = 1670,
	SSI_WS9_B_MARK___3 = 1671,
	AUDIO_CLKOUT3_B_MARK___3 = 1672,
	IP13_3_0_MARK___3 = 1673,
	MSIOF0_SS1_MARK___3 = 1674,
	HRX2_A_MARK___3 = 1675,
	SSI_SCK4_MARK___3 = 1676,
	HCTS0_N_A_MARK = 1677,
	BPFCLK_C_MARK___3 = 1678,
	SPEEDIN_A_MARK___3 = 1679,
	IP14_3_0_MARK___3 = 1680,
	SSI_SDATA0_MARK___3 = 1681,
	IP15_3_0_MARK___3 = 1682,
	SSI_WS5_MARK___3 = 1683,
	HTX0_B_MARK = 1684,
	USB0_OVC_B_MARK = 1685,
	SDA2_D_MARK = 1686,
	IP12_7_4_MARK___3 = 1687,
	SCK2_A_MARK = 1688,
	HSCK0_A_MARK = 1689,
	AUDIO_CLKB_A_MARK___3 = 1690,
	CTS1_N_MARK___3 = 1691,
	RIF0_CLK_A_MARK___3 = 1692,
	REMOCON_A_MARK___3 = 1693,
	SCIF_CLK_B_MARK___3 = 1694,
	IP13_7_4_MARK___3 = 1695,
	MSIOF0_SS2_MARK___3 = 1696,
	HTX2_A_MARK___3 = 1697,
	SSI_WS4_MARK___3 = 1698,
	HRTS0_N_A_MARK = 1699,
	FMIN_C_MARK___3 = 1700,
	BPFCLK_A_MARK___3 = 1701,
	IP14_7_4_MARK___3 = 1702,
	SSI_SDATA1_MARK = 1703,
	AUDIO_CLKC_B_MARK___3 = 1704,
	PWM0_B_MARK = 1705,
	IP15_7_4_MARK___3 = 1706,
	SSI_SDATA5_MARK___3 = 1707,
	HSCK0_B_MARK = 1708,
	AUDIO_CLKB_C_MARK = 1709,
	TPU0TO0_MARK___3 = 1710,
	IP12_11_8_MARK___3 = 1711,
	TX2_A_MARK___3 = 1712,
	HRX0_A_MARK = 1713,
	AUDIO_CLKOUT2_A_MARK___3 = 1714,
	SCL1_A_MARK___3 = 1715,
	FSO_CFE_0_N_A_MARK = 1716,
	TS_SDEN1_MARK = 1717,
	IP13_11_8_MARK___3 = 1718,
	SSI_SDATA9_MARK = 1719,
	AUDIO_CLKC_A_MARK___3 = 1720,
	SCK1_MARK___3 = 1721,
	IP14_11_8_MARK___3 = 1722,
	SSI_SDATA2_MARK = 1723,
	AUDIO_CLKOUT2_B_MARK___3 = 1724,
	SSI_SCK9_A_MARK___3 = 1725,
	PWM1_B_MARK___3 = 1726,
	IP15_11_8_MARK___3 = 1727,
	SSI_SCK6_MARK___3 = 1728,
	HSCK2_A_MARK___3 = 1729,
	AUDIO_CLKC_C_MARK = 1730,
	TPU0TO1_MARK___3 = 1731,
	FSO_CFE_0_N_B_MARK = 1732,
	SIM0_RST_B_MARK___3 = 1733,
	IP12_15_12_MARK___3 = 1734,
	RX2_A_MARK___3 = 1735,
	HTX0_A_MARK = 1736,
	AUDIO_CLKOUT3_A_MARK___3 = 1737,
	SDA1_A_MARK___3 = 1738,
	FSO_CFE_1_N_A_MARK = 1739,
	TS_SPSYNC1_MARK = 1740,
	IP13_15_12_MARK___3 = 1741,
	MLB_CLK_MARK___3 = 1742,
	RX0_B_MARK = 1743,
	RIF0_D0_A_MARK___3 = 1744,
	SCL1_B_MARK___3 = 1745,
	TCLK1_B_MARK___3 = 1746,
	SIM0_RST_A_MARK___3 = 1747,
	IP14_15_12_MARK___3 = 1748,
	SSI_SCK349_MARK___3 = 1749,
	PWM2_C_MARK = 1750,
	IP15_15_12_MARK___3 = 1751,
	SSI_WS6_MARK___3 = 1752,
	HCTS2_N_A_MARK___3 = 1753,
	AUDIO_CLKOUT2_C_MARK = 1754,
	TPU0TO2_MARK___3 = 1755,
	SDA1_D_MARK = 1756,
	FSO_CFE_1_N_B_MARK = 1757,
	SIM0_D_B_MARK___3 = 1758,
	IP12_19_16_MARK___3 = 1759,
	MSIOF0_SCK_MARK___3 = 1760,
	SSI_SCK78_MARK___3 = 1761,
	IP13_19_16_MARK___3 = 1762,
	MLB_SIG_MARK___3 = 1763,
	SCK0_B_MARK = 1764,
	RIF0_D1_A_MARK___3 = 1765,
	SDA1_B_MARK___3 = 1766,
	TCLK2_B_MARK___3 = 1767,
	SIM0_D_A_MARK___3 = 1768,
	IP14_19_16_MARK___3 = 1769,
	SSI_WS349_MARK___3 = 1770,
	PWM3_C_MARK = 1771,
	IP15_19_16_MARK___3 = 1772,
	SSI_SDATA6_MARK___3 = 1773,
	HRTS2_N_A_MARK___3 = 1774,
	AUDIO_CLKOUT3_C_MARK = 1775,
	TPU0TO3_MARK___3 = 1776,
	SCL1_D_MARK = 1777,
	FSO_TOE_N_B_MARK = 1778,
	SIM0_CLK_B_MARK___3 = 1779,
	IP12_23_20_MARK___3 = 1780,
	MSIOF0_RXD_MARK___3 = 1781,
	SSI_WS78_MARK___3 = 1782,
	TX2_B_MARK___3 = 1783,
	IP13_23_20_MARK___3 = 1784,
	MLB_DAT_MARK___3 = 1785,
	TX0_B_MARK = 1786,
	RIF0_SYNC_A_MARK___3 = 1787,
	SIM0_CLK_A_MARK___3 = 1788,
	IP14_23_20_MARK___3 = 1789,
	SSI_SDATA3_MARK___3 = 1790,
	AUDIO_CLKOUT1_C_MARK = 1791,
	AUDIO_CLKB_B_MARK___3 = 1792,
	PWM4_B_MARK___3 = 1793,
	IP15_23_20_MARK___3 = 1794,
	AUDIO_CLKA_MARK = 1795,
	IP12_27_24_MARK___3 = 1796,
	MSIOF0_TXD_MARK___3 = 1797,
	SSI_SDATA7_MARK___3 = 1798,
	RX2_B_MARK___3 = 1799,
	IP13_27_24_MARK___3 = 1800,
	SSI_SCK01239_MARK___3 = 1801,
	IP14_27_24_MARK___3 = 1802,
	SSI_SDATA4_MARK___3 = 1803,
	SSI_WS9_A_MARK___3 = 1804,
	PWM5_B_MARK___3 = 1805,
	IP15_27_24_MARK___3 = 1806,
	USB30_PWEN_MARK___3 = 1807,
	USB0_PWEN_A_MARK = 1808,
	IP12_31_28_MARK___3 = 1809,
	MSIOF0_SYNC_MARK___3 = 1810,
	AUDIO_CLKOUT_B_MARK___3 = 1811,
	SSI_SDATA8_MARK___3 = 1812,
	IP13_31_28_MARK___3 = 1813,
	SSI_WS01239_MARK___3 = 1814,
	IP14_31_28_MARK___3 = 1815,
	SSI_SCK5_MARK___3 = 1816,
	HRX0_B_MARK = 1817,
	USB0_PWEN_B_MARK = 1818,
	SCL2_D_MARK = 1819,
	PWM6_B_MARK___3 = 1820,
	IP15_31_28_MARK___3 = 1821,
	USB30_OVC_MARK___3 = 1822,
	USB0_OVC_A_MARK = 1823,
	FSO_TOE_N_A_MARK = 1824,
	SEL_SIMCARD_0_MARK___3 = 1825,
	SEL_SIMCARD_1_MARK___3 = 1826,
	SEL_ADGB_0_MARK___3 = 1827,
	SEL_ADGB_2_MARK = 1828,
	SEL_ADGB_1_MARK___3 = 1829,
	SEL_SSI2_0_MARK___3 = 1830,
	SEL_SSI2_1_MARK___3 = 1831,
	SEL_TIMER_TMU_0_MARK___3 = 1832,
	SEL_TIMER_TMU_1_MARK___3 = 1833,
	SEL_DRIF0_0_MARK___3 = 1834,
	SEL_DRIF0_1_MARK___3 = 1835,
	SEL_USB_20_CH0_0_MARK = 1836,
	SEL_USB_20_CH0_1_MARK = 1837,
	SEL_FM_0_MARK___3 = 1838,
	SEL_FM_2_MARK___3 = 1839,
	SEL_FM_1_MARK___3 = 1840,
	SEL_DRIF2_0_MARK___3 = 1841,
	SEL_DRIF2_1_MARK___3 = 1842,
	SEL_FSO_0_MARK = 1843,
	SEL_FSO_1_MARK = 1844,
	SEL_DRIF3_0_MARK___3 = 1845,
	SEL_DRIF3_1_MARK___3 = 1846,
	SEL_HSCIF0_0_MARK = 1847,
	SEL_HSCIF0_1_MARK = 1848,
	SEL_HSCIF3_0_MARK___3 = 1849,
	SEL_HSCIF3_4_MARK = 1850,
	SEL_HSCIF3_2_MARK___3 = 1851,
	SEL_HSCIF3_1_MARK___3 = 1852,
	SEL_HSCIF3_3_MARK___3 = 1853,
	SEL_HSCIF1_0_MARK___3 = 1854,
	SEL_HSCIF1_1_MARK___3 = 1855,
	SEL_HSCIF2_0_MARK___3 = 1856,
	SEL_HSCIF2_1_MARK___3 = 1857,
	SEL_I2C1_0_MARK___3 = 1858,
	SEL_I2C1_2_MARK = 1859,
	SEL_I2C1_1_MARK___3 = 1860,
	SEL_I2C1_3_MARK = 1861,
	SEL_HSCIF4_0_MARK___3 = 1862,
	SEL_HSCIF4_4_MARK = 1863,
	SEL_HSCIF4_2_MARK = 1864,
	SEL_HSCIF4_1_MARK___3 = 1865,
	SEL_HSCIF4_3_MARK = 1866,
	SEL_I2C2_0_MARK___3 = 1867,
	SEL_I2C2_4_MARK = 1868,
	SEL_I2C2_2_MARK = 1869,
	SEL_I2C2_1_MARK___3 = 1870,
	SEL_I2C2_3_MARK = 1871,
	SEL_I2C6_0_MARK___3 = 1872,
	SEL_I2C6_1_MARK___3 = 1873,
	SEL_I2C7_0_MARK = 1874,
	SEL_I2C7_1_MARK = 1875,
	SEL_NDF_0_MARK___3 = 1876,
	SEL_NDF_1_MARK___3 = 1877,
	SEL_MSIOF2_0_MARK___3 = 1878,
	SEL_MSIOF2_1_MARK___3 = 1879,
	SEL_PWM0_0_MARK = 1880,
	SEL_PWM0_1_MARK = 1881,
	SEL_MSIOF3_0_MARK___3 = 1882,
	SEL_MSIOF3_1_MARK___3 = 1883,
	SEL_PWM1_0_MARK___3 = 1884,
	SEL_PWM1_1_MARK___3 = 1885,
	SEL_SCIF3_0_MARK___3 = 1886,
	SEL_SCIF3_2_MARK = 1887,
	SEL_SCIF3_1_MARK___3 = 1888,
	SEL_PWM2_0_MARK___3 = 1889,
	SEL_PWM2_2_MARK = 1890,
	SEL_PWM2_1_MARK___3 = 1891,
	SEL_SCIF4_0_MARK___3 = 1892,
	SEL_SCIF4_2_MARK___3 = 1893,
	SEL_SCIF4_1_MARK___3 = 1894,
	SEL_PWM3_0_MARK___3 = 1895,
	SEL_PWM3_2_MARK = 1896,
	SEL_PWM3_1_MARK___3 = 1897,
	SEL_SCIF5_0_MARK___3 = 1898,
	SEL_SCIF5_2_MARK = 1899,
	SEL_SCIF5_1_MARK___3 = 1900,
	SEL_PWM4_0_MARK___3 = 1901,
	SEL_PWM4_1_MARK___3 = 1902,
	SEL_PWM5_0_MARK___3 = 1903,
	SEL_PWM5_1_MARK___3 = 1904,
	SEL_VIN4_0_MARK___3 = 1905,
	SEL_VIN4_1_MARK___3 = 1906,
	SEL_PWM6_0_MARK___3 = 1907,
	SEL_PWM6_1_MARK___3 = 1908,
	SEL_VIN5_0_MARK = 1909,
	SEL_VIN5_1_MARK = 1910,
	SEL_REMOCON_0_MARK___3 = 1911,
	SEL_REMOCON_2_MARK = 1912,
	SEL_REMOCON_1_MARK___3 = 1913,
	SEL_ADGC_0_MARK___3 = 1914,
	SEL_ADGC_2_MARK = 1915,
	SEL_ADGC_1_MARK___3 = 1916,
	SEL_SCIF_0_MARK___3 = 1917,
	SEL_SCIF_1_MARK___3 = 1918,
	SEL_SSI9_0_MARK___3 = 1919,
	SEL_SSI9_1_MARK___3 = 1920,
	SEL_SCIF0_0_MARK = 1921,
	SEL_SCIF0_1_MARK = 1922,
	SEL_SCIF2_0_MARK___3 = 1923,
	SEL_SCIF2_1_MARK___3 = 1924,
	SEL_SPEED_PULSE_IF_0_MARK = 1925,
	SEL_SPEED_PULSE_IF_2_MARK = 1926,
	SEL_SPEED_PULSE_IF_1_MARK = 1927,
	AVB_TX_CTL_MARK___3 = 1928,
	AVB_TXC_MARK___3 = 1929,
	AVB_TD0_MARK___3 = 1930,
	AVB_TD1_MARK___3 = 1931,
	AVB_TD2_MARK___3 = 1932,
	AVB_TD3_MARK___3 = 1933,
	PRESETOUT_N_MARK = 1934,
	FSCLKST_N_MARK = 1935,
	TRST_N_MARK = 1936,
	TCK_MARK___3 = 1937,
	TMS_MARK___3 = 1938,
	TDI_MARK___3 = 1939,
	ASEBRK_MARK___3 = 1940,
	MLB_REF_MARK___3 = 1941,
	PINMUX_MARK_END___3 = 1942,
};

enum {
	GP_LAST___3 = 209,
	PIN_ASEBRK___3 = 210,
	PIN_AVB_MDC = 211,
	PIN_AVB_MDIO___3 = 212,
	PIN_AVB_TD0___3 = 213,
	PIN_AVB_TD1___3 = 214,
	PIN_AVB_TD2___3 = 215,
	PIN_AVB_TD3___3 = 216,
	PIN_AVB_TXC___3 = 217,
	PIN_AVB_TX_CTL___3 = 218,
	PIN_FSCLKST_N = 219,
	PIN_MLB_REF___3 = 220,
	PIN_PRESETOUT_N___3 = 221,
	PIN_TCK___3 = 222,
	PIN_TDI___3 = 223,
	PIN_TMS___3 = 224,
	PIN_TRST_N___3 = 225,
};

enum ioctrl_regs___2 {
	POCCTRL0 = 0,
	TDSELCTRL___2 = 1,
};

enum {
	PINMUX_RESERVED___4 = 0,
	PINMUX_DATA_BEGIN___4 = 1,
	GP_0_0_DATA___4 = 2,
	GP_0_1_DATA___4 = 3,
	GP_0_2_DATA___4 = 4,
	GP_0_3_DATA___4 = 5,
	GP_0_4_DATA___4 = 6,
	GP_0_5_DATA___4 = 7,
	GP_0_6_DATA___4 = 8,
	GP_0_7_DATA___4 = 9,
	GP_0_8_DATA___4 = 10,
	GP_0_9_DATA___4 = 11,
	GP_0_10_DATA___4 = 12,
	GP_0_11_DATA___4 = 13,
	GP_0_12_DATA___4 = 14,
	GP_0_13_DATA___4 = 15,
	GP_0_14_DATA___4 = 16,
	GP_0_15_DATA___4 = 17,
	GP_1_0_DATA___4 = 18,
	GP_1_1_DATA___4 = 19,
	GP_1_2_DATA___4 = 20,
	GP_1_3_DATA___4 = 21,
	GP_1_4_DATA___4 = 22,
	GP_1_5_DATA___4 = 23,
	GP_1_6_DATA___4 = 24,
	GP_1_7_DATA___4 = 25,
	GP_1_8_DATA___4 = 26,
	GP_1_9_DATA___4 = 27,
	GP_1_10_DATA___4 = 28,
	GP_1_11_DATA___4 = 29,
	GP_1_12_DATA___4 = 30,
	GP_1_13_DATA___4 = 31,
	GP_1_14_DATA___4 = 32,
	GP_1_15_DATA___4 = 33,
	GP_1_16_DATA___4 = 34,
	GP_1_17_DATA___4 = 35,
	GP_1_18_DATA___4 = 36,
	GP_1_19_DATA___4 = 37,
	GP_1_20_DATA___4 = 38,
	GP_1_21_DATA___4 = 39,
	GP_1_22_DATA___4 = 40,
	GP_1_23_DATA___3 = 41,
	GP_1_24_DATA___3 = 42,
	GP_1_25_DATA___3 = 43,
	GP_1_26_DATA___3 = 44,
	GP_1_27_DATA___3 = 45,
	GP_1_28_DATA___3 = 46,
	GP_2_0_DATA___4 = 47,
	GP_2_1_DATA___4 = 48,
	GP_2_2_DATA___4 = 49,
	GP_2_3_DATA___4 = 50,
	GP_2_4_DATA___4 = 51,
	GP_2_5_DATA___4 = 52,
	GP_2_6_DATA___4 = 53,
	GP_2_7_DATA___4 = 54,
	GP_2_8_DATA___4 = 55,
	GP_2_9_DATA___4 = 56,
	GP_2_10_DATA___4 = 57,
	GP_2_11_DATA___4 = 58,
	GP_2_12_DATA___4 = 59,
	GP_2_13_DATA___4 = 60,
	GP_2_14_DATA___4 = 61,
	GP_3_0_DATA___4 = 62,
	GP_3_1_DATA___4 = 63,
	GP_3_2_DATA___4 = 64,
	GP_3_3_DATA___4 = 65,
	GP_3_4_DATA___4 = 66,
	GP_3_5_DATA___4 = 67,
	GP_3_6_DATA___4 = 68,
	GP_3_7_DATA___4 = 69,
	GP_3_8_DATA___4 = 70,
	GP_3_9_DATA___4 = 71,
	GP_3_10_DATA___4 = 72,
	GP_3_11_DATA___4 = 73,
	GP_3_12_DATA___4 = 74,
	GP_3_13_DATA___4 = 75,
	GP_3_14_DATA___4 = 76,
	GP_3_15_DATA___4 = 77,
	GP_4_0_DATA___4 = 78,
	GP_4_1_DATA___4 = 79,
	GP_4_2_DATA___4 = 80,
	GP_4_3_DATA___4 = 81,
	GP_4_4_DATA___4 = 82,
	GP_4_5_DATA___4 = 83,
	GP_4_6_DATA___4 = 84,
	GP_4_7_DATA___4 = 85,
	GP_4_8_DATA___4 = 86,
	GP_4_9_DATA___4 = 87,
	GP_4_10_DATA___4 = 88,
	GP_4_11_DATA___3 = 89,
	GP_4_12_DATA___3 = 90,
	GP_4_13_DATA___3 = 91,
	GP_4_14_DATA___3 = 92,
	GP_4_15_DATA___3 = 93,
	GP_4_16_DATA___3 = 94,
	GP_4_17_DATA___3 = 95,
	GP_5_0_DATA___4 = 96,
	GP_5_1_DATA___4 = 97,
	GP_5_2_DATA___4 = 98,
	GP_5_3_DATA___4 = 99,
	GP_5_4_DATA___4 = 100,
	GP_5_5_DATA___4 = 101,
	GP_5_6_DATA___4 = 102,
	GP_5_7_DATA___4 = 103,
	GP_5_8_DATA___4 = 104,
	GP_5_9_DATA___4 = 105,
	GP_5_10_DATA___4 = 106,
	GP_5_11_DATA___4 = 107,
	GP_5_12_DATA___4 = 108,
	GP_5_13_DATA___4 = 109,
	GP_5_14_DATA___4 = 110,
	GP_5_15_DATA___4 = 111,
	GP_5_16_DATA___4 = 112,
	GP_5_17_DATA___4 = 113,
	GP_5_18_DATA___4 = 114,
	GP_5_19_DATA___4 = 115,
	GP_5_20_DATA___3 = 116,
	GP_5_21_DATA___3 = 117,
	GP_5_22_DATA___3 = 118,
	GP_5_23_DATA___3 = 119,
	GP_5_24_DATA___3 = 120,
	GP_5_25_DATA___3 = 121,
	GP_6_0_DATA___4 = 122,
	GP_6_1_DATA___4 = 123,
	GP_6_2_DATA___4 = 124,
	GP_6_3_DATA___4 = 125,
	GP_6_4_DATA___4 = 126,
	GP_6_5_DATA___4 = 127,
	GP_6_6_DATA___4 = 128,
	GP_6_7_DATA___4 = 129,
	GP_6_8_DATA___4 = 130,
	GP_6_9_DATA___4 = 131,
	GP_6_10_DATA___4 = 132,
	GP_6_11_DATA___4 = 133,
	GP_6_12_DATA___4 = 134,
	GP_6_13_DATA___4 = 135,
	GP_6_14_DATA___4 = 136,
	GP_6_15_DATA___4 = 137,
	GP_6_16_DATA___4 = 138,
	GP_6_17_DATA___4 = 139,
	GP_6_18_DATA___3 = 140,
	GP_6_19_DATA___3 = 141,
	GP_6_20_DATA___3 = 142,
	GP_6_21_DATA___3 = 143,
	GP_6_22_DATA___3 = 144,
	GP_6_23_DATA___3 = 145,
	GP_6_24_DATA___3 = 146,
	GP_6_25_DATA___3 = 147,
	GP_6_26_DATA___3 = 148,
	GP_6_27_DATA___3 = 149,
	GP_6_28_DATA___3 = 150,
	GP_6_29_DATA___3 = 151,
	GP_6_30_DATA___3 = 152,
	GP_6_31_DATA___3 = 153,
	GP_7_0_DATA___3 = 154,
	GP_7_1_DATA___3 = 155,
	GP_7_2_DATA___3 = 156,
	GP_7_3_DATA___3 = 157,
	PINMUX_DATA_END___4 = 158,
	PINMUX_FUNCTION_BEGIN___4 = 159,
	GP_0_0_FN___4 = 160,
	GP_0_1_FN___4 = 161,
	GP_0_2_FN___4 = 162,
	GP_0_3_FN___4 = 163,
	GP_0_4_FN___4 = 164,
	GP_0_5_FN___4 = 165,
	GP_0_6_FN___4 = 166,
	GP_0_7_FN___4 = 167,
	GP_0_8_FN___4 = 168,
	GP_0_9_FN___4 = 169,
	GP_0_10_FN___4 = 170,
	GP_0_11_FN___4 = 171,
	GP_0_12_FN___4 = 172,
	GP_0_13_FN___4 = 173,
	GP_0_14_FN___4 = 174,
	GP_0_15_FN___4 = 175,
	GP_1_0_FN___4 = 176,
	GP_1_1_FN___4 = 177,
	GP_1_2_FN___4 = 178,
	GP_1_3_FN___4 = 179,
	GP_1_4_FN___4 = 180,
	GP_1_5_FN___4 = 181,
	GP_1_6_FN___4 = 182,
	GP_1_7_FN___4 = 183,
	GP_1_8_FN___4 = 184,
	GP_1_9_FN___4 = 185,
	GP_1_10_FN___4 = 186,
	GP_1_11_FN___4 = 187,
	GP_1_12_FN___4 = 188,
	GP_1_13_FN___4 = 189,
	GP_1_14_FN___4 = 190,
	GP_1_15_FN___4 = 191,
	GP_1_16_FN___4 = 192,
	GP_1_17_FN___4 = 193,
	GP_1_18_FN___4 = 194,
	GP_1_19_FN___4 = 195,
	GP_1_20_FN___4 = 196,
	GP_1_21_FN___4 = 197,
	GP_1_22_FN___4 = 198,
	GP_1_23_FN___3 = 199,
	GP_1_24_FN___3 = 200,
	GP_1_25_FN___3 = 201,
	GP_1_26_FN___3 = 202,
	GP_1_27_FN___3 = 203,
	GP_1_28_FN___3 = 204,
	GP_2_0_FN___4 = 205,
	GP_2_1_FN___4 = 206,
	GP_2_2_FN___4 = 207,
	GP_2_3_FN___4 = 208,
	GP_2_4_FN___4 = 209,
	GP_2_5_FN___4 = 210,
	GP_2_6_FN___4 = 211,
	GP_2_7_FN___4 = 212,
	GP_2_8_FN___4 = 213,
	GP_2_9_FN___4 = 214,
	GP_2_10_FN___4 = 215,
	GP_2_11_FN___4 = 216,
	GP_2_12_FN___4 = 217,
	GP_2_13_FN___4 = 218,
	GP_2_14_FN___4 = 219,
	GP_3_0_FN___4 = 220,
	GP_3_1_FN___4 = 221,
	GP_3_2_FN___4 = 222,
	GP_3_3_FN___4 = 223,
	GP_3_4_FN___4 = 224,
	GP_3_5_FN___4 = 225,
	GP_3_6_FN___4 = 226,
	GP_3_7_FN___4 = 227,
	GP_3_8_FN___4 = 228,
	GP_3_9_FN___4 = 229,
	GP_3_10_FN___4 = 230,
	GP_3_11_FN___4 = 231,
	GP_3_12_FN___4 = 232,
	GP_3_13_FN___4 = 233,
	GP_3_14_FN___4 = 234,
	GP_3_15_FN___4 = 235,
	GP_4_0_FN___4 = 236,
	GP_4_1_FN___4 = 237,
	GP_4_2_FN___4 = 238,
	GP_4_3_FN___4 = 239,
	GP_4_4_FN___4 = 240,
	GP_4_5_FN___4 = 241,
	GP_4_6_FN___4 = 242,
	GP_4_7_FN___4 = 243,
	GP_4_8_FN___4 = 244,
	GP_4_9_FN___4 = 245,
	GP_4_10_FN___4 = 246,
	GP_4_11_FN___3 = 247,
	GP_4_12_FN___3 = 248,
	GP_4_13_FN___3 = 249,
	GP_4_14_FN___3 = 250,
	GP_4_15_FN___3 = 251,
	GP_4_16_FN___3 = 252,
	GP_4_17_FN___3 = 253,
	GP_5_0_FN___4 = 254,
	GP_5_1_FN___4 = 255,
	GP_5_2_FN___4 = 256,
	GP_5_3_FN___4 = 257,
	GP_5_4_FN___4 = 258,
	GP_5_5_FN___4 = 259,
	GP_5_6_FN___4 = 260,
	GP_5_7_FN___4 = 261,
	GP_5_8_FN___4 = 262,
	GP_5_9_FN___4 = 263,
	GP_5_10_FN___4 = 264,
	GP_5_11_FN___4 = 265,
	GP_5_12_FN___4 = 266,
	GP_5_13_FN___4 = 267,
	GP_5_14_FN___4 = 268,
	GP_5_15_FN___4 = 269,
	GP_5_16_FN___4 = 270,
	GP_5_17_FN___4 = 271,
	GP_5_18_FN___4 = 272,
	GP_5_19_FN___4 = 273,
	GP_5_20_FN___3 = 274,
	GP_5_21_FN___3 = 275,
	GP_5_22_FN___3 = 276,
	GP_5_23_FN___3 = 277,
	GP_5_24_FN___3 = 278,
	GP_5_25_FN___3 = 279,
	GP_6_0_FN___4 = 280,
	GP_6_1_FN___4 = 281,
	GP_6_2_FN___4 = 282,
	GP_6_3_FN___4 = 283,
	GP_6_4_FN___4 = 284,
	GP_6_5_FN___4 = 285,
	GP_6_6_FN___4 = 286,
	GP_6_7_FN___4 = 287,
	GP_6_8_FN___4 = 288,
	GP_6_9_FN___4 = 289,
	GP_6_10_FN___4 = 290,
	GP_6_11_FN___4 = 291,
	GP_6_12_FN___4 = 292,
	GP_6_13_FN___4 = 293,
	GP_6_14_FN___4 = 294,
	GP_6_15_FN___4 = 295,
	GP_6_16_FN___4 = 296,
	GP_6_17_FN___4 = 297,
	GP_6_18_FN___3 = 298,
	GP_6_19_FN___3 = 299,
	GP_6_20_FN___3 = 300,
	GP_6_21_FN___3 = 301,
	GP_6_22_FN___3 = 302,
	GP_6_23_FN___3 = 303,
	GP_6_24_FN___3 = 304,
	GP_6_25_FN___3 = 305,
	GP_6_26_FN___3 = 306,
	GP_6_27_FN___3 = 307,
	GP_6_28_FN___3 = 308,
	GP_6_29_FN___3 = 309,
	GP_6_30_FN___3 = 310,
	GP_6_31_FN___3 = 311,
	GP_7_0_FN___3 = 312,
	GP_7_1_FN___3 = 313,
	GP_7_2_FN___3 = 314,
	GP_7_3_FN___3 = 315,
	FN_CLKOUT___4 = 316,
	FN_MSIOF0_RXD___4 = 317,
	FN_MSIOF0_TXD___4 = 318,
	FN_MSIOF0_SCK___4 = 319,
	FN_SSI_SDATA5___4 = 320,
	FN_SSI_WS5___4 = 321,
	FN_SSI_SCK5___4 = 322,
	FN_GP7_03___3 = 323,
	FN_GP7_02___3 = 324,
	FN_AVS2___3 = 325,
	FN_AVS1___3 = 326,
	FN_IP0_3_0___4 = 327,
	FN_AVB_MDC___4 = 328,
	FN_MSIOF2_SS2_C___3 = 329,
	FN_IP1_3_0___4 = 330,
	FN_IRQ2___4 = 331,
	FN_QCPV_QDE___4 = 332,
	FN_DU_EXODDF_DU_ODDF_DISP_CDE___3 = 333,
	FN_VI4_DATA2_B___4 = 334,
	FN_MSIOF3_SYNC_E___3 = 335,
	FN_PWM3_B___4 = 336,
	FN_IP2_3_0___4 = 337,
	FN_A1___4 = 338,
	FN_LCDOUT17___4 = 339,
	FN_MSIOF3_TXD_B___4 = 340,
	FN_VI4_DATA9___4 = 341,
	FN_DU_DB1___4 = 342,
	FN_PWM4_A___4 = 343,
	FN_IP3_3_0___4 = 344,
	FN_A9___4 = 345,
	FN_MSIOF2_SCK_A___4 = 346,
	FN_CTS4_N_B___3 = 347,
	FN_VI5_VSYNC_N___3 = 348,
	FN_IP0_7_4___4 = 349,
	FN_AVB_MAGIC___4 = 350,
	FN_MSIOF2_SS1_C___3 = 351,
	FN_SCK4_A___4 = 352,
	FN_IP1_7_4___4 = 353,
	FN_IRQ3___4 = 354,
	FN_QSTVB_QVE___4 = 355,
	FN_DU_DOTCLKOUT1___3 = 356,
	FN_VI4_DATA3_B___4 = 357,
	FN_MSIOF3_SCK_E___3 = 358,
	FN_PWM4_B___4 = 359,
	FN_IP2_7_4___4 = 360,
	FN_A2___4 = 361,
	FN_LCDOUT18___4 = 362,
	FN_MSIOF3_SCK_B___4 = 363,
	FN_VI4_DATA10___4 = 364,
	FN_DU_DB2___4 = 365,
	FN_PWM5_A___4 = 366,
	FN_IP3_7_4___4 = 367,
	FN_A10___4 = 368,
	FN_MSIOF2_RXD_A___4 = 369,
	FN_RTS4_N_B___3 = 370,
	FN_VI5_HSYNC_N___3 = 371,
	FN_IP0_11_8___4 = 372,
	FN_AVB_PHY_INT___4 = 373,
	FN_MSIOF2_SYNC_C___3 = 374,
	FN_RX4_A___4 = 375,
	FN_IP1_11_8___4 = 376,
	FN_IRQ4___4 = 377,
	FN_QSTH_QHS___4 = 378,
	FN_DU_EXHSYNC_DU_HSYNC___3 = 379,
	FN_VI4_DATA4_B___4 = 380,
	FN_MSIOF3_RXD_E___3 = 381,
	FN_PWM5_B___4 = 382,
	FN_IP2_11_8___4 = 383,
	FN_A3___4 = 384,
	FN_LCDOUT19___4 = 385,
	FN_MSIOF3_RXD_B___4 = 386,
	FN_VI4_DATA11___4 = 387,
	FN_DU_DB3___4 = 388,
	FN_PWM6_A___4 = 389,
	FN_IP3_11_8___4 = 390,
	FN_A11___4 = 391,
	FN_TX3_B___4 = 392,
	FN_MSIOF2_TXD_A___4 = 393,
	FN_HTX4_B___4 = 394,
	FN_HSCK4___3 = 395,
	FN_VI5_FIELD___3 = 396,
	FN_SCL6_A___4 = 397,
	FN_AVB_AVTP_CAPTURE_B___3 = 398,
	FN_PWM2_B___4 = 399,
	FN_IP0_15_12___4 = 400,
	FN_AVB_LINK___4 = 401,
	FN_MSIOF2_SCK_C___3 = 402,
	FN_TX4_A___4 = 403,
	FN_IP1_15_12___4 = 404,
	FN_IRQ5___4 = 405,
	FN_QSTB_QHE___4 = 406,
	FN_DU_EXVSYNC_DU_VSYNC___3 = 407,
	FN_VI4_DATA5_B___4 = 408,
	FN_FSCLKST2_N_B___3 = 409,
	FN_MSIOF3_TXD_E___3 = 410,
	FN_PWM6_B___4 = 411,
	FN_IP2_15_12___4 = 412,
	FN_A4___4 = 413,
	FN_LCDOUT20___4 = 414,
	FN_MSIOF3_SS1_B___4 = 415,
	FN_VI4_DATA12___4 = 416,
	FN_VI5_DATA12___3 = 417,
	FN_DU_DB4___4 = 418,
	FN_IP3_15_12___4 = 419,
	FN_A12___4 = 420,
	FN_LCDOUT12___4 = 421,
	FN_MSIOF3_SCK_C___3 = 422,
	FN_HRX4_A___4 = 423,
	FN_VI5_DATA8___3 = 424,
	FN_DU_DG4___4 = 425,
	FN_IP0_19_16___4 = 426,
	FN_AVB_AVTP_MATCH_A___3 = 427,
	FN_MSIOF2_RXD_C___3 = 428,
	FN_CTS4_N_A___4 = 429,
	FN_FSCLKST2_N_A___3 = 430,
	FN_IP1_19_16___4 = 431,
	FN_PWM0___3 = 432,
	FN_AVB_AVTP_PPS___4 = 433,
	FN_VI4_DATA6_B___4 = 434,
	FN_IECLK_B___3 = 435,
	FN_IP2_19_16___4 = 436,
	FN_A5___4 = 437,
	FN_LCDOUT21___4 = 438,
	FN_MSIOF3_SS2_B___3 = 439,
	FN_SCK4_B___4 = 440,
	FN_VI4_DATA13___4 = 441,
	FN_VI5_DATA13___3 = 442,
	FN_DU_DB5___4 = 443,
	FN_IP3_19_16___4 = 444,
	FN_A13___4 = 445,
	FN_LCDOUT13___4 = 446,
	FN_MSIOF3_SYNC_C___3 = 447,
	FN_HTX4_A___4 = 448,
	FN_VI5_DATA9___3 = 449,
	FN_DU_DG5___4 = 450,
	FN_IP0_23_20___4 = 451,
	FN_AVB_AVTP_CAPTURE_A___3 = 452,
	FN_MSIOF2_TXD_C___3 = 453,
	FN_RTS4_N_A___4 = 454,
	FN_IP1_23_20___4 = 455,
	FN_PWM1_A___4 = 456,
	FN_HRX3_D___4 = 457,
	FN_VI4_DATA7_B___4 = 458,
	FN_IERX_B___3 = 459,
	FN_IP2_23_20___4 = 460,
	FN_A6___4 = 461,
	FN_LCDOUT22___4 = 462,
	FN_MSIOF2_SS1_A___4 = 463,
	FN_RX4_B___4 = 464,
	FN_VI4_DATA14___4 = 465,
	FN_VI5_DATA14___3 = 466,
	FN_DU_DB6___4 = 467,
	FN_IP3_23_20___4 = 468,
	FN_A14___4 = 469,
	FN_LCDOUT14___4 = 470,
	FN_MSIOF3_RXD_C___3 = 471,
	FN_HCTS4_N___3 = 472,
	FN_VI5_DATA10___3 = 473,
	FN_DU_DG6___4 = 474,
	FN_IP0_27_24___4 = 475,
	FN_IRQ0___4 = 476,
	FN_QPOLB___4 = 477,
	FN_DU_CDE___4 = 478,
	FN_VI4_DATA0_B___4 = 479,
	FN_CAN0_TX_B___3 = 480,
	FN_CANFD0_TX_B___3 = 481,
	FN_MSIOF3_SS2_E___3 = 482,
	FN_IP1_27_24___4 = 483,
	FN_PWM2_A___4 = 484,
	FN_HTX3_D___4 = 485,
	FN_IETX_B___3 = 486,
	FN_IP2_27_24___4 = 487,
	FN_A7___4 = 488,
	FN_LCDOUT23___4 = 489,
	FN_MSIOF2_SS2_A___4 = 490,
	FN_TX4_B___4 = 491,
	FN_VI4_DATA15___4 = 492,
	FN_VI5_DATA15___3 = 493,
	FN_DU_DB7___4 = 494,
	FN_IP3_27_24___4 = 495,
	FN_A15___4 = 496,
	FN_LCDOUT15___4 = 497,
	FN_MSIOF3_TXD_C___3 = 498,
	FN_HRTS4_N___3 = 499,
	FN_VI5_DATA11___3 = 500,
	FN_DU_DG7___4 = 501,
	FN_IP0_31_28___4 = 502,
	FN_IRQ1___4 = 503,
	FN_QPOLA___4 = 504,
	FN_DU_DISP___4 = 505,
	FN_VI4_DATA1_B___4 = 506,
	FN_CAN0_RX_B___3 = 507,
	FN_CANFD0_RX_B___3 = 508,
	FN_MSIOF3_SS1_E___3 = 509,
	FN_IP1_31_28___4 = 510,
	FN_A0___4 = 511,
	FN_LCDOUT16___4 = 512,
	FN_MSIOF3_SYNC_B___4 = 513,
	FN_VI4_DATA8___4 = 514,
	FN_DU_DB0___4 = 515,
	FN_PWM3_A___4 = 516,
	FN_IP2_31_28___4 = 517,
	FN_A8___4 = 518,
	FN_RX3_B___4 = 519,
	FN_MSIOF2_SYNC_A___4 = 520,
	FN_HRX4_B___4 = 521,
	FN_SDA6_A___4 = 522,
	FN_AVB_AVTP_MATCH_B___3 = 523,
	FN_PWM1_B___4 = 524,
	FN_IP3_31_28___4 = 525,
	FN_A16___4 = 526,
	FN_LCDOUT8___4 = 527,
	FN_VI4_FIELD___4 = 528,
	FN_DU_DG0___4 = 529,
	FN_IP4_3_0___4 = 530,
	FN_A17___4 = 531,
	FN_LCDOUT9___4 = 532,
	FN_VI4_VSYNC_N___4 = 533,
	FN_DU_DG1___4 = 534,
	FN_IP5_3_0___4 = 535,
	FN_WE0_N___4 = 536,
	FN_MSIOF3_TXD_D___3 = 537,
	FN_CTS3_N___3 = 538,
	FN_HCTS3_N___3 = 539,
	FN_SCL6_B___4 = 540,
	FN_CAN_CLK___4 = 541,
	FN_IECLK_A___3 = 542,
	FN_IP6_3_0___4 = 543,
	FN_D5___4 = 544,
	FN_MSIOF2_SYNC_B___4 = 545,
	FN_VI4_DATA21___4 = 546,
	FN_VI5_DATA5___3 = 547,
	FN_IP7_3_0___4 = 548,
	FN_D13___4 = 549,
	FN_LCDOUT5___4 = 550,
	FN_MSIOF2_SS2_D___3 = 551,
	FN_TX4_C___4 = 552,
	FN_VI4_DATA5_A___4 = 553,
	FN_DU_DR5___4 = 554,
	FN_IP4_7_4___4 = 555,
	FN_A18___4 = 556,
	FN_LCDOUT10___4 = 557,
	FN_VI4_HSYNC_N___4 = 558,
	FN_DU_DG2___4 = 559,
	FN_IP5_7_4___4 = 560,
	FN_WE1_N___4 = 561,
	FN_MSIOF3_SS1_D___3 = 562,
	FN_RTS3_N___3 = 563,
	FN_HRTS3_N___3 = 564,
	FN_SDA6_B___4 = 565,
	FN_CAN1_RX___4 = 566,
	FN_CANFD1_RX___4 = 567,
	FN_IERX_A___3 = 568,
	FN_IP6_7_4___4 = 569,
	FN_D6___4 = 570,
	FN_MSIOF2_RXD_B___4 = 571,
	FN_VI4_DATA22___4 = 572,
	FN_VI5_DATA6___3 = 573,
	FN_IP7_7_4___4 = 574,
	FN_D14___4 = 575,
	FN_LCDOUT6___4 = 576,
	FN_MSIOF3_SS1_A___4 = 577,
	FN_HRX3_C___4 = 578,
	FN_VI4_DATA6_A___4 = 579,
	FN_DU_DR6___4 = 580,
	FN_SCL6_C___3 = 581,
	FN_IP4_11_8___4 = 582,
	FN_A19___4 = 583,
	FN_LCDOUT11___4 = 584,
	FN_VI4_CLKENB___4 = 585,
	FN_DU_DG3___4 = 586,
	FN_IP5_11_8___4 = 587,
	FN_EX_WAIT0_A___3 = 588,
	FN_QCLK___4 = 589,
	FN_VI4_CLK___4 = 590,
	FN_DU_DOTCLKOUT0___4 = 591,
	FN_IP6_11_8___4 = 592,
	FN_D7___4 = 593,
	FN_MSIOF2_TXD_B___4 = 594,
	FN_VI4_DATA23___4 = 595,
	FN_VI5_DATA7___3 = 596,
	FN_IP7_11_8___4 = 597,
	FN_D15___4 = 598,
	FN_LCDOUT7___4 = 599,
	FN_MSIOF3_SS2_A___4 = 600,
	FN_HTX3_C___4 = 601,
	FN_VI4_DATA7_A___4 = 602,
	FN_DU_DR7___4 = 603,
	FN_SDA6_C___3 = 604,
	FN_IP4_15_12___4 = 605,
	FN_CS0_N___4 = 606,
	FN_VI5_CLKENB___3 = 607,
	FN_IP5_15_12___4 = 608,
	FN_D0___4 = 609,
	FN_MSIOF2_SS1_B___4 = 610,
	FN_MSIOF3_SCK_A___4 = 611,
	FN_VI4_DATA16___4 = 612,
	FN_VI5_DATA0___3 = 613,
	FN_IP6_15_12___4 = 614,
	FN_D8___4 = 615,
	FN_LCDOUT0___4 = 616,
	FN_MSIOF2_SCK_D___3 = 617,
	FN_SCK4_C___3 = 618,
	FN_VI4_DATA0_A___4 = 619,
	FN_DU_DR0___4 = 620,
	FN_IP4_19_16___4 = 621,
	FN_CS1_N___3 = 622,
	FN_VI5_CLK___3 = 623,
	FN_EX_WAIT0_B___3 = 624,
	FN_IP5_19_16___4 = 625,
	FN_D1___4 = 626,
	FN_MSIOF2_SS2_B___4 = 627,
	FN_MSIOF3_SYNC_A___4 = 628,
	FN_VI4_DATA17___4 = 629,
	FN_VI5_DATA1___3 = 630,
	FN_IP6_19_16___4 = 631,
	FN_D9___4 = 632,
	FN_LCDOUT1___4 = 633,
	FN_MSIOF2_SYNC_D___3 = 634,
	FN_VI4_DATA1_A___4 = 635,
	FN_DU_DR1___4 = 636,
	FN_IP7_19_16___4 = 637,
	FN_SD0_CLK___4 = 638,
	FN_MSIOF1_SCK_E___3 = 639,
	FN_STP_OPWM_0_B___3 = 640,
	FN_IP4_23_20___4 = 641,
	FN_BS_N___4 = 642,
	FN_QSTVA_QVS___4 = 643,
	FN_MSIOF3_SCK_D___3 = 644,
	FN_SCK3___3 = 645,
	FN_HSCK3___3 = 646,
	FN_CAN1_TX___4 = 647,
	FN_CANFD1_TX___4 = 648,
	FN_IETX_A___3 = 649,
	FN_IP5_23_20___4 = 650,
	FN_D2___4 = 651,
	FN_MSIOF3_RXD_A___4 = 652,
	FN_VI4_DATA18___4 = 653,
	FN_VI5_DATA2___3 = 654,
	FN_IP6_23_20___4 = 655,
	FN_D10___4 = 656,
	FN_LCDOUT2___4 = 657,
	FN_MSIOF2_RXD_D___3 = 658,
	FN_HRX3_B___4 = 659,
	FN_VI4_DATA2_A___4 = 660,
	FN_CTS4_N_C___4 = 661,
	FN_DU_DR2___4 = 662,
	FN_IP7_23_20___4 = 663,
	FN_SD0_CMD___4 = 664,
	FN_MSIOF1_SYNC_E___3 = 665,
	FN_STP_IVCXO27_0_B___3 = 666,
	FN_IP4_27_24___4 = 667,
	FN_RD_N___4 = 668,
	FN_MSIOF3_SYNC_D___3 = 669,
	FN_RX3_A___4 = 670,
	FN_HRX3_A___4 = 671,
	FN_CAN0_TX_A___3 = 672,
	FN_CANFD0_TX_A___3 = 673,
	FN_IP5_27_24___4 = 674,
	FN_D3___4 = 675,
	FN_MSIOF3_TXD_A___4 = 676,
	FN_VI4_DATA19___4 = 677,
	FN_VI5_DATA3___3 = 678,
	FN_IP6_27_24___4 = 679,
	FN_D11___4 = 680,
	FN_LCDOUT3___4 = 681,
	FN_MSIOF2_TXD_D___3 = 682,
	FN_HTX3_B___4 = 683,
	FN_VI4_DATA3_A___4 = 684,
	FN_RTS4_N_C___4 = 685,
	FN_DU_DR3___4 = 686,
	FN_IP7_27_24___4 = 687,
	FN_SD0_DAT0___4 = 688,
	FN_MSIOF1_RXD_E___3 = 689,
	FN_TS_SCK0_B___3 = 690,
	FN_STP_ISCLK_0_B___3 = 691,
	FN_IP4_31_28___4 = 692,
	FN_RD_WR_N___4 = 693,
	FN_MSIOF3_RXD_D___3 = 694,
	FN_TX3_A___4 = 695,
	FN_HTX3_A___4 = 696,
	FN_CAN0_RX_A___3 = 697,
	FN_CANFD0_RX_A___3 = 698,
	FN_IP5_31_28___4 = 699,
	FN_D4___4 = 700,
	FN_MSIOF2_SCK_B___4 = 701,
	FN_VI4_DATA20___4 = 702,
	FN_VI5_DATA4___3 = 703,
	FN_IP6_31_28___4 = 704,
	FN_D12___4 = 705,
	FN_LCDOUT4___4 = 706,
	FN_MSIOF2_SS1_D___3 = 707,
	FN_RX4_C___4 = 708,
	FN_VI4_DATA4_A___4 = 709,
	FN_DU_DR4___4 = 710,
	FN_IP7_31_28___4 = 711,
	FN_SD0_DAT1___4 = 712,
	FN_MSIOF1_TXD_E___3 = 713,
	FN_TS_SPSYNC0_B___3 = 714,
	FN_STP_ISSYNC_0_B___3 = 715,
	FN_IP8_3_0___4 = 716,
	FN_SD0_DAT2___4 = 717,
	FN_MSIOF1_SS1_E___3 = 718,
	FN_TS_SDAT0_B___3 = 719,
	FN_STP_ISD_0_B___3 = 720,
	FN_IP9_3_0___4 = 721,
	FN_SD2_CLK___3 = 722,
	FN_NFDATA8___4 = 723,
	FN_IP10_3_0___4 = 724,
	FN_SD3_CMD___4 = 725,
	FN_NFRE_N___4 = 726,
	FN_IP11_3_0___4 = 727,
	FN_SD3_DAT7___4 = 728,
	FN_SD3_WP___4 = 729,
	FN_NFDATA7___4 = 730,
	FN_IP8_7_4___4 = 731,
	FN_SD0_DAT3___4 = 732,
	FN_MSIOF1_SS2_E___3 = 733,
	FN_TS_SDEN0_B___3 = 734,
	FN_STP_ISEN_0_B___3 = 735,
	FN_IP9_7_4___4 = 736,
	FN_SD2_CMD___3 = 737,
	FN_NFDATA9___4 = 738,
	FN_IP10_7_4___4 = 739,
	FN_SD3_DAT0___4 = 740,
	FN_NFDATA0___4 = 741,
	FN_IP11_7_4___4 = 742,
	FN_SD3_DS___4 = 743,
	FN_NFCLE___4 = 744,
	FN_IP8_11_8___4 = 745,
	FN_SD1_CLK___4 = 746,
	FN_MSIOF1_SCK_G___3 = 747,
	FN_SIM0_CLK_A___4 = 748,
	FN_IP9_11_8___4 = 749,
	FN_SD2_DAT0___3 = 750,
	FN_NFDATA10___4 = 751,
	FN_IP10_11_8___4 = 752,
	FN_SD3_DAT1___4 = 753,
	FN_NFDATA1___4 = 754,
	FN_IP11_11_8___4 = 755,
	FN_SD0_CD___4 = 756,
	FN_NFDATA14_A___4 = 757,
	FN_SCL2_B___4 = 758,
	FN_SIM0_RST_A___4 = 759,
	FN_IP8_15_12___4 = 760,
	FN_SD1_CMD___4 = 761,
	FN_MSIOF1_SYNC_G___3 = 762,
	FN_NFCE_N_B___4 = 763,
	FN_SIM0_D_A___4 = 764,
	FN_STP_IVCXO27_1_B___3 = 765,
	FN_IP9_15_12___4 = 766,
	FN_SD2_DAT1___3 = 767,
	FN_NFDATA11___4 = 768,
	FN_IP10_15_12___4 = 769,
	FN_SD3_DAT2___4 = 770,
	FN_NFDATA2___4 = 771,
	FN_IP11_15_12___4 = 772,
	FN_SD0_WP___4 = 773,
	FN_NFDATA15_A___4 = 774,
	FN_SDA2_B___4 = 775,
	FN_IP8_19_16___4 = 776,
	FN_SD1_DAT0___4 = 777,
	FN_SD2_DAT4___3 = 778,
	FN_MSIOF1_RXD_G___3 = 779,
	FN_NFWP_N_B___4 = 780,
	FN_TS_SCK1_B___3 = 781,
	FN_STP_ISCLK_1_B___3 = 782,
	FN_IP9_19_16___4 = 783,
	FN_SD2_DAT2___3 = 784,
	FN_NFDATA12___4 = 785,
	FN_IP10_19_16___4 = 786,
	FN_SD3_DAT3___4 = 787,
	FN_NFDATA3___4 = 788,
	FN_IP11_19_16___4 = 789,
	FN_SD1_CD___4 = 790,
	FN_NFRB_N_A___4 = 791,
	FN_SIM0_CLK_B___4 = 792,
	FN_IP8_23_20___4 = 793,
	FN_SD1_DAT1___4 = 794,
	FN_SD2_DAT5___3 = 795,
	FN_MSIOF1_TXD_G___3 = 796,
	FN_NFDATA14_B___4 = 797,
	FN_TS_SPSYNC1_B___3 = 798,
	FN_STP_ISSYNC_1_B___3 = 799,
	FN_IP9_23_20___4 = 800,
	FN_SD2_DAT3___3 = 801,
	FN_NFDATA13___4 = 802,
	FN_IP10_23_20___4 = 803,
	FN_SD3_DAT4___4 = 804,
	FN_SD2_CD_A___3 = 805,
	FN_NFDATA4___4 = 806,
	FN_IP11_23_20___4 = 807,
	FN_SD1_WP___4 = 808,
	FN_NFCE_N_A___4 = 809,
	FN_SIM0_D_B___4 = 810,
	FN_IP8_27_24___4 = 811,
	FN_SD1_DAT2___4 = 812,
	FN_SD2_DAT6___3 = 813,
	FN_MSIOF1_SS1_G___3 = 814,
	FN_NFDATA15_B___4 = 815,
	FN_TS_SDAT1_B___3 = 816,
	FN_STP_ISD_1_B___3 = 817,
	FN_IP9_27_24___4 = 818,
	FN_SD2_DS___3 = 819,
	FN_NFALE___3 = 820,
	FN_SATA_DEVSLP_B___2 = 821,
	FN_IP10_27_24___4 = 822,
	FN_SD3_DAT5___4 = 823,
	FN_SD2_WP_A___3 = 824,
	FN_NFDATA5___4 = 825,
	FN_IP11_27_24___4 = 826,
	FN_SCK0___3 = 827,
	FN_HSCK1_B___4 = 828,
	FN_MSIOF1_SS2_B___3 = 829,
	FN_AUDIO_CLKC_B___4 = 830,
	FN_SDA2_A___4 = 831,
	FN_SIM0_RST_B___4 = 832,
	FN_STP_OPWM_0_C___3 = 833,
	FN_RIF0_CLK_B___4 = 834,
	FN_ADICHS2___3 = 835,
	FN_SCK5_B___3 = 836,
	FN_IP8_31_28___4 = 837,
	FN_SD1_DAT3___4 = 838,
	FN_SD2_DAT7___3 = 839,
	FN_MSIOF1_SS2_G___3 = 840,
	FN_NFRB_N_B___4 = 841,
	FN_TS_SDEN1_B___3 = 842,
	FN_STP_ISEN_1_B___3 = 843,
	FN_IP9_31_28___4 = 844,
	FN_SD3_CLK___4 = 845,
	FN_NFWE_N___4 = 846,
	FN_IP10_31_28___4 = 847,
	FN_SD3_DAT6___4 = 848,
	FN_SD3_CD___4 = 849,
	FN_NFDATA6___4 = 850,
	FN_IP11_31_28___4 = 851,
	FN_RX0___3 = 852,
	FN_HRX1_B___4 = 853,
	FN_TS_SCK0_C___3 = 854,
	FN_STP_ISCLK_0_C___3 = 855,
	FN_RIF0_D0_B___4 = 856,
	FN_IP12_3_0___4 = 857,
	FN_TX0___3 = 858,
	FN_HTX1_B___4 = 859,
	FN_TS_SPSYNC0_C___3 = 860,
	FN_STP_ISSYNC_0_C___3 = 861,
	FN_RIF0_D1_B___4 = 862,
	FN_IP13_3_0___4 = 863,
	FN_TX2_A___4 = 864,
	FN_SD2_CD_B___3 = 865,
	FN_SCL1_A___4 = 866,
	FN_FMCLK_A___4 = 867,
	FN_RIF1_D1_C___3 = 868,
	FN_FSO_CFE_0_N___3 = 869,
	FN_IP14_3_0___4 = 870,
	FN_MSIOF0_SS1___4 = 871,
	FN_RX5_A___4 = 872,
	FN_NFWP_N_A___4 = 873,
	FN_AUDIO_CLKA_C___3 = 874,
	FN_SSI_SCK2_A___4 = 875,
	FN_STP_IVCXO27_0_C___3 = 876,
	FN_AUDIO_CLKOUT3_A___4 = 877,
	FN_TCLK1_B___4 = 878,
	FN_IP15_3_0___4 = 879,
	FN_SSI_SDATA1_A___3 = 880,
	FN_IP12_7_4___4 = 881,
	FN_CTS0_N___3 = 882,
	FN_HCTS1_N_B___4 = 883,
	FN_MSIOF1_SYNC_B___3 = 884,
	FN_TS_SPSYNC1_C___3 = 885,
	FN_STP_ISSYNC_1_C___3 = 886,
	FN_RIF1_SYNC_B___3 = 887,
	FN_AUDIO_CLKOUT_C___3 = 888,
	FN_ADICS_SAMP___3 = 889,
	FN_IP13_7_4___4 = 890,
	FN_RX2_A___4 = 891,
	FN_SD2_WP_B___3 = 892,
	FN_SDA1_A___4 = 893,
	FN_FMIN_A___4 = 894,
	FN_RIF1_SYNC_C___3 = 895,
	FN_FSO_CFE_1_N___3 = 896,
	FN_IP14_7_4___4 = 897,
	FN_MSIOF0_SS2___4 = 898,
	FN_TX5_A___4 = 899,
	FN_MSIOF1_SS2_D___3 = 900,
	FN_AUDIO_CLKC_A___4 = 901,
	FN_SSI_WS2_A___4 = 902,
	FN_STP_OPWM_0_D___3 = 903,
	FN_AUDIO_CLKOUT_D___3 = 904,
	FN_SPEEDIN_B___4 = 905,
	FN_IP15_7_4___4 = 906,
	FN_SSI_SDATA2_A___3 = 907,
	FN_SSI_SCK1_B___3 = 908,
	FN_IP12_11_8___4 = 909,
	FN_RTS0_N___3 = 910,
	FN_HRTS1_N_B___4 = 911,
	FN_MSIOF1_SS1_B___3 = 912,
	FN_AUDIO_CLKA_B___3 = 913,
	FN_SCL2_A___4 = 914,
	FN_STP_IVCXO27_1_C___3 = 915,
	FN_RIF0_SYNC_B___4 = 916,
	FN_ADICHS1___3 = 917,
	FN_IP13_11_8___4 = 918,
	FN_HSCK0___3 = 919,
	FN_MSIOF1_SCK_D___3 = 920,
	FN_AUDIO_CLKB_A___4 = 921,
	FN_SSI_SDATA1_B___3 = 922,
	FN_TS_SCK0_D___3 = 923,
	FN_STP_ISCLK_0_D___3 = 924,
	FN_RIF0_CLK_C___3 = 925,
	FN_RX5_B___4 = 926,
	FN_IP14_11_8___4 = 927,
	FN_MLB_CLK___4 = 928,
	FN_MSIOF1_SCK_F___3 = 929,
	FN_SCL1_B___4 = 930,
	FN_IP15_11_8___4 = 931,
	FN_SSI_SCK349___4 = 932,
	FN_MSIOF1_SS1_A___3 = 933,
	FN_STP_OPWM_0_A___3 = 934,
	FN_IP12_15_12___4 = 935,
	FN_RX1_A___3 = 936,
	FN_HRX1_A___4 = 937,
	FN_TS_SDAT0_C___3 = 938,
	FN_STP_ISD_0_C___3 = 939,
	FN_RIF1_CLK_C___3 = 940,
	FN_IP13_15_12___4 = 941,
	FN_HRX0___3 = 942,
	FN_MSIOF1_RXD_D___3 = 943,
	FN_SSI_SDATA2_B___3 = 944,
	FN_TS_SDEN0_D___3 = 945,
	FN_STP_ISEN_0_D___3 = 946,
	FN_RIF0_D0_C___3 = 947,
	FN_IP14_15_12___4 = 948,
	FN_MLB_SIG___4 = 949,
	FN_RX1_B___3 = 950,
	FN_MSIOF1_SYNC_F___3 = 951,
	FN_SDA1_B___4 = 952,
	FN_IP15_15_12___4 = 953,
	FN_SSI_WS349___4 = 954,
	FN_HCTS2_N_A___4 = 955,
	FN_MSIOF1_SS2_A___3 = 956,
	FN_STP_IVCXO27_0_A___3 = 957,
	FN_IP12_19_16___4 = 958,
	FN_TX1_A___3 = 959,
	FN_HTX1_A___4 = 960,
	FN_TS_SDEN0_C___3 = 961,
	FN_STP_ISEN_0_C___3 = 962,
	FN_RIF1_D0_C___3 = 963,
	FN_IP13_19_16___4 = 964,
	FN_HTX0___3 = 965,
	FN_MSIOF1_TXD_D___3 = 966,
	FN_SSI_SDATA9_B___3 = 967,
	FN_TS_SDAT0_D___3 = 968,
	FN_STP_ISD_0_D___3 = 969,
	FN_RIF0_D1_C___3 = 970,
	FN_IP14_19_16___4 = 971,
	FN_MLB_DAT___4 = 972,
	FN_TX1_B___3 = 973,
	FN_MSIOF1_RXD_F___3 = 974,
	FN_IP15_19_16___4 = 975,
	FN_SSI_SDATA3___4 = 976,
	FN_HRTS2_N_A___4 = 977,
	FN_MSIOF1_TXD_A___3 = 978,
	FN_TS_SCK0_A___3 = 979,
	FN_STP_ISCLK_0_A___3 = 980,
	FN_RIF0_D1_A___4 = 981,
	FN_RIF2_D0_A___4 = 982,
	FN_IP12_23_20___4 = 983,
	FN_CTS1_N___4 = 984,
	FN_HCTS1_N_A___3 = 985,
	FN_MSIOF1_RXD_B___3 = 986,
	FN_TS_SDEN1_C___3 = 987,
	FN_STP_ISEN_1_C___3 = 988,
	FN_RIF1_D0_B___3 = 989,
	FN_ADIDATA___3 = 990,
	FN_IP13_23_20___4 = 991,
	FN_HCTS0_N___3 = 992,
	FN_RX2_B___4 = 993,
	FN_MSIOF1_SYNC_D___3 = 994,
	FN_SSI_SCK9_A___4 = 995,
	FN_TS_SPSYNC0_D___3 = 996,
	FN_STP_ISSYNC_0_D___3 = 997,
	FN_RIF0_SYNC_C___3 = 998,
	FN_AUDIO_CLKOUT1_A___4 = 999,
	FN_IP14_23_20___4 = 1000,
	FN_SSI_SCK01239___4 = 1001,
	FN_MSIOF1_TXD_F___3 = 1002,
	FN_IP15_23_20___4 = 1003,
	FN_SSI_SCK4___4 = 1004,
	FN_HRX2_A___4 = 1005,
	FN_MSIOF1_SCK_A___3 = 1006,
	FN_TS_SDAT0_A___3 = 1007,
	FN_STP_ISD_0_A___3 = 1008,
	FN_RIF0_CLK_A___4 = 1009,
	FN_RIF2_CLK_A___4 = 1010,
	FN_IP12_27_24___4 = 1011,
	FN_RTS1_N___4 = 1012,
	FN_HRTS1_N_A___3 = 1013,
	FN_MSIOF1_TXD_B___3 = 1014,
	FN_TS_SDAT1_C___3 = 1015,
	FN_STP_ISD_1_C___3 = 1016,
	FN_RIF1_D1_B___3 = 1017,
	FN_ADICHS0___3 = 1018,
	FN_IP13_27_24___4 = 1019,
	FN_HRTS0_N___3 = 1020,
	FN_TX2_B___4 = 1021,
	FN_MSIOF1_SS1_D___3 = 1022,
	FN_SSI_WS9_A___4 = 1023,
	FN_STP_IVCXO27_0_D___3 = 1024,
	FN_BPFCLK_A___4 = 1025,
	FN_AUDIO_CLKOUT2_A___4 = 1026,
	FN_IP14_27_24___4 = 1027,
	FN_SSI_WS01239___4 = 1028,
	FN_MSIOF1_SS1_F___3 = 1029,
	FN_IP15_27_24___4 = 1030,
	FN_SSI_WS4___4 = 1031,
	FN_HTX2_A___4 = 1032,
	FN_MSIOF1_SYNC_A___3 = 1033,
	FN_TS_SDEN0_A___3 = 1034,
	FN_STP_ISEN_0_A___3 = 1035,
	FN_RIF0_SYNC_A___4 = 1036,
	FN_RIF2_SYNC_A___4 = 1037,
	FN_IP12_31_28___4 = 1038,
	FN_SCK2___3 = 1039,
	FN_SCIF_CLK_B___4 = 1040,
	FN_MSIOF1_SCK_B___3 = 1041,
	FN_TS_SCK1_C___3 = 1042,
	FN_STP_ISCLK_1_C___3 = 1043,
	FN_RIF1_CLK_B___3 = 1044,
	FN_ADICLK___3 = 1045,
	FN_IP13_31_28___4 = 1046,
	FN_MSIOF0_SYNC___4 = 1047,
	FN_AUDIO_CLKOUT_A___4 = 1048,
	FN_TX5_B___4 = 1049,
	FN_BPFCLK_D___3 = 1050,
	FN_IP14_31_28___4 = 1051,
	FN_SSI_SDATA0___4 = 1052,
	FN_MSIOF1_SS2_F___3 = 1053,
	FN_IP15_31_28___4 = 1054,
	FN_SSI_SDATA4___4 = 1055,
	FN_HSCK2_A___4 = 1056,
	FN_MSIOF1_RXD_A___3 = 1057,
	FN_TS_SPSYNC0_A___3 = 1058,
	FN_STP_ISSYNC_0_A___3 = 1059,
	FN_RIF0_D0_A___4 = 1060,
	FN_RIF2_D1_A___4 = 1061,
	FN_IP16_3_0___3 = 1062,
	FN_SSI_SCK6___4 = 1063,
	FN_USB2_PWEN = 1064,
	FN_SIM0_RST_D___3 = 1065,
	FN_IP17_3_0___3 = 1066,
	FN_AUDIO_CLKA_A___3 = 1067,
	FN_IP18_3_0___3 = 1068,
	FN_USB2_CH3_PWEN = 1069,
	FN_AUDIO_CLKOUT2_B___4 = 1070,
	FN_SSI_SCK9_B___4 = 1071,
	FN_TS_SDEN0_E___3 = 1072,
	FN_STP_ISEN_0_E___3 = 1073,
	FN_RIF2_D0_B___4 = 1074,
	FN_TPU0TO2___4 = 1075,
	FN_FMCLK_C___4 = 1076,
	FN_FMCLK_D___3 = 1077,
	FN_IP16_7_4___3 = 1078,
	FN_SSI_WS6___4 = 1079,
	FN_USB2_OVC = 1080,
	FN_SIM0_D_D___3 = 1081,
	FN_IP17_7_4___3 = 1082,
	FN_AUDIO_CLKB_B___4 = 1083,
	FN_SCIF_CLK_A___4 = 1084,
	FN_STP_IVCXO27_1_D___3 = 1085,
	FN_REMOCON_A___4 = 1086,
	FN_TCLK1_A___4 = 1087,
	FN_IP18_7_4___3 = 1088,
	FN_USB2_CH3_OVC = 1089,
	FN_AUDIO_CLKOUT3_B___4 = 1090,
	FN_SSI_WS9_B___4 = 1091,
	FN_TS_SPSYNC0_E___3 = 1092,
	FN_STP_ISSYNC_0_E___3 = 1093,
	FN_RIF2_D1_B___4 = 1094,
	FN_TPU0TO3___4 = 1095,
	FN_FMIN_C___4 = 1096,
	FN_FMIN_D___3 = 1097,
	FN_IP16_11_8___3 = 1098,
	FN_SSI_SDATA6___4 = 1099,
	FN_SIM0_CLK_D___3 = 1100,
	FN_SATA_DEVSLP_A___2 = 1101,
	FN_IP17_11_8___3 = 1102,
	FN_USB0_PWEN___3 = 1103,
	FN_SIM0_RST_C___3 = 1104,
	FN_TS_SCK1_D___3 = 1105,
	FN_STP_ISCLK_1_D___3 = 1106,
	FN_BPFCLK_B___4 = 1107,
	FN_RIF3_CLK_B___4 = 1108,
	FN_HSCK2_C___3 = 1109,
	FN_IP16_15_12___3 = 1110,
	FN_SSI_SCK78___4 = 1111,
	FN_HRX2_B___4 = 1112,
	FN_MSIOF1_SCK_C___3 = 1113,
	FN_TS_SCK1_A___3 = 1114,
	FN_STP_ISCLK_1_A___3 = 1115,
	FN_RIF1_CLK_A___3 = 1116,
	FN_RIF3_CLK_A___4 = 1117,
	FN_IP17_15_12___3 = 1118,
	FN_USB0_OVC___3 = 1119,
	FN_SIM0_D_C___3 = 1120,
	FN_TS_SDAT1_D___3 = 1121,
	FN_STP_ISD_1_D___3 = 1122,
	FN_RIF3_SYNC_B___4 = 1123,
	FN_HRX2_C___3 = 1124,
	FN_IP16_19_16___3 = 1125,
	FN_SSI_WS78___4 = 1126,
	FN_HTX2_B___4 = 1127,
	FN_MSIOF1_SYNC_C___3 = 1128,
	FN_TS_SDAT1_A___3 = 1129,
	FN_STP_ISD_1_A___3 = 1130,
	FN_RIF1_SYNC_A___3 = 1131,
	FN_RIF3_SYNC_A___4 = 1132,
	FN_IP17_19_16___3 = 1133,
	FN_USB1_PWEN___3 = 1134,
	FN_SIM0_CLK_C___3 = 1135,
	FN_SSI_SCK1_A___3 = 1136,
	FN_TS_SCK0_E___3 = 1137,
	FN_STP_ISCLK_0_E___3 = 1138,
	FN_FMCLK_B___4 = 1139,
	FN_RIF2_CLK_B___4 = 1140,
	FN_SPEEDIN_A___4 = 1141,
	FN_HTX2_C___3 = 1142,
	FN_IP16_23_20___3 = 1143,
	FN_SSI_SDATA7___4 = 1144,
	FN_HCTS2_N_B___3 = 1145,
	FN_MSIOF1_RXD_C___3 = 1146,
	FN_TS_SDEN1_A___3 = 1147,
	FN_STP_ISEN_1_A___3 = 1148,
	FN_RIF1_D0_A___3 = 1149,
	FN_RIF3_D0_A___4 = 1150,
	FN_TCLK2_A___4 = 1151,
	FN_IP17_23_20___3 = 1152,
	FN_USB1_OVC___3 = 1153,
	FN_MSIOF1_SS2_C___3 = 1154,
	FN_SSI_WS1_A___3 = 1155,
	FN_TS_SDAT0_E___3 = 1156,
	FN_STP_ISD_0_E___3 = 1157,
	FN_FMIN_B___4 = 1158,
	FN_RIF2_SYNC_B___4 = 1159,
	FN_REMOCON_B___4 = 1160,
	FN_HCTS2_N_C___3 = 1161,
	FN_IP16_27_24___3 = 1162,
	FN_SSI_SDATA8___4 = 1163,
	FN_HRTS2_N_B___3 = 1164,
	FN_MSIOF1_TXD_C___3 = 1165,
	FN_TS_SPSYNC1_A___3 = 1166,
	FN_STP_ISSYNC_1_A___3 = 1167,
	FN_RIF1_D1_A___3 = 1168,
	FN_RIF3_D1_A___4 = 1169,
	FN_IP17_27_24___3 = 1170,
	FN_USB30_PWEN___4 = 1171,
	FN_AUDIO_CLKOUT_B___4 = 1172,
	FN_SSI_SCK2_B___4 = 1173,
	FN_TS_SDEN1_D___3 = 1174,
	FN_STP_ISEN_1_D___3 = 1175,
	FN_STP_OPWM_0_E___3 = 1176,
	FN_RIF3_D0_B___4 = 1177,
	FN_TCLK2_B___4 = 1178,
	FN_TPU0TO0___4 = 1179,
	FN_BPFCLK_C___4 = 1180,
	FN_HRTS2_N_C___3 = 1181,
	FN_IP16_31_28___3 = 1182,
	FN_SSI_SDATA9_A___3 = 1183,
	FN_HSCK2_B___3 = 1184,
	FN_MSIOF1_SS1_C___3 = 1185,
	FN_HSCK1_A___4 = 1186,
	FN_SSI_WS1_B___3 = 1187,
	FN_SCK1___4 = 1188,
	FN_STP_IVCXO27_1_A___3 = 1189,
	FN_SCK5_A___4 = 1190,
	FN_IP17_31_28___3 = 1191,
	FN_USB30_OVC___4 = 1192,
	FN_AUDIO_CLKOUT1_B___4 = 1193,
	FN_SSI_WS2_B___4 = 1194,
	FN_TS_SPSYNC1_D___3 = 1195,
	FN_STP_ISSYNC_1_D___3 = 1196,
	FN_STP_IVCXO27_0_E___3 = 1197,
	FN_RIF3_D1_B___4 = 1198,
	FN_FSO_TOE_N___3 = 1199,
	FN_TPU0TO1___4 = 1200,
	FN_SEL_MSIOF3_0___4 = 1201,
	FN_SEL_MSIOF3_1___4 = 1202,
	FN_SEL_MSIOF3_2___3 = 1203,
	FN_SEL_MSIOF3_3___3 = 1204,
	FN_SEL_MSIOF3_4___3 = 1205,
	FN_SEL_TSIF1_0___3 = 1206,
	FN_SEL_TSIF1_1___3 = 1207,
	FN_SEL_TSIF1_2___3 = 1208,
	FN_SEL_TSIF1_3___3 = 1209,
	FN_I2C_SEL_5_0___3 = 1210,
	FN_I2C_SEL_5_1___3 = 1211,
	FN_I2C_SEL_3_0___3 = 1212,
	FN_I2C_SEL_3_1___3 = 1213,
	FN_SEL_TSIF0_0___3 = 1214,
	FN_SEL_TSIF0_1___3 = 1215,
	FN_SEL_TSIF0_2___3 = 1216,
	FN_SEL_TSIF0_3___3 = 1217,
	FN_SEL_TSIF0_4___3 = 1218,
	FN_I2C_SEL_0_0___3 = 1219,
	FN_I2C_SEL_0_1___3 = 1220,
	FN_SEL_MSIOF2_0___4 = 1221,
	FN_SEL_MSIOF2_1___4 = 1222,
	FN_SEL_MSIOF2_2___3 = 1223,
	FN_SEL_MSIOF2_3___3 = 1224,
	FN_SEL_FM_0___4 = 1225,
	FN_SEL_FM_1___4 = 1226,
	FN_SEL_FM_2___4 = 1227,
	FN_SEL_FM_3___3 = 1228,
	FN_SEL_MSIOF1_0___3 = 1229,
	FN_SEL_MSIOF1_1___3 = 1230,
	FN_SEL_MSIOF1_2___3 = 1231,
	FN_SEL_MSIOF1_3___3 = 1232,
	FN_SEL_MSIOF1_4___3 = 1233,
	FN_SEL_MSIOF1_5___3 = 1234,
	FN_SEL_MSIOF1_6___3 = 1235,
	FN_SEL_TIMER_TMU1_0 = 1236,
	FN_SEL_TIMER_TMU1_1 = 1237,
	FN_SEL_SCIF5_0___4 = 1238,
	FN_SEL_SCIF5_1___4 = 1239,
	FN_SEL_SSP1_1_0___3 = 1240,
	FN_SEL_SSP1_1_1___3 = 1241,
	FN_SEL_SSP1_1_2___3 = 1242,
	FN_SEL_SSP1_1_3___3 = 1243,
	FN_SEL_I2C6_0___4 = 1244,
	FN_SEL_I2C6_1___4 = 1245,
	FN_SEL_I2C6_2___3 = 1246,
	FN_SEL_LBSC_0___3 = 1247,
	FN_SEL_LBSC_1___3 = 1248,
	FN_SEL_SSP1_0_0___3 = 1249,
	FN_SEL_SSP1_0_1___3 = 1250,
	FN_SEL_SSP1_0_2___3 = 1251,
	FN_SEL_SSP1_0_3___3 = 1252,
	FN_SEL_SSP1_0_4___3 = 1253,
	FN_SEL_IEBUS_0___3 = 1254,
	FN_SEL_IEBUS_1___3 = 1255,
	FN_SEL_I2C2_0___4 = 1256,
	FN_SEL_I2C2_1___4 = 1257,
	FN_SEL_SSI2_0___4 = 1258,
	FN_SEL_SSI2_1___4 = 1259,
	FN_SEL_I2C1_0___4 = 1260,
	FN_SEL_I2C1_1___4 = 1261,
	FN_SEL_SSI1_0___3 = 1262,
	FN_SEL_SSI1_1___3 = 1263,
	FN_SEL_SSI9_0___4 = 1264,
	FN_SEL_SSI9_1___4 = 1265,
	FN_SEL_HSCIF4_0___4 = 1266,
	FN_SEL_HSCIF4_1___4 = 1267,
	FN_SEL_SPEED_PULSE_0___3 = 1268,
	FN_SEL_SPEED_PULSE_1___3 = 1269,
	FN_SEL_TIMER_TMU2_0___3 = 1270,
	FN_SEL_TIMER_TMU2_1___3 = 1271,
	FN_SEL_HSCIF3_0___4 = 1272,
	FN_SEL_HSCIF3_1___4 = 1273,
	FN_SEL_HSCIF3_2___4 = 1274,
	FN_SEL_HSCIF3_3___4 = 1275,
	FN_SEL_SIMCARD_0___4 = 1276,
	FN_SEL_SIMCARD_1___4 = 1277,
	FN_SEL_SIMCARD_2___3 = 1278,
	FN_SEL_SIMCARD_3___3 = 1279,
	FN_SEL_ADGB_0___4 = 1280,
	FN_SEL_ADGB_1___4 = 1281,
	FN_SEL_ADGC_0___4 = 1282,
	FN_SEL_ADGC_1___4 = 1283,
	FN_SEL_HSCIF1_0___4 = 1284,
	FN_SEL_HSCIF1_1___4 = 1285,
	FN_SEL_SDHI2_0___3 = 1286,
	FN_SEL_SDHI2_1___3 = 1287,
	FN_SEL_SCIF4_0___4 = 1288,
	FN_SEL_SCIF4_1___4 = 1289,
	FN_SEL_SCIF4_2___4 = 1290,
	FN_SEL_HSCIF2_0___4 = 1291,
	FN_SEL_HSCIF2_1___4 = 1292,
	FN_SEL_HSCIF2_2___3 = 1293,
	FN_SEL_SCIF3_0___4 = 1294,
	FN_SEL_SCIF3_1___4 = 1295,
	FN_SEL_ETHERAVB_0___3 = 1296,
	FN_SEL_ETHERAVB_1___3 = 1297,
	FN_SEL_SCIF2_0___4 = 1298,
	FN_SEL_SCIF2_1___4 = 1299,
	FN_SEL_DRIF3_0___4 = 1300,
	FN_SEL_DRIF3_1___4 = 1301,
	FN_SEL_SCIF1_0___3 = 1302,
	FN_SEL_SCIF1_1___3 = 1303,
	FN_SEL_DRIF2_0___4 = 1304,
	FN_SEL_DRIF2_1___4 = 1305,
	FN_SEL_SCIF_0___4 = 1306,
	FN_SEL_SCIF_1___4 = 1307,
	FN_SEL_DRIF1_0___3 = 1308,
	FN_SEL_DRIF1_1___3 = 1309,
	FN_SEL_DRIF1_2___3 = 1310,
	FN_SEL_REMOCON_0___4 = 1311,
	FN_SEL_REMOCON_1___4 = 1312,
	FN_SEL_DRIF0_0___4 = 1313,
	FN_SEL_DRIF0_1___4 = 1314,
	FN_SEL_DRIF0_2___3 = 1315,
	FN_SEL_RCAN0_0___3 = 1316,
	FN_SEL_RCAN0_1___3 = 1317,
	FN_SEL_CANFD0_0___3 = 1318,
	FN_SEL_CANFD0_1___3 = 1319,
	FN_SEL_PWM6_0___4 = 1320,
	FN_SEL_PWM6_1___4 = 1321,
	FN_SEL_ADGA_0___3 = 1322,
	FN_SEL_ADGA_1___3 = 1323,
	FN_SEL_ADGA_2___3 = 1324,
	FN_SEL_ADGA_3___3 = 1325,
	FN_SEL_PWM5_0___4 = 1326,
	FN_SEL_PWM5_1___4 = 1327,
	FN_SEL_PWM4_0___4 = 1328,
	FN_SEL_PWM4_1___4 = 1329,
	FN_SEL_PWM3_0___4 = 1330,
	FN_SEL_PWM3_1___4 = 1331,
	FN_SEL_PWM2_0___4 = 1332,
	FN_SEL_PWM2_1___4 = 1333,
	FN_SEL_PWM1_0___4 = 1334,
	FN_SEL_PWM1_1___4 = 1335,
	FN_SEL_VIN4_0___4 = 1336,
	FN_SEL_VIN4_1___4 = 1337,
	PINMUX_FUNCTION_END___4 = 1338,
	PINMUX_MARK_BEGIN___4 = 1339,
	CLKOUT_MARK___4 = 1340,
	MSIOF0_RXD_MARK___4 = 1341,
	MSIOF0_TXD_MARK___4 = 1342,
	MSIOF0_SCK_MARK___4 = 1343,
	SSI_SDATA5_MARK___4 = 1344,
	SSI_WS5_MARK___4 = 1345,
	SSI_SCK5_MARK___4 = 1346,
	GP7_03_MARK___3 = 1347,
	GP7_02_MARK___3 = 1348,
	AVS2_MARK___3 = 1349,
	AVS1_MARK___3 = 1350,
	IP0_3_0_MARK___4 = 1351,
	AVB_MDC_MARK___4 = 1352,
	MSIOF2_SS2_C_MARK___3 = 1353,
	IP1_3_0_MARK___4 = 1354,
	IRQ2_MARK___4 = 1355,
	QCPV_QDE_MARK___4 = 1356,
	DU_EXODDF_DU_ODDF_DISP_CDE_MARK___3 = 1357,
	VI4_DATA2_B_MARK___4 = 1358,
	MSIOF3_SYNC_E_MARK___3 = 1359,
	PWM3_B_MARK___4 = 1360,
	IP2_3_0_MARK___4 = 1361,
	A1_MARK___4 = 1362,
	LCDOUT17_MARK___4 = 1363,
	MSIOF3_TXD_B_MARK___4 = 1364,
	VI4_DATA9_MARK___4 = 1365,
	DU_DB1_MARK___4 = 1366,
	PWM4_A_MARK___4 = 1367,
	IP3_3_0_MARK___4 = 1368,
	A9_MARK___4 = 1369,
	MSIOF2_SCK_A_MARK___4 = 1370,
	CTS4_N_B_MARK___3 = 1371,
	VI5_VSYNC_N_MARK___3 = 1372,
	IP0_7_4_MARK___4 = 1373,
	AVB_MAGIC_MARK___4 = 1374,
	MSIOF2_SS1_C_MARK___3 = 1375,
	SCK4_A_MARK___4 = 1376,
	IP1_7_4_MARK___4 = 1377,
	IRQ3_MARK___4 = 1378,
	QSTVB_QVE_MARK___4 = 1379,
	DU_DOTCLKOUT1_MARK___3 = 1380,
	VI4_DATA3_B_MARK___4 = 1381,
	MSIOF3_SCK_E_MARK___3 = 1382,
	PWM4_B_MARK___4 = 1383,
	IP2_7_4_MARK___4 = 1384,
	A2_MARK___4 = 1385,
	LCDOUT18_MARK___4 = 1386,
	MSIOF3_SCK_B_MARK___4 = 1387,
	VI4_DATA10_MARK___4 = 1388,
	DU_DB2_MARK___4 = 1389,
	PWM5_A_MARK___4 = 1390,
	IP3_7_4_MARK___4 = 1391,
	A10_MARK___4 = 1392,
	MSIOF2_RXD_A_MARK___4 = 1393,
	RTS4_N_B_MARK___3 = 1394,
	VI5_HSYNC_N_MARK___3 = 1395,
	IP0_11_8_MARK___4 = 1396,
	AVB_PHY_INT_MARK___4 = 1397,
	MSIOF2_SYNC_C_MARK___3 = 1398,
	RX4_A_MARK___4 = 1399,
	IP1_11_8_MARK___4 = 1400,
	IRQ4_MARK___4 = 1401,
	QSTH_QHS_MARK___4 = 1402,
	DU_EXHSYNC_DU_HSYNC_MARK___3 = 1403,
	VI4_DATA4_B_MARK___4 = 1404,
	MSIOF3_RXD_E_MARK___3 = 1405,
	PWM5_B_MARK___4 = 1406,
	IP2_11_8_MARK___4 = 1407,
	A3_MARK___4 = 1408,
	LCDOUT19_MARK___4 = 1409,
	MSIOF3_RXD_B_MARK___4 = 1410,
	VI4_DATA11_MARK___4 = 1411,
	DU_DB3_MARK___4 = 1412,
	PWM6_A_MARK___4 = 1413,
	IP3_11_8_MARK___4 = 1414,
	A11_MARK___4 = 1415,
	TX3_B_MARK___4 = 1416,
	MSIOF2_TXD_A_MARK___4 = 1417,
	HTX4_B_MARK___4 = 1418,
	HSCK4_MARK___3 = 1419,
	VI5_FIELD_MARK___3 = 1420,
	SCL6_A_MARK___4 = 1421,
	AVB_AVTP_CAPTURE_B_MARK___3 = 1422,
	PWM2_B_MARK___4 = 1423,
	IP0_15_12_MARK___4 = 1424,
	AVB_LINK_MARK___4 = 1425,
	MSIOF2_SCK_C_MARK___3 = 1426,
	TX4_A_MARK___4 = 1427,
	IP1_15_12_MARK___4 = 1428,
	IRQ5_MARK___4 = 1429,
	QSTB_QHE_MARK___4 = 1430,
	DU_EXVSYNC_DU_VSYNC_MARK___3 = 1431,
	VI4_DATA5_B_MARK___4 = 1432,
	FSCLKST2_N_B_MARK___3 = 1433,
	MSIOF3_TXD_E_MARK___3 = 1434,
	PWM6_B_MARK___4 = 1435,
	IP2_15_12_MARK___4 = 1436,
	A4_MARK___4 = 1437,
	LCDOUT20_MARK___4 = 1438,
	MSIOF3_SS1_B_MARK___4 = 1439,
	VI4_DATA12_MARK___4 = 1440,
	VI5_DATA12_MARK___3 = 1441,
	DU_DB4_MARK___4 = 1442,
	IP3_15_12_MARK___4 = 1443,
	A12_MARK___4 = 1444,
	LCDOUT12_MARK___4 = 1445,
	MSIOF3_SCK_C_MARK___3 = 1446,
	HRX4_A_MARK___4 = 1447,
	VI5_DATA8_MARK___3 = 1448,
	DU_DG4_MARK___4 = 1449,
	IP0_19_16_MARK___4 = 1450,
	AVB_AVTP_MATCH_A_MARK___3 = 1451,
	MSIOF2_RXD_C_MARK___3 = 1452,
	CTS4_N_A_MARK___4 = 1453,
	FSCLKST2_N_A_MARK___3 = 1454,
	IP1_19_16_MARK___4 = 1455,
	PWM0_MARK___3 = 1456,
	AVB_AVTP_PPS_MARK___4 = 1457,
	VI4_DATA6_B_MARK___4 = 1458,
	IECLK_B_MARK___3 = 1459,
	IP2_19_16_MARK___4 = 1460,
	A5_MARK___4 = 1461,
	LCDOUT21_MARK___4 = 1462,
	MSIOF3_SS2_B_MARK___3 = 1463,
	SCK4_B_MARK___4 = 1464,
	VI4_DATA13_MARK___4 = 1465,
	VI5_DATA13_MARK___3 = 1466,
	DU_DB5_MARK___4 = 1467,
	IP3_19_16_MARK___4 = 1468,
	A13_MARK___4 = 1469,
	LCDOUT13_MARK___4 = 1470,
	MSIOF3_SYNC_C_MARK___3 = 1471,
	HTX4_A_MARK___4 = 1472,
	VI5_DATA9_MARK___3 = 1473,
	DU_DG5_MARK___4 = 1474,
	IP0_23_20_MARK___4 = 1475,
	AVB_AVTP_CAPTURE_A_MARK___3 = 1476,
	MSIOF2_TXD_C_MARK___3 = 1477,
	RTS4_N_A_MARK___4 = 1478,
	IP1_23_20_MARK___4 = 1479,
	PWM1_A_MARK___4 = 1480,
	HRX3_D_MARK___4 = 1481,
	VI4_DATA7_B_MARK___4 = 1482,
	IERX_B_MARK___3 = 1483,
	IP2_23_20_MARK___4 = 1484,
	A6_MARK___4 = 1485,
	LCDOUT22_MARK___4 = 1486,
	MSIOF2_SS1_A_MARK___4 = 1487,
	RX4_B_MARK___4 = 1488,
	VI4_DATA14_MARK___4 = 1489,
	VI5_DATA14_MARK___3 = 1490,
	DU_DB6_MARK___4 = 1491,
	IP3_23_20_MARK___4 = 1492,
	A14_MARK___4 = 1493,
	LCDOUT14_MARK___4 = 1494,
	MSIOF3_RXD_C_MARK___3 = 1495,
	HCTS4_N_MARK___3 = 1496,
	VI5_DATA10_MARK___3 = 1497,
	DU_DG6_MARK___4 = 1498,
	IP0_27_24_MARK___4 = 1499,
	IRQ0_MARK___4 = 1500,
	QPOLB_MARK___4 = 1501,
	DU_CDE_MARK___4 = 1502,
	VI4_DATA0_B_MARK___4 = 1503,
	CAN0_TX_B_MARK___3 = 1504,
	CANFD0_TX_B_MARK___3 = 1505,
	MSIOF3_SS2_E_MARK___3 = 1506,
	IP1_27_24_MARK___4 = 1507,
	PWM2_A_MARK___4 = 1508,
	HTX3_D_MARK___4 = 1509,
	IETX_B_MARK___3 = 1510,
	IP2_27_24_MARK___4 = 1511,
	A7_MARK___4 = 1512,
	LCDOUT23_MARK___4 = 1513,
	MSIOF2_SS2_A_MARK___4 = 1514,
	TX4_B_MARK___4 = 1515,
	VI4_DATA15_MARK___4 = 1516,
	VI5_DATA15_MARK___3 = 1517,
	DU_DB7_MARK___4 = 1518,
	IP3_27_24_MARK___4 = 1519,
	A15_MARK___4 = 1520,
	LCDOUT15_MARK___4 = 1521,
	MSIOF3_TXD_C_MARK___3 = 1522,
	HRTS4_N_MARK___3 = 1523,
	VI5_DATA11_MARK___3 = 1524,
	DU_DG7_MARK___4 = 1525,
	IP0_31_28_MARK___4 = 1526,
	IRQ1_MARK___4 = 1527,
	QPOLA_MARK___4 = 1528,
	DU_DISP_MARK___4 = 1529,
	VI4_DATA1_B_MARK___4 = 1530,
	CAN0_RX_B_MARK___3 = 1531,
	CANFD0_RX_B_MARK___3 = 1532,
	MSIOF3_SS1_E_MARK___3 = 1533,
	IP1_31_28_MARK___4 = 1534,
	A0_MARK___4 = 1535,
	LCDOUT16_MARK___4 = 1536,
	MSIOF3_SYNC_B_MARK___4 = 1537,
	VI4_DATA8_MARK___4 = 1538,
	DU_DB0_MARK___4 = 1539,
	PWM3_A_MARK___4 = 1540,
	IP2_31_28_MARK___4 = 1541,
	A8_MARK___4 = 1542,
	RX3_B_MARK___4 = 1543,
	MSIOF2_SYNC_A_MARK___4 = 1544,
	HRX4_B_MARK___4 = 1545,
	SDA6_A_MARK___4 = 1546,
	AVB_AVTP_MATCH_B_MARK___3 = 1547,
	PWM1_B_MARK___4 = 1548,
	IP3_31_28_MARK___4 = 1549,
	A16_MARK___4 = 1550,
	LCDOUT8_MARK___4 = 1551,
	VI4_FIELD_MARK___4 = 1552,
	DU_DG0_MARK___4 = 1553,
	IP4_3_0_MARK___4 = 1554,
	A17_MARK___4 = 1555,
	LCDOUT9_MARK___4 = 1556,
	VI4_VSYNC_N_MARK___4 = 1557,
	DU_DG1_MARK___4 = 1558,
	IP5_3_0_MARK___4 = 1559,
	WE0_N_MARK___4 = 1560,
	MSIOF3_TXD_D_MARK___3 = 1561,
	CTS3_N_MARK___3 = 1562,
	HCTS3_N_MARK___3 = 1563,
	SCL6_B_MARK___4 = 1564,
	CAN_CLK_MARK___4 = 1565,
	IECLK_A_MARK___3 = 1566,
	IP6_3_0_MARK___4 = 1567,
	D5_MARK___4 = 1568,
	MSIOF2_SYNC_B_MARK___4 = 1569,
	VI4_DATA21_MARK___4 = 1570,
	VI5_DATA5_MARK___3 = 1571,
	IP7_3_0_MARK___4 = 1572,
	D13_MARK___4 = 1573,
	LCDOUT5_MARK___4 = 1574,
	MSIOF2_SS2_D_MARK___3 = 1575,
	TX4_C_MARK___4 = 1576,
	VI4_DATA5_A_MARK___4 = 1577,
	DU_DR5_MARK___4 = 1578,
	IP4_7_4_MARK___4 = 1579,
	A18_MARK___4 = 1580,
	LCDOUT10_MARK___4 = 1581,
	VI4_HSYNC_N_MARK___4 = 1582,
	DU_DG2_MARK___4 = 1583,
	IP5_7_4_MARK___4 = 1584,
	WE1_N_MARK___4 = 1585,
	MSIOF3_SS1_D_MARK___3 = 1586,
	RTS3_N_MARK___3 = 1587,
	HRTS3_N_MARK___3 = 1588,
	SDA6_B_MARK___4 = 1589,
	CAN1_RX_MARK___4 = 1590,
	CANFD1_RX_MARK___4 = 1591,
	IERX_A_MARK___3 = 1592,
	IP6_7_4_MARK___4 = 1593,
	D6_MARK___4 = 1594,
	MSIOF2_RXD_B_MARK___4 = 1595,
	VI4_DATA22_MARK___4 = 1596,
	VI5_DATA6_MARK___3 = 1597,
	IP7_7_4_MARK___4 = 1598,
	D14_MARK___4 = 1599,
	LCDOUT6_MARK___4 = 1600,
	MSIOF3_SS1_A_MARK___4 = 1601,
	HRX3_C_MARK___4 = 1602,
	VI4_DATA6_A_MARK___4 = 1603,
	DU_DR6_MARK___4 = 1604,
	SCL6_C_MARK___3 = 1605,
	IP4_11_8_MARK___4 = 1606,
	A19_MARK___4 = 1607,
	LCDOUT11_MARK___4 = 1608,
	VI4_CLKENB_MARK___4 = 1609,
	DU_DG3_MARK___4 = 1610,
	IP5_11_8_MARK___4 = 1611,
	EX_WAIT0_A_MARK___3 = 1612,
	QCLK_MARK___4 = 1613,
	VI4_CLK_MARK___4 = 1614,
	DU_DOTCLKOUT0_MARK___4 = 1615,
	IP6_11_8_MARK___4 = 1616,
	D7_MARK___4 = 1617,
	MSIOF2_TXD_B_MARK___4 = 1618,
	VI4_DATA23_MARK___4 = 1619,
	VI5_DATA7_MARK___3 = 1620,
	IP7_11_8_MARK___4 = 1621,
	D15_MARK___4 = 1622,
	LCDOUT7_MARK___4 = 1623,
	MSIOF3_SS2_A_MARK___4 = 1624,
	HTX3_C_MARK___4 = 1625,
	VI4_DATA7_A_MARK___4 = 1626,
	DU_DR7_MARK___4 = 1627,
	SDA6_C_MARK___3 = 1628,
	IP4_15_12_MARK___4 = 1629,
	CS0_N_MARK___4 = 1630,
	VI5_CLKENB_MARK___3 = 1631,
	IP5_15_12_MARK___4 = 1632,
	D0_MARK___4 = 1633,
	MSIOF2_SS1_B_MARK___4 = 1634,
	MSIOF3_SCK_A_MARK___4 = 1635,
	VI4_DATA16_MARK___4 = 1636,
	VI5_DATA0_MARK___3 = 1637,
	IP6_15_12_MARK___4 = 1638,
	D8_MARK___4 = 1639,
	LCDOUT0_MARK___4 = 1640,
	MSIOF2_SCK_D_MARK___3 = 1641,
	SCK4_C_MARK___3 = 1642,
	VI4_DATA0_A_MARK___4 = 1643,
	DU_DR0_MARK___4 = 1644,
	IP4_19_16_MARK___4 = 1645,
	CS1_N_MARK___3 = 1646,
	VI5_CLK_MARK___3 = 1647,
	EX_WAIT0_B_MARK___3 = 1648,
	IP5_19_16_MARK___4 = 1649,
	D1_MARK___4 = 1650,
	MSIOF2_SS2_B_MARK___4 = 1651,
	MSIOF3_SYNC_A_MARK___4 = 1652,
	VI4_DATA17_MARK___4 = 1653,
	VI5_DATA1_MARK___3 = 1654,
	IP6_19_16_MARK___4 = 1655,
	D9_MARK___4 = 1656,
	LCDOUT1_MARK___4 = 1657,
	MSIOF2_SYNC_D_MARK___3 = 1658,
	VI4_DATA1_A_MARK___4 = 1659,
	DU_DR1_MARK___4 = 1660,
	IP7_19_16_MARK___4 = 1661,
	SD0_CLK_MARK___4 = 1662,
	MSIOF1_SCK_E_MARK___3 = 1663,
	STP_OPWM_0_B_MARK___3 = 1664,
	IP4_23_20_MARK___4 = 1665,
	BS_N_MARK___4 = 1666,
	QSTVA_QVS_MARK___4 = 1667,
	MSIOF3_SCK_D_MARK___3 = 1668,
	SCK3_MARK___3 = 1669,
	HSCK3_MARK___3 = 1670,
	CAN1_TX_MARK___4 = 1671,
	CANFD1_TX_MARK___4 = 1672,
	IETX_A_MARK___3 = 1673,
	IP5_23_20_MARK___4 = 1674,
	D2_MARK___4 = 1675,
	MSIOF3_RXD_A_MARK___4 = 1676,
	VI4_DATA18_MARK___4 = 1677,
	VI5_DATA2_MARK___3 = 1678,
	IP6_23_20_MARK___4 = 1679,
	D10_MARK___4 = 1680,
	LCDOUT2_MARK___4 = 1681,
	MSIOF2_RXD_D_MARK___3 = 1682,
	HRX3_B_MARK___4 = 1683,
	VI4_DATA2_A_MARK___4 = 1684,
	CTS4_N_C_MARK___4 = 1685,
	DU_DR2_MARK___4 = 1686,
	IP7_23_20_MARK___4 = 1687,
	SD0_CMD_MARK___4 = 1688,
	MSIOF1_SYNC_E_MARK___3 = 1689,
	STP_IVCXO27_0_B_MARK___3 = 1690,
	IP4_27_24_MARK___4 = 1691,
	RD_N_MARK___4 = 1692,
	MSIOF3_SYNC_D_MARK___3 = 1693,
	RX3_A_MARK___4 = 1694,
	HRX3_A_MARK___4 = 1695,
	CAN0_TX_A_MARK___3 = 1696,
	CANFD0_TX_A_MARK___3 = 1697,
	IP5_27_24_MARK___4 = 1698,
	D3_MARK___4 = 1699,
	MSIOF3_TXD_A_MARK___4 = 1700,
	VI4_DATA19_MARK___4 = 1701,
	VI5_DATA3_MARK___3 = 1702,
	IP6_27_24_MARK___4 = 1703,
	D11_MARK___4 = 1704,
	LCDOUT3_MARK___4 = 1705,
	MSIOF2_TXD_D_MARK___3 = 1706,
	HTX3_B_MARK___4 = 1707,
	VI4_DATA3_A_MARK___4 = 1708,
	RTS4_N_C_MARK___4 = 1709,
	DU_DR3_MARK___4 = 1710,
	IP7_27_24_MARK___4 = 1711,
	SD0_DAT0_MARK___4 = 1712,
	MSIOF1_RXD_E_MARK___3 = 1713,
	TS_SCK0_B_MARK___3 = 1714,
	STP_ISCLK_0_B_MARK___3 = 1715,
	IP4_31_28_MARK___4 = 1716,
	RD_WR_N_MARK___4 = 1717,
	MSIOF3_RXD_D_MARK___3 = 1718,
	TX3_A_MARK___4 = 1719,
	HTX3_A_MARK___4 = 1720,
	CAN0_RX_A_MARK___3 = 1721,
	CANFD0_RX_A_MARK___3 = 1722,
	IP5_31_28_MARK___4 = 1723,
	D4_MARK___4 = 1724,
	MSIOF2_SCK_B_MARK___4 = 1725,
	VI4_DATA20_MARK___4 = 1726,
	VI5_DATA4_MARK___3 = 1727,
	IP6_31_28_MARK___4 = 1728,
	D12_MARK___4 = 1729,
	LCDOUT4_MARK___4 = 1730,
	MSIOF2_SS1_D_MARK___3 = 1731,
	RX4_C_MARK___4 = 1732,
	VI4_DATA4_A_MARK___4 = 1733,
	DU_DR4_MARK___4 = 1734,
	IP7_31_28_MARK___4 = 1735,
	SD0_DAT1_MARK___4 = 1736,
	MSIOF1_TXD_E_MARK___3 = 1737,
	TS_SPSYNC0_B_MARK___3 = 1738,
	STP_ISSYNC_0_B_MARK___3 = 1739,
	IP8_3_0_MARK___4 = 1740,
	SD0_DAT2_MARK___4 = 1741,
	MSIOF1_SS1_E_MARK___3 = 1742,
	TS_SDAT0_B_MARK___3 = 1743,
	STP_ISD_0_B_MARK___3 = 1744,
	IP9_3_0_MARK___4 = 1745,
	SD2_CLK_MARK___3 = 1746,
	NFDATA8_MARK___4 = 1747,
	IP10_3_0_MARK___4 = 1748,
	SD3_CMD_MARK___4 = 1749,
	NFRE_N_MARK___4 = 1750,
	IP11_3_0_MARK___4 = 1751,
	SD3_DAT7_MARK___4 = 1752,
	SD3_WP_MARK___4 = 1753,
	NFDATA7_MARK___4 = 1754,
	IP8_7_4_MARK___4 = 1755,
	SD0_DAT3_MARK___4 = 1756,
	MSIOF1_SS2_E_MARK___3 = 1757,
	TS_SDEN0_B_MARK___3 = 1758,
	STP_ISEN_0_B_MARK___3 = 1759,
	IP9_7_4_MARK___4 = 1760,
	SD2_CMD_MARK___3 = 1761,
	NFDATA9_MARK___4 = 1762,
	IP10_7_4_MARK___4 = 1763,
	SD3_DAT0_MARK___4 = 1764,
	NFDATA0_MARK___4 = 1765,
	IP11_7_4_MARK___4 = 1766,
	SD3_DS_MARK___4 = 1767,
	NFCLE_MARK___4 = 1768,
	IP8_11_8_MARK___4 = 1769,
	SD1_CLK_MARK___4 = 1770,
	MSIOF1_SCK_G_MARK___3 = 1771,
	SIM0_CLK_A_MARK___4 = 1772,
	IP9_11_8_MARK___4 = 1773,
	SD2_DAT0_MARK___3 = 1774,
	NFDATA10_MARK___4 = 1775,
	IP10_11_8_MARK___4 = 1776,
	SD3_DAT1_MARK___4 = 1777,
	NFDATA1_MARK___4 = 1778,
	IP11_11_8_MARK___4 = 1779,
	SD0_CD_MARK___4 = 1780,
	NFDATA14_A_MARK___4 = 1781,
	SCL2_B_MARK___4 = 1782,
	SIM0_RST_A_MARK___4 = 1783,
	IP8_15_12_MARK___4 = 1784,
	SD1_CMD_MARK___4 = 1785,
	MSIOF1_SYNC_G_MARK___3 = 1786,
	NFCE_N_B_MARK___4 = 1787,
	SIM0_D_A_MARK___4 = 1788,
	STP_IVCXO27_1_B_MARK___3 = 1789,
	IP9_15_12_MARK___4 = 1790,
	SD2_DAT1_MARK___3 = 1791,
	NFDATA11_MARK___4 = 1792,
	IP10_15_12_MARK___4 = 1793,
	SD3_DAT2_MARK___4 = 1794,
	NFDATA2_MARK___4 = 1795,
	IP11_15_12_MARK___4 = 1796,
	SD0_WP_MARK___4 = 1797,
	NFDATA15_A_MARK___4 = 1798,
	SDA2_B_MARK___4 = 1799,
	IP8_19_16_MARK___4 = 1800,
	SD1_DAT0_MARK___4 = 1801,
	SD2_DAT4_MARK___3 = 1802,
	MSIOF1_RXD_G_MARK___3 = 1803,
	NFWP_N_B_MARK___4 = 1804,
	TS_SCK1_B_MARK___3 = 1805,
	STP_ISCLK_1_B_MARK___3 = 1806,
	IP9_19_16_MARK___4 = 1807,
	SD2_DAT2_MARK___3 = 1808,
	NFDATA12_MARK___4 = 1809,
	IP10_19_16_MARK___4 = 1810,
	SD3_DAT3_MARK___4 = 1811,
	NFDATA3_MARK___4 = 1812,
	IP11_19_16_MARK___4 = 1813,
	SD1_CD_MARK___4 = 1814,
	NFRB_N_A_MARK___4 = 1815,
	SIM0_CLK_B_MARK___4 = 1816,
	IP8_23_20_MARK___4 = 1817,
	SD1_DAT1_MARK___4 = 1818,
	SD2_DAT5_MARK___3 = 1819,
	MSIOF1_TXD_G_MARK___3 = 1820,
	NFDATA14_B_MARK___4 = 1821,
	TS_SPSYNC1_B_MARK___3 = 1822,
	STP_ISSYNC_1_B_MARK___3 = 1823,
	IP9_23_20_MARK___4 = 1824,
	SD2_DAT3_MARK___3 = 1825,
	NFDATA13_MARK___4 = 1826,
	IP10_23_20_MARK___4 = 1827,
	SD3_DAT4_MARK___4 = 1828,
	SD2_CD_A_MARK___3 = 1829,
	NFDATA4_MARK___4 = 1830,
	IP11_23_20_MARK___4 = 1831,
	SD1_WP_MARK___4 = 1832,
	NFCE_N_A_MARK___4 = 1833,
	SIM0_D_B_MARK___4 = 1834,
	IP8_27_24_MARK___4 = 1835,
	SD1_DAT2_MARK___4 = 1836,
	SD2_DAT6_MARK___3 = 1837,
	MSIOF1_SS1_G_MARK___3 = 1838,
	NFDATA15_B_MARK___4 = 1839,
	TS_SDAT1_B_MARK___3 = 1840,
	STP_ISD_1_B_MARK___3 = 1841,
	IP9_27_24_MARK___4 = 1842,
	SD2_DS_MARK___3 = 1843,
	NFALE_MARK___3 = 1844,
	SATA_DEVSLP_B_MARK___2 = 1845,
	IP10_27_24_MARK___4 = 1846,
	SD3_DAT5_MARK___4 = 1847,
	SD2_WP_A_MARK___3 = 1848,
	NFDATA5_MARK___4 = 1849,
	IP11_27_24_MARK___4 = 1850,
	SCK0_MARK___3 = 1851,
	HSCK1_B_MARK___4 = 1852,
	MSIOF1_SS2_B_MARK___3 = 1853,
	AUDIO_CLKC_B_MARK___4 = 1854,
	SDA2_A_MARK___4 = 1855,
	SIM0_RST_B_MARK___4 = 1856,
	STP_OPWM_0_C_MARK___3 = 1857,
	RIF0_CLK_B_MARK___4 = 1858,
	ADICHS2_MARK___3 = 1859,
	SCK5_B_MARK___3 = 1860,
	IP8_31_28_MARK___4 = 1861,
	SD1_DAT3_MARK___4 = 1862,
	SD2_DAT7_MARK___3 = 1863,
	MSIOF1_SS2_G_MARK___3 = 1864,
	NFRB_N_B_MARK___4 = 1865,
	TS_SDEN1_B_MARK___3 = 1866,
	STP_ISEN_1_B_MARK___3 = 1867,
	IP9_31_28_MARK___4 = 1868,
	SD3_CLK_MARK___4 = 1869,
	NFWE_N_MARK___4 = 1870,
	IP10_31_28_MARK___4 = 1871,
	SD3_DAT6_MARK___4 = 1872,
	SD3_CD_MARK___4 = 1873,
	NFDATA6_MARK___4 = 1874,
	IP11_31_28_MARK___4 = 1875,
	RX0_MARK___3 = 1876,
	HRX1_B_MARK___4 = 1877,
	TS_SCK0_C_MARK___3 = 1878,
	STP_ISCLK_0_C_MARK___3 = 1879,
	RIF0_D0_B_MARK___4 = 1880,
	IP12_3_0_MARK___4 = 1881,
	TX0_MARK___3 = 1882,
	HTX1_B_MARK___4 = 1883,
	TS_SPSYNC0_C_MARK___3 = 1884,
	STP_ISSYNC_0_C_MARK___3 = 1885,
	RIF0_D1_B_MARK___4 = 1886,
	IP13_3_0_MARK___4 = 1887,
	TX2_A_MARK___4 = 1888,
	SD2_CD_B_MARK___3 = 1889,
	SCL1_A_MARK___4 = 1890,
	FMCLK_A_MARK___4 = 1891,
	RIF1_D1_C_MARK___3 = 1892,
	FSO_CFE_0_N_MARK___3 = 1893,
	IP14_3_0_MARK___4 = 1894,
	MSIOF0_SS1_MARK___4 = 1895,
	RX5_A_MARK___4 = 1896,
	NFWP_N_A_MARK___4 = 1897,
	AUDIO_CLKA_C_MARK___3 = 1898,
	SSI_SCK2_A_MARK___4 = 1899,
	STP_IVCXO27_0_C_MARK___3 = 1900,
	AUDIO_CLKOUT3_A_MARK___4 = 1901,
	TCLK1_B_MARK___4 = 1902,
	IP15_3_0_MARK___4 = 1903,
	SSI_SDATA1_A_MARK___3 = 1904,
	IP12_7_4_MARK___4 = 1905,
	CTS0_N_MARK___3 = 1906,
	HCTS1_N_B_MARK___4 = 1907,
	MSIOF1_SYNC_B_MARK___3 = 1908,
	TS_SPSYNC1_C_MARK___3 = 1909,
	STP_ISSYNC_1_C_MARK___3 = 1910,
	RIF1_SYNC_B_MARK___3 = 1911,
	AUDIO_CLKOUT_C_MARK___3 = 1912,
	ADICS_SAMP_MARK___3 = 1913,
	IP13_7_4_MARK___4 = 1914,
	RX2_A_MARK___4 = 1915,
	SD2_WP_B_MARK___3 = 1916,
	SDA1_A_MARK___4 = 1917,
	FMIN_A_MARK___4 = 1918,
	RIF1_SYNC_C_MARK___3 = 1919,
	FSO_CFE_1_N_MARK___3 = 1920,
	IP14_7_4_MARK___4 = 1921,
	MSIOF0_SS2_MARK___4 = 1922,
	TX5_A_MARK___4 = 1923,
	MSIOF1_SS2_D_MARK___3 = 1924,
	AUDIO_CLKC_A_MARK___4 = 1925,
	SSI_WS2_A_MARK___4 = 1926,
	STP_OPWM_0_D_MARK___3 = 1927,
	AUDIO_CLKOUT_D_MARK___3 = 1928,
	SPEEDIN_B_MARK___4 = 1929,
	IP15_7_4_MARK___4 = 1930,
	SSI_SDATA2_A_MARK___3 = 1931,
	SSI_SCK1_B_MARK___3 = 1932,
	IP12_11_8_MARK___4 = 1933,
	RTS0_N_MARK___3 = 1934,
	HRTS1_N_B_MARK___4 = 1935,
	MSIOF1_SS1_B_MARK___3 = 1936,
	AUDIO_CLKA_B_MARK___3 = 1937,
	SCL2_A_MARK___4 = 1938,
	STP_IVCXO27_1_C_MARK___3 = 1939,
	RIF0_SYNC_B_MARK___4 = 1940,
	ADICHS1_MARK___3 = 1941,
	IP13_11_8_MARK___4 = 1942,
	HSCK0_MARK___3 = 1943,
	MSIOF1_SCK_D_MARK___3 = 1944,
	AUDIO_CLKB_A_MARK___4 = 1945,
	SSI_SDATA1_B_MARK___3 = 1946,
	TS_SCK0_D_MARK___3 = 1947,
	STP_ISCLK_0_D_MARK___3 = 1948,
	RIF0_CLK_C_MARK___3 = 1949,
	RX5_B_MARK___4 = 1950,
	IP14_11_8_MARK___4 = 1951,
	MLB_CLK_MARK___4 = 1952,
	MSIOF1_SCK_F_MARK___3 = 1953,
	SCL1_B_MARK___4 = 1954,
	IP15_11_8_MARK___4 = 1955,
	SSI_SCK349_MARK___4 = 1956,
	MSIOF1_SS1_A_MARK___3 = 1957,
	STP_OPWM_0_A_MARK___3 = 1958,
	IP12_15_12_MARK___4 = 1959,
	RX1_A_MARK___3 = 1960,
	HRX1_A_MARK___4 = 1961,
	TS_SDAT0_C_MARK___3 = 1962,
	STP_ISD_0_C_MARK___3 = 1963,
	RIF1_CLK_C_MARK___3 = 1964,
	IP13_15_12_MARK___4 = 1965,
	HRX0_MARK___3 = 1966,
	MSIOF1_RXD_D_MARK___3 = 1967,
	SSI_SDATA2_B_MARK___3 = 1968,
	TS_SDEN0_D_MARK___3 = 1969,
	STP_ISEN_0_D_MARK___3 = 1970,
	RIF0_D0_C_MARK___3 = 1971,
	IP14_15_12_MARK___4 = 1972,
	MLB_SIG_MARK___4 = 1973,
	RX1_B_MARK___3 = 1974,
	MSIOF1_SYNC_F_MARK___3 = 1975,
	SDA1_B_MARK___4 = 1976,
	IP15_15_12_MARK___4 = 1977,
	SSI_WS349_MARK___4 = 1978,
	HCTS2_N_A_MARK___4 = 1979,
	MSIOF1_SS2_A_MARK___3 = 1980,
	STP_IVCXO27_0_A_MARK___3 = 1981,
	IP12_19_16_MARK___4 = 1982,
	TX1_A_MARK___3 = 1983,
	HTX1_A_MARK___4 = 1984,
	TS_SDEN0_C_MARK___3 = 1985,
	STP_ISEN_0_C_MARK___3 = 1986,
	RIF1_D0_C_MARK___3 = 1987,
	IP13_19_16_MARK___4 = 1988,
	HTX0_MARK___3 = 1989,
	MSIOF1_TXD_D_MARK___3 = 1990,
	SSI_SDATA9_B_MARK___3 = 1991,
	TS_SDAT0_D_MARK___3 = 1992,
	STP_ISD_0_D_MARK___3 = 1993,
	RIF0_D1_C_MARK___3 = 1994,
	IP14_19_16_MARK___4 = 1995,
	MLB_DAT_MARK___4 = 1996,
	TX1_B_MARK___3 = 1997,
	MSIOF1_RXD_F_MARK___3 = 1998,
	IP15_19_16_MARK___4 = 1999,
	SSI_SDATA3_MARK___4 = 2000,
	HRTS2_N_A_MARK___4 = 2001,
	MSIOF1_TXD_A_MARK___3 = 2002,
	TS_SCK0_A_MARK___3 = 2003,
	STP_ISCLK_0_A_MARK___3 = 2004,
	RIF0_D1_A_MARK___4 = 2005,
	RIF2_D0_A_MARK___4 = 2006,
	IP12_23_20_MARK___4 = 2007,
	CTS1_N_MARK___4 = 2008,
	HCTS1_N_A_MARK___3 = 2009,
	MSIOF1_RXD_B_MARK___3 = 2010,
	TS_SDEN1_C_MARK___3 = 2011,
	STP_ISEN_1_C_MARK___3 = 2012,
	RIF1_D0_B_MARK___3 = 2013,
	ADIDATA_MARK___3 = 2014,
	IP13_23_20_MARK___4 = 2015,
	HCTS0_N_MARK___3 = 2016,
	RX2_B_MARK___4 = 2017,
	MSIOF1_SYNC_D_MARK___3 = 2018,
	SSI_SCK9_A_MARK___4 = 2019,
	TS_SPSYNC0_D_MARK___3 = 2020,
	STP_ISSYNC_0_D_MARK___3 = 2021,
	RIF0_SYNC_C_MARK___3 = 2022,
	AUDIO_CLKOUT1_A_MARK___4 = 2023,
	IP14_23_20_MARK___4 = 2024,
	SSI_SCK01239_MARK___4 = 2025,
	MSIOF1_TXD_F_MARK___3 = 2026,
	IP15_23_20_MARK___4 = 2027,
	SSI_SCK4_MARK___4 = 2028,
	HRX2_A_MARK___4 = 2029,
	MSIOF1_SCK_A_MARK___3 = 2030,
	TS_SDAT0_A_MARK___3 = 2031,
	STP_ISD_0_A_MARK___3 = 2032,
	RIF0_CLK_A_MARK___4 = 2033,
	RIF2_CLK_A_MARK___4 = 2034,
	IP12_27_24_MARK___4 = 2035,
	RTS1_N_MARK___4 = 2036,
	HRTS1_N_A_MARK___3 = 2037,
	MSIOF1_TXD_B_MARK___3 = 2038,
	TS_SDAT1_C_MARK___3 = 2039,
	STP_ISD_1_C_MARK___3 = 2040,
	RIF1_D1_B_MARK___3 = 2041,
	ADICHS0_MARK___3 = 2042,
	IP13_27_24_MARK___4 = 2043,
	HRTS0_N_MARK___3 = 2044,
	TX2_B_MARK___4 = 2045,
	MSIOF1_SS1_D_MARK___3 = 2046,
	SSI_WS9_A_MARK___4 = 2047,
	STP_IVCXO27_0_D_MARK___3 = 2048,
	BPFCLK_A_MARK___4 = 2049,
	AUDIO_CLKOUT2_A_MARK___4 = 2050,
	IP14_27_24_MARK___4 = 2051,
	SSI_WS01239_MARK___4 = 2052,
	MSIOF1_SS1_F_MARK___3 = 2053,
	IP15_27_24_MARK___4 = 2054,
	SSI_WS4_MARK___4 = 2055,
	HTX2_A_MARK___4 = 2056,
	MSIOF1_SYNC_A_MARK___3 = 2057,
	TS_SDEN0_A_MARK___3 = 2058,
	STP_ISEN_0_A_MARK___3 = 2059,
	RIF0_SYNC_A_MARK___4 = 2060,
	RIF2_SYNC_A_MARK___4 = 2061,
	IP12_31_28_MARK___4 = 2062,
	SCK2_MARK___3 = 2063,
	SCIF_CLK_B_MARK___4 = 2064,
	MSIOF1_SCK_B_MARK___3 = 2065,
	TS_SCK1_C_MARK___3 = 2066,
	STP_ISCLK_1_C_MARK___3 = 2067,
	RIF1_CLK_B_MARK___3 = 2068,
	ADICLK_MARK___3 = 2069,
	IP13_31_28_MARK___4 = 2070,
	MSIOF0_SYNC_MARK___4 = 2071,
	AUDIO_CLKOUT_A_MARK___4 = 2072,
	TX5_B_MARK___4 = 2073,
	BPFCLK_D_MARK___3 = 2074,
	IP14_31_28_MARK___4 = 2075,
	SSI_SDATA0_MARK___4 = 2076,
	MSIOF1_SS2_F_MARK___3 = 2077,
	IP15_31_28_MARK___4 = 2078,
	SSI_SDATA4_MARK___4 = 2079,
	HSCK2_A_MARK___4 = 2080,
	MSIOF1_RXD_A_MARK___3 = 2081,
	TS_SPSYNC0_A_MARK___3 = 2082,
	STP_ISSYNC_0_A_MARK___3 = 2083,
	RIF0_D0_A_MARK___4 = 2084,
	RIF2_D1_A_MARK___4 = 2085,
	IP16_3_0_MARK___3 = 2086,
	SSI_SCK6_MARK___4 = 2087,
	USB2_PWEN_MARK = 2088,
	SIM0_RST_D_MARK___3 = 2089,
	IP17_3_0_MARK___3 = 2090,
	AUDIO_CLKA_A_MARK___3 = 2091,
	IP18_3_0_MARK___3 = 2092,
	USB2_CH3_PWEN_MARK = 2093,
	AUDIO_CLKOUT2_B_MARK___4 = 2094,
	SSI_SCK9_B_MARK___4 = 2095,
	TS_SDEN0_E_MARK___3 = 2096,
	STP_ISEN_0_E_MARK___3 = 2097,
	RIF2_D0_B_MARK___4 = 2098,
	TPU0TO2_MARK___4 = 2099,
	FMCLK_C_MARK___4 = 2100,
	FMCLK_D_MARK___3 = 2101,
	IP16_7_4_MARK___3 = 2102,
	SSI_WS6_MARK___4 = 2103,
	USB2_OVC_MARK = 2104,
	SIM0_D_D_MARK___3 = 2105,
	IP17_7_4_MARK___3 = 2106,
	AUDIO_CLKB_B_MARK___4 = 2107,
	SCIF_CLK_A_MARK___4 = 2108,
	STP_IVCXO27_1_D_MARK___3 = 2109,
	REMOCON_A_MARK___4 = 2110,
	TCLK1_A_MARK___4 = 2111,
	IP18_7_4_MARK___3 = 2112,
	USB2_CH3_OVC_MARK = 2113,
	AUDIO_CLKOUT3_B_MARK___4 = 2114,
	SSI_WS9_B_MARK___4 = 2115,
	TS_SPSYNC0_E_MARK___3 = 2116,
	STP_ISSYNC_0_E_MARK___3 = 2117,
	RIF2_D1_B_MARK___4 = 2118,
	TPU0TO3_MARK___4 = 2119,
	FMIN_C_MARK___4 = 2120,
	FMIN_D_MARK___3 = 2121,
	IP16_11_8_MARK___3 = 2122,
	SSI_SDATA6_MARK___4 = 2123,
	SIM0_CLK_D_MARK___3 = 2124,
	SATA_DEVSLP_A_MARK___2 = 2125,
	IP17_11_8_MARK___3 = 2126,
	USB0_PWEN_MARK___3 = 2127,
	SIM0_RST_C_MARK___3 = 2128,
	TS_SCK1_D_MARK___3 = 2129,
	STP_ISCLK_1_D_MARK___3 = 2130,
	BPFCLK_B_MARK___4 = 2131,
	RIF3_CLK_B_MARK___4 = 2132,
	HSCK2_C_MARK___3 = 2133,
	IP16_15_12_MARK___3 = 2134,
	SSI_SCK78_MARK___4 = 2135,
	HRX2_B_MARK___4 = 2136,
	MSIOF1_SCK_C_MARK___3 = 2137,
	TS_SCK1_A_MARK___3 = 2138,
	STP_ISCLK_1_A_MARK___3 = 2139,
	RIF1_CLK_A_MARK___3 = 2140,
	RIF3_CLK_A_MARK___4 = 2141,
	IP17_15_12_MARK___3 = 2142,
	USB0_OVC_MARK___3 = 2143,
	SIM0_D_C_MARK___3 = 2144,
	TS_SDAT1_D_MARK___3 = 2145,
	STP_ISD_1_D_MARK___3 = 2146,
	RIF3_SYNC_B_MARK___4 = 2147,
	HRX2_C_MARK___3 = 2148,
	IP16_19_16_MARK___3 = 2149,
	SSI_WS78_MARK___4 = 2150,
	HTX2_B_MARK___4 = 2151,
	MSIOF1_SYNC_C_MARK___3 = 2152,
	TS_SDAT1_A_MARK___3 = 2153,
	STP_ISD_1_A_MARK___3 = 2154,
	RIF1_SYNC_A_MARK___3 = 2155,
	RIF3_SYNC_A_MARK___4 = 2156,
	IP17_19_16_MARK___3 = 2157,
	USB1_PWEN_MARK___3 = 2158,
	SIM0_CLK_C_MARK___3 = 2159,
	SSI_SCK1_A_MARK___3 = 2160,
	TS_SCK0_E_MARK___3 = 2161,
	STP_ISCLK_0_E_MARK___3 = 2162,
	FMCLK_B_MARK___4 = 2163,
	RIF2_CLK_B_MARK___4 = 2164,
	SPEEDIN_A_MARK___4 = 2165,
	HTX2_C_MARK___3 = 2166,
	IP16_23_20_MARK___3 = 2167,
	SSI_SDATA7_MARK___4 = 2168,
	HCTS2_N_B_MARK___3 = 2169,
	MSIOF1_RXD_C_MARK___3 = 2170,
	TS_SDEN1_A_MARK___3 = 2171,
	STP_ISEN_1_A_MARK___3 = 2172,
	RIF1_D0_A_MARK___3 = 2173,
	RIF3_D0_A_MARK___4 = 2174,
	TCLK2_A_MARK___4 = 2175,
	IP17_23_20_MARK___3 = 2176,
	USB1_OVC_MARK___3 = 2177,
	MSIOF1_SS2_C_MARK___3 = 2178,
	SSI_WS1_A_MARK___3 = 2179,
	TS_SDAT0_E_MARK___3 = 2180,
	STP_ISD_0_E_MARK___3 = 2181,
	FMIN_B_MARK___4 = 2182,
	RIF2_SYNC_B_MARK___4 = 2183,
	REMOCON_B_MARK___4 = 2184,
	HCTS2_N_C_MARK___3 = 2185,
	IP16_27_24_MARK___3 = 2186,
	SSI_SDATA8_MARK___4 = 2187,
	HRTS2_N_B_MARK___3 = 2188,
	MSIOF1_TXD_C_MARK___3 = 2189,
	TS_SPSYNC1_A_MARK___3 = 2190,
	STP_ISSYNC_1_A_MARK___3 = 2191,
	RIF1_D1_A_MARK___3 = 2192,
	RIF3_D1_A_MARK___4 = 2193,
	IP17_27_24_MARK___3 = 2194,
	USB30_PWEN_MARK___4 = 2195,
	AUDIO_CLKOUT_B_MARK___4 = 2196,
	SSI_SCK2_B_MARK___4 = 2197,
	TS_SDEN1_D_MARK___3 = 2198,
	STP_ISEN_1_D_MARK___3 = 2199,
	STP_OPWM_0_E_MARK___3 = 2200,
	RIF3_D0_B_MARK___4 = 2201,
	TCLK2_B_MARK___4 = 2202,
	TPU0TO0_MARK___4 = 2203,
	BPFCLK_C_MARK___4 = 2204,
	HRTS2_N_C_MARK___3 = 2205,
	IP16_31_28_MARK___3 = 2206,
	SSI_SDATA9_A_MARK___3 = 2207,
	HSCK2_B_MARK___3 = 2208,
	MSIOF1_SS1_C_MARK___3 = 2209,
	HSCK1_A_MARK___4 = 2210,
	SSI_WS1_B_MARK___3 = 2211,
	SCK1_MARK___4 = 2212,
	STP_IVCXO27_1_A_MARK___3 = 2213,
	SCK5_A_MARK___4 = 2214,
	IP17_31_28_MARK___3 = 2215,
	USB30_OVC_MARK___4 = 2216,
	AUDIO_CLKOUT1_B_MARK___4 = 2217,
	SSI_WS2_B_MARK___4 = 2218,
	TS_SPSYNC1_D_MARK___3 = 2219,
	STP_ISSYNC_1_D_MARK___3 = 2220,
	STP_IVCXO27_0_E_MARK___3 = 2221,
	RIF3_D1_B_MARK___4 = 2222,
	FSO_TOE_N_MARK___3 = 2223,
	TPU0TO1_MARK___4 = 2224,
	SEL_MSIOF3_0_MARK___4 = 2225,
	SEL_MSIOF3_1_MARK___4 = 2226,
	SEL_MSIOF3_2_MARK___3 = 2227,
	SEL_MSIOF3_3_MARK___3 = 2228,
	SEL_MSIOF3_4_MARK___3 = 2229,
	SEL_TSIF1_0_MARK___3 = 2230,
	SEL_TSIF1_1_MARK___3 = 2231,
	SEL_TSIF1_2_MARK___3 = 2232,
	SEL_TSIF1_3_MARK___3 = 2233,
	I2C_SEL_5_0_MARK___3 = 2234,
	I2C_SEL_5_1_MARK___3 = 2235,
	I2C_SEL_3_0_MARK___3 = 2236,
	I2C_SEL_3_1_MARK___3 = 2237,
	SEL_TSIF0_0_MARK___3 = 2238,
	SEL_TSIF0_1_MARK___3 = 2239,
	SEL_TSIF0_2_MARK___3 = 2240,
	SEL_TSIF0_3_MARK___3 = 2241,
	SEL_TSIF0_4_MARK___3 = 2242,
	I2C_SEL_0_0_MARK___3 = 2243,
	I2C_SEL_0_1_MARK___3 = 2244,
	SEL_MSIOF2_0_MARK___4 = 2245,
	SEL_MSIOF2_1_MARK___4 = 2246,
	SEL_MSIOF2_2_MARK___3 = 2247,
	SEL_MSIOF2_3_MARK___3 = 2248,
	SEL_FM_0_MARK___4 = 2249,
	SEL_FM_1_MARK___4 = 2250,
	SEL_FM_2_MARK___4 = 2251,
	SEL_FM_3_MARK___3 = 2252,
	SEL_MSIOF1_0_MARK___3 = 2253,
	SEL_MSIOF1_1_MARK___3 = 2254,
	SEL_MSIOF1_2_MARK___3 = 2255,
	SEL_MSIOF1_3_MARK___3 = 2256,
	SEL_MSIOF1_4_MARK___3 = 2257,
	SEL_MSIOF1_5_MARK___3 = 2258,
	SEL_MSIOF1_6_MARK___3 = 2259,
	SEL_TIMER_TMU1_0_MARK = 2260,
	SEL_TIMER_TMU1_1_MARK = 2261,
	SEL_SCIF5_0_MARK___4 = 2262,
	SEL_SCIF5_1_MARK___4 = 2263,
	SEL_SSP1_1_0_MARK___3 = 2264,
	SEL_SSP1_1_1_MARK___3 = 2265,
	SEL_SSP1_1_2_MARK___3 = 2266,
	SEL_SSP1_1_3_MARK___3 = 2267,
	SEL_I2C6_0_MARK___4 = 2268,
	SEL_I2C6_1_MARK___4 = 2269,
	SEL_I2C6_2_MARK___3 = 2270,
	SEL_LBSC_0_MARK___3 = 2271,
	SEL_LBSC_1_MARK___3 = 2272,
	SEL_SSP1_0_0_MARK___3 = 2273,
	SEL_SSP1_0_1_MARK___3 = 2274,
	SEL_SSP1_0_2_MARK___3 = 2275,
	SEL_SSP1_0_3_MARK___3 = 2276,
	SEL_SSP1_0_4_MARK___3 = 2277,
	SEL_IEBUS_0_MARK___3 = 2278,
	SEL_IEBUS_1_MARK___3 = 2279,
	SEL_I2C2_0_MARK___4 = 2280,
	SEL_I2C2_1_MARK___4 = 2281,
	SEL_SSI2_0_MARK___4 = 2282,
	SEL_SSI2_1_MARK___4 = 2283,
	SEL_I2C1_0_MARK___4 = 2284,
	SEL_I2C1_1_MARK___4 = 2285,
	SEL_SSI1_0_MARK___3 = 2286,
	SEL_SSI1_1_MARK___3 = 2287,
	SEL_SSI9_0_MARK___4 = 2288,
	SEL_SSI9_1_MARK___4 = 2289,
	SEL_HSCIF4_0_MARK___4 = 2290,
	SEL_HSCIF4_1_MARK___4 = 2291,
	SEL_SPEED_PULSE_0_MARK___3 = 2292,
	SEL_SPEED_PULSE_1_MARK___3 = 2293,
	SEL_TIMER_TMU2_0_MARK___3 = 2294,
	SEL_TIMER_TMU2_1_MARK___3 = 2295,
	SEL_HSCIF3_0_MARK___4 = 2296,
	SEL_HSCIF3_1_MARK___4 = 2297,
	SEL_HSCIF3_2_MARK___4 = 2298,
	SEL_HSCIF3_3_MARK___4 = 2299,
	SEL_SIMCARD_0_MARK___4 = 2300,
	SEL_SIMCARD_1_MARK___4 = 2301,
	SEL_SIMCARD_2_MARK___3 = 2302,
	SEL_SIMCARD_3_MARK___3 = 2303,
	SEL_ADGB_0_MARK___4 = 2304,
	SEL_ADGB_1_MARK___4 = 2305,
	SEL_ADGC_0_MARK___4 = 2306,
	SEL_ADGC_1_MARK___4 = 2307,
	SEL_HSCIF1_0_MARK___4 = 2308,
	SEL_HSCIF1_1_MARK___4 = 2309,
	SEL_SDHI2_0_MARK___3 = 2310,
	SEL_SDHI2_1_MARK___3 = 2311,
	SEL_SCIF4_0_MARK___4 = 2312,
	SEL_SCIF4_1_MARK___4 = 2313,
	SEL_SCIF4_2_MARK___4 = 2314,
	SEL_HSCIF2_0_MARK___4 = 2315,
	SEL_HSCIF2_1_MARK___4 = 2316,
	SEL_HSCIF2_2_MARK___3 = 2317,
	SEL_SCIF3_0_MARK___4 = 2318,
	SEL_SCIF3_1_MARK___4 = 2319,
	SEL_ETHERAVB_0_MARK___3 = 2320,
	SEL_ETHERAVB_1_MARK___3 = 2321,
	SEL_SCIF2_0_MARK___4 = 2322,
	SEL_SCIF2_1_MARK___4 = 2323,
	SEL_DRIF3_0_MARK___4 = 2324,
	SEL_DRIF3_1_MARK___4 = 2325,
	SEL_SCIF1_0_MARK___3 = 2326,
	SEL_SCIF1_1_MARK___3 = 2327,
	SEL_DRIF2_0_MARK___4 = 2328,
	SEL_DRIF2_1_MARK___4 = 2329,
	SEL_SCIF_0_MARK___4 = 2330,
	SEL_SCIF_1_MARK___4 = 2331,
	SEL_DRIF1_0_MARK___3 = 2332,
	SEL_DRIF1_1_MARK___3 = 2333,
	SEL_DRIF1_2_MARK___3 = 2334,
	SEL_REMOCON_0_MARK___4 = 2335,
	SEL_REMOCON_1_MARK___4 = 2336,
	SEL_DRIF0_0_MARK___4 = 2337,
	SEL_DRIF0_1_MARK___4 = 2338,
	SEL_DRIF0_2_MARK___3 = 2339,
	SEL_RCAN0_0_MARK___3 = 2340,
	SEL_RCAN0_1_MARK___3 = 2341,
	SEL_CANFD0_0_MARK___3 = 2342,
	SEL_CANFD0_1_MARK___3 = 2343,
	SEL_PWM6_0_MARK___4 = 2344,
	SEL_PWM6_1_MARK___4 = 2345,
	SEL_ADGA_0_MARK___3 = 2346,
	SEL_ADGA_1_MARK___3 = 2347,
	SEL_ADGA_2_MARK___3 = 2348,
	SEL_ADGA_3_MARK___3 = 2349,
	SEL_PWM5_0_MARK___4 = 2350,
	SEL_PWM5_1_MARK___4 = 2351,
	SEL_PWM4_0_MARK___4 = 2352,
	SEL_PWM4_1_MARK___4 = 2353,
	SEL_PWM3_0_MARK___4 = 2354,
	SEL_PWM3_1_MARK___4 = 2355,
	SEL_PWM2_0_MARK___4 = 2356,
	SEL_PWM2_1_MARK___4 = 2357,
	SEL_PWM1_0_MARK___4 = 2358,
	SEL_PWM1_1_MARK___4 = 2359,
	SEL_VIN4_0_MARK___4 = 2360,
	SEL_VIN4_1_MARK___4 = 2361,
	QSPI0_SPCLK_MARK___4 = 2362,
	QSPI0_SSL_MARK___4 = 2363,
	QSPI0_MOSI_IO0_MARK___4 = 2364,
	QSPI0_MISO_IO1_MARK___4 = 2365,
	QSPI0_IO2_MARK___4 = 2366,
	QSPI0_IO3_MARK___4 = 2367,
	QSPI1_SPCLK_MARK___4 = 2368,
	QSPI1_SSL_MARK___4 = 2369,
	QSPI1_MOSI_IO0_MARK___4 = 2370,
	QSPI1_MISO_IO1_MARK___4 = 2371,
	QSPI1_IO2_MARK___4 = 2372,
	QSPI1_IO3_MARK___4 = 2373,
	RPC_INT_MARK___3 = 2374,
	RPC_WP_MARK___3 = 2375,
	RPC_RESET_MARK___3 = 2376,
	AVB_TX_CTL_MARK___4 = 2377,
	AVB_TXC_MARK___4 = 2378,
	AVB_TD0_MARK___4 = 2379,
	AVB_TD1_MARK___4 = 2380,
	AVB_TD2_MARK___4 = 2381,
	AVB_TD3_MARK___4 = 2382,
	AVB_RX_CTL_MARK___4 = 2383,
	AVB_RXC_MARK___4 = 2384,
	AVB_RD0_MARK___4 = 2385,
	AVB_RD1_MARK___4 = 2386,
	AVB_RD2_MARK___4 = 2387,
	AVB_RD3_MARK___4 = 2388,
	AVB_TXCREFCLK_MARK___4 = 2389,
	AVB_MDIO_MARK___4 = 2390,
	PRESETOUT_MARK___3 = 2391,
	DU_DOTCLKIN0_MARK___4 = 2392,
	DU_DOTCLKIN1_MARK___4 = 2393,
	DU_DOTCLKIN2_MARK___2 = 2394,
	DU_DOTCLKIN3_MARK___2 = 2395,
	TMS_MARK___4 = 2396,
	TDO_MARK___3 = 2397,
	ASEBRK_MARK___4 = 2398,
	MLB_REF_MARK___4 = 2399,
	TDI_MARK___4 = 2400,
	TCK_MARK___4 = 2401,
	TRST_MARK___3 = 2402,
	EXTALR_MARK___3 = 2403,
	SCL0_MARK___3 = 2404,
	SDA0_MARK___3 = 2405,
	SCL3_MARK___3 = 2406,
	SDA3_MARK___3 = 2407,
	SCL5_MARK___4 = 2408,
	SDA5_MARK___4 = 2409,
	PINMUX_MARK_END___4 = 2410,
};

enum {
	GP_LAST___4 = 227,
	PIN_ASEBRK___4 = 228,
	PIN_AVB_MDIO___4 = 229,
	PIN_AVB_RD0___3 = 230,
	PIN_AVB_RD1___3 = 231,
	PIN_AVB_RD2___3 = 232,
	PIN_AVB_RD3___3 = 233,
	PIN_AVB_RXC___3 = 234,
	PIN_AVB_RX_CTL___3 = 235,
	PIN_AVB_TD0___4 = 236,
	PIN_AVB_TD1___4 = 237,
	PIN_AVB_TD2___4 = 238,
	PIN_AVB_TD3___4 = 239,
	PIN_AVB_TXC___4 = 240,
	PIN_AVB_TXCREFCLK___3 = 241,
	PIN_AVB_TX_CTL___4 = 242,
	PIN_DU_DOTCLKIN0___3 = 243,
	PIN_DU_DOTCLKIN1___3 = 244,
	PIN_DU_DOTCLKIN2___2 = 245,
	PIN_DU_DOTCLKIN3___2 = 246,
	PIN_EXTALR___3 = 247,
	PIN_FSCLKST_N___2 = 248,
	PIN_MLB_REF___4 = 249,
	PIN_PRESETOUT_N___4 = 250,
	PIN_QSPI0_IO2___3 = 251,
	PIN_QSPI0_IO3___3 = 252,
	PIN_QSPI0_MISO_IO1___3 = 253,
	PIN_QSPI0_MOSI_IO0___3 = 254,
	PIN_QSPI0_SPCLK___3 = 255,
	PIN_QSPI0_SSL___3 = 256,
	PIN_QSPI1_IO2___3 = 257,
	PIN_QSPI1_IO3___3 = 258,
	PIN_QSPI1_MISO_IO1___3 = 259,
	PIN_QSPI1_MOSI_IO0___3 = 260,
	PIN_QSPI1_SPCLK___3 = 261,
	PIN_QSPI1_SSL___3 = 262,
	PIN_RPC_INT_N___3 = 263,
	PIN_RPC_RESET_N___3 = 264,
	PIN_RPC_WP_N___3 = 265,
	PIN_TCK___4 = 266,
	PIN_TDI___4 = 267,
	PIN_TDO___3 = 268,
	PIN_TMS___4 = 269,
	PIN_TRST_N___4 = 270,
};

enum {
	PINMUX_RESERVED___5 = 0,
	PINMUX_DATA_BEGIN___5 = 1,
	GP_0_0_DATA___5 = 2,
	GP_0_1_DATA___5 = 3,
	GP_0_2_DATA___5 = 4,
	GP_0_3_DATA___5 = 5,
	GP_0_4_DATA___5 = 6,
	GP_0_5_DATA___5 = 7,
	GP_0_6_DATA___5 = 8,
	GP_0_7_DATA___5 = 9,
	GP_0_8_DATA___5 = 10,
	GP_0_9_DATA___5 = 11,
	GP_0_10_DATA___5 = 12,
	GP_0_11_DATA___5 = 13,
	GP_0_12_DATA___5 = 14,
	GP_0_13_DATA___5 = 15,
	GP_0_14_DATA___5 = 16,
	GP_0_15_DATA___5 = 17,
	GP_1_0_DATA___5 = 18,
	GP_1_1_DATA___5 = 19,
	GP_1_2_DATA___5 = 20,
	GP_1_3_DATA___5 = 21,
	GP_1_4_DATA___5 = 22,
	GP_1_5_DATA___5 = 23,
	GP_1_6_DATA___5 = 24,
	GP_1_7_DATA___5 = 25,
	GP_1_8_DATA___5 = 26,
	GP_1_9_DATA___5 = 27,
	GP_1_10_DATA___5 = 28,
	GP_1_11_DATA___5 = 29,
	GP_1_12_DATA___5 = 30,
	GP_1_13_DATA___5 = 31,
	GP_1_14_DATA___5 = 32,
	GP_1_15_DATA___5 = 33,
	GP_1_16_DATA___5 = 34,
	GP_1_17_DATA___5 = 35,
	GP_1_18_DATA___5 = 36,
	GP_1_19_DATA___5 = 37,
	GP_1_20_DATA___5 = 38,
	GP_1_21_DATA___5 = 39,
	GP_1_22_DATA___5 = 40,
	GP_1_23_DATA___4 = 41,
	GP_1_24_DATA___4 = 42,
	GP_1_25_DATA___4 = 43,
	GP_1_26_DATA___4 = 44,
	GP_1_27_DATA___4 = 45,
	GP_2_0_DATA___5 = 46,
	GP_2_1_DATA___5 = 47,
	GP_2_2_DATA___5 = 48,
	GP_2_3_DATA___5 = 49,
	GP_2_4_DATA___5 = 50,
	GP_2_5_DATA___5 = 51,
	GP_2_6_DATA___5 = 52,
	GP_2_7_DATA___5 = 53,
	GP_2_8_DATA___5 = 54,
	GP_2_9_DATA___5 = 55,
	GP_2_10_DATA___5 = 56,
	GP_2_11_DATA___5 = 57,
	GP_2_12_DATA___5 = 58,
	GP_2_13_DATA___5 = 59,
	GP_2_14_DATA___5 = 60,
	GP_3_0_DATA___5 = 61,
	GP_3_1_DATA___5 = 62,
	GP_3_2_DATA___5 = 63,
	GP_3_3_DATA___5 = 64,
	GP_3_4_DATA___5 = 65,
	GP_3_5_DATA___5 = 66,
	GP_3_6_DATA___5 = 67,
	GP_3_7_DATA___5 = 68,
	GP_3_8_DATA___5 = 69,
	GP_3_9_DATA___5 = 70,
	GP_3_10_DATA___5 = 71,
	GP_3_11_DATA___5 = 72,
	GP_3_12_DATA___5 = 73,
	GP_3_13_DATA___5 = 74,
	GP_3_14_DATA___5 = 75,
	GP_3_15_DATA___5 = 76,
	GP_4_0_DATA___5 = 77,
	GP_4_1_DATA___5 = 78,
	GP_4_2_DATA___5 = 79,
	GP_4_3_DATA___5 = 80,
	GP_4_4_DATA___5 = 81,
	GP_4_5_DATA___5 = 82,
	GP_4_6_DATA___5 = 83,
	GP_4_7_DATA___5 = 84,
	GP_4_8_DATA___5 = 85,
	GP_4_9_DATA___5 = 86,
	GP_4_10_DATA___5 = 87,
	GP_4_11_DATA___4 = 88,
	GP_4_12_DATA___4 = 89,
	GP_4_13_DATA___4 = 90,
	GP_4_14_DATA___4 = 91,
	GP_4_15_DATA___4 = 92,
	GP_4_16_DATA___4 = 93,
	GP_4_17_DATA___4 = 94,
	GP_5_0_DATA___5 = 95,
	GP_5_1_DATA___5 = 96,
	GP_5_2_DATA___5 = 97,
	GP_5_3_DATA___5 = 98,
	GP_5_4_DATA___5 = 99,
	GP_5_5_DATA___5 = 100,
	GP_5_6_DATA___5 = 101,
	GP_5_7_DATA___5 = 102,
	GP_5_8_DATA___5 = 103,
	GP_5_9_DATA___5 = 104,
	GP_5_10_DATA___5 = 105,
	GP_5_11_DATA___5 = 106,
	GP_5_12_DATA___5 = 107,
	GP_5_13_DATA___5 = 108,
	GP_5_14_DATA___5 = 109,
	GP_5_15_DATA___5 = 110,
	GP_5_16_DATA___5 = 111,
	GP_5_17_DATA___5 = 112,
	GP_5_18_DATA___5 = 113,
	GP_5_19_DATA___5 = 114,
	GP_5_20_DATA___4 = 115,
	GP_5_21_DATA___4 = 116,
	GP_5_22_DATA___4 = 117,
	GP_5_23_DATA___4 = 118,
	GP_5_24_DATA___4 = 119,
	GP_5_25_DATA___4 = 120,
	GP_6_0_DATA___5 = 121,
	GP_6_1_DATA___5 = 122,
	GP_6_2_DATA___5 = 123,
	GP_6_3_DATA___5 = 124,
	GP_6_4_DATA___5 = 125,
	GP_6_5_DATA___5 = 126,
	GP_6_6_DATA___5 = 127,
	GP_6_7_DATA___5 = 128,
	GP_6_8_DATA___5 = 129,
	GP_6_9_DATA___5 = 130,
	GP_6_10_DATA___5 = 131,
	GP_6_11_DATA___5 = 132,
	GP_6_12_DATA___5 = 133,
	GP_6_13_DATA___5 = 134,
	GP_6_14_DATA___5 = 135,
	GP_6_15_DATA___5 = 136,
	GP_6_16_DATA___5 = 137,
	GP_6_17_DATA___5 = 138,
	GP_6_18_DATA___4 = 139,
	GP_6_19_DATA___4 = 140,
	GP_6_20_DATA___4 = 141,
	GP_6_21_DATA___4 = 142,
	GP_6_22_DATA___4 = 143,
	GP_6_23_DATA___4 = 144,
	GP_6_24_DATA___4 = 145,
	GP_6_25_DATA___4 = 146,
	GP_6_26_DATA___4 = 147,
	GP_6_27_DATA___4 = 148,
	GP_6_28_DATA___4 = 149,
	GP_6_29_DATA___4 = 150,
	GP_6_30_DATA___4 = 151,
	GP_6_31_DATA___4 = 152,
	GP_7_0_DATA___4 = 153,
	GP_7_1_DATA___4 = 154,
	GP_7_2_DATA___4 = 155,
	GP_7_3_DATA___4 = 156,
	PINMUX_DATA_END___5 = 157,
	PINMUX_FUNCTION_BEGIN___5 = 158,
	GP_0_0_FN___5 = 159,
	GP_0_1_FN___5 = 160,
	GP_0_2_FN___5 = 161,
	GP_0_3_FN___5 = 162,
	GP_0_4_FN___5 = 163,
	GP_0_5_FN___5 = 164,
	GP_0_6_FN___5 = 165,
	GP_0_7_FN___5 = 166,
	GP_0_8_FN___5 = 167,
	GP_0_9_FN___5 = 168,
	GP_0_10_FN___5 = 169,
	GP_0_11_FN___5 = 170,
	GP_0_12_FN___5 = 171,
	GP_0_13_FN___5 = 172,
	GP_0_14_FN___5 = 173,
	GP_0_15_FN___5 = 174,
	GP_1_0_FN___5 = 175,
	GP_1_1_FN___5 = 176,
	GP_1_2_FN___5 = 177,
	GP_1_3_FN___5 = 178,
	GP_1_4_FN___5 = 179,
	GP_1_5_FN___5 = 180,
	GP_1_6_FN___5 = 181,
	GP_1_7_FN___5 = 182,
	GP_1_8_FN___5 = 183,
	GP_1_9_FN___5 = 184,
	GP_1_10_FN___5 = 185,
	GP_1_11_FN___5 = 186,
	GP_1_12_FN___5 = 187,
	GP_1_13_FN___5 = 188,
	GP_1_14_FN___5 = 189,
	GP_1_15_FN___5 = 190,
	GP_1_16_FN___5 = 191,
	GP_1_17_FN___5 = 192,
	GP_1_18_FN___5 = 193,
	GP_1_19_FN___5 = 194,
	GP_1_20_FN___5 = 195,
	GP_1_21_FN___5 = 196,
	GP_1_22_FN___5 = 197,
	GP_1_23_FN___4 = 198,
	GP_1_24_FN___4 = 199,
	GP_1_25_FN___4 = 200,
	GP_1_26_FN___4 = 201,
	GP_1_27_FN___4 = 202,
	GP_2_0_FN___5 = 203,
	GP_2_1_FN___5 = 204,
	GP_2_2_FN___5 = 205,
	GP_2_3_FN___5 = 206,
	GP_2_4_FN___5 = 207,
	GP_2_5_FN___5 = 208,
	GP_2_6_FN___5 = 209,
	GP_2_7_FN___5 = 210,
	GP_2_8_FN___5 = 211,
	GP_2_9_FN___5 = 212,
	GP_2_10_FN___5 = 213,
	GP_2_11_FN___5 = 214,
	GP_2_12_FN___5 = 215,
	GP_2_13_FN___5 = 216,
	GP_2_14_FN___5 = 217,
	GP_3_0_FN___5 = 218,
	GP_3_1_FN___5 = 219,
	GP_3_2_FN___5 = 220,
	GP_3_3_FN___5 = 221,
	GP_3_4_FN___5 = 222,
	GP_3_5_FN___5 = 223,
	GP_3_6_FN___5 = 224,
	GP_3_7_FN___5 = 225,
	GP_3_8_FN___5 = 226,
	GP_3_9_FN___5 = 227,
	GP_3_10_FN___5 = 228,
	GP_3_11_FN___5 = 229,
	GP_3_12_FN___5 = 230,
	GP_3_13_FN___5 = 231,
	GP_3_14_FN___5 = 232,
	GP_3_15_FN___5 = 233,
	GP_4_0_FN___5 = 234,
	GP_4_1_FN___5 = 235,
	GP_4_2_FN___5 = 236,
	GP_4_3_FN___5 = 237,
	GP_4_4_FN___5 = 238,
	GP_4_5_FN___5 = 239,
	GP_4_6_FN___5 = 240,
	GP_4_7_FN___5 = 241,
	GP_4_8_FN___5 = 242,
	GP_4_9_FN___5 = 243,
	GP_4_10_FN___5 = 244,
	GP_4_11_FN___4 = 245,
	GP_4_12_FN___4 = 246,
	GP_4_13_FN___4 = 247,
	GP_4_14_FN___4 = 248,
	GP_4_15_FN___4 = 249,
	GP_4_16_FN___4 = 250,
	GP_4_17_FN___4 = 251,
	GP_5_0_FN___5 = 252,
	GP_5_1_FN___5 = 253,
	GP_5_2_FN___5 = 254,
	GP_5_3_FN___5 = 255,
	GP_5_4_FN___5 = 256,
	GP_5_5_FN___5 = 257,
	GP_5_6_FN___5 = 258,
	GP_5_7_FN___5 = 259,
	GP_5_8_FN___5 = 260,
	GP_5_9_FN___5 = 261,
	GP_5_10_FN___5 = 262,
	GP_5_11_FN___5 = 263,
	GP_5_12_FN___5 = 264,
	GP_5_13_FN___5 = 265,
	GP_5_14_FN___5 = 266,
	GP_5_15_FN___5 = 267,
	GP_5_16_FN___5 = 268,
	GP_5_17_FN___5 = 269,
	GP_5_18_FN___5 = 270,
	GP_5_19_FN___5 = 271,
	GP_5_20_FN___4 = 272,
	GP_5_21_FN___4 = 273,
	GP_5_22_FN___4 = 274,
	GP_5_23_FN___4 = 275,
	GP_5_24_FN___4 = 276,
	GP_5_25_FN___4 = 277,
	GP_6_0_FN___5 = 278,
	GP_6_1_FN___5 = 279,
	GP_6_2_FN___5 = 280,
	GP_6_3_FN___5 = 281,
	GP_6_4_FN___5 = 282,
	GP_6_5_FN___5 = 283,
	GP_6_6_FN___5 = 284,
	GP_6_7_FN___5 = 285,
	GP_6_8_FN___5 = 286,
	GP_6_9_FN___5 = 287,
	GP_6_10_FN___5 = 288,
	GP_6_11_FN___5 = 289,
	GP_6_12_FN___5 = 290,
	GP_6_13_FN___5 = 291,
	GP_6_14_FN___5 = 292,
	GP_6_15_FN___5 = 293,
	GP_6_16_FN___5 = 294,
	GP_6_17_FN___5 = 295,
	GP_6_18_FN___4 = 296,
	GP_6_19_FN___4 = 297,
	GP_6_20_FN___4 = 298,
	GP_6_21_FN___4 = 299,
	GP_6_22_FN___4 = 300,
	GP_6_23_FN___4 = 301,
	GP_6_24_FN___4 = 302,
	GP_6_25_FN___4 = 303,
	GP_6_26_FN___4 = 304,
	GP_6_27_FN___4 = 305,
	GP_6_28_FN___4 = 306,
	GP_6_29_FN___4 = 307,
	GP_6_30_FN___4 = 308,
	GP_6_31_FN___4 = 309,
	GP_7_0_FN___4 = 310,
	GP_7_1_FN___4 = 311,
	GP_7_2_FN___4 = 312,
	GP_7_3_FN___4 = 313,
	FN_MSIOF0_RXD___5 = 314,
	FN_MSIOF0_TXD___5 = 315,
	FN_SD3_DS___5 = 316,
	FN_MSIOF0_SCK___5 = 317,
	FN_SSI_SDATA5___5 = 318,
	FN_SD3_DAT3___5 = 319,
	FN_SSI_WS5___5 = 320,
	FN_SD3_DAT2___5 = 321,
	FN_SSI_SCK5___5 = 322,
	FN_SD3_DAT1___5 = 323,
	FN_SD3_DAT0___5 = 324,
	FN_SD3_CMD___5 = 325,
	FN_SD3_CLK___5 = 326,
	FN_GP7_03___4 = 327,
	FN_GP7_02___4 = 328,
	FN_SD2_CMD___4 = 329,
	FN_AVS2___4 = 330,
	FN_AVS1___4 = 331,
	FN_IP0_3_0___5 = 332,
	FN_AVB_MDC___5 = 333,
	FN_MSIOF2_SS2_C___4 = 334,
	FN_IP1_3_0___5 = 335,
	FN_IRQ2___5 = 336,
	FN_QCPV_QDE___5 = 337,
	FN_DU_EXODDF_DU_ODDF_DISP_CDE___4 = 338,
	FN_VI4_DATA2_B___5 = 339,
	FN_PWM3_B___5 = 340,
	FN_IP2_3_0___5 = 341,
	FN_A1___5 = 342,
	FN_LCDOUT17___5 = 343,
	FN_MSIOF3_TXD_B___5 = 344,
	FN_VI4_DATA9___5 = 345,
	FN_DU_DB1___5 = 346,
	FN_PWM4_A___5 = 347,
	FN_IP3_3_0___5 = 348,
	FN_A9___5 = 349,
	FN_MSIOF2_SCK_A___5 = 350,
	FN_CTS4_N_B___4 = 351,
	FN_VI5_VSYNC_N___4 = 352,
	FN_IP0_7_4___5 = 353,
	FN_AVB_MAGIC___5 = 354,
	FN_MSIOF2_SS1_C___4 = 355,
	FN_SCK4_A___5 = 356,
	FN_IP1_7_4___5 = 357,
	FN_IRQ3___5 = 358,
	FN_QSTVB_QVE___5 = 359,
	FN_A25 = 360,
	FN_DU_DOTCLKOUT1___4 = 361,
	FN_VI4_DATA3_B___5 = 362,
	FN_PWM4_B___5 = 363,
	FN_IP2_7_4___5 = 364,
	FN_A2___5 = 365,
	FN_LCDOUT18___5 = 366,
	FN_MSIOF3_SCK_B___5 = 367,
	FN_VI4_DATA10___5 = 368,
	FN_DU_DB2___5 = 369,
	FN_PWM5_A___5 = 370,
	FN_IP3_7_4___5 = 371,
	FN_A10___5 = 372,
	FN_MSIOF2_RXD_A___5 = 373,
	FN_RTS4_N_B___4 = 374,
	FN_VI5_HSYNC_N___4 = 375,
	FN_IP0_11_8___5 = 376,
	FN_AVB_PHY_INT___5 = 377,
	FN_MSIOF2_SYNC_C___4 = 378,
	FN_RX4_A___5 = 379,
	FN_IP1_11_8___5 = 380,
	FN_IRQ4___5 = 381,
	FN_QSTH_QHS___5 = 382,
	FN_A24 = 383,
	FN_DU_EXHSYNC_DU_HSYNC___4 = 384,
	FN_VI4_DATA4_B___5 = 385,
	FN_PWM5_B___5 = 386,
	FN_IP2_11_8___5 = 387,
	FN_A3___5 = 388,
	FN_LCDOUT19___5 = 389,
	FN_MSIOF3_RXD_B___5 = 390,
	FN_VI4_DATA11___5 = 391,
	FN_DU_DB3___5 = 392,
	FN_PWM6_A___5 = 393,
	FN_IP3_11_8___5 = 394,
	FN_A11___5 = 395,
	FN_TX3_B___5 = 396,
	FN_MSIOF2_TXD_A___5 = 397,
	FN_HTX4_B___5 = 398,
	FN_HSCK4___4 = 399,
	FN_VI5_FIELD___4 = 400,
	FN_SCL6_A___5 = 401,
	FN_AVB_AVTP_CAPTURE_B___4 = 402,
	FN_PWM2_B___5 = 403,
	FN_IP0_15_12___5 = 404,
	FN_AVB_LINK___5 = 405,
	FN_MSIOF2_SCK_C___4 = 406,
	FN_TX4_A___5 = 407,
	FN_IP1_15_12___5 = 408,
	FN_IRQ5___5 = 409,
	FN_QSTB_QHE___5 = 410,
	FN_A23 = 411,
	FN_DU_EXVSYNC_DU_VSYNC___4 = 412,
	FN_VI4_DATA5_B___5 = 413,
	FN_PWM6_B___5 = 414,
	FN_IP2_15_12___5 = 415,
	FN_A4___5 = 416,
	FN_LCDOUT20___5 = 417,
	FN_MSIOF3_SS1_B___5 = 418,
	FN_VI4_DATA12___5 = 419,
	FN_VI5_DATA12___4 = 420,
	FN_DU_DB4___5 = 421,
	FN_IP3_15_12___5 = 422,
	FN_A12___5 = 423,
	FN_LCDOUT12___5 = 424,
	FN_MSIOF3_SCK_C___4 = 425,
	FN_HRX4_A___5 = 426,
	FN_VI5_DATA8___4 = 427,
	FN_DU_DG4___5 = 428,
	FN_IP0_19_16___5 = 429,
	FN_AVB_AVTP_MATCH_A___4 = 430,
	FN_MSIOF2_RXD_C___4 = 431,
	FN_CTS4_N_A___5 = 432,
	FN_IP1_19_16___5 = 433,
	FN_PWM0___4 = 434,
	FN_AVB_AVTP_PPS___5 = 435,
	FN_A22 = 436,
	FN_VI4_DATA6_B___5 = 437,
	FN_IECLK_B___4 = 438,
	FN_IP2_19_16___5 = 439,
	FN_A5___5 = 440,
	FN_LCDOUT21___5 = 441,
	FN_MSIOF3_SS2_B___4 = 442,
	FN_SCK4_B___5 = 443,
	FN_VI4_DATA13___5 = 444,
	FN_VI5_DATA13___4 = 445,
	FN_DU_DB5___5 = 446,
	FN_IP3_19_16___5 = 447,
	FN_A13___5 = 448,
	FN_LCDOUT13___5 = 449,
	FN_MSIOF3_SYNC_C___4 = 450,
	FN_HTX4_A___5 = 451,
	FN_VI5_DATA9___4 = 452,
	FN_DU_DG5___5 = 453,
	FN_IP0_23_20___5 = 454,
	FN_AVB_AVTP_CAPTURE_A___4 = 455,
	FN_MSIOF2_TXD_C___4 = 456,
	FN_RTS4_N_A___5 = 457,
	FN_IP1_23_20___5 = 458,
	FN_PWM1_A___5 = 459,
	FN_A21 = 460,
	FN_HRX3_D___5 = 461,
	FN_VI4_DATA7_B___5 = 462,
	FN_IERX_B___4 = 463,
	FN_IP2_23_20___5 = 464,
	FN_A6___5 = 465,
	FN_LCDOUT22___5 = 466,
	FN_MSIOF2_SS1_A___5 = 467,
	FN_RX4_B___5 = 468,
	FN_VI4_DATA14___5 = 469,
	FN_VI5_DATA14___4 = 470,
	FN_DU_DB6___5 = 471,
	FN_IP3_23_20___5 = 472,
	FN_A14___5 = 473,
	FN_LCDOUT14___5 = 474,
	FN_MSIOF3_RXD_C___4 = 475,
	FN_HCTS4_N___4 = 476,
	FN_VI5_DATA10___4 = 477,
	FN_DU_DG6___5 = 478,
	FN_IP0_27_24___5 = 479,
	FN_IRQ0___5 = 480,
	FN_QPOLB___5 = 481,
	FN_DU_CDE___5 = 482,
	FN_VI4_DATA0_B___5 = 483,
	FN_CAN0_TX_B___4 = 484,
	FN_CANFD0_TX_B___4 = 485,
	FN_IP1_27_24___5 = 486,
	FN_PWM2_A___5 = 487,
	FN_A20 = 488,
	FN_HTX3_D___5 = 489,
	FN_IETX_B___4 = 490,
	FN_IP2_27_24___5 = 491,
	FN_A7___5 = 492,
	FN_LCDOUT23___5 = 493,
	FN_MSIOF2_SS2_A___5 = 494,
	FN_TX4_B___5 = 495,
	FN_VI4_DATA15___5 = 496,
	FN_VI5_DATA15___4 = 497,
	FN_DU_DB7___5 = 498,
	FN_IP3_27_24___5 = 499,
	FN_A15___5 = 500,
	FN_LCDOUT15___5 = 501,
	FN_MSIOF3_TXD_C___4 = 502,
	FN_HRTS4_N___4 = 503,
	FN_VI5_DATA11___4 = 504,
	FN_DU_DG7___5 = 505,
	FN_IP0_31_28___5 = 506,
	FN_IRQ1___5 = 507,
	FN_QPOLA___5 = 508,
	FN_DU_DISP___5 = 509,
	FN_VI4_DATA1_B___5 = 510,
	FN_CAN0_RX_B___4 = 511,
	FN_CANFD0_RX_B___4 = 512,
	FN_IP1_31_28___5 = 513,
	FN_A0___5 = 514,
	FN_LCDOUT16___5 = 515,
	FN_MSIOF3_SYNC_B___5 = 516,
	FN_VI4_DATA8___5 = 517,
	FN_DU_DB0___5 = 518,
	FN_PWM3_A___5 = 519,
	FN_IP2_31_28___5 = 520,
	FN_A8___5 = 521,
	FN_RX3_B___5 = 522,
	FN_MSIOF2_SYNC_A___5 = 523,
	FN_HRX4_B___5 = 524,
	FN_SDA6_A___5 = 525,
	FN_AVB_AVTP_MATCH_B___4 = 526,
	FN_PWM1_B___5 = 527,
	FN_IP3_31_28___5 = 528,
	FN_A16___5 = 529,
	FN_LCDOUT8___5 = 530,
	FN_VI4_FIELD___5 = 531,
	FN_DU_DG0___5 = 532,
	FN_IP4_3_0___5 = 533,
	FN_A17___5 = 534,
	FN_LCDOUT9___5 = 535,
	FN_VI4_VSYNC_N___5 = 536,
	FN_DU_DG1___5 = 537,
	FN_IP5_3_0___5 = 538,
	FN_WE0_N___5 = 539,
	FN_MSIOF3_TXD_D___4 = 540,
	FN_CTS3_N___4 = 541,
	FN_HCTS3_N___4 = 542,
	FN_SCL6_B___5 = 543,
	FN_CAN_CLK___5 = 544,
	FN_IECLK_A___4 = 545,
	FN_IP6_3_0___5 = 546,
	FN_D5___5 = 547,
	FN_MSIOF2_SYNC_B___5 = 548,
	FN_VI4_DATA21___5 = 549,
	FN_VI5_DATA5___4 = 550,
	FN_IP7_3_0___5 = 551,
	FN_D13___5 = 552,
	FN_LCDOUT5___5 = 553,
	FN_MSIOF2_SS2_D___4 = 554,
	FN_TX4_C___5 = 555,
	FN_VI4_DATA5_A___5 = 556,
	FN_DU_DR5___5 = 557,
	FN_IP4_7_4___5 = 558,
	FN_A18___5 = 559,
	FN_LCDOUT10___5 = 560,
	FN_VI4_HSYNC_N___5 = 561,
	FN_DU_DG2___5 = 562,
	FN_IP5_7_4___5 = 563,
	FN_WE1_N___5 = 564,
	FN_MSIOF3_SS1_D___4 = 565,
	FN_RTS3_N___4 = 566,
	FN_HRTS3_N___4 = 567,
	FN_SDA6_B___5 = 568,
	FN_CAN1_RX___5 = 569,
	FN_CANFD1_RX___5 = 570,
	FN_IERX_A___4 = 571,
	FN_IP6_7_4___5 = 572,
	FN_D6___5 = 573,
	FN_MSIOF2_RXD_B___5 = 574,
	FN_VI4_DATA22___5 = 575,
	FN_VI5_DATA6___4 = 576,
	FN_IP7_7_4___5 = 577,
	FN_D14___5 = 578,
	FN_LCDOUT6___5 = 579,
	FN_MSIOF3_SS1_A___5 = 580,
	FN_HRX3_C___5 = 581,
	FN_VI4_DATA6_A___5 = 582,
	FN_DU_DR6___5 = 583,
	FN_SCL6_C___4 = 584,
	FN_IP4_11_8___5 = 585,
	FN_A19___5 = 586,
	FN_LCDOUT11___5 = 587,
	FN_VI4_CLKENB___5 = 588,
	FN_DU_DG3___5 = 589,
	FN_IP5_11_8___5 = 590,
	FN_EX_WAIT0_A___4 = 591,
	FN_QCLK___5 = 592,
	FN_VI4_CLK___5 = 593,
	FN_DU_DOTCLKOUT0___5 = 594,
	FN_IP6_11_8___5 = 595,
	FN_D7___5 = 596,
	FN_MSIOF2_TXD_B___5 = 597,
	FN_VI4_DATA23___5 = 598,
	FN_VI5_DATA7___4 = 599,
	FN_IP7_11_8___5 = 600,
	FN_D15___5 = 601,
	FN_LCDOUT7___5 = 602,
	FN_MSIOF3_SS2_A___5 = 603,
	FN_HTX3_C___5 = 604,
	FN_VI4_DATA7_A___5 = 605,
	FN_DU_DR7___5 = 606,
	FN_SDA6_C___4 = 607,
	FN_IP4_15_12___5 = 608,
	FN_CS0_N___5 = 609,
	FN_VI5_CLKENB___4 = 610,
	FN_IP5_15_12___5 = 611,
	FN_D0___5 = 612,
	FN_MSIOF2_SS1_B___5 = 613,
	FN_MSIOF3_SCK_A___5 = 614,
	FN_VI4_DATA16___5 = 615,
	FN_VI5_DATA0___4 = 616,
	FN_IP6_15_12___5 = 617,
	FN_D8___5 = 618,
	FN_LCDOUT0___5 = 619,
	FN_MSIOF2_SCK_D___4 = 620,
	FN_SCK4_C___4 = 621,
	FN_VI4_DATA0_A___5 = 622,
	FN_DU_DR0___5 = 623,
	FN_IP7_15_12___2 = 624,
	FN_FSCLKST = 625,
	FN_IP4_19_16___5 = 626,
	FN_CS1_N_A26___2 = 627,
	FN_VI5_CLK___4 = 628,
	FN_EX_WAIT0_B___4 = 629,
	FN_IP5_19_16___5 = 630,
	FN_D1___5 = 631,
	FN_MSIOF2_SS2_B___5 = 632,
	FN_MSIOF3_SYNC_A___5 = 633,
	FN_VI4_DATA17___5 = 634,
	FN_VI5_DATA1___4 = 635,
	FN_IP6_19_16___5 = 636,
	FN_D9___5 = 637,
	FN_LCDOUT1___5 = 638,
	FN_MSIOF2_SYNC_D___4 = 639,
	FN_VI4_DATA1_A___5 = 640,
	FN_DU_DR1___5 = 641,
	FN_IP7_19_16___5 = 642,
	FN_SD0_CLK___5 = 643,
	FN_MSIOF1_SCK_E___4 = 644,
	FN_STP_OPWM_0_B___4 = 645,
	FN_IP4_23_20___5 = 646,
	FN_BS_N___5 = 647,
	FN_QSTVA_QVS___5 = 648,
	FN_MSIOF3_SCK_D___4 = 649,
	FN_SCK3___4 = 650,
	FN_HSCK3___4 = 651,
	FN_CAN1_TX___5 = 652,
	FN_CANFD1_TX___5 = 653,
	FN_IETX_A___4 = 654,
	FN_IP5_23_20___5 = 655,
	FN_D2___5 = 656,
	FN_MSIOF3_RXD_A___5 = 657,
	FN_VI4_DATA18___5 = 658,
	FN_VI5_DATA2___4 = 659,
	FN_IP6_23_20___5 = 660,
	FN_D10___5 = 661,
	FN_LCDOUT2___5 = 662,
	FN_MSIOF2_RXD_D___4 = 663,
	FN_HRX3_B___5 = 664,
	FN_VI4_DATA2_A___5 = 665,
	FN_CTS4_N_C___5 = 666,
	FN_DU_DR2___5 = 667,
	FN_IP7_23_20___5 = 668,
	FN_SD0_CMD___5 = 669,
	FN_MSIOF1_SYNC_E___4 = 670,
	FN_STP_IVCXO27_0_B___4 = 671,
	FN_IP4_27_24___5 = 672,
	FN_RD_N___5 = 673,
	FN_MSIOF3_SYNC_D___4 = 674,
	FN_RX3_A___5 = 675,
	FN_HRX3_A___5 = 676,
	FN_CAN0_TX_A___4 = 677,
	FN_CANFD0_TX_A___4 = 678,
	FN_IP5_27_24___5 = 679,
	FN_D3___5 = 680,
	FN_MSIOF3_TXD_A___5 = 681,
	FN_VI4_DATA19___5 = 682,
	FN_VI5_DATA3___4 = 683,
	FN_IP6_27_24___5 = 684,
	FN_D11___5 = 685,
	FN_LCDOUT3___5 = 686,
	FN_MSIOF2_TXD_D___4 = 687,
	FN_HTX3_B___5 = 688,
	FN_VI4_DATA3_A___5 = 689,
	FN_RTS4_N_C___5 = 690,
	FN_DU_DR3___5 = 691,
	FN_IP7_27_24___5 = 692,
	FN_SD0_DAT0___5 = 693,
	FN_MSIOF1_RXD_E___4 = 694,
	FN_TS_SCK0_B___4 = 695,
	FN_STP_ISCLK_0_B___4 = 696,
	FN_IP4_31_28___5 = 697,
	FN_RD_WR_N___5 = 698,
	FN_MSIOF3_RXD_D___4 = 699,
	FN_TX3_A___5 = 700,
	FN_HTX3_A___5 = 701,
	FN_CAN0_RX_A___4 = 702,
	FN_CANFD0_RX_A___4 = 703,
	FN_IP5_31_28___5 = 704,
	FN_D4___5 = 705,
	FN_MSIOF2_SCK_B___5 = 706,
	FN_VI4_DATA20___5 = 707,
	FN_VI5_DATA4___4 = 708,
	FN_IP6_31_28___5 = 709,
	FN_D12___5 = 710,
	FN_LCDOUT4___5 = 711,
	FN_MSIOF2_SS1_D___4 = 712,
	FN_RX4_C___5 = 713,
	FN_VI4_DATA4_A___5 = 714,
	FN_DU_DR4___5 = 715,
	FN_IP7_31_28___5 = 716,
	FN_SD0_DAT1___5 = 717,
	FN_MSIOF1_TXD_E___4 = 718,
	FN_TS_SPSYNC0_B___4 = 719,
	FN_STP_ISSYNC_0_B___4 = 720,
	FN_IP8_3_0___5 = 721,
	FN_SD0_DAT2___5 = 722,
	FN_MSIOF1_SS1_E___4 = 723,
	FN_TS_SDAT0_B___4 = 724,
	FN_STP_ISD_0_B___4 = 725,
	FN_IP9_3_0___5 = 726,
	FN_SD2_CLK___4 = 727,
	FN_IP10_3_0___5 = 728,
	FN_SD3_DAT6___5 = 729,
	FN_SD3_CD___5 = 730,
	FN_IP11_3_0___5 = 731,
	FN_TX0___4 = 732,
	FN_HTX1_B___5 = 733,
	FN_TS_SPSYNC0_C___4 = 734,
	FN_STP_ISSYNC_0_C___4 = 735,
	FN_RIF0_D1_B___5 = 736,
	FN_IP8_7_4___5 = 737,
	FN_SD0_DAT3___5 = 738,
	FN_MSIOF1_SS2_E___4 = 739,
	FN_TS_SDEN0_B___4 = 740,
	FN_STP_ISEN_0_B___4 = 741,
	FN_IP9_7_4___5 = 742,
	FN_SD2_DAT0___4 = 743,
	FN_IP10_7_4___5 = 744,
	FN_SD3_DAT7___5 = 745,
	FN_SD3_WP___5 = 746,
	FN_IP11_7_4___5 = 747,
	FN_CTS0_N___4 = 748,
	FN_HCTS1_N_B___5 = 749,
	FN_MSIOF1_SYNC_B___4 = 750,
	FN_TS_SPSYNC1_C___4 = 751,
	FN_STP_ISSYNC_1_C___4 = 752,
	FN_RIF1_SYNC_B___4 = 753,
	FN_AUDIO_CLKOUT_C___4 = 754,
	FN_ADICS_SAMP___4 = 755,
	FN_IP8_11_8___5 = 756,
	FN_SD1_CLK___5 = 757,
	FN_MSIOF1_SCK_G___4 = 758,
	FN_SIM0_CLK_A___5 = 759,
	FN_IP9_11_8___5 = 760,
	FN_SD2_DAT1___4 = 761,
	FN_IP10_11_8___5 = 762,
	FN_SD0_CD___5 = 763,
	FN_SCL2_B___5 = 764,
	FN_SIM0_RST_A___5 = 765,
	FN_IP11_11_8___5 = 766,
	FN_RTS0_N___4 = 767,
	FN_HRTS1_N_B___5 = 768,
	FN_MSIOF1_SS1_B___4 = 769,
	FN_AUDIO_CLKA_B___4 = 770,
	FN_SCL2_A___5 = 771,
	FN_STP_IVCXO27_1_C___4 = 772,
	FN_RIF0_SYNC_B___5 = 773,
	FN_ADICHS1___4 = 774,
	FN_IP8_15_12___5 = 775,
	FN_SD1_CMD___5 = 776,
	FN_MSIOF1_SYNC_G___4 = 777,
	FN_SIM0_D_A___5 = 778,
	FN_STP_IVCXO27_1_B___4 = 779,
	FN_IP9_15_12___5 = 780,
	FN_SD2_DAT2___4 = 781,
	FN_IP10_15_12___5 = 782,
	FN_SD0_WP___5 = 783,
	FN_SDA2_B___5 = 784,
	FN_IP11_15_12___5 = 785,
	FN_RX1_A___4 = 786,
	FN_HRX1_A___5 = 787,
	FN_TS_SDAT0_C___4 = 788,
	FN_STP_ISD_0_C___4 = 789,
	FN_RIF1_CLK_C___4 = 790,
	FN_IP8_19_16___5 = 791,
	FN_SD1_DAT0___5 = 792,
	FN_SD2_DAT4___4 = 793,
	FN_MSIOF1_RXD_G___4 = 794,
	FN_TS_SCK1_B___4 = 795,
	FN_STP_ISCLK_1_B___4 = 796,
	FN_IP9_19_16___5 = 797,
	FN_SD2_DAT3___4 = 798,
	FN_IP10_19_16___5 = 799,
	FN_SD1_CD___5 = 800,
	FN_SIM0_CLK_B___5 = 801,
	FN_IP11_19_16___5 = 802,
	FN_TX1_A___4 = 803,
	FN_HTX1_A___5 = 804,
	FN_TS_SDEN0_C___4 = 805,
	FN_STP_ISEN_0_C___4 = 806,
	FN_RIF1_D0_C___4 = 807,
	FN_IP8_23_20___5 = 808,
	FN_SD1_DAT1___5 = 809,
	FN_SD2_DAT5___4 = 810,
	FN_MSIOF1_TXD_G___4 = 811,
	FN_TS_SPSYNC1_B___4 = 812,
	FN_STP_ISSYNC_1_B___4 = 813,
	FN_IP9_23_20___5 = 814,
	FN_SD2_DS___4 = 815,
	FN_SATA_DEVSLP_B___3 = 816,
	FN_IP10_23_20___5 = 817,
	FN_SD1_WP___5 = 818,
	FN_SIM0_D_B___5 = 819,
	FN_IP11_23_20___5 = 820,
	FN_CTS1_N___5 = 821,
	FN_HCTS1_N_A___4 = 822,
	FN_MSIOF1_RXD_B___4 = 823,
	FN_TS_SDEN1_C___4 = 824,
	FN_STP_ISEN_1_C___4 = 825,
	FN_RIF1_D0_B___4 = 826,
	FN_ADIDATA___4 = 827,
	FN_IP8_27_24___5 = 828,
	FN_SD1_DAT2___5 = 829,
	FN_SD2_DAT6___4 = 830,
	FN_MSIOF1_SS1_G___4 = 831,
	FN_TS_SDAT1_B___4 = 832,
	FN_STP_ISD_1_B___4 = 833,
	FN_IP9_27_24___5 = 834,
	FN_SD3_DAT4___5 = 835,
	FN_SD2_CD_A___4 = 836,
	FN_IP10_27_24___5 = 837,
	FN_SCK0___4 = 838,
	FN_HSCK1_B___5 = 839,
	FN_MSIOF1_SS2_B___4 = 840,
	FN_AUDIO_CLKC_B___5 = 841,
	FN_SDA2_A___5 = 842,
	FN_SIM0_RST_B___5 = 843,
	FN_STP_OPWM_0_C___4 = 844,
	FN_RIF0_CLK_B___5 = 845,
	FN_ADICHS2___4 = 846,
	FN_IP11_27_24___5 = 847,
	FN_RTS1_N___5 = 848,
	FN_HRTS1_N_A___4 = 849,
	FN_MSIOF1_TXD_B___4 = 850,
	FN_TS_SDAT1_C___4 = 851,
	FN_STP_ISD_1_C___4 = 852,
	FN_RIF1_D1_B___4 = 853,
	FN_ADICHS0___4 = 854,
	FN_IP8_31_28___5 = 855,
	FN_SD1_DAT3___5 = 856,
	FN_SD2_DAT7___4 = 857,
	FN_MSIOF1_SS2_G___4 = 858,
	FN_TS_SDEN1_B___4 = 859,
	FN_STP_ISEN_1_B___4 = 860,
	FN_IP9_31_28___5 = 861,
	FN_SD3_DAT5___5 = 862,
	FN_SD2_WP_A___4 = 863,
	FN_IP10_31_28___5 = 864,
	FN_RX0___4 = 865,
	FN_HRX1_B___5 = 866,
	FN_TS_SCK0_C___4 = 867,
	FN_STP_ISCLK_0_C___4 = 868,
	FN_RIF0_D0_B___5 = 869,
	FN_IP11_31_28___5 = 870,
	FN_SCK2___4 = 871,
	FN_SCIF_CLK_B___5 = 872,
	FN_MSIOF1_SCK_B___4 = 873,
	FN_TS_SCK1_C___4 = 874,
	FN_STP_ISCLK_1_C___4 = 875,
	FN_RIF1_CLK_B___4 = 876,
	FN_ADICLK___4 = 877,
	FN_IP12_3_0___5 = 878,
	FN_TX2_A___5 = 879,
	FN_SD2_CD_B___4 = 880,
	FN_SCL1_A___5 = 881,
	FN_FMCLK_A___5 = 882,
	FN_RIF1_D1_C___4 = 883,
	FN_FSO_CFE_0_B = 884,
	FN_IP13_3_0___5 = 885,
	FN_MSIOF0_SS1___5 = 886,
	FN_RX5 = 887,
	FN_AUDIO_CLKA_C___4 = 888,
	FN_SSI_SCK2_A___5 = 889,
	FN_STP_IVCXO27_0_C___4 = 890,
	FN_AUDIO_CLKOUT3_A___5 = 891,
	FN_TCLK1_B___5 = 892,
	FN_IP14_3_0___5 = 893,
	FN_SSI_SDATA1_A___4 = 894,
	FN_IP15_3_0___5 = 895,
	FN_SSI_SCK6___5 = 896,
	FN_USB2_PWEN___2 = 897,
	FN_SIM0_RST_D___4 = 898,
	FN_IP12_7_4___5 = 899,
	FN_RX2_A___5 = 900,
	FN_SD2_WP_B___4 = 901,
	FN_SDA1_A___5 = 902,
	FN_FMIN_A___5 = 903,
	FN_RIF1_SYNC_C___4 = 904,
	FN_FSO_CFE_1_B = 905,
	FN_IP13_7_4___5 = 906,
	FN_MSIOF0_SS2___5 = 907,
	FN_TX5 = 908,
	FN_MSIOF1_SS2_D___4 = 909,
	FN_AUDIO_CLKC_A___5 = 910,
	FN_SSI_WS2_A___5 = 911,
	FN_STP_OPWM_0_D___4 = 912,
	FN_AUDIO_CLKOUT_D___4 = 913,
	FN_SPEEDIN_B___5 = 914,
	FN_IP14_7_4___5 = 915,
	FN_SSI_SDATA2_A___4 = 916,
	FN_SSI_SCK1_B___4 = 917,
	FN_IP15_7_4___5 = 918,
	FN_SSI_WS6___5 = 919,
	FN_USB2_OVC___2 = 920,
	FN_SIM0_D_D___4 = 921,
	FN_IP12_11_8___5 = 922,
	FN_HSCK0___4 = 923,
	FN_MSIOF1_SCK_D___4 = 924,
	FN_AUDIO_CLKB_A___5 = 925,
	FN_SSI_SDATA1_B___4 = 926,
	FN_TS_SCK0_D___4 = 927,
	FN_STP_ISCLK_0_D___4 = 928,
	FN_RIF0_CLK_C___4 = 929,
	FN_IP13_11_8___5 = 930,
	FN_MLB_CLK___5 = 931,
	FN_MSIOF1_SCK_F___4 = 932,
	FN_SCL1_B___5 = 933,
	FN_IP14_11_8___5 = 934,
	FN_SSI_SCK349___5 = 935,
	FN_MSIOF1_SS1_A___4 = 936,
	FN_STP_OPWM_0_A___4 = 937,
	FN_IP15_11_8___5 = 938,
	FN_SSI_SDATA6___5 = 939,
	FN_SIM0_CLK_D___4 = 940,
	FN_SATA_DEVSLP_A___3 = 941,
	FN_IP12_15_12___5 = 942,
	FN_HRX0___4 = 943,
	FN_MSIOF1_RXD_D___4 = 944,
	FN_SSI_SDATA2_B___4 = 945,
	FN_TS_SDEN0_D___4 = 946,
	FN_STP_ISEN_0_D___4 = 947,
	FN_RIF0_D0_C___4 = 948,
	FN_IP13_15_12___5 = 949,
	FN_MLB_SIG___5 = 950,
	FN_RX1_B___4 = 951,
	FN_MSIOF1_SYNC_F___4 = 952,
	FN_SDA1_B___5 = 953,
	FN_IP14_15_12___5 = 954,
	FN_SSI_WS349___5 = 955,
	FN_HCTS2_N_A___5 = 956,
	FN_MSIOF1_SS2_A___4 = 957,
	FN_STP_IVCXO27_0_A___4 = 958,
	FN_IP15_15_12___5 = 959,
	FN_SSI_SCK78___5 = 960,
	FN_HRX2_B___5 = 961,
	FN_MSIOF1_SCK_C___4 = 962,
	FN_TS_SCK1_A___4 = 963,
	FN_STP_ISCLK_1_A___4 = 964,
	FN_RIF1_CLK_A___4 = 965,
	FN_RIF3_CLK_A___5 = 966,
	FN_IP12_19_16___5 = 967,
	FN_HTX0___4 = 968,
	FN_MSIOF1_TXD_D___4 = 969,
	FN_SSI_SDATA9_B___4 = 970,
	FN_TS_SDAT0_D___4 = 971,
	FN_STP_ISD_0_D___4 = 972,
	FN_RIF0_D1_C___4 = 973,
	FN_IP13_19_16___5 = 974,
	FN_MLB_DAT___5 = 975,
	FN_TX1_B___4 = 976,
	FN_MSIOF1_RXD_F___4 = 977,
	FN_IP14_19_16___5 = 978,
	FN_SSI_SDATA3___5 = 979,
	FN_HRTS2_N_A___5 = 980,
	FN_MSIOF1_TXD_A___4 = 981,
	FN_TS_SCK0_A___4 = 982,
	FN_STP_ISCLK_0_A___4 = 983,
	FN_RIF0_D1_A___5 = 984,
	FN_RIF2_D0_A___5 = 985,
	FN_IP15_19_16___5 = 986,
	FN_SSI_WS78___5 = 987,
	FN_HTX2_B___5 = 988,
	FN_MSIOF1_SYNC_C___4 = 989,
	FN_TS_SDAT1_A___4 = 990,
	FN_STP_ISD_1_A___4 = 991,
	FN_RIF1_SYNC_A___4 = 992,
	FN_RIF3_SYNC_A___5 = 993,
	FN_IP12_23_20___5 = 994,
	FN_HCTS0_N___4 = 995,
	FN_RX2_B___5 = 996,
	FN_MSIOF1_SYNC_D___4 = 997,
	FN_SSI_SCK9_A___5 = 998,
	FN_TS_SPSYNC0_D___4 = 999,
	FN_STP_ISSYNC_0_D___4 = 1000,
	FN_RIF0_SYNC_C___4 = 1001,
	FN_AUDIO_CLKOUT1_A___5 = 1002,
	FN_IP13_23_20___5 = 1003,
	FN_SSI_SCK01239___5 = 1004,
	FN_MSIOF1_TXD_F___4 = 1005,
	FN_IP14_23_20___5 = 1006,
	FN_SSI_SCK4___5 = 1007,
	FN_HRX2_A___5 = 1008,
	FN_MSIOF1_SCK_A___4 = 1009,
	FN_TS_SDAT0_A___4 = 1010,
	FN_STP_ISD_0_A___4 = 1011,
	FN_RIF0_CLK_A___5 = 1012,
	FN_RIF2_CLK_A___5 = 1013,
	FN_IP15_23_20___5 = 1014,
	FN_SSI_SDATA7___5 = 1015,
	FN_HCTS2_N_B___4 = 1016,
	FN_MSIOF1_RXD_C___4 = 1017,
	FN_TS_SDEN1_A___4 = 1018,
	FN_STP_ISEN_1_A___4 = 1019,
	FN_RIF1_D0_A___4 = 1020,
	FN_RIF3_D0_A___5 = 1021,
	FN_TCLK2_A___5 = 1022,
	FN_IP12_27_24___5 = 1023,
	FN_HRTS0_N___4 = 1024,
	FN_TX2_B___5 = 1025,
	FN_MSIOF1_SS1_D___4 = 1026,
	FN_SSI_WS9_A___5 = 1027,
	FN_STP_IVCXO27_0_D___4 = 1028,
	FN_BPFCLK_A___5 = 1029,
	FN_AUDIO_CLKOUT2_A___5 = 1030,
	FN_IP13_27_24___5 = 1031,
	FN_SSI_WS01239___5 = 1032,
	FN_MSIOF1_SS1_F___4 = 1033,
	FN_IP14_27_24___5 = 1034,
	FN_SSI_WS4___5 = 1035,
	FN_HTX2_A___5 = 1036,
	FN_MSIOF1_SYNC_A___4 = 1037,
	FN_TS_SDEN0_A___4 = 1038,
	FN_STP_ISEN_0_A___4 = 1039,
	FN_RIF0_SYNC_A___5 = 1040,
	FN_RIF2_SYNC_A___5 = 1041,
	FN_IP15_27_24___5 = 1042,
	FN_SSI_SDATA8___5 = 1043,
	FN_HRTS2_N_B___4 = 1044,
	FN_MSIOF1_TXD_C___4 = 1045,
	FN_TS_SPSYNC1_A___4 = 1046,
	FN_STP_ISSYNC_1_A___4 = 1047,
	FN_RIF1_D1_A___4 = 1048,
	FN_RIF3_D1_A___5 = 1049,
	FN_IP12_31_28___5 = 1050,
	FN_MSIOF0_SYNC___5 = 1051,
	FN_AUDIO_CLKOUT_A___5 = 1052,
	FN_IP13_31_28___5 = 1053,
	FN_SSI_SDATA0___5 = 1054,
	FN_MSIOF1_SS2_F___4 = 1055,
	FN_IP14_31_28___5 = 1056,
	FN_SSI_SDATA4___5 = 1057,
	FN_HSCK2_A___5 = 1058,
	FN_MSIOF1_RXD_A___4 = 1059,
	FN_TS_SPSYNC0_A___4 = 1060,
	FN_STP_ISSYNC_0_A___4 = 1061,
	FN_RIF0_D0_A___5 = 1062,
	FN_RIF2_D1_A___5 = 1063,
	FN_IP15_31_28___5 = 1064,
	FN_SSI_SDATA9_A___4 = 1065,
	FN_HSCK2_B___4 = 1066,
	FN_MSIOF1_SS1_C___4 = 1067,
	FN_HSCK1_A___5 = 1068,
	FN_SSI_WS1_B___4 = 1069,
	FN_SCK1___5 = 1070,
	FN_STP_IVCXO27_1_A___4 = 1071,
	FN_SCK5 = 1072,
	FN_IP16_3_0___4 = 1073,
	FN_AUDIO_CLKA_A___4 = 1074,
	FN_IP17_3_0___4 = 1075,
	FN_USB31_PWEN = 1076,
	FN_AUDIO_CLKOUT2_B___5 = 1077,
	FN_SSI_SCK9_B___5 = 1078,
	FN_TS_SDEN0_E___4 = 1079,
	FN_STP_ISEN_0_E___4 = 1080,
	FN_RIF2_D0_B___5 = 1081,
	FN_TPU0TO2___5 = 1082,
	FN_IP16_7_4___4 = 1083,
	FN_AUDIO_CLKB_B___5 = 1084,
	FN_SCIF_CLK_A___5 = 1085,
	FN_STP_IVCXO27_1_D___4 = 1086,
	FN_REMOCON_A___5 = 1087,
	FN_TCLK1_A___5 = 1088,
	FN_IP17_7_4___4 = 1089,
	FN_USB31_OVC = 1090,
	FN_AUDIO_CLKOUT3_B___5 = 1091,
	FN_SSI_WS9_B___5 = 1092,
	FN_TS_SPSYNC0_E___4 = 1093,
	FN_STP_ISSYNC_0_E___4 = 1094,
	FN_RIF2_D1_B___5 = 1095,
	FN_TPU0TO3___5 = 1096,
	FN_IP16_11_8___4 = 1097,
	FN_USB0_PWEN___4 = 1098,
	FN_SIM0_RST_C___4 = 1099,
	FN_TS_SCK1_D___4 = 1100,
	FN_STP_ISCLK_1_D___4 = 1101,
	FN_BPFCLK_B___5 = 1102,
	FN_RIF3_CLK_B___5 = 1103,
	FN_IP16_15_12___4 = 1104,
	FN_USB0_OVC___4 = 1105,
	FN_SIM0_D_C___4 = 1106,
	FN_TS_SDAT1_D___4 = 1107,
	FN_STP_ISD_1_D___4 = 1108,
	FN_RIF3_SYNC_B___5 = 1109,
	FN_IP16_19_16___4 = 1110,
	FN_USB1_PWEN___4 = 1111,
	FN_SIM0_CLK_C___4 = 1112,
	FN_SSI_SCK1_A___4 = 1113,
	FN_TS_SCK0_E___4 = 1114,
	FN_STP_ISCLK_0_E___4 = 1115,
	FN_FMCLK_B___5 = 1116,
	FN_RIF2_CLK_B___5 = 1117,
	FN_SPEEDIN_A___5 = 1118,
	FN_IP16_23_20___4 = 1119,
	FN_USB1_OVC___4 = 1120,
	FN_MSIOF1_SS2_C___4 = 1121,
	FN_SSI_WS1_A___4 = 1122,
	FN_TS_SDAT0_E___4 = 1123,
	FN_STP_ISD_0_E___4 = 1124,
	FN_FMIN_B___5 = 1125,
	FN_RIF2_SYNC_B___5 = 1126,
	FN_REMOCON_B___5 = 1127,
	FN_IP16_27_24___4 = 1128,
	FN_USB30_PWEN___5 = 1129,
	FN_AUDIO_CLKOUT_B___5 = 1130,
	FN_SSI_SCK2_B___5 = 1131,
	FN_TS_SDEN1_D___4 = 1132,
	FN_STP_ISEN_1_D___4 = 1133,
	FN_STP_OPWM_0_E___4 = 1134,
	FN_RIF3_D0_B___5 = 1135,
	FN_TCLK2_B___5 = 1136,
	FN_TPU0TO0___5 = 1137,
	FN_IP16_31_28___4 = 1138,
	FN_USB30_OVC___5 = 1139,
	FN_AUDIO_CLKOUT1_B___5 = 1140,
	FN_SSI_WS2_B___5 = 1141,
	FN_TS_SPSYNC1_D___4 = 1142,
	FN_STP_ISSYNC_1_D___4 = 1143,
	FN_STP_IVCXO27_0_E___4 = 1144,
	FN_RIF3_D1_B___5 = 1145,
	FN_FSO_TOE_B = 1146,
	FN_TPU0TO1___5 = 1147,
	FN_SEL_TSIF1_0___4 = 1148,
	FN_SEL_TSIF1_1___4 = 1149,
	FN_SEL_TSIF1_2___4 = 1150,
	FN_SEL_TSIF1_3___4 = 1151,
	FN_I2C_SEL_5_0___4 = 1152,
	FN_I2C_SEL_5_1___4 = 1153,
	FN_SEL_MSIOF3_0___5 = 1154,
	FN_SEL_MSIOF3_1___5 = 1155,
	FN_SEL_MSIOF3_2___4 = 1156,
	FN_SEL_MSIOF3_3___4 = 1157,
	FN_I2C_SEL_3_0___4 = 1158,
	FN_I2C_SEL_3_1___4 = 1159,
	FN_SEL_TSIF0_0___4 = 1160,
	FN_SEL_TSIF0_1___4 = 1161,
	FN_SEL_TSIF0_2___4 = 1162,
	FN_SEL_TSIF0_3___4 = 1163,
	FN_SEL_TSIF0_4___4 = 1164,
	FN_I2C_SEL_0_0___4 = 1165,
	FN_I2C_SEL_0_1___4 = 1166,
	FN_SEL_MSIOF2_0___5 = 1167,
	FN_SEL_MSIOF2_1___5 = 1168,
	FN_SEL_MSIOF2_2___4 = 1169,
	FN_SEL_MSIOF2_3___4 = 1170,
	FN_SEL_MSIOF1_0___4 = 1171,
	FN_SEL_MSIOF1_1___4 = 1172,
	FN_SEL_MSIOF1_2___4 = 1173,
	FN_SEL_MSIOF1_3___4 = 1174,
	FN_SEL_MSIOF1_4___4 = 1175,
	FN_SEL_MSIOF1_5___4 = 1176,
	FN_SEL_MSIOF1_6___4 = 1177,
	FN_SEL_TIMER_TMU_0___4 = 1178,
	FN_SEL_TIMER_TMU_1___4 = 1179,
	FN_SEL_SSP1_1_0___4 = 1180,
	FN_SEL_SSP1_1_1___4 = 1181,
	FN_SEL_SSP1_1_2___4 = 1182,
	FN_SEL_SSP1_1_3___4 = 1183,
	FN_SEL_LBSC_0___4 = 1184,
	FN_SEL_LBSC_1___4 = 1185,
	FN_SEL_SSP1_0_0___4 = 1186,
	FN_SEL_SSP1_0_1___4 = 1187,
	FN_SEL_SSP1_0_2___4 = 1188,
	FN_SEL_SSP1_0_3___4 = 1189,
	FN_SEL_SSP1_0_4___4 = 1190,
	FN_SEL_IEBUS_0___4 = 1191,
	FN_SEL_IEBUS_1___4 = 1192,
	FN_SEL_I2C6_0___5 = 1193,
	FN_SEL_I2C6_1___5 = 1194,
	FN_SEL_I2C6_2___4 = 1195,
	FN_SEL_SSI_0 = 1196,
	FN_SEL_SSI_1 = 1197,
	FN_SEL_I2C2_0___5 = 1198,
	FN_SEL_I2C2_1___5 = 1199,
	FN_SEL_SPEED_PULSE_0___4 = 1200,
	FN_SEL_SPEED_PULSE_1___4 = 1201,
	FN_SEL_I2C1_0___5 = 1202,
	FN_SEL_I2C1_1___5 = 1203,
	FN_SEL_SIMCARD_0___5 = 1204,
	FN_SEL_SIMCARD_1___5 = 1205,
	FN_SEL_SIMCARD_2___4 = 1206,
	FN_SEL_SIMCARD_3___4 = 1207,
	FN_SEL_HSCIF4_0___5 = 1208,
	FN_SEL_HSCIF4_1___5 = 1209,
	FN_SEL_HSCIF3_0___5 = 1210,
	FN_SEL_HSCIF3_1___5 = 1211,
	FN_SEL_HSCIF3_2___5 = 1212,
	FN_SEL_HSCIF3_3___5 = 1213,
	FN_SEL_SDHI2_0___4 = 1214,
	FN_SEL_SDHI2_1___4 = 1215,
	FN_SEL_SCIF4_0___5 = 1216,
	FN_SEL_SCIF4_1___5 = 1217,
	FN_SEL_SCIF4_2___5 = 1218,
	FN_SEL_HSCIF2_0___5 = 1219,
	FN_SEL_HSCIF2_1___5 = 1220,
	FN_SEL_HSCIF1_0___5 = 1221,
	FN_SEL_HSCIF1_1___5 = 1222,
	FN_SEL_SCIF3_0___5 = 1223,
	FN_SEL_SCIF3_1___5 = 1224,
	FN_SEL_FSO_0___2 = 1225,
	FN_SEL_FSO_1___2 = 1226,
	FN_SEL_SCIF2_0___5 = 1227,
	FN_SEL_SCIF2_1___5 = 1228,
	FN_SEL_FM_0___5 = 1229,
	FN_SEL_FM_1___5 = 1230,
	FN_SEL_SCIF1_0___4 = 1231,
	FN_SEL_SCIF1_1___4 = 1232,
	FN_SEL_ETHERAVB_0___4 = 1233,
	FN_SEL_ETHERAVB_1___4 = 1234,
	FN_SEL_SATA_0 = 1235,
	FN_SEL_SATA_1 = 1236,
	FN_SEL_DRIF3_0___5 = 1237,
	FN_SEL_DRIF3_1___5 = 1238,
	FN_SEL_REMOCON_0___5 = 1239,
	FN_SEL_REMOCON_1___5 = 1240,
	FN_SEL_DRIF2_0___5 = 1241,
	FN_SEL_DRIF2_1___5 = 1242,
	FN_SEL_DRIF1_0___4 = 1243,
	FN_SEL_DRIF1_1___4 = 1244,
	FN_SEL_DRIF1_2___4 = 1245,
	FN_SEL_RCAN0_0___4 = 1246,
	FN_SEL_RCAN0_1___4 = 1247,
	FN_SEL_DRIF0_0___5 = 1248,
	FN_SEL_DRIF0_1___5 = 1249,
	FN_SEL_DRIF0_2___4 = 1250,
	FN_SEL_PWM6_0___5 = 1251,
	FN_SEL_PWM6_1___5 = 1252,
	FN_SEL_PWM5_0___5 = 1253,
	FN_SEL_PWM5_1___5 = 1254,
	FN_SEL_CANFD0_0___4 = 1255,
	FN_SEL_CANFD0_1___4 = 1256,
	FN_SEL_PWM4_0___5 = 1257,
	FN_SEL_PWM4_1___5 = 1258,
	FN_SEL_ADG_0 = 1259,
	FN_SEL_ADG_1 = 1260,
	FN_SEL_ADG_2 = 1261,
	FN_SEL_ADG_3 = 1262,
	FN_SEL_PWM3_0___5 = 1263,
	FN_SEL_PWM3_1___5 = 1264,
	FN_SEL_PWM2_0___5 = 1265,
	FN_SEL_PWM2_1___5 = 1266,
	FN_SEL_PWM1_0___5 = 1267,
	FN_SEL_PWM1_1___5 = 1268,
	FN_SEL_VIN4_0___5 = 1269,
	FN_SEL_VIN4_1___5 = 1270,
	PINMUX_FUNCTION_END___5 = 1271,
	PINMUX_MARK_BEGIN___5 = 1272,
	MSIOF0_RXD_MARK___5 = 1273,
	MSIOF0_TXD_MARK___5 = 1274,
	SD3_DS_MARK___5 = 1275,
	MSIOF0_SCK_MARK___5 = 1276,
	SSI_SDATA5_MARK___5 = 1277,
	SD3_DAT3_MARK___5 = 1278,
	SSI_WS5_MARK___5 = 1279,
	SD3_DAT2_MARK___5 = 1280,
	SSI_SCK5_MARK___5 = 1281,
	SD3_DAT1_MARK___5 = 1282,
	SD3_DAT0_MARK___5 = 1283,
	SD3_CMD_MARK___5 = 1284,
	SD3_CLK_MARK___5 = 1285,
	GP7_03_MARK___4 = 1286,
	GP7_02_MARK___4 = 1287,
	SD2_CMD_MARK___4 = 1288,
	AVS2_MARK___4 = 1289,
	AVS1_MARK___4 = 1290,
	IP0_3_0_MARK___5 = 1291,
	AVB_MDC_MARK___5 = 1292,
	MSIOF2_SS2_C_MARK___4 = 1293,
	IP1_3_0_MARK___5 = 1294,
	IRQ2_MARK___5 = 1295,
	QCPV_QDE_MARK___5 = 1296,
	DU_EXODDF_DU_ODDF_DISP_CDE_MARK___4 = 1297,
	VI4_DATA2_B_MARK___5 = 1298,
	PWM3_B_MARK___5 = 1299,
	IP2_3_0_MARK___5 = 1300,
	A1_MARK___5 = 1301,
	LCDOUT17_MARK___5 = 1302,
	MSIOF3_TXD_B_MARK___5 = 1303,
	VI4_DATA9_MARK___5 = 1304,
	DU_DB1_MARK___5 = 1305,
	PWM4_A_MARK___5 = 1306,
	IP3_3_0_MARK___5 = 1307,
	A9_MARK___5 = 1308,
	MSIOF2_SCK_A_MARK___5 = 1309,
	CTS4_N_B_MARK___4 = 1310,
	VI5_VSYNC_N_MARK___4 = 1311,
	IP0_7_4_MARK___5 = 1312,
	AVB_MAGIC_MARK___5 = 1313,
	MSIOF2_SS1_C_MARK___4 = 1314,
	SCK4_A_MARK___5 = 1315,
	IP1_7_4_MARK___5 = 1316,
	IRQ3_MARK___5 = 1317,
	QSTVB_QVE_MARK___5 = 1318,
	A25_MARK = 1319,
	DU_DOTCLKOUT1_MARK___4 = 1320,
	VI4_DATA3_B_MARK___5 = 1321,
	PWM4_B_MARK___5 = 1322,
	IP2_7_4_MARK___5 = 1323,
	A2_MARK___5 = 1324,
	LCDOUT18_MARK___5 = 1325,
	MSIOF3_SCK_B_MARK___5 = 1326,
	VI4_DATA10_MARK___5 = 1327,
	DU_DB2_MARK___5 = 1328,
	PWM5_A_MARK___5 = 1329,
	IP3_7_4_MARK___5 = 1330,
	A10_MARK___5 = 1331,
	MSIOF2_RXD_A_MARK___5 = 1332,
	RTS4_N_B_MARK___4 = 1333,
	VI5_HSYNC_N_MARK___4 = 1334,
	IP0_11_8_MARK___5 = 1335,
	AVB_PHY_INT_MARK___5 = 1336,
	MSIOF2_SYNC_C_MARK___4 = 1337,
	RX4_A_MARK___5 = 1338,
	IP1_11_8_MARK___5 = 1339,
	IRQ4_MARK___5 = 1340,
	QSTH_QHS_MARK___5 = 1341,
	A24_MARK = 1342,
	DU_EXHSYNC_DU_HSYNC_MARK___4 = 1343,
	VI4_DATA4_B_MARK___5 = 1344,
	PWM5_B_MARK___5 = 1345,
	IP2_11_8_MARK___5 = 1346,
	A3_MARK___5 = 1347,
	LCDOUT19_MARK___5 = 1348,
	MSIOF3_RXD_B_MARK___5 = 1349,
	VI4_DATA11_MARK___5 = 1350,
	DU_DB3_MARK___5 = 1351,
	PWM6_A_MARK___5 = 1352,
	IP3_11_8_MARK___5 = 1353,
	A11_MARK___5 = 1354,
	TX3_B_MARK___5 = 1355,
	MSIOF2_TXD_A_MARK___5 = 1356,
	HTX4_B_MARK___5 = 1357,
	HSCK4_MARK___4 = 1358,
	VI5_FIELD_MARK___4 = 1359,
	SCL6_A_MARK___5 = 1360,
	AVB_AVTP_CAPTURE_B_MARK___4 = 1361,
	PWM2_B_MARK___5 = 1362,
	IP0_15_12_MARK___5 = 1363,
	AVB_LINK_MARK___5 = 1364,
	MSIOF2_SCK_C_MARK___4 = 1365,
	TX4_A_MARK___5 = 1366,
	IP1_15_12_MARK___5 = 1367,
	IRQ5_MARK___5 = 1368,
	QSTB_QHE_MARK___5 = 1369,
	A23_MARK = 1370,
	DU_EXVSYNC_DU_VSYNC_MARK___4 = 1371,
	VI4_DATA5_B_MARK___5 = 1372,
	PWM6_B_MARK___5 = 1373,
	IP2_15_12_MARK___5 = 1374,
	A4_MARK___5 = 1375,
	LCDOUT20_MARK___5 = 1376,
	MSIOF3_SS1_B_MARK___5 = 1377,
	VI4_DATA12_MARK___5 = 1378,
	VI5_DATA12_MARK___4 = 1379,
	DU_DB4_MARK___5 = 1380,
	IP3_15_12_MARK___5 = 1381,
	A12_MARK___5 = 1382,
	LCDOUT12_MARK___5 = 1383,
	MSIOF3_SCK_C_MARK___4 = 1384,
	HRX4_A_MARK___5 = 1385,
	VI5_DATA8_MARK___4 = 1386,
	DU_DG4_MARK___5 = 1387,
	IP0_19_16_MARK___5 = 1388,
	AVB_AVTP_MATCH_A_MARK___4 = 1389,
	MSIOF2_RXD_C_MARK___4 = 1390,
	CTS4_N_A_MARK___5 = 1391,
	IP1_19_16_MARK___5 = 1392,
	PWM0_MARK___4 = 1393,
	AVB_AVTP_PPS_MARK___5 = 1394,
	A22_MARK = 1395,
	VI4_DATA6_B_MARK___5 = 1396,
	IECLK_B_MARK___4 = 1397,
	IP2_19_16_MARK___5 = 1398,
	A5_MARK___5 = 1399,
	LCDOUT21_MARK___5 = 1400,
	MSIOF3_SS2_B_MARK___4 = 1401,
	SCK4_B_MARK___5 = 1402,
	VI4_DATA13_MARK___5 = 1403,
	VI5_DATA13_MARK___4 = 1404,
	DU_DB5_MARK___5 = 1405,
	IP3_19_16_MARK___5 = 1406,
	A13_MARK___5 = 1407,
	LCDOUT13_MARK___5 = 1408,
	MSIOF3_SYNC_C_MARK___4 = 1409,
	HTX4_A_MARK___5 = 1410,
	VI5_DATA9_MARK___4 = 1411,
	DU_DG5_MARK___5 = 1412,
	IP0_23_20_MARK___5 = 1413,
	AVB_AVTP_CAPTURE_A_MARK___4 = 1414,
	MSIOF2_TXD_C_MARK___4 = 1415,
	RTS4_N_A_MARK___5 = 1416,
	IP1_23_20_MARK___5 = 1417,
	PWM1_A_MARK___5 = 1418,
	A21_MARK = 1419,
	HRX3_D_MARK___5 = 1420,
	VI4_DATA7_B_MARK___5 = 1421,
	IERX_B_MARK___4 = 1422,
	IP2_23_20_MARK___5 = 1423,
	A6_MARK___5 = 1424,
	LCDOUT22_MARK___5 = 1425,
	MSIOF2_SS1_A_MARK___5 = 1426,
	RX4_B_MARK___5 = 1427,
	VI4_DATA14_MARK___5 = 1428,
	VI5_DATA14_MARK___4 = 1429,
	DU_DB6_MARK___5 = 1430,
	IP3_23_20_MARK___5 = 1431,
	A14_MARK___5 = 1432,
	LCDOUT14_MARK___5 = 1433,
	MSIOF3_RXD_C_MARK___4 = 1434,
	HCTS4_N_MARK___4 = 1435,
	VI5_DATA10_MARK___4 = 1436,
	DU_DG6_MARK___5 = 1437,
	IP0_27_24_MARK___5 = 1438,
	IRQ0_MARK___5 = 1439,
	QPOLB_MARK___5 = 1440,
	DU_CDE_MARK___5 = 1441,
	VI4_DATA0_B_MARK___5 = 1442,
	CAN0_TX_B_MARK___4 = 1443,
	CANFD0_TX_B_MARK___4 = 1444,
	IP1_27_24_MARK___5 = 1445,
	PWM2_A_MARK___5 = 1446,
	A20_MARK = 1447,
	HTX3_D_MARK___5 = 1448,
	IETX_B_MARK___4 = 1449,
	IP2_27_24_MARK___5 = 1450,
	A7_MARK___5 = 1451,
	LCDOUT23_MARK___5 = 1452,
	MSIOF2_SS2_A_MARK___5 = 1453,
	TX4_B_MARK___5 = 1454,
	VI4_DATA15_MARK___5 = 1455,
	VI5_DATA15_MARK___4 = 1456,
	DU_DB7_MARK___5 = 1457,
	IP3_27_24_MARK___5 = 1458,
	A15_MARK___5 = 1459,
	LCDOUT15_MARK___5 = 1460,
	MSIOF3_TXD_C_MARK___4 = 1461,
	HRTS4_N_MARK___4 = 1462,
	VI5_DATA11_MARK___4 = 1463,
	DU_DG7_MARK___5 = 1464,
	IP0_31_28_MARK___5 = 1465,
	IRQ1_MARK___5 = 1466,
	QPOLA_MARK___5 = 1467,
	DU_DISP_MARK___5 = 1468,
	VI4_DATA1_B_MARK___5 = 1469,
	CAN0_RX_B_MARK___4 = 1470,
	CANFD0_RX_B_MARK___4 = 1471,
	IP1_31_28_MARK___5 = 1472,
	A0_MARK___5 = 1473,
	LCDOUT16_MARK___5 = 1474,
	MSIOF3_SYNC_B_MARK___5 = 1475,
	VI4_DATA8_MARK___5 = 1476,
	DU_DB0_MARK___5 = 1477,
	PWM3_A_MARK___5 = 1478,
	IP2_31_28_MARK___5 = 1479,
	A8_MARK___5 = 1480,
	RX3_B_MARK___5 = 1481,
	MSIOF2_SYNC_A_MARK___5 = 1482,
	HRX4_B_MARK___5 = 1483,
	SDA6_A_MARK___5 = 1484,
	AVB_AVTP_MATCH_B_MARK___4 = 1485,
	PWM1_B_MARK___5 = 1486,
	IP3_31_28_MARK___5 = 1487,
	A16_MARK___5 = 1488,
	LCDOUT8_MARK___5 = 1489,
	VI4_FIELD_MARK___5 = 1490,
	DU_DG0_MARK___5 = 1491,
	IP4_3_0_MARK___5 = 1492,
	A17_MARK___5 = 1493,
	LCDOUT9_MARK___5 = 1494,
	VI4_VSYNC_N_MARK___5 = 1495,
	DU_DG1_MARK___5 = 1496,
	IP5_3_0_MARK___5 = 1497,
	WE0_N_MARK___5 = 1498,
	MSIOF3_TXD_D_MARK___4 = 1499,
	CTS3_N_MARK___4 = 1500,
	HCTS3_N_MARK___4 = 1501,
	SCL6_B_MARK___5 = 1502,
	CAN_CLK_MARK___5 = 1503,
	IECLK_A_MARK___4 = 1504,
	IP6_3_0_MARK___5 = 1505,
	D5_MARK___5 = 1506,
	MSIOF2_SYNC_B_MARK___5 = 1507,
	VI4_DATA21_MARK___5 = 1508,
	VI5_DATA5_MARK___4 = 1509,
	IP7_3_0_MARK___5 = 1510,
	D13_MARK___5 = 1511,
	LCDOUT5_MARK___5 = 1512,
	MSIOF2_SS2_D_MARK___4 = 1513,
	TX4_C_MARK___5 = 1514,
	VI4_DATA5_A_MARK___5 = 1515,
	DU_DR5_MARK___5 = 1516,
	IP4_7_4_MARK___5 = 1517,
	A18_MARK___5 = 1518,
	LCDOUT10_MARK___5 = 1519,
	VI4_HSYNC_N_MARK___5 = 1520,
	DU_DG2_MARK___5 = 1521,
	IP5_7_4_MARK___5 = 1522,
	WE1_N_MARK___5 = 1523,
	MSIOF3_SS1_D_MARK___4 = 1524,
	RTS3_N_MARK___4 = 1525,
	HRTS3_N_MARK___4 = 1526,
	SDA6_B_MARK___5 = 1527,
	CAN1_RX_MARK___5 = 1528,
	CANFD1_RX_MARK___5 = 1529,
	IERX_A_MARK___4 = 1530,
	IP6_7_4_MARK___5 = 1531,
	D6_MARK___5 = 1532,
	MSIOF2_RXD_B_MARK___5 = 1533,
	VI4_DATA22_MARK___5 = 1534,
	VI5_DATA6_MARK___4 = 1535,
	IP7_7_4_MARK___5 = 1536,
	D14_MARK___5 = 1537,
	LCDOUT6_MARK___5 = 1538,
	MSIOF3_SS1_A_MARK___5 = 1539,
	HRX3_C_MARK___5 = 1540,
	VI4_DATA6_A_MARK___5 = 1541,
	DU_DR6_MARK___5 = 1542,
	SCL6_C_MARK___4 = 1543,
	IP4_11_8_MARK___5 = 1544,
	A19_MARK___5 = 1545,
	LCDOUT11_MARK___5 = 1546,
	VI4_CLKENB_MARK___5 = 1547,
	DU_DG3_MARK___5 = 1548,
	IP5_11_8_MARK___5 = 1549,
	EX_WAIT0_A_MARK___4 = 1550,
	QCLK_MARK___5 = 1551,
	VI4_CLK_MARK___5 = 1552,
	DU_DOTCLKOUT0_MARK___5 = 1553,
	IP6_11_8_MARK___5 = 1554,
	D7_MARK___5 = 1555,
	MSIOF2_TXD_B_MARK___5 = 1556,
	VI4_DATA23_MARK___5 = 1557,
	VI5_DATA7_MARK___4 = 1558,
	IP7_11_8_MARK___5 = 1559,
	D15_MARK___5 = 1560,
	LCDOUT7_MARK___5 = 1561,
	MSIOF3_SS2_A_MARK___5 = 1562,
	HTX3_C_MARK___5 = 1563,
	VI4_DATA7_A_MARK___5 = 1564,
	DU_DR7_MARK___5 = 1565,
	SDA6_C_MARK___4 = 1566,
	IP4_15_12_MARK___5 = 1567,
	CS0_N_MARK___5 = 1568,
	VI5_CLKENB_MARK___4 = 1569,
	IP5_15_12_MARK___5 = 1570,
	D0_MARK___5 = 1571,
	MSIOF2_SS1_B_MARK___5 = 1572,
	MSIOF3_SCK_A_MARK___5 = 1573,
	VI4_DATA16_MARK___5 = 1574,
	VI5_DATA0_MARK___4 = 1575,
	IP6_15_12_MARK___5 = 1576,
	D8_MARK___5 = 1577,
	LCDOUT0_MARK___5 = 1578,
	MSIOF2_SCK_D_MARK___4 = 1579,
	SCK4_C_MARK___4 = 1580,
	VI4_DATA0_A_MARK___5 = 1581,
	DU_DR0_MARK___5 = 1582,
	IP7_15_12_MARK___2 = 1583,
	FSCLKST_MARK = 1584,
	IP4_19_16_MARK___5 = 1585,
	CS1_N_A26_MARK___2 = 1586,
	VI5_CLK_MARK___4 = 1587,
	EX_WAIT0_B_MARK___4 = 1588,
	IP5_19_16_MARK___5 = 1589,
	D1_MARK___5 = 1590,
	MSIOF2_SS2_B_MARK___5 = 1591,
	MSIOF3_SYNC_A_MARK___5 = 1592,
	VI4_DATA17_MARK___5 = 1593,
	VI5_DATA1_MARK___4 = 1594,
	IP6_19_16_MARK___5 = 1595,
	D9_MARK___5 = 1596,
	LCDOUT1_MARK___5 = 1597,
	MSIOF2_SYNC_D_MARK___4 = 1598,
	VI4_DATA1_A_MARK___5 = 1599,
	DU_DR1_MARK___5 = 1600,
	IP7_19_16_MARK___5 = 1601,
	SD0_CLK_MARK___5 = 1602,
	MSIOF1_SCK_E_MARK___4 = 1603,
	STP_OPWM_0_B_MARK___4 = 1604,
	IP4_23_20_MARK___5 = 1605,
	BS_N_MARK___5 = 1606,
	QSTVA_QVS_MARK___5 = 1607,
	MSIOF3_SCK_D_MARK___4 = 1608,
	SCK3_MARK___4 = 1609,
	HSCK3_MARK___4 = 1610,
	CAN1_TX_MARK___5 = 1611,
	CANFD1_TX_MARK___5 = 1612,
	IETX_A_MARK___4 = 1613,
	IP5_23_20_MARK___5 = 1614,
	D2_MARK___5 = 1615,
	MSIOF3_RXD_A_MARK___5 = 1616,
	VI4_DATA18_MARK___5 = 1617,
	VI5_DATA2_MARK___4 = 1618,
	IP6_23_20_MARK___5 = 1619,
	D10_MARK___5 = 1620,
	LCDOUT2_MARK___5 = 1621,
	MSIOF2_RXD_D_MARK___4 = 1622,
	HRX3_B_MARK___5 = 1623,
	VI4_DATA2_A_MARK___5 = 1624,
	CTS4_N_C_MARK___5 = 1625,
	DU_DR2_MARK___5 = 1626,
	IP7_23_20_MARK___5 = 1627,
	SD0_CMD_MARK___5 = 1628,
	MSIOF1_SYNC_E_MARK___4 = 1629,
	STP_IVCXO27_0_B_MARK___4 = 1630,
	IP4_27_24_MARK___5 = 1631,
	RD_N_MARK___5 = 1632,
	MSIOF3_SYNC_D_MARK___4 = 1633,
	RX3_A_MARK___5 = 1634,
	HRX3_A_MARK___5 = 1635,
	CAN0_TX_A_MARK___4 = 1636,
	CANFD0_TX_A_MARK___4 = 1637,
	IP5_27_24_MARK___5 = 1638,
	D3_MARK___5 = 1639,
	MSIOF3_TXD_A_MARK___5 = 1640,
	VI4_DATA19_MARK___5 = 1641,
	VI5_DATA3_MARK___4 = 1642,
	IP6_27_24_MARK___5 = 1643,
	D11_MARK___5 = 1644,
	LCDOUT3_MARK___5 = 1645,
	MSIOF2_TXD_D_MARK___4 = 1646,
	HTX3_B_MARK___5 = 1647,
	VI4_DATA3_A_MARK___5 = 1648,
	RTS4_N_C_MARK___5 = 1649,
	DU_DR3_MARK___5 = 1650,
	IP7_27_24_MARK___5 = 1651,
	SD0_DAT0_MARK___5 = 1652,
	MSIOF1_RXD_E_MARK___4 = 1653,
	TS_SCK0_B_MARK___4 = 1654,
	STP_ISCLK_0_B_MARK___4 = 1655,
	IP4_31_28_MARK___5 = 1656,
	RD_WR_N_MARK___5 = 1657,
	MSIOF3_RXD_D_MARK___4 = 1658,
	TX3_A_MARK___5 = 1659,
	HTX3_A_MARK___5 = 1660,
	CAN0_RX_A_MARK___4 = 1661,
	CANFD0_RX_A_MARK___4 = 1662,
	IP5_31_28_MARK___5 = 1663,
	D4_MARK___5 = 1664,
	MSIOF2_SCK_B_MARK___5 = 1665,
	VI4_DATA20_MARK___5 = 1666,
	VI5_DATA4_MARK___4 = 1667,
	IP6_31_28_MARK___5 = 1668,
	D12_MARK___5 = 1669,
	LCDOUT4_MARK___5 = 1670,
	MSIOF2_SS1_D_MARK___4 = 1671,
	RX4_C_MARK___5 = 1672,
	VI4_DATA4_A_MARK___5 = 1673,
	DU_DR4_MARK___5 = 1674,
	IP7_31_28_MARK___5 = 1675,
	SD0_DAT1_MARK___5 = 1676,
	MSIOF1_TXD_E_MARK___4 = 1677,
	TS_SPSYNC0_B_MARK___4 = 1678,
	STP_ISSYNC_0_B_MARK___4 = 1679,
	IP8_3_0_MARK___5 = 1680,
	SD0_DAT2_MARK___5 = 1681,
	MSIOF1_SS1_E_MARK___4 = 1682,
	TS_SDAT0_B_MARK___4 = 1683,
	STP_ISD_0_B_MARK___4 = 1684,
	IP9_3_0_MARK___5 = 1685,
	SD2_CLK_MARK___4 = 1686,
	IP10_3_0_MARK___5 = 1687,
	SD3_DAT6_MARK___5 = 1688,
	SD3_CD_MARK___5 = 1689,
	IP11_3_0_MARK___5 = 1690,
	TX0_MARK___4 = 1691,
	HTX1_B_MARK___5 = 1692,
	TS_SPSYNC0_C_MARK___4 = 1693,
	STP_ISSYNC_0_C_MARK___4 = 1694,
	RIF0_D1_B_MARK___5 = 1695,
	IP8_7_4_MARK___5 = 1696,
	SD0_DAT3_MARK___5 = 1697,
	MSIOF1_SS2_E_MARK___4 = 1698,
	TS_SDEN0_B_MARK___4 = 1699,
	STP_ISEN_0_B_MARK___4 = 1700,
	IP9_7_4_MARK___5 = 1701,
	SD2_DAT0_MARK___4 = 1702,
	IP10_7_4_MARK___5 = 1703,
	SD3_DAT7_MARK___5 = 1704,
	SD3_WP_MARK___5 = 1705,
	IP11_7_4_MARK___5 = 1706,
	CTS0_N_MARK___4 = 1707,
	HCTS1_N_B_MARK___5 = 1708,
	MSIOF1_SYNC_B_MARK___4 = 1709,
	TS_SPSYNC1_C_MARK___4 = 1710,
	STP_ISSYNC_1_C_MARK___4 = 1711,
	RIF1_SYNC_B_MARK___4 = 1712,
	AUDIO_CLKOUT_C_MARK___4 = 1713,
	ADICS_SAMP_MARK___4 = 1714,
	IP8_11_8_MARK___5 = 1715,
	SD1_CLK_MARK___5 = 1716,
	MSIOF1_SCK_G_MARK___4 = 1717,
	SIM0_CLK_A_MARK___5 = 1718,
	IP9_11_8_MARK___5 = 1719,
	SD2_DAT1_MARK___4 = 1720,
	IP10_11_8_MARK___5 = 1721,
	SD0_CD_MARK___5 = 1722,
	SCL2_B_MARK___5 = 1723,
	SIM0_RST_A_MARK___5 = 1724,
	IP11_11_8_MARK___5 = 1725,
	RTS0_N_MARK___4 = 1726,
	HRTS1_N_B_MARK___5 = 1727,
	MSIOF1_SS1_B_MARK___4 = 1728,
	AUDIO_CLKA_B_MARK___4 = 1729,
	SCL2_A_MARK___5 = 1730,
	STP_IVCXO27_1_C_MARK___4 = 1731,
	RIF0_SYNC_B_MARK___5 = 1732,
	ADICHS1_MARK___4 = 1733,
	IP8_15_12_MARK___5 = 1734,
	SD1_CMD_MARK___5 = 1735,
	MSIOF1_SYNC_G_MARK___4 = 1736,
	SIM0_D_A_MARK___5 = 1737,
	STP_IVCXO27_1_B_MARK___4 = 1738,
	IP9_15_12_MARK___5 = 1739,
	SD2_DAT2_MARK___4 = 1740,
	IP10_15_12_MARK___5 = 1741,
	SD0_WP_MARK___5 = 1742,
	SDA2_B_MARK___5 = 1743,
	IP11_15_12_MARK___5 = 1744,
	RX1_A_MARK___4 = 1745,
	HRX1_A_MARK___5 = 1746,
	TS_SDAT0_C_MARK___4 = 1747,
	STP_ISD_0_C_MARK___4 = 1748,
	RIF1_CLK_C_MARK___4 = 1749,
	IP8_19_16_MARK___5 = 1750,
	SD1_DAT0_MARK___5 = 1751,
	SD2_DAT4_MARK___4 = 1752,
	MSIOF1_RXD_G_MARK___4 = 1753,
	TS_SCK1_B_MARK___4 = 1754,
	STP_ISCLK_1_B_MARK___4 = 1755,
	IP9_19_16_MARK___5 = 1756,
	SD2_DAT3_MARK___4 = 1757,
	IP10_19_16_MARK___5 = 1758,
	SD1_CD_MARK___5 = 1759,
	SIM0_CLK_B_MARK___5 = 1760,
	IP11_19_16_MARK___5 = 1761,
	TX1_A_MARK___4 = 1762,
	HTX1_A_MARK___5 = 1763,
	TS_SDEN0_C_MARK___4 = 1764,
	STP_ISEN_0_C_MARK___4 = 1765,
	RIF1_D0_C_MARK___4 = 1766,
	IP8_23_20_MARK___5 = 1767,
	SD1_DAT1_MARK___5 = 1768,
	SD2_DAT5_MARK___4 = 1769,
	MSIOF1_TXD_G_MARK___4 = 1770,
	TS_SPSYNC1_B_MARK___4 = 1771,
	STP_ISSYNC_1_B_MARK___4 = 1772,
	IP9_23_20_MARK___5 = 1773,
	SD2_DS_MARK___4 = 1774,
	SATA_DEVSLP_B_MARK___3 = 1775,
	IP10_23_20_MARK___5 = 1776,
	SD1_WP_MARK___5 = 1777,
	SIM0_D_B_MARK___5 = 1778,
	IP11_23_20_MARK___5 = 1779,
	CTS1_N_MARK___5 = 1780,
	HCTS1_N_A_MARK___4 = 1781,
	MSIOF1_RXD_B_MARK___4 = 1782,
	TS_SDEN1_C_MARK___4 = 1783,
	STP_ISEN_1_C_MARK___4 = 1784,
	RIF1_D0_B_MARK___4 = 1785,
	ADIDATA_MARK___4 = 1786,
	IP8_27_24_MARK___5 = 1787,
	SD1_DAT2_MARK___5 = 1788,
	SD2_DAT6_MARK___4 = 1789,
	MSIOF1_SS1_G_MARK___4 = 1790,
	TS_SDAT1_B_MARK___4 = 1791,
	STP_ISD_1_B_MARK___4 = 1792,
	IP9_27_24_MARK___5 = 1793,
	SD3_DAT4_MARK___5 = 1794,
	SD2_CD_A_MARK___4 = 1795,
	IP10_27_24_MARK___5 = 1796,
	SCK0_MARK___4 = 1797,
	HSCK1_B_MARK___5 = 1798,
	MSIOF1_SS2_B_MARK___4 = 1799,
	AUDIO_CLKC_B_MARK___5 = 1800,
	SDA2_A_MARK___5 = 1801,
	SIM0_RST_B_MARK___5 = 1802,
	STP_OPWM_0_C_MARK___4 = 1803,
	RIF0_CLK_B_MARK___5 = 1804,
	ADICHS2_MARK___4 = 1805,
	IP11_27_24_MARK___5 = 1806,
	RTS1_N_MARK___5 = 1807,
	HRTS1_N_A_MARK___4 = 1808,
	MSIOF1_TXD_B_MARK___4 = 1809,
	TS_SDAT1_C_MARK___4 = 1810,
	STP_ISD_1_C_MARK___4 = 1811,
	RIF1_D1_B_MARK___4 = 1812,
	ADICHS0_MARK___4 = 1813,
	IP8_31_28_MARK___5 = 1814,
	SD1_DAT3_MARK___5 = 1815,
	SD2_DAT7_MARK___4 = 1816,
	MSIOF1_SS2_G_MARK___4 = 1817,
	TS_SDEN1_B_MARK___4 = 1818,
	STP_ISEN_1_B_MARK___4 = 1819,
	IP9_31_28_MARK___5 = 1820,
	SD3_DAT5_MARK___5 = 1821,
	SD2_WP_A_MARK___4 = 1822,
	IP10_31_28_MARK___5 = 1823,
	RX0_MARK___4 = 1824,
	HRX1_B_MARK___5 = 1825,
	TS_SCK0_C_MARK___4 = 1826,
	STP_ISCLK_0_C_MARK___4 = 1827,
	RIF0_D0_B_MARK___5 = 1828,
	IP11_31_28_MARK___5 = 1829,
	SCK2_MARK___4 = 1830,
	SCIF_CLK_B_MARK___5 = 1831,
	MSIOF1_SCK_B_MARK___4 = 1832,
	TS_SCK1_C_MARK___4 = 1833,
	STP_ISCLK_1_C_MARK___4 = 1834,
	RIF1_CLK_B_MARK___4 = 1835,
	ADICLK_MARK___4 = 1836,
	IP12_3_0_MARK___5 = 1837,
	TX2_A_MARK___5 = 1838,
	SD2_CD_B_MARK___4 = 1839,
	SCL1_A_MARK___5 = 1840,
	FMCLK_A_MARK___5 = 1841,
	RIF1_D1_C_MARK___4 = 1842,
	FSO_CFE_0_B_MARK = 1843,
	IP13_3_0_MARK___5 = 1844,
	MSIOF0_SS1_MARK___5 = 1845,
	RX5_MARK = 1846,
	AUDIO_CLKA_C_MARK___4 = 1847,
	SSI_SCK2_A_MARK___5 = 1848,
	STP_IVCXO27_0_C_MARK___4 = 1849,
	AUDIO_CLKOUT3_A_MARK___5 = 1850,
	TCLK1_B_MARK___5 = 1851,
	IP14_3_0_MARK___5 = 1852,
	SSI_SDATA1_A_MARK___4 = 1853,
	IP15_3_0_MARK___5 = 1854,
	SSI_SCK6_MARK___5 = 1855,
	USB2_PWEN_MARK___2 = 1856,
	SIM0_RST_D_MARK___4 = 1857,
	IP12_7_4_MARK___5 = 1858,
	RX2_A_MARK___5 = 1859,
	SD2_WP_B_MARK___4 = 1860,
	SDA1_A_MARK___5 = 1861,
	FMIN_A_MARK___5 = 1862,
	RIF1_SYNC_C_MARK___4 = 1863,
	FSO_CFE_1_B_MARK = 1864,
	IP13_7_4_MARK___5 = 1865,
	MSIOF0_SS2_MARK___5 = 1866,
	TX5_MARK = 1867,
	MSIOF1_SS2_D_MARK___4 = 1868,
	AUDIO_CLKC_A_MARK___5 = 1869,
	SSI_WS2_A_MARK___5 = 1870,
	STP_OPWM_0_D_MARK___4 = 1871,
	AUDIO_CLKOUT_D_MARK___4 = 1872,
	SPEEDIN_B_MARK___5 = 1873,
	IP14_7_4_MARK___5 = 1874,
	SSI_SDATA2_A_MARK___4 = 1875,
	SSI_SCK1_B_MARK___4 = 1876,
	IP15_7_4_MARK___5 = 1877,
	SSI_WS6_MARK___5 = 1878,
	USB2_OVC_MARK___2 = 1879,
	SIM0_D_D_MARK___4 = 1880,
	IP12_11_8_MARK___5 = 1881,
	HSCK0_MARK___4 = 1882,
	MSIOF1_SCK_D_MARK___4 = 1883,
	AUDIO_CLKB_A_MARK___5 = 1884,
	SSI_SDATA1_B_MARK___4 = 1885,
	TS_SCK0_D_MARK___4 = 1886,
	STP_ISCLK_0_D_MARK___4 = 1887,
	RIF0_CLK_C_MARK___4 = 1888,
	IP13_11_8_MARK___5 = 1889,
	MLB_CLK_MARK___5 = 1890,
	MSIOF1_SCK_F_MARK___4 = 1891,
	SCL1_B_MARK___5 = 1892,
	IP14_11_8_MARK___5 = 1893,
	SSI_SCK349_MARK___5 = 1894,
	MSIOF1_SS1_A_MARK___4 = 1895,
	STP_OPWM_0_A_MARK___4 = 1896,
	IP15_11_8_MARK___5 = 1897,
	SSI_SDATA6_MARK___5 = 1898,
	SIM0_CLK_D_MARK___4 = 1899,
	SATA_DEVSLP_A_MARK___3 = 1900,
	IP12_15_12_MARK___5 = 1901,
	HRX0_MARK___4 = 1902,
	MSIOF1_RXD_D_MARK___4 = 1903,
	SSI_SDATA2_B_MARK___4 = 1904,
	TS_SDEN0_D_MARK___4 = 1905,
	STP_ISEN_0_D_MARK___4 = 1906,
	RIF0_D0_C_MARK___4 = 1907,
	IP13_15_12_MARK___5 = 1908,
	MLB_SIG_MARK___5 = 1909,
	RX1_B_MARK___4 = 1910,
	MSIOF1_SYNC_F_MARK___4 = 1911,
	SDA1_B_MARK___5 = 1912,
	IP14_15_12_MARK___5 = 1913,
	SSI_WS349_MARK___5 = 1914,
	HCTS2_N_A_MARK___5 = 1915,
	MSIOF1_SS2_A_MARK___4 = 1916,
	STP_IVCXO27_0_A_MARK___4 = 1917,
	IP15_15_12_MARK___5 = 1918,
	SSI_SCK78_MARK___5 = 1919,
	HRX2_B_MARK___5 = 1920,
	MSIOF1_SCK_C_MARK___4 = 1921,
	TS_SCK1_A_MARK___4 = 1922,
	STP_ISCLK_1_A_MARK___4 = 1923,
	RIF1_CLK_A_MARK___4 = 1924,
	RIF3_CLK_A_MARK___5 = 1925,
	IP12_19_16_MARK___5 = 1926,
	HTX0_MARK___4 = 1927,
	MSIOF1_TXD_D_MARK___4 = 1928,
	SSI_SDATA9_B_MARK___4 = 1929,
	TS_SDAT0_D_MARK___4 = 1930,
	STP_ISD_0_D_MARK___4 = 1931,
	RIF0_D1_C_MARK___4 = 1932,
	IP13_19_16_MARK___5 = 1933,
	MLB_DAT_MARK___5 = 1934,
	TX1_B_MARK___4 = 1935,
	MSIOF1_RXD_F_MARK___4 = 1936,
	IP14_19_16_MARK___5 = 1937,
	SSI_SDATA3_MARK___5 = 1938,
	HRTS2_N_A_MARK___5 = 1939,
	MSIOF1_TXD_A_MARK___4 = 1940,
	TS_SCK0_A_MARK___4 = 1941,
	STP_ISCLK_0_A_MARK___4 = 1942,
	RIF0_D1_A_MARK___5 = 1943,
	RIF2_D0_A_MARK___5 = 1944,
	IP15_19_16_MARK___5 = 1945,
	SSI_WS78_MARK___5 = 1946,
	HTX2_B_MARK___5 = 1947,
	MSIOF1_SYNC_C_MARK___4 = 1948,
	TS_SDAT1_A_MARK___4 = 1949,
	STP_ISD_1_A_MARK___4 = 1950,
	RIF1_SYNC_A_MARK___4 = 1951,
	RIF3_SYNC_A_MARK___5 = 1952,
	IP12_23_20_MARK___5 = 1953,
	HCTS0_N_MARK___4 = 1954,
	RX2_B_MARK___5 = 1955,
	MSIOF1_SYNC_D_MARK___4 = 1956,
	SSI_SCK9_A_MARK___5 = 1957,
	TS_SPSYNC0_D_MARK___4 = 1958,
	STP_ISSYNC_0_D_MARK___4 = 1959,
	RIF0_SYNC_C_MARK___4 = 1960,
	AUDIO_CLKOUT1_A_MARK___5 = 1961,
	IP13_23_20_MARK___5 = 1962,
	SSI_SCK01239_MARK___5 = 1963,
	MSIOF1_TXD_F_MARK___4 = 1964,
	IP14_23_20_MARK___5 = 1965,
	SSI_SCK4_MARK___5 = 1966,
	HRX2_A_MARK___5 = 1967,
	MSIOF1_SCK_A_MARK___4 = 1968,
	TS_SDAT0_A_MARK___4 = 1969,
	STP_ISD_0_A_MARK___4 = 1970,
	RIF0_CLK_A_MARK___5 = 1971,
	RIF2_CLK_A_MARK___5 = 1972,
	IP15_23_20_MARK___5 = 1973,
	SSI_SDATA7_MARK___5 = 1974,
	HCTS2_N_B_MARK___4 = 1975,
	MSIOF1_RXD_C_MARK___4 = 1976,
	TS_SDEN1_A_MARK___4 = 1977,
	STP_ISEN_1_A_MARK___4 = 1978,
	RIF1_D0_A_MARK___4 = 1979,
	RIF3_D0_A_MARK___5 = 1980,
	TCLK2_A_MARK___5 = 1981,
	IP12_27_24_MARK___5 = 1982,
	HRTS0_N_MARK___4 = 1983,
	TX2_B_MARK___5 = 1984,
	MSIOF1_SS1_D_MARK___4 = 1985,
	SSI_WS9_A_MARK___5 = 1986,
	STP_IVCXO27_0_D_MARK___4 = 1987,
	BPFCLK_A_MARK___5 = 1988,
	AUDIO_CLKOUT2_A_MARK___5 = 1989,
	IP13_27_24_MARK___5 = 1990,
	SSI_WS01239_MARK___5 = 1991,
	MSIOF1_SS1_F_MARK___4 = 1992,
	IP14_27_24_MARK___5 = 1993,
	SSI_WS4_MARK___5 = 1994,
	HTX2_A_MARK___5 = 1995,
	MSIOF1_SYNC_A_MARK___4 = 1996,
	TS_SDEN0_A_MARK___4 = 1997,
	STP_ISEN_0_A_MARK___4 = 1998,
	RIF0_SYNC_A_MARK___5 = 1999,
	RIF2_SYNC_A_MARK___5 = 2000,
	IP15_27_24_MARK___5 = 2001,
	SSI_SDATA8_MARK___5 = 2002,
	HRTS2_N_B_MARK___4 = 2003,
	MSIOF1_TXD_C_MARK___4 = 2004,
	TS_SPSYNC1_A_MARK___4 = 2005,
	STP_ISSYNC_1_A_MARK___4 = 2006,
	RIF1_D1_A_MARK___4 = 2007,
	RIF3_D1_A_MARK___5 = 2008,
	IP12_31_28_MARK___5 = 2009,
	MSIOF0_SYNC_MARK___5 = 2010,
	AUDIO_CLKOUT_A_MARK___5 = 2011,
	IP13_31_28_MARK___5 = 2012,
	SSI_SDATA0_MARK___5 = 2013,
	MSIOF1_SS2_F_MARK___4 = 2014,
	IP14_31_28_MARK___5 = 2015,
	SSI_SDATA4_MARK___5 = 2016,
	HSCK2_A_MARK___5 = 2017,
	MSIOF1_RXD_A_MARK___4 = 2018,
	TS_SPSYNC0_A_MARK___4 = 2019,
	STP_ISSYNC_0_A_MARK___4 = 2020,
	RIF0_D0_A_MARK___5 = 2021,
	RIF2_D1_A_MARK___5 = 2022,
	IP15_31_28_MARK___5 = 2023,
	SSI_SDATA9_A_MARK___4 = 2024,
	HSCK2_B_MARK___4 = 2025,
	MSIOF1_SS1_C_MARK___4 = 2026,
	HSCK1_A_MARK___5 = 2027,
	SSI_WS1_B_MARK___4 = 2028,
	SCK1_MARK___5 = 2029,
	STP_IVCXO27_1_A_MARK___4 = 2030,
	SCK5_MARK = 2031,
	IP16_3_0_MARK___4 = 2032,
	AUDIO_CLKA_A_MARK___4 = 2033,
	IP17_3_0_MARK___4 = 2034,
	USB31_PWEN_MARK = 2035,
	AUDIO_CLKOUT2_B_MARK___5 = 2036,
	SSI_SCK9_B_MARK___5 = 2037,
	TS_SDEN0_E_MARK___4 = 2038,
	STP_ISEN_0_E_MARK___4 = 2039,
	RIF2_D0_B_MARK___5 = 2040,
	TPU0TO2_MARK___5 = 2041,
	IP16_7_4_MARK___4 = 2042,
	AUDIO_CLKB_B_MARK___5 = 2043,
	SCIF_CLK_A_MARK___5 = 2044,
	STP_IVCXO27_1_D_MARK___4 = 2045,
	REMOCON_A_MARK___5 = 2046,
	TCLK1_A_MARK___5 = 2047,
	IP17_7_4_MARK___4 = 2048,
	USB31_OVC_MARK = 2049,
	AUDIO_CLKOUT3_B_MARK___5 = 2050,
	SSI_WS9_B_MARK___5 = 2051,
	TS_SPSYNC0_E_MARK___4 = 2052,
	STP_ISSYNC_0_E_MARK___4 = 2053,
	RIF2_D1_B_MARK___5 = 2054,
	TPU0TO3_MARK___5 = 2055,
	IP16_11_8_MARK___4 = 2056,
	USB0_PWEN_MARK___4 = 2057,
	SIM0_RST_C_MARK___4 = 2058,
	TS_SCK1_D_MARK___4 = 2059,
	STP_ISCLK_1_D_MARK___4 = 2060,
	BPFCLK_B_MARK___5 = 2061,
	RIF3_CLK_B_MARK___5 = 2062,
	IP16_15_12_MARK___4 = 2063,
	USB0_OVC_MARK___4 = 2064,
	SIM0_D_C_MARK___4 = 2065,
	TS_SDAT1_D_MARK___4 = 2066,
	STP_ISD_1_D_MARK___4 = 2067,
	RIF3_SYNC_B_MARK___5 = 2068,
	IP16_19_16_MARK___4 = 2069,
	USB1_PWEN_MARK___4 = 2070,
	SIM0_CLK_C_MARK___4 = 2071,
	SSI_SCK1_A_MARK___4 = 2072,
	TS_SCK0_E_MARK___4 = 2073,
	STP_ISCLK_0_E_MARK___4 = 2074,
	FMCLK_B_MARK___5 = 2075,
	RIF2_CLK_B_MARK___5 = 2076,
	SPEEDIN_A_MARK___5 = 2077,
	IP16_23_20_MARK___4 = 2078,
	USB1_OVC_MARK___4 = 2079,
	MSIOF1_SS2_C_MARK___4 = 2080,
	SSI_WS1_A_MARK___4 = 2081,
	TS_SDAT0_E_MARK___4 = 2082,
	STP_ISD_0_E_MARK___4 = 2083,
	FMIN_B_MARK___5 = 2084,
	RIF2_SYNC_B_MARK___5 = 2085,
	REMOCON_B_MARK___5 = 2086,
	IP16_27_24_MARK___4 = 2087,
	USB30_PWEN_MARK___5 = 2088,
	AUDIO_CLKOUT_B_MARK___5 = 2089,
	SSI_SCK2_B_MARK___5 = 2090,
	TS_SDEN1_D_MARK___4 = 2091,
	STP_ISEN_1_D_MARK___4 = 2092,
	STP_OPWM_0_E_MARK___4 = 2093,
	RIF3_D0_B_MARK___5 = 2094,
	TCLK2_B_MARK___5 = 2095,
	TPU0TO0_MARK___5 = 2096,
	IP16_31_28_MARK___4 = 2097,
	USB30_OVC_MARK___5 = 2098,
	AUDIO_CLKOUT1_B_MARK___5 = 2099,
	SSI_WS2_B_MARK___5 = 2100,
	TS_SPSYNC1_D_MARK___4 = 2101,
	STP_ISSYNC_1_D_MARK___4 = 2102,
	STP_IVCXO27_0_E_MARK___4 = 2103,
	RIF3_D1_B_MARK___5 = 2104,
	FSO_TOE_B_MARK = 2105,
	TPU0TO1_MARK___5 = 2106,
	SEL_TSIF1_0_MARK___4 = 2107,
	SEL_TSIF1_1_MARK___4 = 2108,
	SEL_TSIF1_2_MARK___4 = 2109,
	SEL_TSIF1_3_MARK___4 = 2110,
	I2C_SEL_5_0_MARK___4 = 2111,
	I2C_SEL_5_1_MARK___4 = 2112,
	SEL_MSIOF3_0_MARK___5 = 2113,
	SEL_MSIOF3_1_MARK___5 = 2114,
	SEL_MSIOF3_2_MARK___4 = 2115,
	SEL_MSIOF3_3_MARK___4 = 2116,
	I2C_SEL_3_0_MARK___4 = 2117,
	I2C_SEL_3_1_MARK___4 = 2118,
	SEL_TSIF0_0_MARK___4 = 2119,
	SEL_TSIF0_1_MARK___4 = 2120,
	SEL_TSIF0_2_MARK___4 = 2121,
	SEL_TSIF0_3_MARK___4 = 2122,
	SEL_TSIF0_4_MARK___4 = 2123,
	I2C_SEL_0_0_MARK___4 = 2124,
	I2C_SEL_0_1_MARK___4 = 2125,
	SEL_MSIOF2_0_MARK___5 = 2126,
	SEL_MSIOF2_1_MARK___5 = 2127,
	SEL_MSIOF2_2_MARK___4 = 2128,
	SEL_MSIOF2_3_MARK___4 = 2129,
	SEL_MSIOF1_0_MARK___4 = 2130,
	SEL_MSIOF1_1_MARK___4 = 2131,
	SEL_MSIOF1_2_MARK___4 = 2132,
	SEL_MSIOF1_3_MARK___4 = 2133,
	SEL_MSIOF1_4_MARK___4 = 2134,
	SEL_MSIOF1_5_MARK___4 = 2135,
	SEL_MSIOF1_6_MARK___4 = 2136,
	SEL_TIMER_TMU_0_MARK___4 = 2137,
	SEL_TIMER_TMU_1_MARK___4 = 2138,
	SEL_SSP1_1_0_MARK___4 = 2139,
	SEL_SSP1_1_1_MARK___4 = 2140,
	SEL_SSP1_1_2_MARK___4 = 2141,
	SEL_SSP1_1_3_MARK___4 = 2142,
	SEL_LBSC_0_MARK___4 = 2143,
	SEL_LBSC_1_MARK___4 = 2144,
	SEL_SSP1_0_0_MARK___4 = 2145,
	SEL_SSP1_0_1_MARK___4 = 2146,
	SEL_SSP1_0_2_MARK___4 = 2147,
	SEL_SSP1_0_3_MARK___4 = 2148,
	SEL_SSP1_0_4_MARK___4 = 2149,
	SEL_IEBUS_0_MARK___4 = 2150,
	SEL_IEBUS_1_MARK___4 = 2151,
	SEL_I2C6_0_MARK___5 = 2152,
	SEL_I2C6_1_MARK___5 = 2153,
	SEL_I2C6_2_MARK___4 = 2154,
	SEL_SSI_0_MARK = 2155,
	SEL_SSI_1_MARK = 2156,
	SEL_I2C2_0_MARK___5 = 2157,
	SEL_I2C2_1_MARK___5 = 2158,
	SEL_SPEED_PULSE_0_MARK___4 = 2159,
	SEL_SPEED_PULSE_1_MARK___4 = 2160,
	SEL_I2C1_0_MARK___5 = 2161,
	SEL_I2C1_1_MARK___5 = 2162,
	SEL_SIMCARD_0_MARK___5 = 2163,
	SEL_SIMCARD_1_MARK___5 = 2164,
	SEL_SIMCARD_2_MARK___4 = 2165,
	SEL_SIMCARD_3_MARK___4 = 2166,
	SEL_HSCIF4_0_MARK___5 = 2167,
	SEL_HSCIF4_1_MARK___5 = 2168,
	SEL_HSCIF3_0_MARK___5 = 2169,
	SEL_HSCIF3_1_MARK___5 = 2170,
	SEL_HSCIF3_2_MARK___5 = 2171,
	SEL_HSCIF3_3_MARK___5 = 2172,
	SEL_SDHI2_0_MARK___4 = 2173,
	SEL_SDHI2_1_MARK___4 = 2174,
	SEL_SCIF4_0_MARK___5 = 2175,
	SEL_SCIF4_1_MARK___5 = 2176,
	SEL_SCIF4_2_MARK___5 = 2177,
	SEL_HSCIF2_0_MARK___5 = 2178,
	SEL_HSCIF2_1_MARK___5 = 2179,
	SEL_HSCIF1_0_MARK___5 = 2180,
	SEL_HSCIF1_1_MARK___5 = 2181,
	SEL_SCIF3_0_MARK___5 = 2182,
	SEL_SCIF3_1_MARK___5 = 2183,
	SEL_FSO_0_MARK___2 = 2184,
	SEL_FSO_1_MARK___2 = 2185,
	SEL_SCIF2_0_MARK___5 = 2186,
	SEL_SCIF2_1_MARK___5 = 2187,
	SEL_FM_0_MARK___5 = 2188,
	SEL_FM_1_MARK___5 = 2189,
	SEL_SCIF1_0_MARK___4 = 2190,
	SEL_SCIF1_1_MARK___4 = 2191,
	SEL_ETHERAVB_0_MARK___4 = 2192,
	SEL_ETHERAVB_1_MARK___4 = 2193,
	SEL_SATA_0_MARK = 2194,
	SEL_SATA_1_MARK = 2195,
	SEL_DRIF3_0_MARK___5 = 2196,
	SEL_DRIF3_1_MARK___5 = 2197,
	SEL_REMOCON_0_MARK___5 = 2198,
	SEL_REMOCON_1_MARK___5 = 2199,
	SEL_DRIF2_0_MARK___5 = 2200,
	SEL_DRIF2_1_MARK___5 = 2201,
	SEL_DRIF1_0_MARK___4 = 2202,
	SEL_DRIF1_1_MARK___4 = 2203,
	SEL_DRIF1_2_MARK___4 = 2204,
	SEL_RCAN0_0_MARK___4 = 2205,
	SEL_RCAN0_1_MARK___4 = 2206,
	SEL_DRIF0_0_MARK___5 = 2207,
	SEL_DRIF0_1_MARK___5 = 2208,
	SEL_DRIF0_2_MARK___4 = 2209,
	SEL_PWM6_0_MARK___5 = 2210,
	SEL_PWM6_1_MARK___5 = 2211,
	SEL_PWM5_0_MARK___5 = 2212,
	SEL_PWM5_1_MARK___5 = 2213,
	SEL_CANFD0_0_MARK___4 = 2214,
	SEL_CANFD0_1_MARK___4 = 2215,
	SEL_PWM4_0_MARK___5 = 2216,
	SEL_PWM4_1_MARK___5 = 2217,
	SEL_ADG_0_MARK = 2218,
	SEL_ADG_1_MARK = 2219,
	SEL_ADG_2_MARK = 2220,
	SEL_ADG_3_MARK = 2221,
	SEL_PWM3_0_MARK___5 = 2222,
	SEL_PWM3_1_MARK___5 = 2223,
	SEL_PWM2_0_MARK___5 = 2224,
	SEL_PWM2_1_MARK___5 = 2225,
	SEL_PWM1_0_MARK___5 = 2226,
	SEL_PWM1_1_MARK___5 = 2227,
	SEL_VIN4_0_MARK___5 = 2228,
	SEL_VIN4_1_MARK___5 = 2229,
	QSPI0_SPCLK_MARK___5 = 2230,
	QSPI0_SSL_MARK___5 = 2231,
	QSPI0_MOSI_IO0_MARK___5 = 2232,
	QSPI0_MISO_IO1_MARK___5 = 2233,
	QSPI0_IO2_MARK___5 = 2234,
	QSPI0_IO3_MARK___5 = 2235,
	QSPI1_SPCLK_MARK___5 = 2236,
	QSPI1_SSL_MARK___5 = 2237,
	QSPI1_MOSI_IO0_MARK___5 = 2238,
	QSPI1_MISO_IO1_MARK___5 = 2239,
	QSPI1_IO2_MARK___5 = 2240,
	QSPI1_IO3_MARK___5 = 2241,
	RPC_INT_MARK___4 = 2242,
	RPC_WP_MARK___4 = 2243,
	RPC_RESET_MARK___4 = 2244,
	AVB_TX_CTL_MARK___5 = 2245,
	AVB_TXC_MARK___5 = 2246,
	AVB_TD0_MARK___5 = 2247,
	AVB_TD1_MARK___5 = 2248,
	AVB_TD2_MARK___5 = 2249,
	AVB_TD3_MARK___5 = 2250,
	AVB_RX_CTL_MARK___5 = 2251,
	AVB_RXC_MARK___5 = 2252,
	AVB_RD0_MARK___5 = 2253,
	AVB_RD1_MARK___5 = 2254,
	AVB_RD2_MARK___5 = 2255,
	AVB_RD3_MARK___5 = 2256,
	AVB_TXCREFCLK_MARK___5 = 2257,
	AVB_MDIO_MARK___5 = 2258,
	CLKOUT_MARK___5 = 2259,
	PRESETOUT_MARK___4 = 2260,
	DU_DOTCLKIN0_MARK___5 = 2261,
	DU_DOTCLKIN1_MARK___5 = 2262,
	DU_DOTCLKIN2_MARK___3 = 2263,
	DU_DOTCLKIN3_MARK___3 = 2264,
	TMS_MARK___5 = 2265,
	TDO_MARK___4 = 2266,
	ASEBRK_MARK___5 = 2267,
	MLB_REF_MARK___5 = 2268,
	TDI_MARK___5 = 2269,
	TCK_MARK___5 = 2270,
	TRST_MARK___4 = 2271,
	EXTALR_MARK___4 = 2272,
	SCL0_MARK___4 = 2273,
	SDA0_MARK___4 = 2274,
	SCL3_MARK___4 = 2275,
	SDA3_MARK___4 = 2276,
	SCL5_MARK___5 = 2277,
	SDA5_MARK___5 = 2278,
	PINMUX_MARK_END___5 = 2279,
};

enum {
	GP_LAST___5 = 227,
	PIN_ASEBRK___5 = 228,
	PIN_AVB_MDIO___5 = 229,
	PIN_AVB_RD0___4 = 230,
	PIN_AVB_RD1___4 = 231,
	PIN_AVB_RD2___4 = 232,
	PIN_AVB_RD3___4 = 233,
	PIN_AVB_RXC___4 = 234,
	PIN_AVB_RX_CTL___4 = 235,
	PIN_AVB_TD0___5 = 236,
	PIN_AVB_TD1___5 = 237,
	PIN_AVB_TD2___5 = 238,
	PIN_AVB_TD3___5 = 239,
	PIN_AVB_TXC___5 = 240,
	PIN_AVB_TXCREFCLK___4 = 241,
	PIN_AVB_TX_CTL___5 = 242,
	PIN_CLKOUT = 243,
	PIN_DU_DOTCLKIN0___4 = 244,
	PIN_DU_DOTCLKIN1___4 = 245,
	PIN_DU_DOTCLKIN2___3 = 246,
	PIN_DU_DOTCLKIN3___3 = 247,
	PIN_EXTALR___4 = 248,
	PIN_FSCLKST_N___3 = 249,
	PIN_MLB_REF___5 = 250,
	PIN_PRESETOUT_N___5 = 251,
	PIN_QSPI0_IO2___4 = 252,
	PIN_QSPI0_IO3___4 = 253,
	PIN_QSPI0_MISO_IO1___4 = 254,
	PIN_QSPI0_MOSI_IO0___4 = 255,
	PIN_QSPI0_SPCLK___4 = 256,
	PIN_QSPI0_SSL___4 = 257,
	PIN_QSPI1_IO2___4 = 258,
	PIN_QSPI1_IO3___4 = 259,
	PIN_QSPI1_MISO_IO1___4 = 260,
	PIN_QSPI1_MOSI_IO0___4 = 261,
	PIN_QSPI1_SPCLK___4 = 262,
	PIN_QSPI1_SSL___4 = 263,
	PIN_RPC_INT_N___4 = 264,
	PIN_RPC_RESET_N___4 = 265,
	PIN_RPC_WP_N___4 = 266,
	PIN_TCK___5 = 267,
	PIN_TDI___5 = 268,
	PIN_TDO___4 = 269,
	PIN_TMS___5 = 270,
	PIN_TRST_N___5 = 271,
};

union vin_data12 {
	unsigned int data12[12];
	unsigned int data10[10];
	unsigned int data8[8];
};

enum {
	PINMUX_RESERVED___6 = 0,
	PINMUX_DATA_BEGIN___6 = 1,
	GP_0_0_DATA___6 = 2,
	GP_0_1_DATA___6 = 3,
	GP_0_2_DATA___6 = 4,
	GP_0_3_DATA___6 = 5,
	GP_0_4_DATA___6 = 6,
	GP_0_5_DATA___6 = 7,
	GP_0_6_DATA___6 = 8,
	GP_0_7_DATA___6 = 9,
	GP_0_8_DATA___6 = 10,
	GP_0_9_DATA___6 = 11,
	GP_0_10_DATA___6 = 12,
	GP_0_11_DATA___6 = 13,
	GP_0_12_DATA___6 = 14,
	GP_0_13_DATA___6 = 15,
	GP_0_14_DATA___6 = 16,
	GP_0_15_DATA___6 = 17,
	GP_0_16_DATA___2 = 18,
	GP_0_17_DATA___2 = 19,
	GP_0_18_DATA = 20,
	GP_0_19_DATA = 21,
	GP_0_20_DATA = 22,
	GP_0_21_DATA = 23,
	GP_1_0_DATA___6 = 24,
	GP_1_1_DATA___6 = 25,
	GP_1_2_DATA___6 = 26,
	GP_1_3_DATA___6 = 27,
	GP_1_4_DATA___6 = 28,
	GP_1_5_DATA___6 = 29,
	GP_1_6_DATA___6 = 30,
	GP_1_7_DATA___6 = 31,
	GP_1_8_DATA___6 = 32,
	GP_1_9_DATA___6 = 33,
	GP_1_10_DATA___6 = 34,
	GP_1_11_DATA___6 = 35,
	GP_1_12_DATA___6 = 36,
	GP_1_13_DATA___6 = 37,
	GP_1_14_DATA___6 = 38,
	GP_1_15_DATA___6 = 39,
	GP_1_16_DATA___6 = 40,
	GP_1_17_DATA___6 = 41,
	GP_1_18_DATA___6 = 42,
	GP_1_19_DATA___6 = 43,
	GP_1_20_DATA___6 = 44,
	GP_1_21_DATA___6 = 45,
	GP_1_22_DATA___6 = 46,
	GP_1_23_DATA___5 = 47,
	GP_1_24_DATA___5 = 48,
	GP_1_25_DATA___5 = 49,
	GP_1_26_DATA___5 = 50,
	GP_1_27_DATA___5 = 51,
	GP_2_0_DATA___6 = 52,
	GP_2_1_DATA___6 = 53,
	GP_2_2_DATA___6 = 54,
	GP_2_3_DATA___6 = 55,
	GP_2_4_DATA___6 = 56,
	GP_2_5_DATA___6 = 57,
	GP_2_6_DATA___6 = 58,
	GP_2_7_DATA___6 = 59,
	GP_2_8_DATA___6 = 60,
	GP_2_9_DATA___6 = 61,
	GP_2_10_DATA___6 = 62,
	GP_2_11_DATA___6 = 63,
	GP_2_12_DATA___6 = 64,
	GP_2_13_DATA___6 = 65,
	GP_2_14_DATA___6 = 66,
	GP_2_15_DATA___2 = 67,
	GP_2_16_DATA___2 = 68,
	GP_3_0_DATA___6 = 69,
	GP_3_1_DATA___6 = 70,
	GP_3_2_DATA___6 = 71,
	GP_3_3_DATA___6 = 72,
	GP_3_4_DATA___6 = 73,
	GP_3_5_DATA___6 = 74,
	GP_3_6_DATA___6 = 75,
	GP_3_7_DATA___6 = 76,
	GP_3_8_DATA___6 = 77,
	GP_3_9_DATA___6 = 78,
	GP_3_10_DATA___6 = 79,
	GP_3_11_DATA___6 = 80,
	GP_3_12_DATA___6 = 81,
	GP_3_13_DATA___6 = 82,
	GP_3_14_DATA___6 = 83,
	GP_3_15_DATA___6 = 84,
	GP_3_16_DATA = 85,
	GP_4_0_DATA___6 = 86,
	GP_4_1_DATA___6 = 87,
	GP_4_2_DATA___6 = 88,
	GP_4_3_DATA___6 = 89,
	GP_4_4_DATA___6 = 90,
	GP_4_5_DATA___6 = 91,
	GP_5_0_DATA___6 = 92,
	GP_5_1_DATA___6 = 93,
	GP_5_2_DATA___6 = 94,
	GP_5_3_DATA___6 = 95,
	GP_5_4_DATA___6 = 96,
	GP_5_5_DATA___6 = 97,
	GP_5_6_DATA___6 = 98,
	GP_5_7_DATA___6 = 99,
	GP_5_8_DATA___6 = 100,
	GP_5_9_DATA___6 = 101,
	GP_5_10_DATA___6 = 102,
	GP_5_11_DATA___6 = 103,
	GP_5_12_DATA___6 = 104,
	GP_5_13_DATA___6 = 105,
	GP_5_14_DATA___6 = 106,
	PINMUX_DATA_END___6 = 107,
	PINMUX_FUNCTION_BEGIN___6 = 108,
	GP_0_0_FN___6 = 109,
	GP_0_1_FN___6 = 110,
	GP_0_2_FN___6 = 111,
	GP_0_3_FN___6 = 112,
	GP_0_4_FN___6 = 113,
	GP_0_5_FN___6 = 114,
	GP_0_6_FN___6 = 115,
	GP_0_7_FN___6 = 116,
	GP_0_8_FN___6 = 117,
	GP_0_9_FN___6 = 118,
	GP_0_10_FN___6 = 119,
	GP_0_11_FN___6 = 120,
	GP_0_12_FN___6 = 121,
	GP_0_13_FN___6 = 122,
	GP_0_14_FN___6 = 123,
	GP_0_15_FN___6 = 124,
	GP_0_16_FN___2 = 125,
	GP_0_17_FN___2 = 126,
	GP_0_18_FN = 127,
	GP_0_19_FN = 128,
	GP_0_20_FN = 129,
	GP_0_21_FN = 130,
	GP_1_0_FN___6 = 131,
	GP_1_1_FN___6 = 132,
	GP_1_2_FN___6 = 133,
	GP_1_3_FN___6 = 134,
	GP_1_4_FN___6 = 135,
	GP_1_5_FN___6 = 136,
	GP_1_6_FN___6 = 137,
	GP_1_7_FN___6 = 138,
	GP_1_8_FN___6 = 139,
	GP_1_9_FN___6 = 140,
	GP_1_10_FN___6 = 141,
	GP_1_11_FN___6 = 142,
	GP_1_12_FN___6 = 143,
	GP_1_13_FN___6 = 144,
	GP_1_14_FN___6 = 145,
	GP_1_15_FN___6 = 146,
	GP_1_16_FN___6 = 147,
	GP_1_17_FN___6 = 148,
	GP_1_18_FN___6 = 149,
	GP_1_19_FN___6 = 150,
	GP_1_20_FN___6 = 151,
	GP_1_21_FN___6 = 152,
	GP_1_22_FN___6 = 153,
	GP_1_23_FN___5 = 154,
	GP_1_24_FN___5 = 155,
	GP_1_25_FN___5 = 156,
	GP_1_26_FN___5 = 157,
	GP_1_27_FN___5 = 158,
	GP_2_0_FN___6 = 159,
	GP_2_1_FN___6 = 160,
	GP_2_2_FN___6 = 161,
	GP_2_3_FN___6 = 162,
	GP_2_4_FN___6 = 163,
	GP_2_5_FN___6 = 164,
	GP_2_6_FN___6 = 165,
	GP_2_7_FN___6 = 166,
	GP_2_8_FN___6 = 167,
	GP_2_9_FN___6 = 168,
	GP_2_10_FN___6 = 169,
	GP_2_11_FN___6 = 170,
	GP_2_12_FN___6 = 171,
	GP_2_13_FN___6 = 172,
	GP_2_14_FN___6 = 173,
	GP_2_15_FN___2 = 174,
	GP_2_16_FN___2 = 175,
	GP_3_0_FN___6 = 176,
	GP_3_1_FN___6 = 177,
	GP_3_2_FN___6 = 178,
	GP_3_3_FN___6 = 179,
	GP_3_4_FN___6 = 180,
	GP_3_5_FN___6 = 181,
	GP_3_6_FN___6 = 182,
	GP_3_7_FN___6 = 183,
	GP_3_8_FN___6 = 184,
	GP_3_9_FN___6 = 185,
	GP_3_10_FN___6 = 186,
	GP_3_11_FN___6 = 187,
	GP_3_12_FN___6 = 188,
	GP_3_13_FN___6 = 189,
	GP_3_14_FN___6 = 190,
	GP_3_15_FN___6 = 191,
	GP_3_16_FN = 192,
	GP_4_0_FN___6 = 193,
	GP_4_1_FN___6 = 194,
	GP_4_2_FN___6 = 195,
	GP_4_3_FN___6 = 196,
	GP_4_4_FN___6 = 197,
	GP_4_5_FN___6 = 198,
	GP_5_0_FN___6 = 199,
	GP_5_1_FN___6 = 200,
	GP_5_2_FN___6 = 201,
	GP_5_3_FN___6 = 202,
	GP_5_4_FN___6 = 203,
	GP_5_5_FN___6 = 204,
	GP_5_6_FN___6 = 205,
	GP_5_7_FN___6 = 206,
	GP_5_8_FN___6 = 207,
	GP_5_9_FN___6 = 208,
	GP_5_10_FN___6 = 209,
	GP_5_11_FN___6 = 210,
	GP_5_12_FN___6 = 211,
	GP_5_13_FN___6 = 212,
	GP_5_14_FN___6 = 213,
	FN_AVB0_AVTP_MATCH = 214,
	FN_AVB0_LINK = 215,
	FN_AVB0_PHY_INT = 216,
	FN_AVB0_MAGIC = 217,
	FN_AVB0_MDC = 218,
	FN_AVB0_MDIO = 219,
	FN_RPC_INT_N___2 = 220,
	FN_AVB0_TXCREFCLK = 221,
	FN_RPC_WP_N = 222,
	FN_AVB0_TD3 = 223,
	FN_RPC_RESET_N___2 = 224,
	FN_AVB0_TD2 = 225,
	FN_QSPI1_SSL___2 = 226,
	FN_AVB0_TD1 = 227,
	FN_QSPI1_IO3___2 = 228,
	FN_AVB0_TD0 = 229,
	FN_QSPI1_IO2___2 = 230,
	FN_AVB0_TXC = 231,
	FN_QSPI1_MISO_IO1___2 = 232,
	FN_AVB0_TX_CTL = 233,
	FN_QSPI1_MOSI_IO0___2 = 234,
	FN_AVB0_RD3 = 235,
	FN_QSPI1_SPCLK___2 = 236,
	FN_AVB0_RD2 = 237,
	FN_QSPI0_SSL___2 = 238,
	FN_AVB0_RD1 = 239,
	FN_QSPI0_IO3___2 = 240,
	FN_AVB0_RD0 = 241,
	FN_QSPI0_IO2___2 = 242,
	FN_AVB0_RXC = 243,
	FN_QSPI0_MISO_IO1___2 = 244,
	FN_AVB0_RX_CTL = 245,
	FN_QSPI0_MOSI_IO0___2 = 246,
	FN_QSPI0_SPCLK___2 = 247,
	FN_IP0_3_0___6 = 248,
	FN_DU_DR2___6 = 249,
	FN_HSCK0___5 = 250,
	FN_A0___6 = 251,
	FN_IP1_3_0___6 = 252,
	FN_DU_DG4___6 = 253,
	FN_A8___6 = 254,
	FN_FSO_CFE_0_N_A___2 = 255,
	FN_IP2_3_0___6 = 256,
	FN_DU_DB6___6 = 257,
	FN_A16___6 = 258,
	FN_FXR_TXENB_N = 259,
	FN_IP3_3_0___6 = 260,
	FN_VI0_CLKENB = 261,
	FN_MSIOF2_RXD = 262,
	FN_RX3 = 263,
	FN_RD_WR_N___6 = 264,
	FN_HCTS3_N___5 = 265,
	FN_IP0_7_4___6 = 266,
	FN_DU_DR3___6 = 267,
	FN_HRTS0_N___5 = 268,
	FN_A1___6 = 269,
	FN_IP1_7_4___6 = 270,
	FN_DU_DG5___6 = 271,
	FN_A9___6 = 272,
	FN_FSO_CFE_1_N_A___2 = 273,
	FN_IP2_7_4___6 = 274,
	FN_DU_DB7___6 = 275,
	FN_A17___6 = 276,
	FN_IP3_7_4___6 = 277,
	FN_VI0_HSYNC_N = 278,
	FN_MSIOF2_TXD = 279,
	FN_TX3 = 280,
	FN_HRTS3_N___5 = 281,
	FN_IP0_11_8___6 = 282,
	FN_DU_DR4___6 = 283,
	FN_HCTS0_N___5 = 284,
	FN_A2___6 = 285,
	FN_IP1_11_8___6 = 286,
	FN_DU_DG6___6 = 287,
	FN_A10___6 = 288,
	FN_FSO_TOE_N_A___2 = 289,
	FN_IP2_11_8___6 = 290,
	FN_DU_DOTCLKOUT = 291,
	FN_SCIF_CLK_A___6 = 292,
	FN_A18___6 = 293,
	FN_IP3_11_8___6 = 294,
	FN_VI0_VSYNC_N = 295,
	FN_MSIOF2_SYNC = 296,
	FN_CTS3_N___5 = 297,
	FN_HTX3 = 298,
	FN_IP0_15_12___6 = 299,
	FN_DU_DR5___6 = 300,
	FN_HTX0___5 = 301,
	FN_A3___6 = 302,
	FN_IP1_15_12___6 = 303,
	FN_DU_DG7___6 = 304,
	FN_A11___6 = 305,
	FN_IRQ1___6 = 306,
	FN_IP2_15_12___6 = 307,
	FN_DU_EXHSYNC_DU_HSYNC___5 = 308,
	FN_HRX0___5 = 309,
	FN_A19___6 = 310,
	FN_IRQ3___6 = 311,
	FN_IP3_15_12___6 = 312,
	FN_VI0_DATA0 = 313,
	FN_MSIOF2_SS1 = 314,
	FN_RTS3_N___5 = 315,
	FN_HRX3 = 316,
	FN_IP0_19_16___6 = 317,
	FN_DU_DR6___6 = 318,
	FN_MSIOF3_RXD = 319,
	FN_A4___6 = 320,
	FN_IP1_19_16___6 = 321,
	FN_DU_DB2___6 = 322,
	FN_A12___6 = 323,
	FN_IRQ2___6 = 324,
	FN_IP2_19_16___6 = 325,
	FN_DU_EXVSYNC_DU_VSYNC___5 = 326,
	FN_MSIOF3_SCK = 327,
	FN_IP3_19_16___6 = 328,
	FN_VI0_DATA1 = 329,
	FN_MSIOF2_SS2 = 330,
	FN_SCK1___6 = 331,
	FN_SPEEDIN_A___6 = 332,
	FN_IP0_23_20___6 = 333,
	FN_DU_DR7___6 = 334,
	FN_MSIOF3_TXD = 335,
	FN_A5___6 = 336,
	FN_IP1_23_20___6 = 337,
	FN_DU_DB3___6 = 338,
	FN_A13___6 = 339,
	FN_FXR_CLKOUT1 = 340,
	FN_IP2_23_20___6 = 341,
	FN_DU_EXODDF_DU_ODDF_DISP_CDE___5 = 342,
	FN_MSIOF3_SYNC = 343,
	FN_IP3_23_20___6 = 344,
	FN_VI0_DATA2 = 345,
	FN_AVB0_AVTP_PPS = 346,
	FN_SDA3_A = 347,
	FN_IP0_27_24___6 = 348,
	FN_DU_DG2___6 = 349,
	FN_MSIOF3_SS1 = 350,
	FN_A6___6 = 351,
	FN_IP1_27_24___6 = 352,
	FN_DU_DB4___6 = 353,
	FN_A14___6 = 354,
	FN_FXR_CLKOUT2 = 355,
	FN_IP2_27_24___6 = 356,
	FN_IRQ0___6 = 357,
	FN_IP3_27_24___6 = 358,
	FN_VI0_DATA3 = 359,
	FN_HSCK1 = 360,
	FN_SCL3_A = 361,
	FN_IP0_31_28___6 = 362,
	FN_DU_DG3___6 = 363,
	FN_MSIOF3_SS2 = 364,
	FN_A7___6 = 365,
	FN_PWMFSW0 = 366,
	FN_IP1_31_28___6 = 367,
	FN_DU_DB5___6 = 368,
	FN_A15___6 = 369,
	FN_FXR_TXENA_N = 370,
	FN_IP2_31_28___6 = 371,
	FN_VI0_CLK = 372,
	FN_MSIOF2_SCK = 373,
	FN_SCK3___5 = 374,
	FN_HSCK3___5 = 375,
	FN_IP3_31_28___6 = 376,
	FN_VI0_DATA4 = 377,
	FN_HRTS1_N = 378,
	FN_RX1_A___5 = 379,
	FN_IP4_3_0___6 = 380,
	FN_VI0_DATA5 = 381,
	FN_HCTS1_N = 382,
	FN_TX1_A___5 = 383,
	FN_IP5_3_0___6 = 384,
	FN_VI1_CLK = 385,
	FN_MSIOF1_RXD___2 = 386,
	FN_CS0_N___6 = 387,
	FN_IP6_3_0___6 = 388,
	FN_VI1_DATA4 = 389,
	FN_CANFD_CLK_B = 390,
	FN_D7___6 = 391,
	FN_MMC_D2 = 392,
	FN_IP7_3_0___6 = 393,
	FN_VI1_FIELD = 394,
	FN_SDA4___2 = 395,
	FN_IRQ5___6 = 396,
	FN_D15___6 = 397,
	FN_IP4_7_4___6 = 398,
	FN_VI0_DATA6 = 399,
	FN_HTX1 = 400,
	FN_CTS1_N___6 = 401,
	FN_IP5_7_4___6 = 402,
	FN_VI1_CLKENB = 403,
	FN_MSIOF1_TXD___2 = 404,
	FN_D0___6 = 405,
	FN_IP6_7_4___6 = 406,
	FN_VI1_DATA5 = 407,
	FN_SCK4 = 408,
	FN_D8___6 = 409,
	FN_MMC_D3 = 410,
	FN_IP7_7_4___6 = 411,
	FN_SCL0 = 412,
	FN_DU_DR0___6 = 413,
	FN_TPU0TO0___6 = 414,
	FN_CLKOUT___5 = 415,
	FN_MSIOF0_RXD___6 = 416,
	FN_IP4_11_8___6 = 417,
	FN_VI0_DATA7 = 418,
	FN_HRX1 = 419,
	FN_RTS1_N___6 = 420,
	FN_IP5_11_8___6 = 421,
	FN_VI1_HSYNC_N = 422,
	FN_MSIOF1_SCK___2 = 423,
	FN_D1___6 = 424,
	FN_IP6_11_8___6 = 425,
	FN_VI1_DATA6 = 426,
	FN_RX4 = 427,
	FN_D9___6 = 428,
	FN_MMC_CLK = 429,
	FN_IP7_11_8___6 = 430,
	FN_SDA0 = 431,
	FN_DU_DR1___6 = 432,
	FN_TPU0TO1___6 = 433,
	FN_BS_N___6 = 434,
	FN_SCK0___5 = 435,
	FN_MSIOF0_TXD___6 = 436,
	FN_IP4_15_12___6 = 437,
	FN_VI0_DATA8 = 438,
	FN_HSCK2 = 439,
	FN_PWM0_A___2 = 440,
	FN_A22___2 = 441,
	FN_IP5_15_12___6 = 442,
	FN_VI1_VSYNC_N = 443,
	FN_MSIOF1_SYNC___2 = 444,
	FN_D2___6 = 445,
	FN_IP6_15_12___6 = 446,
	FN_VI1_DATA7 = 447,
	FN_TX4 = 448,
	FN_D10___6 = 449,
	FN_MMC_D4 = 450,
	FN_IP7_15_12___3 = 451,
	FN_SCL1 = 452,
	FN_DU_DG0___6 = 453,
	FN_TPU0TO2___6 = 454,
	FN_RD_N___6 = 455,
	FN_CTS0_N___5 = 456,
	FN_MSIOF0_SCK___6 = 457,
	FN_IP4_19_16___6 = 458,
	FN_VI0_DATA9 = 459,
	FN_HCTS2_N = 460,
	FN_PWM1_A___6 = 461,
	FN_A23___2 = 462,
	FN_FSO_CFE_0_N_B___2 = 463,
	FN_IP5_19_16___6 = 464,
	FN_VI1_DATA0 = 465,
	FN_MSIOF1_SS1___2 = 466,
	FN_D3___6 = 467,
	FN_IP6_19_16___6 = 468,
	FN_VI1_DATA8 = 469,
	FN_CTS4_N = 470,
	FN_D11___6 = 471,
	FN_MMC_D5 = 472,
	FN_IP7_19_16___6 = 473,
	FN_SDA1 = 474,
	FN_DU_DG1___6 = 475,
	FN_TPU0TO3___6 = 476,
	FN_WE0_N___6 = 477,
	FN_RTS0_N___5 = 478,
	FN_MSIOF0_SYNC___6 = 479,
	FN_IP4_23_20___6 = 480,
	FN_VI0_DATA10 = 481,
	FN_HRTS2_N = 482,
	FN_PWM2_A___6 = 483,
	FN_A24___2 = 484,
	FN_FSO_CFE_1_N_B___2 = 485,
	FN_IP5_23_20___6 = 486,
	FN_VI1_DATA1 = 487,
	FN_MSIOF1_SS2___2 = 488,
	FN_D4___6 = 489,
	FN_MMC_CMD = 490,
	FN_IP6_23_20___6 = 491,
	FN_VI1_DATA9 = 492,
	FN_RTS4_N = 493,
	FN_D12___6 = 494,
	FN_MMC_D6 = 495,
	FN_SCL3_B = 496,
	FN_IP7_23_20___6 = 497,
	FN_SCL2 = 498,
	FN_DU_DB0___6 = 499,
	FN_TCLK1_A___6 = 500,
	FN_WE1_N___6 = 501,
	FN_RX0___5 = 502,
	FN_MSIOF0_SS1___6 = 503,
	FN_IP4_27_24___6 = 504,
	FN_VI0_DATA11 = 505,
	FN_HTX2 = 506,
	FN_PWM3_A___6 = 507,
	FN_A25___2 = 508,
	FN_FSO_TOE_N_B___2 = 509,
	FN_IP5_27_24___6 = 510,
	FN_VI1_DATA2 = 511,
	FN_CANFD0_TX_B___5 = 512,
	FN_D5___6 = 513,
	FN_MMC_D0 = 514,
	FN_IP6_27_24___6 = 515,
	FN_VI1_DATA10 = 516,
	FN_D13___6 = 517,
	FN_MMC_D7 = 518,
	FN_SDA3_B = 519,
	FN_IP7_27_24___6 = 520,
	FN_SDA2 = 521,
	FN_DU_DB1___6 = 522,
	FN_TCLK2_A___6 = 523,
	FN_EX_WAIT0___2 = 524,
	FN_TX0___5 = 525,
	FN_MSIOF0_SS2___6 = 526,
	FN_IP4_31_28___6 = 527,
	FN_VI0_FIELD = 528,
	FN_HRX2 = 529,
	FN_PWM4_A___6 = 530,
	FN_CS1_N___4 = 531,
	FN_FSCLKST2_N_A___4 = 532,
	FN_IP5_31_28___6 = 533,
	FN_VI1_DATA3 = 534,
	FN_CANFD0_RX_B___5 = 535,
	FN_D6___6 = 536,
	FN_MMC_D1 = 537,
	FN_IP6_31_28___6 = 538,
	FN_VI1_DATA11 = 539,
	FN_SCL4___2 = 540,
	FN_IRQ4___6 = 541,
	FN_D14___6 = 542,
	FN_IP7_31_28___6 = 543,
	FN_AVB0_AVTP_CAPTURE = 544,
	FN_FSCLKST2_N_B___4 = 545,
	FN_IP8_3_0___6 = 546,
	FN_CANFD0_TX_A___5 = 547,
	FN_FXR_TXDA = 548,
	FN_PWM0_B___2 = 549,
	FN_DU_DISP___6 = 550,
	FN_FSCLKST2_N_C = 551,
	FN_IP8_7_4___6 = 552,
	FN_CANFD0_RX_A___5 = 553,
	FN_RXDA_EXTFXR = 554,
	FN_PWM1_B___6 = 555,
	FN_DU_CDE___6 = 556,
	FN_IP8_11_8___6 = 557,
	FN_CANFD1_TX___6 = 558,
	FN_FXR_TXDB = 559,
	FN_PWM2_B___6 = 560,
	FN_TCLK1_B___6 = 561,
	FN_TX1_B___5 = 562,
	FN_IP8_15_12___6 = 563,
	FN_CANFD1_RX___6 = 564,
	FN_RXDB_EXTFXR = 565,
	FN_PWM3_B___6 = 566,
	FN_TCLK2_B___6 = 567,
	FN_RX1_B___5 = 568,
	FN_IP8_19_16___6 = 569,
	FN_CANFD_CLK_A = 570,
	FN_CLK_EXTFXR = 571,
	FN_PWM4_B___6 = 572,
	FN_SPEEDIN_B___6 = 573,
	FN_SCIF_CLK_B___6 = 574,
	FN_IP8_23_20___6 = 575,
	FN_DIGRF_CLKIN = 576,
	FN_DIGRF_CLKEN_IN = 577,
	FN_IP8_27_24___6 = 578,
	FN_DIGRF_CLKOUT = 579,
	FN_DIGRF_CLKEN_OUT = 580,
	FN_IP8_31_28___6 = 581,
	FN_SEL_I2C3_0 = 582,
	FN_SEL_I2C3_1 = 583,
	FN_SEL_HSCIF0_0___2 = 584,
	FN_SEL_HSCIF0_1___2 = 585,
	FN_SEL_SCIF1_0___5 = 586,
	FN_SEL_SCIF1_1___5 = 587,
	FN_SEL_CANFD0_0___5 = 588,
	FN_SEL_CANFD0_1___5 = 589,
	FN_SEL_PWM4_0___6 = 590,
	FN_SEL_PWM4_1___6 = 591,
	FN_SEL_PWM3_0___6 = 592,
	FN_SEL_PWM3_1___6 = 593,
	FN_SEL_PWM2_0___6 = 594,
	FN_SEL_PWM2_1___6 = 595,
	FN_SEL_PWM1_0___6 = 596,
	FN_SEL_PWM1_1___6 = 597,
	FN_SEL_PWM0_0___2 = 598,
	FN_SEL_PWM0_1___2 = 599,
	FN_SEL_RFSO_0 = 600,
	FN_SEL_RFSO_1 = 601,
	FN_SEL_RSP_0 = 602,
	FN_SEL_RSP_1 = 603,
	FN_SEL_TMU_0 = 604,
	FN_SEL_TMU_1 = 605,
	PINMUX_FUNCTION_END___6 = 606,
	PINMUX_MARK_BEGIN___6 = 607,
	AVB0_AVTP_MATCH_MARK = 608,
	AVB0_LINK_MARK = 609,
	AVB0_PHY_INT_MARK = 610,
	AVB0_MAGIC_MARK = 611,
	AVB0_MDC_MARK = 612,
	AVB0_MDIO_MARK = 613,
	RPC_INT_N_MARK___2 = 614,
	AVB0_TXCREFCLK_MARK = 615,
	RPC_WP_N_MARK = 616,
	AVB0_TD3_MARK = 617,
	RPC_RESET_N_MARK___2 = 618,
	AVB0_TD2_MARK = 619,
	QSPI1_SSL_MARK___6 = 620,
	AVB0_TD1_MARK = 621,
	QSPI1_IO3_MARK___6 = 622,
	AVB0_TD0_MARK = 623,
	QSPI1_IO2_MARK___6 = 624,
	AVB0_TXC_MARK = 625,
	QSPI1_MISO_IO1_MARK___6 = 626,
	AVB0_TX_CTL_MARK = 627,
	QSPI1_MOSI_IO0_MARK___6 = 628,
	AVB0_RD3_MARK = 629,
	QSPI1_SPCLK_MARK___6 = 630,
	AVB0_RD2_MARK = 631,
	QSPI0_SSL_MARK___6 = 632,
	AVB0_RD1_MARK = 633,
	QSPI0_IO3_MARK___6 = 634,
	AVB0_RD0_MARK = 635,
	QSPI0_IO2_MARK___6 = 636,
	AVB0_RXC_MARK = 637,
	QSPI0_MISO_IO1_MARK___6 = 638,
	AVB0_RX_CTL_MARK = 639,
	QSPI0_MOSI_IO0_MARK___6 = 640,
	QSPI0_SPCLK_MARK___6 = 641,
	IP0_3_0_MARK___6 = 642,
	DU_DR2_MARK___6 = 643,
	HSCK0_MARK___5 = 644,
	A0_MARK___6 = 645,
	IP1_3_0_MARK___6 = 646,
	DU_DG4_MARK___6 = 647,
	A8_MARK___6 = 648,
	FSO_CFE_0_N_A_MARK___2 = 649,
	IP2_3_0_MARK___6 = 650,
	DU_DB6_MARK___6 = 651,
	A16_MARK___6 = 652,
	FXR_TXENB_N_MARK = 653,
	IP3_3_0_MARK___6 = 654,
	VI0_CLKENB_MARK = 655,
	MSIOF2_RXD_MARK = 656,
	RX3_MARK = 657,
	RD_WR_N_MARK___6 = 658,
	HCTS3_N_MARK___5 = 659,
	IP0_7_4_MARK___6 = 660,
	DU_DR3_MARK___6 = 661,
	HRTS0_N_MARK___5 = 662,
	A1_MARK___6 = 663,
	IP1_7_4_MARK___6 = 664,
	DU_DG5_MARK___6 = 665,
	A9_MARK___6 = 666,
	FSO_CFE_1_N_A_MARK___2 = 667,
	IP2_7_4_MARK___6 = 668,
	DU_DB7_MARK___6 = 669,
	A17_MARK___6 = 670,
	IP3_7_4_MARK___6 = 671,
	VI0_HSYNC_N_MARK = 672,
	MSIOF2_TXD_MARK = 673,
	TX3_MARK = 674,
	HRTS3_N_MARK___5 = 675,
	IP0_11_8_MARK___6 = 676,
	DU_DR4_MARK___6 = 677,
	HCTS0_N_MARK___5 = 678,
	A2_MARK___6 = 679,
	IP1_11_8_MARK___6 = 680,
	DU_DG6_MARK___6 = 681,
	A10_MARK___6 = 682,
	FSO_TOE_N_A_MARK___2 = 683,
	IP2_11_8_MARK___6 = 684,
	DU_DOTCLKOUT_MARK = 685,
	SCIF_CLK_A_MARK___6 = 686,
	A18_MARK___6 = 687,
	IP3_11_8_MARK___6 = 688,
	VI0_VSYNC_N_MARK = 689,
	MSIOF2_SYNC_MARK = 690,
	CTS3_N_MARK___5 = 691,
	HTX3_MARK = 692,
	IP0_15_12_MARK___6 = 693,
	DU_DR5_MARK___6 = 694,
	HTX0_MARK___5 = 695,
	A3_MARK___6 = 696,
	IP1_15_12_MARK___6 = 697,
	DU_DG7_MARK___6 = 698,
	A11_MARK___6 = 699,
	IRQ1_MARK___6 = 700,
	IP2_15_12_MARK___6 = 701,
	DU_EXHSYNC_DU_HSYNC_MARK___5 = 702,
	HRX0_MARK___5 = 703,
	A19_MARK___6 = 704,
	IRQ3_MARK___6 = 705,
	IP3_15_12_MARK___6 = 706,
	VI0_DATA0_MARK = 707,
	MSIOF2_SS1_MARK = 708,
	RTS3_N_MARK___5 = 709,
	HRX3_MARK = 710,
	IP0_19_16_MARK___6 = 711,
	DU_DR6_MARK___6 = 712,
	MSIOF3_RXD_MARK = 713,
	A4_MARK___6 = 714,
	IP1_19_16_MARK___6 = 715,
	DU_DB2_MARK___6 = 716,
	A12_MARK___6 = 717,
	IRQ2_MARK___6 = 718,
	IP2_19_16_MARK___6 = 719,
	DU_EXVSYNC_DU_VSYNC_MARK___5 = 720,
	MSIOF3_SCK_MARK = 721,
	IP3_19_16_MARK___6 = 722,
	VI0_DATA1_MARK = 723,
	MSIOF2_SS2_MARK = 724,
	SCK1_MARK___6 = 725,
	SPEEDIN_A_MARK___6 = 726,
	IP0_23_20_MARK___6 = 727,
	DU_DR7_MARK___6 = 728,
	MSIOF3_TXD_MARK = 729,
	A5_MARK___6 = 730,
	IP1_23_20_MARK___6 = 731,
	DU_DB3_MARK___6 = 732,
	A13_MARK___6 = 733,
	FXR_CLKOUT1_MARK = 734,
	IP2_23_20_MARK___6 = 735,
	DU_EXODDF_DU_ODDF_DISP_CDE_MARK___5 = 736,
	MSIOF3_SYNC_MARK = 737,
	IP3_23_20_MARK___6 = 738,
	VI0_DATA2_MARK = 739,
	AVB0_AVTP_PPS_MARK = 740,
	SDA3_A_MARK = 741,
	IP0_27_24_MARK___6 = 742,
	DU_DG2_MARK___6 = 743,
	MSIOF3_SS1_MARK = 744,
	A6_MARK___6 = 745,
	IP1_27_24_MARK___6 = 746,
	DU_DB4_MARK___6 = 747,
	A14_MARK___6 = 748,
	FXR_CLKOUT2_MARK = 749,
	IP2_27_24_MARK___6 = 750,
	IRQ0_MARK___6 = 751,
	IP3_27_24_MARK___6 = 752,
	VI0_DATA3_MARK = 753,
	HSCK1_MARK = 754,
	SCL3_A_MARK = 755,
	IP0_31_28_MARK___6 = 756,
	DU_DG3_MARK___6 = 757,
	MSIOF3_SS2_MARK = 758,
	A7_MARK___6 = 759,
	PWMFSW0_MARK = 760,
	IP1_31_28_MARK___6 = 761,
	DU_DB5_MARK___6 = 762,
	A15_MARK___6 = 763,
	FXR_TXENA_N_MARK = 764,
	IP2_31_28_MARK___6 = 765,
	VI0_CLK_MARK = 766,
	MSIOF2_SCK_MARK = 767,
	SCK3_MARK___5 = 768,
	HSCK3_MARK___5 = 769,
	IP3_31_28_MARK___6 = 770,
	VI0_DATA4_MARK = 771,
	HRTS1_N_MARK = 772,
	RX1_A_MARK___5 = 773,
	IP4_3_0_MARK___6 = 774,
	VI0_DATA5_MARK = 775,
	HCTS1_N_MARK = 776,
	TX1_A_MARK___5 = 777,
	IP5_3_0_MARK___6 = 778,
	VI1_CLK_MARK = 779,
	MSIOF1_RXD_MARK___2 = 780,
	CS0_N_MARK___6 = 781,
	IP6_3_0_MARK___6 = 782,
	VI1_DATA4_MARK = 783,
	CANFD_CLK_B_MARK = 784,
	D7_MARK___6 = 785,
	MMC_D2_MARK = 786,
	IP7_3_0_MARK___6 = 787,
	VI1_FIELD_MARK = 788,
	SDA4_MARK___2 = 789,
	IRQ5_MARK___6 = 790,
	D15_MARK___6 = 791,
	IP4_7_4_MARK___6 = 792,
	VI0_DATA6_MARK = 793,
	HTX1_MARK = 794,
	CTS1_N_MARK___6 = 795,
	IP5_7_4_MARK___6 = 796,
	VI1_CLKENB_MARK = 797,
	MSIOF1_TXD_MARK___2 = 798,
	D0_MARK___6 = 799,
	IP6_7_4_MARK___6 = 800,
	VI1_DATA5_MARK = 801,
	SCK4_MARK = 802,
	D8_MARK___6 = 803,
	MMC_D3_MARK = 804,
	IP7_7_4_MARK___6 = 805,
	SCL0_MARK___5 = 806,
	DU_DR0_MARK___6 = 807,
	TPU0TO0_MARK___6 = 808,
	CLKOUT_MARK___6 = 809,
	MSIOF0_RXD_MARK___6 = 810,
	IP4_11_8_MARK___6 = 811,
	VI0_DATA7_MARK = 812,
	HRX1_MARK = 813,
	RTS1_N_MARK___6 = 814,
	IP5_11_8_MARK___6 = 815,
	VI1_HSYNC_N_MARK = 816,
	MSIOF1_SCK_MARK___2 = 817,
	D1_MARK___6 = 818,
	IP6_11_8_MARK___6 = 819,
	VI1_DATA6_MARK = 820,
	RX4_MARK = 821,
	D9_MARK___6 = 822,
	MMC_CLK_MARK = 823,
	IP7_11_8_MARK___6 = 824,
	SDA0_MARK___5 = 825,
	DU_DR1_MARK___6 = 826,
	TPU0TO1_MARK___6 = 827,
	BS_N_MARK___6 = 828,
	SCK0_MARK___5 = 829,
	MSIOF0_TXD_MARK___6 = 830,
	IP4_15_12_MARK___6 = 831,
	VI0_DATA8_MARK = 832,
	HSCK2_MARK = 833,
	PWM0_A_MARK___2 = 834,
	A22_MARK___2 = 835,
	IP5_15_12_MARK___6 = 836,
	VI1_VSYNC_N_MARK = 837,
	MSIOF1_SYNC_MARK___2 = 838,
	D2_MARK___6 = 839,
	IP6_15_12_MARK___6 = 840,
	VI1_DATA7_MARK = 841,
	TX4_MARK = 842,
	D10_MARK___6 = 843,
	MMC_D4_MARK = 844,
	IP7_15_12_MARK___3 = 845,
	SCL1_MARK = 846,
	DU_DG0_MARK___6 = 847,
	TPU0TO2_MARK___6 = 848,
	RD_N_MARK___6 = 849,
	CTS0_N_MARK___5 = 850,
	MSIOF0_SCK_MARK___6 = 851,
	IP4_19_16_MARK___6 = 852,
	VI0_DATA9_MARK = 853,
	HCTS2_N_MARK = 854,
	PWM1_A_MARK___6 = 855,
	A23_MARK___2 = 856,
	FSO_CFE_0_N_B_MARK___2 = 857,
	IP5_19_16_MARK___6 = 858,
	VI1_DATA0_MARK = 859,
	MSIOF1_SS1_MARK___2 = 860,
	D3_MARK___6 = 861,
	IP6_19_16_MARK___6 = 862,
	VI1_DATA8_MARK = 863,
	CTS4_N_MARK = 864,
	D11_MARK___6 = 865,
	MMC_D5_MARK = 866,
	IP7_19_16_MARK___6 = 867,
	SDA1_MARK = 868,
	DU_DG1_MARK___6 = 869,
	TPU0TO3_MARK___6 = 870,
	WE0_N_MARK___6 = 871,
	RTS0_N_MARK___5 = 872,
	MSIOF0_SYNC_MARK___6 = 873,
	IP4_23_20_MARK___6 = 874,
	VI0_DATA10_MARK = 875,
	HRTS2_N_MARK = 876,
	PWM2_A_MARK___6 = 877,
	A24_MARK___2 = 878,
	FSO_CFE_1_N_B_MARK___2 = 879,
	IP5_23_20_MARK___6 = 880,
	VI1_DATA1_MARK = 881,
	MSIOF1_SS2_MARK___2 = 882,
	D4_MARK___6 = 883,
	MMC_CMD_MARK = 884,
	IP6_23_20_MARK___6 = 885,
	VI1_DATA9_MARK = 886,
	RTS4_N_MARK = 887,
	D12_MARK___6 = 888,
	MMC_D6_MARK = 889,
	SCL3_B_MARK = 890,
	IP7_23_20_MARK___6 = 891,
	SCL2_MARK = 892,
	DU_DB0_MARK___6 = 893,
	TCLK1_A_MARK___6 = 894,
	WE1_N_MARK___6 = 895,
	RX0_MARK___5 = 896,
	MSIOF0_SS1_MARK___6 = 897,
	IP4_27_24_MARK___6 = 898,
	VI0_DATA11_MARK = 899,
	HTX2_MARK = 900,
	PWM3_A_MARK___6 = 901,
	A25_MARK___2 = 902,
	FSO_TOE_N_B_MARK___2 = 903,
	IP5_27_24_MARK___6 = 904,
	VI1_DATA2_MARK = 905,
	CANFD0_TX_B_MARK___5 = 906,
	D5_MARK___6 = 907,
	MMC_D0_MARK = 908,
	IP6_27_24_MARK___6 = 909,
	VI1_DATA10_MARK = 910,
	D13_MARK___6 = 911,
	MMC_D7_MARK = 912,
	SDA3_B_MARK = 913,
	IP7_27_24_MARK___6 = 914,
	SDA2_MARK = 915,
	DU_DB1_MARK___6 = 916,
	TCLK2_A_MARK___6 = 917,
	EX_WAIT0_MARK___2 = 918,
	TX0_MARK___5 = 919,
	MSIOF0_SS2_MARK___6 = 920,
	IP4_31_28_MARK___6 = 921,
	VI0_FIELD_MARK = 922,
	HRX2_MARK = 923,
	PWM4_A_MARK___6 = 924,
	CS1_N_MARK___4 = 925,
	FSCLKST2_N_A_MARK___4 = 926,
	IP5_31_28_MARK___6 = 927,
	VI1_DATA3_MARK = 928,
	CANFD0_RX_B_MARK___5 = 929,
	D6_MARK___6 = 930,
	MMC_D1_MARK = 931,
	IP6_31_28_MARK___6 = 932,
	VI1_DATA11_MARK = 933,
	SCL4_MARK___2 = 934,
	IRQ4_MARK___6 = 935,
	D14_MARK___6 = 936,
	IP7_31_28_MARK___6 = 937,
	AVB0_AVTP_CAPTURE_MARK = 938,
	FSCLKST2_N_B_MARK___4 = 939,
	IP8_3_0_MARK___6 = 940,
	CANFD0_TX_A_MARK___5 = 941,
	FXR_TXDA_MARK = 942,
	PWM0_B_MARK___2 = 943,
	DU_DISP_MARK___6 = 944,
	FSCLKST2_N_C_MARK = 945,
	IP8_7_4_MARK___6 = 946,
	CANFD0_RX_A_MARK___5 = 947,
	RXDA_EXTFXR_MARK = 948,
	PWM1_B_MARK___6 = 949,
	DU_CDE_MARK___6 = 950,
	IP8_11_8_MARK___6 = 951,
	CANFD1_TX_MARK___6 = 952,
	FXR_TXDB_MARK = 953,
	PWM2_B_MARK___6 = 954,
	TCLK1_B_MARK___6 = 955,
	TX1_B_MARK___5 = 956,
	IP8_15_12_MARK___6 = 957,
	CANFD1_RX_MARK___6 = 958,
	RXDB_EXTFXR_MARK = 959,
	PWM3_B_MARK___6 = 960,
	TCLK2_B_MARK___6 = 961,
	RX1_B_MARK___5 = 962,
	IP8_19_16_MARK___6 = 963,
	CANFD_CLK_A_MARK = 964,
	CLK_EXTFXR_MARK = 965,
	PWM4_B_MARK___6 = 966,
	SPEEDIN_B_MARK___6 = 967,
	SCIF_CLK_B_MARK___6 = 968,
	IP8_23_20_MARK___6 = 969,
	DIGRF_CLKIN_MARK = 970,
	DIGRF_CLKEN_IN_MARK = 971,
	IP8_27_24_MARK___6 = 972,
	DIGRF_CLKOUT_MARK = 973,
	DIGRF_CLKEN_OUT_MARK = 974,
	IP8_31_28_MARK___6 = 975,
	SEL_I2C3_0_MARK = 976,
	SEL_I2C3_1_MARK = 977,
	SEL_HSCIF0_0_MARK___2 = 978,
	SEL_HSCIF0_1_MARK___2 = 979,
	SEL_SCIF1_0_MARK___5 = 980,
	SEL_SCIF1_1_MARK___5 = 981,
	SEL_CANFD0_0_MARK___5 = 982,
	SEL_CANFD0_1_MARK___5 = 983,
	SEL_PWM4_0_MARK___6 = 984,
	SEL_PWM4_1_MARK___6 = 985,
	SEL_PWM3_0_MARK___6 = 986,
	SEL_PWM3_1_MARK___6 = 987,
	SEL_PWM2_0_MARK___6 = 988,
	SEL_PWM2_1_MARK___6 = 989,
	SEL_PWM1_0_MARK___6 = 990,
	SEL_PWM1_1_MARK___6 = 991,
	SEL_PWM0_0_MARK___2 = 992,
	SEL_PWM0_1_MARK___2 = 993,
	SEL_RFSO_0_MARK = 994,
	SEL_RFSO_1_MARK = 995,
	SEL_RSP_0_MARK = 996,
	SEL_RSP_1_MARK = 997,
	SEL_TMU_0_MARK = 998,
	SEL_TMU_1_MARK = 999,
	PINMUX_MARK_END___6 = 1000,
};

enum ioctrl_regs___3 {
	POCCTRL0___2 = 0,
	POCCTRL1 = 1,
	POCCTRL2 = 2,
	TDSELCTRL___3 = 3,
};

enum {
	PINMUX_RESERVED___7 = 0,
	PINMUX_DATA_BEGIN___7 = 1,
	GP_0_0_DATA___7 = 2,
	GP_0_1_DATA___7 = 3,
	GP_0_2_DATA___7 = 4,
	GP_0_3_DATA___7 = 5,
	GP_0_4_DATA___7 = 6,
	GP_0_5_DATA___7 = 7,
	GP_0_6_DATA___7 = 8,
	GP_0_7_DATA___7 = 9,
	GP_0_8_DATA___7 = 10,
	GP_0_9_DATA___7 = 11,
	GP_0_10_DATA___7 = 12,
	GP_0_11_DATA___7 = 13,
	GP_0_12_DATA___7 = 14,
	GP_0_13_DATA___7 = 15,
	GP_0_14_DATA___7 = 16,
	GP_0_15_DATA___7 = 17,
	GP_0_16_DATA___3 = 18,
	GP_0_17_DATA___3 = 19,
	GP_0_18_DATA___2 = 20,
	GP_0_19_DATA___2 = 21,
	GP_0_20_DATA___2 = 22,
	GP_0_21_DATA___2 = 23,
	GP_1_0_DATA___7 = 24,
	GP_1_1_DATA___7 = 25,
	GP_1_2_DATA___7 = 26,
	GP_1_3_DATA___7 = 27,
	GP_1_4_DATA___7 = 28,
	GP_1_5_DATA___7 = 29,
	GP_1_6_DATA___7 = 30,
	GP_1_7_DATA___7 = 31,
	GP_1_8_DATA___7 = 32,
	GP_1_9_DATA___7 = 33,
	GP_1_10_DATA___7 = 34,
	GP_1_11_DATA___7 = 35,
	GP_1_12_DATA___7 = 36,
	GP_1_13_DATA___7 = 37,
	GP_1_14_DATA___7 = 38,
	GP_1_15_DATA___7 = 39,
	GP_1_16_DATA___7 = 40,
	GP_1_17_DATA___7 = 41,
	GP_1_18_DATA___7 = 42,
	GP_1_19_DATA___7 = 43,
	GP_1_20_DATA___7 = 44,
	GP_1_21_DATA___7 = 45,
	GP_1_22_DATA___7 = 46,
	GP_1_23_DATA___6 = 47,
	GP_1_24_DATA___6 = 48,
	GP_1_25_DATA___6 = 49,
	GP_1_26_DATA___6 = 50,
	GP_1_27_DATA___6 = 51,
	GP_2_0_DATA___7 = 52,
	GP_2_1_DATA___7 = 53,
	GP_2_2_DATA___7 = 54,
	GP_2_3_DATA___7 = 55,
	GP_2_4_DATA___7 = 56,
	GP_2_5_DATA___7 = 57,
	GP_2_6_DATA___7 = 58,
	GP_2_7_DATA___7 = 59,
	GP_2_8_DATA___7 = 60,
	GP_2_9_DATA___7 = 61,
	GP_2_10_DATA___7 = 62,
	GP_2_11_DATA___7 = 63,
	GP_2_12_DATA___7 = 64,
	GP_2_13_DATA___7 = 65,
	GP_2_14_DATA___7 = 66,
	GP_2_15_DATA___3 = 67,
	GP_2_16_DATA___3 = 68,
	GP_2_17_DATA___2 = 69,
	GP_2_18_DATA___2 = 70,
	GP_2_19_DATA___2 = 71,
	GP_2_20_DATA___2 = 72,
	GP_2_21_DATA___2 = 73,
	GP_2_22_DATA___2 = 74,
	GP_2_23_DATA___2 = 75,
	GP_2_24_DATA___2 = 76,
	GP_2_25_DATA___2 = 77,
	GP_2_26_DATA = 78,
	GP_2_27_DATA = 79,
	GP_2_28_DATA = 80,
	GP_2_29_DATA = 81,
	GP_3_0_DATA___7 = 82,
	GP_3_1_DATA___7 = 83,
	GP_3_2_DATA___7 = 84,
	GP_3_3_DATA___7 = 85,
	GP_3_4_DATA___7 = 86,
	GP_3_5_DATA___7 = 87,
	GP_3_6_DATA___7 = 88,
	GP_3_7_DATA___7 = 89,
	GP_3_8_DATA___7 = 90,
	GP_3_9_DATA___7 = 91,
	GP_3_10_DATA___7 = 92,
	GP_3_11_DATA___7 = 93,
	GP_3_12_DATA___7 = 94,
	GP_3_13_DATA___7 = 95,
	GP_3_14_DATA___7 = 96,
	GP_3_15_DATA___7 = 97,
	GP_3_16_DATA___2 = 98,
	GP_4_0_DATA___7 = 99,
	GP_4_1_DATA___7 = 100,
	GP_4_2_DATA___7 = 101,
	GP_4_3_DATA___7 = 102,
	GP_4_4_DATA___7 = 103,
	GP_4_5_DATA___7 = 104,
	GP_4_6_DATA___6 = 105,
	GP_4_7_DATA___6 = 106,
	GP_4_8_DATA___6 = 107,
	GP_4_9_DATA___6 = 108,
	GP_4_10_DATA___6 = 109,
	GP_4_11_DATA___5 = 110,
	GP_4_12_DATA___5 = 111,
	GP_4_13_DATA___5 = 112,
	GP_4_14_DATA___5 = 113,
	GP_4_15_DATA___5 = 114,
	GP_4_16_DATA___5 = 115,
	GP_4_17_DATA___5 = 116,
	GP_4_18_DATA = 117,
	GP_4_19_DATA = 118,
	GP_4_20_DATA = 119,
	GP_4_21_DATA = 120,
	GP_4_22_DATA = 121,
	GP_4_23_DATA = 122,
	GP_4_24_DATA = 123,
	GP_5_0_DATA___7 = 124,
	GP_5_1_DATA___7 = 125,
	GP_5_2_DATA___7 = 126,
	GP_5_3_DATA___7 = 127,
	GP_5_4_DATA___7 = 128,
	GP_5_5_DATA___7 = 129,
	GP_5_6_DATA___7 = 130,
	GP_5_7_DATA___7 = 131,
	GP_5_8_DATA___7 = 132,
	GP_5_9_DATA___7 = 133,
	GP_5_10_DATA___7 = 134,
	GP_5_11_DATA___7 = 135,
	GP_5_12_DATA___7 = 136,
	GP_5_13_DATA___7 = 137,
	GP_5_14_DATA___7 = 138,
	PINMUX_DATA_END___7 = 139,
	PINMUX_FUNCTION_BEGIN___7 = 140,
	GP_0_0_FN___7 = 141,
	GP_0_1_FN___7 = 142,
	GP_0_2_FN___7 = 143,
	GP_0_3_FN___7 = 144,
	GP_0_4_FN___7 = 145,
	GP_0_5_FN___7 = 146,
	GP_0_6_FN___7 = 147,
	GP_0_7_FN___7 = 148,
	GP_0_8_FN___7 = 149,
	GP_0_9_FN___7 = 150,
	GP_0_10_FN___7 = 151,
	GP_0_11_FN___7 = 152,
	GP_0_12_FN___7 = 153,
	GP_0_13_FN___7 = 154,
	GP_0_14_FN___7 = 155,
	GP_0_15_FN___7 = 156,
	GP_0_16_FN___3 = 157,
	GP_0_17_FN___3 = 158,
	GP_0_18_FN___2 = 159,
	GP_0_19_FN___2 = 160,
	GP_0_20_FN___2 = 161,
	GP_0_21_FN___2 = 162,
	GP_1_0_FN___7 = 163,
	GP_1_1_FN___7 = 164,
	GP_1_2_FN___7 = 165,
	GP_1_3_FN___7 = 166,
	GP_1_4_FN___7 = 167,
	GP_1_5_FN___7 = 168,
	GP_1_6_FN___7 = 169,
	GP_1_7_FN___7 = 170,
	GP_1_8_FN___7 = 171,
	GP_1_9_FN___7 = 172,
	GP_1_10_FN___7 = 173,
	GP_1_11_FN___7 = 174,
	GP_1_12_FN___7 = 175,
	GP_1_13_FN___7 = 176,
	GP_1_14_FN___7 = 177,
	GP_1_15_FN___7 = 178,
	GP_1_16_FN___7 = 179,
	GP_1_17_FN___7 = 180,
	GP_1_18_FN___7 = 181,
	GP_1_19_FN___7 = 182,
	GP_1_20_FN___7 = 183,
	GP_1_21_FN___7 = 184,
	GP_1_22_FN___7 = 185,
	GP_1_23_FN___6 = 186,
	GP_1_24_FN___6 = 187,
	GP_1_25_FN___6 = 188,
	GP_1_26_FN___6 = 189,
	GP_1_27_FN___6 = 190,
	GP_2_0_FN___7 = 191,
	GP_2_1_FN___7 = 192,
	GP_2_2_FN___7 = 193,
	GP_2_3_FN___7 = 194,
	GP_2_4_FN___7 = 195,
	GP_2_5_FN___7 = 196,
	GP_2_6_FN___7 = 197,
	GP_2_7_FN___7 = 198,
	GP_2_8_FN___7 = 199,
	GP_2_9_FN___7 = 200,
	GP_2_10_FN___7 = 201,
	GP_2_11_FN___7 = 202,
	GP_2_12_FN___7 = 203,
	GP_2_13_FN___7 = 204,
	GP_2_14_FN___7 = 205,
	GP_2_15_FN___3 = 206,
	GP_2_16_FN___3 = 207,
	GP_2_17_FN___2 = 208,
	GP_2_18_FN___2 = 209,
	GP_2_19_FN___2 = 210,
	GP_2_20_FN___2 = 211,
	GP_2_21_FN___2 = 212,
	GP_2_22_FN___2 = 213,
	GP_2_23_FN___2 = 214,
	GP_2_24_FN___2 = 215,
	GP_2_25_FN___2 = 216,
	GP_2_26_FN = 217,
	GP_2_27_FN = 218,
	GP_2_28_FN = 219,
	GP_2_29_FN = 220,
	GP_3_0_FN___7 = 221,
	GP_3_1_FN___7 = 222,
	GP_3_2_FN___7 = 223,
	GP_3_3_FN___7 = 224,
	GP_3_4_FN___7 = 225,
	GP_3_5_FN___7 = 226,
	GP_3_6_FN___7 = 227,
	GP_3_7_FN___7 = 228,
	GP_3_8_FN___7 = 229,
	GP_3_9_FN___7 = 230,
	GP_3_10_FN___7 = 231,
	GP_3_11_FN___7 = 232,
	GP_3_12_FN___7 = 233,
	GP_3_13_FN___7 = 234,
	GP_3_14_FN___7 = 235,
	GP_3_15_FN___7 = 236,
	GP_3_16_FN___2 = 237,
	GP_4_0_FN___7 = 238,
	GP_4_1_FN___7 = 239,
	GP_4_2_FN___7 = 240,
	GP_4_3_FN___7 = 241,
	GP_4_4_FN___7 = 242,
	GP_4_5_FN___7 = 243,
	GP_4_6_FN___6 = 244,
	GP_4_7_FN___6 = 245,
	GP_4_8_FN___6 = 246,
	GP_4_9_FN___6 = 247,
	GP_4_10_FN___6 = 248,
	GP_4_11_FN___5 = 249,
	GP_4_12_FN___5 = 250,
	GP_4_13_FN___5 = 251,
	GP_4_14_FN___5 = 252,
	GP_4_15_FN___5 = 253,
	GP_4_16_FN___5 = 254,
	GP_4_17_FN___5 = 255,
	GP_4_18_FN = 256,
	GP_4_19_FN = 257,
	GP_4_20_FN = 258,
	GP_4_21_FN = 259,
	GP_4_22_FN = 260,
	GP_4_23_FN = 261,
	GP_4_24_FN = 262,
	GP_5_0_FN___7 = 263,
	GP_5_1_FN___7 = 264,
	GP_5_2_FN___7 = 265,
	GP_5_3_FN___7 = 266,
	GP_5_4_FN___7 = 267,
	GP_5_5_FN___7 = 268,
	GP_5_6_FN___7 = 269,
	GP_5_7_FN___7 = 270,
	GP_5_8_FN___7 = 271,
	GP_5_9_FN___7 = 272,
	GP_5_10_FN___7 = 273,
	GP_5_11_FN___7 = 274,
	GP_5_12_FN___7 = 275,
	GP_5_13_FN___7 = 276,
	GP_5_14_FN___7 = 277,
	FN_GETHER_LINK_A = 278,
	FN_GETHER_PHY_INT_A = 279,
	FN_GETHER_MAGIC = 280,
	FN_GETHER_MDC_A = 281,
	FN_GETHER_MDIO_A = 282,
	FN_GETHER_TXCREFCLK_MEGA = 283,
	FN_AVB_LINK___6 = 284,
	FN_GETHER_TXCREFCLK = 285,
	FN_AVB_PHY_INT___6 = 286,
	FN_GETHER_TD3 = 287,
	FN_AVB_MAGIC___6 = 288,
	FN_GETHER_TD2 = 289,
	FN_AVB_MDC___6 = 290,
	FN_GETHER_TD1 = 291,
	FN_AVB_MDIO___2 = 292,
	FN_GETHER_TD0 = 293,
	FN_RPC_INT_N___3 = 294,
	FN_AVB_TXCREFCLK___2 = 295,
	FN_GETHER_TXC = 296,
	FN_RPC_WP_N___2 = 297,
	FN_AVB_TD3 = 298,
	FN_GETHER_TX_CTL = 299,
	FN_RPC_RESET_N___3 = 300,
	FN_AVB_TD2 = 301,
	FN_GETHER_RD3 = 302,
	FN_QSPI1_SSL___3 = 303,
	FN_AVB_TD1 = 304,
	FN_GETHER_RD2 = 305,
	FN_QSPI1_IO3___3 = 306,
	FN_AVB_TD0 = 307,
	FN_GETHER_RD1 = 308,
	FN_QSPI1_IO2___3 = 309,
	FN_AVB_TXC = 310,
	FN_GETHER_RD0 = 311,
	FN_QSPI1_MISO_IO1___3 = 312,
	FN_AVB_TX_CTL = 313,
	FN_GETHER_RXC = 314,
	FN_QSPI1_MOSI_IO0___3 = 315,
	FN_AVB_RD3___2 = 316,
	FN_GETHER_RX_CTL = 317,
	FN_QSPI1_SPCLK___3 = 318,
	FN_AVB_RD2___2 = 319,
	FN_QSPI0_SSL___3 = 320,
	FN_AVB_RD1___2 = 321,
	FN_QSPI0_IO3___3 = 322,
	FN_AVB_RD0___2 = 323,
	FN_QSPI0_IO2___3 = 324,
	FN_AVB_RXC___2 = 325,
	FN_QSPI0_MISO_IO1___3 = 326,
	FN_AVB_RX_CTL___2 = 327,
	FN_QSPI0_MOSI_IO0___3 = 328,
	FN_QSPI0_SPCLK___3 = 329,
	FN_IP0_3_0___7 = 330,
	FN_DU_DR2___7 = 331,
	FN_SCK4___2 = 332,
	FN_GETHER_RMII_CRS_DV = 333,
	FN_A0___7 = 334,
	FN_IP1_3_0___7 = 335,
	FN_DU_DG4___7 = 336,
	FN_SCL5___2 = 337,
	FN_A8___7 = 338,
	FN_IP2_3_0___7 = 339,
	FN_DU_DB6___7 = 340,
	FN_MSIOF3_RXD___2 = 341,
	FN_A16___7 = 342,
	FN_IP3_3_0___7 = 343,
	FN_VI0_CLKENB___2 = 344,
	FN_MSIOF2_RXD___2 = 345,
	FN_RX3___2 = 346,
	FN_RD_WR_N___7 = 347,
	FN_HCTS3_N___6 = 348,
	FN_IP0_7_4___7 = 349,
	FN_DU_DR3___7 = 350,
	FN_RX4___2 = 351,
	FN_GETHER_RMII_RX_ER = 352,
	FN_A1___7 = 353,
	FN_IP1_7_4___7 = 354,
	FN_DU_DG5___7 = 355,
	FN_SDA5___2 = 356,
	FN_GETHER_MDC_B = 357,
	FN_A9___7 = 358,
	FN_IP2_7_4___7 = 359,
	FN_DU_DB7___7 = 360,
	FN_MSIOF3_TXD___2 = 361,
	FN_A17___7 = 362,
	FN_IP3_7_4___7 = 363,
	FN_VI0_HSYNC_N___2 = 364,
	FN_MSIOF2_TXD___2 = 365,
	FN_TX3___2 = 366,
	FN_HRTS3_N___6 = 367,
	FN_IP0_11_8___7 = 368,
	FN_DU_DR4___7 = 369,
	FN_TX4___2 = 370,
	FN_GETHER_RMII_RXD0 = 371,
	FN_A2___7 = 372,
	FN_IP1_11_8___7 = 373,
	FN_DU_DG6___7 = 374,
	FN_SCIF_CLK_A___7 = 375,
	FN_GETHER_MDIO_B = 376,
	FN_A10___7 = 377,
	FN_IP2_11_8___7 = 378,
	FN_DU_DOTCLKOUT___2 = 379,
	FN_MSIOF3_SS1___2 = 380,
	FN_GETHER_LINK_B = 381,
	FN_A18___7 = 382,
	FN_IP3_11_8___7 = 383,
	FN_VI0_VSYNC_N___2 = 384,
	FN_MSIOF2_SYNC___2 = 385,
	FN_CTS3_N___6 = 386,
	FN_HTX3___2 = 387,
	FN_IP0_15_12___7 = 388,
	FN_DU_DR5___7 = 389,
	FN_CTS4_N___2 = 390,
	FN_GETHER_RMII_RXD1 = 391,
	FN_A3___7 = 392,
	FN_IP1_15_12___7 = 393,
	FN_DU_DG7___7 = 394,
	FN_HRX0_A___2 = 395,
	FN_A11___7 = 396,
	FN_IP2_15_12___7 = 397,
	FN_DU_EXHSYNC_DU_HSYNC___6 = 398,
	FN_MSIOF3_SS2___2 = 399,
	FN_GETHER_PHY_INT_B = 400,
	FN_A19___7 = 401,
	FN_FXR_TXENA_N___2 = 402,
	FN_IP3_15_12___7 = 403,
	FN_VI0_DATA0___2 = 404,
	FN_MSIOF2_SS1___2 = 405,
	FN_RTS3_N___6 = 406,
	FN_HRX3___2 = 407,
	FN_IP0_19_16___7 = 408,
	FN_DU_DR6___7 = 409,
	FN_RTS4_N___2 = 410,
	FN_GETHER_RMII_TXD_EN = 411,
	FN_A4___7 = 412,
	FN_IP1_19_16___7 = 413,
	FN_DU_DB2___7 = 414,
	FN_HSCK0_A___2 = 415,
	FN_A12___7 = 416,
	FN_IRQ1___7 = 417,
	FN_IP2_19_16___7 = 418,
	FN_DU_EXVSYNC_DU_VSYNC___6 = 419,
	FN_MSIOF3_SCK___2 = 420,
	FN_FXR_TXENB_N___2 = 421,
	FN_IP3_19_16___7 = 422,
	FN_VI0_DATA1___2 = 423,
	FN_MSIOF2_SS2___2 = 424,
	FN_SCK1___7 = 425,
	FN_SPEEDIN_A___7 = 426,
	FN_IP0_23_20___7 = 427,
	FN_DU_DR7___7 = 428,
	FN_GETHER_RMII_TXD0 = 429,
	FN_A5___7 = 430,
	FN_IP1_23_20___7 = 431,
	FN_DU_DB3___7 = 432,
	FN_HRTS0_N_A___2 = 433,
	FN_A13___7 = 434,
	FN_IRQ2___7 = 435,
	FN_IP2_23_20___7 = 436,
	FN_DU_EXODDF_DU_ODDF_DISP_CDE___6 = 437,
	FN_MSIOF3_SYNC___2 = 438,
	FN_IP3_23_20___7 = 439,
	FN_VI0_DATA2___2 = 440,
	FN_AVB_AVTP_PPS___6 = 441,
	FN_IP0_27_24___7 = 442,
	FN_DU_DG2___7 = 443,
	FN_GETHER_RMII_TXD1 = 444,
	FN_A6___7 = 445,
	FN_IP1_27_24___7 = 446,
	FN_DU_DB4___7 = 447,
	FN_HCTS0_N_A___2 = 448,
	FN_A14___7 = 449,
	FN_IRQ3___7 = 450,
	FN_IP2_27_24___7 = 451,
	FN_IRQ0___7 = 452,
	FN_IP3_27_24___7 = 453,
	FN_VI0_DATA3___2 = 454,
	FN_HSCK1___2 = 455,
	FN_IP0_31_28___7 = 456,
	FN_DU_DG3___7 = 457,
	FN_CPG_CPCKOUT = 458,
	FN_GETHER_RMII_REFCLK = 459,
	FN_A7___7 = 460,
	FN_PWMFSW0___2 = 461,
	FN_IP1_31_28___7 = 462,
	FN_DU_DB5___7 = 463,
	FN_HTX0_A___2 = 464,
	FN_PWM0_A___3 = 465,
	FN_A15___7 = 466,
	FN_IP2_31_28___7 = 467,
	FN_VI0_CLK___2 = 468,
	FN_MSIOF2_SCK___2 = 469,
	FN_SCK3___6 = 470,
	FN_HSCK3___6 = 471,
	FN_IP3_31_28___7 = 472,
	FN_VI0_DATA4___2 = 473,
	FN_HRTS1_N___2 = 474,
	FN_RX1_A___6 = 475,
	FN_IP4_3_0___7 = 476,
	FN_VI0_DATA5___2 = 477,
	FN_HCTS1_N___2 = 478,
	FN_TX1_A___6 = 479,
	FN_IP5_3_0___7 = 480,
	FN_VI1_CLK___2 = 481,
	FN_MSIOF1_RXD___3 = 482,
	FN_CS0_N___7 = 483,
	FN_IP6_3_0___7 = 484,
	FN_VI1_DATA4___2 = 485,
	FN_CANFD_CLK_B___2 = 486,
	FN_D7___7 = 487,
	FN_MMC_D0___2 = 488,
	FN_IP7_3_0___7 = 489,
	FN_VI1_FIELD___2 = 490,
	FN_SDA4___3 = 491,
	FN_D15___7 = 492,
	FN_MMC_D7___2 = 493,
	FN_IP4_7_4___7 = 494,
	FN_VI0_DATA6___2 = 495,
	FN_HTX1___2 = 496,
	FN_CTS1_N___7 = 497,
	FN_IP5_7_4___7 = 498,
	FN_VI1_CLKENB___2 = 499,
	FN_MSIOF1_TXD___3 = 500,
	FN_D0___7 = 501,
	FN_IP6_7_4___7 = 502,
	FN_VI1_DATA5___2 = 503,
	FN_D8___7 = 504,
	FN_MMC_D1___2 = 505,
	FN_IP7_7_4___7 = 506,
	FN_SCL0___2 = 507,
	FN_CLKOUT___6 = 508,
	FN_IP4_11_8___7 = 509,
	FN_VI0_DATA7___2 = 510,
	FN_HRX1___2 = 511,
	FN_RTS1_N___7 = 512,
	FN_IP5_11_8___7 = 513,
	FN_VI1_HSYNC_N___2 = 514,
	FN_MSIOF1_SCK___3 = 515,
	FN_D1___7 = 516,
	FN_IP6_11_8___7 = 517,
	FN_VI1_DATA6___2 = 518,
	FN_D9___7 = 519,
	FN_MMC_D2___2 = 520,
	FN_IP7_11_8___7 = 521,
	FN_SDA0___2 = 522,
	FN_BS_N___7 = 523,
	FN_SCK0___6 = 524,
	FN_HSCK0_B___2 = 525,
	FN_IP4_15_12___7 = 526,
	FN_VI0_DATA8___2 = 527,
	FN_HSCK2___2 = 528,
	FN_IP5_15_12___7 = 529,
	FN_VI1_VSYNC_N___2 = 530,
	FN_MSIOF1_SYNC___3 = 531,
	FN_D2___7 = 532,
	FN_IP6_15_12___7 = 533,
	FN_VI1_DATA7___2 = 534,
	FN_D10___7 = 535,
	FN_MMC_D3___2 = 536,
	FN_IP7_15_12___4 = 537,
	FN_SCL1___2 = 538,
	FN_TPU0TO2___7 = 539,
	FN_RD_N___7 = 540,
	FN_CTS0_N___6 = 541,
	FN_HCTS0_N_B = 542,
	FN_IP4_19_16___7 = 543,
	FN_VI0_DATA9___2 = 544,
	FN_HCTS2_N___2 = 545,
	FN_PWM1_A___7 = 546,
	FN_IP5_19_16___7 = 547,
	FN_VI1_DATA0___2 = 548,
	FN_MSIOF1_SS1___3 = 549,
	FN_D3___7 = 550,
	FN_MMC_WP = 551,
	FN_IP6_19_16___7 = 552,
	FN_VI1_DATA8___2 = 553,
	FN_D11___7 = 554,
	FN_MMC_CLK___2 = 555,
	FN_IP7_19_16___7 = 556,
	FN_SDA1___2 = 557,
	FN_TPU0TO3___7 = 558,
	FN_WE0_N___7 = 559,
	FN_RTS0_N___6 = 560,
	FN_HRTS0_N_B = 561,
	FN_IP4_23_20___7 = 562,
	FN_VI0_DATA10___2 = 563,
	FN_HRTS2_N___2 = 564,
	FN_PWM2_A___7 = 565,
	FN_IP5_23_20___7 = 566,
	FN_VI1_DATA1___2 = 567,
	FN_MSIOF1_SS2___3 = 568,
	FN_D4___7 = 569,
	FN_MMC_CD = 570,
	FN_IP6_23_20___7 = 571,
	FN_VI1_DATA9___2 = 572,
	FN_TCLK1_A___7 = 573,
	FN_D12___7 = 574,
	FN_MMC_D4___2 = 575,
	FN_IP7_23_20___7 = 576,
	FN_SCL2___2 = 577,
	FN_WE1_N___7 = 578,
	FN_RX0___6 = 579,
	FN_HRX0_B___2 = 580,
	FN_IP4_27_24___7 = 581,
	FN_VI0_DATA11___2 = 582,
	FN_HTX2___2 = 583,
	FN_PWM3_A___7 = 584,
	FN_IP5_27_24___7 = 585,
	FN_VI1_DATA2___2 = 586,
	FN_CANFD0_TX_B___6 = 587,
	FN_D5___7 = 588,
	FN_MMC_DS = 589,
	FN_IP6_27_24___7 = 590,
	FN_VI1_DATA10___2 = 591,
	FN_TCLK2_A___7 = 592,
	FN_D13___7 = 593,
	FN_MMC_D5___2 = 594,
	FN_IP7_27_24___7 = 595,
	FN_SDA2___2 = 596,
	FN_EX_WAIT0___3 = 597,
	FN_TX0___6 = 598,
	FN_HTX0_B___2 = 599,
	FN_IP4_31_28___7 = 600,
	FN_VI0_FIELD___2 = 601,
	FN_HRX2___2 = 602,
	FN_PWM4_A___7 = 603,
	FN_CS1_N___5 = 604,
	FN_IP5_31_28___7 = 605,
	FN_VI1_DATA3___2 = 606,
	FN_CANFD0_RX_B___6 = 607,
	FN_D6___7 = 608,
	FN_MMC_CMD___2 = 609,
	FN_IP6_31_28___7 = 610,
	FN_VI1_DATA11___2 = 611,
	FN_SCL4___3 = 612,
	FN_D14___7 = 613,
	FN_MMC_D6___2 = 614,
	FN_IP7_31_28___7 = 615,
	FN_AVB_AVTP_MATCH___2 = 616,
	FN_TPU0TO0___7 = 617,
	FN_IP8_3_0___7 = 618,
	FN_AVB_AVTP_CAPTURE___2 = 619,
	FN_TPU0TO1___7 = 620,
	FN_IP9_3_0___6 = 621,
	FN_IRQ4___7 = 622,
	FN_VI0_DATA12 = 623,
	FN_IP10_3_0___6 = 624,
	FN_SCL3 = 625,
	FN_VI0_DATA20 = 626,
	FN_IP8_7_4___7 = 627,
	FN_CANFD0_TX_A___6 = 628,
	FN_FXR_TXDA___2 = 629,
	FN_PWM0_B___3 = 630,
	FN_DU_DISP___7 = 631,
	FN_IP9_7_4___6 = 632,
	FN_IRQ5___7 = 633,
	FN_VI0_DATA13 = 634,
	FN_IP10_7_4___6 = 635,
	FN_SDA3 = 636,
	FN_VI0_DATA21 = 637,
	FN_IP8_11_8___7 = 638,
	FN_CANFD0_RX_A___6 = 639,
	FN_RXDA_EXTFXR___2 = 640,
	FN_PWM1_B___7 = 641,
	FN_DU_CDE___7 = 642,
	FN_IP9_11_8___6 = 643,
	FN_MSIOF0_RXD___7 = 644,
	FN_DU_DR0___7 = 645,
	FN_VI0_DATA14 = 646,
	FN_IP10_11_8___6 = 647,
	FN_FSO_CFE_0_N___4 = 648,
	FN_VI0_DATA22 = 649,
	FN_IP8_15_12___7 = 650,
	FN_CANFD1_TX___7 = 651,
	FN_FXR_TXDB___2 = 652,
	FN_PWM2_B___7 = 653,
	FN_TCLK1_B___7 = 654,
	FN_TX1_B___6 = 655,
	FN_IP9_15_12___6 = 656,
	FN_MSIOF0_TXD___7 = 657,
	FN_DU_DR1___7 = 658,
	FN_VI0_DATA15 = 659,
	FN_IP10_15_12___6 = 660,
	FN_FSO_CFE_1_N___4 = 661,
	FN_VI0_DATA23 = 662,
	FN_IP8_19_16___7 = 663,
	FN_CANFD1_RX___7 = 664,
	FN_RXDB_EXTFXR___2 = 665,
	FN_PWM3_B___7 = 666,
	FN_TCLK2_B___7 = 667,
	FN_RX1_B___6 = 668,
	FN_IP9_19_16___6 = 669,
	FN_MSIOF0_SCK___7 = 670,
	FN_DU_DG0___7 = 671,
	FN_VI0_DATA16 = 672,
	FN_IP10_19_16___6 = 673,
	FN_FSO_TOE_N___4 = 674,
	FN_IP8_23_20___7 = 675,
	FN_CANFD_CLK_A___2 = 676,
	FN_CLK_EXTFXR___2 = 677,
	FN_PWM4_B___7 = 678,
	FN_SPEEDIN_B___7 = 679,
	FN_SCIF_CLK_B___7 = 680,
	FN_IP9_23_20___6 = 681,
	FN_MSIOF0_SYNC___7 = 682,
	FN_DU_DG1___7 = 683,
	FN_VI0_DATA17 = 684,
	FN_IP10_23_20___6 = 685,
	FN_IP8_27_24___7 = 686,
	FN_DIGRF_CLKIN___2 = 687,
	FN_DIGRF_CLKEN_IN___2 = 688,
	FN_IP9_27_24___6 = 689,
	FN_MSIOF0_SS1___7 = 690,
	FN_DU_DB0___7 = 691,
	FN_TCLK3 = 692,
	FN_VI0_DATA18 = 693,
	FN_IP10_27_24___6 = 694,
	FN_IP8_31_28___7 = 695,
	FN_DIGRF_CLKOUT___2 = 696,
	FN_DIGRF_CLKEN_OUT___2 = 697,
	FN_IP9_31_28___6 = 698,
	FN_MSIOF0_SS2___7 = 699,
	FN_DU_DB1___7 = 700,
	FN_TCLK4 = 701,
	FN_VI0_DATA19 = 702,
	FN_IP10_31_28___6 = 703,
	FN_SEL_CANFD0_0___6 = 704,
	FN_SEL_CANFD0_1___6 = 705,
	FN_SEL_GETHER_0 = 706,
	FN_SEL_GETHER_1 = 707,
	FN_SEL_HSCIF0_0___3 = 708,
	FN_SEL_HSCIF0_1___3 = 709,
	FN_SEL_PWM0_0___3 = 710,
	FN_SEL_PWM0_1___3 = 711,
	FN_SEL_PWM1_0___7 = 712,
	FN_SEL_PWM1_1___7 = 713,
	FN_SEL_PWM2_0___7 = 714,
	FN_SEL_PWM2_1___7 = 715,
	FN_SEL_PWM3_0___7 = 716,
	FN_SEL_PWM3_1___7 = 717,
	FN_SEL_PWM4_0___7 = 718,
	FN_SEL_PWM4_1___7 = 719,
	FN_SEL_RSP_0___2 = 720,
	FN_SEL_RSP_1___2 = 721,
	FN_SEL_SCIF1_0___6 = 722,
	FN_SEL_SCIF1_1___6 = 723,
	FN_SEL_TMU_0___2 = 724,
	FN_SEL_TMU_1___2 = 725,
	PINMUX_FUNCTION_END___7 = 726,
	PINMUX_MARK_BEGIN___7 = 727,
	GETHER_LINK_A_MARK = 728,
	GETHER_PHY_INT_A_MARK = 729,
	GETHER_MAGIC_MARK = 730,
	GETHER_MDC_A_MARK = 731,
	GETHER_MDIO_A_MARK = 732,
	GETHER_TXCREFCLK_MEGA_MARK = 733,
	AVB_LINK_MARK___6 = 734,
	GETHER_TXCREFCLK_MARK = 735,
	AVB_PHY_INT_MARK___6 = 736,
	GETHER_TD3_MARK = 737,
	AVB_MAGIC_MARK___6 = 738,
	GETHER_TD2_MARK = 739,
	AVB_MDC_MARK___6 = 740,
	GETHER_TD1_MARK = 741,
	AVB_MDIO_MARK___6 = 742,
	GETHER_TD0_MARK = 743,
	RPC_INT_N_MARK___3 = 744,
	AVB_TXCREFCLK_MARK___6 = 745,
	GETHER_TXC_MARK = 746,
	RPC_WP_N_MARK___2 = 747,
	AVB_TD3_MARK___6 = 748,
	GETHER_TX_CTL_MARK = 749,
	RPC_RESET_N_MARK___3 = 750,
	AVB_TD2_MARK___6 = 751,
	GETHER_RD3_MARK = 752,
	QSPI1_SSL_MARK___7 = 753,
	AVB_TD1_MARK___6 = 754,
	GETHER_RD2_MARK = 755,
	QSPI1_IO3_MARK___7 = 756,
	AVB_TD0_MARK___6 = 757,
	GETHER_RD1_MARK = 758,
	QSPI1_IO2_MARK___7 = 759,
	AVB_TXC_MARK___6 = 760,
	GETHER_RD0_MARK = 761,
	QSPI1_MISO_IO1_MARK___7 = 762,
	AVB_TX_CTL_MARK___6 = 763,
	GETHER_RXC_MARK = 764,
	QSPI1_MOSI_IO0_MARK___7 = 765,
	AVB_RD3_MARK___6 = 766,
	GETHER_RX_CTL_MARK = 767,
	QSPI1_SPCLK_MARK___7 = 768,
	AVB_RD2_MARK___6 = 769,
	QSPI0_SSL_MARK___7 = 770,
	AVB_RD1_MARK___6 = 771,
	QSPI0_IO3_MARK___7 = 772,
	AVB_RD0_MARK___6 = 773,
	QSPI0_IO2_MARK___7 = 774,
	AVB_RXC_MARK___6 = 775,
	QSPI0_MISO_IO1_MARK___7 = 776,
	AVB_RX_CTL_MARK___6 = 777,
	QSPI0_MOSI_IO0_MARK___7 = 778,
	QSPI0_SPCLK_MARK___7 = 779,
	IP0_3_0_MARK___7 = 780,
	DU_DR2_MARK___7 = 781,
	SCK4_MARK___2 = 782,
	GETHER_RMII_CRS_DV_MARK = 783,
	A0_MARK___7 = 784,
	IP1_3_0_MARK___7 = 785,
	DU_DG4_MARK___7 = 786,
	SCL5_MARK___6 = 787,
	A8_MARK___7 = 788,
	IP2_3_0_MARK___7 = 789,
	DU_DB6_MARK___7 = 790,
	MSIOF3_RXD_MARK___2 = 791,
	A16_MARK___7 = 792,
	IP3_3_0_MARK___7 = 793,
	VI0_CLKENB_MARK___2 = 794,
	MSIOF2_RXD_MARK___2 = 795,
	RX3_MARK___2 = 796,
	RD_WR_N_MARK___7 = 797,
	HCTS3_N_MARK___6 = 798,
	IP0_7_4_MARK___7 = 799,
	DU_DR3_MARK___7 = 800,
	RX4_MARK___2 = 801,
	GETHER_RMII_RX_ER_MARK = 802,
	A1_MARK___7 = 803,
	IP1_7_4_MARK___7 = 804,
	DU_DG5_MARK___7 = 805,
	SDA5_MARK___6 = 806,
	GETHER_MDC_B_MARK = 807,
	A9_MARK___7 = 808,
	IP2_7_4_MARK___7 = 809,
	DU_DB7_MARK___7 = 810,
	MSIOF3_TXD_MARK___2 = 811,
	A17_MARK___7 = 812,
	IP3_7_4_MARK___7 = 813,
	VI0_HSYNC_N_MARK___2 = 814,
	MSIOF2_TXD_MARK___2 = 815,
	TX3_MARK___2 = 816,
	HRTS3_N_MARK___6 = 817,
	IP0_11_8_MARK___7 = 818,
	DU_DR4_MARK___7 = 819,
	TX4_MARK___2 = 820,
	GETHER_RMII_RXD0_MARK = 821,
	A2_MARK___7 = 822,
	IP1_11_8_MARK___7 = 823,
	DU_DG6_MARK___7 = 824,
	SCIF_CLK_A_MARK___7 = 825,
	GETHER_MDIO_B_MARK = 826,
	A10_MARK___7 = 827,
	IP2_11_8_MARK___7 = 828,
	DU_DOTCLKOUT_MARK___2 = 829,
	MSIOF3_SS1_MARK___2 = 830,
	GETHER_LINK_B_MARK = 831,
	A18_MARK___7 = 832,
	IP3_11_8_MARK___7 = 833,
	VI0_VSYNC_N_MARK___2 = 834,
	MSIOF2_SYNC_MARK___2 = 835,
	CTS3_N_MARK___6 = 836,
	HTX3_MARK___2 = 837,
	IP0_15_12_MARK___7 = 838,
	DU_DR5_MARK___7 = 839,
	CTS4_N_MARK___2 = 840,
	GETHER_RMII_RXD1_MARK = 841,
	A3_MARK___7 = 842,
	IP1_15_12_MARK___7 = 843,
	DU_DG7_MARK___7 = 844,
	HRX0_A_MARK___2 = 845,
	A11_MARK___7 = 846,
	IP2_15_12_MARK___7 = 847,
	DU_EXHSYNC_DU_HSYNC_MARK___6 = 848,
	MSIOF3_SS2_MARK___2 = 849,
	GETHER_PHY_INT_B_MARK = 850,
	A19_MARK___7 = 851,
	FXR_TXENA_N_MARK___2 = 852,
	IP3_15_12_MARK___7 = 853,
	VI0_DATA0_MARK___2 = 854,
	MSIOF2_SS1_MARK___2 = 855,
	RTS3_N_MARK___6 = 856,
	HRX3_MARK___2 = 857,
	IP0_19_16_MARK___7 = 858,
	DU_DR6_MARK___7 = 859,
	RTS4_N_MARK___2 = 860,
	GETHER_RMII_TXD_EN_MARK = 861,
	A4_MARK___7 = 862,
	IP1_19_16_MARK___7 = 863,
	DU_DB2_MARK___7 = 864,
	HSCK0_A_MARK___2 = 865,
	A12_MARK___7 = 866,
	IRQ1_MARK___7 = 867,
	IP2_19_16_MARK___7 = 868,
	DU_EXVSYNC_DU_VSYNC_MARK___6 = 869,
	MSIOF3_SCK_MARK___2 = 870,
	FXR_TXENB_N_MARK___2 = 871,
	IP3_19_16_MARK___7 = 872,
	VI0_DATA1_MARK___2 = 873,
	MSIOF2_SS2_MARK___2 = 874,
	SCK1_MARK___7 = 875,
	SPEEDIN_A_MARK___7 = 876,
	IP0_23_20_MARK___7 = 877,
	DU_DR7_MARK___7 = 878,
	GETHER_RMII_TXD0_MARK = 879,
	A5_MARK___7 = 880,
	IP1_23_20_MARK___7 = 881,
	DU_DB3_MARK___7 = 882,
	HRTS0_N_A_MARK___2 = 883,
	A13_MARK___7 = 884,
	IRQ2_MARK___7 = 885,
	IP2_23_20_MARK___7 = 886,
	DU_EXODDF_DU_ODDF_DISP_CDE_MARK___6 = 887,
	MSIOF3_SYNC_MARK___2 = 888,
	IP3_23_20_MARK___7 = 889,
	VI0_DATA2_MARK___2 = 890,
	AVB_AVTP_PPS_MARK___6 = 891,
	IP0_27_24_MARK___7 = 892,
	DU_DG2_MARK___7 = 893,
	GETHER_RMII_TXD1_MARK = 894,
	A6_MARK___7 = 895,
	IP1_27_24_MARK___7 = 896,
	DU_DB4_MARK___7 = 897,
	HCTS0_N_A_MARK___2 = 898,
	A14_MARK___7 = 899,
	IRQ3_MARK___7 = 900,
	IP2_27_24_MARK___7 = 901,
	IRQ0_MARK___7 = 902,
	IP3_27_24_MARK___7 = 903,
	VI0_DATA3_MARK___2 = 904,
	HSCK1_MARK___2 = 905,
	IP0_31_28_MARK___7 = 906,
	DU_DG3_MARK___7 = 907,
	CPG_CPCKOUT_MARK = 908,
	GETHER_RMII_REFCLK_MARK = 909,
	A7_MARK___7 = 910,
	PWMFSW0_MARK___2 = 911,
	IP1_31_28_MARK___7 = 912,
	DU_DB5_MARK___7 = 913,
	HTX0_A_MARK___2 = 914,
	PWM0_A_MARK___3 = 915,
	A15_MARK___7 = 916,
	IP2_31_28_MARK___7 = 917,
	VI0_CLK_MARK___2 = 918,
	MSIOF2_SCK_MARK___2 = 919,
	SCK3_MARK___6 = 920,
	HSCK3_MARK___6 = 921,
	IP3_31_28_MARK___7 = 922,
	VI0_DATA4_MARK___2 = 923,
	HRTS1_N_MARK___2 = 924,
	RX1_A_MARK___6 = 925,
	IP4_3_0_MARK___7 = 926,
	VI0_DATA5_MARK___2 = 927,
	HCTS1_N_MARK___2 = 928,
	TX1_A_MARK___6 = 929,
	IP5_3_0_MARK___7 = 930,
	VI1_CLK_MARK___2 = 931,
	MSIOF1_RXD_MARK___3 = 932,
	CS0_N_MARK___7 = 933,
	IP6_3_0_MARK___7 = 934,
	VI1_DATA4_MARK___2 = 935,
	CANFD_CLK_B_MARK___2 = 936,
	D7_MARK___7 = 937,
	MMC_D0_MARK___2 = 938,
	IP7_3_0_MARK___7 = 939,
	VI1_FIELD_MARK___2 = 940,
	SDA4_MARK___3 = 941,
	D15_MARK___7 = 942,
	MMC_D7_MARK___2 = 943,
	IP4_7_4_MARK___7 = 944,
	VI0_DATA6_MARK___2 = 945,
	HTX1_MARK___2 = 946,
	CTS1_N_MARK___7 = 947,
	IP5_7_4_MARK___7 = 948,
	VI1_CLKENB_MARK___2 = 949,
	MSIOF1_TXD_MARK___3 = 950,
	D0_MARK___7 = 951,
	IP6_7_4_MARK___7 = 952,
	VI1_DATA5_MARK___2 = 953,
	D8_MARK___7 = 954,
	MMC_D1_MARK___2 = 955,
	IP7_7_4_MARK___7 = 956,
	SCL0_MARK___6 = 957,
	CLKOUT_MARK___7 = 958,
	IP4_11_8_MARK___7 = 959,
	VI0_DATA7_MARK___2 = 960,
	HRX1_MARK___2 = 961,
	RTS1_N_MARK___7 = 962,
	IP5_11_8_MARK___7 = 963,
	VI1_HSYNC_N_MARK___2 = 964,
	MSIOF1_SCK_MARK___3 = 965,
	D1_MARK___7 = 966,
	IP6_11_8_MARK___7 = 967,
	VI1_DATA6_MARK___2 = 968,
	D9_MARK___7 = 969,
	MMC_D2_MARK___2 = 970,
	IP7_11_8_MARK___7 = 971,
	SDA0_MARK___6 = 972,
	BS_N_MARK___7 = 973,
	SCK0_MARK___6 = 974,
	HSCK0_B_MARK___2 = 975,
	IP4_15_12_MARK___7 = 976,
	VI0_DATA8_MARK___2 = 977,
	HSCK2_MARK___2 = 978,
	IP5_15_12_MARK___7 = 979,
	VI1_VSYNC_N_MARK___2 = 980,
	MSIOF1_SYNC_MARK___3 = 981,
	D2_MARK___7 = 982,
	IP6_15_12_MARK___7 = 983,
	VI1_DATA7_MARK___2 = 984,
	D10_MARK___7 = 985,
	MMC_D3_MARK___2 = 986,
	IP7_15_12_MARK___4 = 987,
	SCL1_MARK___2 = 988,
	TPU0TO2_MARK___7 = 989,
	RD_N_MARK___7 = 990,
	CTS0_N_MARK___6 = 991,
	HCTS0_N_B_MARK = 992,
	IP4_19_16_MARK___7 = 993,
	VI0_DATA9_MARK___2 = 994,
	HCTS2_N_MARK___2 = 995,
	PWM1_A_MARK___7 = 996,
	IP5_19_16_MARK___7 = 997,
	VI1_DATA0_MARK___2 = 998,
	MSIOF1_SS1_MARK___3 = 999,
	D3_MARK___7 = 1000,
	MMC_WP_MARK = 1001,
	IP6_19_16_MARK___7 = 1002,
	VI1_DATA8_MARK___2 = 1003,
	D11_MARK___7 = 1004,
	MMC_CLK_MARK___2 = 1005,
	IP7_19_16_MARK___7 = 1006,
	SDA1_MARK___2 = 1007,
	TPU0TO3_MARK___7 = 1008,
	WE0_N_MARK___7 = 1009,
	RTS0_N_MARK___6 = 1010,
	HRTS0_N_B_MARK = 1011,
	IP4_23_20_MARK___7 = 1012,
	VI0_DATA10_MARK___2 = 1013,
	HRTS2_N_MARK___2 = 1014,
	PWM2_A_MARK___7 = 1015,
	IP5_23_20_MARK___7 = 1016,
	VI1_DATA1_MARK___2 = 1017,
	MSIOF1_SS2_MARK___3 = 1018,
	D4_MARK___7 = 1019,
	MMC_CD_MARK = 1020,
	IP6_23_20_MARK___7 = 1021,
	VI1_DATA9_MARK___2 = 1022,
	TCLK1_A_MARK___7 = 1023,
	D12_MARK___7 = 1024,
	MMC_D4_MARK___2 = 1025,
	IP7_23_20_MARK___7 = 1026,
	SCL2_MARK___2 = 1027,
	WE1_N_MARK___7 = 1028,
	RX0_MARK___6 = 1029,
	HRX0_B_MARK___2 = 1030,
	IP4_27_24_MARK___7 = 1031,
	VI0_DATA11_MARK___2 = 1032,
	HTX2_MARK___2 = 1033,
	PWM3_A_MARK___7 = 1034,
	IP5_27_24_MARK___7 = 1035,
	VI1_DATA2_MARK___2 = 1036,
	CANFD0_TX_B_MARK___6 = 1037,
	D5_MARK___7 = 1038,
	MMC_DS_MARK = 1039,
	IP6_27_24_MARK___7 = 1040,
	VI1_DATA10_MARK___2 = 1041,
	TCLK2_A_MARK___7 = 1042,
	D13_MARK___7 = 1043,
	MMC_D5_MARK___2 = 1044,
	IP7_27_24_MARK___7 = 1045,
	SDA2_MARK___2 = 1046,
	EX_WAIT0_MARK___3 = 1047,
	TX0_MARK___6 = 1048,
	HTX0_B_MARK___2 = 1049,
	IP4_31_28_MARK___7 = 1050,
	VI0_FIELD_MARK___2 = 1051,
	HRX2_MARK___2 = 1052,
	PWM4_A_MARK___7 = 1053,
	CS1_N_MARK___5 = 1054,
	IP5_31_28_MARK___7 = 1055,
	VI1_DATA3_MARK___2 = 1056,
	CANFD0_RX_B_MARK___6 = 1057,
	D6_MARK___7 = 1058,
	MMC_CMD_MARK___2 = 1059,
	IP6_31_28_MARK___7 = 1060,
	VI1_DATA11_MARK___2 = 1061,
	SCL4_MARK___3 = 1062,
	D14_MARK___7 = 1063,
	MMC_D6_MARK___2 = 1064,
	IP7_31_28_MARK___7 = 1065,
	AVB_AVTP_MATCH_MARK___2 = 1066,
	TPU0TO0_MARK___7 = 1067,
	IP8_3_0_MARK___7 = 1068,
	AVB_AVTP_CAPTURE_MARK___2 = 1069,
	TPU0TO1_MARK___7 = 1070,
	IP9_3_0_MARK___6 = 1071,
	IRQ4_MARK___7 = 1072,
	VI0_DATA12_MARK = 1073,
	IP10_3_0_MARK___6 = 1074,
	SCL3_MARK___5 = 1075,
	VI0_DATA20_MARK = 1076,
	IP8_7_4_MARK___7 = 1077,
	CANFD0_TX_A_MARK___6 = 1078,
	FXR_TXDA_MARK___2 = 1079,
	PWM0_B_MARK___3 = 1080,
	DU_DISP_MARK___7 = 1081,
	IP9_7_4_MARK___6 = 1082,
	IRQ5_MARK___7 = 1083,
	VI0_DATA13_MARK = 1084,
	IP10_7_4_MARK___6 = 1085,
	SDA3_MARK___5 = 1086,
	VI0_DATA21_MARK = 1087,
	IP8_11_8_MARK___7 = 1088,
	CANFD0_RX_A_MARK___6 = 1089,
	RXDA_EXTFXR_MARK___2 = 1090,
	PWM1_B_MARK___7 = 1091,
	DU_CDE_MARK___7 = 1092,
	IP9_11_8_MARK___6 = 1093,
	MSIOF0_RXD_MARK___7 = 1094,
	DU_DR0_MARK___7 = 1095,
	VI0_DATA14_MARK = 1096,
	IP10_11_8_MARK___6 = 1097,
	FSO_CFE_0_N_MARK___4 = 1098,
	VI0_DATA22_MARK = 1099,
	IP8_15_12_MARK___7 = 1100,
	CANFD1_TX_MARK___7 = 1101,
	FXR_TXDB_MARK___2 = 1102,
	PWM2_B_MARK___7 = 1103,
	TCLK1_B_MARK___7 = 1104,
	TX1_B_MARK___6 = 1105,
	IP9_15_12_MARK___6 = 1106,
	MSIOF0_TXD_MARK___7 = 1107,
	DU_DR1_MARK___7 = 1108,
	VI0_DATA15_MARK = 1109,
	IP10_15_12_MARK___6 = 1110,
	FSO_CFE_1_N_MARK___4 = 1111,
	VI0_DATA23_MARK = 1112,
	IP8_19_16_MARK___7 = 1113,
	CANFD1_RX_MARK___7 = 1114,
	RXDB_EXTFXR_MARK___2 = 1115,
	PWM3_B_MARK___7 = 1116,
	TCLK2_B_MARK___7 = 1117,
	RX1_B_MARK___6 = 1118,
	IP9_19_16_MARK___6 = 1119,
	MSIOF0_SCK_MARK___7 = 1120,
	DU_DG0_MARK___7 = 1121,
	VI0_DATA16_MARK = 1122,
	IP10_19_16_MARK___6 = 1123,
	FSO_TOE_N_MARK___4 = 1124,
	IP8_23_20_MARK___7 = 1125,
	CANFD_CLK_A_MARK___2 = 1126,
	CLK_EXTFXR_MARK___2 = 1127,
	PWM4_B_MARK___7 = 1128,
	SPEEDIN_B_MARK___7 = 1129,
	SCIF_CLK_B_MARK___7 = 1130,
	IP9_23_20_MARK___6 = 1131,
	MSIOF0_SYNC_MARK___7 = 1132,
	DU_DG1_MARK___7 = 1133,
	VI0_DATA17_MARK = 1134,
	IP10_23_20_MARK___6 = 1135,
	IP8_27_24_MARK___7 = 1136,
	DIGRF_CLKIN_MARK___2 = 1137,
	DIGRF_CLKEN_IN_MARK___2 = 1138,
	IP9_27_24_MARK___6 = 1139,
	MSIOF0_SS1_MARK___7 = 1140,
	DU_DB0_MARK___7 = 1141,
	TCLK3_MARK = 1142,
	VI0_DATA18_MARK = 1143,
	IP10_27_24_MARK___6 = 1144,
	IP8_31_28_MARK___7 = 1145,
	DIGRF_CLKOUT_MARK___2 = 1146,
	DIGRF_CLKEN_OUT_MARK___2 = 1147,
	IP9_31_28_MARK___6 = 1148,
	MSIOF0_SS2_MARK___7 = 1149,
	DU_DB1_MARK___7 = 1150,
	TCLK4_MARK = 1151,
	VI0_DATA19_MARK = 1152,
	IP10_31_28_MARK___6 = 1153,
	SEL_CANFD0_0_MARK___6 = 1154,
	SEL_CANFD0_1_MARK___6 = 1155,
	SEL_GETHER_0_MARK = 1156,
	SEL_GETHER_1_MARK = 1157,
	SEL_HSCIF0_0_MARK___3 = 1158,
	SEL_HSCIF0_1_MARK___3 = 1159,
	SEL_PWM0_0_MARK___3 = 1160,
	SEL_PWM0_1_MARK___3 = 1161,
	SEL_PWM1_0_MARK___7 = 1162,
	SEL_PWM1_1_MARK___7 = 1163,
	SEL_PWM2_0_MARK___7 = 1164,
	SEL_PWM2_1_MARK___7 = 1165,
	SEL_PWM3_0_MARK___7 = 1166,
	SEL_PWM3_1_MARK___7 = 1167,
	SEL_PWM4_0_MARK___7 = 1168,
	SEL_PWM4_1_MARK___7 = 1169,
	SEL_RSP_0_MARK___2 = 1170,
	SEL_RSP_1_MARK___2 = 1171,
	SEL_SCIF1_0_MARK___6 = 1172,
	SEL_SCIF1_1_MARK___6 = 1173,
	SEL_TMU_0_MARK___2 = 1174,
	SEL_TMU_1_MARK___2 = 1175,
	PINMUX_MARK_END___7 = 1176,
};

enum ioctrl_regs___4 {
	POCCTRL0___3 = 0,
	POCCTRL1___2 = 1,
	POCCTRL2___2 = 2,
	POCCTRL3 = 3,
	TDSELCTRL___4 = 4,
};

enum {
	PINMUX_RESERVED___8 = 0,
	PINMUX_DATA_BEGIN___8 = 1,
	GP_0_0_DATA___8 = 2,
	GP_0_1_DATA___8 = 3,
	GP_0_2_DATA___8 = 4,
	GP_0_3_DATA___8 = 5,
	GP_0_4_DATA___8 = 6,
	GP_0_5_DATA___8 = 7,
	GP_0_6_DATA___8 = 8,
	GP_0_7_DATA___8 = 9,
	GP_0_8_DATA___8 = 10,
	GP_1_0_DATA___8 = 11,
	GP_1_1_DATA___8 = 12,
	GP_1_2_DATA___8 = 13,
	GP_1_3_DATA___8 = 14,
	GP_1_4_DATA___8 = 15,
	GP_1_5_DATA___8 = 16,
	GP_1_6_DATA___8 = 17,
	GP_1_7_DATA___8 = 18,
	GP_1_8_DATA___8 = 19,
	GP_1_9_DATA___8 = 20,
	GP_1_10_DATA___8 = 21,
	GP_1_11_DATA___8 = 22,
	GP_1_12_DATA___8 = 23,
	GP_1_13_DATA___8 = 24,
	GP_1_14_DATA___8 = 25,
	GP_1_15_DATA___8 = 26,
	GP_1_16_DATA___8 = 27,
	GP_1_17_DATA___8 = 28,
	GP_1_18_DATA___8 = 29,
	GP_1_19_DATA___8 = 30,
	GP_1_20_DATA___8 = 31,
	GP_1_21_DATA___8 = 32,
	GP_1_22_DATA___8 = 33,
	GP_1_23_DATA___7 = 34,
	GP_1_24_DATA___7 = 35,
	GP_1_25_DATA___7 = 36,
	GP_1_26_DATA___7 = 37,
	GP_1_27_DATA___7 = 38,
	GP_1_28_DATA___4 = 39,
	GP_1_29_DATA = 40,
	GP_1_30_DATA = 41,
	GP_1_31_DATA = 42,
	GP_2_0_DATA___8 = 43,
	GP_2_1_DATA___8 = 44,
	GP_2_2_DATA___8 = 45,
	GP_2_3_DATA___8 = 46,
	GP_2_4_DATA___8 = 47,
	GP_2_5_DATA___8 = 48,
	GP_2_6_DATA___8 = 49,
	GP_2_7_DATA___8 = 50,
	GP_2_8_DATA___8 = 51,
	GP_2_9_DATA___8 = 52,
	GP_2_10_DATA___8 = 53,
	GP_2_11_DATA___8 = 54,
	GP_2_12_DATA___8 = 55,
	GP_2_13_DATA___8 = 56,
	GP_2_14_DATA___8 = 57,
	GP_2_15_DATA___4 = 58,
	GP_2_16_DATA___4 = 59,
	GP_2_17_DATA___3 = 60,
	GP_2_18_DATA___3 = 61,
	GP_2_19_DATA___3 = 62,
	GP_2_20_DATA___3 = 63,
	GP_2_21_DATA___3 = 64,
	GP_2_22_DATA___3 = 65,
	GP_2_23_DATA___3 = 66,
	GP_2_24_DATA___3 = 67,
	GP_2_25_DATA___3 = 68,
	GP_2_26_DATA___2 = 69,
	GP_2_27_DATA___2 = 70,
	GP_2_28_DATA___2 = 71,
	GP_2_29_DATA___2 = 72,
	GP_2_30_DATA = 73,
	GP_2_31_DATA = 74,
	GP_3_0_DATA___8 = 75,
	GP_3_1_DATA___8 = 76,
	GP_3_2_DATA___8 = 77,
	GP_3_3_DATA___8 = 78,
	GP_3_4_DATA___8 = 79,
	GP_3_5_DATA___8 = 80,
	GP_3_6_DATA___8 = 81,
	GP_3_7_DATA___8 = 82,
	GP_3_8_DATA___8 = 83,
	GP_3_9_DATA___8 = 84,
	GP_4_0_DATA___8 = 85,
	GP_4_1_DATA___8 = 86,
	GP_4_2_DATA___8 = 87,
	GP_4_3_DATA___8 = 88,
	GP_4_4_DATA___8 = 89,
	GP_4_5_DATA___8 = 90,
	GP_4_6_DATA___7 = 91,
	GP_4_7_DATA___7 = 92,
	GP_4_8_DATA___7 = 93,
	GP_4_9_DATA___7 = 94,
	GP_4_10_DATA___7 = 95,
	GP_4_11_DATA___6 = 96,
	GP_4_12_DATA___6 = 97,
	GP_4_13_DATA___6 = 98,
	GP_4_14_DATA___6 = 99,
	GP_4_15_DATA___6 = 100,
	GP_4_16_DATA___6 = 101,
	GP_4_17_DATA___6 = 102,
	GP_4_18_DATA___2 = 103,
	GP_4_19_DATA___2 = 104,
	GP_4_20_DATA___2 = 105,
	GP_4_21_DATA___2 = 106,
	GP_4_22_DATA___2 = 107,
	GP_4_23_DATA___2 = 108,
	GP_4_24_DATA___2 = 109,
	GP_4_25_DATA = 110,
	GP_4_26_DATA = 111,
	GP_4_27_DATA = 112,
	GP_4_28_DATA = 113,
	GP_4_29_DATA = 114,
	GP_4_30_DATA = 115,
	GP_4_31_DATA = 116,
	GP_5_0_DATA___8 = 117,
	GP_5_1_DATA___8 = 118,
	GP_5_2_DATA___8 = 119,
	GP_5_3_DATA___8 = 120,
	GP_5_4_DATA___8 = 121,
	GP_5_5_DATA___8 = 122,
	GP_5_6_DATA___8 = 123,
	GP_5_7_DATA___8 = 124,
	GP_5_8_DATA___8 = 125,
	GP_5_9_DATA___8 = 126,
	GP_5_10_DATA___8 = 127,
	GP_5_11_DATA___8 = 128,
	GP_5_12_DATA___8 = 129,
	GP_5_13_DATA___8 = 130,
	GP_5_14_DATA___8 = 131,
	GP_5_15_DATA___6 = 132,
	GP_5_16_DATA___6 = 133,
	GP_5_17_DATA___6 = 134,
	GP_5_18_DATA___6 = 135,
	GP_5_19_DATA___6 = 136,
	GP_5_20_DATA___5 = 137,
	GP_6_0_DATA___6 = 138,
	GP_6_1_DATA___6 = 139,
	GP_6_2_DATA___6 = 140,
	GP_6_3_DATA___6 = 141,
	GP_6_4_DATA___6 = 142,
	GP_6_5_DATA___6 = 143,
	GP_6_6_DATA___6 = 144,
	GP_6_7_DATA___6 = 145,
	GP_6_8_DATA___6 = 146,
	GP_6_9_DATA___6 = 147,
	GP_6_10_DATA___6 = 148,
	GP_6_11_DATA___6 = 149,
	GP_6_12_DATA___6 = 150,
	GP_6_13_DATA___6 = 151,
	PINMUX_DATA_END___8 = 152,
	PINMUX_FUNCTION_BEGIN___8 = 153,
	GP_0_0_FN___8 = 154,
	GP_0_1_FN___8 = 155,
	GP_0_2_FN___8 = 156,
	GP_0_3_FN___8 = 157,
	GP_0_4_FN___8 = 158,
	GP_0_5_FN___8 = 159,
	GP_0_6_FN___8 = 160,
	GP_0_7_FN___8 = 161,
	GP_0_8_FN___8 = 162,
	GP_1_0_FN___8 = 163,
	GP_1_1_FN___8 = 164,
	GP_1_2_FN___8 = 165,
	GP_1_3_FN___8 = 166,
	GP_1_4_FN___8 = 167,
	GP_1_5_FN___8 = 168,
	GP_1_6_FN___8 = 169,
	GP_1_7_FN___8 = 170,
	GP_1_8_FN___8 = 171,
	GP_1_9_FN___8 = 172,
	GP_1_10_FN___8 = 173,
	GP_1_11_FN___8 = 174,
	GP_1_12_FN___8 = 175,
	GP_1_13_FN___8 = 176,
	GP_1_14_FN___8 = 177,
	GP_1_15_FN___8 = 178,
	GP_1_16_FN___8 = 179,
	GP_1_17_FN___8 = 180,
	GP_1_18_FN___8 = 181,
	GP_1_19_FN___8 = 182,
	GP_1_20_FN___8 = 183,
	GP_1_21_FN___8 = 184,
	GP_1_22_FN___8 = 185,
	GP_1_23_FN___7 = 186,
	GP_1_24_FN___7 = 187,
	GP_1_25_FN___7 = 188,
	GP_1_26_FN___7 = 189,
	GP_1_27_FN___7 = 190,
	GP_1_28_FN___4 = 191,
	GP_1_29_FN = 192,
	GP_1_30_FN = 193,
	GP_1_31_FN = 194,
	GP_2_0_FN___8 = 195,
	GP_2_1_FN___8 = 196,
	GP_2_2_FN___8 = 197,
	GP_2_3_FN___8 = 198,
	GP_2_4_FN___8 = 199,
	GP_2_5_FN___8 = 200,
	GP_2_6_FN___8 = 201,
	GP_2_7_FN___8 = 202,
	GP_2_8_FN___8 = 203,
	GP_2_9_FN___8 = 204,
	GP_2_10_FN___8 = 205,
	GP_2_11_FN___8 = 206,
	GP_2_12_FN___8 = 207,
	GP_2_13_FN___8 = 208,
	GP_2_14_FN___8 = 209,
	GP_2_15_FN___4 = 210,
	GP_2_16_FN___4 = 211,
	GP_2_17_FN___3 = 212,
	GP_2_18_FN___3 = 213,
	GP_2_19_FN___3 = 214,
	GP_2_20_FN___3 = 215,
	GP_2_21_FN___3 = 216,
	GP_2_22_FN___3 = 217,
	GP_2_23_FN___3 = 218,
	GP_2_24_FN___3 = 219,
	GP_2_25_FN___3 = 220,
	GP_2_26_FN___2 = 221,
	GP_2_27_FN___2 = 222,
	GP_2_28_FN___2 = 223,
	GP_2_29_FN___2 = 224,
	GP_2_30_FN = 225,
	GP_2_31_FN = 226,
	GP_3_0_FN___8 = 227,
	GP_3_1_FN___8 = 228,
	GP_3_2_FN___8 = 229,
	GP_3_3_FN___8 = 230,
	GP_3_4_FN___8 = 231,
	GP_3_5_FN___8 = 232,
	GP_3_6_FN___8 = 233,
	GP_3_7_FN___8 = 234,
	GP_3_8_FN___8 = 235,
	GP_3_9_FN___8 = 236,
	GP_4_0_FN___8 = 237,
	GP_4_1_FN___8 = 238,
	GP_4_2_FN___8 = 239,
	GP_4_3_FN___8 = 240,
	GP_4_4_FN___8 = 241,
	GP_4_5_FN___8 = 242,
	GP_4_6_FN___7 = 243,
	GP_4_7_FN___7 = 244,
	GP_4_8_FN___7 = 245,
	GP_4_9_FN___7 = 246,
	GP_4_10_FN___7 = 247,
	GP_4_11_FN___6 = 248,
	GP_4_12_FN___6 = 249,
	GP_4_13_FN___6 = 250,
	GP_4_14_FN___6 = 251,
	GP_4_15_FN___6 = 252,
	GP_4_16_FN___6 = 253,
	GP_4_17_FN___6 = 254,
	GP_4_18_FN___2 = 255,
	GP_4_19_FN___2 = 256,
	GP_4_20_FN___2 = 257,
	GP_4_21_FN___2 = 258,
	GP_4_22_FN___2 = 259,
	GP_4_23_FN___2 = 260,
	GP_4_24_FN___2 = 261,
	GP_4_25_FN = 262,
	GP_4_26_FN = 263,
	GP_4_27_FN = 264,
	GP_4_28_FN = 265,
	GP_4_29_FN = 266,
	GP_4_30_FN = 267,
	GP_4_31_FN = 268,
	GP_5_0_FN___8 = 269,
	GP_5_1_FN___8 = 270,
	GP_5_2_FN___8 = 271,
	GP_5_3_FN___8 = 272,
	GP_5_4_FN___8 = 273,
	GP_5_5_FN___8 = 274,
	GP_5_6_FN___8 = 275,
	GP_5_7_FN___8 = 276,
	GP_5_8_FN___8 = 277,
	GP_5_9_FN___8 = 278,
	GP_5_10_FN___8 = 279,
	GP_5_11_FN___8 = 280,
	GP_5_12_FN___8 = 281,
	GP_5_13_FN___8 = 282,
	GP_5_14_FN___8 = 283,
	GP_5_15_FN___6 = 284,
	GP_5_16_FN___6 = 285,
	GP_5_17_FN___6 = 286,
	GP_5_18_FN___6 = 287,
	GP_5_19_FN___6 = 288,
	GP_5_20_FN___5 = 289,
	GP_6_0_FN___6 = 290,
	GP_6_1_FN___6 = 291,
	GP_6_2_FN___6 = 292,
	GP_6_3_FN___6 = 293,
	GP_6_4_FN___6 = 294,
	GP_6_5_FN___6 = 295,
	GP_6_6_FN___6 = 296,
	GP_6_7_FN___6 = 297,
	GP_6_8_FN___6 = 298,
	GP_6_9_FN___6 = 299,
	GP_6_10_FN___6 = 300,
	GP_6_11_FN___6 = 301,
	GP_6_12_FN___6 = 302,
	GP_6_13_FN___6 = 303,
	FN_TX2 = 304,
	FN_RX2 = 305,
	FN_AVB0_LINK___2 = 306,
	FN_AVB0_PHY_INT___2 = 307,
	FN_AVB0_MAGIC___2 = 308,
	FN_AVB0_MDC___2 = 309,
	FN_AVB0_MDIO___2 = 310,
	FN_MSIOF0_RXD___8 = 311,
	FN_AVB0_TXCREFCLK___2 = 312,
	FN_MSIOF0_TXD___8 = 313,
	FN_AVB0_TD3___2 = 314,
	FN_MSIOF0_SYNC___8 = 315,
	FN_AVB0_TD2___2 = 316,
	FN_RPC_INT_N___4 = 317,
	FN_MSIOF0_SCK___8 = 318,
	FN_AVB0_TD1___2 = 319,
	FN_RPC_RESET_N___4 = 320,
	FN_AVB0_TD0___2 = 321,
	FN_QSPI1_SSL___4 = 322,
	FN_AVB0_TXC___2 = 323,
	FN_QSPI1_IO3___4 = 324,
	FN_SDA0___3 = 325,
	FN_AVB0_TX_CTL___2 = 326,
	FN_QSPI1_IO2___4 = 327,
	FN_SCL0___3 = 328,
	FN_AVB0_RD3___2 = 329,
	FN_QSPI1_MISO_IO1___4 = 330,
	FN_AVB0_RD2___2 = 331,
	FN_QSPI1_MOSI_IO0___4 = 332,
	FN_AVB0_RD1___2 = 333,
	FN_QSPI1_SPCLK___4 = 334,
	FN_VI4_DATA4 = 335,
	FN_AVB0_RD0___2 = 336,
	FN_QSPI0_SSL___4 = 337,
	FN_AVB0_RXC___2 = 338,
	FN_QSPI0_IO3___4 = 339,
	FN_AVB0_RX_CTL___2 = 340,
	FN_QSPI0_IO2___4 = 341,
	FN_QSPI0_MISO_IO1___4 = 342,
	FN_USB0_OVC___5 = 343,
	FN_QSPI0_MOSI_IO0___4 = 344,
	FN_USB0_PWEN___5 = 345,
	FN_VI4_CLK___6 = 346,
	FN_QSPI0_SPCLK___4 = 347,
	FN_IP0_3_0___8 = 348,
	FN_IRQ0_A = 349,
	FN_MSIOF2_SYNC_B___6 = 350,
	FN_IP1_3_0___8 = 351,
	FN_DU_DB1___8 = 352,
	FN_LCDOUT1___6 = 353,
	FN_MSIOF3_RXD_B___6 = 354,
	FN_IP2_3_0___8 = 355,
	FN_DU_DG1___8 = 356,
	FN_LCDOUT9___6 = 357,
	FN_MSIOF3_SYNC_B___6 = 358,
	FN_IP3_3_0___8 = 359,
	FN_DU_DR1___8 = 360,
	FN_LCDOUT17___6 = 361,
	FN_TX4_B___6 = 362,
	FN_IP0_7_4___8 = 363,
	FN_MSIOF2_SCK___3 = 364,
	FN_IP1_7_4___8 = 365,
	FN_DU_DB2___8 = 366,
	FN_LCDOUT2___6 = 367,
	FN_IRQ0_B = 368,
	FN_IP2_7_4___8 = 369,
	FN_DU_DG2___8 = 370,
	FN_LCDOUT10___6 = 371,
	FN_IP3_7_4___8 = 372,
	FN_DU_DR2___8 = 373,
	FN_LCDOUT18___6 = 374,
	FN_PWM0_B___4 = 375,
	FN_IP0_11_8___8 = 376,
	FN_MSIOF2_TXD___3 = 377,
	FN_SCL3_A___2 = 378,
	FN_IP1_11_8___8 = 379,
	FN_DU_DB3___8 = 380,
	FN_LCDOUT3___6 = 381,
	FN_SCK5_B___4 = 382,
	FN_IP2_11_8___8 = 383,
	FN_DU_DG3___8 = 384,
	FN_LCDOUT11___6 = 385,
	FN_IRQ1_A = 386,
	FN_IP3_11_8___8 = 387,
	FN_DU_DR3___8 = 388,
	FN_LCDOUT19___6 = 389,
	FN_PWM1_B___8 = 390,
	FN_IP0_15_12___8 = 391,
	FN_MSIOF2_RXD___3 = 392,
	FN_SDA3_A___2 = 393,
	FN_IP1_15_12___8 = 394,
	FN_DU_DB4___8 = 395,
	FN_LCDOUT4___6 = 396,
	FN_RX5_B___5 = 397,
	FN_IP2_15_12___8 = 398,
	FN_DU_DG4___8 = 399,
	FN_LCDOUT12___6 = 400,
	FN_HSCK3_B___2 = 401,
	FN_IP3_15_12___8 = 402,
	FN_DU_DR4___8 = 403,
	FN_LCDOUT20___6 = 404,
	FN_TCLK2_B___8 = 405,
	FN_IP0_19_16___8 = 406,
	FN_MLB_CLK___6 = 407,
	FN_MSIOF2_SYNC_A___6 = 408,
	FN_SCK5_A___5 = 409,
	FN_IP1_19_16___8 = 410,
	FN_DU_DB5___8 = 411,
	FN_LCDOUT5___6 = 412,
	FN_TX5_B___5 = 413,
	FN_IP2_19_16___8 = 414,
	FN_DU_DG5___8 = 415,
	FN_LCDOUT13___6 = 416,
	FN_HTX3_B___6 = 417,
	FN_IP3_19_16___8 = 418,
	FN_DU_DR5___8 = 419,
	FN_LCDOUT21___6 = 420,
	FN_NMI = 421,
	FN_IP0_23_20___8 = 422,
	FN_MLB_DAT___6 = 423,
	FN_MSIOF2_SS1___3 = 424,
	FN_RX5_A___5 = 425,
	FN_SCL3_B___2 = 426,
	FN_IP1_23_20___8 = 427,
	FN_DU_DB6___8 = 428,
	FN_LCDOUT6___6 = 429,
	FN_MSIOF3_SS1_B___6 = 430,
	FN_IP2_23_20___8 = 431,
	FN_DU_DG6___8 = 432,
	FN_LCDOUT14___6 = 433,
	FN_HRX3_B___6 = 434,
	FN_IP3_23_20___8 = 435,
	FN_DU_DR6___8 = 436,
	FN_LCDOUT22___6 = 437,
	FN_PWM2_B___8 = 438,
	FN_IP0_27_24___8 = 439,
	FN_MLB_SIG___6 = 440,
	FN_MSIOF2_SS2___3 = 441,
	FN_TX5_A___5 = 442,
	FN_SDA3_B___2 = 443,
	FN_IP1_27_24___8 = 444,
	FN_DU_DB7___8 = 445,
	FN_LCDOUT7___6 = 446,
	FN_MSIOF3_SS2_B___5 = 447,
	FN_IP2_27_24___8 = 448,
	FN_DU_DG7___8 = 449,
	FN_LCDOUT15___6 = 450,
	FN_SCK4_B___6 = 451,
	FN_IP3_27_24___8 = 452,
	FN_DU_DR7___8 = 453,
	FN_LCDOUT23___6 = 454,
	FN_TCLK1_B___8 = 455,
	FN_IP0_31_28___8 = 456,
	FN_DU_DB0___8 = 457,
	FN_LCDOUT0___6 = 458,
	FN_MSIOF3_TXD_B___6 = 459,
	FN_IP1_31_28___8 = 460,
	FN_DU_DG0___8 = 461,
	FN_LCDOUT8___6 = 462,
	FN_MSIOF3_SCK_B___6 = 463,
	FN_IP2_31_28___8 = 464,
	FN_DU_DR0___8 = 465,
	FN_LCDOUT16___6 = 466,
	FN_RX4_B___6 = 467,
	FN_IP3_31_28___8 = 468,
	FN_DU_DOTCLKOUT0___6 = 469,
	FN_QCLK___6 = 470,
	FN_IP4_3_0___8 = 471,
	FN_DU_HSYNC___2 = 472,
	FN_QSTH_QHS___6 = 473,
	FN_IRQ3_A = 474,
	FN_IP5_3_0___8 = 475,
	FN_VI4_DATA1 = 476,
	FN_PWM1_A___8 = 477,
	FN_IP6_3_0___8 = 478,
	FN_VI4_DATA10___6 = 479,
	FN_RX4_A___6 = 480,
	FN_IP7_3_0___8 = 481,
	FN_VI4_DATA18___6 = 482,
	FN_HSCK3_A = 483,
	FN_IP4_7_4___8 = 484,
	FN_DU_VSYNC___2 = 485,
	FN_QSTVA_QVS___6 = 486,
	FN_IRQ4_A = 487,
	FN_IP5_7_4___8 = 488,
	FN_VI4_DATA2 = 489,
	FN_PWM2_A___8 = 490,
	FN_IP6_7_4___8 = 491,
	FN_VI4_DATA11___6 = 492,
	FN_TX4_A___6 = 493,
	FN_IP7_7_4___8 = 494,
	FN_VI4_DATA19___6 = 495,
	FN_SSI_WS4_B = 496,
	FN_NFDATA15 = 497,
	FN_IP4_11_8___8 = 498,
	FN_DU_DISP___8 = 499,
	FN_QSTVB_QVE___6 = 500,
	FN_PWM3_B___8 = 501,
	FN_IP5_11_8___8 = 502,
	FN_VI4_DATA3 = 503,
	FN_PWM3_A___8 = 504,
	FN_IP6_11_8___8 = 505,
	FN_VI4_DATA12___6 = 506,
	FN_TCLK1_A___8 = 507,
	FN_IP7_11_8___8 = 508,
	FN_VI4_DATA20___6 = 509,
	FN_MSIOF3_SYNC_A___6 = 510,
	FN_NFDATA14 = 511,
	FN_IP4_15_12___8 = 512,
	FN_DU_DISP_CDE___2 = 513,
	FN_QCPV_QDE___6 = 514,
	FN_IRQ2_B = 515,
	FN_DU_DOTCLKIN1___2 = 516,
	FN_IP5_15_12___8 = 517,
	FN_VI4_DATA5 = 518,
	FN_SCK4_A___6 = 519,
	FN_IP6_15_12___8 = 520,
	FN_VI4_DATA13___6 = 521,
	FN_MSIOF3_SS1_A___6 = 522,
	FN_HCTS3_N___7 = 523,
	FN_IP7_15_12___5 = 524,
	FN_VI4_DATA21___6 = 525,
	FN_MSIOF3_TXD_A___6 = 526,
	FN_NFDATA13___5 = 527,
	FN_IP4_19_16___8 = 528,
	FN_DU_CDE___8 = 529,
	FN_QSTB_QHE___6 = 530,
	FN_SCK3_B = 531,
	FN_IP5_19_16___8 = 532,
	FN_VI4_DATA6 = 533,
	FN_IRQ2_A = 534,
	FN_IP6_19_16___8 = 535,
	FN_VI4_DATA14___6 = 536,
	FN_SSI_SCK4_B = 537,
	FN_HRTS3_N___7 = 538,
	FN_IP7_19_16___8 = 539,
	FN_VI4_DATA22___6 = 540,
	FN_MSIOF3_RXD_A___6 = 541,
	FN_NFDATA12___5 = 542,
	FN_IP4_23_20___8 = 543,
	FN_QPOLA___6 = 544,
	FN_RX3_B___6 = 545,
	FN_IP5_23_20___8 = 546,
	FN_VI4_DATA7 = 547,
	FN_TCLK2_A___8 = 548,
	FN_IP6_23_20___8 = 549,
	FN_VI4_DATA15___6 = 550,
	FN_SSI_SDATA4_B = 551,
	FN_IP7_23_20___8 = 552,
	FN_VI4_DATA23___6 = 553,
	FN_MSIOF3_SCK_A___6 = 554,
	FN_NFDATA11___5 = 555,
	FN_IP4_27_24___8 = 556,
	FN_QPOLB___6 = 557,
	FN_TX3_B___6 = 558,
	FN_IP5_27_24___8 = 559,
	FN_VI4_DATA8___6 = 560,
	FN_IP6_27_24___8 = 561,
	FN_VI4_DATA16___6 = 562,
	FN_HRX3_A___6 = 563,
	FN_IP7_27_24___8 = 564,
	FN_VI4_VSYNC_N___6 = 565,
	FN_SCK1_B = 566,
	FN_NFDATA10___5 = 567,
	FN_IP4_31_28___8 = 568,
	FN_VI4_DATA0 = 569,
	FN_PWM0_A___4 = 570,
	FN_IP5_31_28___8 = 571,
	FN_VI4_DATA9___6 = 572,
	FN_MSIOF3_SS2_A___6 = 573,
	FN_IRQ1_B = 574,
	FN_IP6_31_28___8 = 575,
	FN_VI4_DATA17___6 = 576,
	FN_HTX3_A___6 = 577,
	FN_IP7_31_28___8 = 578,
	FN_VI4_HSYNC_N___6 = 579,
	FN_RX1_B___7 = 580,
	FN_NFDATA9___5 = 581,
	FN_IP8_3_0___8 = 582,
	FN_VI4_FIELD___6 = 583,
	FN_AUDIO_CLKB = 584,
	FN_IRQ5_A = 585,
	FN_SCIF_CLK = 586,
	FN_NFDATA8___5 = 587,
	FN_IP9_3_0___7 = 588,
	FN_NFDATA0___5 = 589,
	FN_MMC_D0___3 = 590,
	FN_IP10_3_0___7 = 591,
	FN_AUDIO_CLKA___2 = 592,
	FN_DVC_MUTE_B = 593,
	FN_IP11_3_0___6 = 594,
	FN_SDA1___3 = 595,
	FN_RTS1_N___8 = 596,
	FN_IP8_7_4___8 = 597,
	FN_VI4_CLKENB___6 = 598,
	FN_TX1_B___7 = 599,
	FN_NFWP_N = 600,
	FN_DVC_MUTE_A = 601,
	FN_IP9_7_4___7 = 602,
	FN_NFDATA1___5 = 603,
	FN_MMC_D1___3 = 604,
	FN_IP10_7_4___7 = 605,
	FN_SSI_SCK34 = 606,
	FN_FSO_CFE_0_N_A___3 = 607,
	FN_IP11_7_4___6 = 608,
	FN_MSIOF1_SCK___4 = 609,
	FN_AVB0_AVTP_PPS_B = 610,
	FN_IP8_11_8___8 = 611,
	FN_NFALE___4 = 612,
	FN_SCL2_B___6 = 613,
	FN_IRQ3_B = 614,
	FN_PWM0_C = 615,
	FN_IP9_11_8___7 = 616,
	FN_NFDATA2___5 = 617,
	FN_MMC_D2___3 = 618,
	FN_IP10_11_8___7 = 619,
	FN_SSI_SDATA3___6 = 620,
	FN_FSO_CFE_1_N_A___3 = 621,
	FN_IP11_11_8___6 = 622,
	FN_MSIOF1_TXD___4 = 623,
	FN_AVB0_AVTP_CAPTURE_B = 624,
	FN_IP8_15_12___8 = 625,
	FN_NFCLE___5 = 626,
	FN_SDA2_B___6 = 627,
	FN_SCK3_A___2 = 628,
	FN_PWM1_C = 629,
	FN_IP9_15_12___7 = 630,
	FN_NFDATA3___5 = 631,
	FN_MMC_D3___3 = 632,
	FN_IP10_15_12___7 = 633,
	FN_SSI_WS34 = 634,
	FN_FSO_TOE_N_A___3 = 635,
	FN_IP11_15_12___6 = 636,
	FN_MSIOF1_RXD___4 = 637,
	FN_AVB0_AVTP_MATCH_B = 638,
	FN_IP8_19_16___8 = 639,
	FN_NFCE_N = 640,
	FN_RX3_A___6 = 641,
	FN_PWM2_C___2 = 642,
	FN_IP9_19_16___7 = 643,
	FN_NFDATA4___5 = 644,
	FN_MMC_D4___3 = 645,
	FN_IP10_19_16___7 = 646,
	FN_SSI_SCK4_A = 647,
	FN_HSCK0___6 = 648,
	FN_AUDIO_CLKOUT = 649,
	FN_CAN0_RX_B___5 = 650,
	FN_IRQ4_B = 651,
	FN_IP11_19_16___6 = 652,
	FN_SCK0_A___2 = 653,
	FN_MSIOF1_SYNC___4 = 654,
	FN_FSO_CFE_0_N_B___3 = 655,
	FN_IP8_23_20___8 = 656,
	FN_NFRB_N = 657,
	FN_TX3_A___6 = 658,
	FN_PWM3_C___2 = 659,
	FN_IP9_23_20___7 = 660,
	FN_NFDATA5___5 = 661,
	FN_MMC_D5___3 = 662,
	FN_IP10_23_20___7 = 663,
	FN_SSI_SDATA4_A = 664,
	FN_HTX0___6 = 665,
	FN_SCL2_A___6 = 666,
	FN_CAN1_RX_B = 667,
	FN_IP11_23_20___6 = 668,
	FN_RX0_A___2 = 669,
	FN_MSIOF0_SS1___8 = 670,
	FN_FSO_CFE_1_N_B___3 = 671,
	FN_IP8_27_24___8 = 672,
	FN_NFRE_N___5 = 673,
	FN_MMC_CMD___3 = 674,
	FN_IP9_27_24___7 = 675,
	FN_NFDATA6___5 = 676,
	FN_MMC_D6___3 = 677,
	FN_IP10_27_24___7 = 678,
	FN_SSI_WS4_A = 679,
	FN_HRX0___6 = 680,
	FN_SDA2_A___6 = 681,
	FN_CAN1_TX_B = 682,
	FN_IP11_27_24___6 = 683,
	FN_TX0_A___2 = 684,
	FN_MSIOF0_SS2___8 = 685,
	FN_FSO_TOE_N_B___3 = 686,
	FN_IP8_31_28___8 = 687,
	FN_NFWE_N___5 = 688,
	FN_MMC_CLK___3 = 689,
	FN_IP9_31_28___7 = 690,
	FN_NFDATA7___5 = 691,
	FN_MMC_D7___3 = 692,
	FN_IP10_31_28___7 = 693,
	FN_SCL1___3 = 694,
	FN_CTS1_N___8 = 695,
	FN_IP11_31_28___6 = 696,
	FN_SCK1_A = 697,
	FN_MSIOF1_SS2___4 = 698,
	FN_TPU0TO2_B = 699,
	FN_CAN0_TX_B___5 = 700,
	FN_AUDIO_CLKOUT1 = 701,
	FN_IP12_3_0___6 = 702,
	FN_RX1_A___7 = 703,
	FN_CTS0_N___7 = 704,
	FN_TPU0TO0_B = 705,
	FN_IP13_3_0___6 = 706,
	FN_CAN1_RX_A = 707,
	FN_CANFD1_RX___8 = 708,
	FN_TPU0TO2_A = 709,
	FN_IP12_7_4___6 = 710,
	FN_TX1_A___7 = 711,
	FN_RTS0_N___7 = 712,
	FN_TPU0TO1_B = 713,
	FN_IP13_7_4___6 = 714,
	FN_CAN1_TX_A = 715,
	FN_CANFD1_TX___8 = 716,
	FN_TPU0TO3_A = 717,
	FN_IP12_11_8___6 = 718,
	FN_SCK2___5 = 719,
	FN_MSIOF1_SS1___4 = 720,
	FN_TPU0TO3_B = 721,
	FN_IP12_15_12___6 = 722,
	FN_TPU0TO0_A = 723,
	FN_AVB0_AVTP_CAPTURE_A = 724,
	FN_HCTS0_N___6 = 725,
	FN_IP12_19_16___6 = 726,
	FN_TPU0TO1_A = 727,
	FN_AVB0_AVTP_MATCH_A = 728,
	FN_HRTS0_N___6 = 729,
	FN_IP12_23_20___6 = 730,
	FN_CAN_CLK___6 = 731,
	FN_AVB0_AVTP_PPS_A = 732,
	FN_SCK0_B___2 = 733,
	FN_IRQ5_B = 734,
	FN_IP12_27_24___6 = 735,
	FN_CAN0_RX_A___5 = 736,
	FN_CANFD0_RX___2 = 737,
	FN_RX0_B___2 = 738,
	FN_IP12_31_28___6 = 739,
	FN_CAN0_TX_A___5 = 740,
	FN_CANFD0_TX___2 = 741,
	FN_TX0_B___2 = 742,
	FN_SEL_CAN0_0 = 743,
	FN_SEL_CAN0_1 = 744,
	FN_SEL_MSIOF2_0___6 = 745,
	FN_SEL_MSIOF2_1___6 = 746,
	FN_SEL_CAN1_0 = 747,
	FN_SEL_CAN1_1 = 748,
	FN_SEL_I2C3_0___2 = 749,
	FN_SEL_I2C3_1___2 = 750,
	FN_SEL_I2C2_0___6 = 751,
	FN_SEL_I2C2_1___6 = 752,
	FN_SEL_SCIF5_0___5 = 753,
	FN_SEL_SCIF5_1___5 = 754,
	FN_SEL_ETHERAVB_0___5 = 755,
	FN_SEL_ETHERAVB_1___5 = 756,
	FN_SEL_MSIOF3_0___6 = 757,
	FN_SEL_MSIOF3_1___6 = 758,
	FN_SEL_SCIF0_0___2 = 759,
	FN_SEL_SCIF0_1___2 = 760,
	FN_SEL_HSCIF3_0___6 = 761,
	FN_SEL_HSCIF3_1___6 = 762,
	FN_SEL_SSIF4_0 = 763,
	FN_SEL_SSIF4_1 = 764,
	FN_SEL_SCIF4_0___6 = 765,
	FN_SEL_SCIF4_1___6 = 766,
	FN_SEL_PWM0_0___4 = 767,
	FN_SEL_PWM0_2 = 768,
	FN_SEL_PWM0_1___4 = 769,
	FN_SEL_PWM1_0___8 = 770,
	FN_SEL_PWM1_2 = 771,
	FN_SEL_PWM1_1___8 = 772,
	FN_SEL_PWM2_0___8 = 773,
	FN_SEL_PWM2_2___2 = 774,
	FN_SEL_PWM2_1___8 = 775,
	FN_SEL_PWM3_0___8 = 776,
	FN_SEL_PWM3_2___2 = 777,
	FN_SEL_PWM3_1___8 = 778,
	FN_SEL_IRQ_0_0 = 779,
	FN_SEL_IRQ_0_1 = 780,
	FN_SEL_IRQ_1_0 = 781,
	FN_SEL_IRQ_1_1 = 782,
	FN_SEL_IRQ_2_0 = 783,
	FN_SEL_IRQ_2_1 = 784,
	FN_SEL_IRQ_3_0 = 785,
	FN_SEL_IRQ_3_1 = 786,
	FN_SEL_IRQ_4_0 = 787,
	FN_SEL_IRQ_4_1 = 788,
	FN_SEL_IRQ_5_0 = 789,
	FN_SEL_IRQ_5_1 = 790,
	FN_SEL_TMU_0_0 = 791,
	FN_SEL_TMU_0_1 = 792,
	FN_SEL_TMU_1_0 = 793,
	FN_SEL_TMU_1_1 = 794,
	FN_SEL_SCIF3_0___6 = 795,
	FN_SEL_SCIF3_1___6 = 796,
	FN_SEL_SCIF1_0___7 = 797,
	FN_SEL_SCIF1_1___7 = 798,
	FN_SEL_SCU_0 = 799,
	FN_SEL_SCU_1 = 800,
	FN_SEL_RFSO_0___2 = 801,
	FN_SEL_RFSO_1___2 = 802,
	PINMUX_FUNCTION_END___8 = 803,
	PINMUX_MARK_BEGIN___8 = 804,
	TX2_MARK = 805,
	RX2_MARK = 806,
	AVB0_LINK_MARK___2 = 807,
	AVB0_PHY_INT_MARK___2 = 808,
	AVB0_MAGIC_MARK___2 = 809,
	AVB0_MDC_MARK___2 = 810,
	AVB0_MDIO_MARK___2 = 811,
	MSIOF0_RXD_MARK___8 = 812,
	AVB0_TXCREFCLK_MARK___2 = 813,
	MSIOF0_TXD_MARK___8 = 814,
	AVB0_TD3_MARK___2 = 815,
	MSIOF0_SYNC_MARK___8 = 816,
	AVB0_TD2_MARK___2 = 817,
	RPC_INT_N_MARK___4 = 818,
	MSIOF0_SCK_MARK___8 = 819,
	AVB0_TD1_MARK___2 = 820,
	RPC_RESET_N_MARK___4 = 821,
	AVB0_TD0_MARK___2 = 822,
	QSPI1_SSL_MARK___8 = 823,
	AVB0_TXC_MARK___2 = 824,
	QSPI1_IO3_MARK___8 = 825,
	SDA0_MARK___7 = 826,
	AVB0_TX_CTL_MARK___2 = 827,
	QSPI1_IO2_MARK___8 = 828,
	SCL0_MARK___7 = 829,
	AVB0_RD3_MARK___2 = 830,
	QSPI1_MISO_IO1_MARK___8 = 831,
	AVB0_RD2_MARK___2 = 832,
	QSPI1_MOSI_IO0_MARK___8 = 833,
	AVB0_RD1_MARK___2 = 834,
	QSPI1_SPCLK_MARK___8 = 835,
	VI4_DATA4_MARK = 836,
	AVB0_RD0_MARK___2 = 837,
	QSPI0_SSL_MARK___8 = 838,
	AVB0_RXC_MARK___2 = 839,
	QSPI0_IO3_MARK___8 = 840,
	AVB0_RX_CTL_MARK___2 = 841,
	QSPI0_IO2_MARK___8 = 842,
	QSPI0_MISO_IO1_MARK___8 = 843,
	USB0_OVC_MARK___5 = 844,
	QSPI0_MOSI_IO0_MARK___8 = 845,
	USB0_PWEN_MARK___5 = 846,
	VI4_CLK_MARK___6 = 847,
	QSPI0_SPCLK_MARK___8 = 848,
	IP0_3_0_MARK___8 = 849,
	IRQ0_A_MARK = 850,
	MSIOF2_SYNC_B_MARK___6 = 851,
	IP1_3_0_MARK___8 = 852,
	DU_DB1_MARK___8 = 853,
	LCDOUT1_MARK___6 = 854,
	MSIOF3_RXD_B_MARK___6 = 855,
	IP2_3_0_MARK___8 = 856,
	DU_DG1_MARK___8 = 857,
	LCDOUT9_MARK___6 = 858,
	MSIOF3_SYNC_B_MARK___6 = 859,
	IP3_3_0_MARK___8 = 860,
	DU_DR1_MARK___8 = 861,
	LCDOUT17_MARK___6 = 862,
	TX4_B_MARK___6 = 863,
	IP0_7_4_MARK___8 = 864,
	MSIOF2_SCK_MARK___3 = 865,
	IP1_7_4_MARK___8 = 866,
	DU_DB2_MARK___8 = 867,
	LCDOUT2_MARK___6 = 868,
	IRQ0_B_MARK = 869,
	IP2_7_4_MARK___8 = 870,
	DU_DG2_MARK___8 = 871,
	LCDOUT10_MARK___6 = 872,
	IP3_7_4_MARK___8 = 873,
	DU_DR2_MARK___8 = 874,
	LCDOUT18_MARK___6 = 875,
	PWM0_B_MARK___4 = 876,
	IP0_11_8_MARK___8 = 877,
	MSIOF2_TXD_MARK___3 = 878,
	SCL3_A_MARK___2 = 879,
	IP1_11_8_MARK___8 = 880,
	DU_DB3_MARK___8 = 881,
	LCDOUT3_MARK___6 = 882,
	SCK5_B_MARK___4 = 883,
	IP2_11_8_MARK___8 = 884,
	DU_DG3_MARK___8 = 885,
	LCDOUT11_MARK___6 = 886,
	IRQ1_A_MARK = 887,
	IP3_11_8_MARK___8 = 888,
	DU_DR3_MARK___8 = 889,
	LCDOUT19_MARK___6 = 890,
	PWM1_B_MARK___8 = 891,
	IP0_15_12_MARK___8 = 892,
	MSIOF2_RXD_MARK___3 = 893,
	SDA3_A_MARK___2 = 894,
	IP1_15_12_MARK___8 = 895,
	DU_DB4_MARK___8 = 896,
	LCDOUT4_MARK___6 = 897,
	RX5_B_MARK___5 = 898,
	IP2_15_12_MARK___8 = 899,
	DU_DG4_MARK___8 = 900,
	LCDOUT12_MARK___6 = 901,
	HSCK3_B_MARK___2 = 902,
	IP3_15_12_MARK___8 = 903,
	DU_DR4_MARK___8 = 904,
	LCDOUT20_MARK___6 = 905,
	TCLK2_B_MARK___8 = 906,
	IP0_19_16_MARK___8 = 907,
	MLB_CLK_MARK___6 = 908,
	MSIOF2_SYNC_A_MARK___6 = 909,
	SCK5_A_MARK___5 = 910,
	IP1_19_16_MARK___8 = 911,
	DU_DB5_MARK___8 = 912,
	LCDOUT5_MARK___6 = 913,
	TX5_B_MARK___5 = 914,
	IP2_19_16_MARK___8 = 915,
	DU_DG5_MARK___8 = 916,
	LCDOUT13_MARK___6 = 917,
	HTX3_B_MARK___6 = 918,
	IP3_19_16_MARK___8 = 919,
	DU_DR5_MARK___8 = 920,
	LCDOUT21_MARK___6 = 921,
	NMI_MARK = 922,
	IP0_23_20_MARK___8 = 923,
	MLB_DAT_MARK___6 = 924,
	MSIOF2_SS1_MARK___3 = 925,
	RX5_A_MARK___5 = 926,
	SCL3_B_MARK___2 = 927,
	IP1_23_20_MARK___8 = 928,
	DU_DB6_MARK___8 = 929,
	LCDOUT6_MARK___6 = 930,
	MSIOF3_SS1_B_MARK___6 = 931,
	IP2_23_20_MARK___8 = 932,
	DU_DG6_MARK___8 = 933,
	LCDOUT14_MARK___6 = 934,
	HRX3_B_MARK___6 = 935,
	IP3_23_20_MARK___8 = 936,
	DU_DR6_MARK___8 = 937,
	LCDOUT22_MARK___6 = 938,
	PWM2_B_MARK___8 = 939,
	IP0_27_24_MARK___8 = 940,
	MLB_SIG_MARK___6 = 941,
	MSIOF2_SS2_MARK___3 = 942,
	TX5_A_MARK___5 = 943,
	SDA3_B_MARK___2 = 944,
	IP1_27_24_MARK___8 = 945,
	DU_DB7_MARK___8 = 946,
	LCDOUT7_MARK___6 = 947,
	MSIOF3_SS2_B_MARK___5 = 948,
	IP2_27_24_MARK___8 = 949,
	DU_DG7_MARK___8 = 950,
	LCDOUT15_MARK___6 = 951,
	SCK4_B_MARK___6 = 952,
	IP3_27_24_MARK___8 = 953,
	DU_DR7_MARK___8 = 954,
	LCDOUT23_MARK___6 = 955,
	TCLK1_B_MARK___8 = 956,
	IP0_31_28_MARK___8 = 957,
	DU_DB0_MARK___8 = 958,
	LCDOUT0_MARK___6 = 959,
	MSIOF3_TXD_B_MARK___6 = 960,
	IP1_31_28_MARK___8 = 961,
	DU_DG0_MARK___8 = 962,
	LCDOUT8_MARK___6 = 963,
	MSIOF3_SCK_B_MARK___6 = 964,
	IP2_31_28_MARK___8 = 965,
	DU_DR0_MARK___8 = 966,
	LCDOUT16_MARK___6 = 967,
	RX4_B_MARK___6 = 968,
	IP3_31_28_MARK___8 = 969,
	DU_DOTCLKOUT0_MARK___6 = 970,
	QCLK_MARK___6 = 971,
	IP4_3_0_MARK___8 = 972,
	DU_HSYNC_MARK___2 = 973,
	QSTH_QHS_MARK___6 = 974,
	IRQ3_A_MARK = 975,
	IP5_3_0_MARK___8 = 976,
	VI4_DATA1_MARK = 977,
	PWM1_A_MARK___8 = 978,
	IP6_3_0_MARK___8 = 979,
	VI4_DATA10_MARK___6 = 980,
	RX4_A_MARK___6 = 981,
	IP7_3_0_MARK___8 = 982,
	VI4_DATA18_MARK___6 = 983,
	HSCK3_A_MARK = 984,
	IP4_7_4_MARK___8 = 985,
	DU_VSYNC_MARK___2 = 986,
	QSTVA_QVS_MARK___6 = 987,
	IRQ4_A_MARK = 988,
	IP5_7_4_MARK___8 = 989,
	VI4_DATA2_MARK = 990,
	PWM2_A_MARK___8 = 991,
	IP6_7_4_MARK___8 = 992,
	VI4_DATA11_MARK___6 = 993,
	TX4_A_MARK___6 = 994,
	IP7_7_4_MARK___8 = 995,
	VI4_DATA19_MARK___6 = 996,
	SSI_WS4_B_MARK = 997,
	NFDATA15_MARK = 998,
	IP4_11_8_MARK___8 = 999,
	DU_DISP_MARK___8 = 1000,
	QSTVB_QVE_MARK___6 = 1001,
	PWM3_B_MARK___8 = 1002,
	IP5_11_8_MARK___8 = 1003,
	VI4_DATA3_MARK = 1004,
	PWM3_A_MARK___8 = 1005,
	IP6_11_8_MARK___8 = 1006,
	VI4_DATA12_MARK___6 = 1007,
	TCLK1_A_MARK___8 = 1008,
	IP7_11_8_MARK___8 = 1009,
	VI4_DATA20_MARK___6 = 1010,
	MSIOF3_SYNC_A_MARK___6 = 1011,
	NFDATA14_MARK = 1012,
	IP4_15_12_MARK___8 = 1013,
	DU_DISP_CDE_MARK___2 = 1014,
	QCPV_QDE_MARK___6 = 1015,
	IRQ2_B_MARK = 1016,
	DU_DOTCLKIN1_MARK___6 = 1017,
	IP5_15_12_MARK___8 = 1018,
	VI4_DATA5_MARK = 1019,
	SCK4_A_MARK___6 = 1020,
	IP6_15_12_MARK___8 = 1021,
	VI4_DATA13_MARK___6 = 1022,
	MSIOF3_SS1_A_MARK___6 = 1023,
	HCTS3_N_MARK___7 = 1024,
	IP7_15_12_MARK___5 = 1025,
	VI4_DATA21_MARK___6 = 1026,
	MSIOF3_TXD_A_MARK___6 = 1027,
	NFDATA13_MARK___5 = 1028,
	IP4_19_16_MARK___8 = 1029,
	DU_CDE_MARK___8 = 1030,
	QSTB_QHE_MARK___6 = 1031,
	SCK3_B_MARK = 1032,
	IP5_19_16_MARK___8 = 1033,
	VI4_DATA6_MARK = 1034,
	IRQ2_A_MARK = 1035,
	IP6_19_16_MARK___8 = 1036,
	VI4_DATA14_MARK___6 = 1037,
	SSI_SCK4_B_MARK = 1038,
	HRTS3_N_MARK___7 = 1039,
	IP7_19_16_MARK___8 = 1040,
	VI4_DATA22_MARK___6 = 1041,
	MSIOF3_RXD_A_MARK___6 = 1042,
	NFDATA12_MARK___5 = 1043,
	IP4_23_20_MARK___8 = 1044,
	QPOLA_MARK___6 = 1045,
	RX3_B_MARK___6 = 1046,
	IP5_23_20_MARK___8 = 1047,
	VI4_DATA7_MARK = 1048,
	TCLK2_A_MARK___8 = 1049,
	IP6_23_20_MARK___8 = 1050,
	VI4_DATA15_MARK___6 = 1051,
	SSI_SDATA4_B_MARK = 1052,
	IP7_23_20_MARK___8 = 1053,
	VI4_DATA23_MARK___6 = 1054,
	MSIOF3_SCK_A_MARK___6 = 1055,
	NFDATA11_MARK___5 = 1056,
	IP4_27_24_MARK___8 = 1057,
	QPOLB_MARK___6 = 1058,
	TX3_B_MARK___6 = 1059,
	IP5_27_24_MARK___8 = 1060,
	VI4_DATA8_MARK___6 = 1061,
	IP6_27_24_MARK___8 = 1062,
	VI4_DATA16_MARK___6 = 1063,
	HRX3_A_MARK___6 = 1064,
	IP7_27_24_MARK___8 = 1065,
	VI4_VSYNC_N_MARK___6 = 1066,
	SCK1_B_MARK = 1067,
	NFDATA10_MARK___5 = 1068,
	IP4_31_28_MARK___8 = 1069,
	VI4_DATA0_MARK = 1070,
	PWM0_A_MARK___4 = 1071,
	IP5_31_28_MARK___8 = 1072,
	VI4_DATA9_MARK___6 = 1073,
	MSIOF3_SS2_A_MARK___6 = 1074,
	IRQ1_B_MARK = 1075,
	IP6_31_28_MARK___8 = 1076,
	VI4_DATA17_MARK___6 = 1077,
	HTX3_A_MARK___6 = 1078,
	IP7_31_28_MARK___8 = 1079,
	VI4_HSYNC_N_MARK___6 = 1080,
	RX1_B_MARK___7 = 1081,
	NFDATA9_MARK___5 = 1082,
	IP8_3_0_MARK___8 = 1083,
	VI4_FIELD_MARK___6 = 1084,
	AUDIO_CLKB_MARK = 1085,
	IRQ5_A_MARK = 1086,
	SCIF_CLK_MARK = 1087,
	NFDATA8_MARK___5 = 1088,
	IP9_3_0_MARK___7 = 1089,
	NFDATA0_MARK___5 = 1090,
	MMC_D0_MARK___3 = 1091,
	IP10_3_0_MARK___7 = 1092,
	AUDIO_CLKA_MARK___2 = 1093,
	DVC_MUTE_B_MARK = 1094,
	IP11_3_0_MARK___6 = 1095,
	SDA1_MARK___3 = 1096,
	RTS1_N_MARK___8 = 1097,
	IP8_7_4_MARK___8 = 1098,
	VI4_CLKENB_MARK___6 = 1099,
	TX1_B_MARK___7 = 1100,
	NFWP_N_MARK = 1101,
	DVC_MUTE_A_MARK = 1102,
	IP9_7_4_MARK___7 = 1103,
	NFDATA1_MARK___5 = 1104,
	MMC_D1_MARK___3 = 1105,
	IP10_7_4_MARK___7 = 1106,
	SSI_SCK34_MARK = 1107,
	FSO_CFE_0_N_A_MARK___3 = 1108,
	IP11_7_4_MARK___6 = 1109,
	MSIOF1_SCK_MARK___4 = 1110,
	AVB0_AVTP_PPS_B_MARK = 1111,
	IP8_11_8_MARK___8 = 1112,
	NFALE_MARK___4 = 1113,
	SCL2_B_MARK___6 = 1114,
	IRQ3_B_MARK = 1115,
	PWM0_C_MARK = 1116,
	IP9_11_8_MARK___7 = 1117,
	NFDATA2_MARK___5 = 1118,
	MMC_D2_MARK___3 = 1119,
	IP10_11_8_MARK___7 = 1120,
	SSI_SDATA3_MARK___6 = 1121,
	FSO_CFE_1_N_A_MARK___3 = 1122,
	IP11_11_8_MARK___6 = 1123,
	MSIOF1_TXD_MARK___4 = 1124,
	AVB0_AVTP_CAPTURE_B_MARK = 1125,
	IP8_15_12_MARK___8 = 1126,
	NFCLE_MARK___5 = 1127,
	SDA2_B_MARK___6 = 1128,
	SCK3_A_MARK___2 = 1129,
	PWM1_C_MARK = 1130,
	IP9_15_12_MARK___7 = 1131,
	NFDATA3_MARK___5 = 1132,
	MMC_D3_MARK___3 = 1133,
	IP10_15_12_MARK___7 = 1134,
	SSI_WS34_MARK = 1135,
	FSO_TOE_N_A_MARK___3 = 1136,
	IP11_15_12_MARK___6 = 1137,
	MSIOF1_RXD_MARK___4 = 1138,
	AVB0_AVTP_MATCH_B_MARK = 1139,
	IP8_19_16_MARK___8 = 1140,
	NFCE_N_MARK = 1141,
	RX3_A_MARK___6 = 1142,
	PWM2_C_MARK___2 = 1143,
	IP9_19_16_MARK___7 = 1144,
	NFDATA4_MARK___5 = 1145,
	MMC_D4_MARK___3 = 1146,
	IP10_19_16_MARK___7 = 1147,
	SSI_SCK4_A_MARK = 1148,
	HSCK0_MARK___6 = 1149,
	AUDIO_CLKOUT_MARK = 1150,
	CAN0_RX_B_MARK___5 = 1151,
	IRQ4_B_MARK = 1152,
	IP11_19_16_MARK___6 = 1153,
	SCK0_A_MARK___2 = 1154,
	MSIOF1_SYNC_MARK___4 = 1155,
	FSO_CFE_0_N_B_MARK___3 = 1156,
	IP8_23_20_MARK___8 = 1157,
	NFRB_N_MARK = 1158,
	TX3_A_MARK___6 = 1159,
	PWM3_C_MARK___2 = 1160,
	IP9_23_20_MARK___7 = 1161,
	NFDATA5_MARK___5 = 1162,
	MMC_D5_MARK___3 = 1163,
	IP10_23_20_MARK___7 = 1164,
	SSI_SDATA4_A_MARK = 1165,
	HTX0_MARK___6 = 1166,
	SCL2_A_MARK___6 = 1167,
	CAN1_RX_B_MARK = 1168,
	IP11_23_20_MARK___6 = 1169,
	RX0_A_MARK___2 = 1170,
	MSIOF0_SS1_MARK___8 = 1171,
	FSO_CFE_1_N_B_MARK___3 = 1172,
	IP8_27_24_MARK___8 = 1173,
	NFRE_N_MARK___5 = 1174,
	MMC_CMD_MARK___3 = 1175,
	IP9_27_24_MARK___7 = 1176,
	NFDATA6_MARK___5 = 1177,
	MMC_D6_MARK___3 = 1178,
	IP10_27_24_MARK___7 = 1179,
	SSI_WS4_A_MARK = 1180,
	HRX0_MARK___6 = 1181,
	SDA2_A_MARK___6 = 1182,
	CAN1_TX_B_MARK = 1183,
	IP11_27_24_MARK___6 = 1184,
	TX0_A_MARK___2 = 1185,
	MSIOF0_SS2_MARK___8 = 1186,
	FSO_TOE_N_B_MARK___3 = 1187,
	IP8_31_28_MARK___8 = 1188,
	NFWE_N_MARK___5 = 1189,
	MMC_CLK_MARK___3 = 1190,
	IP9_31_28_MARK___7 = 1191,
	NFDATA7_MARK___5 = 1192,
	MMC_D7_MARK___3 = 1193,
	IP10_31_28_MARK___7 = 1194,
	SCL1_MARK___3 = 1195,
	CTS1_N_MARK___8 = 1196,
	IP11_31_28_MARK___6 = 1197,
	SCK1_A_MARK = 1198,
	MSIOF1_SS2_MARK___4 = 1199,
	TPU0TO2_B_MARK = 1200,
	CAN0_TX_B_MARK___5 = 1201,
	AUDIO_CLKOUT1_MARK = 1202,
	IP12_3_0_MARK___6 = 1203,
	RX1_A_MARK___7 = 1204,
	CTS0_N_MARK___7 = 1205,
	TPU0TO0_B_MARK = 1206,
	IP13_3_0_MARK___6 = 1207,
	CAN1_RX_A_MARK = 1208,
	CANFD1_RX_MARK___8 = 1209,
	TPU0TO2_A_MARK = 1210,
	IP12_7_4_MARK___6 = 1211,
	TX1_A_MARK___7 = 1212,
	RTS0_N_MARK___7 = 1213,
	TPU0TO1_B_MARK = 1214,
	IP13_7_4_MARK___6 = 1215,
	CAN1_TX_A_MARK = 1216,
	CANFD1_TX_MARK___8 = 1217,
	TPU0TO3_A_MARK = 1218,
	IP12_11_8_MARK___6 = 1219,
	SCK2_MARK___5 = 1220,
	MSIOF1_SS1_MARK___4 = 1221,
	TPU0TO3_B_MARK = 1222,
	IP12_15_12_MARK___6 = 1223,
	TPU0TO0_A_MARK = 1224,
	AVB0_AVTP_CAPTURE_A_MARK = 1225,
	HCTS0_N_MARK___6 = 1226,
	IP12_19_16_MARK___6 = 1227,
	TPU0TO1_A_MARK = 1228,
	AVB0_AVTP_MATCH_A_MARK = 1229,
	HRTS0_N_MARK___6 = 1230,
	IP12_23_20_MARK___6 = 1231,
	CAN_CLK_MARK___6 = 1232,
	AVB0_AVTP_PPS_A_MARK = 1233,
	SCK0_B_MARK___2 = 1234,
	IRQ5_B_MARK = 1235,
	IP12_27_24_MARK___6 = 1236,
	CAN0_RX_A_MARK___5 = 1237,
	CANFD0_RX_MARK___2 = 1238,
	RX0_B_MARK___2 = 1239,
	IP12_31_28_MARK___6 = 1240,
	CAN0_TX_A_MARK___5 = 1241,
	CANFD0_TX_MARK___2 = 1242,
	TX0_B_MARK___2 = 1243,
	SEL_CAN0_0_MARK = 1244,
	SEL_CAN0_1_MARK = 1245,
	SEL_MSIOF2_0_MARK___6 = 1246,
	SEL_MSIOF2_1_MARK___6 = 1247,
	SEL_CAN1_0_MARK = 1248,
	SEL_CAN1_1_MARK = 1249,
	SEL_I2C3_0_MARK___2 = 1250,
	SEL_I2C3_1_MARK___2 = 1251,
	SEL_I2C2_0_MARK___6 = 1252,
	SEL_I2C2_1_MARK___6 = 1253,
	SEL_SCIF5_0_MARK___5 = 1254,
	SEL_SCIF5_1_MARK___5 = 1255,
	SEL_ETHERAVB_0_MARK___5 = 1256,
	SEL_ETHERAVB_1_MARK___5 = 1257,
	SEL_MSIOF3_0_MARK___6 = 1258,
	SEL_MSIOF3_1_MARK___6 = 1259,
	SEL_SCIF0_0_MARK___2 = 1260,
	SEL_SCIF0_1_MARK___2 = 1261,
	SEL_HSCIF3_0_MARK___6 = 1262,
	SEL_HSCIF3_1_MARK___6 = 1263,
	SEL_SSIF4_0_MARK = 1264,
	SEL_SSIF4_1_MARK = 1265,
	SEL_SCIF4_0_MARK___6 = 1266,
	SEL_SCIF4_1_MARK___6 = 1267,
	SEL_PWM0_0_MARK___4 = 1268,
	SEL_PWM0_2_MARK = 1269,
	SEL_PWM0_1_MARK___4 = 1270,
	SEL_PWM1_0_MARK___8 = 1271,
	SEL_PWM1_2_MARK = 1272,
	SEL_PWM1_1_MARK___8 = 1273,
	SEL_PWM2_0_MARK___8 = 1274,
	SEL_PWM2_2_MARK___2 = 1275,
	SEL_PWM2_1_MARK___8 = 1276,
	SEL_PWM3_0_MARK___8 = 1277,
	SEL_PWM3_2_MARK___2 = 1278,
	SEL_PWM3_1_MARK___8 = 1279,
	SEL_IRQ_0_0_MARK = 1280,
	SEL_IRQ_0_1_MARK = 1281,
	SEL_IRQ_1_0_MARK = 1282,
	SEL_IRQ_1_1_MARK = 1283,
	SEL_IRQ_2_0_MARK = 1284,
	SEL_IRQ_2_1_MARK = 1285,
	SEL_IRQ_3_0_MARK = 1286,
	SEL_IRQ_3_1_MARK = 1287,
	SEL_IRQ_4_0_MARK = 1288,
	SEL_IRQ_4_1_MARK = 1289,
	SEL_IRQ_5_0_MARK = 1290,
	SEL_IRQ_5_1_MARK = 1291,
	SEL_TMU_0_0_MARK = 1292,
	SEL_TMU_0_1_MARK = 1293,
	SEL_TMU_1_0_MARK = 1294,
	SEL_TMU_1_1_MARK = 1295,
	SEL_SCIF3_0_MARK___6 = 1296,
	SEL_SCIF3_1_MARK___6 = 1297,
	SEL_SCIF1_0_MARK___7 = 1298,
	SEL_SCIF1_1_MARK___7 = 1299,
	SEL_SCU_0_MARK = 1300,
	SEL_SCU_1_MARK = 1301,
	SEL_RFSO_0_MARK___2 = 1302,
	SEL_RFSO_1_MARK___2 = 1303,
	PINMUX_MARK_END___8 = 1304,
};

enum ioctrl_regs___5 {
	TDSELCTRL___5 = 0,
};

enum {
	PINMUX_RESERVED___9 = 0,
	PINMUX_DATA_BEGIN___9 = 1,
	GP_0_0_DATA___9 = 2,
	GP_0_1_DATA___9 = 3,
	GP_0_2_DATA___9 = 4,
	GP_0_3_DATA___9 = 5,
	GP_0_4_DATA___9 = 6,
	GP_0_5_DATA___9 = 7,
	GP_0_6_DATA___9 = 8,
	GP_0_7_DATA___9 = 9,
	GP_0_8_DATA___9 = 10,
	GP_0_9_DATA___8 = 11,
	GP_0_10_DATA___8 = 12,
	GP_0_11_DATA___8 = 13,
	GP_0_12_DATA___8 = 14,
	GP_0_13_DATA___8 = 15,
	GP_0_14_DATA___8 = 16,
	GP_0_15_DATA___8 = 17,
	GP_0_16_DATA___4 = 18,
	GP_0_17_DATA___4 = 19,
	GP_0_18_DATA___3 = 20,
	GP_0_19_DATA___3 = 21,
	GP_0_20_DATA___3 = 22,
	GP_0_21_DATA___3 = 23,
	GP_0_22_DATA = 24,
	GP_0_23_DATA = 25,
	GP_0_24_DATA = 26,
	GP_0_25_DATA = 27,
	GP_0_26_DATA = 28,
	GP_0_27_DATA = 29,
	GP_1_0_DATA___9 = 30,
	GP_1_1_DATA___9 = 31,
	GP_1_2_DATA___9 = 32,
	GP_1_3_DATA___9 = 33,
	GP_1_4_DATA___9 = 34,
	GP_1_5_DATA___9 = 35,
	GP_1_6_DATA___9 = 36,
	GP_1_7_DATA___9 = 37,
	GP_1_8_DATA___9 = 38,
	GP_1_9_DATA___9 = 39,
	GP_1_10_DATA___9 = 40,
	GP_1_11_DATA___9 = 41,
	GP_1_12_DATA___9 = 42,
	GP_1_13_DATA___9 = 43,
	GP_1_14_DATA___9 = 44,
	GP_1_15_DATA___9 = 45,
	GP_1_16_DATA___9 = 46,
	GP_1_17_DATA___9 = 47,
	GP_1_18_DATA___9 = 48,
	GP_1_19_DATA___9 = 49,
	GP_1_20_DATA___9 = 50,
	GP_1_21_DATA___9 = 51,
	GP_1_22_DATA___9 = 52,
	GP_1_23_DATA___8 = 53,
	GP_1_24_DATA___8 = 54,
	GP_1_25_DATA___8 = 55,
	GP_1_26_DATA___8 = 56,
	GP_1_27_DATA___8 = 57,
	GP_1_28_DATA___5 = 58,
	GP_1_29_DATA___2 = 59,
	GP_1_30_DATA___2 = 60,
	GP_2_0_DATA___9 = 61,
	GP_2_1_DATA___9 = 62,
	GP_2_2_DATA___9 = 63,
	GP_2_3_DATA___9 = 64,
	GP_2_4_DATA___9 = 65,
	GP_2_5_DATA___9 = 66,
	GP_2_6_DATA___9 = 67,
	GP_2_7_DATA___9 = 68,
	GP_2_8_DATA___9 = 69,
	GP_2_9_DATA___9 = 70,
	GP_2_10_DATA___9 = 71,
	GP_2_11_DATA___9 = 72,
	GP_2_12_DATA___9 = 73,
	GP_2_13_DATA___9 = 74,
	GP_2_14_DATA___9 = 75,
	GP_2_15_DATA___5 = 76,
	GP_2_16_DATA___5 = 77,
	GP_2_17_DATA___4 = 78,
	GP_2_18_DATA___4 = 79,
	GP_2_19_DATA___4 = 80,
	GP_2_20_DATA___4 = 81,
	GP_2_21_DATA___4 = 82,
	GP_2_22_DATA___4 = 83,
	GP_2_23_DATA___4 = 84,
	GP_2_24_DATA___4 = 85,
	GP_3_0_DATA___9 = 86,
	GP_3_1_DATA___9 = 87,
	GP_3_2_DATA___9 = 88,
	GP_3_3_DATA___9 = 89,
	GP_3_4_DATA___9 = 90,
	GP_3_5_DATA___9 = 91,
	GP_3_6_DATA___9 = 92,
	GP_3_7_DATA___9 = 93,
	GP_3_8_DATA___9 = 94,
	GP_3_9_DATA___9 = 95,
	GP_3_10_DATA___8 = 96,
	GP_3_11_DATA___8 = 97,
	GP_3_12_DATA___8 = 98,
	GP_3_13_DATA___8 = 99,
	GP_3_14_DATA___8 = 100,
	GP_3_15_DATA___8 = 101,
	GP_3_16_DATA___3 = 102,
	GP_4_0_DATA___9 = 103,
	GP_4_1_DATA___9 = 104,
	GP_4_2_DATA___9 = 105,
	GP_4_3_DATA___9 = 106,
	GP_4_4_DATA___9 = 107,
	GP_4_5_DATA___9 = 108,
	GP_4_6_DATA___8 = 109,
	GP_4_7_DATA___8 = 110,
	GP_4_8_DATA___8 = 111,
	GP_4_9_DATA___8 = 112,
	GP_4_10_DATA___8 = 113,
	GP_4_11_DATA___7 = 114,
	GP_4_12_DATA___7 = 115,
	GP_4_13_DATA___7 = 116,
	GP_4_14_DATA___7 = 117,
	GP_4_15_DATA___7 = 118,
	GP_4_16_DATA___7 = 119,
	GP_4_17_DATA___7 = 120,
	GP_4_18_DATA___3 = 121,
	GP_4_19_DATA___3 = 122,
	GP_4_20_DATA___3 = 123,
	GP_4_21_DATA___3 = 124,
	GP_4_22_DATA___3 = 125,
	GP_4_23_DATA___3 = 126,
	GP_4_24_DATA___3 = 127,
	GP_4_25_DATA___2 = 128,
	GP_4_26_DATA___2 = 129,
	GP_5_0_DATA___9 = 130,
	GP_5_1_DATA___9 = 131,
	GP_5_2_DATA___9 = 132,
	GP_5_3_DATA___9 = 133,
	GP_5_4_DATA___9 = 134,
	GP_5_5_DATA___9 = 135,
	GP_5_6_DATA___9 = 136,
	GP_5_7_DATA___9 = 137,
	GP_5_8_DATA___9 = 138,
	GP_5_9_DATA___9 = 139,
	GP_5_10_DATA___9 = 140,
	GP_5_11_DATA___9 = 141,
	GP_5_12_DATA___9 = 142,
	GP_5_13_DATA___9 = 143,
	GP_5_14_DATA___9 = 144,
	GP_5_15_DATA___7 = 145,
	GP_5_16_DATA___7 = 146,
	GP_5_17_DATA___7 = 147,
	GP_5_18_DATA___7 = 148,
	GP_5_19_DATA___7 = 149,
	GP_5_20_DATA___6 = 150,
	GP_6_0_DATA___7 = 151,
	GP_6_1_DATA___7 = 152,
	GP_6_2_DATA___7 = 153,
	GP_6_3_DATA___7 = 154,
	GP_6_4_DATA___7 = 155,
	GP_6_5_DATA___7 = 156,
	GP_6_6_DATA___7 = 157,
	GP_6_7_DATA___7 = 158,
	GP_6_8_DATA___7 = 159,
	GP_6_9_DATA___7 = 160,
	GP_6_10_DATA___7 = 161,
	GP_6_11_DATA___7 = 162,
	GP_6_12_DATA___7 = 163,
	GP_6_13_DATA___7 = 164,
	GP_6_14_DATA___6 = 165,
	GP_6_15_DATA___6 = 166,
	GP_6_16_DATA___6 = 167,
	GP_6_17_DATA___6 = 168,
	GP_6_18_DATA___5 = 169,
	GP_6_19_DATA___5 = 170,
	GP_6_20_DATA___5 = 171,
	GP_7_0_DATA___5 = 172,
	GP_7_1_DATA___5 = 173,
	GP_7_2_DATA___5 = 174,
	GP_7_3_DATA___5 = 175,
	GP_7_4_DATA = 176,
	GP_7_5_DATA = 177,
	GP_7_6_DATA = 178,
	GP_7_7_DATA = 179,
	GP_7_8_DATA = 180,
	GP_7_9_DATA = 181,
	GP_7_10_DATA = 182,
	GP_7_11_DATA = 183,
	GP_7_12_DATA = 184,
	GP_7_13_DATA = 185,
	GP_7_14_DATA = 186,
	GP_7_15_DATA = 187,
	GP_7_16_DATA = 188,
	GP_7_17_DATA = 189,
	GP_7_18_DATA = 190,
	GP_7_19_DATA = 191,
	GP_7_20_DATA = 192,
	GP_8_0_DATA = 193,
	GP_8_1_DATA = 194,
	GP_8_2_DATA = 195,
	GP_8_3_DATA = 196,
	GP_8_4_DATA = 197,
	GP_8_5_DATA = 198,
	GP_8_6_DATA = 199,
	GP_8_7_DATA = 200,
	GP_8_8_DATA = 201,
	GP_8_9_DATA = 202,
	GP_8_10_DATA = 203,
	GP_8_11_DATA = 204,
	GP_8_12_DATA = 205,
	GP_8_13_DATA = 206,
	GP_8_14_DATA = 207,
	GP_8_15_DATA = 208,
	GP_8_16_DATA = 209,
	GP_8_17_DATA = 210,
	GP_8_18_DATA = 211,
	GP_8_19_DATA = 212,
	GP_8_20_DATA = 213,
	GP_9_0_DATA = 214,
	GP_9_1_DATA = 215,
	GP_9_2_DATA = 216,
	GP_9_3_DATA = 217,
	GP_9_4_DATA = 218,
	GP_9_5_DATA = 219,
	GP_9_6_DATA = 220,
	GP_9_7_DATA = 221,
	GP_9_8_DATA = 222,
	GP_9_9_DATA = 223,
	GP_9_10_DATA = 224,
	GP_9_11_DATA = 225,
	GP_9_12_DATA = 226,
	GP_9_13_DATA = 227,
	GP_9_14_DATA = 228,
	GP_9_15_DATA = 229,
	GP_9_16_DATA = 230,
	GP_9_17_DATA = 231,
	GP_9_18_DATA = 232,
	GP_9_19_DATA = 233,
	GP_9_20_DATA = 234,
	PINMUX_DATA_END___9 = 235,
	PINMUX_FUNCTION_BEGIN___9 = 236,
	GP_0_0_FN___9 = 237,
	GP_0_1_FN___9 = 238,
	GP_0_2_FN___9 = 239,
	GP_0_3_FN___9 = 240,
	GP_0_4_FN___9 = 241,
	GP_0_5_FN___9 = 242,
	GP_0_6_FN___9 = 243,
	GP_0_7_FN___9 = 244,
	GP_0_8_FN___9 = 245,
	GP_0_9_FN___8 = 246,
	GP_0_10_FN___8 = 247,
	GP_0_11_FN___8 = 248,
	GP_0_12_FN___8 = 249,
	GP_0_13_FN___8 = 250,
	GP_0_14_FN___8 = 251,
	GP_0_15_FN___8 = 252,
	GP_0_16_FN___4 = 253,
	GP_0_17_FN___4 = 254,
	GP_0_18_FN___3 = 255,
	GP_0_19_FN___3 = 256,
	GP_0_20_FN___3 = 257,
	GP_0_21_FN___3 = 258,
	GP_0_22_FN = 259,
	GP_0_23_FN = 260,
	GP_0_24_FN = 261,
	GP_0_25_FN = 262,
	GP_0_26_FN = 263,
	GP_0_27_FN = 264,
	GP_1_0_FN___9 = 265,
	GP_1_1_FN___9 = 266,
	GP_1_2_FN___9 = 267,
	GP_1_3_FN___9 = 268,
	GP_1_4_FN___9 = 269,
	GP_1_5_FN___9 = 270,
	GP_1_6_FN___9 = 271,
	GP_1_7_FN___9 = 272,
	GP_1_8_FN___9 = 273,
	GP_1_9_FN___9 = 274,
	GP_1_10_FN___9 = 275,
	GP_1_11_FN___9 = 276,
	GP_1_12_FN___9 = 277,
	GP_1_13_FN___9 = 278,
	GP_1_14_FN___9 = 279,
	GP_1_15_FN___9 = 280,
	GP_1_16_FN___9 = 281,
	GP_1_17_FN___9 = 282,
	GP_1_18_FN___9 = 283,
	GP_1_19_FN___9 = 284,
	GP_1_20_FN___9 = 285,
	GP_1_21_FN___9 = 286,
	GP_1_22_FN___9 = 287,
	GP_1_23_FN___8 = 288,
	GP_1_24_FN___8 = 289,
	GP_1_25_FN___8 = 290,
	GP_1_26_FN___8 = 291,
	GP_1_27_FN___8 = 292,
	GP_1_28_FN___5 = 293,
	GP_1_29_FN___2 = 294,
	GP_1_30_FN___2 = 295,
	GP_2_0_FN___9 = 296,
	GP_2_1_FN___9 = 297,
	GP_2_2_FN___9 = 298,
	GP_2_3_FN___9 = 299,
	GP_2_4_FN___9 = 300,
	GP_2_5_FN___9 = 301,
	GP_2_6_FN___9 = 302,
	GP_2_7_FN___9 = 303,
	GP_2_8_FN___9 = 304,
	GP_2_9_FN___9 = 305,
	GP_2_10_FN___9 = 306,
	GP_2_11_FN___9 = 307,
	GP_2_12_FN___9 = 308,
	GP_2_13_FN___9 = 309,
	GP_2_14_FN___9 = 310,
	GP_2_15_FN___5 = 311,
	GP_2_16_FN___5 = 312,
	GP_2_17_FN___4 = 313,
	GP_2_18_FN___4 = 314,
	GP_2_19_FN___4 = 315,
	GP_2_20_FN___4 = 316,
	GP_2_21_FN___4 = 317,
	GP_2_22_FN___4 = 318,
	GP_2_23_FN___4 = 319,
	GP_2_24_FN___4 = 320,
	GP_3_0_FN___9 = 321,
	GP_3_1_FN___9 = 322,
	GP_3_2_FN___9 = 323,
	GP_3_3_FN___9 = 324,
	GP_3_4_FN___9 = 325,
	GP_3_5_FN___9 = 326,
	GP_3_6_FN___9 = 327,
	GP_3_7_FN___9 = 328,
	GP_3_8_FN___9 = 329,
	GP_3_9_FN___9 = 330,
	GP_3_10_FN___8 = 331,
	GP_3_11_FN___8 = 332,
	GP_3_12_FN___8 = 333,
	GP_3_13_FN___8 = 334,
	GP_3_14_FN___8 = 335,
	GP_3_15_FN___8 = 336,
	GP_3_16_FN___3 = 337,
	GP_4_0_FN___9 = 338,
	GP_4_1_FN___9 = 339,
	GP_4_2_FN___9 = 340,
	GP_4_3_FN___9 = 341,
	GP_4_4_FN___9 = 342,
	GP_4_5_FN___9 = 343,
	GP_4_6_FN___8 = 344,
	GP_4_7_FN___8 = 345,
	GP_4_8_FN___8 = 346,
	GP_4_9_FN___8 = 347,
	GP_4_10_FN___8 = 348,
	GP_4_11_FN___7 = 349,
	GP_4_12_FN___7 = 350,
	GP_4_13_FN___7 = 351,
	GP_4_14_FN___7 = 352,
	GP_4_15_FN___7 = 353,
	GP_4_16_FN___7 = 354,
	GP_4_17_FN___7 = 355,
	GP_4_18_FN___3 = 356,
	GP_4_19_FN___3 = 357,
	GP_4_20_FN___3 = 358,
	GP_4_21_FN___3 = 359,
	GP_4_22_FN___3 = 360,
	GP_4_23_FN___3 = 361,
	GP_4_24_FN___3 = 362,
	GP_4_25_FN___2 = 363,
	GP_4_26_FN___2 = 364,
	GP_5_0_FN___9 = 365,
	GP_5_1_FN___9 = 366,
	GP_5_2_FN___9 = 367,
	GP_5_3_FN___9 = 368,
	GP_5_4_FN___9 = 369,
	GP_5_5_FN___9 = 370,
	GP_5_6_FN___9 = 371,
	GP_5_7_FN___9 = 372,
	GP_5_8_FN___9 = 373,
	GP_5_9_FN___9 = 374,
	GP_5_10_FN___9 = 375,
	GP_5_11_FN___9 = 376,
	GP_5_12_FN___9 = 377,
	GP_5_13_FN___9 = 378,
	GP_5_14_FN___9 = 379,
	GP_5_15_FN___7 = 380,
	GP_5_16_FN___7 = 381,
	GP_5_17_FN___7 = 382,
	GP_5_18_FN___7 = 383,
	GP_5_19_FN___7 = 384,
	GP_5_20_FN___6 = 385,
	GP_6_0_FN___7 = 386,
	GP_6_1_FN___7 = 387,
	GP_6_2_FN___7 = 388,
	GP_6_3_FN___7 = 389,
	GP_6_4_FN___7 = 390,
	GP_6_5_FN___7 = 391,
	GP_6_6_FN___7 = 392,
	GP_6_7_FN___7 = 393,
	GP_6_8_FN___7 = 394,
	GP_6_9_FN___7 = 395,
	GP_6_10_FN___7 = 396,
	GP_6_11_FN___7 = 397,
	GP_6_12_FN___7 = 398,
	GP_6_13_FN___7 = 399,
	GP_6_14_FN___6 = 400,
	GP_6_15_FN___6 = 401,
	GP_6_16_FN___6 = 402,
	GP_6_17_FN___6 = 403,
	GP_6_18_FN___5 = 404,
	GP_6_19_FN___5 = 405,
	GP_6_20_FN___5 = 406,
	GP_7_0_FN___5 = 407,
	GP_7_1_FN___5 = 408,
	GP_7_2_FN___5 = 409,
	GP_7_3_FN___5 = 410,
	GP_7_4_FN = 411,
	GP_7_5_FN = 412,
	GP_7_6_FN = 413,
	GP_7_7_FN = 414,
	GP_7_8_FN = 415,
	GP_7_9_FN = 416,
	GP_7_10_FN = 417,
	GP_7_11_FN = 418,
	GP_7_12_FN = 419,
	GP_7_13_FN = 420,
	GP_7_14_FN = 421,
	GP_7_15_FN = 422,
	GP_7_16_FN = 423,
	GP_7_17_FN = 424,
	GP_7_18_FN = 425,
	GP_7_19_FN = 426,
	GP_7_20_FN = 427,
	GP_8_0_FN = 428,
	GP_8_1_FN = 429,
	GP_8_2_FN = 430,
	GP_8_3_FN = 431,
	GP_8_4_FN = 432,
	GP_8_5_FN = 433,
	GP_8_6_FN = 434,
	GP_8_7_FN = 435,
	GP_8_8_FN = 436,
	GP_8_9_FN = 437,
	GP_8_10_FN = 438,
	GP_8_11_FN = 439,
	GP_8_12_FN = 440,
	GP_8_13_FN = 441,
	GP_8_14_FN = 442,
	GP_8_15_FN = 443,
	GP_8_16_FN = 444,
	GP_8_17_FN = 445,
	GP_8_18_FN = 446,
	GP_8_19_FN = 447,
	GP_8_20_FN = 448,
	GP_9_0_FN = 449,
	GP_9_1_FN = 450,
	GP_9_2_FN = 451,
	GP_9_3_FN = 452,
	GP_9_4_FN = 453,
	GP_9_5_FN = 454,
	GP_9_6_FN = 455,
	GP_9_7_FN = 456,
	GP_9_8_FN = 457,
	GP_9_9_FN = 458,
	GP_9_10_FN = 459,
	GP_9_11_FN = 460,
	GP_9_12_FN = 461,
	GP_9_13_FN = 462,
	GP_9_14_FN = 463,
	GP_9_15_FN = 464,
	GP_9_16_FN = 465,
	GP_9_17_FN = 466,
	GP_9_18_FN = 467,
	GP_9_19_FN = 468,
	GP_9_20_FN = 469,
	FN_MMC_D7___4 = 470,
	FN_MMC_D6___4 = 471,
	FN_AVS1___5 = 472,
	FN_MMC_D5___4 = 473,
	FN_AVS0 = 474,
	FN_MMC_D4___4 = 475,
	FN_TCLK2_A___9 = 476,
	FN_PCIE3_CLKREQ_N = 477,
	FN_MMC_SD_CLK = 478,
	FN_PCIE2_CLKREQ_N = 479,
	FN_MMC_SD_D3 = 480,
	FN_PCIE1_CLKREQ_N = 481,
	FN_MMC_SD_D2 = 482,
	FN_PCIE0_CLKREQ_N = 483,
	FN_MMC_SD_D1 = 484,
	FN_AVB2_AVTP_PPS = 485,
	FN_AVB3_AVTP_PPS = 486,
	FN_AVB4_AVTP_PPS = 487,
	FN_AVB5_AVTP_PPS = 488,
	FN_MMC_SD_D0 = 489,
	FN_AVB2_AVTP_CAPTURE = 490,
	FN_AVB3_AVTP_CAPTURE = 491,
	FN_AVB4_AVTP_CAPTURE = 492,
	FN_AVB5_AVTP_CAPTURE = 493,
	FN_MMC_SD_CMD = 494,
	FN_AVB2_AVTP_MATCH = 495,
	FN_AVB3_AVTP_MATCH = 496,
	FN_AVB4_AVTP_MATCH = 497,
	FN_AVB5_AVTP_MATCH = 498,
	FN_MMC_DS___2 = 499,
	FN_AVB2_LINK = 500,
	FN_AVB3_LINK = 501,
	FN_AVB4_LINK = 502,
	FN_AVB5_LINK = 503,
	FN_SD_CD = 504,
	FN_CANFD7_RX = 505,
	FN_AVB0_PHY_INT___3 = 506,
	FN_AVB1_PHY_INT = 507,
	FN_AVB2_PHY_INT = 508,
	FN_AVB3_PHY_INT = 509,
	FN_AVB4_PHY_INT = 510,
	FN_AVB5_PHY_INT = 511,
	FN_SD_WP = 512,
	FN_CANFD7_TX = 513,
	FN_AVB2_MAGIC = 514,
	FN_AVB3_MAGIC = 515,
	FN_AVB4_MAGIC = 516,
	FN_AVB5_MAGIC = 517,
	FN_RPC_INT_N___5 = 518,
	FN_CANFD6_RX = 519,
	FN_AVB2_MDC = 520,
	FN_AVB3_MDC = 521,
	FN_AVB4_MDC = 522,
	FN_AVB5_MDC = 523,
	FN_RPC_WP_N___3 = 524,
	FN_AVB2_MDIO = 525,
	FN_AVB3_MDIO = 526,
	FN_AVB4_MDIO = 527,
	FN_AVB5_MDIO = 528,
	FN_RPC_RESET_N___5 = 529,
	FN_AVB2_TXCREFCLK = 530,
	FN_AVB3_TXCREFCLK = 531,
	FN_AVB4_TXCREFCLK = 532,
	FN_AVB5_TXCREFCLK = 533,
	FN_QSPI1_SSL___5 = 534,
	FN_AVB2_TD3 = 535,
	FN_AVB3_TD3 = 536,
	FN_AVB4_TD3 = 537,
	FN_AVB5_TD3 = 538,
	FN_QSPI1_IO3___5 = 539,
	FN_AVB2_TD2 = 540,
	FN_AVB3_TD2 = 541,
	FN_AVB4_TD2 = 542,
	FN_AVB5_TD2 = 543,
	FN_QSPI1_IO2___5 = 544,
	FN_AVB2_TD1 = 545,
	FN_AVB3_TD1 = 546,
	FN_AVB4_TD1 = 547,
	FN_AVB5_TD1 = 548,
	FN_QSPI1_MISO_IO1___5 = 549,
	FN_AVB2_TD0 = 550,
	FN_AVB3_TD0 = 551,
	FN_AVB4_TD0 = 552,
	FN_AVB5_TD0 = 553,
	FN_QSPI1_MOSI_IO0___5 = 554,
	FN_AVB2_TXC = 555,
	FN_AVB3_TXC = 556,
	FN_AVB4_TXC = 557,
	FN_AVB5_TXC = 558,
	FN_QSPI1_SPCLK___5 = 559,
	FN_AVB2_TX_CTL = 560,
	FN_AVB3_TX_CTL = 561,
	FN_AVB4_TX_CTL = 562,
	FN_AVB5_TX_CTL = 563,
	FN_QSPI0_SSL___5 = 564,
	FN_AVB2_RD3 = 565,
	FN_AVB3_RD3 = 566,
	FN_AVB4_RD3 = 567,
	FN_AVB5_RD3 = 568,
	FN_QSPI0_IO3___5 = 569,
	FN_CANFD1_RX___9 = 570,
	FN_AVB2_RD2 = 571,
	FN_AVB3_RD2 = 572,
	FN_AVB4_RD2 = 573,
	FN_AVB5_RD2 = 574,
	FN_QSPI0_IO2___5 = 575,
	FN_CANFD1_TX___9 = 576,
	FN_AVB2_RD1 = 577,
	FN_AVB3_RD1 = 578,
	FN_AVB4_RD1 = 579,
	FN_AVB5_RD1 = 580,
	FN_QSPI0_MISO_IO1___5 = 581,
	FN_AVB2_RD0 = 582,
	FN_AVB3_RD0 = 583,
	FN_AVB4_RD0 = 584,
	FN_AVB5_RD0 = 585,
	FN_QSPI0_MOSI_IO0___5 = 586,
	FN_AVB2_RXC = 587,
	FN_AVB3_RXC = 588,
	FN_AVB4_RXC = 589,
	FN_AVB5_RXC = 590,
	FN_QSPI0_SPCLK___5 = 591,
	FN_CAN_CLK___7 = 592,
	FN_AVB2_RX_CTL = 593,
	FN_AVB3_RX_CTL = 594,
	FN_AVB4_RX_CTL = 595,
	FN_AVB5_RX_CTL = 596,
	FN_IP0SR1_3_0 = 597,
	FN_SCIF_CLK___2 = 598,
	FN_A0___8 = 599,
	FN_IP1SR1_3_0 = 600,
	FN_MSIOF0_SCK___9 = 601,
	FN_DU_DR4___9 = 602,
	FN_A8___8 = 603,
	FN_IP2SR1_3_0 = 604,
	FN_MSIOF1_SS1___5 = 605,
	FN_HCTS3_N___8 = 606,
	FN_RX3___3 = 607,
	FN_DU_DG6___9 = 608,
	FN_A16___8 = 609,
	FN_IP3SR1_3_0 = 610,
	FN_IRQ0___8 = 611,
	FN_DU_DOTCLKOUT___3 = 612,
	FN_A24___3 = 613,
	FN_IP0SR1_7_4 = 614,
	FN_HRX0___7 = 615,
	FN_RX0___7 = 616,
	FN_A1___8 = 617,
	FN_IP1SR1_7_4 = 618,
	FN_MSIOF0_SYNC___9 = 619,
	FN_DU_DR5___9 = 620,
	FN_A9___8 = 621,
	FN_IP2SR1_7_4 = 622,
	FN_MSIOF1_SS2___5 = 623,
	FN_HTX3___3 = 624,
	FN_TX3___3 = 625,
	FN_DU_DG7___9 = 626,
	FN_A17___8 = 627,
	FN_IP3SR1_7_4 = 628,
	FN_IRQ1___8 = 629,
	FN_DU_HSYNC___3 = 630,
	FN_A25___3 = 631,
	FN_IP0SR1_11_8 = 632,
	FN_HSCK0___7 = 633,
	FN_SCK0___7 = 634,
	FN_A2___8 = 635,
	FN_IP1SR1_11_8 = 636,
	FN_MSIOF0_SS1___9 = 637,
	FN_DU_DR6___9 = 638,
	FN_A10___8 = 639,
	FN_IP2SR1_11_8 = 640,
	FN_MSIOF2_RXD___4 = 641,
	FN_HSCK1___3 = 642,
	FN_SCK1___8 = 643,
	FN_DU_DB2___9 = 644,
	FN_A18___8 = 645,
	FN_IP3SR1_11_8 = 646,
	FN_IRQ2___8 = 647,
	FN_DU_VSYNC___3 = 648,
	FN_CS1_N_A26___3 = 649,
	FN_IP0SR1_15_12 = 650,
	FN_HRTS0_N___7 = 651,
	FN_RTS0_N___8 = 652,
	FN_A3___8 = 653,
	FN_IP1SR1_15_12 = 654,
	FN_MSIOF0_SS2___9 = 655,
	FN_DU_DR7___9 = 656,
	FN_A11___8 = 657,
	FN_IP2SR1_15_12 = 658,
	FN_MSIOF2_TXD___4 = 659,
	FN_HCTS1_N___3 = 660,
	FN_CTS1_N___9 = 661,
	FN_DU_DB3___9 = 662,
	FN_A19___8 = 663,
	FN_IP3SR1_15_12 = 664,
	FN_IRQ3___8 = 665,
	FN_DU_ODDF_DISP_CDE = 666,
	FN_CS0_N___8 = 667,
	FN_IP0SR1_19_16 = 668,
	FN_HCTS0_N___7 = 669,
	FN_CTS0_N___8 = 670,
	FN_A4___8 = 671,
	FN_IP1SR1_19_16 = 672,
	FN_MSIOF1_RXD___5 = 673,
	FN_DU_DG2___9 = 674,
	FN_A12___8 = 675,
	FN_IP2SR1_19_16 = 676,
	FN_MSIOF2_SCK___4 = 677,
	FN_HRTS1_N___3 = 678,
	FN_RTS1_N___9 = 679,
	FN_DU_DB4___9 = 680,
	FN_A20___2 = 681,
	FN_IP3SR1_19_16 = 682,
	FN_GP1_28 = 683,
	FN_D0___8 = 684,
	FN_IP0SR1_23_20 = 685,
	FN_HTX0___7 = 686,
	FN_TX0___7 = 687,
	FN_A5___8 = 688,
	FN_IP1SR1_23_20 = 689,
	FN_MSIOF1_TXD___5 = 690,
	FN_HRX3___3 = 691,
	FN_SCK3___7 = 692,
	FN_DU_DG3___9 = 693,
	FN_A13___8 = 694,
	FN_IP2SR1_23_20 = 695,
	FN_MSIOF2_SYNC___3 = 696,
	FN_HRX1___3 = 697,
	FN_RX1_A___8 = 698,
	FN_DU_DB5___9 = 699,
	FN_A21___2 = 700,
	FN_IP3SR1_23_20 = 701,
	FN_GP1_29 = 702,
	FN_D1___8 = 703,
	FN_IP0SR1_27_24 = 704,
	FN_MSIOF0_RXD___9 = 705,
	FN_DU_DR2___9 = 706,
	FN_A6___8 = 707,
	FN_IP1SR1_27_24 = 708,
	FN_MSIOF1_SCK___5 = 709,
	FN_HSCK3___7 = 710,
	FN_CTS3_N___7 = 711,
	FN_DU_DG4___9 = 712,
	FN_A14___8 = 713,
	FN_IP2SR1_27_24 = 714,
	FN_MSIOF2_SS1___4 = 715,
	FN_HTX1___3 = 716,
	FN_TX1_A___8 = 717,
	FN_DU_DB6___9 = 718,
	FN_A22___3 = 719,
	FN_IP3SR1_27_24 = 720,
	FN_GP1_30 = 721,
	FN_D2___8 = 722,
	FN_IP0SR1_31_28 = 723,
	FN_MSIOF0_TXD___9 = 724,
	FN_DU_DR3___9 = 725,
	FN_A7___8 = 726,
	FN_IP1SR1_31_28 = 727,
	FN_MSIOF1_SYNC___5 = 728,
	FN_HRTS3_N___8 = 729,
	FN_RTS3_N___7 = 730,
	FN_DU_DG5___9 = 731,
	FN_A15___8 = 732,
	FN_IP2SR1_31_28 = 733,
	FN_MSIOF2_SS2___4 = 734,
	FN_TCLK1_B___9 = 735,
	FN_DU_DB7___9 = 736,
	FN_A23___3 = 737,
	FN_IP3SR1_31_28 = 738,
	FN_IP0SR2_3_0 = 739,
	FN_IPC_CLKIN = 740,
	FN_IPC_CLKEN_IN = 741,
	FN_DU_DOTCLKIN = 742,
	FN_IP1SR2_3_0 = 743,
	FN_GP2_08 = 744,
	FN_HRX2___3 = 745,
	FN_MSIOF4_SS1 = 746,
	FN_RX4___3 = 747,
	FN_D9___8 = 748,
	FN_IP2SR2_3_0 = 749,
	FN_FXR_TXDA_A = 750,
	FN_MSIOF3_SS1___3 = 751,
	FN_IP0SR2_7_4 = 752,
	FN_IPC_CLKOUT = 753,
	FN_IPC_CLKEN_OUT = 754,
	FN_IP1SR2_7_4 = 755,
	FN_GP2_09 = 756,
	FN_HTX2___3 = 757,
	FN_MSIOF4_SS2 = 758,
	FN_TX4___3 = 759,
	FN_D10___8 = 760,
	FN_IP2SR2_7_4 = 761,
	FN_RXDA_EXTFXR_A = 762,
	FN_MSIOF3_SS2___3 = 763,
	FN_BS_N___8 = 764,
	FN_IP0SR2_11_8 = 765,
	FN_GP2_02 = 766,
	FN_D3___8 = 767,
	FN_IP1SR2_11_8 = 768,
	FN_GP2_10 = 769,
	FN_TCLK2_B___9 = 770,
	FN_MSIOF5_RXD = 771,
	FN_D11___8 = 772,
	FN_IP2SR2_11_8 = 773,
	FN_FXR_TXDB___3 = 774,
	FN_MSIOF3_RXD___3 = 775,
	FN_RD_N___8 = 776,
	FN_IP0SR2_15_12 = 777,
	FN_GP2_03 = 778,
	FN_D4___8 = 779,
	FN_IP1SR2_15_12 = 780,
	FN_GP2_11 = 781,
	FN_TCLK3___2 = 782,
	FN_MSIOF5_TXD = 783,
	FN_D12___8 = 784,
	FN_IP2SR2_15_12 = 785,
	FN_RXDB_EXTFXR___3 = 786,
	FN_MSIOF3_TXD___3 = 787,
	FN_WE0_N___8 = 788,
	FN_IP0SR2_19_16 = 789,
	FN_GP2_04 = 790,
	FN_MSIOF4_RXD = 791,
	FN_D5___8 = 792,
	FN_IP1SR2_19_16 = 793,
	FN_GP2_12 = 794,
	FN_TCLK4___2 = 795,
	FN_MSIOF5_SCK = 796,
	FN_D13___8 = 797,
	FN_IP2SR2_19_16 = 798,
	FN_CLK_EXTFXR___3 = 799,
	FN_MSIOF3_SCK___3 = 800,
	FN_WE1_N___8 = 801,
	FN_IP0SR2_23_20 = 802,
	FN_GP2_05 = 803,
	FN_HSCK2___3 = 804,
	FN_MSIOF4_TXD = 805,
	FN_SCK4___3 = 806,
	FN_D6___8 = 807,
	FN_IP1SR2_23_20 = 808,
	FN_GP2_13 = 809,
	FN_MSIOF5_SYNC = 810,
	FN_D14___8 = 811,
	FN_IP2SR2_23_20 = 812,
	FN_TPU0TO0___8 = 813,
	FN_MSIOF3_SYNC___3 = 814,
	FN_RD_WR_N___8 = 815,
	FN_IP0SR2_27_24 = 816,
	FN_GP2_06 = 817,
	FN_HCTS2_N___3 = 818,
	FN_MSIOF4_SCK = 819,
	FN_CTS4_N___3 = 820,
	FN_D7___8 = 821,
	FN_IP1SR2_27_24 = 822,
	FN_GP2_14 = 823,
	FN_IRQ4___8 = 824,
	FN_MSIOF5_SS1 = 825,
	FN_D15___8 = 826,
	FN_IP2SR2_27_24 = 827,
	FN_TPU0TO1___8 = 828,
	FN_CLKOUT___7 = 829,
	FN_IP0SR2_31_28 = 830,
	FN_GP2_07 = 831,
	FN_HRTS2_N___3 = 832,
	FN_MSIOF4_SYNC = 833,
	FN_RTS4_N___3 = 834,
	FN_D8___8 = 835,
	FN_IP1SR2_31_28 = 836,
	FN_GP2_15 = 837,
	FN_IRQ5___8 = 838,
	FN_MSIOF5_SS2 = 839,
	FN_CPG_CPCKOUT___2 = 840,
	FN_IP2SR2_31_28 = 841,
	FN_TCLK1_A___9 = 842,
	FN_EX_WAIT0___4 = 843,
	FN_IP0SR3_3_0 = 844,
	FN_IP1SR3_3_0 = 845,
	FN_CANFD3_RX = 846,
	FN_PWM3 = 847,
	FN_IP0SR3_7_4 = 848,
	FN_CANFD0_TX___3 = 849,
	FN_FXR_TXDA_B = 850,
	FN_TX1_B___8 = 851,
	FN_IP1SR3_7_4 = 852,
	FN_CANFD4_TX = 853,
	FN_PWM4 = 854,
	FN_FXR_CLKOUT1___2 = 855,
	FN_IP0SR3_11_8 = 856,
	FN_CANFD0_RX___3 = 857,
	FN_RXDA_EXTFXR_B = 858,
	FN_RX1_B___8 = 859,
	FN_IP1SR3_11_8 = 860,
	FN_CANFD4_RX = 861,
	FN_FXR_CLKOUT2___2 = 862,
	FN_IP0SR3_15_12 = 863,
	FN_IP1SR3_15_12 = 864,
	FN_CANFD5_TX = 865,
	FN_FXR_TXENA_N___3 = 866,
	FN_IP0SR3_19_16 = 867,
	FN_IP1SR3_19_16 = 868,
	FN_CANFD5_RX = 869,
	FN_FXR_TXENB_N___3 = 870,
	FN_IP0SR3_23_20 = 871,
	FN_CANFD2_TX = 872,
	FN_TPU0TO2___8 = 873,
	FN_PWM0___5 = 874,
	FN_IP1SR3_23_20 = 875,
	FN_CANFD6_TX = 876,
	FN_STPWT_EXTFXR = 877,
	FN_IP0SR3_27_24 = 878,
	FN_CANFD2_RX = 879,
	FN_TPU0TO3___8 = 880,
	FN_PWM1 = 881,
	FN_IP1SR3_27_24 = 882,
	FN_IP0SR3_31_28 = 883,
	FN_CANFD3_TX = 884,
	FN_PWM2 = 885,
	FN_IP1SR3_31_28 = 886,
	FN_IP0SR4_3_0 = 887,
	FN_AVB0_RX_CTL___3 = 888,
	FN_AVB0_MII_RX_DV = 889,
	FN_IP1SR4_3_0 = 890,
	FN_AVB0_TD0___3 = 891,
	FN_AVB0_MII_TD0 = 892,
	FN_IP2SR4_3_0 = 893,
	FN_IP0SR4_7_4 = 894,
	FN_AVB0_RXC___3 = 895,
	FN_AVB0_MII_RXC = 896,
	FN_IP1SR4_7_4 = 897,
	FN_AVB0_TD1___3 = 898,
	FN_AVB0_MII_TD1 = 899,
	FN_IP2SR4_7_4 = 900,
	FN_AVB0_LINK___3 = 901,
	FN_AVB0_MII_TX_ER = 902,
	FN_IP0SR4_11_8 = 903,
	FN_AVB0_RD0___3 = 904,
	FN_AVB0_MII_RD0 = 905,
	FN_IP1SR4_11_8 = 906,
	FN_AVB0_TD2___3 = 907,
	FN_AVB0_MII_TD2 = 908,
	FN_IP2SR4_11_8 = 909,
	FN_AVB0_AVTP_MATCH___2 = 910,
	FN_AVB0_MII_RX_ER = 911,
	FN_CC5_OSCOUT = 912,
	FN_IP0SR4_15_12 = 913,
	FN_AVB0_RD1___3 = 914,
	FN_AVB0_MII_RD1 = 915,
	FN_IP1SR4_15_12 = 916,
	FN_AVB0_TD3___3 = 917,
	FN_AVB0_MII_TD3 = 918,
	FN_IP2SR4_15_12 = 919,
	FN_AVB0_AVTP_CAPTURE___2 = 920,
	FN_AVB0_MII_CRS = 921,
	FN_IP0SR4_19_16 = 922,
	FN_AVB0_RD2___3 = 923,
	FN_AVB0_MII_RD2 = 924,
	FN_IP1SR4_19_16 = 925,
	FN_AVB0_TXCREFCLK___3 = 926,
	FN_IP2SR4_19_16 = 927,
	FN_AVB0_AVTP_PPS___2 = 928,
	FN_AVB0_MII_COL = 929,
	FN_IP0SR4_23_20 = 930,
	FN_AVB0_RD3___3 = 931,
	FN_AVB0_MII_RD3 = 932,
	FN_IP1SR4_23_20 = 933,
	FN_AVB0_MDIO___3 = 934,
	FN_IP2SR4_23_20 = 935,
	FN_IP0SR4_27_24 = 936,
	FN_AVB0_TX_CTL___3 = 937,
	FN_AVB0_MII_TX_EN = 938,
	FN_IP1SR4_27_24 = 939,
	FN_AVB0_MDC___3 = 940,
	FN_IP2SR4_27_24 = 941,
	FN_IP0SR4_31_28 = 942,
	FN_AVB0_TXC___3 = 943,
	FN_AVB0_MII_TXC = 944,
	FN_IP1SR4_31_28 = 945,
	FN_AVB0_MAGIC___3 = 946,
	FN_IP2SR4_31_28 = 947,
	FN_IP0SR5_3_0 = 948,
	FN_AVB1_RX_CTL = 949,
	FN_AVB1_MII_RX_DV = 950,
	FN_IP1SR5_3_0 = 951,
	FN_AVB1_TD0 = 952,
	FN_AVB1_MII_TD0 = 953,
	FN_IP2SR5_3_0 = 954,
	FN_IP0SR5_7_4 = 955,
	FN_AVB1_RXC = 956,
	FN_AVB1_MII_RXC = 957,
	FN_IP1SR5_7_4 = 958,
	FN_AVB1_TD1 = 959,
	FN_AVB1_MII_TD1 = 960,
	FN_IP2SR5_7_4 = 961,
	FN_AVB1_LINK = 962,
	FN_AVB1_MII_TX_ER = 963,
	FN_IP0SR5_11_8 = 964,
	FN_AVB1_RD0 = 965,
	FN_AVB1_MII_RD0 = 966,
	FN_IP1SR5_11_8 = 967,
	FN_AVB1_TD2 = 968,
	FN_AVB1_MII_TD2 = 969,
	FN_IP2SR5_11_8 = 970,
	FN_AVB1_AVTP_MATCH = 971,
	FN_AVB1_MII_RX_ER = 972,
	FN_IP0SR5_15_12 = 973,
	FN_AVB1_RD1 = 974,
	FN_AVB1_MII_RD1 = 975,
	FN_IP1SR5_15_12 = 976,
	FN_AVB1_TD3 = 977,
	FN_AVB1_MII_TD3 = 978,
	FN_IP2SR5_15_12 = 979,
	FN_AVB1_AVTP_CAPTURE = 980,
	FN_AVB1_MII_CRS = 981,
	FN_IP0SR5_19_16 = 982,
	FN_AVB1_RD2 = 983,
	FN_AVB1_MII_RD2 = 984,
	FN_IP1SR5_19_16 = 985,
	FN_AVB1_TXCREFCLK = 986,
	FN_IP2SR5_19_16 = 987,
	FN_AVB1_AVTP_PPS = 988,
	FN_AVB1_MII_COL = 989,
	FN_IP0SR5_23_20 = 990,
	FN_AVB1_RD3 = 991,
	FN_AVB1_MII_RD3 = 992,
	FN_IP1SR5_23_20 = 993,
	FN_AVB1_MDIO = 994,
	FN_IP2SR5_23_20 = 995,
	FN_IP0SR5_27_24 = 996,
	FN_AVB1_TX_CTL = 997,
	FN_AVB1_MII_TX_EN = 998,
	FN_IP1SR5_27_24 = 999,
	FN_AVB1_MDC = 1000,
	FN_IP2SR5_27_24 = 1001,
	FN_IP0SR5_31_28 = 1002,
	FN_AVB1_TXC = 1003,
	FN_AVB1_MII_TXC = 1004,
	FN_IP1SR5_31_28 = 1005,
	FN_AVB1_MAGIC = 1006,
	FN_IP2SR5_31_28 = 1007,
	FN_SEL_I2C6_0___6 = 1008,
	FN_SEL_I2C6_3 = 1009,
	FN_SEL_I2C5_0 = 1010,
	FN_SEL_I2C5_3 = 1011,
	FN_SEL_I2C4_0 = 1012,
	FN_SEL_I2C4_3 = 1013,
	FN_SEL_I2C3_0___3 = 1014,
	FN_SEL_I2C3_3 = 1015,
	FN_SEL_I2C2_0___7 = 1016,
	FN_SEL_I2C2_3___2 = 1017,
	FN_SEL_I2C1_0___6 = 1018,
	FN_SEL_I2C1_3___2 = 1019,
	FN_SEL_I2C0_0 = 1020,
	FN_SEL_I2C0_3 = 1021,
	PINMUX_FUNCTION_END___9 = 1022,
	PINMUX_MARK_BEGIN___9 = 1023,
	MMC_D7_MARK___4 = 1024,
	MMC_D6_MARK___4 = 1025,
	AVS1_MARK___5 = 1026,
	MMC_D5_MARK___4 = 1027,
	AVS0_MARK = 1028,
	MMC_D4_MARK___4 = 1029,
	TCLK2_A_MARK___9 = 1030,
	PCIE3_CLKREQ_N_MARK = 1031,
	MMC_SD_CLK_MARK = 1032,
	PCIE2_CLKREQ_N_MARK = 1033,
	MMC_SD_D3_MARK = 1034,
	PCIE1_CLKREQ_N_MARK = 1035,
	MMC_SD_D2_MARK = 1036,
	PCIE0_CLKREQ_N_MARK = 1037,
	MMC_SD_D1_MARK = 1038,
	AVB2_AVTP_PPS_MARK = 1039,
	AVB3_AVTP_PPS_MARK = 1040,
	AVB4_AVTP_PPS_MARK = 1041,
	AVB5_AVTP_PPS_MARK = 1042,
	MMC_SD_D0_MARK = 1043,
	AVB2_AVTP_CAPTURE_MARK = 1044,
	AVB3_AVTP_CAPTURE_MARK = 1045,
	AVB4_AVTP_CAPTURE_MARK = 1046,
	AVB5_AVTP_CAPTURE_MARK = 1047,
	MMC_SD_CMD_MARK = 1048,
	AVB2_AVTP_MATCH_MARK = 1049,
	AVB3_AVTP_MATCH_MARK = 1050,
	AVB4_AVTP_MATCH_MARK = 1051,
	AVB5_AVTP_MATCH_MARK = 1052,
	MMC_DS_MARK___2 = 1053,
	AVB2_LINK_MARK = 1054,
	AVB3_LINK_MARK = 1055,
	AVB4_LINK_MARK = 1056,
	AVB5_LINK_MARK = 1057,
	SD_CD_MARK = 1058,
	CANFD7_RX_MARK = 1059,
	AVB0_PHY_INT_MARK___3 = 1060,
	AVB1_PHY_INT_MARK = 1061,
	AVB2_PHY_INT_MARK = 1062,
	AVB3_PHY_INT_MARK = 1063,
	AVB4_PHY_INT_MARK = 1064,
	AVB5_PHY_INT_MARK = 1065,
	SD_WP_MARK = 1066,
	CANFD7_TX_MARK = 1067,
	AVB2_MAGIC_MARK = 1068,
	AVB3_MAGIC_MARK = 1069,
	AVB4_MAGIC_MARK = 1070,
	AVB5_MAGIC_MARK = 1071,
	RPC_INT_N_MARK___5 = 1072,
	CANFD6_RX_MARK = 1073,
	AVB2_MDC_MARK = 1074,
	AVB3_MDC_MARK = 1075,
	AVB4_MDC_MARK = 1076,
	AVB5_MDC_MARK = 1077,
	RPC_WP_N_MARK___3 = 1078,
	AVB2_MDIO_MARK = 1079,
	AVB3_MDIO_MARK = 1080,
	AVB4_MDIO_MARK = 1081,
	AVB5_MDIO_MARK = 1082,
	RPC_RESET_N_MARK___5 = 1083,
	AVB2_TXCREFCLK_MARK = 1084,
	AVB3_TXCREFCLK_MARK = 1085,
	AVB4_TXCREFCLK_MARK = 1086,
	AVB5_TXCREFCLK_MARK = 1087,
	QSPI1_SSL_MARK___9 = 1088,
	AVB2_TD3_MARK = 1089,
	AVB3_TD3_MARK = 1090,
	AVB4_TD3_MARK = 1091,
	AVB5_TD3_MARK = 1092,
	QSPI1_IO3_MARK___9 = 1093,
	AVB2_TD2_MARK = 1094,
	AVB3_TD2_MARK = 1095,
	AVB4_TD2_MARK = 1096,
	AVB5_TD2_MARK = 1097,
	QSPI1_IO2_MARK___9 = 1098,
	AVB2_TD1_MARK = 1099,
	AVB3_TD1_MARK = 1100,
	AVB4_TD1_MARK = 1101,
	AVB5_TD1_MARK = 1102,
	QSPI1_MISO_IO1_MARK___9 = 1103,
	AVB2_TD0_MARK = 1104,
	AVB3_TD0_MARK = 1105,
	AVB4_TD0_MARK = 1106,
	AVB5_TD0_MARK = 1107,
	QSPI1_MOSI_IO0_MARK___9 = 1108,
	AVB2_TXC_MARK = 1109,
	AVB3_TXC_MARK = 1110,
	AVB4_TXC_MARK = 1111,
	AVB5_TXC_MARK = 1112,
	QSPI1_SPCLK_MARK___9 = 1113,
	AVB2_TX_CTL_MARK = 1114,
	AVB3_TX_CTL_MARK = 1115,
	AVB4_TX_CTL_MARK = 1116,
	AVB5_TX_CTL_MARK = 1117,
	QSPI0_SSL_MARK___9 = 1118,
	AVB2_RD3_MARK = 1119,
	AVB3_RD3_MARK = 1120,
	AVB4_RD3_MARK = 1121,
	AVB5_RD3_MARK = 1122,
	QSPI0_IO3_MARK___9 = 1123,
	CANFD1_RX_MARK___9 = 1124,
	AVB2_RD2_MARK = 1125,
	AVB3_RD2_MARK = 1126,
	AVB4_RD2_MARK = 1127,
	AVB5_RD2_MARK = 1128,
	QSPI0_IO2_MARK___9 = 1129,
	CANFD1_TX_MARK___9 = 1130,
	AVB2_RD1_MARK = 1131,
	AVB3_RD1_MARK = 1132,
	AVB4_RD1_MARK = 1133,
	AVB5_RD1_MARK = 1134,
	QSPI0_MISO_IO1_MARK___9 = 1135,
	AVB2_RD0_MARK = 1136,
	AVB3_RD0_MARK = 1137,
	AVB4_RD0_MARK = 1138,
	AVB5_RD0_MARK = 1139,
	QSPI0_MOSI_IO0_MARK___9 = 1140,
	AVB2_RXC_MARK = 1141,
	AVB3_RXC_MARK = 1142,
	AVB4_RXC_MARK = 1143,
	AVB5_RXC_MARK = 1144,
	QSPI0_SPCLK_MARK___9 = 1145,
	CAN_CLK_MARK___7 = 1146,
	AVB2_RX_CTL_MARK = 1147,
	AVB3_RX_CTL_MARK = 1148,
	AVB4_RX_CTL_MARK = 1149,
	AVB5_RX_CTL_MARK = 1150,
	IP0SR1_3_0_MARK = 1151,
	SCIF_CLK_MARK___2 = 1152,
	A0_MARK___8 = 1153,
	IP1SR1_3_0_MARK = 1154,
	MSIOF0_SCK_MARK___9 = 1155,
	DU_DR4_MARK___9 = 1156,
	A8_MARK___8 = 1157,
	IP2SR1_3_0_MARK = 1158,
	MSIOF1_SS1_MARK___5 = 1159,
	HCTS3_N_MARK___8 = 1160,
	RX3_MARK___3 = 1161,
	DU_DG6_MARK___9 = 1162,
	A16_MARK___8 = 1163,
	IP3SR1_3_0_MARK = 1164,
	IRQ0_MARK___8 = 1165,
	DU_DOTCLKOUT_MARK___3 = 1166,
	A24_MARK___3 = 1167,
	IP0SR1_7_4_MARK = 1168,
	HRX0_MARK___7 = 1169,
	RX0_MARK___7 = 1170,
	A1_MARK___8 = 1171,
	IP1SR1_7_4_MARK = 1172,
	MSIOF0_SYNC_MARK___9 = 1173,
	DU_DR5_MARK___9 = 1174,
	A9_MARK___8 = 1175,
	IP2SR1_7_4_MARK = 1176,
	MSIOF1_SS2_MARK___5 = 1177,
	HTX3_MARK___3 = 1178,
	TX3_MARK___3 = 1179,
	DU_DG7_MARK___9 = 1180,
	A17_MARK___8 = 1181,
	IP3SR1_7_4_MARK = 1182,
	IRQ1_MARK___8 = 1183,
	DU_HSYNC_MARK___3 = 1184,
	A25_MARK___3 = 1185,
	IP0SR1_11_8_MARK = 1186,
	HSCK0_MARK___7 = 1187,
	SCK0_MARK___7 = 1188,
	A2_MARK___8 = 1189,
	IP1SR1_11_8_MARK = 1190,
	MSIOF0_SS1_MARK___9 = 1191,
	DU_DR6_MARK___9 = 1192,
	A10_MARK___8 = 1193,
	IP2SR1_11_8_MARK = 1194,
	MSIOF2_RXD_MARK___4 = 1195,
	HSCK1_MARK___3 = 1196,
	SCK1_MARK___8 = 1197,
	DU_DB2_MARK___9 = 1198,
	A18_MARK___8 = 1199,
	IP3SR1_11_8_MARK = 1200,
	IRQ2_MARK___8 = 1201,
	DU_VSYNC_MARK___3 = 1202,
	CS1_N_A26_MARK___3 = 1203,
	IP0SR1_15_12_MARK = 1204,
	HRTS0_N_MARK___7 = 1205,
	RTS0_N_MARK___8 = 1206,
	A3_MARK___8 = 1207,
	IP1SR1_15_12_MARK = 1208,
	MSIOF0_SS2_MARK___9 = 1209,
	DU_DR7_MARK___9 = 1210,
	A11_MARK___8 = 1211,
	IP2SR1_15_12_MARK = 1212,
	MSIOF2_TXD_MARK___4 = 1213,
	HCTS1_N_MARK___3 = 1214,
	CTS1_N_MARK___9 = 1215,
	DU_DB3_MARK___9 = 1216,
	A19_MARK___8 = 1217,
	IP3SR1_15_12_MARK = 1218,
	IRQ3_MARK___8 = 1219,
	DU_ODDF_DISP_CDE_MARK = 1220,
	CS0_N_MARK___8 = 1221,
	IP0SR1_19_16_MARK = 1222,
	HCTS0_N_MARK___7 = 1223,
	CTS0_N_MARK___8 = 1224,
	A4_MARK___8 = 1225,
	IP1SR1_19_16_MARK = 1226,
	MSIOF1_RXD_MARK___5 = 1227,
	DU_DG2_MARK___9 = 1228,
	A12_MARK___8 = 1229,
	IP2SR1_19_16_MARK = 1230,
	MSIOF2_SCK_MARK___4 = 1231,
	HRTS1_N_MARK___3 = 1232,
	RTS1_N_MARK___9 = 1233,
	DU_DB4_MARK___9 = 1234,
	A20_MARK___2 = 1235,
	IP3SR1_19_16_MARK = 1236,
	GP1_28_MARK = 1237,
	D0_MARK___8 = 1238,
	IP0SR1_23_20_MARK = 1239,
	HTX0_MARK___7 = 1240,
	TX0_MARK___7 = 1241,
	A5_MARK___8 = 1242,
	IP1SR1_23_20_MARK = 1243,
	MSIOF1_TXD_MARK___5 = 1244,
	HRX3_MARK___3 = 1245,
	SCK3_MARK___7 = 1246,
	DU_DG3_MARK___9 = 1247,
	A13_MARK___8 = 1248,
	IP2SR1_23_20_MARK = 1249,
	MSIOF2_SYNC_MARK___3 = 1250,
	HRX1_MARK___3 = 1251,
	RX1_A_MARK___8 = 1252,
	DU_DB5_MARK___9 = 1253,
	A21_MARK___2 = 1254,
	IP3SR1_23_20_MARK = 1255,
	GP1_29_MARK = 1256,
	D1_MARK___8 = 1257,
	IP0SR1_27_24_MARK = 1258,
	MSIOF0_RXD_MARK___9 = 1259,
	DU_DR2_MARK___9 = 1260,
	A6_MARK___8 = 1261,
	IP1SR1_27_24_MARK = 1262,
	MSIOF1_SCK_MARK___5 = 1263,
	HSCK3_MARK___7 = 1264,
	CTS3_N_MARK___7 = 1265,
	DU_DG4_MARK___9 = 1266,
	A14_MARK___8 = 1267,
	IP2SR1_27_24_MARK = 1268,
	MSIOF2_SS1_MARK___4 = 1269,
	HTX1_MARK___3 = 1270,
	TX1_A_MARK___8 = 1271,
	DU_DB6_MARK___9 = 1272,
	A22_MARK___3 = 1273,
	IP3SR1_27_24_MARK = 1274,
	GP1_30_MARK = 1275,
	D2_MARK___8 = 1276,
	IP0SR1_31_28_MARK = 1277,
	MSIOF0_TXD_MARK___9 = 1278,
	DU_DR3_MARK___9 = 1279,
	A7_MARK___8 = 1280,
	IP1SR1_31_28_MARK = 1281,
	MSIOF1_SYNC_MARK___5 = 1282,
	HRTS3_N_MARK___8 = 1283,
	RTS3_N_MARK___7 = 1284,
	DU_DG5_MARK___9 = 1285,
	A15_MARK___8 = 1286,
	IP2SR1_31_28_MARK = 1287,
	MSIOF2_SS2_MARK___4 = 1288,
	TCLK1_B_MARK___9 = 1289,
	DU_DB7_MARK___9 = 1290,
	A23_MARK___3 = 1291,
	IP3SR1_31_28_MARK = 1292,
	IP0SR2_3_0_MARK = 1293,
	IPC_CLKIN_MARK = 1294,
	IPC_CLKEN_IN_MARK = 1295,
	DU_DOTCLKIN_MARK = 1296,
	IP1SR2_3_0_MARK = 1297,
	GP2_08_MARK = 1298,
	HRX2_MARK___3 = 1299,
	MSIOF4_SS1_MARK = 1300,
	RX4_MARK___3 = 1301,
	D9_MARK___8 = 1302,
	IP2SR2_3_0_MARK = 1303,
	FXR_TXDA_A_MARK = 1304,
	MSIOF3_SS1_MARK___3 = 1305,
	IP0SR2_7_4_MARK = 1306,
	IPC_CLKOUT_MARK = 1307,
	IPC_CLKEN_OUT_MARK = 1308,
	IP1SR2_7_4_MARK = 1309,
	GP2_09_MARK = 1310,
	HTX2_MARK___3 = 1311,
	MSIOF4_SS2_MARK = 1312,
	TX4_MARK___3 = 1313,
	D10_MARK___8 = 1314,
	IP2SR2_7_4_MARK = 1315,
	RXDA_EXTFXR_A_MARK = 1316,
	MSIOF3_SS2_MARK___3 = 1317,
	BS_N_MARK___8 = 1318,
	IP0SR2_11_8_MARK = 1319,
	GP2_02_MARK = 1320,
	D3_MARK___8 = 1321,
	IP1SR2_11_8_MARK = 1322,
	GP2_10_MARK = 1323,
	TCLK2_B_MARK___9 = 1324,
	MSIOF5_RXD_MARK = 1325,
	D11_MARK___8 = 1326,
	IP2SR2_11_8_MARK = 1327,
	FXR_TXDB_MARK___3 = 1328,
	MSIOF3_RXD_MARK___3 = 1329,
	RD_N_MARK___8 = 1330,
	IP0SR2_15_12_MARK = 1331,
	GP2_03_MARK = 1332,
	D4_MARK___8 = 1333,
	IP1SR2_15_12_MARK = 1334,
	GP2_11_MARK = 1335,
	TCLK3_MARK___2 = 1336,
	MSIOF5_TXD_MARK = 1337,
	D12_MARK___8 = 1338,
	IP2SR2_15_12_MARK = 1339,
	RXDB_EXTFXR_MARK___3 = 1340,
	MSIOF3_TXD_MARK___3 = 1341,
	WE0_N_MARK___8 = 1342,
	IP0SR2_19_16_MARK = 1343,
	GP2_04_MARK = 1344,
	MSIOF4_RXD_MARK = 1345,
	D5_MARK___8 = 1346,
	IP1SR2_19_16_MARK = 1347,
	GP2_12_MARK = 1348,
	TCLK4_MARK___2 = 1349,
	MSIOF5_SCK_MARK = 1350,
	D13_MARK___8 = 1351,
	IP2SR2_19_16_MARK = 1352,
	CLK_EXTFXR_MARK___3 = 1353,
	MSIOF3_SCK_MARK___3 = 1354,
	WE1_N_MARK___8 = 1355,
	IP0SR2_23_20_MARK = 1356,
	GP2_05_MARK = 1357,
	HSCK2_MARK___3 = 1358,
	MSIOF4_TXD_MARK = 1359,
	SCK4_MARK___3 = 1360,
	D6_MARK___8 = 1361,
	IP1SR2_23_20_MARK = 1362,
	GP2_13_MARK = 1363,
	MSIOF5_SYNC_MARK = 1364,
	D14_MARK___8 = 1365,
	IP2SR2_23_20_MARK = 1366,
	TPU0TO0_MARK___8 = 1367,
	MSIOF3_SYNC_MARK___3 = 1368,
	RD_WR_N_MARK___8 = 1369,
	IP0SR2_27_24_MARK = 1370,
	GP2_06_MARK = 1371,
	HCTS2_N_MARK___3 = 1372,
	MSIOF4_SCK_MARK = 1373,
	CTS4_N_MARK___3 = 1374,
	D7_MARK___8 = 1375,
	IP1SR2_27_24_MARK = 1376,
	GP2_14_MARK = 1377,
	IRQ4_MARK___8 = 1378,
	MSIOF5_SS1_MARK = 1379,
	D15_MARK___8 = 1380,
	IP2SR2_27_24_MARK = 1381,
	TPU0TO1_MARK___8 = 1382,
	CLKOUT_MARK___8 = 1383,
	IP0SR2_31_28_MARK = 1384,
	GP2_07_MARK = 1385,
	HRTS2_N_MARK___3 = 1386,
	MSIOF4_SYNC_MARK = 1387,
	RTS4_N_MARK___3 = 1388,
	D8_MARK___8 = 1389,
	IP1SR2_31_28_MARK = 1390,
	GP2_15_MARK = 1391,
	IRQ5_MARK___8 = 1392,
	MSIOF5_SS2_MARK = 1393,
	CPG_CPCKOUT_MARK___2 = 1394,
	IP2SR2_31_28_MARK = 1395,
	TCLK1_A_MARK___9 = 1396,
	EX_WAIT0_MARK___4 = 1397,
	IP0SR3_3_0_MARK = 1398,
	IP1SR3_3_0_MARK = 1399,
	CANFD3_RX_MARK = 1400,
	PWM3_MARK = 1401,
	IP0SR3_7_4_MARK = 1402,
	CANFD0_TX_MARK___3 = 1403,
	FXR_TXDA_B_MARK = 1404,
	TX1_B_MARK___8 = 1405,
	IP1SR3_7_4_MARK = 1406,
	CANFD4_TX_MARK = 1407,
	PWM4_MARK = 1408,
	FXR_CLKOUT1_MARK___2 = 1409,
	IP0SR3_11_8_MARK = 1410,
	CANFD0_RX_MARK___3 = 1411,
	RXDA_EXTFXR_B_MARK = 1412,
	RX1_B_MARK___8 = 1413,
	IP1SR3_11_8_MARK = 1414,
	CANFD4_RX_MARK = 1415,
	FXR_CLKOUT2_MARK___2 = 1416,
	IP0SR3_15_12_MARK = 1417,
	IP1SR3_15_12_MARK = 1418,
	CANFD5_TX_MARK = 1419,
	FXR_TXENA_N_MARK___3 = 1420,
	IP0SR3_19_16_MARK = 1421,
	IP1SR3_19_16_MARK = 1422,
	CANFD5_RX_MARK = 1423,
	FXR_TXENB_N_MARK___3 = 1424,
	IP0SR3_23_20_MARK = 1425,
	CANFD2_TX_MARK = 1426,
	TPU0TO2_MARK___8 = 1427,
	PWM0_MARK___5 = 1428,
	IP1SR3_23_20_MARK = 1429,
	CANFD6_TX_MARK = 1430,
	STPWT_EXTFXR_MARK = 1431,
	IP0SR3_27_24_MARK = 1432,
	CANFD2_RX_MARK = 1433,
	TPU0TO3_MARK___8 = 1434,
	PWM1_MARK = 1435,
	IP1SR3_27_24_MARK = 1436,
	IP0SR3_31_28_MARK = 1437,
	CANFD3_TX_MARK = 1438,
	PWM2_MARK = 1439,
	IP1SR3_31_28_MARK = 1440,
	IP0SR4_3_0_MARK = 1441,
	AVB0_RX_CTL_MARK___3 = 1442,
	AVB0_MII_RX_DV_MARK = 1443,
	IP1SR4_3_0_MARK = 1444,
	AVB0_TD0_MARK___3 = 1445,
	AVB0_MII_TD0_MARK = 1446,
	IP2SR4_3_0_MARK = 1447,
	IP0SR4_7_4_MARK = 1448,
	AVB0_RXC_MARK___3 = 1449,
	AVB0_MII_RXC_MARK = 1450,
	IP1SR4_7_4_MARK = 1451,
	AVB0_TD1_MARK___3 = 1452,
	AVB0_MII_TD1_MARK = 1453,
	IP2SR4_7_4_MARK = 1454,
	AVB0_LINK_MARK___3 = 1455,
	AVB0_MII_TX_ER_MARK = 1456,
	IP0SR4_11_8_MARK = 1457,
	AVB0_RD0_MARK___3 = 1458,
	AVB0_MII_RD0_MARK = 1459,
	IP1SR4_11_8_MARK = 1460,
	AVB0_TD2_MARK___3 = 1461,
	AVB0_MII_TD2_MARK = 1462,
	IP2SR4_11_8_MARK = 1463,
	AVB0_AVTP_MATCH_MARK___2 = 1464,
	AVB0_MII_RX_ER_MARK = 1465,
	CC5_OSCOUT_MARK = 1466,
	IP0SR4_15_12_MARK = 1467,
	AVB0_RD1_MARK___3 = 1468,
	AVB0_MII_RD1_MARK = 1469,
	IP1SR4_15_12_MARK = 1470,
	AVB0_TD3_MARK___3 = 1471,
	AVB0_MII_TD3_MARK = 1472,
	IP2SR4_15_12_MARK = 1473,
	AVB0_AVTP_CAPTURE_MARK___2 = 1474,
	AVB0_MII_CRS_MARK = 1475,
	IP0SR4_19_16_MARK = 1476,
	AVB0_RD2_MARK___3 = 1477,
	AVB0_MII_RD2_MARK = 1478,
	IP1SR4_19_16_MARK = 1479,
	AVB0_TXCREFCLK_MARK___3 = 1480,
	IP2SR4_19_16_MARK = 1481,
	AVB0_AVTP_PPS_MARK___2 = 1482,
	AVB0_MII_COL_MARK = 1483,
	IP0SR4_23_20_MARK = 1484,
	AVB0_RD3_MARK___3 = 1485,
	AVB0_MII_RD3_MARK = 1486,
	IP1SR4_23_20_MARK = 1487,
	AVB0_MDIO_MARK___3 = 1488,
	IP2SR4_23_20_MARK = 1489,
	IP0SR4_27_24_MARK = 1490,
	AVB0_TX_CTL_MARK___3 = 1491,
	AVB0_MII_TX_EN_MARK = 1492,
	IP1SR4_27_24_MARK = 1493,
	AVB0_MDC_MARK___3 = 1494,
	IP2SR4_27_24_MARK = 1495,
	IP0SR4_31_28_MARK = 1496,
	AVB0_TXC_MARK___3 = 1497,
	AVB0_MII_TXC_MARK = 1498,
	IP1SR4_31_28_MARK = 1499,
	AVB0_MAGIC_MARK___3 = 1500,
	IP2SR4_31_28_MARK = 1501,
	IP0SR5_3_0_MARK = 1502,
	AVB1_RX_CTL_MARK = 1503,
	AVB1_MII_RX_DV_MARK = 1504,
	IP1SR5_3_0_MARK = 1505,
	AVB1_TD0_MARK = 1506,
	AVB1_MII_TD0_MARK = 1507,
	IP2SR5_3_0_MARK = 1508,
	IP0SR5_7_4_MARK = 1509,
	AVB1_RXC_MARK = 1510,
	AVB1_MII_RXC_MARK = 1511,
	IP1SR5_7_4_MARK = 1512,
	AVB1_TD1_MARK = 1513,
	AVB1_MII_TD1_MARK = 1514,
	IP2SR5_7_4_MARK = 1515,
	AVB1_LINK_MARK = 1516,
	AVB1_MII_TX_ER_MARK = 1517,
	IP0SR5_11_8_MARK = 1518,
	AVB1_RD0_MARK = 1519,
	AVB1_MII_RD0_MARK = 1520,
	IP1SR5_11_8_MARK = 1521,
	AVB1_TD2_MARK = 1522,
	AVB1_MII_TD2_MARK = 1523,
	IP2SR5_11_8_MARK = 1524,
	AVB1_AVTP_MATCH_MARK = 1525,
	AVB1_MII_RX_ER_MARK = 1526,
	IP0SR5_15_12_MARK = 1527,
	AVB1_RD1_MARK = 1528,
	AVB1_MII_RD1_MARK = 1529,
	IP1SR5_15_12_MARK = 1530,
	AVB1_TD3_MARK = 1531,
	AVB1_MII_TD3_MARK = 1532,
	IP2SR5_15_12_MARK = 1533,
	AVB1_AVTP_CAPTURE_MARK = 1534,
	AVB1_MII_CRS_MARK = 1535,
	IP0SR5_19_16_MARK = 1536,
	AVB1_RD2_MARK = 1537,
	AVB1_MII_RD2_MARK = 1538,
	IP1SR5_19_16_MARK = 1539,
	AVB1_TXCREFCLK_MARK = 1540,
	IP2SR5_19_16_MARK = 1541,
	AVB1_AVTP_PPS_MARK = 1542,
	AVB1_MII_COL_MARK = 1543,
	IP0SR5_23_20_MARK = 1544,
	AVB1_RD3_MARK = 1545,
	AVB1_MII_RD3_MARK = 1546,
	IP1SR5_23_20_MARK = 1547,
	AVB1_MDIO_MARK = 1548,
	IP2SR5_23_20_MARK = 1549,
	IP0SR5_27_24_MARK = 1550,
	AVB1_TX_CTL_MARK = 1551,
	AVB1_MII_TX_EN_MARK = 1552,
	IP1SR5_27_24_MARK = 1553,
	AVB1_MDC_MARK = 1554,
	IP2SR5_27_24_MARK = 1555,
	IP0SR5_31_28_MARK = 1556,
	AVB1_TXC_MARK = 1557,
	AVB1_MII_TXC_MARK = 1558,
	IP1SR5_31_28_MARK = 1559,
	AVB1_MAGIC_MARK = 1560,
	IP2SR5_31_28_MARK = 1561,
	SEL_I2C6_0_MARK___6 = 1562,
	SEL_I2C6_3_MARK = 1563,
	SEL_I2C5_0_MARK = 1564,
	SEL_I2C5_3_MARK = 1565,
	SEL_I2C4_0_MARK = 1566,
	SEL_I2C4_3_MARK = 1567,
	SEL_I2C3_0_MARK___3 = 1568,
	SEL_I2C3_3_MARK = 1569,
	SEL_I2C2_0_MARK___7 = 1570,
	SEL_I2C2_3_MARK___2 = 1571,
	SEL_I2C1_0_MARK___6 = 1572,
	SEL_I2C1_3_MARK___2 = 1573,
	SEL_I2C0_0_MARK = 1574,
	SEL_I2C0_3_MARK = 1575,
	SCL0_MARK___8 = 1576,
	SDA0_MARK___8 = 1577,
	SCL1_MARK___4 = 1578,
	SDA1_MARK___4 = 1579,
	SCL2_MARK___3 = 1580,
	SDA2_MARK___3 = 1581,
	SCL3_MARK___6 = 1582,
	SDA3_MARK___6 = 1583,
	SCL4_MARK___4 = 1584,
	SDA4_MARK___4 = 1585,
	SCL5_MARK___7 = 1586,
	SDA5_MARK___7 = 1587,
	SCL6_MARK = 1588,
	SDA6_MARK = 1589,
	PINMUX_MARK_END___9 = 1590,
};

enum ioctrl_regs___6 {
	POC0 = 0,
	POC1 = 1,
	POC2 = 2,
	POC4 = 3,
	POC5 = 4,
	POC6 = 5,
	POC7 = 6,
	POC8 = 7,
	POC9 = 8,
	TD1SEL0 = 9,
};

enum pin_type {
	GLOBAL_CTRL_PIN = 0,
	COMMON_PIN = 1,
	MISC_PIN = 2,
};

struct sprd_pins_info {
	const char *name;
	unsigned int num;
	enum pin_type type;
	long unsigned int bit_offset;
	long unsigned int bit_width;
	unsigned int reg;
};

enum pin_sleep_mode {
	AP_SLEEP = 1,
	PUBCP_SLEEP = 2,
	TGLDSP_SLEEP = 4,
	AGDSP_SLEEP = 8,
	CM4_SLEEP = 16,
};

enum pin_func_sel {
	PIN_FUNC_1 = 0,
	PIN_FUNC_2 = 1,
	PIN_FUNC_3 = 2,
	PIN_FUNC_4 = 3,
	PIN_FUNC_MAX = 4,
};

struct sprd_pin {
	const char *name;
	unsigned int number;
	enum pin_type type;
	long unsigned int reg;
	long unsigned int bit_offset;
	long unsigned int bit_width;
};

struct sprd_pin_group {
	const char *name;
	unsigned int npins;
	unsigned int *pins;
};

struct sprd_pinctrl_soc_info {
	struct sprd_pin_group *groups;
	unsigned int ngroups;
	struct sprd_pin *pins;
	unsigned int npins;
	const char **grp_names;
};

struct sprd_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctl;
	void *base;
	struct sprd_pinctrl_soc_info *info;
};

enum sprd_sc9860_pins {
	SC9860_VIO28_0_IRTE = 2832,
	SC9860_VIO_SD2_IRTE = 1051152,
	SC9860_VIO_SD0_IRTE = 2099472,
	SC9860_VIO_SIM2_IRTE = 3147792,
	SC9860_VIO_SIM1_IRTE = 4196112,
	SC9860_VIO_SIM0_IRTE = 5244432,
	SC9860_VIO28_0_MS = 6292752,
	SC9860_VIO_SD2_MS = 7341072,
	SC9860_VIO_SD0_MS = 8389392,
	SC9860_VIO_SIM2_MS = 9437712,
	SC9860_VIO_SIM1_MS = 10486032,
	SC9860_VIO_SIM0_MS = 11534352,
	SC9860_SPSPI_PIN_IN_SEL = 12590866,
	SC9860_UART1_USB30_PHY_SEL = 13639186,
	SC9860_USB30_PHY_DM_OE = 14687506,
	SC9860_USB30_PHY_DP_OE = 15735826,
	SC9860_UART5_SYS_SEL = 16783666,
	SC9860_ORP_URXD_PIN_IN_SEL = 17831954,
	SC9860_SIM2_SYS_SEL = 18880274,
	SC9860_SIM1_SYS_SEL = 19928594,
	SC9860_SIM0_SYS_SEL = 20976914,
	SC9860_CLK26MHZ_BUF_OUT_SEL = 22025234,
	SC9860_UART4_SYS_SEL = 23072818,
	SC9860_UART3_SYS_SEL = 24120626,
	SC9860_UART2_SYS_SEL = 25168434,
	SC9860_UART1_SYS_SEL = 26216242,
	SC9860_UART0_SYS_SEL = 27264050,
	SC9860_UART24_LOOP_SEL = 28312338,
	SC9860_UART23_LOOP_SEL = 29360658,
	SC9860_UART14_LOOP_SEL = 30408978,
	SC9860_UART13_LOOP_SEL = 31457298,
	SC9860_IIS3_SYS_SEL = 32510531,
	SC9860_IIS2_SYS_SEL = 33558083,
	SC9860_IIS1_SYS_SEL = 34605635,
	SC9860_IIS0_SYS_SEL = 35653187,
	SC9860_IIS23_LOOP_SEL = 36701459,
	SC9860_IIS13_LOOP_SEL = 37749779,
	SC9860_IIS12_LOOP_SEL = 38798099,
	SC9860_IIS03_LOOP_SEL = 39846419,
	SC9860_IIS02_LOOP_SEL = 40894739,
	SC9860_IIS01_LOOP_SEL = 41943059,
	SC9860_IIS6_SYS_SEL = 42998596,
	SC9860_IIS5_SYS_SEL = 44046148,
	SC9860_IIS4_SYS_SEL = 45093700,
	SC9860_I2C_INF6_SYS_SEL = 46139428,
	SC9860_I2C_INF4_SYS_SEL = 47187492,
	SC9860_I2C_INF2_SYS_SEL = 48235556,
	SC9860_I2C_INF1_SYS_SEL = 49283620,
	SC9860_I2C_INF0_SYS_SEL = 50331684,
	SC9860_GPIO_INF7_SYS_SEL = 51387157,
	SC9860_GPIO_INF6_SYS_SEL = 52435477,
	SC9860_GPIO_INF5_SYS_SEL = 53483797,
	SC9860_GPIO_INF4_SYS_SEL = 54532117,
	SC9860_GPIO_INF3_SYS_SEL = 55580437,
	SC9860_GPIO_INF2_SYS_SEL = 56628757,
	SC9860_GPIO_INF1_SYS_SEL = 57677077,
	SC9860_GPIO_INF0_SYS_SEL = 58725397,
	SC9860_WDRST_OUT_SEL = 59772981,
	SC9860_ADI_SYNC_PIN_OUT_SEL = 60821013,
	SC9860_CMRST_SEL = 61869333,
	SC9860_CMPD_SEL = 62917653,
	SC9860_TEST_DBG_MODE11 = 63965973,
	SC9860_TEST_DBG_MODE10 = 65014293,
	SC9860_TEST_DBG_MODE9 = 66062613,
	SC9860_TEST_DBG_MODE8 = 67110933,
	SC9860_TEST_DBG_MODE7 = 68159253,
	SC9860_TEST_DBG_MODE6 = 69207573,
	SC9860_TEST_DBG_MODE5 = 70255893,
	SC9860_TEST_DBG_MODE4 = 71304213,
	SC9860_TEST_DBG_MODE3 = 72352533,
	SC9860_TEST_DBG_MODE2 = 73400853,
	SC9860_TEST_DBG_MODE1 = 74449173,
	SC9860_TEST_DBG_MODE0 = 75497493,
	SC9860_SP_EIC_DPAD3_SEL = 76552326,
	SC9860_SP_EIC_DPAD2_SEL = 77598854,
	SC9860_SP_EIC_DPAD1_SEL = 78645382,
	SC9860_SP_EIC_DPAD0_SEL = 79691910,
	SC9860_SP_EIC_DPAD7_SEL = 80746631,
	SC9860_SP_EIC_DPAD6_SEL = 81793159,
	SC9860_SP_EIC_DPAD5_SEL = 82839687,
	SC9860_SP_EIC_DPAD4_SEL = 83886215,
	SC9860_RFCTL20 = 85000192,
	SC9860_RFCTL21 = 87097344,
	SC9860_RFCTL30 = 89194496,
	SC9860_RFCTL31 = 91291648,
	SC9860_RFCTL32 = 93388800,
	SC9860_RFCTL33 = 95485952,
	SC9860_RFCTL34 = 97583104,
	SC9860_RFCTL35 = 99680256,
	SC9860_RFCTL36 = 101777408,
	SC9860_RFCTL37 = 103874560,
	SC9860_RFCTL22 = 105971712,
	SC9860_RFCTL23 = 108068864,
	SC9860_RFCTL24 = 110166016,
	SC9860_RFCTL25 = 112263168,
	SC9860_RFCTL26 = 114360320,
	SC9860_RFCTL27 = 116457472,
	SC9860_RFCTL28 = 118554624,
	SC9860_RFCTL29 = 120651776,
	SC9860_SCL2 = 122748928,
	SC9860_SDA2 = 124846080,
	SC9860_MTCK_ARM = 126943232,
	SC9860_MTMS_ARM = 129040384,
	SC9860_XTL_EN0 = 131137536,
	SC9860_PTEST = 133234688,
	SC9860_AUD_DAD1 = 135331840,
	SC9860_AUD_ADD0 = 137428992,
	SC9860_AUD_ADSYNC = 139526144,
	SC9860_AUD_SCLK = 141623296,
	SC9860_CHIP_SLEEP = 143720448,
	SC9860_CLK_32K = 145817600,
	SC9860_DCDC_ARM_EN = 147914752,
	SC9860_EXT_RST_B = 150011904,
	SC9860_ADI_D = 152109056,
	SC9860_ADI_SCLK = 154206208,
	SC9860_XTL_EN1 = 156303360,
	SC9860_ANA_INT = 158400512,
	SC9860_AUD_DAD0 = 160497664,
	SC9860_AUD_DASYNC = 162594816,
	SC9860_LCM_RSTN = 164691968,
	SC9860_DSI_TE = 166789120,
	SC9860_PWMA = 168886272,
	SC9860_EXTINT0 = 170983424,
	SC9860_EXTINT1 = 173080576,
	SC9860_SDA1 = 175177728,
	SC9860_SCL1 = 177274880,
	SC9860_SIMCLK2 = 179372032,
	SC9860_SIMDA2 = 181469184,
	SC9860_SIMRST2 = 183566336,
	SC9860_SIMCLK1 = 185663488,
	SC9860_SIMDA1 = 187760640,
	SC9860_SIMRST1 = 189857792,
	SC9860_SIMCLK0 = 191954944,
	SC9860_SIMDA0 = 194052096,
	SC9860_SIMRST0 = 196149248,
	SC9860_SD2_CMD = 198246400,
	SC9860_SD2_D0 = 200343552,
	SC9860_SD2_D1 = 202440704,
	SC9860_SD2_CLK = 204537856,
	SC9860_SD2_D2 = 206635008,
	SC9860_SD2_D3 = 208732160,
	SC9860_SD0_D3 = 210829312,
	SC9860_SD0_D2 = 212926464,
	SC9860_SD0_CMD = 215023616,
	SC9860_SD0_D0 = 217120768,
	SC9860_SD0_D1 = 219217920,
	SC9860_SD0_CLK = 221315072,
	SC9860_EMMC_CMD_reserved = 223412224,
	SC9860_EMMC_CMD = 225509376,
	SC9860_EMMC_D6 = 227606528,
	SC9860_EMMC_D7 = 229703680,
	SC9860_EMMC_CLK = 231800832,
	SC9860_EMMC_D5 = 233897984,
	SC9860_EMMC_D4 = 235995136,
	SC9860_EMMC_DS = 238092288,
	SC9860_EMMC_D3_reserved = 240189440,
	SC9860_EMMC_D3 = 242286592,
	SC9860_EMMC_RST = 244383744,
	SC9860_EMMC_D1 = 246480896,
	SC9860_EMMC_D2 = 248578048,
	SC9860_EMMC_D0 = 250675200,
	SC9860_IIS0DI = 252772352,
	SC9860_IIS0DO = 254869504,
	SC9860_IIS0CLK = 256966656,
	SC9860_IIS0LRCK = 259063808,
	SC9860_SD1_CLK = 261160960,
	SC9860_SD1_CMD = 263258112,
	SC9860_SD1_D0 = 265355264,
	SC9860_SD1_D1 = 267452416,
	SC9860_SD1_D2 = 269549568,
	SC9860_SD1_D3 = 271646720,
	SC9860_CLK_AUX0 = 273743872,
	SC9860_WIFI_COEXIST = 275841024,
	SC9860_BEIDOU_COEXIST = 277938176,
	SC9860_U3TXD = 280035328,
	SC9860_U3RXD = 282132480,
	SC9860_U3CTS = 284229632,
	SC9860_U3RTS = 286326784,
	SC9860_U0TXD = 288423936,
	SC9860_U0RXD = 290521088,
	SC9860_U0CTS = 292618240,
	SC9860_U0RTS = 294715392,
	SC9860_IIS1DI = 296812544,
	SC9860_IIS1DO = 298909696,
	SC9860_IIS1CLK = 301006848,
	SC9860_IIS1LRCK = 303104000,
	SC9860_SPI0_CSN = 305201152,
	SC9860_SPI0_DO = 307298304,
	SC9860_SPI0_DI = 309395456,
	SC9860_SPI0_CLK = 311492608,
	SC9860_U2TXD = 313589760,
	SC9860_U2RXD = 315686912,
	SC9860_U4TXD = 317784064,
	SC9860_U4RXD = 319881216,
	SC9860_CMMCLK1 = 321978368,
	SC9860_CMRST1 = 324075520,
	SC9860_CMMCLK0 = 326172672,
	SC9860_CMRST0 = 328269824,
	SC9860_CMPD0 = 330366976,
	SC9860_CMPD1 = 332464128,
	SC9860_SCL0 = 334561280,
	SC9860_SDA0 = 336658432,
	SC9860_SDA6 = 338755584,
	SC9860_SCL6 = 340852736,
	SC9860_U1TXD = 342949888,
	SC9860_U1RXD = 345047040,
	SC9860_KEYOUT0 = 347144192,
	SC9860_KEYOUT1 = 349241344,
	SC9860_KEYOUT2 = 351338496,
	SC9860_KEYIN0 = 353435648,
	SC9860_KEYIN1 = 355532800,
	SC9860_KEYIN2 = 357629952,
	SC9860_IIS3DI = 359727104,
	SC9860_IIS3DO = 361824256,
	SC9860_IIS3CLK = 363921408,
	SC9860_IIS3LRCK = 366018560,
	SC9860_RFCTL0 = 368115712,
	SC9860_RFCTL1 = 370212864,
	SC9860_RFCTL10 = 372310016,
	SC9860_RFCTL11 = 374407168,
	SC9860_RFCTL12 = 376504320,
	SC9860_RFCTL13 = 378601472,
	SC9860_RFCTL14 = 380698624,
	SC9860_RFCTL15 = 382795776,
	SC9860_RFCTL16 = 384892928,
	SC9860_RFCTL17 = 386990080,
	SC9860_RFCTL18 = 389087232,
	SC9860_RFCTL19 = 391184384,
	SC9860_RFCTL2 = 393281536,
	SC9860_EXTINT5 = 395378688,
	SC9860_EXTINT6 = 397475840,
	SC9860_EXTINT7 = 399572992,
	SC9860_GPIO30 = 401670144,
	SC9860_GPIO31 = 403767296,
	SC9860_GPIO32 = 405864448,
	SC9860_GPIO33 = 407961600,
	SC9860_GPIO34 = 410058752,
	SC9860_RFCTL3 = 412155904,
	SC9860_RFCTL4 = 414253056,
	SC9860_RFCTL5 = 416350208,
	SC9860_RFCTL6 = 418447360,
	SC9860_RFCTL7 = 420544512,
	SC9860_RFCTL8 = 422641664,
	SC9860_RFCTL9 = 424738816,
	SC9860_RFFE0_SCK0 = 426835968,
	SC9860_GPIO38 = 428933120,
	SC9860_RFFE0_SDA0 = 431030272,
	SC9860_GPIO39 = 433127424,
	SC9860_RFFE1_SCK0 = 435224576,
	SC9860_GPIO181 = 437321728,
	SC9860_RFFE1_SDA0 = 439418880,
	SC9860_GPIO182 = 441516032,
	SC9860_RF_LVDS0_ADC_ON = 443613184,
	SC9860_RF_LVDS0_DAC_ON = 445710336,
	SC9860_RFSCK0 = 447807488,
	SC9860_RFSDA0 = 449904640,
	SC9860_RFSEN0 = 452001792,
	SC9860_RF_LVDS1_ADC_ON = 454098944,
	SC9860_RF_LVDS1_DAC_ON = 456196096,
	SC9860_RFSCK1 = 458293248,
	SC9860_RFSDA1 = 460390400,
	SC9860_RFSEN1 = 462487552,
	SC9860_RFCTL38 = 464584704,
	SC9860_RFCTL39 = 466681856,
	SC9860_RFCTL20_MISC = 86114304,
	SC9860_RFCTL21_MISC = 88211456,
	SC9860_RFCTL30_MISC = 90308608,
	SC9860_RFCTL31_MISC = 92405760,
	SC9860_RFCTL32_MISC = 94502912,
	SC9860_RFCTL33_MISC = 96600064,
	SC9860_RFCTL34_MISC = 98697216,
	SC9860_RFCTL35_MISC = 100794368,
	SC9860_RFCTL36_MISC = 102891520,
	SC9860_RFCTL37_MISC = 104988672,
	SC9860_RFCTL22_MISC = 107085824,
	SC9860_RFCTL23_MISC = 109182976,
	SC9860_RFCTL24_MISC = 111280128,
	SC9860_RFCTL25_MISC = 113377280,
	SC9860_RFCTL26_MISC = 115474432,
	SC9860_RFCTL27_MISC = 117571584,
	SC9860_RFCTL28_MISC = 119668736,
	SC9860_RFCTL29_MISC = 121765888,
	SC9860_SCL2_MISC = 123863040,
	SC9860_SDA2_MISC = 125960192,
	SC9860_MTCK_ARM_MISC = 128057344,
	SC9860_MTMS_ARM_MISC = 130154496,
	SC9860_XTL_EN0_MISC = 132251648,
	SC9860_PTEST_MISC = 134348800,
	SC9860_AUD_DAD1_MISC = 136445952,
	SC9860_AUD_ADD0_MISC = 138543104,
	SC9860_AUD_ADSYNC_MISC = 140640256,
	SC9860_AUD_SCLK_MISC = 142737408,
	SC9860_CHIP_SLEEP_MISC = 144834560,
	SC9860_CLK_32K_MISC = 146931712,
	SC9860_DCDC_ARM_EN_MISC = 149028864,
	SC9860_EXT_RST_B_MISC = 151126016,
	SC9860_ADI_D_MISC = 153223168,
	SC9860_ADI_SCLK_MISC = 155320320,
	SC9860_XTL_EN1_MISC = 157417472,
	SC9860_ANA_INT_MISC = 159514624,
	SC9860_AUD_DAD0_MISC = 161611776,
	SC9860_AUD_DASYNC_MISC = 163708928,
	SC9860_LCM_RSTN_MISC = 165806080,
	SC9860_DSI_TE_MISC = 167903232,
	SC9860_PWMA_MISC = 170000384,
	SC9860_EXTINT0_MISC = 172097536,
	SC9860_EXTINT1_MISC = 174194688,
	SC9860_SDA1_MISC = 176291840,
	SC9860_SCL1_MISC = 178388992,
	SC9860_SIMCLK2_MISC = 180486144,
	SC9860_SIMDA2_MISC = 182583296,
	SC9860_SIMRST2_MISC = 184680448,
	SC9860_SIMCLK1_MISC = 186777600,
	SC9860_SIMDA1_MISC = 188874752,
	SC9860_SIMRST1_MISC = 190971904,
	SC9860_SIMCLK0_MISC = 193069056,
	SC9860_SIMDA0_MISC = 195166208,
	SC9860_SIMRST0_MISC = 197263360,
	SC9860_SD2_CMD_MISC = 199360512,
	SC9860_SD2_D0_MISC = 201457664,
	SC9860_SD2_D1_MISC = 203554816,
	SC9860_SD2_CLK_MISC = 205651968,
	SC9860_SD2_D2_MISC = 207749120,
	SC9860_SD2_D3_MISC = 209846272,
	SC9860_SD0_D3_MISC = 211943424,
	SC9860_SD0_D2_MISC = 214040576,
	SC9860_SD0_CMD_MISC = 216137728,
	SC9860_SD0_D0_MISC = 218234880,
	SC9860_SD0_D1_MISC = 220332032,
	SC9860_SD0_CLK_MISC = 222429184,
	SC9860_EMMC_CMD_reserved_MISC = 224526336,
	SC9860_EMMC_CMD_MISC = 226623488,
	SC9860_EMMC_D6_MISC = 228720640,
	SC9860_EMMC_D7_MISC = 230817792,
	SC9860_EMMC_CLK_MISC = 232914944,
	SC9860_EMMC_D5_MISC = 235012096,
	SC9860_EMMC_D4_MISC = 237109248,
	SC9860_EMMC_DS_MISC = 239206400,
	SC9860_EMMC_D3_reserved_MISC = 241303552,
	SC9860_EMMC_D3_MISC = 243400704,
	SC9860_EMMC_RST_MISC = 245497856,
	SC9860_EMMC_D1_MISC = 247595008,
	SC9860_EMMC_D2_MISC = 249692160,
	SC9860_EMMC_D0_MISC = 251789312,
	SC9860_IIS0DI_MISC = 253886464,
	SC9860_IIS0DO_MISC = 255983616,
	SC9860_IIS0CLK_MISC = 258080768,
	SC9860_IIS0LRCK_MISC = 260177920,
	SC9860_SD1_CLK_MISC = 262275072,
	SC9860_SD1_CMD_MISC = 264372224,
	SC9860_SD1_D0_MISC = 266469376,
	SC9860_SD1_D1_MISC = 268566528,
	SC9860_SD1_D2_MISC = 270663680,
	SC9860_SD1_D3_MISC = 272760832,
	SC9860_CLK_AUX0_MISC = 274857984,
	SC9860_WIFI_COEXIST_MISC = 276955136,
	SC9860_BEIDOU_COEXIST_MISC = 279052288,
	SC9860_U3TXD_MISC = 281149440,
	SC9860_U3RXD_MISC = 283246592,
	SC9860_U3CTS_MISC = 285343744,
	SC9860_U3RTS_MISC = 287440896,
	SC9860_U0TXD_MISC = 289538048,
	SC9860_U0RXD_MISC = 291635200,
	SC9860_U0CTS_MISC = 293732352,
	SC9860_U0RTS_MISC = 295829504,
	SC9860_IIS1DI_MISC = 297926656,
	SC9860_IIS1DO_MISC = 300023808,
	SC9860_IIS1CLK_MISC = 302120960,
	SC9860_IIS1LRCK_MISC = 304218112,
	SC9860_SPI0_CSN_MISC = 306315264,
	SC9860_SPI0_DO_MISC = 308412416,
	SC9860_SPI0_DI_MISC = 310509568,
	SC9860_SPI0_CLK_MISC = 312606720,
	SC9860_U2TXD_MISC = 314703872,
	SC9860_U2RXD_MISC = 316801024,
	SC9860_U4TXD_MISC = 318898176,
	SC9860_U4RXD_MISC = 320995328,
	SC9860_CMMCLK1_MISC = 323092480,
	SC9860_CMRST1_MISC = 325189632,
	SC9860_CMMCLK0_MISC = 327286784,
	SC9860_CMRST0_MISC = 329383936,
	SC9860_CMPD0_MISC = 331481088,
	SC9860_CMPD1_MISC = 333578240,
	SC9860_SCL0_MISC = 335675392,
	SC9860_SDA0_MISC = 337772544,
	SC9860_SDA6_MISC = 339869696,
	SC9860_SCL6_MISC = 341966848,
	SC9860_U1TXD_MISC = 344064000,
	SC9860_U1RXD_MISC = 346161152,
	SC9860_KEYOUT0_MISC = 348258304,
	SC9860_KEYOUT1_MISC = 350355456,
	SC9860_KEYOUT2_MISC = 352452608,
	SC9860_KEYIN0_MISC = 354549760,
	SC9860_KEYIN1_MISC = 356646912,
	SC9860_KEYIN2_MISC = 358744064,
	SC9860_IIS3DI_MISC = 360841216,
	SC9860_IIS3DO_MISC = 362938368,
	SC9860_IIS3CLK_MISC = 365035520,
	SC9860_IIS3LRCK_MISC = 367132672,
	SC9860_RFCTL0_MISC = 369229824,
	SC9860_RFCTL1_MISC = 371326976,
	SC9860_RFCTL10_MISC = 373424128,
	SC9860_RFCTL11_MISC = 375521280,
	SC9860_RFCTL12_MISC = 377618432,
	SC9860_RFCTL13_MISC = 379715584,
	SC9860_RFCTL14_MISC = 381812736,
	SC9860_RFCTL15_MISC = 383909888,
	SC9860_RFCTL16_MISC = 386007040,
	SC9860_RFCTL17_MISC = 388104192,
	SC9860_RFCTL18_MISC = 390201344,
	SC9860_RFCTL19_MISC = 392298496,
	SC9860_RFCTL2_MISC = 394395648,
	SC9860_EXTINT5_MISC = 396492800,
	SC9860_EXTINT6_MISC = 398589952,
	SC9860_EXTINT7_MISC = 400687104,
	SC9860_GPIO30_MISC = 402784256,
	SC9860_GPIO31_MISC = 404881408,
	SC9860_GPIO32_MISC = 406978560,
	SC9860_GPIO33_MISC = 409075712,
	SC9860_GPIO34_MISC = 411172864,
	SC9860_RFCTL3_MISC = 413270016,
	SC9860_RFCTL4_MISC = 415367168,
	SC9860_RFCTL5_MISC = 417464320,
	SC9860_RFCTL6_MISC = 419561472,
	SC9860_RFCTL7_MISC = 421658624,
	SC9860_RFCTL8_MISC = 423755776,
	SC9860_RFCTL9_MISC = 425852928,
	SC9860_RFFE0_SCK0_MISC = 427950080,
	SC9860_GPIO38_MISC = 430047232,
	SC9860_RFFE0_SDA0_MISC = 432144384,
	SC9860_GPIO39_MISC = 434241536,
	SC9860_RFFE1_SCK0_MISC = 436338688,
	SC9860_GPIO181_MISC = 438435840,
	SC9860_RFFE1_SDA0_MISC = 440532992,
	SC9860_GPIO182_MISC = 442630144,
	SC9860_RF_LVDS0_ADC_ON_MISC = 444727296,
	SC9860_RF_LVDS0_DAC_ON_MISC = 446824448,
	SC9860_RFSCK0_MISC = 448921600,
	SC9860_RFSDA0_MISC = 451018752,
	SC9860_RFSEN0_MISC = 453115904,
	SC9860_RF_LVDS1_ADC_ON_MISC = 455213056,
	SC9860_RF_LVDS1_DAC_ON_MISC = 457310208,
	SC9860_RFSCK1_MISC = 459407360,
	SC9860_RFSDA1_MISC = 461504512,
	SC9860_RFSEN1_MISC = 463601664,
	SC9860_RFCTL38_MISC = 465698816,
	SC9860_RFCTL39_MISC = 467795968,
};

enum sunxi_desc_bias_voltage {
	BIAS_VOLTAGE_NONE = 0,
	BIAS_VOLTAGE_GRP_CONFIG = 1,
	BIAS_VOLTAGE_PIO_POW_MODE_SEL = 2,
};

struct sunxi_desc_function {
	long unsigned int variant;
	const char *name;
	u8 muxval;
	u8 irqbank;
	u8 irqnum;
};

struct sunxi_desc_pin {
	struct pinctrl_pin_desc pin;
	long unsigned int variant;
	struct sunxi_desc_function *functions;
};

struct sunxi_pinctrl_desc {
	const struct sunxi_desc_pin *pins;
	int npins;
	unsigned int pin_base;
	unsigned int irq_banks;
	const unsigned int *irq_bank_map;
	bool irq_read_needs_mux;
	bool disable_strict_mode;
	enum sunxi_desc_bias_voltage io_bias_cfg_variant;
};

struct sunxi_pinctrl_function {
	const char *name;
	const char **groups;
	unsigned int ngroups;
};

struct sunxi_pinctrl_group {
	const char *name;
	unsigned int pin;
};

struct sunxi_pinctrl_regulator {
	struct regulator *regulator;
	refcount_t refcount;
};

struct sunxi_pinctrl {
	void *membase;
	struct gpio_chip *chip;
	const struct sunxi_pinctrl_desc *desc;
	struct device *dev;
	struct sunxi_pinctrl_regulator regulators[9];
	struct irq_domain *domain;
	struct sunxi_pinctrl_function *functions;
	unsigned int nfunctions;
	struct sunxi_pinctrl_group *groups;
	unsigned int ngroups;
	int *irq;
	unsigned int *irq_array;
	raw_spinlock_t lock;
	struct pinctrl_dev *pctl_dev;
	long unsigned int variant;
};

struct mtk_eint_regs {
	unsigned int stat;
	unsigned int ack;
	unsigned int mask;
	unsigned int mask_set;
	unsigned int mask_clr;
	unsigned int sens;
	unsigned int sens_set;
	unsigned int sens_clr;
	unsigned int soft;
	unsigned int soft_set;
	unsigned int soft_clr;
	unsigned int pol;
	unsigned int pol_set;
	unsigned int pol_clr;
	unsigned int dom_en;
	unsigned int dbnc_ctrl;
	unsigned int dbnc_set;
	unsigned int dbnc_clr;
};

struct mtk_eint_hw {
	u8 port_mask;
	u8 ports;
	unsigned int ap_num;
	unsigned int db_cnt;
};

struct mtk_eint_xt {
	int (*get_gpio_n)(void *, long unsigned int, unsigned int *, struct gpio_chip **);
	int (*get_gpio_state)(void *, long unsigned int);
	int (*set_gpio_as_eint)(void *, long unsigned int);
};

struct mtk_eint {
	struct device *dev;
	void *base;
	struct irq_domain *domain;
	int irq;
	int *dual_edge;
	u32 *wake_mask;
	u32 *cur_mask;
	const struct mtk_eint_hw *hw;
	const struct mtk_eint_regs *regs;
	void *pctl;
	const struct mtk_eint_xt *gpio_xlate;
};

struct mtk_desc_function {
	const char *name;
	unsigned char muxval;
};

struct mtk_desc_eint {
	unsigned char eintmux;
	unsigned char eintnum;
};

struct mtk_desc_pin {
	struct pinctrl_pin_desc pin;
	const struct mtk_desc_eint eint;
	const struct mtk_desc_function *functions;
};

struct mtk_pinctrl_group {
	const char *name;
	long unsigned int config;
	unsigned int pin;
};

struct mtk_drv_group_desc {
	unsigned char min_drv;
	unsigned char max_drv;
	unsigned char low_bit;
	unsigned char high_bit;
	unsigned char step;
};

struct mtk_pin_drv_grp {
	short unsigned int pin;
	short unsigned int offset;
	unsigned char bit;
	unsigned char grp;
};

struct mtk_pin_spec_pupd_set_samereg {
	short unsigned int pin;
	short unsigned int offset;
	unsigned char pupd_bit;
	unsigned char r1_bit;
	unsigned char r0_bit;
};

struct mtk_pin_ies_smt_set {
	short unsigned int start;
	short unsigned int end;
	short unsigned int offset;
	unsigned char bit;
};

struct mtk_pinctrl_devdata {
	const struct mtk_desc_pin *pins;
	unsigned int npins;
	const struct mtk_drv_group_desc *grp_desc;
	unsigned int n_grp_cls;
	const struct mtk_pin_drv_grp *pin_drv_grp;
	unsigned int n_pin_drv_grps;
	int (*spec_pull_set)(struct regmap *, unsigned int, unsigned char, bool, unsigned int);
	int (*spec_ies_smt_set)(struct regmap *, unsigned int, unsigned char, int, enum pin_config_param);
	void (*spec_pinmux_set)(struct regmap *, unsigned int, unsigned int);
	void (*spec_dir_set)(unsigned int *, unsigned int);
	unsigned int dir_offset;
	unsigned int ies_offset;
	unsigned int smt_offset;
	unsigned int pullen_offset;
	unsigned int pullsel_offset;
	unsigned int drv_offset;
	unsigned int dout_offset;
	unsigned int din_offset;
	unsigned int pinmux_offset;
	short unsigned int type1_start;
	short unsigned int type1_end;
	unsigned char port_shf;
	unsigned char port_mask;
	unsigned char port_align;
	struct mtk_eint_hw eint_hw;
	struct mtk_eint_regs *eint_regs;
};

struct mtk_pinctrl {
	struct regmap *regmap1;
	struct regmap *regmap2;
	struct pinctrl_desc pctl_desc;
	struct device *dev;
	struct gpio_chip *chip;
	struct mtk_pinctrl_group *groups;
	unsigned int ngroups;
	const char **grp_names;
	struct pinctrl_dev *pctl_dev;
	const struct mtk_pinctrl_devdata *devdata;
	struct mtk_eint *eint;
};

enum {
	PINCTRL_PIN_REG_MODE = 0,
	PINCTRL_PIN_REG_DIR = 1,
	PINCTRL_PIN_REG_DI = 2,
	PINCTRL_PIN_REG_DO = 3,
	PINCTRL_PIN_REG_SR = 4,
	PINCTRL_PIN_REG_SMT = 5,
	PINCTRL_PIN_REG_PD = 6,
	PINCTRL_PIN_REG_PU = 7,
	PINCTRL_PIN_REG_E4 = 8,
	PINCTRL_PIN_REG_E8 = 9,
	PINCTRL_PIN_REG_TDSEL = 10,
	PINCTRL_PIN_REG_RDSEL = 11,
	PINCTRL_PIN_REG_DRV = 12,
	PINCTRL_PIN_REG_PUPD = 13,
	PINCTRL_PIN_REG_R0 = 14,
	PINCTRL_PIN_REG_R1 = 15,
	PINCTRL_PIN_REG_IES = 16,
	PINCTRL_PIN_REG_PULLEN = 17,
	PINCTRL_PIN_REG_PULLSEL = 18,
	PINCTRL_PIN_REG_DRV_EN = 19,
	PINCTRL_PIN_REG_DRV_E0 = 20,
	PINCTRL_PIN_REG_DRV_E1 = 21,
	PINCTRL_PIN_REG_DRV_ADV = 22,
	PINCTRL_PIN_REG_MAX = 23,
};

enum {
	DRV_FIXED = 0,
	DRV_GRP0 = 1,
	DRV_GRP1 = 2,
	DRV_GRP2 = 3,
	DRV_GRP3 = 4,
	DRV_GRP4 = 5,
	DRV_GRP_MAX = 6,
};

struct mtk_pin_field {
	u8 index;
	u32 offset;
	u32 mask;
	u8 bitpos;
	u8 next;
};

struct mtk_pin_field_calc {
	u16 s_pin;
	u16 e_pin;
	u8 i_base;
	u32 s_addr;
	u8 x_addrs;
	u8 s_bit;
	u8 x_bits;
	u8 sz_reg;
	u8 fixed;
};

struct mtk_pin_reg_calc {
	const struct mtk_pin_field_calc *range;
	unsigned int nranges;
};

struct mtk_func_desc {
	const char *name;
	u8 muxval;
};

struct mtk_eint_desc {
	u16 eint_m;
	u16 eint_n;
};

struct mtk_pin_desc {
	unsigned int number;
	const char *name;
	struct mtk_eint_desc eint;
	u8 drv_n;
	struct mtk_func_desc *funcs;
};

struct mtk_pinctrl___2;

struct mtk_pin_soc {
	const struct mtk_pin_reg_calc *reg_cal;
	const struct mtk_pin_desc *pins;
	unsigned int npins;
	const struct group_desc *grps;
	unsigned int ngrps;
	const struct function_desc *funcs;
	unsigned int nfuncs;
	const struct mtk_eint_regs *eint_regs;
	const struct mtk_eint_hw *eint_hw;
	u8 gpio_m;
	bool ies_present;
	const char * const *base_names;
	unsigned int nbase_names;
	int (*bias_disable_set)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *);
	int (*bias_disable_get)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, int *);
	int (*bias_set)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, bool);
	int (*bias_get)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, bool, int *);
	int (*bias_set_combo)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, u32, u32);
	int (*bias_get_combo)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, u32 *, u32 *);
	int (*drive_set)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, u32);
	int (*drive_get)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, int *);
	int (*adv_pull_set)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, bool, u32);
	int (*adv_pull_get)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, bool, u32 *);
	int (*adv_drive_set)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, u32);
	int (*adv_drive_get)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, u32 *);
	void *driver_data;
};

struct mtk_pinctrl___2 {
	struct pinctrl_dev *pctrl;
	void **base;
	u8 nbase;
	struct device *dev;
	struct gpio_chip chip;
	const struct mtk_pin_soc *soc;
	struct mtk_eint *eint;
	struct mtk_pinctrl_group *groups;
	const char **grp_names;
	spinlock_t lock;
};

struct mtk_drive_desc {
	u8 min;
	u8 max;
	u8 step;
	u8 scal;
};

struct mt6397_chip {
	struct device *dev;
	struct regmap *regmap;
	struct notifier_block pm_nb;
	int irq;
	struct irq_domain *irq_domain;
	struct mutex irqlock;
	u16 wake_mask[2];
	u16 irq_masks_cur[2];
	u16 irq_masks_cache[2];
	u16 int_con[2];
	u16 int_status[2];
	u16 chip_id;
	void *irq_data;
};

struct gpio_pin_range {
	struct list_head node;
	struct pinctrl_dev *pctldev;
	struct pinctrl_gpio_range range;
};

struct gpio_array;

struct gpio_descs {
	struct gpio_array *info;
	unsigned int ndescs;
	struct gpio_desc___2 *desc[0];
};

struct gpio_array {
	struct gpio_desc___2 **desc;
	unsigned int size;
	struct gpio_chip *chip;
	long unsigned int *get_mask;
	long unsigned int *set_mask;
	long unsigned int invert_mask[0];
};

enum gpiod_flags {
	GPIOD_ASIS = 0,
	GPIOD_IN = 1,
	GPIOD_OUT_LOW = 3,
	GPIOD_OUT_HIGH = 7,
	GPIOD_OUT_LOW_OPEN_DRAIN = 11,
	GPIOD_OUT_HIGH_OPEN_DRAIN = 15,
};

enum gpio_lookup_flags {
	GPIO_ACTIVE_HIGH = 0,
	GPIO_ACTIVE_LOW = 1,
	GPIO_OPEN_DRAIN = 2,
	GPIO_OPEN_SOURCE = 4,
	GPIO_PERSISTENT = 0,
	GPIO_TRANSITORY = 8,
	GPIO_PULL_UP = 16,
	GPIO_PULL_DOWN = 32,
	GPIO_LOOKUP_FLAGS_DEFAULT = 0,
};

struct gpiod_lookup {
	const char *key;
	u16 chip_hwnum;
	const char *con_id;
	unsigned int idx;
	long unsigned int flags;
};

struct gpiod_lookup_table {
	struct list_head list;
	const char *dev_id;
	struct gpiod_lookup table[0];
};

struct gpiod_hog {
	struct list_head list;
	const char *chip_label;
	u16 chip_hwnum;
	const char *line_name;
	long unsigned int lflags;
	int dflags;
};

enum {
	GPIOLINE_CHANGED_REQUESTED = 1,
	GPIOLINE_CHANGED_RELEASED = 2,
	GPIOLINE_CHANGED_CONFIG = 3,
};

struct acpi_gpio_info {
	struct acpi_device *adev;
	enum gpiod_flags flags;
	bool gpioint;
	int pin_config;
	int polarity;
	int triggering;
	unsigned int debounce;
	unsigned int quirks;
};

struct trace_event_raw_gpio_direction {
	struct trace_entry ent;
	unsigned int gpio;
	int in;
	int err;
	char __data[0];
};

struct trace_event_raw_gpio_value {
	struct trace_entry ent;
	unsigned int gpio;
	int get;
	int value;
	char __data[0];
};

struct trace_event_data_offsets_gpio_direction {};

struct trace_event_data_offsets_gpio_value {};

typedef void (*btf_trace_gpio_direction)(void *, unsigned int, int, int);

typedef void (*btf_trace_gpio_value)(void *, unsigned int, int, int);

struct devres;

struct gpio {
	unsigned int gpio;
	long unsigned int flags;
	const char *label;
};

struct of_reconfig_data {
	struct device_node *dn;
	struct property *prop;
	struct property *old_prop;
};

enum of_reconfig_change {
	OF_RECONFIG_NO_CHANGE = 0,
	OF_RECONFIG_CHANGE_ADD = 1,
	OF_RECONFIG_CHANGE_REMOVE = 2,
};

enum of_gpio_flags {
	OF_GPIO_ACTIVE_LOW = 1,
	OF_GPIO_SINGLE_ENDED = 2,
	OF_GPIO_OPEN_DRAIN = 4,
	OF_GPIO_TRANSITORY = 8,
	OF_GPIO_PULL_UP = 16,
	OF_GPIO_PULL_DOWN = 32,
};

struct of_mm_gpio_chip {
	struct gpio_chip gc;
	void (*save_regs)(struct of_mm_gpio_chip *);
	void *regs;
};

struct gpiochip_info {
	char name[32];
	char label[32];
	__u32 lines;
};

enum gpio_v2_line_flag {
	GPIO_V2_LINE_FLAG_USED = 1,
	GPIO_V2_LINE_FLAG_ACTIVE_LOW = 2,
	GPIO_V2_LINE_FLAG_INPUT = 4,
	GPIO_V2_LINE_FLAG_OUTPUT = 8,
	GPIO_V2_LINE_FLAG_EDGE_RISING = 16,
	GPIO_V2_LINE_FLAG_EDGE_FALLING = 32,
	GPIO_V2_LINE_FLAG_OPEN_DRAIN = 64,
	GPIO_V2_LINE_FLAG_OPEN_SOURCE = 128,
	GPIO_V2_LINE_FLAG_BIAS_PULL_UP = 256,
	GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN = 512,
	GPIO_V2_LINE_FLAG_BIAS_DISABLED = 1024,
	GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME = 2048,
};

struct gpio_v2_line_values {
	__u64 bits;
	__u64 mask;
};

enum gpio_v2_line_attr_id {
	GPIO_V2_LINE_ATTR_ID_FLAGS = 1,
	GPIO_V2_LINE_ATTR_ID_OUTPUT_VALUES = 2,
	GPIO_V2_LINE_ATTR_ID_DEBOUNCE = 3,
};

struct gpio_v2_line_attribute {
	__u32 id;
	__u32 padding;
	union {
		__u64 flags;
		__u64 values;
		__u32 debounce_period_us;
	};
};

struct gpio_v2_line_config_attribute {
	struct gpio_v2_line_attribute attr;
	__u64 mask;
};

struct gpio_v2_line_config {
	__u64 flags;
	__u32 num_attrs;
	__u32 padding[5];
	struct gpio_v2_line_config_attribute attrs[10];
};

struct gpio_v2_line_request {
	__u32 offsets[64];
	char consumer[32];
	struct gpio_v2_line_config config;
	__u32 num_lines;
	__u32 event_buffer_size;
	__u32 padding[5];
	__s32 fd;
};

struct gpio_v2_line_info {
	char name[32];
	char consumer[32];
	__u32 offset;
	__u32 num_attrs;
	__u64 flags;
	struct gpio_v2_line_attribute attrs[10];
	__u32 padding[4];
};

enum gpio_v2_line_changed_type {
	GPIO_V2_LINE_CHANGED_REQUESTED = 1,
	GPIO_V2_LINE_CHANGED_RELEASED = 2,
	GPIO_V2_LINE_CHANGED_CONFIG = 3,
};

struct gpio_v2_line_info_changed {
	struct gpio_v2_line_info info;
	__u64 timestamp_ns;
	__u32 event_type;
	__u32 padding[5];
};

enum gpio_v2_line_event_id {
	GPIO_V2_LINE_EVENT_RISING_EDGE = 1,
	GPIO_V2_LINE_EVENT_FALLING_EDGE = 2,
};

struct gpio_v2_line_event {
	__u64 timestamp_ns;
	__u32 id;
	__u32 offset;
	__u32 seqno;
	__u32 line_seqno;
	__u32 padding[6];
};

struct linereq;

struct line {
	struct gpio_desc___2 *desc;
	struct linereq *req;
	unsigned int irq;
	u64 eflags;
	u64 timestamp_ns;
	u32 req_seqno;
	u32 line_seqno;
	struct delayed_work work;
	unsigned int sw_debounced;
	unsigned int level;
};

struct linereq {
	struct gpio_device *gdev;
	const char *label;
	u32 num_lines;
	wait_queue_head_t wait;
	u32 event_buffer_size;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_event *type;
			const struct gpio_v2_line_event *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_event *ptr;
			const struct gpio_v2_line_event *ptr_const;
		};
		struct gpio_v2_line_event buf[0];
	} events;
	atomic_t seqno;
	struct mutex config_mutex;
	struct line lines[0];
};

struct gpio_chardev_data {
	struct gpio_device *gdev;
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_info_changed *type;
			const struct gpio_v2_line_info_changed *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_info_changed *ptr;
			const struct gpio_v2_line_info_changed *ptr_const;
		};
		struct gpio_v2_line_info_changed buf[32];
	} events;
	struct notifier_block lineinfo_changed_nb;
	long unsigned int *watched_lines;
};

struct class_attribute {
	struct attribute attr;
	ssize_t (*show)(struct class *, struct class_attribute *, char *);
	ssize_t (*store)(struct class *, struct class_attribute *, const char *, size_t);
};

struct gpiod_data {
	struct gpio_desc___2 *desc;
	struct mutex mutex;
	struct kernfs_node *value_kn;
	int irq;
	unsigned char irq_flags;
	bool direction_can_change;
};

enum dmi_field {
	DMI_NONE = 0,
	DMI_BIOS_VENDOR = 1,
	DMI_BIOS_VERSION = 2,
	DMI_BIOS_DATE = 3,
	DMI_BIOS_RELEASE = 4,
	DMI_EC_FIRMWARE_RELEASE = 5,
	DMI_SYS_VENDOR = 6,
	DMI_PRODUCT_NAME = 7,
	DMI_PRODUCT_VERSION = 8,
	DMI_PRODUCT_SERIAL = 9,
	DMI_PRODUCT_UUID = 10,
	DMI_PRODUCT_SKU = 11,
	DMI_PRODUCT_FAMILY = 12,
	DMI_BOARD_VENDOR = 13,
	DMI_BOARD_NAME = 14,
	DMI_BOARD_VERSION = 15,
	DMI_BOARD_SERIAL = 16,
	DMI_BOARD_ASSET_TAG = 17,
	DMI_CHASSIS_VENDOR = 18,
	DMI_CHASSIS_TYPE = 19,
	DMI_CHASSIS_VERSION = 20,
	DMI_CHASSIS_SERIAL = 21,
	DMI_CHASSIS_ASSET_TAG = 22,
	DMI_STRING_MAX = 23,
	DMI_OEM_STRING = 24,
};

struct dmi_strmatch {
	unsigned char slot: 7;
	unsigned char exact_match: 1;
	char substr[79];
};

struct dmi_system_id {
	int (*callback)(const struct dmi_system_id *);
	const char *ident;
	struct dmi_strmatch matches[4];
	void *driver_data;
};

typedef u8 acpi_adr_space_type;

struct acpi_connection_info {
	u8 *connection;
	u16 length;
	u8 access_length;
};

struct acpi_gpiolib_dmi_quirk {
	bool no_edge_events_on_boot;
	char *ignore_wake;
};

struct acpi_gpio_event {
	struct list_head node;
	acpi_handle handle;
	irq_handler_t handler;
	unsigned int pin;
	unsigned int irq;
	long unsigned int irqflags;
	bool irq_is_wake;
	bool irq_requested;
	struct gpio_desc___2 *desc;
};

struct acpi_gpio_connection {
	struct list_head node;
	unsigned int pin;
	struct gpio_desc___2 *desc;
};

struct acpi_gpio_chip {
	struct acpi_connection_info conn_info;
	struct list_head conns;
	struct mutex conn_lock;
	struct gpio_chip *chip;
	struct list_head events;
	struct list_head deferred_req_irqs_list_entry;
};

struct acpi_gpio_lookup {
	struct acpi_gpio_info info;
	int index;
	u16 pin_index;
	bool active_low;
	struct gpio_desc___2 *desc;
	int n;
};

struct bgpio_pdata {
	const char *label;
	int base;
	int ngpio;
};

struct davinci_gpio_platform_data {
	bool no_auto_base;
	u32 base;
	u32 ngpio;
	u32 gpio_unbanked;
};

struct davinci_gpio_regs {
	u32 dir;
	u32 out_data;
	u32 set_data;
	u32 clr_data;
	u32 in_data;
	u32 set_rising;
	u32 clr_rising;
	u32 set_falling;
	u32 clr_falling;
	u32 intstat;
};

typedef struct irq_chip * (*gpio_get_irq_chip_cb_t)(unsigned int);

struct davinci_gpio_controller;

struct davinci_gpio_irq_data {
	void *regs;
	struct davinci_gpio_controller *chip;
	int bank_num;
};

struct davinci_gpio_controller {
	struct gpio_chip chip;
	struct irq_domain *irq_domain;
	spinlock_t lock;
	void *regs[5];
	int gpio_unbanked;
	int irqs[32];
};

struct ftgpio_gpio {
	struct device *dev;
	struct gpio_chip gc;
	struct irq_chip irq;
	void *base;
	struct clk *clk;
};

struct mpc8xxx_gpio_chip {
	struct gpio_chip gc;
	void *regs;
	raw_spinlock_t lock;
	int (*direction_output)(struct gpio_chip *, unsigned int, int);
	struct irq_domain *irq;
	unsigned int irqn;
};

struct mpc8xxx_gpio_devtype {
	int (*gpio_dir_out)(struct gpio_chip *, unsigned int, int);
	int (*gpio_get)(struct gpio_chip *, unsigned int);
	int (*irq_set_type)(struct irq_data *, unsigned int);
};

enum pwm_polarity {
	PWM_POLARITY_NORMAL = 0,
	PWM_POLARITY_INVERSED = 1,
};

struct pwm_args {
	u64 period;
	enum pwm_polarity polarity;
};

struct pwm_state {
	u64 period;
	u64 duty_cycle;
	enum pwm_polarity polarity;
	bool enabled;
};

struct pwm_chip;

struct pwm_device {
	const char *label;
	long unsigned int flags;
	unsigned int hwpwm;
	unsigned int pwm;
	struct pwm_chip *chip;
	void *chip_data;
	struct pwm_args args;
	struct pwm_state state;
	struct pwm_state last;
};

struct pwm_ops;

struct pwm_chip {
	struct device *dev;
	const struct pwm_ops *ops;
	int base;
	unsigned int npwm;
	struct pwm_device * (*of_xlate)(struct pwm_chip *, const struct of_phandle_args *);
	unsigned int of_pwm_n_cells;
	struct list_head list;
	struct pwm_device *pwms;
};

struct pwm_capture;

struct pwm_ops {
	int (*request)(struct pwm_chip *, struct pwm_device *);
	void (*free)(struct pwm_chip *, struct pwm_device *);
	int (*capture)(struct pwm_chip *, struct pwm_device *, struct pwm_capture *, long unsigned int);
	int (*apply)(struct pwm_chip *, struct pwm_device *, const struct pwm_state *);
	void (*get_state)(struct pwm_chip *, struct pwm_device *, struct pwm_state *);
	struct module *owner;
	int (*config)(struct pwm_chip *, struct pwm_device *, int, int);
	int (*set_polarity)(struct pwm_chip *, struct pwm_device *, enum pwm_polarity);
	int (*enable)(struct pwm_chip *, struct pwm_device *);
	void (*disable)(struct pwm_chip *, struct pwm_device *);
};

struct pwm_capture {
	unsigned int period;
	unsigned int duty_cycle;
};

struct mvebu_gpio_chip;

struct mvebu_pwm {
	struct regmap *regs;
	u32 offset;
	long unsigned int clk_rate;
	struct gpio_desc *gpiod;
	struct pwm_chip chip;
	spinlock_t lock;
	struct mvebu_gpio_chip *mvchip;
	u32 blink_select;
	u32 blink_on_duration;
	u32 blink_off_duration;
};

struct mvebu_gpio_chip {
	struct gpio_chip chip;
	struct regmap *regs;
	u32 offset;
	struct regmap *percpu_regs;
	int irqbase;
	struct irq_domain *domain;
	int soc_variant;
	struct clk *clk;
	struct mvebu_pwm *mvpwm;
	u32 out_reg;
	u32 io_conf_reg;
	u32 blink_en_reg;
	u32 in_pol_reg;
	u32 edge_mask_regs[4];
	u32 level_mask_regs[4];
};

struct mxc_gpio_hwdata {
	unsigned int dr_reg;
	unsigned int gdir_reg;
	unsigned int psr_reg;
	unsigned int icr1_reg;
	unsigned int icr2_reg;
	unsigned int imr_reg;
	unsigned int isr_reg;
	int edge_sel_reg;
	unsigned int low_level;
	unsigned int high_level;
	unsigned int rise_edge;
	unsigned int fall_edge;
};

struct mxc_gpio_reg_saved {
	u32 icr1;
	u32 icr2;
	u32 imr;
	u32 gdir;
	u32 edge_sel;
	u32 dr;
};

struct mxc_gpio_port {
	struct list_head node;
	void *base;
	struct clk *clk;
	int irq;
	int irq_high;
	struct irq_domain *domain;
	struct gpio_chip gc;
	struct device *dev;
	u32 both_edges;
	struct mxc_gpio_reg_saved gpio_saved_reg;
	bool power_off;
	const struct mxc_gpio_hwdata *hwdata;
};

struct palmas_adc_wakeup_property {
	int adc_channel_number;
	int adc_high_threshold;
	int adc_low_threshold;
};

struct palmas_gpadc_platform_data {
	int ch3_current;
	int ch0_current;
	bool extended_delay;
	int bat_removal;
	int start_polarity;
	int auto_conversion_period_ms;
	struct palmas_adc_wakeup_property *adc_wakeup1_data;
	struct palmas_adc_wakeup_property *adc_wakeup2_data;
};

struct palmas_usb_platform_data {
	int wakeup;
};

struct palmas_resource_platform_data {
	int regen1_mode_sleep;
	int regen2_mode_sleep;
	int sysen1_mode_sleep;
	int sysen2_mode_sleep;
	u8 nsleep_res;
	u8 nsleep_smps;
	u8 nsleep_ldo1;
	u8 nsleep_ldo2;
	u8 enable1_res;
	u8 enable1_smps;
	u8 enable1_ldo1;
	u8 enable1_ldo2;
	u8 enable2_res;
	u8 enable2_smps;
	u8 enable2_ldo1;
	u8 enable2_ldo2;
};

struct palmas_clk_platform_data {
	int clk32kg_mode_sleep;
	int clk32kgaudio_mode_sleep;
};

struct palmas_platform_data {
	int irq_flags;
	int gpio_base;
	u8 power_ctrl;
	int mux_from_pdata;
	u8 pad1;
	u8 pad2;
	bool pm_off;
	struct palmas_pmic_platform_data *pmic_pdata;
	struct palmas_gpadc_platform_data *gpadc_pdata;
	struct palmas_usb_platform_data *usb_pdata;
	struct palmas_resource_platform_data *resource_pdata;
	struct palmas_clk_platform_data *clk_pdata;
};

enum palmas_irqs {
	PALMAS_CHARG_DET_N_VBUS_OVV_IRQ = 0,
	PALMAS_PWRON_IRQ = 1,
	PALMAS_LONG_PRESS_KEY_IRQ = 2,
	PALMAS_RPWRON_IRQ = 3,
	PALMAS_PWRDOWN_IRQ = 4,
	PALMAS_HOTDIE_IRQ = 5,
	PALMAS_VSYS_MON_IRQ = 6,
	PALMAS_VBAT_MON_IRQ = 7,
	PALMAS_RTC_ALARM_IRQ = 8,
	PALMAS_RTC_TIMER_IRQ = 9,
	PALMAS_WDT_IRQ = 10,
	PALMAS_BATREMOVAL_IRQ = 11,
	PALMAS_RESET_IN_IRQ = 12,
	PALMAS_FBI_BB_IRQ = 13,
	PALMAS_SHORT_IRQ = 14,
	PALMAS_VAC_ACOK_IRQ = 15,
	PALMAS_GPADC_AUTO_0_IRQ = 16,
	PALMAS_GPADC_AUTO_1_IRQ = 17,
	PALMAS_GPADC_EOC_SW_IRQ = 18,
	PALMAS_GPADC_EOC_RT_IRQ = 19,
	PALMAS_ID_OTG_IRQ = 20,
	PALMAS_ID_IRQ = 21,
	PALMAS_VBUS_OTG_IRQ = 22,
	PALMAS_VBUS_IRQ = 23,
	PALMAS_GPIO_0_IRQ = 24,
	PALMAS_GPIO_1_IRQ = 25,
	PALMAS_GPIO_2_IRQ = 26,
	PALMAS_GPIO_3_IRQ = 27,
	PALMAS_GPIO_4_IRQ = 28,
	PALMAS_GPIO_5_IRQ = 29,
	PALMAS_GPIO_6_IRQ = 30,
	PALMAS_GPIO_7_IRQ = 31,
	PALMAS_NUM_IRQ = 32,
};

struct palmas_gpio {
	struct gpio_chip gpio_chip;
	struct palmas *palmas;
};

struct palmas_device_data {
	int ngpio;
};

struct amba_id {
	unsigned int id;
	unsigned int mask;
	void *data;
};

struct amba_cs_uci_id {
	unsigned int devarch;
	unsigned int devarch_mask;
	unsigned int devtype;
	void *data;
};

struct amba_device {
	struct device dev;
	struct resource res;
	struct clk *pclk;
	struct device_dma_parameters dma_parms;
	unsigned int periphid;
	unsigned int cid;
	struct amba_cs_uci_id uci;
	unsigned int irq[9];
	char *driver_override;
};

struct amba_driver {
	struct device_driver drv;
	int (*probe)(struct amba_device *, const struct amba_id *);
	void (*remove)(struct amba_device *);
	void (*shutdown)(struct amba_device *);
	const struct amba_id *id_table;
};

struct pl061_context_save_regs {
	u8 gpio_data;
	u8 gpio_dir;
	u8 gpio_is;
	u8 gpio_ibe;
	u8 gpio_iev;
	u8 gpio_ie;
};

struct pl061 {
	raw_spinlock_t lock;
	void *base;
	struct gpio_chip gc;
	struct irq_chip irq_chip;
	int parent_irq;
	struct pl061_context_save_regs csave_regs;
};

enum {
	RC5T583_IRQ_ONKEY = 0,
	RC5T583_IRQ_ACOK = 1,
	RC5T583_IRQ_LIDOPEN = 2,
	RC5T583_IRQ_PREOT = 3,
	RC5T583_IRQ_CLKSTP = 4,
	RC5T583_IRQ_ONKEY_OFF = 5,
	RC5T583_IRQ_WD = 6,
	RC5T583_IRQ_EN_PWRREQ1 = 7,
	RC5T583_IRQ_EN_PWRREQ2 = 8,
	RC5T583_IRQ_PRE_VINDET = 9,
	RC5T583_IRQ_DC0LIM = 10,
	RC5T583_IRQ_DC1LIM = 11,
	RC5T583_IRQ_DC2LIM = 12,
	RC5T583_IRQ_DC3LIM = 13,
	RC5T583_IRQ_CTC = 14,
	RC5T583_IRQ_YALE = 15,
	RC5T583_IRQ_DALE = 16,
	RC5T583_IRQ_WALE = 17,
	RC5T583_IRQ_AIN1L = 18,
	RC5T583_IRQ_AIN2L = 19,
	RC5T583_IRQ_AIN3L = 20,
	RC5T583_IRQ_VBATL = 21,
	RC5T583_IRQ_VIN3L = 22,
	RC5T583_IRQ_VIN8L = 23,
	RC5T583_IRQ_AIN1H = 24,
	RC5T583_IRQ_AIN2H = 25,
	RC5T583_IRQ_AIN3H = 26,
	RC5T583_IRQ_VBATH = 27,
	RC5T583_IRQ_VIN3H = 28,
	RC5T583_IRQ_VIN8H = 29,
	RC5T583_IRQ_ADCEND = 30,
	RC5T583_IRQ_GPIO0 = 31,
	RC5T583_IRQ_GPIO1 = 32,
	RC5T583_IRQ_GPIO2 = 33,
	RC5T583_IRQ_GPIO3 = 34,
	RC5T583_IRQ_GPIO4 = 35,
	RC5T583_IRQ_GPIO5 = 36,
	RC5T583_IRQ_GPIO6 = 37,
	RC5T583_IRQ_GPIO7 = 38,
	RC5T583_MAX_IRQS = 39,
};

enum {
	RC5T583_GPIO0 = 0,
	RC5T583_GPIO1 = 1,
	RC5T583_GPIO2 = 2,
	RC5T583_GPIO3 = 3,
	RC5T583_GPIO4 = 4,
	RC5T583_GPIO5 = 5,
	RC5T583_GPIO6 = 6,
	RC5T583_GPIO7 = 7,
	RC5T583_MAX_GPIO = 8,
};

enum {
	RC5T583_REGULATOR_DC0 = 0,
	RC5T583_REGULATOR_DC1 = 1,
	RC5T583_REGULATOR_DC2 = 2,
	RC5T583_REGULATOR_DC3 = 3,
	RC5T583_REGULATOR_LDO0 = 4,
	RC5T583_REGULATOR_LDO1 = 5,
	RC5T583_REGULATOR_LDO2 = 6,
	RC5T583_REGULATOR_LDO3 = 7,
	RC5T583_REGULATOR_LDO4 = 8,
	RC5T583_REGULATOR_LDO5 = 9,
	RC5T583_REGULATOR_LDO6 = 10,
	RC5T583_REGULATOR_LDO7 = 11,
	RC5T583_REGULATOR_LDO8 = 12,
	RC5T583_REGULATOR_LDO9 = 13,
	RC5T583_REGULATOR_MAX = 14,
};

struct rc5t583 {
	struct device *dev;
	struct regmap *regmap;
	int chip_irq;
	int irq_base;
	struct mutex irq_lock;
	long unsigned int group_irq_en[5];
	uint8_t intc_inten_reg;
	uint8_t irq_en_reg[8];
	uint8_t gpedge_reg[2];
};

struct rc5t583_platform_data {
	int irq_base;
	int gpio_base;
	bool enable_shutdown;
	int regulator_deepsleep_slot[14];
	long unsigned int regulator_ext_pwr_control[14];
	struct regulator_init_data *reg_init_data[14];
};

struct rc5t583_gpio {
	struct gpio_chip gpio_chip;
	struct rc5t583 *rc5t583;
};

struct sifive_gpio {
	void *base;
	struct gpio_chip gc;
	struct regmap *regs;
	long unsigned int irq_state;
	unsigned int trigger[32];
	unsigned int irq_number[32];
};

enum stmpe_block {
	STMPE_BLOCK_GPIO = 1,
	STMPE_BLOCK_KEYPAD = 2,
	STMPE_BLOCK_TOUCHSCREEN = 4,
	STMPE_BLOCK_ADC = 8,
	STMPE_BLOCK_PWM = 16,
	STMPE_BLOCK_ROTATOR = 32,
};

enum stmpe_partnum {
	STMPE610 = 0,
	STMPE801 = 1,
	STMPE811 = 2,
	STMPE1600 = 3,
	STMPE1601 = 4,
	STMPE1801 = 5,
	STMPE2401 = 6,
	STMPE2403 = 7,
	STMPE_NBR_PARTS = 8,
};

enum {
	STMPE_IDX_CHIP_ID = 0,
	STMPE_IDX_SYS_CTRL = 1,
	STMPE_IDX_SYS_CTRL2 = 2,
	STMPE_IDX_ICR_LSB = 3,
	STMPE_IDX_IER_LSB = 4,
	STMPE_IDX_IER_MSB = 5,
	STMPE_IDX_ISR_LSB = 6,
	STMPE_IDX_ISR_MSB = 7,
	STMPE_IDX_GPMR_LSB = 8,
	STMPE_IDX_GPMR_CSB = 9,
	STMPE_IDX_GPMR_MSB = 10,
	STMPE_IDX_GPSR_LSB = 11,
	STMPE_IDX_GPSR_CSB = 12,
	STMPE_IDX_GPSR_MSB = 13,
	STMPE_IDX_GPCR_LSB = 14,
	STMPE_IDX_GPCR_CSB = 15,
	STMPE_IDX_GPCR_MSB = 16,
	STMPE_IDX_GPDR_LSB = 17,
	STMPE_IDX_GPDR_CSB = 18,
	STMPE_IDX_GPDR_MSB = 19,
	STMPE_IDX_GPEDR_LSB = 20,
	STMPE_IDX_GPEDR_CSB = 21,
	STMPE_IDX_GPEDR_MSB = 22,
	STMPE_IDX_GPRER_LSB = 23,
	STMPE_IDX_GPRER_CSB = 24,
	STMPE_IDX_GPRER_MSB = 25,
	STMPE_IDX_GPFER_LSB = 26,
	STMPE_IDX_GPFER_CSB = 27,
	STMPE_IDX_GPFER_MSB = 28,
	STMPE_IDX_GPPUR_LSB = 29,
	STMPE_IDX_GPPDR_LSB = 30,
	STMPE_IDX_GPAFR_U_MSB = 31,
	STMPE_IDX_IEGPIOR_LSB = 32,
	STMPE_IDX_IEGPIOR_CSB = 33,
	STMPE_IDX_IEGPIOR_MSB = 34,
	STMPE_IDX_ISGPIOR_LSB = 35,
	STMPE_IDX_ISGPIOR_CSB = 36,
	STMPE_IDX_ISGPIOR_MSB = 37,
	STMPE_IDX_MAX = 38,
};

struct stmpe_client_info;

struct stmpe_variant_info;

struct stmpe_platform_data;

struct stmpe {
	struct regulator *vcc;
	struct regulator *vio;
	struct mutex lock;
	struct mutex irq_lock;
	struct device *dev;
	struct irq_domain *domain;
	void *client;
	struct stmpe_client_info *ci;
	enum stmpe_partnum partnum;
	struct stmpe_variant_info *variant;
	const u8 *regs;
	int irq;
	int num_gpios;
	u8 ier[2];
	u8 oldier[2];
	struct stmpe_platform_data *pdata;
	u8 sample_time;
	u8 mod_12b;
	u8 ref_sel;
	u8 adc_freq;
};

enum {
	REG_RE = 0,
	REG_FE = 1,
	REG_IE = 2,
};

enum {
	LSB = 0,
	CSB = 1,
	MSB = 2,
};

struct stmpe_gpio {
	struct gpio_chip chip;
	struct stmpe *stmpe;
	struct device *dev;
	struct mutex irq_lock;
	u32 norequest_mask;
	u8 regs[9];
	u8 oldregs[9];
};

struct tc3589x_platform_data;

struct tc3589x {
	struct mutex lock;
	struct device *dev;
	struct i2c_client *i2c;
	struct irq_domain *domain;
	int irq_base;
	int num_gpio;
	struct tc3589x_platform_data *pdata;
};

struct tc3589x_platform_data {
	unsigned int block;
};

enum {
	REG_IBE = 0,
	REG_IEV = 1,
	REG_IS = 2,
	REG_IE___2 = 3,
	REG_DIRECT = 4,
};

struct tc3589x_gpio {
	struct gpio_chip chip;
	struct tc3589x *tc3589x;
	struct device *dev;
	struct mutex irq_lock;
	u8 regs[15];
	u8 oldregs[15];
};

enum {
	TPS6586X_ID_SYS = 0,
	TPS6586X_ID_SM_0 = 1,
	TPS6586X_ID_SM_1 = 2,
	TPS6586X_ID_SM_2 = 3,
	TPS6586X_ID_LDO_0 = 4,
	TPS6586X_ID_LDO_1 = 5,
	TPS6586X_ID_LDO_2 = 6,
	TPS6586X_ID_LDO_3 = 7,
	TPS6586X_ID_LDO_4 = 8,
	TPS6586X_ID_LDO_5 = 9,
	TPS6586X_ID_LDO_6 = 10,
	TPS6586X_ID_LDO_7 = 11,
	TPS6586X_ID_LDO_8 = 12,
	TPS6586X_ID_LDO_9 = 13,
	TPS6586X_ID_LDO_RTC = 14,
	TPS6586X_ID_MAX_REGULATOR = 15,
};

enum {
	TPS6586X_INT_PLDO_0 = 0,
	TPS6586X_INT_PLDO_1 = 1,
	TPS6586X_INT_PLDO_2 = 2,
	TPS6586X_INT_PLDO_3 = 3,
	TPS6586X_INT_PLDO_4 = 4,
	TPS6586X_INT_PLDO_5 = 5,
	TPS6586X_INT_PLDO_6 = 6,
	TPS6586X_INT_PLDO_7 = 7,
	TPS6586X_INT_COMP_DET = 8,
	TPS6586X_INT_ADC = 9,
	TPS6586X_INT_PLDO_8 = 10,
	TPS6586X_INT_PLDO_9 = 11,
	TPS6586X_INT_PSM_0 = 12,
	TPS6586X_INT_PSM_1 = 13,
	TPS6586X_INT_PSM_2 = 14,
	TPS6586X_INT_PSM_3 = 15,
	TPS6586X_INT_RTC_ALM1 = 16,
	TPS6586X_INT_ACUSB_OVP = 17,
	TPS6586X_INT_USB_DET = 18,
	TPS6586X_INT_AC_DET = 19,
	TPS6586X_INT_BAT_DET = 20,
	TPS6586X_INT_CHG_STAT = 21,
	TPS6586X_INT_CHG_TEMP = 22,
	TPS6586X_INT_PP = 23,
	TPS6586X_INT_RESUME = 24,
	TPS6586X_INT_LOW_SYS = 25,
	TPS6586X_INT_RTC_ALM2 = 26,
};

struct tps6586x_subdev_info {
	int id;
	const char *name;
	void *platform_data;
	struct device_node *of_node;
};

struct tps6586x_platform_data {
	int num_subdevs;
	struct tps6586x_subdev_info *subdevs;
	int gpio_base;
	int irq_base;
	bool pm_off;
	struct regulator_init_data *reg_init_data[15];
};

struct tps6586x_gpio {
	struct gpio_chip gpio_chip;
	struct device *parent;
};

struct tps65910_sleep_keepon_data {
	unsigned int therm_keepon: 1;
	unsigned int clkout32k_keepon: 1;
	unsigned int i2chs_keepon: 1;
};

struct tps65910_board {
	int gpio_base;
	int irq;
	int irq_base;
	int vmbch_threshold;
	int vmbch2_threshold;
	bool en_ck32k_xtal;
	bool en_dev_slp;
	bool pm_off;
	struct tps65910_sleep_keepon_data slp_keepon;
	bool en_gpio_sleep[9];
	long unsigned int regulator_ext_sleep_control[14];
	struct regulator_init_data *tps65910_pmic_init_data[14];
};

struct tps65910 {
	struct device *dev;
	struct i2c_client *i2c_client;
	struct regmap *regmap;
	long unsigned int id;
	struct tps65910_board *of_plat_data;
	int chip_irq;
	struct regmap_irq_chip_data *irq_data;
};

struct tps65910_gpio {
	struct gpio_chip gpio_chip;
	struct tps65910 *tps65910;
};

struct tps68470_gpio_data {
	struct regmap *tps68470_regmap;
	struct gpio_chip gc;
};

struct xgene_gpio {
	struct gpio_chip chip;
	void *base;
	spinlock_t lock;
	u32 set_dr_val[3];
};

struct xgpio_instance {
	struct gpio_chip gc;
	void *regs;
	unsigned int gpio_width[2];
	u32 gpio_state[2];
	u32 gpio_last_irq_read[2];
	u32 gpio_dir[2];
	spinlock_t gpio_lock;
	int irq;
	struct irq_chip irqchip;
	u32 irq_enable[2];
	u32 irq_rising_edge[2];
	u32 irq_falling_edge[2];
	struct clk *clk;
};

enum {
	PWMF_REQUESTED = 1,
	PWMF_EXPORTED = 2,
};

struct pwm_lookup {
	struct list_head list;
	const char *provider;
	unsigned int index;
	const char *dev_id;
	const char *con_id;
	unsigned int period;
	enum pwm_polarity polarity;
	const char *module;
};

struct trace_event_raw_pwm {
	struct trace_entry ent;
	struct pwm_device *pwm;
	u64 period;
	u64 duty_cycle;
	enum pwm_polarity polarity;
	bool enabled;
	char __data[0];
};

struct trace_event_data_offsets_pwm {};

typedef void (*btf_trace_pwm_apply)(void *, struct pwm_device *, const struct pwm_state *);

typedef void (*btf_trace_pwm_get)(void *, struct pwm_device *, const struct pwm_state *);

struct pwm_export {
	struct device child;
	struct pwm_device *pwm;
	struct mutex lock;
	struct pwm_state suspend;
};

struct stmpe_pwm {
	struct stmpe *stmpe;
	struct pwm_chip chip;
	u8 last_duty;
};

enum {
	pci_channel_io_normal = 1,
	pci_channel_io_frozen = 2,
	pci_channel_io_perm_failure = 3,
};

struct pci_sriov {
	int pos;
	int nres;
	u32 cap;
	u16 ctrl;
	u16 total_VFs;
	u16 initial_VFs;
	u16 num_VFs;
	u16 offset;
	u16 stride;
	u16 vf_device;
	u32 pgsz;
	u8 link;
	u8 max_VF_buses;
	u16 driver_max_VFs;
	struct pci_dev *dev;
	struct pci_dev *self;
	u32 class;
	u8 hdr_type;
	u16 subsystem_vendor;
	u16 subsystem_device;
	resource_size_t barsz[6];
	bool drivers_autoprobe;
};

struct rcec_ea {
	u8 nextbusn;
	u8 lastbusn;
	u32 bitmap;
};

struct pci_bus_resource {
	struct list_head list;
	struct resource *res;
	unsigned int flags;
};

typedef u64 pci_bus_addr_t;

struct pci_bus_region {
	pci_bus_addr_t start;
	pci_bus_addr_t end;
};

enum pci_fixup_pass {
	pci_fixup_early = 0,
	pci_fixup_header = 1,
	pci_fixup_final = 2,
	pci_fixup_enable = 3,
	pci_fixup_resume = 4,
	pci_fixup_suspend = 5,
	pci_fixup_resume_early = 6,
	pci_fixup_suspend_late = 7,
};

struct hotplug_slot_ops;

struct hotplug_slot {
	const struct hotplug_slot_ops *ops;
	struct list_head slot_list;
	struct pci_slot *pci_slot;
	struct module *owner;
	const char *mod_name;
};

enum pci_dev_flags {
	PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
	PCI_DEV_FLAGS_NO_D3 = 2,
	PCI_DEV_FLAGS_ASSIGNED = 4,
	PCI_DEV_FLAGS_ACS_ENABLED_QUIRK = 8,
	PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS = 32,
	PCI_DEV_FLAGS_NO_BUS_RESET = 64,
	PCI_DEV_FLAGS_NO_PM_RESET = 128,
	PCI_DEV_FLAGS_VPD_REF_F0 = 256,
	PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT = 512,
	PCI_DEV_FLAGS_NO_FLR_RESET = 1024,
	PCI_DEV_FLAGS_NO_RELAXED_ORDERING = 2048,
	PCI_DEV_FLAGS_ENABLE_ASPM = 4096,
	PCI_DEV_FLAGS_HAS_MSI_MASKING = 8192,
};

enum pci_bus_flags {
	PCI_BUS_FLAGS_NO_MSI = 1,
	PCI_BUS_FLAGS_NO_MMRBC = 2,
	PCI_BUS_FLAGS_NO_AERSID = 4,
	PCI_BUS_FLAGS_NO_EXTCFG = 8,
};

enum pci_bus_speed {
	PCI_SPEED_33MHz = 0,
	PCI_SPEED_66MHz = 1,
	PCI_SPEED_66MHz_PCIX = 2,
	PCI_SPEED_100MHz_PCIX = 3,
	PCI_SPEED_133MHz_PCIX = 4,
	PCI_SPEED_66MHz_PCIX_ECC = 5,
	PCI_SPEED_100MHz_PCIX_ECC = 6,
	PCI_SPEED_133MHz_PCIX_ECC = 7,
	PCI_SPEED_66MHz_PCIX_266 = 9,
	PCI_SPEED_100MHz_PCIX_266 = 10,
	PCI_SPEED_133MHz_PCIX_266 = 11,
	AGP_UNKNOWN = 12,
	AGP_1X = 13,
	AGP_2X = 14,
	AGP_4X = 15,
	AGP_8X = 16,
	PCI_SPEED_66MHz_PCIX_533 = 17,
	PCI_SPEED_100MHz_PCIX_533 = 18,
	PCI_SPEED_133MHz_PCIX_533 = 19,
	PCIE_SPEED_2_5GT = 20,
	PCIE_SPEED_5_0GT = 21,
	PCIE_SPEED_8_0GT = 22,
	PCIE_SPEED_16_0GT = 23,
	PCIE_SPEED_32_0GT = 24,
	PCIE_SPEED_64_0GT = 25,
	PCI_SPEED_UNKNOWN = 255,
};

enum {
	PCI_REASSIGN_ALL_RSRC = 1,
	PCI_REASSIGN_ALL_BUS = 2,
	PCI_PROBE_ONLY = 4,
	PCI_CAN_SKIP_ISA_ALIGN = 8,
	PCI_ENABLE_PROC_DOMAINS = 16,
	PCI_COMPAT_DOMAIN_0 = 32,
	PCI_SCAN_ALL_PCIE_DEVS = 64,
};

struct hotplug_slot_ops {
	int (*enable_slot)(struct hotplug_slot *);
	int (*disable_slot)(struct hotplug_slot *);
	int (*set_attention_status)(struct hotplug_slot *, u8);
	int (*hardware_test)(struct hotplug_slot *, u32);
	int (*get_power_status)(struct hotplug_slot *, u8 *);
	int (*get_attention_status)(struct hotplug_slot *, u8 *);
	int (*get_latch_status)(struct hotplug_slot *, u8 *);
	int (*get_adapter_status)(struct hotplug_slot *, u8 *);
	int (*reset_slot)(struct hotplug_slot *, int);
};

enum pci_bar_type {
	pci_bar_unknown = 0,
	pci_bar_io = 1,
	pci_bar_mem32 = 2,
	pci_bar_mem64 = 3,
};

struct pci_domain_busn_res {
	struct list_head list;
	struct resource res;
	int domain_nr;
};

enum pcie_reset_state {
	pcie_deassert_reset = 1,
	pcie_warm_reset = 2,
	pcie_hot_reset = 3,
};

enum pcie_link_width {
	PCIE_LNK_WIDTH_RESRV = 0,
	PCIE_LNK_X1 = 1,
	PCIE_LNK_X2 = 2,
	PCIE_LNK_X4 = 4,
	PCIE_LNK_X8 = 8,
	PCIE_LNK_X12 = 12,
	PCIE_LNK_X16 = 16,
	PCIE_LNK_X32 = 32,
	PCIE_LNK_WIDTH_UNKNOWN = 255,
};

struct pci_cap_saved_data {
	u16 cap_nr;
	bool cap_extended;
	unsigned int size;
	u32 data[0];
};

struct pci_cap_saved_state {
	struct hlist_node next;
	struct pci_cap_saved_data cap;
};

typedef int (*arch_set_vga_state_t)(struct pci_dev *, bool, unsigned int, u32);

struct pci_platform_pm_ops {
	bool (*bridge_d3)(struct pci_dev *);
	bool (*is_manageable)(struct pci_dev *);
	int (*set_state)(struct pci_dev *, pci_power_t);
	pci_power_t (*get_state)(struct pci_dev *);
	void (*refresh_state)(struct pci_dev *);
	pci_power_t (*choose_state)(struct pci_dev *);
	int (*set_wakeup)(struct pci_dev *, bool);
	bool (*need_resume)(struct pci_dev *);
};

struct pci_pme_device {
	struct list_head list;
	struct pci_dev *dev;
};

struct pci_saved_state {
	u32 config_space[16];
	struct pci_cap_saved_data cap[0];
};

struct pci_devres {
	unsigned int enabled: 1;
	unsigned int pinned: 1;
	unsigned int orig_intx: 1;
	unsigned int restore_intx: 1;
	unsigned int mwi: 1;
	u32 region_mask;
};

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *, char *);
	ssize_t (*store)(struct device_driver *, const char *, size_t);
};

enum pci_ers_result {
	PCI_ERS_RESULT_NONE = 1,
	PCI_ERS_RESULT_CAN_RECOVER = 2,
	PCI_ERS_RESULT_NEED_RESET = 3,
	PCI_ERS_RESULT_DISCONNECT = 4,
	PCI_ERS_RESULT_RECOVERED = 5,
	PCI_ERS_RESULT_NO_AER_DRIVER = 6,
};

struct pcie_device {
	int irq;
	struct pci_dev *port;
	u32 service;
	void *priv_data;
	struct device device;
};

struct pcie_port_service_driver {
	const char *name;
	int (*probe)(struct pcie_device *);
	void (*remove)(struct pcie_device *);
	int (*suspend)(struct pcie_device *);
	int (*resume_noirq)(struct pcie_device *);
	int (*resume)(struct pcie_device *);
	int (*runtime_suspend)(struct pcie_device *);
	int (*runtime_resume)(struct pcie_device *);
	void (*error_resume)(struct pci_dev *);
	int port_type;
	u32 service;
	struct device_driver driver;
};

struct pci_dynid {
	struct list_head node;
	struct pci_device_id id;
};

struct drv_dev_and_id {
	struct pci_driver *drv;
	struct pci_dev *dev;
	const struct pci_device_id *id;
};

enum pci_mmap_state {
	pci_mmap_io = 0,
	pci_mmap_mem = 1,
};

enum pci_mmap_api {
	PCI_MMAP_SYSFS = 0,
	PCI_MMAP_PROCFS = 1,
};

struct pci_vpd_ops;

struct pci_vpd {
	const struct pci_vpd_ops *ops;
	struct mutex lock;
	unsigned int len;
	u16 flag;
	u8 cap;
	unsigned int busy: 1;
	unsigned int valid: 1;
};

struct pci_vpd_ops {
	ssize_t (*read)(struct pci_dev *, loff_t, size_t, void *);
	ssize_t (*write)(struct pci_dev *, loff_t, size_t, const void *);
};

struct pci_dev_resource {
	struct list_head list;
	struct resource *res;
	struct pci_dev *dev;
	resource_size_t start;
	resource_size_t end;
	resource_size_t add_size;
	resource_size_t min_align;
	long unsigned int flags;
};

enum release_type {
	leaf_only = 0,
	whole_subtree = 1,
};

enum enable_type {
	undefined = 4294967295,
	user_disabled = 0,
	auto_disabled = 1,
	user_enabled = 2,
	auto_enabled = 3,
};

struct msix_entry {
	u32 vector;
	u16 entry;
};

struct portdrv_service_data {
	struct pcie_port_service_driver *drv;
	struct device *dev;
	u32 service;
};

typedef int (*pcie_pm_callback_t)(struct pcie_device *);

struct walk_rcec_data {
	struct pci_dev *rcec;
	int (*user_callback)(struct pci_dev *, void *);
	void *user_data;
};

struct aspm_latency {
	u32 l0s;
	u32 l1;
};

struct pcie_link_state {
	struct pci_dev *pdev;
	struct pci_dev *downstream;
	struct pcie_link_state *root;
	struct pcie_link_state *parent;
	struct list_head sibling;
	u32 aspm_support: 7;
	u32 aspm_enabled: 7;
	u32 aspm_capable: 7;
	u32 aspm_default: 7;
	char: 4;
	u32 aspm_disable: 7;
	u32 clkpm_capable: 1;
	u32 clkpm_enabled: 1;
	u32 clkpm_default: 1;
	u32 clkpm_disable: 1;
	struct aspm_latency latency_up;
	struct aspm_latency latency_dw;
	struct aspm_latency acceptable[8];
};

enum {
	CPER_SEV_RECOVERABLE = 0,
	CPER_SEV_FATAL = 1,
	CPER_SEV_CORRECTED = 2,
	CPER_SEV_INFORMATIONAL = 3,
};

struct aer_stats {
	u64 dev_cor_errs[16];
	u64 dev_fatal_errs[27];
	u64 dev_nonfatal_errs[27];
	u64 dev_total_cor_errs;
	u64 dev_total_fatal_errs;
	u64 dev_total_nonfatal_errs;
	u64 rootport_total_cor_errs;
	u64 rootport_total_fatal_errs;
	u64 rootport_total_nonfatal_errs;
};

struct aer_header_log_regs {
	unsigned int dw0;
	unsigned int dw1;
	unsigned int dw2;
	unsigned int dw3;
};

struct aer_capability_regs {
	u32 header;
	u32 uncor_status;
	u32 uncor_mask;
	u32 uncor_severity;
	u32 cor_status;
	u32 cor_mask;
	u32 cap_control;
	struct aer_header_log_regs header_log;
	u32 root_command;
	u32 root_status;
	u16 cor_err_source;
	u16 uncor_err_source;
};

struct aer_err_info {
	struct pci_dev *dev[5];
	int error_dev_num;
	unsigned int id: 16;
	unsigned int severity: 2;
	unsigned int __pad1: 5;
	unsigned int multi_error_valid: 1;
	unsigned int first_error: 5;
	unsigned int __pad2: 2;
	unsigned int tlp_header_valid: 1;
	unsigned int status;
	unsigned int mask;
	struct aer_header_log_regs tlp;
};

struct aer_err_source {
	unsigned int status;
	unsigned int id;
};

struct aer_rpc {
	struct pci_dev *rpd;
	struct {
		union {
			struct __kfifo kfifo;
			struct aer_err_source *type;
			const struct aer_err_source *const_type;
			char (*rectype)[0];
			struct aer_err_source *ptr;
			const struct aer_err_source *ptr_const;
		};
		struct aer_err_source buf[128];
	} aer_fifo;
};

struct aer_recover_entry {
	u8 bus;
	u8 devfn;
	u16 domain;
	int severity;
	struct aer_capability_regs *regs;
};

struct pcie_pme_service_data {
	spinlock_t lock;
	struct pcie_device *srv;
	struct work_struct work;
	bool noirq;
};

struct pci_slot_attribute {
	struct attribute attr;
	ssize_t (*show)(struct pci_slot *, char *);
	ssize_t (*store)(struct pci_slot *, const char *, size_t);
};

struct acpi_buffer {
	acpi_size length;
	void *pointer;
};

struct acpi_bus_type {
	struct list_head list;
	const char *name;
	bool (*match)(struct device *);
	struct acpi_device * (*find_companion)(struct device *);
	void (*setup)(struct device *);
	void (*cleanup)(struct device *);
};

enum pm_qos_flags_status {
	PM_QOS_FLAGS_UNDEFINED = 4294967295,
	PM_QOS_FLAGS_NONE = 0,
	PM_QOS_FLAGS_SOME = 1,
	PM_QOS_FLAGS_ALL = 2,
};

struct hpx_type0 {
	u32 revision;
	u8 cache_line_size;
	u8 latency_timer;
	u8 enable_serr;
	u8 enable_perr;
};

struct hpx_type1 {
	u32 revision;
	u8 max_mem_read;
	u8 avg_max_split;
	u16 tot_max_split;
};

struct hpx_type2 {
	u32 revision;
	u32 unc_err_mask_and;
	u32 unc_err_mask_or;
	u32 unc_err_sever_and;
	u32 unc_err_sever_or;
	u32 cor_err_mask_and;
	u32 cor_err_mask_or;
	u32 adv_err_cap_and;
	u32 adv_err_cap_or;
	u16 pci_exp_devctl_and;
	u16 pci_exp_devctl_or;
	u16 pci_exp_lnkctl_and;
	u16 pci_exp_lnkctl_or;
	u32 sec_unc_err_sever_and;
	u32 sec_unc_err_sever_or;
	u32 sec_unc_err_mask_and;
	u32 sec_unc_err_mask_or;
};

struct hpx_type3 {
	u16 device_type;
	u16 function_type;
	u16 config_space_location;
	u16 pci_exp_cap_id;
	u16 pci_exp_cap_ver;
	u16 pci_exp_vendor_id;
	u16 dvsec_id;
	u16 dvsec_rev;
	u16 match_offset;
	u32 match_mask_and;
	u32 match_value;
	u16 reg_offset;
	u32 reg_mask_and;
	u32 reg_mask_or;
};

enum hpx_type3_dev_type {
	HPX_TYPE_ENDPOINT = 1,
	HPX_TYPE_LEG_END = 2,
	HPX_TYPE_RC_END = 4,
	HPX_TYPE_RC_EC = 8,
	HPX_TYPE_ROOT_PORT = 16,
	HPX_TYPE_UPSTREAM = 32,
	HPX_TYPE_DOWNSTREAM = 64,
	HPX_TYPE_PCI_BRIDGE = 128,
	HPX_TYPE_PCIE_BRIDGE = 256,
};

enum hpx_type3_fn_type {
	HPX_FN_NORMAL = 1,
	HPX_FN_SRIOV_PHYS = 2,
	HPX_FN_SRIOV_VIRT = 4,
};

enum hpx_type3_cfg_loc {
	HPX_CFG_PCICFG = 0,
	HPX_CFG_PCIE_CAP = 1,
	HPX_CFG_PCIE_CAP_EXT = 2,
	HPX_CFG_VEND_CAP = 3,
	HPX_CFG_DVSEC = 4,
	HPX_CFG_MAX = 5,
};

struct of_bus;

struct of_pci_range_parser {
	struct device_node *node;
	struct of_bus *bus;
	const __be32 *range;
	const __be32 *end;
	int na;
	int ns;
	int pna;
	bool dma;
};

struct of_pci_range {
	union {
		u64 pci_addr;
		u64 bus_addr;
	};
	u64 cpu_addr;
	u64 size;
	u32 flags;
};

struct pci_fixup {
	u16 vendor;
	u16 device;
	u32 class;
	unsigned int class_shift;
	int hook_offset;
};

enum {
	NVME_REG_CAP = 0,
	NVME_REG_VS = 8,
	NVME_REG_INTMS = 12,
	NVME_REG_INTMC = 16,
	NVME_REG_CC = 20,
	NVME_REG_CSTS = 28,
	NVME_REG_NSSR = 32,
	NVME_REG_AQA = 36,
	NVME_REG_ASQ = 40,
	NVME_REG_ACQ = 48,
	NVME_REG_CMBLOC = 56,
	NVME_REG_CMBSZ = 60,
	NVME_REG_BPINFO = 64,
	NVME_REG_BPRSEL = 68,
	NVME_REG_BPMBL = 72,
	NVME_REG_CMBMSC = 80,
	NVME_REG_PMRCAP = 3584,
	NVME_REG_PMRCTL = 3588,
	NVME_REG_PMRSTS = 3592,
	NVME_REG_PMREBS = 3596,
	NVME_REG_PMRSWTP = 3600,
	NVME_REG_DBS = 4096,
};

enum {
	NVME_CC_ENABLE = 1,
	NVME_CC_EN_SHIFT = 0,
	NVME_CC_CSS_SHIFT = 4,
	NVME_CC_MPS_SHIFT = 7,
	NVME_CC_AMS_SHIFT = 11,
	NVME_CC_SHN_SHIFT = 14,
	NVME_CC_IOSQES_SHIFT = 16,
	NVME_CC_IOCQES_SHIFT = 20,
	NVME_CC_CSS_NVM = 0,
	NVME_CC_CSS_CSI = 96,
	NVME_CC_CSS_MASK = 112,
	NVME_CC_AMS_RR = 0,
	NVME_CC_AMS_WRRU = 2048,
	NVME_CC_AMS_VS = 14336,
	NVME_CC_SHN_NONE = 0,
	NVME_CC_SHN_NORMAL = 16384,
	NVME_CC_SHN_ABRUPT = 32768,
	NVME_CC_SHN_MASK = 49152,
	NVME_CC_IOSQES = 393216,
	NVME_CC_IOCQES = 4194304,
	NVME_CAP_CSS_NVM = 1,
	NVME_CAP_CSS_CSI = 64,
	NVME_CSTS_RDY = 1,
	NVME_CSTS_CFS = 2,
	NVME_CSTS_NSSRO = 16,
	NVME_CSTS_PP = 32,
	NVME_CSTS_SHST_NORMAL = 0,
	NVME_CSTS_SHST_OCCUR = 4,
	NVME_CSTS_SHST_CMPLT = 8,
	NVME_CSTS_SHST_MASK = 12,
	NVME_CMBMSC_CRE = 1,
	NVME_CMBMSC_CMSE = 2,
};

enum {
	NVME_AEN_BIT_NS_ATTR = 8,
	NVME_AEN_BIT_FW_ACT = 9,
	NVME_AEN_BIT_ANA_CHANGE = 11,
	NVME_AEN_BIT_DISC_CHANGE = 31,
};

enum {
	SWITCHTEC_GAS_MRPC_OFFSET = 0,
	SWITCHTEC_GAS_TOP_CFG_OFFSET = 4096,
	SWITCHTEC_GAS_SW_EVENT_OFFSET = 6144,
	SWITCHTEC_GAS_SYS_INFO_OFFSET = 8192,
	SWITCHTEC_GAS_FLASH_INFO_OFFSET = 8704,
	SWITCHTEC_GAS_PART_CFG_OFFSET = 16384,
	SWITCHTEC_GAS_NTB_OFFSET = 65536,
	SWITCHTEC_GAS_PFF_CSR_OFFSET = 1261568,
};

enum {
	SWITCHTEC_NTB_REG_INFO_OFFSET = 0,
	SWITCHTEC_NTB_REG_CTRL_OFFSET = 16384,
	SWITCHTEC_NTB_REG_DBMSG_OFFSET = 409600,
};

struct nt_partition_info {
	u32 xlink_enabled;
	u32 target_part_low;
	u32 target_part_high;
	u32 reserved;
};

struct ntb_info_regs {
	u8 partition_count;
	u8 partition_id;
	u16 reserved1;
	u64 ep_map;
	u16 requester_id;
	u16 reserved2;
	u32 reserved3[4];
	struct nt_partition_info ntp_info[48];
} __attribute__((packed));

struct ntb_ctrl_regs {
	u32 partition_status;
	u32 partition_op;
	u32 partition_ctrl;
	u32 bar_setup;
	u32 bar_error;
	u16 lut_table_entries;
	u16 lut_table_offset;
	u32 lut_error;
	u16 req_id_table_size;
	u16 req_id_table_offset;
	u32 req_id_error;
	u32 reserved1[7];
	struct {
		u32 ctl;
		u32 win_size;
		u64 xlate_addr;
	} bar_entry[6];
	struct {
		u32 win_size;
		u32 reserved[3];
	} bar_ext_entry[6];
	u32 reserved2[192];
	u32 req_id_table[512];
	u32 reserved3[256];
	u64 lut_entry[512];
};

struct pci_dev_reset_methods {
	u16 vendor;
	u16 device;
	int (*reset)(struct pci_dev *, int);
};

struct pci_dev_acs_enabled {
	u16 vendor;
	u16 device;
	int (*acs_enabled)(struct pci_dev *, u16);
};

struct pci_dev_acs_ops {
	u16 vendor;
	u16 device;
	int (*enable_acs)(struct pci_dev *);
	int (*disable_acs_redir)(struct pci_dev *);
};

struct slot {
	u8 number;
	unsigned int devfn;
	struct pci_bus *bus;
	struct pci_dev *dev;
	unsigned int latch_status: 1;
	unsigned int adapter_status: 1;
	unsigned int extracting;
	struct hotplug_slot hotplug_slot;
	struct list_head slot_list;
};

struct cpci_hp_controller_ops {
	int (*query_enum)();
	int (*enable_irq)();
	int (*disable_irq)();
	int (*check_irq)(void *);
	int (*hardware_test)(struct slot *, u32);
	u8 (*get_power)(struct slot *);
	int (*set_power)(struct slot *, int);
};

struct cpci_hp_controller {
	unsigned int irq;
	long unsigned int irq_flags;
	char *devname;
	void *dev_id;
	char *name;
	struct cpci_hp_controller_ops *ops;
};

struct controller {
	struct pcie_device *pcie;
	u32 slot_cap;
	unsigned int inband_presence_disabled: 1;
	u16 slot_ctrl;
	struct mutex ctrl_lock;
	long unsigned int cmd_started;
	unsigned int cmd_busy: 1;
	wait_queue_head_t queue;
	atomic_t pending_events;
	unsigned int notification_enabled: 1;
	unsigned int power_fault_detected;
	struct task_struct *poll_thread;
	u8 state;
	struct mutex state_lock;
	struct delayed_work button_work;
	struct hotplug_slot hotplug_slot;
	struct rw_semaphore reset_lock;
	unsigned int depth;
	unsigned int ist_running;
	int request_result;
	wait_queue_head_t requester;
};

struct controller___2;

struct hpc_ops;

struct slot___2 {
	u8 bus;
	u8 device;
	u16 status;
	u32 number;
	u8 is_a_board;
	u8 state;
	u8 attention_save;
	u8 presence_save;
	u8 latch_save;
	u8 pwr_save;
	struct controller___2 *ctrl;
	const struct hpc_ops *hpc_ops;
	struct hotplug_slot hotplug_slot;
	struct list_head slot_list;
	struct delayed_work work;
	struct mutex lock;
	struct workqueue_struct *wq;
	u8 hp_slot;
};

struct controller___2 {
	struct mutex crit_sect;
	struct mutex cmd_lock;
	int num_slots;
	int slot_num_inc;
	struct pci_dev *pci_dev;
	struct list_head slot_list;
	const struct hpc_ops *hpc_ops;
	wait_queue_head_t queue;
	u8 slot_device_offset;
	u32 pcix_misc2_reg;
	u32 first_slot;
	u32 cap_offset;
	long unsigned int mmio_base;
	long unsigned int mmio_size;
	void *creg;
	struct timer_list poll_timer;
};

struct hpc_ops {
	int (*power_on_slot)(struct slot___2 *);
	int (*slot_enable)(struct slot___2 *);
	int (*slot_disable)(struct slot___2 *);
	int (*set_bus_speed_mode)(struct slot___2 *, enum pci_bus_speed);
	int (*get_power_status)(struct slot___2 *, u8 *);
	int (*get_attention_status)(struct slot___2 *, u8 *);
	int (*set_attention_status)(struct slot___2 *, u8);
	int (*get_latch_status)(struct slot___2 *, u8 *);
	int (*get_adapter_status)(struct slot___2 *, u8 *);
	int (*get_adapter_speed)(struct slot___2 *, enum pci_bus_speed *);
	int (*get_mode1_ECC_cap)(struct slot___2 *, u8 *);
	int (*get_prog_int)(struct slot___2 *, u8 *);
	int (*query_power_fault)(struct slot___2 *);
	void (*green_led_on)(struct slot___2 *);
	void (*green_led_off)(struct slot___2 *);
	void (*green_led_blink)(struct slot___2 *);
	void (*release_ctlr)(struct controller___2 *);
	int (*check_cmd_status)(struct controller___2 *);
};

struct event_info {
	u32 event_type;
	struct slot___2 *p_slot;
	struct work_struct work;
};

struct pushbutton_work_info {
	struct slot___2 *p_slot;
	struct work_struct work;
};

enum ctrl_offsets {
	BASE_OFFSET = 0,
	SLOT_AVAIL1 = 4,
	SLOT_AVAIL2 = 8,
	SLOT_CONFIG = 12,
	SEC_BUS_CONFIG = 16,
	MSI_CTRL = 18,
	PROG_INTERFACE = 19,
	CMD = 20,
	CMD_STATUS = 22,
	INTR_LOC = 24,
	SERR_LOC = 28,
	SERR_INTR_ENABLE = 32,
	SLOT1 = 36,
};

struct acpiphp_slot;

struct slot___3 {
	struct hotplug_slot hotplug_slot;
	struct acpiphp_slot *acpi_slot;
	unsigned int sun;
};

struct acpiphp_slot {
	struct list_head node;
	struct pci_bus *bus;
	struct list_head funcs;
	struct slot___3 *slot;
	u8 device;
	u32 flags;
};

struct acpiphp_attention_info {
	int (*set_attn)(struct hotplug_slot *, u8);
	int (*get_attn)(struct hotplug_slot *, u8 *);
	struct module *owner;
};

struct acpiphp_context;

struct acpiphp_bridge {
	struct list_head list;
	struct list_head slots;
	struct kref ref;
	struct acpiphp_context *context;
	int nr_slots;
	struct pci_bus *pci_bus;
	struct pci_dev *pci_dev;
	bool is_going_away;
};

struct acpiphp_func {
	struct acpiphp_bridge *parent;
	struct acpiphp_slot *slot;
	struct list_head sibling;
	u8 function;
	u32 flags;
};

struct acpiphp_context {
	struct acpi_hotplug_context hp;
	struct acpiphp_func func;
	struct acpiphp_bridge *bridge;
	unsigned int refcount;
};

struct acpiphp_root_context {
	struct acpi_hotplug_context hp;
	struct acpiphp_bridge *root_bridge;
};

struct pci_bridge_emul_conf {
	__le16 vendor;
	__le16 device;
	__le16 command;
	__le16 status;
	__le32 class_revision;
	u8 cache_line_size;
	u8 latency_timer;
	u8 header_type;
	u8 bist;
	__le32 bar[2];
	u8 primary_bus;
	u8 secondary_bus;
	u8 subordinate_bus;
	u8 secondary_latency_timer;
	u8 iobase;
	u8 iolimit;
	__le16 secondary_status;
	__le16 membase;
	__le16 memlimit;
	__le16 pref_mem_base;
	__le16 pref_mem_limit;
	__le32 prefbaseupper;
	__le32 preflimitupper;
	__le16 iobaseupper;
	__le16 iolimitupper;
	u8 capabilities_pointer;
	u8 reserve[3];
	__le32 romaddr;
	u8 intline;
	u8 intpin;
	__le16 bridgectrl;
};

struct pci_bridge_emul_pcie_conf {
	u8 cap_id;
	u8 next;
	__le16 cap;
	__le32 devcap;
	__le16 devctl;
	__le16 devsta;
	__le32 lnkcap;
	__le16 lnkctl;
	__le16 lnksta;
	__le32 slotcap;
	__le16 slotctl;
	__le16 slotsta;
	__le16 rootctl;
	__le16 rootcap;
	__le32 rootsta;
	__le32 devcap2;
	__le16 devctl2;
	__le16 devsta2;
	__le32 lnkcap2;
	__le16 lnkctl2;
	__le16 lnksta2;
	__le32 slotcap2;
	__le16 slotctl2;
	__le16 slotsta2;
};

typedef enum {
	PCI_BRIDGE_EMUL_HANDLED = 0,
	PCI_BRIDGE_EMUL_NOT_HANDLED = 1,
} pci_bridge_emul_read_status_t;

struct pci_bridge_emul;

struct pci_bridge_emul_ops {
	pci_bridge_emul_read_status_t (*read_base)(struct pci_bridge_emul *, int, u32 *);
	pci_bridge_emul_read_status_t (*read_pcie)(struct pci_bridge_emul *, int, u32 *);
	void (*write_base)(struct pci_bridge_emul *, int, u32, u32, u32);
	void (*write_pcie)(struct pci_bridge_emul *, int, u32, u32, u32);
};

struct pci_bridge_reg_behavior;

struct pci_bridge_emul {
	struct pci_bridge_emul_conf conf;
	struct pci_bridge_emul_pcie_conf pcie_conf;
	struct pci_bridge_emul_ops *ops;
	struct pci_bridge_reg_behavior *pci_regs_behavior;
	struct pci_bridge_reg_behavior *pcie_cap_regs_behavior;
	void *data;
	bool has_pcie;
};

struct pci_bridge_reg_behavior {
	u32 ro;
	u32 rw;
	u32 w1c;
};

enum {
	PCI_BRIDGE_EMUL_NO_PREFETCHABLE_BAR = 1,
};

enum dmi_device_type {
	DMI_DEV_TYPE_ANY = 0,
	DMI_DEV_TYPE_OTHER = 1,
	DMI_DEV_TYPE_UNKNOWN = 2,
	DMI_DEV_TYPE_VIDEO = 3,
	DMI_DEV_TYPE_SCSI = 4,
	DMI_DEV_TYPE_ETHERNET = 5,
	DMI_DEV_TYPE_TOKENRING = 6,
	DMI_DEV_TYPE_SOUND = 7,
	DMI_DEV_TYPE_PATA = 8,
	DMI_DEV_TYPE_SATA = 9,
	DMI_DEV_TYPE_SAS = 10,
	DMI_DEV_TYPE_IPMI = 4294967295,
	DMI_DEV_TYPE_OEM_STRING = 4294967294,
	DMI_DEV_TYPE_DEV_ONBOARD = 4294967293,
	DMI_DEV_TYPE_DEV_SLOT = 4294967292,
};

struct dmi_device {
	struct list_head list;
	int type;
	const char *name;
	void *device_data;
};

struct dmi_dev_onboard {
	struct dmi_device dev;
	int instance;
	int segment;
	int bus;
	int devfn;
};

enum smbios_attr_enum {
	SMBIOS_ATTR_NONE = 0,
	SMBIOS_ATTR_LABEL_SHOW = 1,
	SMBIOS_ATTR_INSTANCE_SHOW = 2,
};

enum acpi_attr_enum {
	ACPI_ATTR_LABEL_SHOW = 0,
	ACPI_ATTR_INDEX_SHOW = 1,
};

struct pci_epf_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

enum pci_interrupt_pin {
	PCI_INTERRUPT_UNKNOWN = 0,
	PCI_INTERRUPT_INTA = 1,
	PCI_INTERRUPT_INTB = 2,
	PCI_INTERRUPT_INTC = 3,
	PCI_INTERRUPT_INTD = 4,
};

enum pci_barno {
	NO_BAR = 4294967295,
	BAR_0 = 0,
	BAR_1 = 1,
	BAR_2 = 2,
	BAR_3 = 3,
	BAR_4 = 4,
	BAR_5 = 5,
};

struct pci_epf_header {
	u16 vendorid;
	u16 deviceid;
	u8 revid;
	u8 progif_code;
	u8 subclass_code;
	u8 baseclass_code;
	u8 cache_line_size;
	u16 subsys_vendor_id;
	u16 subsys_id;
	enum pci_interrupt_pin interrupt_pin;
};

struct pci_epf;

struct pci_epf_ops {
	int (*bind)(struct pci_epf *);
	void (*unbind)(struct pci_epf *);
	struct config_group * (*add_cfs)(struct pci_epf *, struct config_group *);
};

struct pci_epf_bar {
	dma_addr_t phys_addr;
	void *addr;
	size_t size;
	enum pci_barno barno;
	int flags;
};

struct pci_epc;

struct pci_epf_driver;

struct pci_epf {
	struct device dev;
	const char *name;
	struct pci_epf_header *header;
	struct pci_epf_bar bar[6];
	u8 msi_interrupts;
	u16 msix_interrupts;
	u8 func_no;
	struct pci_epc *epc;
	struct pci_epf_driver *driver;
	struct list_head list;
	struct notifier_block nb;
	struct mutex lock;
	struct pci_epc *sec_epc;
	struct list_head sec_epc_list;
	struct pci_epf_bar sec_epc_bar[6];
	u8 sec_epc_func_no;
	struct config_group *group;
};

struct pci_epf_driver {
	int (*probe)(struct pci_epf *);
	int (*remove)(struct pci_epf *);
	struct device_driver driver;
	struct pci_epf_ops *ops;
	struct module *owner;
	struct list_head epf_group;
	const struct pci_epf_device_id *id_table;
};

struct pci_epc_ops;

struct pci_epc_mem;

struct pci_epc {
	struct device dev;
	struct list_head pci_epf;
	const struct pci_epc_ops *ops;
	struct pci_epc_mem **windows;
	struct pci_epc_mem *mem;
	unsigned int num_windows;
	u8 max_functions;
	struct config_group *group;
	struct mutex lock;
	long unsigned int function_num_map;
	struct atomic_notifier_head notifier;
};

enum pci_epc_interface_type {
	UNKNOWN_INTERFACE = 4294967295,
	PRIMARY_INTERFACE = 0,
	SECONDARY_INTERFACE = 1,
};

enum pci_epc_irq_type {
	PCI_EPC_IRQ_UNKNOWN = 0,
	PCI_EPC_IRQ_LEGACY = 1,
	PCI_EPC_IRQ_MSI = 2,
	PCI_EPC_IRQ_MSIX = 3,
};

struct pci_epc_features;

struct pci_epc_ops {
	int (*write_header)(struct pci_epc *, u8, struct pci_epf_header *);
	int (*set_bar)(struct pci_epc *, u8, struct pci_epf_bar *);
	void (*clear_bar)(struct pci_epc *, u8, struct pci_epf_bar *);
	int (*map_addr)(struct pci_epc *, u8, phys_addr_t, u64, size_t);
	void (*unmap_addr)(struct pci_epc *, u8, phys_addr_t);
	int (*set_msi)(struct pci_epc *, u8, u8);
	int (*get_msi)(struct pci_epc *, u8);
	int (*set_msix)(struct pci_epc *, u8, u16, enum pci_barno, u32);
	int (*get_msix)(struct pci_epc *, u8);
	int (*raise_irq)(struct pci_epc *, u8, enum pci_epc_irq_type, u16);
	int (*map_msi_irq)(struct pci_epc *, u8, phys_addr_t, u8, u32, u32 *, u32 *);
	int (*start)(struct pci_epc *);
	void (*stop)(struct pci_epc *);
	const struct pci_epc_features * (*get_features)(struct pci_epc *, u8);
	struct module *owner;
};

struct pci_epc_features {
	unsigned int linkup_notifier: 1;
	unsigned int core_init_notifier: 1;
	unsigned int msi_capable: 1;
	unsigned int msix_capable: 1;
	u8 reserved_bar;
	u8 bar_fixed_64bit;
	u64 bar_fixed_size[6];
	size_t align;
};

struct pci_epc_mem_window {
	phys_addr_t phys_base;
	size_t size;
	size_t page_size;
};

struct pci_epc_mem {
	struct pci_epc_mem_window window;
	long unsigned int *bitmap;
	int pages;
	struct mutex lock;
};

struct pci_epf_group {
	struct config_group group;
	struct config_group primary_epc_group;
	struct config_group secondary_epc_group;
	struct delayed_work cfs_work;
	struct pci_epf *epf;
	int index;
};

struct pci_epc_group {
	struct config_group group;
	struct pci_epc *epc;
	bool start;
};

enum pci_notify_event {
	CORE_INIT = 0,
	LINK_UP = 1,
};

struct cdns_pcie;

struct cdns_pcie_ops {
	int (*start_link)(struct cdns_pcie *);
	void (*stop_link)(struct cdns_pcie *);
	bool (*link_up)(struct cdns_pcie *);
	u64 (*cpu_addr_fixup)(struct cdns_pcie *, u64);
};

struct cdns_pcie {
	void *reg_base;
	struct resource *mem_res;
	struct device *dev;
	bool is_rc;
	int phy_count;
	struct phy **phy;
	struct device_link **link;
	const struct cdns_pcie_ops *ops;
};

enum cdns_pcie_rp_bar {
	RP_BAR_UNDEFINED = 4294967295,
	RP_BAR0 = 0,
	RP_BAR1 = 1,
	RP_NO_BAR = 2,
};

struct cdns_pcie_rc {
	struct cdns_pcie pcie;
	struct resource *cfg_res;
	void *cfg_base;
	u32 vendor_id;
	u32 device_id;
	bool avail_ib_bar[3];
	unsigned int quirk_retrain_flag: 1;
	unsigned int quirk_detect_quiet_flag: 1;
};

struct pci_epf_msix_tbl {
	u64 msg_addr;
	u32 msg_data;
	u32 vector_ctrl;
};

enum cdns_pcie_msg_code {
	MSG_CODE_ASSERT_INTA = 32,
	MSG_CODE_ASSERT_INTB = 33,
	MSG_CODE_ASSERT_INTC = 34,
	MSG_CODE_ASSERT_INTD = 35,
	MSG_CODE_DEASSERT_INTA = 36,
	MSG_CODE_DEASSERT_INTB = 37,
	MSG_CODE_DEASSERT_INTC = 38,
	MSG_CODE_DEASSERT_INTD = 39,
};

enum cdns_pcie_msg_routing {
	MSG_ROUTING_TO_RC = 0,
	MSG_ROUTING_BY_ADDR = 1,
	MSG_ROUTING_BY_ID = 2,
	MSG_ROUTING_BCAST = 3,
	MSG_ROUTING_LOCAL = 4,
	MSG_ROUTING_GATHER = 5,
};

struct cdns_pcie_epf {
	struct pci_epf_bar *epf_bar[6];
};

struct cdns_pcie_ep {
	struct cdns_pcie pcie;
	u32 max_regions;
	long unsigned int ob_region_map;
	phys_addr_t *ob_addr;
	phys_addr_t irq_phys_addr;
	void *irq_cpu_addr;
	u64 irq_pci_addr;
	u8 irq_pci_fn;
	u8 irq_pending;
	spinlock_t lock;
	struct cdns_pcie_epf *epf;
	unsigned int quirk_detect_quiet_flag: 1;
};

struct cdns_plat_pcie {
	struct cdns_pcie *pcie;
	bool is_rc;
};

struct cdns_plat_pcie_of_data {
	bool is_rc;
};

enum link_status {
	NO_RECEIVERS_DETECTED = 0,
	LINK_TRAINING_IN_PROGRESS = 1,
	LINK_UP_DL_IN_PROGRESS = 2,
	LINK_UP_DL_COMPLETED = 3,
};

struct j721e_pcie {
	struct device *dev;
	struct clk *refclk;
	u32 mode;
	u32 num_lanes;
	struct cdns_pcie *cdns_pcie;
	void *user_cfg_base;
	void *intd_cfg_base;
	u32 linkdown_irq_regfield;
};

enum j721e_pcie_mode {
	PCI_MODE_RC = 0,
	PCI_MODE_EP = 1,
};

struct j721e_pcie_data {
	enum j721e_pcie_mode mode;
	unsigned int quirk_retrain_flag: 1;
	unsigned int quirk_detect_quiet_flag: 1;
	u32 linkdown_irq_regfield;
	unsigned int byte_access_allowed: 1;
};

struct faraday_pci_variant {
	bool cascaded_irq;
};

struct faraday_pci {
	struct device *dev;
	void *base;
	struct irq_domain *irqdomain;
	struct pci_bus *bus;
	struct clk *bus_clk;
};

enum {
	LTSSM_DETECT_QUIET = 0,
	LTSSM_DETECT_ACTIVE = 1,
	LTSSM_POLLING_ACTIVE = 2,
	LTSSM_POLLING_COMPLIANCE = 3,
	LTSSM_POLLING_CONFIGURATION = 4,
	LTSSM_CONFIG_LINKWIDTH_START = 5,
	LTSSM_CONFIG_LINKWIDTH_ACCEPT = 6,
	LTSSM_CONFIG_LANENUM_ACCEPT = 7,
	LTSSM_CONFIG_LANENUM_WAIT = 8,
	LTSSM_CONFIG_COMPLETE = 9,
	LTSSM_CONFIG_IDLE = 10,
	LTSSM_RECOVERY_RCVR_LOCK = 11,
	LTSSM_RECOVERY_SPEED = 12,
	LTSSM_RECOVERY_RCVR_CFG = 13,
	LTSSM_RECOVERY_IDLE = 14,
	LTSSM_L0 = 16,
	LTSSM_RX_L0S_ENTRY = 17,
	LTSSM_RX_L0S_IDLE = 18,
	LTSSM_RX_L0S_FTS = 19,
	LTSSM_TX_L0S_ENTRY = 20,
	LTSSM_TX_L0S_IDLE = 21,
	LTSSM_TX_L0S_FTS = 22,
	LTSSM_L1_ENTRY = 23,
	LTSSM_L1_IDLE = 24,
	LTSSM_L2_IDLE = 25,
	LTSSM_L2_TRANSMIT_WAKE = 26,
	LTSSM_DISABLED = 32,
	LTSSM_LOOPBACK_ENTRY_MASTER = 33,
	LTSSM_LOOPBACK_ACTIVE_MASTER = 34,
	LTSSM_LOOPBACK_EXIT_MASTER = 35,
	LTSSM_LOOPBACK_ENTRY_SLAVE = 36,
	LTSSM_LOOPBACK_ACTIVE_SLAVE = 37,
	LTSSM_LOOPBACK_EXIT_SLAVE = 38,
	LTSSM_HOT_RESET = 39,
	LTSSM_RECOVERY_EQUALIZATION_PHASE0 = 40,
	LTSSM_RECOVERY_EQUALIZATION_PHASE1 = 41,
	LTSSM_RECOVERY_EQUALIZATION_PHASE2 = 42,
	LTSSM_RECOVERY_EQUALIZATION_PHASE3 = 43,
};

struct advk_pcie {
	struct platform_device *pdev;
	void *base;
	struct {
		phys_addr_t match;
		phys_addr_t remap;
		phys_addr_t mask;
		u32 actions;
	} wins[8];
	u8 wins_count;
	struct irq_domain *irq_domain;
	struct irq_chip irq_chip;
	raw_spinlock_t irq_lock;
	struct irq_domain *msi_domain;
	struct irq_domain *msi_inner_domain;
	struct irq_chip msi_bottom_irq_chip;
	struct irq_chip msi_irq_chip;
	struct msi_domain_info msi_domain_info;
	long unsigned int msi_used[1];
	struct mutex msi_used_lock;
	u16 msi_msg;
	int link_gen;
	struct pci_bridge_emul bridge;
	struct gpio_desc *reset_gpio;
	struct phy *phy;
};

struct rcar_pcie {
	struct device *dev;
	void *base;
};

enum {
	RCAR_PCI_ACCESS_READ = 0,
	RCAR_PCI_ACCESS_WRITE = 1,
};

struct rcar_msi {
	long unsigned int used[1];
	struct irq_domain *domain;
	struct mutex map_lock;
	spinlock_t mask_lock;
	int irq1;
	int irq2;
};

struct rcar_pcie_host {
	struct rcar_pcie pcie;
	struct phy *phy;
	struct clk *bus_clk;
	struct rcar_msi msi;
	int (*phy_init_fn)(struct rcar_pcie_host *);
};

struct rcar_pcie_endpoint {
	struct rcar_pcie pcie;
	phys_addr_t *ob_mapped_addr;
	struct pci_epc_mem_window *ob_window;
	u8 max_functions;
	unsigned int bar_to_atu[6];
	long unsigned int *ib_window_map;
	u32 num_ib_windows;
	u32 num_ob_windows;
};

struct thunder_pem_pci {
	u32 ea_entry[3];
	void *pem_reg_base;
};

struct xilinx_pcie_port {
	void *reg_base;
	struct device *dev;
	long unsigned int msi_map[2];
	struct mutex map_lock;
	struct irq_domain *msi_domain;
	struct irq_domain *leg_domain;
	struct list_head resources;
};

struct nwl_msi {
	struct irq_domain *msi_domain;
	long unsigned int *bitmap;
	struct irq_domain *dev_domain;
	struct mutex lock;
	int irq_msi0;
	int irq_msi1;
};

struct nwl_pcie {
	struct device *dev;
	void *breg_base;
	void *pcireg_base;
	void *ecam_base;
	phys_addr_t phys_breg_base;
	phys_addr_t phys_pcie_reg_base;
	phys_addr_t phys_ecam_base;
	u32 breg_size;
	u32 pcie_reg_size;
	u32 ecam_size;
	int irq_intx;
	int irq_misc;
	u32 ecam_value;
	u8 last_busno;
	struct nwl_msi msi;
	struct irq_domain *legacy_irq_domain;
	struct clk *clk;
	raw_spinlock_t leg_mask_lock;
};

struct xilinx_cpm_pcie_port {
	void *reg_base;
	void *cpm_base;
	struct device *dev;
	struct irq_domain *intx_domain;
	struct irq_domain *cpm_domain;
	struct pci_config_window *cfg;
	int intx_irq;
	int irq;
	raw_spinlock_t lock;
};

struct xgene_pcie_port {
	struct device_node *node;
	struct device *dev;
	struct clk *clk;
	void *csr_base;
	void *cfg_base;
	long unsigned int cfg_addr;
	bool link_up;
	u32 version;
};

struct xgene_msi;

struct xgene_msi_group {
	struct xgene_msi *msi;
	int gic_irq;
	u32 msi_grp;
};

struct xgene_msi {
	struct device_node *node;
	struct irq_domain *inner_domain;
	struct irq_domain *msi_domain;
	u64 msi_addr;
	void *msi_regs;
	long unsigned int *bitmap;
	struct mutex bitmap_lock;
	struct xgene_msi_group *msi_groups;
	int num_cpus;
};

enum iproc_pcie_type {
	IPROC_PCIE_PAXB_BCMA = 0,
	IPROC_PCIE_PAXB = 1,
	IPROC_PCIE_PAXB_V2 = 2,
	IPROC_PCIE_PAXC = 3,
	IPROC_PCIE_PAXC_V2 = 4,
};

struct iproc_pcie_ob {
	resource_size_t axi_offset;
	unsigned int nr_windows;
};

struct iproc_pcie_ib {
	unsigned int nr_regions;
};

struct iproc_pcie_ob_map;

struct iproc_pcie_ib_map;

struct iproc_msi;

struct iproc_pcie {
	struct device *dev;
	enum iproc_pcie_type type;
	u16 *reg_offsets;
	void *base;
	phys_addr_t base_addr;
	struct resource mem;
	struct phy *phy;
	int (*map_irq)(const struct pci_dev *, u8, u8);
	bool ep_is_internal;
	bool iproc_cfg_read;
	bool rej_unconfig_pf;
	bool has_apb_err_disable;
	bool fix_paxc_cap;
	bool need_ob_cfg;
	struct iproc_pcie_ob ob;
	const struct iproc_pcie_ob_map *ob_map;
	bool need_ib_cfg;
	struct iproc_pcie_ib ib;
	const struct iproc_pcie_ib_map *ib_map;
	bool need_msi_steer;
	struct iproc_msi *msi;
};

struct iproc_msi_grp;

struct iproc_msi {
	struct iproc_pcie *pcie;
	const u16 (*reg_offsets)[8];
	struct iproc_msi_grp *grps;
	int nr_irqs;
	int nr_cpus;
	bool has_inten_reg;
	long unsigned int *bitmap;
	struct mutex bitmap_lock;
	unsigned int nr_msi_vecs;
	struct irq_domain *inner_domain;
	struct irq_domain *msi_domain;
	unsigned int nr_eq_region;
	unsigned int nr_msi_region;
	void *eq_cpu;
	dma_addr_t eq_dma;
	phys_addr_t msi_addr;
};

enum iproc_msi_reg {
	IPROC_MSI_EQ_PAGE = 0,
	IPROC_MSI_EQ_PAGE_UPPER = 1,
	IPROC_MSI_PAGE = 2,
	IPROC_MSI_PAGE_UPPER = 3,
	IPROC_MSI_CTRL = 4,
	IPROC_MSI_EQ_HEAD = 5,
	IPROC_MSI_EQ_TAIL = 6,
	IPROC_MSI_INTS_EN = 7,
	IPROC_MSI_REG_SIZE = 8,
};

struct iproc_msi_grp {
	struct iproc_msi *msi;
	int gic_irq;
	unsigned int eq;
};

enum altera_pcie_version {
	ALTERA_PCIE_V1 = 0,
	ALTERA_PCIE_V2 = 1,
};

struct altera_pcie_data;

struct altera_pcie {
	struct platform_device *pdev;
	void *cra_base;
	void *hip_base;
	int irq;
	u8 root_bus_nr;
	struct irq_domain *irq_domain;
	struct resource bus_range;
	const struct altera_pcie_data *pcie_data;
};

struct altera_pcie_ops;

struct altera_pcie_data {
	const struct altera_pcie_ops *ops;
	enum altera_pcie_version version;
	u32 cap_offset;
	u32 cfgrd0;
	u32 cfgrd1;
	u32 cfgwr0;
	u32 cfgwr1;
};

struct altera_pcie_ops {
	int (*tlp_read_pkt)(struct altera_pcie *, u32 *);
	void (*tlp_write_pkt)(struct altera_pcie *, u32 *, u32, bool);
	bool (*get_link_status)(struct altera_pcie *);
	int (*rp_read_cfg)(struct altera_pcie *, int, int, u32 *);
	int (*rp_write_cfg)(struct altera_pcie *, u8, int, int, u32);
};

struct tlp_rp_regpair_t {
	u32 ctrl;
	u32 reg0;
	u32 reg1;
};

struct altera_msi {
	long unsigned int used[1];
	struct mutex lock;
	struct platform_device *pdev;
	struct irq_domain *msi_domain;
	struct irq_domain *inner_domain;
	void *csr_base;
	void *vector_base;
	phys_addr_t vector_phy;
	u32 num_of_vectors;
	int irq;
};

struct rockchip_pcie {
	void *reg_base;
	void *apb_base;
	bool legacy_phy;
	struct phy *phys[4];
	struct reset_control *core_rst;
	struct reset_control *mgmt_rst;
	struct reset_control *mgmt_sticky_rst;
	struct reset_control *pipe_rst;
	struct reset_control *pm_rst;
	struct reset_control *aclk_rst;
	struct reset_control *pclk_rst;
	struct clk *aclk_pcie;
	struct clk *aclk_perf_pcie;
	struct clk *hclk_pcie;
	struct clk *clk_pcie_pm;
	struct regulator *vpcie12v;
	struct regulator *vpcie3v3;
	struct regulator *vpcie1v8;
	struct regulator *vpcie0v9;
	struct gpio_desc *ep_gpio;
	u32 lanes;
	u8 lanes_map;
	int link_gen;
	struct device *dev;
	struct irq_domain *irq_domain;
	int offset;
	void *msg_region;
	phys_addr_t msg_bus_addr;
	bool is_rc;
	struct resource *mem_res;
};

struct rockchip_pcie_ep {
	struct rockchip_pcie rockchip;
	struct pci_epc *epc;
	u32 max_regions;
	long unsigned int ob_region_map;
	phys_addr_t *ob_addr;
	phys_addr_t irq_phys_addr;
	void *irq_cpu_addr;
	u64 irq_pci_addr;
	u8 irq_pci_fn;
	u8 irq_pending;
};

struct mtk_pcie_port;

struct mtk_pcie_soc {
	bool need_fix_class_id;
	bool need_fix_device_id;
	bool no_msi;
	unsigned int device_id;
	struct pci_ops *ops;
	int (*startup)(struct mtk_pcie_port *);
	int (*setup_irq)(struct mtk_pcie_port *, struct device_node *);
};

struct mtk_pcie;

struct mtk_pcie_port {
	void *base;
	struct list_head list;
	struct mtk_pcie *pcie;
	struct reset_control *reset;
	struct clk *sys_ck;
	struct clk *ahb_ck;
	struct clk *axi_ck;
	struct clk *aux_ck;
	struct clk *obff_ck;
	struct clk *pipe_ck;
	struct phy *phy;
	u32 slot;
	int irq;
	struct irq_domain *irq_domain;
	struct irq_domain *inner_domain;
	struct irq_domain *msi_domain;
	struct mutex lock;
	long unsigned int msi_irq_in_use[1];
};

struct mtk_pcie {
	struct device *dev;
	void *base;
	struct clk *free_ck;
	struct list_head ports;
	const struct mtk_pcie_soc *soc;
};

struct event_map {
	u32 reg_mask;
	u32 event_bit;
};

struct mc_msi {
	struct mutex lock;
	struct irq_domain *msi_domain;
	struct irq_domain *dev_domain;
	u32 num_vectors;
	u64 vector_phy;
	long unsigned int used[1];
};

struct mc_port {
	void *axi_base_addr;
	struct device *dev;
	struct irq_domain *intx_domain;
	struct irq_domain *event_domain;
	raw_spinlock_t lock;
	struct mc_msi msi;
};

struct cause {
	const char *sym;
	const char *str;
};

struct acpi_object_list {
	u32 count;
	union acpi_object *pointer;
};

struct acpi_hest_generic_data {
	u8 section_type[16];
	u32 error_severity;
	u16 revision;
	u8 validation_bits;
	u8 flags;
	u32 error_data_length;
	u8 fru_id[16];
	u8 fru_text[20];
};

struct acpi_hest_generic_data_v300 {
	u8 section_type[16];
	u32 error_severity;
	u16 revision;
	u8 validation_bits;
	u8 flags;
	u32 error_data_length;
	u8 fru_id[16];
	u8 fru_text[20];
	u64 time_stamp;
};

struct hisi_pcie_error_data {
	u64 val_bits;
	u8 version;
	u8 soc_id;
	u8 socket_id;
	u8 nimbus_id;
	u8 sub_module_id;
	u8 core_id;
	u8 port_id;
	u8 err_severity;
	u16 err_type;
	u8 reserv[2];
	u32 err_misc[33];
};

struct hisi_pcie_error_private {
	struct notifier_block nb;
	struct device *dev;
};

enum hisi_pcie_submodule_id {
	HISI_PCIE_SUB_MODULE_ID_AP = 0,
	HISI_PCIE_SUB_MODULE_ID_TL = 1,
	HISI_PCIE_SUB_MODULE_ID_MAC = 2,
	HISI_PCIE_SUB_MODULE_ID_DL = 3,
	HISI_PCIE_SUB_MODULE_ID_SDI = 4,
};

enum hisi_pcie_err_severity {
	HISI_PCIE_ERR_SEV_RECOVERABLE = 0,
	HISI_PCIE_ERR_SEV_FATAL = 1,
	HISI_PCIE_ERR_SEV_CORRECTED = 2,
	HISI_PCIE_ERR_SEV_NONE = 3,
};

enum dw_pcie_region_type {
	DW_PCIE_REGION_UNKNOWN = 0,
	DW_PCIE_REGION_INBOUND = 1,
	DW_PCIE_REGION_OUTBOUND = 2,
};

struct pcie_port;

struct dw_pcie_host_ops {
	int (*host_init)(struct pcie_port *);
	int (*msi_host_init)(struct pcie_port *);
};

struct pcie_port {
	bool has_msi_ctrl: 1;
	u64 cfg0_base;
	void *va_cfg0_base;
	u32 cfg0_size;
	resource_size_t io_base;
	phys_addr_t io_bus_addr;
	u32 io_size;
	int irq;
	const struct dw_pcie_host_ops *ops;
	int msi_irq;
	struct irq_domain *irq_domain;
	struct irq_domain *msi_domain;
	u16 msi_msg;
	dma_addr_t msi_data;
	struct irq_chip *msi_irq_chip;
	u32 num_vectors;
	u32 irq_mask[8];
	struct pci_host_bridge *bridge;
	raw_spinlock_t lock;
	long unsigned int msi_irq_in_use[4];
};

enum dw_pcie_as_type {
	DW_PCIE_AS_UNKNOWN = 0,
	DW_PCIE_AS_MEM = 1,
	DW_PCIE_AS_IO = 2,
};

struct dw_pcie_ep;

struct dw_pcie_ep_ops {
	void (*ep_init)(struct dw_pcie_ep *);
	int (*raise_irq)(struct dw_pcie_ep *, u8, enum pci_epc_irq_type, u16);
	const struct pci_epc_features * (*get_features)(struct dw_pcie_ep *);
	unsigned int (*func_conf_select)(struct dw_pcie_ep *, u8);
};

struct dw_pcie_ep {
	struct pci_epc *epc;
	struct list_head func_list;
	const struct dw_pcie_ep_ops *ops;
	phys_addr_t phys_base;
	size_t addr_size;
	size_t page_size;
	u8 bar_to_atu[6];
	phys_addr_t *outbound_addr;
	long unsigned int *ib_window_map;
	long unsigned int *ob_window_map;
	void *msi_mem;
	phys_addr_t msi_mem_phys;
	struct pci_epf_bar *epf_bar[6];
};

struct dw_pcie;

struct dw_pcie_ops {
	u64 (*cpu_addr_fixup)(struct dw_pcie *, u64);
	u32 (*read_dbi)(struct dw_pcie *, void *, u32, size_t);
	void (*write_dbi)(struct dw_pcie *, void *, u32, size_t, u32);
	void (*write_dbi2)(struct dw_pcie *, void *, u32, size_t, u32);
	int (*link_up)(struct dw_pcie *);
	int (*start_link)(struct dw_pcie *);
	void (*stop_link)(struct dw_pcie *);
};

struct dw_pcie {
	struct device *dev;
	void *dbi_base;
	void *dbi_base2;
	void *atu_base;
	size_t atu_size;
	u32 num_ib_windows;
	u32 num_ob_windows;
	struct pcie_port pp;
	struct dw_pcie_ep ep;
	const struct dw_pcie_ops *ops;
	unsigned int version;
	int num_lanes;
	int link_gen;
	u8 n_fts[2];
	bool iatu_unroll_enabled: 1;
	bool io_cfg_atu_shared: 1;
};

struct dw_pcie_ep_func {
	struct list_head list;
	u8 func_no;
	u8 msi_cap;
	u8 msix_cap;
};

enum dw_pcie_device_mode {
	DW_PCIE_UNKNOWN_TYPE = 0,
	DW_PCIE_EP_TYPE = 1,
	DW_PCIE_LEG_EP_TYPE = 2,
	DW_PCIE_RC_TYPE = 3,
};

struct dw_plat_pcie {
	struct dw_pcie *pci;
	struct regmap *regmap;
	enum dw_pcie_device_mode mode;
};

struct dw_plat_pcie_of_data {
	enum dw_pcie_device_mode mode;
};

struct pm_domain_data {
	struct list_head list_node;
	struct device *dev;
};

struct dev_power_governor {
	bool (*power_down_ok)(struct dev_pm_domain *);
	bool (*suspend_ok)(struct device *);
};

enum imx6_pcie_variants {
	IMX6Q = 0,
	IMX6SX = 1,
	IMX6QP = 2,
	IMX7D = 3,
	IMX8MQ = 4,
};

struct imx6_pcie_drvdata {
	enum imx6_pcie_variants variant;
	u32 flags;
	int dbi_length;
};

struct imx6_pcie {
	struct dw_pcie *pci;
	int reset_gpio;
	bool gpio_active_high;
	struct clk *pcie_bus;
	struct clk *pcie_phy;
	struct clk *pcie_inbound_axi;
	struct clk *pcie;
	struct clk *pcie_aux;
	struct regmap *iomuxc_gpr;
	u32 controller_id;
	struct reset_control *pciephy_reset;
	struct reset_control *apps_reset;
	struct reset_control *turnoff_reset;
	u32 tx_deemph_gen1;
	u32 tx_deemph_gen2_3p5db;
	u32 tx_deemph_gen2_6db;
	u32 tx_swing_full;
	u32 tx_swing_low;
	struct regulator *vpcie;
	void *phy_base;
	struct device *pd_pcie;
	struct device *pd_pcie_phy;
	const struct imx6_pcie_drvdata *drvdata;
};

struct ks_pcie_of_data {
	enum dw_pcie_device_mode mode;
	const struct dw_pcie_host_ops *host_ops;
	const struct dw_pcie_ep_ops *ep_ops;
	unsigned int version;
};

struct keystone_pcie {
	struct dw_pcie *pci;
	u32 device_id;
	int legacy_host_irqs[4];
	struct device_node *legacy_intc_np;
	int msi_host_irq;
	int num_lanes;
	u32 num_viewport;
	struct phy **phy;
	struct device_link **link;
	struct device_node *msi_intc_np;
	struct irq_domain *legacy_irq_domain;
	struct device_node *np;
	void *va_app_base;
	struct resource app;
	bool is_am6;
};

struct ls_pcie_drvdata {
	u32 lut_offset;
	u32 ltssm_shift;
	u32 lut_dbg;
	const struct dw_pcie_host_ops *ops;
	const struct dw_pcie_ops *dw_pcie_ops;
};

struct ls_pcie {
	struct dw_pcie *pci;
	void *lut;
	struct regmap *scfg;
	const struct ls_pcie_drvdata *drvdata;
	int index;
};

struct ls_pcie_ep_drvdata {
	u32 func_offset;
	const struct dw_pcie_ep_ops *ops;
	const struct dw_pcie_ops *dw_pcie_ops;
};

struct ls_pcie_ep {
	struct dw_pcie *pci;
	struct pci_epc_features *ls_epc;
	const struct ls_pcie_ep_drvdata *drvdata;
};

struct clk_bulk_data {
	const char *id;
	struct clk *clk;
};

struct regulator_bulk_data {
	const char *supply;
	struct regulator *consumer;
	int ret;
};

struct qcom_pcie_resources_2_1_0 {
	struct clk_bulk_data clks[5];
	struct reset_control *pci_reset;
	struct reset_control *axi_reset;
	struct reset_control *ahb_reset;
	struct reset_control *por_reset;
	struct reset_control *phy_reset;
	struct reset_control *ext_reset;
	struct regulator_bulk_data supplies[3];
};

struct qcom_pcie_resources_1_0_0 {
	struct clk *iface;
	struct clk *aux;
	struct clk *master_bus;
	struct clk *slave_bus;
	struct reset_control *core;
	struct regulator *vdda;
};

struct qcom_pcie_resources_2_3_2 {
	struct clk *aux_clk;
	struct clk *master_clk;
	struct clk *slave_clk;
	struct clk *cfg_clk;
	struct clk *pipe_clk;
	struct regulator_bulk_data supplies[2];
};

struct qcom_pcie_resources_2_4_0 {
	struct clk_bulk_data clks[4];
	int num_clks;
	struct reset_control *axi_m_reset;
	struct reset_control *axi_s_reset;
	struct reset_control *pipe_reset;
	struct reset_control *axi_m_vmid_reset;
	struct reset_control *axi_s_xpu_reset;
	struct reset_control *parf_reset;
	struct reset_control *phy_reset;
	struct reset_control *axi_m_sticky_reset;
	struct reset_control *pipe_sticky_reset;
	struct reset_control *pwr_reset;
	struct reset_control *ahb_reset;
	struct reset_control *phy_ahb_reset;
};

struct qcom_pcie_resources_2_3_3 {
	struct clk *iface;
	struct clk *axi_m_clk;
	struct clk *axi_s_clk;
	struct clk *ahb_clk;
	struct clk *aux_clk;
	struct reset_control *rst[7];
};

struct qcom_pcie_resources_2_7_0 {
	struct clk_bulk_data clks[7];
	int num_clks;
	struct regulator_bulk_data supplies[2];
	struct reset_control *pci_reset;
	struct clk *pipe_clk;
};

union qcom_pcie_resources {
	struct qcom_pcie_resources_1_0_0 v1_0_0;
	struct qcom_pcie_resources_2_1_0 v2_1_0;
	struct qcom_pcie_resources_2_3_2 v2_3_2;
	struct qcom_pcie_resources_2_3_3 v2_3_3;
	struct qcom_pcie_resources_2_4_0 v2_4_0;
	struct qcom_pcie_resources_2_7_0 v2_7_0;
};

struct qcom_pcie;

struct qcom_pcie_ops {
	int (*get_resources)(struct qcom_pcie *);
	int (*init)(struct qcom_pcie *);
	int (*post_init)(struct qcom_pcie *);
	void (*deinit)(struct qcom_pcie *);
	void (*post_deinit)(struct qcom_pcie *);
	void (*ltssm_enable)(struct qcom_pcie *);
	int (*config_sid)(struct qcom_pcie *);
};

struct qcom_pcie {
	struct dw_pcie *pci;
	void *parf;
	void *elbi;
	union qcom_pcie_resources res;
	struct phy *phy;
	struct gpio_desc *reset;
	const struct qcom_pcie_ops *ops;
};

struct armada8k_pcie {
	struct dw_pcie *pci;
	struct clk *clk;
	struct clk *clk_reg;
	struct phy *phy[4];
	unsigned int phy_count;
};

struct kirin_pcie {
	struct dw_pcie *pci;
	void *apb_base;
	void *phy_base;
	struct regmap *crgctrl;
	struct regmap *sysctrl;
	struct clk *apb_sys_clk;
	struct clk *apb_phy_clk;
	struct clk *phy_ref_clk;
	struct clk *pcie_aclk;
	struct clk *pcie_aux_clk;
	int gpio_id_reset;
};

struct histb_pcie {
	struct dw_pcie *pci;
	struct clk *aux_clk;
	struct clk *pipe_clk;
	struct clk *sys_clk;
	struct clk *bus_clk;
	struct phy *phy;
	struct reset_control *soft_reset;
	struct reset_control *sys_reset;
	struct reset_control *bus_reset;
	void *ctrl;
	int reset_gpio;
	struct regulator *vpcie;
};

struct al_pcie_acpi {
	void *dbi_base;
};

struct al_pcie_reg_offsets {
	unsigned int ob_ctrl;
};

struct al_pcie_target_bus_cfg {
	u8 reg_val;
	u8 reg_mask;
	u8 ecam_mask;
};

struct al_pcie {
	struct dw_pcie *pci;
	void *controller_base;
	struct device *dev;
	resource_size_t ecam_size;
	unsigned int controller_rev_id;
	struct al_pcie_reg_offsets reg_offsets;
	struct al_pcie_target_bus_cfg target_bus_cfg;
};

struct tegra194_pcie_ecam {
	void *config_base;
	void *iatu_base;
	void *dbi_base;
};

struct rio_device_id {
	__u16 did;
	__u16 vid;
	__u16 asm_did;
	__u16 asm_vid;
};

typedef s32 dma_cookie_t;

enum dma_status {
	DMA_COMPLETE = 0,
	DMA_IN_PROGRESS = 1,
	DMA_PAUSED = 2,
	DMA_ERROR = 3,
	DMA_OUT_OF_ORDER = 4,
};

enum dma_transaction_type {
	DMA_MEMCPY = 0,
	DMA_XOR = 1,
	DMA_PQ = 2,
	DMA_XOR_VAL = 3,
	DMA_PQ_VAL = 4,
	DMA_MEMSET = 5,
	DMA_MEMSET_SG = 6,
	DMA_INTERRUPT = 7,
	DMA_PRIVATE = 8,
	DMA_ASYNC_TX = 9,
	DMA_SLAVE = 10,
	DMA_CYCLIC = 11,
	DMA_INTERLEAVE = 12,
	DMA_COMPLETION_NO_ORDER = 13,
	DMA_REPEAT = 14,
	DMA_LOAD_EOT = 15,
	DMA_TX_TYPE_END = 16,
};

enum dma_transfer_direction {
	DMA_MEM_TO_MEM = 0,
	DMA_MEM_TO_DEV = 1,
	DMA_DEV_TO_MEM = 2,
	DMA_DEV_TO_DEV = 3,
	DMA_TRANS_NONE = 4,
};

struct data_chunk {
	size_t size;
	size_t icg;
	size_t dst_icg;
	size_t src_icg;
};

struct dma_interleaved_template {
	dma_addr_t src_start;
	dma_addr_t dst_start;
	enum dma_transfer_direction dir;
	bool src_inc;
	bool dst_inc;
	bool src_sgl;
	bool dst_sgl;
	size_t numf;
	size_t frame_size;
	struct data_chunk sgl[0];
};

enum dma_ctrl_flags {
	DMA_PREP_INTERRUPT = 1,
	DMA_CTRL_ACK = 2,
	DMA_PREP_PQ_DISABLE_P = 4,
	DMA_PREP_PQ_DISABLE_Q = 8,
	DMA_PREP_CONTINUE = 16,
	DMA_PREP_FENCE = 32,
	DMA_CTRL_REUSE = 64,
	DMA_PREP_CMD = 128,
	DMA_PREP_REPEAT = 256,
	DMA_PREP_LOAD_EOT = 512,
};

enum sum_check_bits {
	SUM_CHECK_P = 0,
	SUM_CHECK_Q = 1,
};

enum sum_check_flags {
	SUM_CHECK_P_RESULT = 1,
	SUM_CHECK_Q_RESULT = 2,
};

typedef struct {
	long unsigned int bits[1];
} dma_cap_mask_t;

enum dma_desc_metadata_mode {
	DESC_METADATA_NONE = 0,
	DESC_METADATA_CLIENT = 1,
	DESC_METADATA_ENGINE = 2,
};

struct dma_chan_percpu {
	long unsigned int memcpy_count;
	long unsigned int bytes_transferred;
};

struct dma_router {
	struct device *dev;
	void (*route_free)(struct device *, void *);
};

struct dma_device;

struct dma_chan_dev;

struct dma_chan {
	struct dma_device *device;
	struct device *slave;
	dma_cookie_t cookie;
	dma_cookie_t completed_cookie;
	int chan_id;
	struct dma_chan_dev *dev;
	const char *name;
	char *dbg_client_name;
	struct list_head device_node;
	struct dma_chan_percpu *local;
	int client_count;
	int table_count;
	struct dma_router *router;
	void *route_data;
	void *private;
};

typedef bool (*dma_filter_fn)(struct dma_chan *, void *);

struct dma_slave_map;

struct dma_filter {
	dma_filter_fn fn;
	int mapcnt;
	const struct dma_slave_map *map;
};

enum dmaengine_alignment {
	DMAENGINE_ALIGN_1_BYTE = 0,
	DMAENGINE_ALIGN_2_BYTES = 1,
	DMAENGINE_ALIGN_4_BYTES = 2,
	DMAENGINE_ALIGN_8_BYTES = 3,
	DMAENGINE_ALIGN_16_BYTES = 4,
	DMAENGINE_ALIGN_32_BYTES = 5,
	DMAENGINE_ALIGN_64_BYTES = 6,
	DMAENGINE_ALIGN_128_BYTES = 7,
	DMAENGINE_ALIGN_256_BYTES = 8,
};

enum dma_residue_granularity {
	DMA_RESIDUE_GRANULARITY_DESCRIPTOR = 0,
	DMA_RESIDUE_GRANULARITY_SEGMENT = 1,
	DMA_RESIDUE_GRANULARITY_BURST = 2,
};

struct dma_async_tx_descriptor;

struct dma_slave_caps;

struct dma_slave_config;

struct dma_tx_state;

struct dma_device {
	struct kref ref;
	unsigned int chancnt;
	unsigned int privatecnt;
	struct list_head channels;
	struct list_head global_node;
	struct dma_filter filter;
	dma_cap_mask_t cap_mask;
	enum dma_desc_metadata_mode desc_metadata_modes;
	short unsigned int max_xor;
	short unsigned int max_pq;
	enum dmaengine_alignment copy_align;
	enum dmaengine_alignment xor_align;
	enum dmaengine_alignment pq_align;
	enum dmaengine_alignment fill_align;
	int dev_id;
	struct device *dev;
	struct module *owner;
	struct ida chan_ida;
	struct mutex chan_mutex;
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool descriptor_reuse;
	enum dma_residue_granularity residue_granularity;
	int (*device_alloc_chan_resources)(struct dma_chan *);
	int (*device_router_config)(struct dma_chan *);
	void (*device_free_chan_resources)(struct dma_chan *);
	struct dma_async_tx_descriptor * (*device_prep_dma_memcpy)(struct dma_chan *, dma_addr_t, dma_addr_t, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor)(struct dma_chan *, dma_addr_t, dma_addr_t *, unsigned int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor_val)(struct dma_chan *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq_val)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset)(struct dma_chan *, dma_addr_t, int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset_sg)(struct dma_chan *, struct scatterlist *, unsigned int, int, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_interrupt)(struct dma_chan *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_slave_sg)(struct dma_chan *, struct scatterlist *, unsigned int, enum dma_transfer_direction, long unsigned int, void *);
	struct dma_async_tx_descriptor * (*device_prep_dma_cyclic)(struct dma_chan *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_interleaved_dma)(struct dma_chan *, struct dma_interleaved_template *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_imm_data)(struct dma_chan *, dma_addr_t, u64, long unsigned int);
	void (*device_caps)(struct dma_chan *, struct dma_slave_caps *);
	int (*device_config)(struct dma_chan *, struct dma_slave_config *);
	int (*device_pause)(struct dma_chan *);
	int (*device_resume)(struct dma_chan *);
	int (*device_terminate_all)(struct dma_chan *);
	void (*device_synchronize)(struct dma_chan *);
	enum dma_status (*device_tx_status)(struct dma_chan *, dma_cookie_t, struct dma_tx_state *);
	void (*device_issue_pending)(struct dma_chan *);
	void (*device_release)(struct dma_device *);
	void (*dbg_summary_show)(struct seq_file *, struct dma_device *);
	struct dentry *dbg_dev_root;
};

struct dma_chan_dev {
	struct dma_chan *chan;
	struct device device;
	int dev_id;
	bool chan_dma_dev;
};

enum dma_slave_buswidth {
	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
	DMA_SLAVE_BUSWIDTH_3_BYTES = 3,
	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
	DMA_SLAVE_BUSWIDTH_16_BYTES = 16,
	DMA_SLAVE_BUSWIDTH_32_BYTES = 32,
	DMA_SLAVE_BUSWIDTH_64_BYTES = 64,
};

struct dma_slave_config {
	enum dma_transfer_direction direction;
	phys_addr_t src_addr;
	phys_addr_t dst_addr;
	enum dma_slave_buswidth src_addr_width;
	enum dma_slave_buswidth dst_addr_width;
	u32 src_maxburst;
	u32 dst_maxburst;
	u32 src_port_window_size;
	u32 dst_port_window_size;
	bool device_fc;
	unsigned int slave_id;
	void *peripheral_config;
	size_t peripheral_size;
};

struct dma_slave_caps {
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool cmd_pause;
	bool cmd_resume;
	bool cmd_terminate;
	enum dma_residue_granularity residue_granularity;
	bool descriptor_reuse;
};

typedef void (*dma_async_tx_callback)(void *);

enum dmaengine_tx_result {
	DMA_TRANS_NOERROR = 0,
	DMA_TRANS_READ_FAILED = 1,
	DMA_TRANS_WRITE_FAILED = 2,
	DMA_TRANS_ABORTED = 3,
};

struct dmaengine_result {
	enum dmaengine_tx_result result;
	u32 residue;
};

typedef void (*dma_async_tx_callback_result)(void *, const struct dmaengine_result *);

struct dmaengine_unmap_data {
	u16 map_cnt;
	u8 to_cnt;
	u8 from_cnt;
	u8 bidi_cnt;
	struct device *dev;
	struct kref kref;
	size_t len;
	dma_addr_t addr[0];
};

struct dma_descriptor_metadata_ops {
	int (*attach)(struct dma_async_tx_descriptor *, void *, size_t);
	void * (*get_ptr)(struct dma_async_tx_descriptor *, size_t *, size_t *);
	int (*set_len)(struct dma_async_tx_descriptor *, size_t);
};

struct dma_async_tx_descriptor {
	dma_cookie_t cookie;
	enum dma_ctrl_flags flags;
	dma_addr_t phys;
	struct dma_chan *chan;
	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *);
	int (*desc_free)(struct dma_async_tx_descriptor *);
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
	struct dmaengine_unmap_data *unmap;
	enum dma_desc_metadata_mode desc_metadata_mode;
	struct dma_descriptor_metadata_ops *metadata_ops;
	struct dma_async_tx_descriptor *next;
	struct dma_async_tx_descriptor *parent;
	spinlock_t lock;
};

struct dma_tx_state {
	dma_cookie_t last;
	dma_cookie_t used;
	u32 residue;
	u32 in_flight_bytes;
};

struct dma_slave_map {
	const char *devname;
	const char *slave;
	void *param;
};

struct rio_switch_ops;

struct rio_dev;

struct rio_switch {
	struct list_head node;
	u8 *route_table;
	u32 port_ok;
	struct rio_switch_ops *ops;
	spinlock_t lock;
	struct rio_dev *nextdev[0];
};

struct rio_mport;

struct rio_switch_ops {
	struct module *owner;
	int (*add_entry)(struct rio_mport *, u16, u8, u16, u16, u8);
	int (*get_entry)(struct rio_mport *, u16, u8, u16, u16, u8 *);
	int (*clr_table)(struct rio_mport *, u16, u8, u16);
	int (*set_domain)(struct rio_mport *, u16, u8, u8);
	int (*get_domain)(struct rio_mport *, u16, u8, u8 *);
	int (*em_init)(struct rio_dev *);
	int (*em_handle)(struct rio_dev *, u8);
};

struct rio_net;

struct rio_driver;

union rio_pw_msg;

struct rio_dev {
	struct list_head global_list;
	struct list_head net_list;
	struct rio_net *net;
	bool do_enum;
	u16 did;
	u16 vid;
	u32 device_rev;
	u16 asm_did;
	u16 asm_vid;
	u16 asm_rev;
	u16 efptr;
	u32 pef;
	u32 swpinfo;
	u32 src_ops;
	u32 dst_ops;
	u32 comp_tag;
	u32 phys_efptr;
	u32 phys_rmap;
	u32 em_efptr;
	u64 dma_mask;
	struct rio_driver *driver;
	struct device dev;
	struct resource riores[16];
	int (*pwcback)(struct rio_dev *, union rio_pw_msg *, int);
	u16 destid;
	u8 hopcount;
	struct rio_dev *prev;
	atomic_t state;
	struct rio_switch rswitch[0];
};

struct rio_msg {
	struct resource *res;
	void (*mcback)(struct rio_mport *, void *, int, int);
};

struct rio_ops;

struct rio_scan;

struct rio_mport {
	struct list_head dbells;
	struct list_head pwrites;
	struct list_head node;
	struct list_head nnode;
	struct rio_net *net;
	struct mutex lock;
	struct resource iores;
	struct resource riores[16];
	struct rio_msg inb_msg[4];
	struct rio_msg outb_msg[4];
	int host_deviceid;
	struct rio_ops *ops;
	unsigned char id;
	unsigned char index;
	unsigned int sys_size;
	u32 phys_efptr;
	u32 phys_rmap;
	unsigned char name[40];
	struct device dev;
	void *priv;
	struct dma_device dma;
	struct rio_scan *nscan;
	atomic_t state;
	unsigned int pwe_refcnt;
};

enum rio_device_state {
	RIO_DEVICE_INITIALIZING = 0,
	RIO_DEVICE_RUNNING = 1,
	RIO_DEVICE_GONE = 2,
	RIO_DEVICE_SHUTDOWN = 3,
};

struct rio_net {
	struct list_head node;
	struct list_head devices;
	struct list_head switches;
	struct list_head mports;
	struct rio_mport *hport;
	unsigned char id;
	struct device dev;
	void *enum_data;
	void (*release)(struct rio_net *);
};

struct rio_driver {
	struct list_head node;
	char *name;
	const struct rio_device_id *id_table;
	int (*probe)(struct rio_dev *, const struct rio_device_id *);
	void (*remove)(struct rio_dev *);
	void (*shutdown)(struct rio_dev *);
	int (*suspend)(struct rio_dev *, u32);
	int (*resume)(struct rio_dev *);
	int (*enable_wake)(struct rio_dev *, u32, int);
	struct device_driver driver;
};

union rio_pw_msg {
	struct {
		u32 comptag;
		u32 errdetect;
		u32 is_port;
		u32 ltlerrdet;
		u32 padding[12];
	} em;
	u32 raw[16];
};

struct rio_dbell {
	struct list_head node;
	struct resource *res;
	void (*dinb)(struct rio_mport *, void *, u16, u16, u16);
	void *dev_id;
};

struct rio_mport_attr;

struct rio_ops {
	int (*lcread)(struct rio_mport *, int, u32, int, u32 *);
	int (*lcwrite)(struct rio_mport *, int, u32, int, u32);
	int (*cread)(struct rio_mport *, int, u16, u8, u32, int, u32 *);
	int (*cwrite)(struct rio_mport *, int, u16, u8, u32, int, u32);
	int (*dsend)(struct rio_mport *, int, u16, u16);
	int (*pwenable)(struct rio_mport *, int);
	int (*open_outb_mbox)(struct rio_mport *, void *, int, int);
	void (*close_outb_mbox)(struct rio_mport *, int);
	int (*open_inb_mbox)(struct rio_mport *, void *, int, int);
	void (*close_inb_mbox)(struct rio_mport *, int);
	int (*add_outb_message)(struct rio_mport *, struct rio_dev *, int, void *, size_t);
	int (*add_inb_buffer)(struct rio_mport *, int, void *);
	void * (*get_inb_message)(struct rio_mport *, int);
	int (*map_inb)(struct rio_mport *, dma_addr_t, u64, u64, u32);
	void (*unmap_inb)(struct rio_mport *, dma_addr_t);
	int (*query_mport)(struct rio_mport *, struct rio_mport_attr *);
	int (*map_outb)(struct rio_mport *, u16, u64, u32, u32, dma_addr_t *);
	void (*unmap_outb)(struct rio_mport *, u16, u64);
};

struct rio_scan {
	struct module *owner;
	int (*enumerate)(struct rio_mport *, u32);
	int (*discover)(struct rio_mport *, u32);
};

struct rio_mport_attr {
	int flags;
	int link_speed;
	int link_width;
	int dma_max_sge;
	int dma_max_size;
	int dma_align;
};

enum rio_write_type {
	RDW_DEFAULT = 0,
	RDW_ALL_NWRITE = 1,
	RDW_ALL_NWRITE_R = 2,
	RDW_LAST_NWRITE_R = 3,
};

struct rio_dma_ext {
	u16 destid;
	u64 rio_addr;
	u8 rio_addr_u;
	enum rio_write_type wr_type;
};

struct rio_dma_data {
	struct scatterlist *sg;
	unsigned int sg_len;
	u64 rio_addr;
	u8 rio_addr_u;
	enum rio_write_type wr_type;
};

struct rio_scan_node {
	int mport_id;
	struct list_head node;
	struct rio_scan *ops;
};

struct rio_pwrite {
	struct list_head node;
	int (*pwcback)(struct rio_mport *, void *, union rio_pw_msg *, int);
	void *context;
};

struct rio_disc_work {
	struct work_struct work;
	struct rio_mport *mport;
};

enum hdmi_infoframe_type {
	HDMI_INFOFRAME_TYPE_VENDOR = 129,
	HDMI_INFOFRAME_TYPE_AVI = 130,
	HDMI_INFOFRAME_TYPE_SPD = 131,
	HDMI_INFOFRAME_TYPE_AUDIO = 132,
	HDMI_INFOFRAME_TYPE_DRM = 135,
};

struct hdmi_any_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
};

enum hdmi_colorspace {
	HDMI_COLORSPACE_RGB = 0,
	HDMI_COLORSPACE_YUV422 = 1,
	HDMI_COLORSPACE_YUV444 = 2,
	HDMI_COLORSPACE_YUV420 = 3,
	HDMI_COLORSPACE_RESERVED4 = 4,
	HDMI_COLORSPACE_RESERVED5 = 5,
	HDMI_COLORSPACE_RESERVED6 = 6,
	HDMI_COLORSPACE_IDO_DEFINED = 7,
};

enum hdmi_scan_mode {
	HDMI_SCAN_MODE_NONE = 0,
	HDMI_SCAN_MODE_OVERSCAN = 1,
	HDMI_SCAN_MODE_UNDERSCAN = 2,
	HDMI_SCAN_MODE_RESERVED = 3,
};

enum hdmi_colorimetry {
	HDMI_COLORIMETRY_NONE = 0,
	HDMI_COLORIMETRY_ITU_601 = 1,
	HDMI_COLORIMETRY_ITU_709 = 2,
	HDMI_COLORIMETRY_EXTENDED = 3,
};

enum hdmi_picture_aspect {
	HDMI_PICTURE_ASPECT_NONE = 0,
	HDMI_PICTURE_ASPECT_4_3 = 1,
	HDMI_PICTURE_ASPECT_16_9 = 2,
	HDMI_PICTURE_ASPECT_64_27 = 3,
	HDMI_PICTURE_ASPECT_256_135 = 4,
	HDMI_PICTURE_ASPECT_RESERVED = 5,
};

enum hdmi_active_aspect {
	HDMI_ACTIVE_ASPECT_16_9_TOP = 2,
	HDMI_ACTIVE_ASPECT_14_9_TOP = 3,
	HDMI_ACTIVE_ASPECT_16_9_CENTER = 4,
	HDMI_ACTIVE_ASPECT_PICTURE = 8,
	HDMI_ACTIVE_ASPECT_4_3 = 9,
	HDMI_ACTIVE_ASPECT_16_9 = 10,
	HDMI_ACTIVE_ASPECT_14_9 = 11,
	HDMI_ACTIVE_ASPECT_4_3_SP_14_9 = 13,
	HDMI_ACTIVE_ASPECT_16_9_SP_14_9 = 14,
	HDMI_ACTIVE_ASPECT_16_9_SP_4_3 = 15,
};

enum hdmi_extended_colorimetry {
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_601 = 0,
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_709 = 1,
	HDMI_EXTENDED_COLORIMETRY_S_YCC_601 = 2,
	HDMI_EXTENDED_COLORIMETRY_OPYCC_601 = 3,
	HDMI_EXTENDED_COLORIMETRY_OPRGB = 4,
	HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM = 5,
	HDMI_EXTENDED_COLORIMETRY_BT2020 = 6,
	HDMI_EXTENDED_COLORIMETRY_RESERVED = 7,
};

enum hdmi_quantization_range {
	HDMI_QUANTIZATION_RANGE_DEFAULT = 0,
	HDMI_QUANTIZATION_RANGE_LIMITED = 1,
	HDMI_QUANTIZATION_RANGE_FULL = 2,
	HDMI_QUANTIZATION_RANGE_RESERVED = 3,
};

enum hdmi_nups {
	HDMI_NUPS_UNKNOWN = 0,
	HDMI_NUPS_HORIZONTAL = 1,
	HDMI_NUPS_VERTICAL = 2,
	HDMI_NUPS_BOTH = 3,
};

enum hdmi_ycc_quantization_range {
	HDMI_YCC_QUANTIZATION_RANGE_LIMITED = 0,
	HDMI_YCC_QUANTIZATION_RANGE_FULL = 1,
};

enum hdmi_content_type {
	HDMI_CONTENT_TYPE_GRAPHICS = 0,
	HDMI_CONTENT_TYPE_PHOTO = 1,
	HDMI_CONTENT_TYPE_CINEMA = 2,
	HDMI_CONTENT_TYPE_GAME = 3,
};

enum hdmi_metadata_type {
	HDMI_STATIC_METADATA_TYPE1 = 0,
};

enum hdmi_eotf {
	HDMI_EOTF_TRADITIONAL_GAMMA_SDR = 0,
	HDMI_EOTF_TRADITIONAL_GAMMA_HDR = 1,
	HDMI_EOTF_SMPTE_ST2084 = 2,
	HDMI_EOTF_BT_2100_HLG = 3,
};

struct hdmi_avi_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_colorspace colorspace;
	enum hdmi_scan_mode scan_mode;
	enum hdmi_colorimetry colorimetry;
	enum hdmi_picture_aspect picture_aspect;
	enum hdmi_active_aspect active_aspect;
	bool itc;
	enum hdmi_extended_colorimetry extended_colorimetry;
	enum hdmi_quantization_range quantization_range;
	enum hdmi_nups nups;
	unsigned char video_code;
	enum hdmi_ycc_quantization_range ycc_quantization_range;
	enum hdmi_content_type content_type;
	unsigned char pixel_repeat;
	short unsigned int top_bar;
	short unsigned int bottom_bar;
	short unsigned int left_bar;
	short unsigned int right_bar;
};

struct hdmi_drm_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_eotf eotf;
	enum hdmi_metadata_type metadata_type;
	struct {
		u16 x;
		u16 y;
	} display_primaries[3];
	struct {
		u16 x;
		u16 y;
	} white_point;
	u16 max_display_mastering_luminance;
	u16 min_display_mastering_luminance;
	u16 max_cll;
	u16 max_fall;
};

enum hdmi_spd_sdi {
	HDMI_SPD_SDI_UNKNOWN = 0,
	HDMI_SPD_SDI_DSTB = 1,
	HDMI_SPD_SDI_DVDP = 2,
	HDMI_SPD_SDI_DVHS = 3,
	HDMI_SPD_SDI_HDDVR = 4,
	HDMI_SPD_SDI_DVC = 5,
	HDMI_SPD_SDI_DSC = 6,
	HDMI_SPD_SDI_VCD = 7,
	HDMI_SPD_SDI_GAME = 8,
	HDMI_SPD_SDI_PC = 9,
	HDMI_SPD_SDI_BD = 10,
	HDMI_SPD_SDI_SACD = 11,
	HDMI_SPD_SDI_HDDVD = 12,
	HDMI_SPD_SDI_PMP = 13,
};

struct hdmi_spd_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	char vendor[8];
	char product[16];
	enum hdmi_spd_sdi sdi;
};

enum hdmi_audio_coding_type {
	HDMI_AUDIO_CODING_TYPE_STREAM = 0,
	HDMI_AUDIO_CODING_TYPE_PCM = 1,
	HDMI_AUDIO_CODING_TYPE_AC3 = 2,
	HDMI_AUDIO_CODING_TYPE_MPEG1 = 3,
	HDMI_AUDIO_CODING_TYPE_MP3 = 4,
	HDMI_AUDIO_CODING_TYPE_MPEG2 = 5,
	HDMI_AUDIO_CODING_TYPE_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_DTS = 7,
	HDMI_AUDIO_CODING_TYPE_ATRAC = 8,
	HDMI_AUDIO_CODING_TYPE_DSD = 9,
	HDMI_AUDIO_CODING_TYPE_EAC3 = 10,
	HDMI_AUDIO_CODING_TYPE_DTS_HD = 11,
	HDMI_AUDIO_CODING_TYPE_MLP = 12,
	HDMI_AUDIO_CODING_TYPE_DST = 13,
	HDMI_AUDIO_CODING_TYPE_WMA_PRO = 14,
	HDMI_AUDIO_CODING_TYPE_CXT = 15,
};

enum hdmi_audio_sample_size {
	HDMI_AUDIO_SAMPLE_SIZE_STREAM = 0,
	HDMI_AUDIO_SAMPLE_SIZE_16 = 1,
	HDMI_AUDIO_SAMPLE_SIZE_20 = 2,
	HDMI_AUDIO_SAMPLE_SIZE_24 = 3,
};

enum hdmi_audio_sample_frequency {
	HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM = 0,
	HDMI_AUDIO_SAMPLE_FREQUENCY_32000 = 1,
	HDMI_AUDIO_SAMPLE_FREQUENCY_44100 = 2,
	HDMI_AUDIO_SAMPLE_FREQUENCY_48000 = 3,
	HDMI_AUDIO_SAMPLE_FREQUENCY_88200 = 4,
	HDMI_AUDIO_SAMPLE_FREQUENCY_96000 = 5,
	HDMI_AUDIO_SAMPLE_FREQUENCY_176400 = 6,
	HDMI_AUDIO_SAMPLE_FREQUENCY_192000 = 7,
};

enum hdmi_audio_coding_type_ext {
	HDMI_AUDIO_CODING_TYPE_EXT_CT = 0,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC = 1,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC_V2 = 2,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG_SURROUND = 3,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC = 4,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_V2 = 5,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_EXT_DRA = 7,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_SURROUND = 8,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC_SURROUND = 10,
};

struct hdmi_audio_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned char channels;
	enum hdmi_audio_coding_type coding_type;
	enum hdmi_audio_sample_size sample_size;
	enum hdmi_audio_sample_frequency sample_frequency;
	enum hdmi_audio_coding_type_ext coding_type_ext;
	unsigned char channel_allocation;
	unsigned char level_shift_value;
	bool downmix_inhibit;
};

enum hdmi_3d_structure {
	HDMI_3D_STRUCTURE_INVALID = 4294967295,
	HDMI_3D_STRUCTURE_FRAME_PACKING = 0,
	HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE = 1,
	HDMI_3D_STRUCTURE_LINE_ALTERNATIVE = 2,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL = 3,
	HDMI_3D_STRUCTURE_L_DEPTH = 4,
	HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH = 5,
	HDMI_3D_STRUCTURE_TOP_AND_BOTTOM = 6,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF = 8,
};

struct hdmi_vendor_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned int oui;
	u8 vic;
	enum hdmi_3d_structure s3d_struct;
	unsigned int s3d_ext_data;
};

union hdmi_vendor_any_infoframe {
	struct {
		enum hdmi_infoframe_type type;
		unsigned char version;
		unsigned char length;
		unsigned int oui;
	} any;
	struct hdmi_vendor_infoframe hdmi;
};

union hdmi_infoframe {
	struct hdmi_any_infoframe any;
	struct hdmi_avi_infoframe avi;
	struct hdmi_spd_infoframe spd;
	union hdmi_vendor_any_infoframe vendor;
	struct hdmi_audio_infoframe audio;
	struct hdmi_drm_infoframe drm;
};

struct fb_fix_screeninfo {
	char id[16];
	long unsigned int smem_start;
	__u32 smem_len;
	__u32 type;
	__u32 type_aux;
	__u32 visual;
	__u16 xpanstep;
	__u16 ypanstep;
	__u16 ywrapstep;
	__u32 line_length;
	long unsigned int mmio_start;
	__u32 mmio_len;
	__u32 accel;
	__u16 capabilities;
	__u16 reserved[2];
};

struct fb_bitfield {
	__u32 offset;
	__u32 length;
	__u32 msb_right;
};

struct fb_var_screeninfo {
	__u32 xres;
	__u32 yres;
	__u32 xres_virtual;
	__u32 yres_virtual;
	__u32 xoffset;
	__u32 yoffset;
	__u32 bits_per_pixel;
	__u32 grayscale;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	__u32 nonstd;
	__u32 activate;
	__u32 height;
	__u32 width;
	__u32 accel_flags;
	__u32 pixclock;
	__u32 left_margin;
	__u32 right_margin;
	__u32 upper_margin;
	__u32 lower_margin;
	__u32 hsync_len;
	__u32 vsync_len;
	__u32 sync;
	__u32 vmode;
	__u32 rotate;
	__u32 colorspace;
	__u32 reserved[4];
};

struct fb_cmap {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

enum {
	FB_BLANK_UNBLANK = 0,
	FB_BLANK_NORMAL = 1,
	FB_BLANK_VSYNC_SUSPEND = 2,
	FB_BLANK_HSYNC_SUSPEND = 3,
	FB_BLANK_POWERDOWN = 4,
};

struct fb_copyarea {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 sx;
	__u32 sy;
};

struct fb_fillrect {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 color;
	__u32 rop;
};

struct fb_image {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 fg_color;
	__u32 bg_color;
	__u8 depth;
	const char *data;
	struct fb_cmap cmap;
};

struct fbcurpos {
	__u16 x;
	__u16 y;
};

struct fb_cursor {
	__u16 set;
	__u16 enable;
	__u16 rop;
	const char *mask;
	struct fbcurpos hot;
	struct fb_image image;
};

struct fb_chroma {
	__u32 redx;
	__u32 greenx;
	__u32 bluex;
	__u32 whitex;
	__u32 redy;
	__u32 greeny;
	__u32 bluey;
	__u32 whitey;
};

struct fb_videomode;

struct fb_monspecs {
	struct fb_chroma chroma;
	struct fb_videomode *modedb;
	__u8 manufacturer[4];
	__u8 monitor[14];
	__u8 serial_no[14];
	__u8 ascii[14];
	__u32 modedb_len;
	__u32 model;
	__u32 serial;
	__u32 year;
	__u32 week;
	__u32 hfmin;
	__u32 hfmax;
	__u32 dclkmin;
	__u32 dclkmax;
	__u16 input;
	__u16 dpms;
	__u16 signal;
	__u16 vfmin;
	__u16 vfmax;
	__u16 gamma;
	__u16 gtf: 1;
	__u16 misc;
	__u8 version;
	__u8 revision;
	__u8 max_x;
	__u8 max_y;
};

struct fb_videomode {
	const char *name;
	u32 refresh;
	u32 xres;
	u32 yres;
	u32 pixclock;
	u32 left_margin;
	u32 right_margin;
	u32 upper_margin;
	u32 lower_margin;
	u32 hsync_len;
	u32 vsync_len;
	u32 sync;
	u32 vmode;
	u32 flag;
};

struct fb_info;

struct fb_event {
	struct fb_info *info;
	void *data;
};

struct fb_pixmap {
	u8 *addr;
	u32 size;
	u32 offset;
	u32 buf_align;
	u32 scan_align;
	u32 access_align;
	u32 flags;
	u32 blit_x;
	u32 blit_y;
	void (*writeio)(struct fb_info *, void *, void *, unsigned int);
	void (*readio)(struct fb_info *, void *, void *, unsigned int);
};

struct backlight_device;

struct fb_deferred_io;

struct fb_ops;

struct fb_tile_ops;

struct apertures_struct;

struct fb_info {
	atomic_t count;
	int node;
	int flags;
	int fbcon_rotate_hint;
	struct mutex lock;
	struct mutex mm_lock;
	struct fb_var_screeninfo var;
	struct fb_fix_screeninfo fix;
	struct fb_monspecs monspecs;
	struct work_struct queue;
	struct fb_pixmap pixmap;
	struct fb_pixmap sprite;
	struct fb_cmap cmap;
	struct list_head modelist;
	struct fb_videomode *mode;
	struct backlight_device *bl_dev;
	struct mutex bl_curve_mutex;
	u8 bl_curve[128];
	struct delayed_work deferred_work;
	struct fb_deferred_io *fbdefio;
	const struct fb_ops *fbops;
	struct device *device;
	struct device *dev;
	int class_flag;
	struct fb_tile_ops *tileops;
	union {
		char *screen_base;
		char *screen_buffer;
	};
	long unsigned int screen_size;
	void *pseudo_palette;
	u32 state;
	void *fbcon_par;
	void *par;
	struct apertures_struct *apertures;
	bool skip_vt_switch;
};

struct fb_blit_caps {
	u32 x;
	u32 y;
	u32 len;
	u32 flags;
};

struct fb_deferred_io {
	long unsigned int delay;
	struct mutex lock;
	struct list_head pagelist;
	void (*first_io)(struct fb_info *);
	void (*deferred_io)(struct fb_info *, struct list_head *);
};

struct fb_ops {
	struct module *owner;
	int (*fb_open)(struct fb_info *, int);
	int (*fb_release)(struct fb_info *, int);
	ssize_t (*fb_read)(struct fb_info *, char *, size_t, loff_t *);
	ssize_t (*fb_write)(struct fb_info *, const char *, size_t, loff_t *);
	int (*fb_check_var)(struct fb_var_screeninfo *, struct fb_info *);
	int (*fb_set_par)(struct fb_info *);
	int (*fb_setcolreg)(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, struct fb_info *);
	int (*fb_setcmap)(struct fb_cmap *, struct fb_info *);
	int (*fb_blank)(int, struct fb_info *);
	int (*fb_pan_display)(struct fb_var_screeninfo *, struct fb_info *);
	void (*fb_fillrect)(struct fb_info *, const struct fb_fillrect *);
	void (*fb_copyarea)(struct fb_info *, const struct fb_copyarea *);
	void (*fb_imageblit)(struct fb_info *, const struct fb_image *);
	int (*fb_cursor)(struct fb_info *, struct fb_cursor *);
	int (*fb_sync)(struct fb_info *);
	int (*fb_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_compat_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_mmap)(struct fb_info *, struct vm_area_struct *);
	void (*fb_get_caps)(struct fb_info *, struct fb_blit_caps *, struct fb_var_screeninfo *);
	void (*fb_destroy)(struct fb_info *);
	int (*fb_debug_enter)(struct fb_info *);
	int (*fb_debug_leave)(struct fb_info *);
};

struct fb_tilemap {
	__u32 width;
	__u32 height;
	__u32 depth;
	__u32 length;
	const __u8 *data;
};

struct fb_tilerect {
	__u32 sx;
	__u32 sy;
	__u32 width;
	__u32 height;
	__u32 index;
	__u32 fg;
	__u32 bg;
	__u32 rop;
};

struct fb_tilearea {
	__u32 sx;
	__u32 sy;
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
};

struct fb_tileblit {
	__u32 sx;
	__u32 sy;
	__u32 width;
	__u32 height;
	__u32 fg;
	__u32 bg;
	__u32 length;
	__u32 *indices;
};

struct fb_tilecursor {
	__u32 sx;
	__u32 sy;
	__u32 mode;
	__u32 shape;
	__u32 fg;
	__u32 bg;
};

struct fb_tile_ops {
	void (*fb_settile)(struct fb_info *, struct fb_tilemap *);
	void (*fb_tilecopy)(struct fb_info *, struct fb_tilearea *);
	void (*fb_tilefill)(struct fb_info *, struct fb_tilerect *);
	void (*fb_tileblit)(struct fb_info *, struct fb_tileblit *);
	void (*fb_tilecursor)(struct fb_info *, struct fb_tilecursor *);
	int (*fb_get_tilemax)(struct fb_info *);
};

struct aperture {
	resource_size_t base;
	resource_size_t size;
};

struct apertures_struct {
	unsigned int count;
	struct aperture ranges[0];
};

enum backlight_type {
	BACKLIGHT_RAW = 1,
	BACKLIGHT_PLATFORM = 2,
	BACKLIGHT_FIRMWARE = 3,
	BACKLIGHT_TYPE_MAX = 4,
};

enum backlight_scale {
	BACKLIGHT_SCALE_UNKNOWN = 0,
	BACKLIGHT_SCALE_LINEAR = 1,
	BACKLIGHT_SCALE_NON_LINEAR = 2,
};

struct backlight_properties {
	int brightness;
	int max_brightness;
	int power;
	int fb_blank;
	enum backlight_type type;
	unsigned int state;
	enum backlight_scale scale;
};

struct backlight_ops;

struct backlight_device {
	struct backlight_properties props;
	struct mutex update_lock;
	struct mutex ops_lock;
	const struct backlight_ops *ops;
	struct notifier_block fb_notif;
	struct list_head entry;
	struct device dev;
	bool fb_bl_on[32];
	int use_count;
};

struct dmt_videomode {
	u32 dmt_id;
	u32 std_2byte_code;
	u32 cvt_3byte_code;
	const struct fb_videomode *mode;
};

enum backlight_update_reason {
	BACKLIGHT_UPDATE_HOTKEY = 0,
	BACKLIGHT_UPDATE_SYSFS = 1,
};

enum backlight_notification {
	BACKLIGHT_REGISTERED = 0,
	BACKLIGHT_UNREGISTERED = 1,
};

struct backlight_ops {
	unsigned int options;
	int (*update_status)(struct backlight_device *);
	int (*get_brightness)(struct backlight_device *);
	int (*check_fb)(struct backlight_device *, struct fb_info *);
};

struct linux_logo {
	int type;
	unsigned int width;
	unsigned int height;
	unsigned int clutsize;
	const unsigned char *clut;
	const unsigned char *data;
};

struct fb_cmap_user {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

struct fb_modelist {
	struct list_head list;
	struct fb_videomode mode;
};

struct fb_fix_screeninfo32 {
	char id[16];
	compat_caddr_t smem_start;
	u32 smem_len;
	u32 type;
	u32 type_aux;
	u32 visual;
	u16 xpanstep;
	u16 ypanstep;
	u16 ywrapstep;
	u32 line_length;
	compat_caddr_t mmio_start;
	u32 mmio_len;
	u32 accel;
	u16 reserved[3];
};

struct fb_cmap32 {
	u32 start;
	u32 len;
	compat_caddr_t red;
	compat_caddr_t green;
	compat_caddr_t blue;
	compat_caddr_t transp;
};

enum display_flags {
	DISPLAY_FLAGS_HSYNC_LOW = 1,
	DISPLAY_FLAGS_HSYNC_HIGH = 2,
	DISPLAY_FLAGS_VSYNC_LOW = 4,
	DISPLAY_FLAGS_VSYNC_HIGH = 8,
	DISPLAY_FLAGS_DE_LOW = 16,
	DISPLAY_FLAGS_DE_HIGH = 32,
	DISPLAY_FLAGS_PIXDATA_POSEDGE = 64,
	DISPLAY_FLAGS_PIXDATA_NEGEDGE = 128,
	DISPLAY_FLAGS_INTERLACED = 256,
	DISPLAY_FLAGS_DOUBLESCAN = 512,
	DISPLAY_FLAGS_DOUBLECLK = 1024,
	DISPLAY_FLAGS_SYNC_POSEDGE = 2048,
	DISPLAY_FLAGS_SYNC_NEGEDGE = 4096,
};

struct videomode {
	long unsigned int pixelclock;
	u32 hactive;
	u32 hfront_porch;
	u32 hback_porch;
	u32 hsync_len;
	u32 vactive;
	u32 vfront_porch;
	u32 vback_porch;
	u32 vsync_len;
	enum display_flags flags;
};

struct broken_edid {
	u8 manufacturer[4];
	u32 model;
	u32 fix;
};

struct __fb_timings {
	u32 dclk;
	u32 hfreq;
	u32 vfreq;
	u32 hactive;
	u32 vactive;
	u32 hblank;
	u32 vblank;
	u32 htotal;
	u32 vtotal;
};

typedef unsigned int u_int;

struct fb_cvt_data {
	u32 xres;
	u32 yres;
	u32 refresh;
	u32 f_refresh;
	u32 pixclock;
	u32 hperiod;
	u32 hblank;
	u32 hfreq;
	u32 htotal;
	u32 vtotal;
	u32 vsync;
	u32 hsync;
	u32 h_front_porch;
	u32 h_back_porch;
	u32 v_front_porch;
	u32 v_back_porch;
	u32 h_margin;
	u32 v_margin;
	u32 interlace;
	u32 aspect_ratio;
	u32 active_pixels;
	u32 flags;
	u32 status;
};

typedef unsigned char u_char;

struct fb_con2fbmap {
	__u32 console;
	__u32 framebuffer;
};

struct fbcon_display {
	const u_char *fontdata;
	int userfont;
	u_short scrollmode;
	u_short inverse;
	short int yscroll;
	int vrows;
	int cursor_shape;
	int con_rotate;
	u32 xres_virtual;
	u32 yres_virtual;
	u32 height;
	u32 width;
	u32 bits_per_pixel;
	u32 grayscale;
	u32 nonstd;
	u32 accel_flags;
	u32 rotate;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	const struct fb_videomode *mode;
};

struct fbcon_ops {
	void (*bmove)(struct vc_data *, struct fb_info *, int, int, int, int, int, int);
	void (*clear)(struct vc_data *, struct fb_info *, int, int, int, int);
	void (*putcs)(struct vc_data *, struct fb_info *, const short unsigned int *, int, int, int, int, int);
	void (*clear_margins)(struct vc_data *, struct fb_info *, int, int);
	void (*cursor)(struct vc_data *, struct fb_info *, int, int, int);
	int (*update_start)(struct fb_info *);
	int (*rotate_font)(struct fb_info *, struct vc_data *);
	struct fb_var_screeninfo var;
	struct timer_list cursor_timer;
	struct fb_cursor cursor_state;
	struct fbcon_display *p;
	struct fb_info *info;
	int currcon;
	int cur_blink_jiffies;
	int cursor_flash;
	int cursor_reset;
	int blank_state;
	int graphics;
	int save_graphics;
	int flags;
	int rotate;
	int cur_rotate;
	char *cursor_data;
	u8 *fontbuffer;
	u8 *fontdata;
	u8 *cursor_src;
	u32 cursor_size;
	u32 fd_size;
};

enum {
	FBCON_LOGO_CANSHOW = 4294967295,
	FBCON_LOGO_DRAW = 4294967294,
	FBCON_LOGO_DONTSHOW = 4294967293,
};

typedef long unsigned int u_long;

enum {
	S1SA = 0,
	S2SA = 1,
	SP = 2,
	DSA = 3,
	CNT = 4,
	DP_OCTL = 5,
	CLR = 6,
	BI = 8,
	MBC = 9,
	BLTCTL = 10,
	HES = 12,
	HEB = 13,
	HSB = 14,
	HT = 15,
	VES = 16,
	VEB = 17,
	VSB = 18,
	VT = 19,
	HCIV = 20,
	VCIV = 21,
	TCDR = 22,
	VIL = 23,
	STGCTL = 24,
	SSR = 25,
	HRIR = 26,
	SPR = 27,
	CMR = 28,
	SRGCTL = 29,
	RRCIV = 30,
	RRSC = 31,
	RRCR = 34,
	GIOE = 32,
	GIO = 33,
	SCR = 35,
	SSTATUS = 36,
	PRC = 37,
};

enum {
	PADDRW = 0,
	PDATA = 4,
	PPMASK = 8,
	PADDRR = 12,
	PIDXLO = 16,
	PIDXHI = 20,
	PIDXDATA = 24,
	PIDXCTL = 28,
};

enum {
	CLKCTL = 2,
	SYNCCTL = 3,
	HSYNCPOS = 4,
	PWRMNGMT = 5,
	DACOP = 6,
	PALETCTL = 7,
	SYSCLKCTL = 8,
	PIXFMT = 10,
	BPP8 = 11,
	BPP16 = 12,
	BPP24 = 13,
	BPP32 = 14,
	PIXCTL1 = 16,
	PIXCTL2 = 17,
	SYSCLKN = 21,
	SYSCLKM = 22,
	SYSCLKP = 23,
	SYSCLKC = 24,
	PIXM0 = 32,
	PIXN0 = 33,
	PIXP0 = 34,
	PIXC0 = 35,
	CURSCTL = 48,
	CURSXLO = 49,
	CURSXHI = 50,
	CURSYLO = 51,
	CURSYHI = 52,
	CURSHOTX = 53,
	CURSHOTY = 54,
	CURSACCTL = 55,
	CURSACATTR = 56,
	CURS1R = 64,
	CURS1G = 65,
	CURS1B = 66,
	CURS2R = 67,
	CURS2G = 68,
	CURS2B = 69,
	CURS3R = 70,
	CURS3G = 71,
	CURS3B = 72,
	BORDR = 96,
	BORDG = 97,
	BORDB = 98,
	MISCTL1 = 112,
	MISCTL2 = 113,
	MISCTL3 = 114,
	KEYCTL = 120,
};

enum {
	TVPADDRW = 0,
	TVPPDATA = 4,
	TVPPMASK = 8,
	TVPPADRR = 12,
	TVPCADRW = 16,
	TVPCDATA = 20,
	TVPCADRR = 28,
	TVPDCCTL = 36,
	TVPIDATA = 40,
	TVPCRDAT = 44,
	TVPCXPOL = 48,
	TVPCXPOH = 52,
	TVPCYPOL = 56,
	TVPCYPOH = 60,
};

enum {
	TVPIRREV = 1,
	TVPIRICC = 6,
	TVPIRBRC = 7,
	TVPIRLAC = 15,
	TVPIRTCC = 24,
	TVPIRMXC = 25,
	TVPIRCLS = 26,
	TVPIRPPG = 28,
	TVPIRGEC = 29,
	TVPIRMIC = 30,
	TVPIRPLA = 44,
	TVPIRPPD = 45,
	TVPIRMPD = 46,
	TVPIRLPD = 47,
	TVPIRCKL = 48,
	TVPIRCKH = 49,
	TVPIRCRL = 50,
	TVPIRCRH = 51,
	TVPIRCGL = 52,
	TVPIRCGH = 53,
	TVPIRCBL = 54,
	TVPIRCBH = 55,
	TVPIRCKC = 56,
	TVPIRMLC = 57,
	TVPIRSEN = 58,
	TVPIRTMD = 59,
	TVPIRRML = 60,
	TVPIRRMM = 61,
	TVPIRRMS = 62,
	TVPIRDID = 63,
	TVPIRRES = 255,
};

struct initvalues {
	__u8 addr;
	__u8 value;
};

struct imstt_regvals {
	__u32 pitch;
	__u16 hes;
	__u16 heb;
	__u16 hsb;
	__u16 ht;
	__u16 ves;
	__u16 veb;
	__u16 vsb;
	__u16 vt;
	__u16 vil;
	__u8 pclk_m;
	__u8 pclk_n;
	__u8 pclk_p;
	__u8 mlc[3];
	__u8 lckl_p[3];
};

struct imstt_par {
	struct imstt_regvals init;
	__u32 *dc_regs;
	long unsigned int cmap_regs_phys;
	__u8 *cmap_regs;
	__u32 ramdac;
	__u32 palette[16];
};

enum {
	IBM = 0,
	TVP = 1,
};

enum {
	CLCD_CAP_RGB444 = 1,
	CLCD_CAP_RGB5551 = 2,
	CLCD_CAP_RGB565 = 4,
	CLCD_CAP_RGB888 = 8,
	CLCD_CAP_BGR444 = 16,
	CLCD_CAP_BGR5551 = 32,
	CLCD_CAP_BGR565 = 64,
	CLCD_CAP_BGR888 = 128,
	CLCD_CAP_444 = 17,
	CLCD_CAP_5551 = 34,
	CLCD_CAP_565 = 68,
	CLCD_CAP_888 = 136,
	CLCD_CAP_RGB = 15,
	CLCD_CAP_BGR = 240,
	CLCD_CAP_ALL = 255,
};

struct clcd_panel {
	struct fb_videomode mode;
	short int width;
	short int height;
	u32 tim2;
	u32 tim3;
	u32 cntl;
	u32 caps;
	unsigned int bpp: 8;
	unsigned int fixedtimings: 1;
	unsigned int grayscale: 1;
	unsigned int connector;
	struct backlight_device *backlight;
	bool bgr_connection;
};

struct clcd_regs {
	u32 tim0;
	u32 tim1;
	u32 tim2;
	u32 tim3;
	u32 cntl;
	long unsigned int pixclock;
};

struct clcd_fb;

struct clcd_board {
	const char *name;
	u32 caps;
	int (*check)(struct clcd_fb *, struct fb_var_screeninfo *);
	void (*decode)(struct clcd_fb *, struct clcd_regs *);
	void (*disable)(struct clcd_fb *);
	void (*enable)(struct clcd_fb *);
	int (*setup)(struct clcd_fb *);
	int (*mmap)(struct clcd_fb *, struct vm_area_struct *);
	void (*remove)(struct clcd_fb *);
};

struct clcd_fb {
	struct fb_info fb;
	struct amba_device *dev;
	struct clk *clk;
	struct clcd_panel *panel;
	struct clcd_board *board;
	void *board_data;
	void *regs;
	u16 off_ienb;
	u16 off_cntl;
	u32 clcd_cntl;
	u32 cmap[16];
	bool clk_enabled;
};

struct timing_entry {
	u32 min;
	u32 typ;
	u32 max;
};

struct display_timing {
	struct timing_entry pixelclock;
	struct timing_entry hactive;
	struct timing_entry hfront_porch;
	struct timing_entry hback_porch;
	struct timing_entry hsync_len;
	struct timing_entry vactive;
	struct timing_entry vfront_porch;
	struct timing_entry vback_porch;
	struct timing_entry vsync_len;
	enum display_flags flags;
};

struct chips_init_reg {
	unsigned char addr;
	unsigned char data;
};

enum drm_panel_orientation {
	DRM_MODE_PANEL_ORIENTATION_UNKNOWN = 4294967295,
	DRM_MODE_PANEL_ORIENTATION_NORMAL = 0,
	DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP = 1,
	DRM_MODE_PANEL_ORIENTATION_LEFT_UP = 2,
	DRM_MODE_PANEL_ORIENTATION_RIGHT_UP = 3,
};

struct bmp_file_header {
	u16 id;
	u32 file_size;
	u32 reserved;
	u32 bitmap_offset;
} __attribute__((packed));

struct bmp_dib_header {
	u32 dib_header_size;
	s32 width;
	s32 height;
	u16 planes;
	u16 bpp;
	u32 compression;
	u32 bitmap_size;
	u32 horz_resolution;
	u32 vert_resolution;
	u32 colors_used;
	u32 colors_important;
};

enum ipu_channel {
	IDMAC_IC_0 = 0,
	IDMAC_IC_1 = 1,
	IDMAC_ADC_0 = 1,
	IDMAC_IC_2 = 2,
	IDMAC_ADC_1 = 2,
	IDMAC_IC_3 = 3,
	IDMAC_IC_4 = 4,
	IDMAC_IC_5 = 5,
	IDMAC_IC_6 = 6,
	IDMAC_IC_7 = 7,
	IDMAC_IC_8 = 8,
	IDMAC_IC_9 = 9,
	IDMAC_IC_10 = 10,
	IDMAC_IC_11 = 11,
	IDMAC_IC_12 = 12,
	IDMAC_IC_13 = 13,
	IDMAC_SDC_0 = 14,
	IDMAC_SDC_1 = 15,
	IDMAC_SDC_2 = 16,
	IDMAC_SDC_3 = 17,
	IDMAC_ADC_2 = 18,
	IDMAC_ADC_3 = 19,
	IDMAC_ADC_4 = 20,
	IDMAC_ADC_5 = 21,
	IDMAC_ADC_6 = 22,
	IDMAC_ADC_7 = 23,
	IDMAC_PF_0 = 24,
	IDMAC_PF_1 = 25,
	IDMAC_PF_2 = 26,
	IDMAC_PF_3 = 27,
	IDMAC_PF_4 = 28,
	IDMAC_PF_5 = 29,
	IDMAC_PF_6 = 30,
	IDMAC_PF_7 = 31,
};

enum ipu_channel_status {
	IPU_CHANNEL_FREE = 0,
	IPU_CHANNEL_INITIALIZED = 1,
	IPU_CHANNEL_READY = 2,
	IPU_CHANNEL_ENABLED = 3,
};

enum pixel_fmt {
	IPU_PIX_FMT_GENERIC = 0,
	IPU_PIX_FMT_RGB332 = 1,
	IPU_PIX_FMT_YUV420P = 2,
	IPU_PIX_FMT_YUV422P = 3,
	IPU_PIX_FMT_YUV420P2 = 4,
	IPU_PIX_FMT_YVU422P = 5,
	IPU_PIX_FMT_RGB565 = 6,
	IPU_PIX_FMT_RGB666 = 7,
	IPU_PIX_FMT_BGR666 = 8,
	IPU_PIX_FMT_YUYV = 9,
	IPU_PIX_FMT_UYVY = 10,
	IPU_PIX_FMT_RGB24 = 11,
	IPU_PIX_FMT_BGR24 = 12,
	IPU_PIX_FMT_GENERIC_32 = 13,
	IPU_PIX_FMT_RGB32 = 14,
	IPU_PIX_FMT_BGR32 = 15,
	IPU_PIX_FMT_ABGR32 = 16,
	IPU_PIX_FMT_BGRA32 = 17,
	IPU_PIX_FMT_RGBA32 = 18,
};

enum display_port {
	DISP0 = 0,
	DISP1 = 1,
	DISP2 = 2,
	DISP3 = 3,
};

struct idmac_video_param {
	short unsigned int in_width;
	short unsigned int in_height;
	uint32_t in_pixel_fmt;
	short unsigned int out_width;
	short unsigned int out_height;
	uint32_t out_pixel_fmt;
	short unsigned int out_stride;
	bool graphics_combine_en;
	bool global_alpha_en;
	bool key_color_en;
	enum display_port disp;
	short unsigned int out_left;
	short unsigned int out_top;
};

union ipu_channel_param {
	struct idmac_video_param video;
};

struct idmac_tx_desc {
	struct dma_async_tx_descriptor txd;
	struct scatterlist *sg;
	unsigned int sg_len;
	struct list_head list;
};

struct idmac_channel {
	struct dma_chan dma_chan;
	dma_cookie_t completed;
	union ipu_channel_param params;
	enum ipu_channel link;
	enum ipu_channel_status status;
	void *client;
	unsigned int n_tx_desc;
	struct idmac_tx_desc *desc;
	struct scatterlist *sg[2];
	struct list_head free_list;
	struct list_head queue;
	spinlock_t lock;
	struct mutex chan_mutex;
	bool sec_chan_en;
	int active_buffer;
	unsigned int eof_irq;
	char eof_name[16];
};

enum disp_data_mapping {
	IPU_DISP_DATA_MAPPING_RGB666 = 0,
	IPU_DISP_DATA_MAPPING_RGB565 = 1,
	IPU_DISP_DATA_MAPPING_RGB888 = 2,
};

struct mx3fb_platform_data {
	struct device *dma_dev;
	const char *name;
	const struct fb_videomode *mode;
	int num_modes;
	enum disp_data_mapping disp_data_fmt;
};

enum ipu_panel {
	IPU_PANEL_SHARP_TFT = 0,
	IPU_PANEL_TFT = 1,
};

struct ipu_di_signal_cfg {
	unsigned int datamask_en: 1;
	unsigned int clksel_en: 1;
	unsigned int clkidle_en: 1;
	unsigned int data_pol: 1;
	unsigned int clk_pol: 1;
	unsigned int enable_pol: 1;
	unsigned int Hsync_pol: 1;
	unsigned int Vsync_pol: 1;
};

struct mx3fb_data {
	struct fb_info *fbi;
	int backlight_level;
	void *reg_base;
	spinlock_t lock;
	struct device *dev;
	struct backlight_device *bl;
	uint32_t h_start_width;
	uint32_t v_start_width;
	enum disp_data_mapping disp_data_fmt;
};

struct dma_chan_request {
	struct mx3fb_data *mx3fb;
	enum ipu_channel id;
};

struct mx3fb_info {
	int blank;
	enum ipu_channel ipu_ch;
	uint32_t cur_ipu_buf;
	u32 pseudo_palette[16];
	struct completion flip_cmpl;
	struct mutex mutex;
	struct mx3fb_data *mx3fb;
	struct idmac_channel *idmac_channel;
	struct dma_async_tx_descriptor *txd;
	dma_cookie_t cookie;
	struct scatterlist sg[2];
	struct fb_var_screeninfo cur_var;
};

struct di_mapping {
	uint32_t b0;
	uint32_t b1;
	uint32_t b2;
};

struct simplefb_format {
	const char *name;
	u32 bits_per_pixel;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	u32 fourcc;
};

struct simplefb_platform_data {
	u32 width;
	u32 height;
	u32 stride;
	const char *format;
};

struct simplefb_params {
	u32 width;
	u32 height;
	u32 stride;
	struct simplefb_format *format;
};

struct simplefb_par {
	u32 palette[16];
	bool clks_enabled;
	unsigned int clk_count;
	struct clk **clks;
	bool regulators_enabled;
	u32 regulator_count;
	struct regulator **regulators;
};

struct display_timings {
	unsigned int num_timings;
	unsigned int native_mode;
	struct display_timing **timings;
};

enum ipmi_addr_src {
	SI_INVALID = 0,
	SI_HOTMOD = 1,
	SI_HARDCODED = 2,
	SI_SPMI = 3,
	SI_ACPI = 4,
	SI_SMBIOS = 5,
	SI_PCI = 6,
	SI_DEVICETREE = 7,
	SI_PLATFORM = 8,
	SI_LAST = 9,
};

struct dmi_header {
	u8 type;
	u8 length;
	u16 handle;
};

enum si_type {
	SI_TYPE_INVALID = 0,
	SI_KCS = 1,
	SI_SMIC = 2,
	SI_BT = 3,
	SI_TYPE_MAX = 4,
};

enum ipmi_addr_space {
	IPMI_IO_ADDR_SPACE = 0,
	IPMI_MEM_ADDR_SPACE = 1,
};

enum ipmi_plat_interface_type {
	IPMI_PLAT_IF_SI = 0,
	IPMI_PLAT_IF_SSIF = 1,
};

struct ipmi_plat_data {
	enum ipmi_plat_interface_type iftype;
	unsigned int type;
	unsigned int space;
	long unsigned int addr;
	unsigned int regspacing;
	unsigned int regsize;
	unsigned int regshift;
	unsigned int irq;
	unsigned int slave_addr;
	enum ipmi_addr_src addr_source;
};

struct ipmi_dmi_info {
	enum si_type si_type;
	unsigned int space;
	long unsigned int addr;
	u8 slave_addr;
	struct ipmi_dmi_info *next;
};

typedef u16 acpi_owner_id;

union acpi_name_union {
	u32 integer;
	char ascii[4];
};

struct acpi_table_desc {
	acpi_physical_address address;
	struct acpi_table_header *pointer;
	u32 length;
	union acpi_name_union signature;
	acpi_owner_id owner_id;
	u8 flags;
	u16 validation_count;
};

struct acpi_madt_local_apic {
	struct acpi_subtable_header header;
	u8 processor_id;
	u8 id;
	u32 lapic_flags;
};

struct acpi_madt_io_apic {
	struct acpi_subtable_header header;
	u8 id;
	u8 reserved;
	u32 address;
	u32 global_irq_base;
};

struct acpi_madt_interrupt_override {
	struct acpi_subtable_header header;
	u8 bus;
	u8 source_irq;
	u32 global_irq;
	u16 inti_flags;
} __attribute__((packed));

struct acpi_madt_nmi_source {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u32 global_irq;
};

struct acpi_madt_local_apic_nmi {
	struct acpi_subtable_header header;
	u8 processor_id;
	u16 inti_flags;
	u8 lint;
} __attribute__((packed));

struct acpi_madt_local_apic_override {
	struct acpi_subtable_header header;
	u16 reserved;
	u64 address;
} __attribute__((packed));

struct acpi_madt_io_sapic {
	struct acpi_subtable_header header;
	u8 id;
	u8 reserved;
	u32 global_irq_base;
	u64 address;
};

struct acpi_madt_local_sapic {
	struct acpi_subtable_header header;
	u8 processor_id;
	u8 id;
	u8 eid;
	u8 reserved[3];
	u32 lapic_flags;
	u32 uid;
	char uid_string[1];
} __attribute__((packed));

struct acpi_madt_interrupt_source {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u8 type;
	u8 id;
	u8 eid;
	u8 io_sapic_vector;
	u32 global_irq;
	u32 flags;
};

struct acpi_madt_local_x2apic {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 local_apic_id;
	u32 lapic_flags;
	u32 uid;
};

struct acpi_madt_local_x2apic_nmi {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u32 uid;
	u8 lint;
	u8 reserved[3];
};

struct acpi_subtable_proc {
	int id;
	acpi_tbl_entry_handler handler;
	int count;
};

struct transaction;

struct acpi_ec {
	acpi_handle handle;
	int gpe;
	int irq;
	long unsigned int command_addr;
	long unsigned int data_addr;
	bool global_lock;
	long unsigned int flags;
	long unsigned int reference_count;
	struct mutex mutex;
	wait_queue_head_t wait;
	struct list_head list;
	struct transaction *curr;
	spinlock_t lock;
	struct work_struct work;
	long unsigned int timestamp;
	long unsigned int nr_pending_queries;
	unsigned int events_in_progress;
	unsigned int queries_in_progress;
	bool busy_polling;
	unsigned int polling_guard;
};

enum acpi_subtable_type {
	ACPI_SUBTABLE_COMMON = 0,
	ACPI_SUBTABLE_HMAT = 1,
};

struct acpi_subtable_entry {
	union acpi_subtable_headers *hdr;
	enum acpi_subtable_type type;
};

typedef char *acpi_string;

struct acpi_osi_entry {
	char string[64];
	bool enable;
};

struct acpi_osi_config {
	u8 default_disabling;
	unsigned int linux_enable: 1;
	unsigned int linux_dmi: 1;
	unsigned int linux_cmdline: 1;
	unsigned int darwin_enable: 1;
	unsigned int darwin_dmi: 1;
	unsigned int darwin_cmdline: 1;
};

typedef u32 acpi_name;

struct acpi_predefined_names {
	const char *name;
	u8 type;
	char *val;
};

typedef u32 (*acpi_osd_handler)(void *);

typedef void (*acpi_osd_exec_callback)(void *);

typedef u32 (*acpi_sci_handler)(void *);

typedef u32 (*acpi_gpe_handler)(acpi_handle, u32, void *);

typedef void (*acpi_notify_handler)(acpi_handle, u32, void *);

typedef void (*acpi_object_handler)(acpi_handle, void *);

typedef acpi_status (*acpi_init_handler)(acpi_handle, u32);

typedef acpi_status (*acpi_exception_handler)(acpi_status, acpi_name, u16, u32, void *);

typedef acpi_status (*acpi_table_handler)(u32, void *, void *);

typedef acpi_status (*acpi_adr_space_handler)(u32, acpi_physical_address, u32, u64 *, void *, void *);

typedef acpi_status (*acpi_adr_space_setup)(acpi_handle, u32, void *, void **);

typedef u32 (*acpi_interface_handler)(acpi_string, u32);

struct acpi_pci_id {
	u16 segment;
	u16 bus;
	u16 device;
	u16 function;
};

struct acpi_mem_mapping {
	acpi_physical_address physical_address;
	u8 *logical_address;
	acpi_size length;
	struct acpi_mem_mapping *next_mm;
};

struct acpi_mem_space_context {
	u32 length;
	acpi_physical_address address;
	struct acpi_mem_mapping *cur_mm;
	struct acpi_mem_mapping *first_mm;
};

typedef enum {
	OSL_GLOBAL_LOCK_HANDLER = 0,
	OSL_NOTIFY_HANDLER = 1,
	OSL_GPE_HANDLER = 2,
	OSL_DEBUGGER_MAIN_THREAD = 3,
	OSL_DEBUGGER_EXEC_THREAD = 4,
	OSL_EC_POLL_HANDLER = 5,
	OSL_EC_BURST_HANDLER = 6,
} acpi_execute_type;

struct acpi_rw_lock {
	void *writer_mutex;
	void *reader_mutex;
	u32 num_readers;
};

struct acpi_mutex_info {
	void *mutex;
	u32 use_count;
	u64 thread_id;
};

union acpi_operand_object;

struct acpi_namespace_node {
	union acpi_operand_object *object;
	u8 descriptor_type;
	u8 type;
	u16 flags;
	union acpi_name_union name;
	struct acpi_namespace_node *parent;
	struct acpi_namespace_node *child;
	struct acpi_namespace_node *peer;
	acpi_owner_id owner_id;
};

struct acpi_object_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
};

struct acpi_object_integer {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 fill[3];
	u64 value;
};

struct acpi_object_string {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	char *pointer;
	u32 length;
};

struct acpi_object_buffer {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 *pointer;
	u32 length;
	u32 aml_length;
	u8 *aml_start;
	struct acpi_namespace_node *node;
};

struct acpi_object_package {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *node;
	union acpi_operand_object **elements;
	u8 *aml_start;
	u32 aml_length;
	u32 count;
};

struct acpi_object_event {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	void *os_semaphore;
};

struct acpi_walk_state;

typedef acpi_status (*acpi_internal_method)(struct acpi_walk_state *);

struct acpi_object_method {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 info_flags;
	u8 param_count;
	u8 sync_level;
	union acpi_operand_object *mutex;
	union acpi_operand_object *node;
	u8 *aml_start;
	union {
		acpi_internal_method implementation;
		union acpi_operand_object *handler;
	} dispatch;
	u32 aml_length;
	acpi_owner_id owner_id;
	u8 thread_count;
};

struct acpi_thread_state;

struct acpi_object_mutex {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 sync_level;
	u16 acquisition_depth;
	void *os_mutex;
	u64 thread_id;
	struct acpi_thread_state *owner_thread;
	union acpi_operand_object *prev;
	union acpi_operand_object *next;
	struct acpi_namespace_node *node;
	u8 original_sync_level;
};

struct acpi_object_region {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 space_id;
	struct acpi_namespace_node *node;
	union acpi_operand_object *handler;
	union acpi_operand_object *next;
	acpi_physical_address address;
	u32 length;
};

struct acpi_object_notify_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
};

struct acpi_gpe_block_info;

struct acpi_object_device {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	struct acpi_gpe_block_info *gpe_block;
};

struct acpi_object_power_resource {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	u32 system_level;
	u32 resource_order;
};

struct acpi_object_processor {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 proc_id;
	u8 length;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	acpi_io_address address;
};

struct acpi_object_thermal_zone {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
};

struct acpi_object_field_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *region_obj;
};

struct acpi_object_region_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	u16 resource_length;
	union acpi_operand_object *region_obj;
	u8 *resource_buffer;
	u16 pin_number_index;
	u8 *internal_pcc_buffer;
};

struct acpi_object_buffer_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	u8 is_create_field;
	union acpi_operand_object *buffer_obj;
};

struct acpi_object_bank_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *region_obj;
	union acpi_operand_object *bank_obj;
};

struct acpi_object_index_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *index_obj;
	union acpi_operand_object *data_obj;
};

struct acpi_object_notify_handler {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *node;
	u32 handler_type;
	acpi_notify_handler handler;
	void *context;
	union acpi_operand_object *next[2];
};

struct acpi_object_addr_handler {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 space_id;
	u8 handler_flags;
	acpi_adr_space_handler handler;
	struct acpi_namespace_node *node;
	void *context;
	void *context_mutex;
	acpi_adr_space_setup setup;
	union acpi_operand_object *region_list;
	union acpi_operand_object *next;
};

struct acpi_object_reference {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 class;
	u8 target_type;
	u8 resolved;
	void *object;
	struct acpi_namespace_node *node;
	union acpi_operand_object **where;
	u8 *index_pointer;
	u8 *aml;
	u32 value;
};

struct acpi_object_extra {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *method_REG;
	struct acpi_namespace_node *scope_node;
	void *region_context;
	u8 *aml_start;
	u32 aml_length;
};

struct acpi_object_data {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	acpi_object_handler handler;
	void *pointer;
};

struct acpi_object_cache_list {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *next;
};

union acpi_operand_object {
	struct acpi_object_common common;
	struct acpi_object_integer integer;
	struct acpi_object_string string;
	struct acpi_object_buffer buffer;
	struct acpi_object_package package;
	struct acpi_object_event event;
	struct acpi_object_method method;
	struct acpi_object_mutex mutex;
	struct acpi_object_region region;
	struct acpi_object_notify_common common_notify;
	struct acpi_object_device device;
	struct acpi_object_power_resource power_resource;
	struct acpi_object_processor processor;
	struct acpi_object_thermal_zone thermal_zone;
	struct acpi_object_field_common common_field;
	struct acpi_object_region_field field;
	struct acpi_object_buffer_field buffer_field;
	struct acpi_object_bank_field bank_field;
	struct acpi_object_index_field index_field;
	struct acpi_object_notify_handler notify;
	struct acpi_object_addr_handler address_space;
	struct acpi_object_reference reference;
	struct acpi_object_extra extra;
	struct acpi_object_data data;
	struct acpi_object_cache_list cache;
	struct acpi_namespace_node node;
};

struct acpi_table_list {
	struct acpi_table_desc *tables;
	u32 current_table_count;
	u32 max_table_count;
	u8 flags;
};

union acpi_parse_object;

union acpi_generic_state;

struct acpi_parse_state {
	u8 *aml_start;
	u8 *aml;
	u8 *aml_end;
	u8 *pkg_start;
	u8 *pkg_end;
	union acpi_parse_object *start_op;
	struct acpi_namespace_node *start_node;
	union acpi_generic_state *scope;
	union acpi_parse_object *start_scope;
	u32 aml_size;
};

typedef acpi_status (*acpi_parse_downwards)(struct acpi_walk_state *, union acpi_parse_object **);

typedef acpi_status (*acpi_parse_upwards)(struct acpi_walk_state *);

struct acpi_opcode_info;

struct acpi_walk_state {
	struct acpi_walk_state *next;
	u8 descriptor_type;
	u8 walk_type;
	u16 opcode;
	u8 next_op_info;
	u8 num_operands;
	u8 operand_index;
	acpi_owner_id owner_id;
	u8 last_predicate;
	u8 current_result;
	u8 return_used;
	u8 scope_depth;
	u8 pass_number;
	u8 namespace_override;
	u8 result_size;
	u8 result_count;
	u8 *aml;
	u32 arg_types;
	u32 method_breakpoint;
	u32 user_breakpoint;
	u32 parse_flags;
	struct acpi_parse_state parser_state;
	u32 prev_arg_types;
	u32 arg_count;
	u16 method_nesting_depth;
	u8 method_is_nested;
	struct acpi_namespace_node arguments[7];
	struct acpi_namespace_node local_variables[8];
	union acpi_operand_object *operands[9];
	union acpi_operand_object **params;
	u8 *aml_last_while;
	union acpi_operand_object **caller_return_desc;
	union acpi_generic_state *control_state;
	struct acpi_namespace_node *deferred_node;
	union acpi_operand_object *implicit_return_obj;
	struct acpi_namespace_node *method_call_node;
	union acpi_parse_object *method_call_op;
	union acpi_operand_object *method_desc;
	struct acpi_namespace_node *method_node;
	char *method_pathname;
	union acpi_parse_object *op;
	const struct acpi_opcode_info *op_info;
	union acpi_parse_object *origin;
	union acpi_operand_object *result_obj;
	union acpi_generic_state *results;
	union acpi_operand_object *return_desc;
	union acpi_generic_state *scope_info;
	union acpi_parse_object *prev_op;
	union acpi_parse_object *next_op;
	struct acpi_thread_state *thread;
	acpi_parse_downwards descending_callback;
	acpi_parse_upwards ascending_callback;
};

struct acpi_sci_handler_info {
	struct acpi_sci_handler_info *next;
	acpi_sci_handler address;
	void *context;
};

struct acpi_gpe_handler_info {
	acpi_gpe_handler address;
	void *context;
	struct acpi_namespace_node *method_node;
	u8 original_flags;
	u8 originally_enabled;
};

struct acpi_gpe_notify_info {
	struct acpi_namespace_node *device_node;
	struct acpi_gpe_notify_info *next;
};

union acpi_gpe_dispatch_info {
	struct acpi_namespace_node *method_node;
	struct acpi_gpe_handler_info *handler;
	struct acpi_gpe_notify_info *notify_list;
};

struct acpi_gpe_register_info;

struct acpi_gpe_event_info {
	union acpi_gpe_dispatch_info dispatch;
	struct acpi_gpe_register_info *register_info;
	u8 flags;
	u8 gpe_number;
	u8 runtime_count;
	u8 disable_for_dispatch;
};

struct acpi_gpe_address {
	u8 space_id;
	u64 address;
};

struct acpi_gpe_register_info {
	struct acpi_gpe_address status_address;
	struct acpi_gpe_address enable_address;
	u16 base_gpe_number;
	u8 enable_for_wake;
	u8 enable_for_run;
	u8 mask_for_run;
	u8 enable_mask;
};

struct acpi_gpe_xrupt_info;

struct acpi_gpe_block_info {
	struct acpi_namespace_node *node;
	struct acpi_gpe_block_info *previous;
	struct acpi_gpe_block_info *next;
	struct acpi_gpe_xrupt_info *xrupt_block;
	struct acpi_gpe_register_info *register_info;
	struct acpi_gpe_event_info *event_info;
	u64 address;
	u32 register_count;
	u16 gpe_count;
	u16 block_base_number;
	u8 space_id;
	u8 initialized;
};

struct acpi_gpe_xrupt_info {
	struct acpi_gpe_xrupt_info *previous;
	struct acpi_gpe_xrupt_info *next;
	struct acpi_gpe_block_info *gpe_block_list_head;
	u32 interrupt_number;
};

struct acpi_common_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
};

struct acpi_update_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	union acpi_operand_object *object;
};

struct acpi_pkg_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u32 index;
	union acpi_operand_object *source_object;
	union acpi_operand_object *dest_object;
	struct acpi_walk_state *walk_state;
	void *this_target_obj;
	u32 num_packages;
};

struct acpi_control_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u16 opcode;
	union acpi_parse_object *predicate_op;
	u8 *aml_predicate_start;
	u8 *package_end;
	u64 loop_timeout;
};

union acpi_parse_value {
	u64 integer;
	u32 size;
	char *string;
	u8 *buffer;
	char *name;
	union acpi_parse_object *arg;
};

struct acpi_parse_obj_common {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
};

struct acpi_parse_obj_named {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
	char *path;
	u8 *data;
	u32 length;
	u32 name;
};

struct acpi_parse_obj_asl {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
	union acpi_parse_object *child;
	union acpi_parse_object *parent_method;
	char *filename;
	u8 file_changed;
	char *parent_filename;
	char *external_name;
	char *namepath;
	char name_seg[4];
	u32 extra_value;
	u32 column;
	u32 line_number;
	u32 logical_line_number;
	u32 logical_byte_offset;
	u32 end_line;
	u32 end_logical_line;
	u32 acpi_btype;
	u32 aml_length;
	u32 aml_subtree_length;
	u32 final_aml_length;
	u32 final_aml_offset;
	u32 compile_flags;
	u16 parse_opcode;
	u8 aml_opcode_length;
	u8 aml_pkg_len_bytes;
	u8 extra;
	char parse_op_name[20];
};

union acpi_parse_object {
	struct acpi_parse_obj_common common;
	struct acpi_parse_obj_named named;
	struct acpi_parse_obj_asl asl;
};

struct acpi_scope_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	struct acpi_namespace_node *node;
};

struct acpi_pscope_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u32 arg_count;
	union acpi_parse_object *op;
	u8 *arg_end;
	u8 *pkg_end;
	u32 arg_list;
};

struct acpi_thread_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u8 current_sync_level;
	struct acpi_walk_state *walk_state_list;
	union acpi_operand_object *acquired_mutex_list;
	u64 thread_id;
};

struct acpi_result_values {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	union acpi_operand_object *obj_desc[8];
};

struct acpi_global_notify_handler {
	acpi_notify_handler handler;
	void *context;
};

struct acpi_notify_info {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u8 handler_list_id;
	struct acpi_namespace_node *node;
	union acpi_operand_object *handler_list_head;
	struct acpi_global_notify_handler *global;
};

union acpi_generic_state {
	struct acpi_common_state common;
	struct acpi_control_state control;
	struct acpi_update_state update;
	struct acpi_scope_state scope;
	struct acpi_pscope_state parse_scope;
	struct acpi_pkg_state pkg;
	struct acpi_thread_state thread;
	struct acpi_result_values results;
	struct acpi_notify_info notify;
};

struct acpi_address_range {
	struct acpi_address_range *next;
	struct acpi_namespace_node *region_node;
	acpi_physical_address start_address;
	acpi_physical_address end_address;
};

struct acpi_opcode_info {
	u32 parse_args;
	u32 runtime_args;
	u16 flags;
	u8 object_type;
	u8 class;
	u8 type;
};

struct acpi_comment_node {
	char *comment;
	struct acpi_comment_node *next;
};

struct acpi_bit_register_info {
	u8 parent_register;
	u8 bit_position;
	u16 access_bit_mask;
};

struct acpi_interface_info {
	char *name;
	struct acpi_interface_info *next;
	u8 flags;
	u8 value;
};

struct acpi_os_dpc {
	acpi_osd_exec_callback function;
	void *context;
	struct work_struct work;
};

struct acpi_ioremap {
	struct list_head list;
	void *virt;
	acpi_physical_address phys;
	acpi_size size;
	union {
		long unsigned int refcount;
		struct rcu_work rwork;
	} track;
};

struct acpi_hp_work {
	struct work_struct work;
	struct acpi_device *adev;
	u32 src;
};

struct acpi_pld_info {
	u8 revision;
	u8 ignore_color;
	u8 red;
	u8 green;
	u8 blue;
	u16 width;
	u16 height;
	u8 user_visible;
	u8 dock;
	u8 lid;
	u8 panel;
	u8 vertical_position;
	u8 horizontal_position;
	u8 shape;
	u8 group_orientation;
	u8 group_token;
	u8 group_position;
	u8 bay;
	u8 ejectable;
	u8 ospm_eject_required;
	u8 cabinet_number;
	u8 card_cage_number;
	u8 reference;
	u8 rotation;
	u8 order;
	u8 reserved;
	u16 vertical_offset;
	u16 horizontal_offset;
};

struct acpi_handle_list {
	u32 count;
	acpi_handle handles[10];
};

enum acpi_predicate {
	all_versions = 0,
	less_than_or_equal = 1,
	equal = 2,
	greater_than_or_equal = 3,
};

struct acpi_platform_list {
	char oem_id[7];
	char oem_table_id[9];
	u32 oem_revision;
	char *table;
	enum acpi_predicate pred;
	char *reason;
	u32 data;
};

struct acpi_device_bus_id {
	const char *bus_id;
	struct ida instance_ida;
	struct list_head node;
};

struct acpi_dev_match_info {
	struct acpi_device_id hid[2];
	const char *uid;
	s64 hrv;
};

struct nvs_region {
	__u64 phys_start;
	__u64 size;
	struct list_head node;
};

struct acpi_wakeup_handler {
	struct list_head list_node;
	bool (*wakeup)(void *);
	void *context;
};

struct acpi_hardware_id {
	struct list_head list;
	const char *id;
};

struct acpi_data_node {
	const char *name;
	acpi_handle handle;
	struct fwnode_handle fwnode;
	struct fwnode_handle *parent;
	struct acpi_device_data data;
	struct list_head sibling;
	struct kobject kobj;
	struct completion kobj_done;
};

struct acpi_data_node_attr {
	struct attribute attr;
	ssize_t (*show)(struct acpi_data_node *, char *);
	ssize_t (*store)(struct acpi_data_node *, const char *, size_t);
};

typedef u32 (*acpi_event_handler)(void *);

enum acpi_bus_device_type {
	ACPI_BUS_TYPE_DEVICE = 0,
	ACPI_BUS_TYPE_POWER = 1,
	ACPI_BUS_TYPE_PROCESSOR = 2,
	ACPI_BUS_TYPE_THERMAL = 3,
	ACPI_BUS_TYPE_POWER_BUTTON = 4,
	ACPI_BUS_TYPE_SLEEP_BUTTON = 5,
	ACPI_BUS_TYPE_ECDT_EC = 6,
	ACPI_BUS_DEVICE_TYPE_COUNT = 7,
};

struct acpi_device_physical_node {
	unsigned int node_id;
	struct list_head node;
	struct device *dev;
	bool put_online: 1;
};

struct acpi_osc_context {
	char *uuid_str;
	int rev;
	struct acpi_buffer cap;
	struct acpi_buffer ret;
};

struct acpi_pnp_device_id {
	u32 length;
	char *string;
};

struct acpi_pnp_device_id_list {
	u32 count;
	u32 list_size;
	struct acpi_pnp_device_id ids[0];
};

struct acpi_device_info {
	u32 info_size;
	u32 name;
	acpi_object_type type;
	u8 param_count;
	u16 valid;
	u8 flags;
	u8 highest_dstates[4];
	u8 lowest_dstates[5];
	u64 address;
	struct acpi_pnp_device_id hardware_id;
	struct acpi_pnp_device_id unique_id;
	struct acpi_pnp_device_id class_code;
	struct acpi_pnp_device_id_list compatible_id_list;
};

struct acpi_table_spcr {
	struct acpi_table_header header;
	u8 interface_type;
	u8 reserved[3];
	struct acpi_generic_address serial_port;
	u8 interrupt_type;
	u8 pc_interrupt;
	u32 interrupt;
	u8 baud_rate;
	u8 parity;
	u8 stop_bits;
	u8 flow_control;
	u8 terminal_type;
	u8 reserved1;
	u16 pci_device_id;
	u16 pci_vendor_id;
	u8 pci_bus;
	u8 pci_device;
	u8 pci_function;
	u32 pci_flags;
	u8 pci_segment;
	u32 reserved2;
} __attribute__((packed));

struct acpi_table_stao {
	struct acpi_table_header header;
	u8 ignore_uart;
} __attribute__((packed));

enum acpi_reconfig_event {
	ACPI_RECONFIG_DEVICE_ADD = 0,
	ACPI_RECONFIG_DEVICE_REMOVE = 1,
};

struct acpi_dep_data {
	struct list_head node;
	acpi_handle supplier;
	acpi_handle consumer;
};

struct acpi_table_events_work {
	struct work_struct work;
	void *table;
	u32 event;
};

struct resource_win {
	struct resource res;
	resource_size_t offset;
};

struct irq_override_cmp {
	const struct dmi_system_id *system;
	unsigned char irq;
	unsigned char triggering;
	unsigned char polarity;
	unsigned char shareable;
};

struct res_proc_context {
	struct list_head *list;
	int (*preproc)(struct acpi_resource *, void *);
	void *preproc_data;
	int count;
	int error;
};

typedef u32 acpi_event_status;

struct acpi_table_ecdt {
	struct acpi_table_header header;
	struct acpi_generic_address control;
	struct acpi_generic_address data;
	u32 uid;
	u8 gpe;
	u8 id[1];
} __attribute__((packed));

struct transaction {
	const u8 *wdata;
	u8 *rdata;
	short unsigned int irq_count;
	u8 command;
	u8 wi;
	u8 ri;
	u8 wlen;
	u8 rlen;
	u8 flags;
};

typedef int (*acpi_ec_query_func)(void *);

enum ec_command {
	ACPI_EC_COMMAND_READ = 128,
	ACPI_EC_COMMAND_WRITE = 129,
	ACPI_EC_BURST_ENABLE = 130,
	ACPI_EC_BURST_DISABLE = 131,
	ACPI_EC_COMMAND_QUERY = 132,
};

enum {
	EC_FLAGS_QUERY_ENABLED = 0,
	EC_FLAGS_QUERY_PENDING = 1,
	EC_FLAGS_QUERY_GUARDING = 2,
	EC_FLAGS_EVENT_HANDLER_INSTALLED = 3,
	EC_FLAGS_EC_HANDLER_INSTALLED = 4,
	EC_FLAGS_QUERY_METHODS_INSTALLED = 5,
	EC_FLAGS_STARTED = 6,
	EC_FLAGS_STOPPED = 7,
	EC_FLAGS_EVENTS_MASKED = 8,
};

struct acpi_ec_query_handler {
	struct list_head node;
	acpi_ec_query_func func;
	acpi_handle handle;
	void *data;
	u8 query_bit;
	struct kref kref;
};

struct acpi_ec_query {
	struct transaction transaction;
	struct work_struct work;
	struct acpi_ec_query_handler *handler;
	struct acpi_ec *ec;
};

struct dock_station {
	acpi_handle handle;
	long unsigned int last_dock_time;
	u32 flags;
	struct list_head dependent_devices;
	struct list_head sibling;
	struct platform_device *dock_device;
};

struct dock_dependent_device {
	struct list_head list;
	struct acpi_device *adev;
};

enum dock_callback_type {
	DOCK_CALL_HANDLER = 0,
	DOCK_CALL_FIXUP = 1,
	DOCK_CALL_UEVENT = 2,
};

struct pci_osc_bit_struct {
	u32 bit;
	char *desc;
};

struct acpi_handle_node {
	struct list_head node;
	acpi_handle handle;
};

struct acpi_pci_link_irq {
	u32 active;
	u8 triggering;
	u8 polarity;
	u8 resource_type;
	u8 possible_count;
	u32 possible[16];
	u8 initialized: 1;
	u8 reserved: 7;
};

struct acpi_pci_link {
	struct list_head list;
	struct acpi_device *device;
	struct acpi_pci_link_irq irq;
	int refcnt;
};

struct acpi_pci_routing_table {
	u32 length;
	u32 pin;
	u64 address;
	u32 source_index;
	char source[4];
};

struct acpi_prt_entry {
	struct acpi_pci_id id;
	u8 pin;
	acpi_handle link;
	u32 index;
};

struct prt_quirk {
	const struct dmi_system_id *system;
	unsigned int segment;
	unsigned int bus;
	unsigned int device;
	unsigned char pin;
	const char *source;
	const char *actual_source;
};

struct apd_private_data;

struct apd_device_desc {
	unsigned int fixed_clk_rate;
	struct property_entry *properties;
	int (*setup)(struct apd_private_data *);
};

struct apd_private_data {
	struct clk *clk;
	struct acpi_device *adev;
	const struct apd_device_desc *dev_desc;
};

struct acpi_power_dependent_device {
	struct device *dev;
	struct list_head node;
};

struct acpi_power_resource {
	struct acpi_device device;
	struct list_head list_node;
	char *name;
	u32 system_level;
	u32 order;
	unsigned int ref_count;
	unsigned int users;
	bool wakeup_enabled;
	struct mutex resource_lock;
	struct list_head dependents;
};

struct acpi_power_resource_entry {
	struct list_head node;
	struct acpi_power_resource *resource;
};

struct acpi_bus_event {
	struct list_head node;
	acpi_device_class device_class;
	acpi_bus_id bus_id;
	u32 type;
	u32 data;
};

struct acpi_genl_event {
	acpi_device_class device_class;
	char bus_id[15];
	u32 type;
	u32 data;
};

enum {
	ACPI_GENL_ATTR_UNSPEC = 0,
	ACPI_GENL_ATTR_EVENT = 1,
	__ACPI_GENL_ATTR_MAX = 2,
};

enum {
	ACPI_GENL_CMD_UNSPEC = 0,
	ACPI_GENL_CMD_EVENT = 1,
	__ACPI_GENL_CMD_MAX = 2,
};

struct acpi_ged_device {
	struct device *dev;
	struct list_head event_list;
};

struct acpi_ged_event {
	struct list_head node;
	struct device *dev;
	unsigned int gsi;
	unsigned int irq;
	acpi_handle handle;
};

typedef void (*acpi_gbl_event_handler)(u32, acpi_handle, u32, void *);

struct acpi_table_bert {
	struct acpi_table_header header;
	u32 region_length;
	u64 address;
};

struct acpi_table_attr {
	struct bin_attribute attr;
	char name[4];
	int instance;
	char filename[8];
	struct list_head node;
};

struct acpi_data_attr {
	struct bin_attribute attr;
	u64 addr;
};

struct acpi_data_obj {
	char *name;
	int (*fn)(void *, struct acpi_data_attr *);
};

struct event_counter {
	u32 count;
	u32 flags;
};

struct acpi_device_properties {
	const guid_t *guid;
	const union acpi_object *properties;
	struct list_head list;
};

struct acpi_lpat {
	int temp;
	int raw;
};

struct acpi_lpat_conversion_table {
	struct acpi_lpat *lpat;
	int lpat_count;
};

struct acpi_irq_parse_one_ctx {
	int rc;
	unsigned int index;
	long unsigned int *res_flags;
	struct irq_fwspec *fwspec;
};

struct acpi_table_wdat {
	struct acpi_table_header header;
	u32 header_length;
	u16 pci_segment;
	u8 pci_bus;
	u8 pci_device;
	u8 pci_function;
	u8 reserved[3];
	u32 timer_period;
	u32 max_count;
	u32 min_count;
	u8 flags;
	u8 reserved2[3];
	u32 entries;
};

struct acpi_wdat_entry {
	u8 action;
	u8 instruction;
	u16 reserved;
	struct acpi_generic_address register_region;
	u32 value;
	u32 mask;
} __attribute__((packed));

enum {
	ACPI_REFCLASS_LOCAL = 0,
	ACPI_REFCLASS_ARG = 1,
	ACPI_REFCLASS_REFOF = 2,
	ACPI_REFCLASS_INDEX = 3,
	ACPI_REFCLASS_TABLE = 4,
	ACPI_REFCLASS_NAME = 5,
	ACPI_REFCLASS_DEBUG = 6,
	ACPI_REFCLASS_MAX = 6,
};

struct acpi_common_descriptor {
	void *common_pointer;
	u8 descriptor_type;
};

union acpi_descriptor {
	struct acpi_common_descriptor common;
	union acpi_operand_object object;
	struct acpi_namespace_node node;
	union acpi_parse_object op;
};

struct acpi_create_field_info {
	struct acpi_namespace_node *region_node;
	struct acpi_namespace_node *field_node;
	struct acpi_namespace_node *register_node;
	struct acpi_namespace_node *data_register_node;
	struct acpi_namespace_node *connection_node;
	u8 *resource_buffer;
	u32 bank_value;
	u32 field_bit_position;
	u32 field_bit_length;
	u16 resource_length;
	u16 pin_number_index;
	u8 field_flags;
	u8 attribute;
	u8 field_type;
	u8 access_length;
};

struct acpi_init_walk_info {
	u32 table_index;
	u32 object_count;
	u32 method_count;
	u32 serial_method_count;
	u32 non_serial_method_count;
	u32 serialized_method_count;
	u32 device_count;
	u32 op_region_count;
	u32 field_count;
	u32 buffer_count;
	u32 package_count;
	u32 op_region_init;
	u32 field_init;
	u32 buffer_init;
	u32 package_init;
	acpi_owner_id owner_id;
};

struct acpi_name_info {
	char name[4];
	u16 argument_list;
	u8 expected_btypes;
} __attribute__((packed));

struct acpi_package_info {
	u8 type;
	u8 object_type1;
	u8 count1;
	u8 object_type2;
	u8 count2;
	u16 reserved;
} __attribute__((packed));

struct acpi_package_info2 {
	u8 type;
	u8 count;
	u8 object_type[4];
	u8 reserved;
};

struct acpi_package_info3 {
	u8 type;
	u8 count;
	u8 object_type[2];
	u8 tail_object_type;
	u16 reserved;
} __attribute__((packed));

struct acpi_package_info4 {
	u8 type;
	u8 object_type1;
	u8 count1;
	u8 sub_object_types;
	u8 pkg_count;
	u16 reserved;
} __attribute__((packed));

union acpi_predefined_info {
	struct acpi_name_info info;
	struct acpi_package_info ret_info;
	struct acpi_package_info2 ret_info2;
	struct acpi_package_info3 ret_info3;
	struct acpi_package_info4 ret_info4;
};

struct acpi_evaluate_info {
	struct acpi_namespace_node *prefix_node;
	const char *relative_pathname;
	union acpi_operand_object **parameters;
	struct acpi_namespace_node *node;
	union acpi_operand_object *obj_desc;
	char *full_pathname;
	const union acpi_predefined_info *predefined;
	union acpi_operand_object *return_object;
	union acpi_operand_object *parent_package;
	u32 return_flags;
	u32 return_btype;
	u16 param_count;
	u16 node_flags;
	u8 pass_number;
	u8 return_object_type;
	u8 flags;
};

enum {
	AML_FIELD_ACCESS_ANY = 0,
	AML_FIELD_ACCESS_BYTE = 1,
	AML_FIELD_ACCESS_WORD = 2,
	AML_FIELD_ACCESS_DWORD = 3,
	AML_FIELD_ACCESS_QWORD = 4,
	AML_FIELD_ACCESS_BUFFER = 5,
};

typedef enum {
	ACPI_IMODE_LOAD_PASS1 = 1,
	ACPI_IMODE_LOAD_PASS2 = 2,
	ACPI_IMODE_EXECUTE = 3,
} acpi_interpreter_mode;

typedef acpi_status (*acpi_execute_op)(struct acpi_walk_state *);

struct acpi_reg_walk_info {
	u32 function;
	u32 reg_run_count;
	acpi_adr_space_type space_id;
};

enum {
	AML_FIELD_UPDATE_PRESERVE = 0,
	AML_FIELD_UPDATE_WRITE_AS_ONES = 32,
	AML_FIELD_UPDATE_WRITE_AS_ZEROS = 64,
};

struct acpi_signal_fatal_info {
	u32 type;
	u32 code;
	u32 argument;
};

enum {
	MATCH_MTR = 0,
	MATCH_MEQ = 1,
	MATCH_MLE = 2,
	MATCH_MLT = 3,
	MATCH_MGE = 4,
	MATCH_MGT = 5,
};

enum {
	AML_FIELD_ATTRIB_QUICK = 2,
	AML_FIELD_ATTRIB_SEND_RECEIVE = 4,
	AML_FIELD_ATTRIB_BYTE = 6,
	AML_FIELD_ATTRIB_WORD = 8,
	AML_FIELD_ATTRIB_BLOCK = 10,
	AML_FIELD_ATTRIB_BYTES = 11,
	AML_FIELD_ATTRIB_PROCESS_CALL = 12,
	AML_FIELD_ATTRIB_BLOCK_PROCESS_CALL = 13,
	AML_FIELD_ATTRIB_RAW_BYTES = 14,
	AML_FIELD_ATTRIB_RAW_PROCESS_BYTES = 15,
};

typedef enum {
	ACPI_TRACE_AML_METHOD = 0,
	ACPI_TRACE_AML_OPCODE = 1,
	ACPI_TRACE_AML_REGION = 2,
} acpi_trace_event_type;

struct acpi_port_info {
	char *name;
	u16 start;
	u16 end;
	u8 osi_dependency;
};

struct acpi_pci_device {
	acpi_handle device;
	struct acpi_pci_device *next;
};

struct acpi_device_walk_info {
	struct acpi_table_desc *table_desc;
	struct acpi_evaluate_info *evaluate_info;
	u32 device_count;
	u32 num_STA;
	u32 num_INI;
};

enum acpi_return_package_types {
	ACPI_PTYPE1_FIXED = 1,
	ACPI_PTYPE1_VAR = 2,
	ACPI_PTYPE1_OPTION = 3,
	ACPI_PTYPE2 = 4,
	ACPI_PTYPE2_COUNT = 5,
	ACPI_PTYPE2_PKG_COUNT = 6,
	ACPI_PTYPE2_FIXED = 7,
	ACPI_PTYPE2_MIN = 8,
	ACPI_PTYPE2_REV_FIXED = 9,
	ACPI_PTYPE2_FIX_VAR = 10,
	ACPI_PTYPE2_VAR_VAR = 11,
	ACPI_PTYPE2_UUID_PAIR = 12,
	ACPI_PTYPE_CUSTOM = 13,
};

typedef acpi_status (*acpi_object_converter)(struct acpi_namespace_node *, union acpi_operand_object *, union acpi_operand_object **);

struct acpi_simple_repair_info {
	char name[4];
	u32 unexpected_btypes;
	u32 package_index;
	acpi_object_converter object_converter;
};

typedef acpi_status (*acpi_repair_function)(struct acpi_evaluate_info *, union acpi_operand_object **);

struct acpi_repair_info {
	char name[4];
	acpi_repair_function repair_function;
};

struct acpi_namestring_info {
	const char *external_name;
	const char *next_external_char;
	char *internal_name;
	u32 length;
	u32 num_segments;
	u32 num_carats;
	u8 fully_qualified;
};

typedef acpi_status (*acpi_walk_callback)(acpi_handle, u32, void *, void **);

struct acpi_get_devices_info {
	acpi_walk_callback user_function;
	void *context;
	const char *hid;
};

struct aml_resource_small_header {
	u8 descriptor_type;
};

struct aml_resource_irq {
	u8 descriptor_type;
	u16 irq_mask;
	u8 flags;
} __attribute__((packed));

struct aml_resource_dma {
	u8 descriptor_type;
	u8 dma_channel_mask;
	u8 flags;
};

struct aml_resource_start_dependent {
	u8 descriptor_type;
	u8 flags;
};

struct aml_resource_end_dependent {
	u8 descriptor_type;
};

struct aml_resource_io {
	u8 descriptor_type;
	u8 flags;
	u16 minimum;
	u16 maximum;
	u8 alignment;
	u8 address_length;
};

struct aml_resource_fixed_io {
	u8 descriptor_type;
	u16 address;
	u8 address_length;
} __attribute__((packed));

struct aml_resource_vendor_small {
	u8 descriptor_type;
};

struct aml_resource_end_tag {
	u8 descriptor_type;
	u8 checksum;
};

struct aml_resource_fixed_dma {
	u8 descriptor_type;
	u16 request_lines;
	u16 channels;
	u8 width;
} __attribute__((packed));

struct aml_resource_large_header {
	u8 descriptor_type;
	u16 resource_length;
} __attribute__((packed));

struct aml_resource_memory24 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u16 minimum;
	u16 maximum;
	u16 alignment;
	u16 address_length;
} __attribute__((packed));

struct aml_resource_vendor_large {
	u8 descriptor_type;
	u16 resource_length;
} __attribute__((packed));

struct aml_resource_memory32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u32 minimum;
	u32 maximum;
	u32 alignment;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_fixed_memory32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u32 address;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_address {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
} __attribute__((packed));

struct aml_resource_extended_address64 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u8 revision_ID;
	u8 reserved;
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
	u64 type_specific;
} __attribute__((packed));

struct aml_resource_address64 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
} __attribute__((packed));

struct aml_resource_address32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u32 granularity;
	u32 minimum;
	u32 maximum;
	u32 translation_offset;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_address16 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u16 granularity;
	u16 minimum;
	u16 maximum;
	u16 translation_offset;
	u16 address_length;
} __attribute__((packed));

struct aml_resource_extended_irq {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u8 interrupt_count;
	u32 interrupts[1];
} __attribute__((packed));

struct aml_resource_generic_register {
	u8 descriptor_type;
	u16 resource_length;
	u8 address_space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct aml_resource_gpio {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 connection_type;
	u16 flags;
	u16 int_flags;
	u8 pin_config;
	u16 drive_strength;
	u16 debounce_timeout;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_common_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
} __attribute__((packed));

struct aml_resource_csi2_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
} __attribute__((packed));

struct aml_resource_i2c_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 connection_speed;
	u16 slave_address;
} __attribute__((packed));

struct aml_resource_spi_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 connection_speed;
	u8 data_bit_length;
	u8 clock_phase;
	u8 clock_polarity;
	u16 device_selection;
} __attribute__((packed));

struct aml_resource_uart_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 default_baud_rate;
	u16 rx_fifo_size;
	u16 tx_fifo_size;
	u8 parity;
	u8 lines_enabled;
} __attribute__((packed));

struct aml_resource_pin_function {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config;
	u16 function_number;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_config {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 pin_table_offset;
	u16 label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group_function {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 function_number;
	u8 res_source_index;
	u16 res_source_offset;
	u16 res_source_label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group_config {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config_type;
	u32 pin_config_value;
	u8 res_source_index;
	u16 res_source_offset;
	u16 res_source_label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

union aml_resource {
	u8 descriptor_type;
	struct aml_resource_small_header small_header;
	struct aml_resource_large_header large_header;
	struct aml_resource_irq irq;
	struct aml_resource_dma dma;
	struct aml_resource_start_dependent start_dpf;
	struct aml_resource_end_dependent end_dpf;
	struct aml_resource_io io;
	struct aml_resource_fixed_io fixed_io;
	struct aml_resource_fixed_dma fixed_dma;
	struct aml_resource_vendor_small vendor_small;
	struct aml_resource_end_tag end_tag;
	struct aml_resource_memory24 memory24;
	struct aml_resource_generic_register generic_reg;
	struct aml_resource_vendor_large vendor_large;
	struct aml_resource_memory32 memory32;
	struct aml_resource_fixed_memory32 fixed_memory32;
	struct aml_resource_address16 address16;
	struct aml_resource_address32 address32;
	struct aml_resource_address64 address64;
	struct aml_resource_extended_address64 ext_address64;
	struct aml_resource_extended_irq extended_irq;
	struct aml_resource_gpio gpio;
	struct aml_resource_i2c_serialbus i2c_serial_bus;
	struct aml_resource_spi_serialbus spi_serial_bus;
	struct aml_resource_uart_serialbus uart_serial_bus;
	struct aml_resource_csi2_serialbus csi2_serial_bus;
	struct aml_resource_common_serialbus common_serial_bus;
	struct aml_resource_pin_function pin_function;
	struct aml_resource_pin_config pin_config;
	struct aml_resource_pin_group pin_group;
	struct aml_resource_pin_group_function pin_group_function;
	struct aml_resource_pin_group_config pin_group_config;
	struct aml_resource_address address;
	u32 dword_item;
	u16 word_item;
	u8 byte_item;
};

struct acpi_rsconvert_info {
	u8 opcode;
	u8 resource_offset;
	u8 aml_offset;
	u8 value;
};

enum {
	ACPI_RSC_INITGET = 0,
	ACPI_RSC_INITSET = 1,
	ACPI_RSC_FLAGINIT = 2,
	ACPI_RSC_1BITFLAG = 3,
	ACPI_RSC_2BITFLAG = 4,
	ACPI_RSC_3BITFLAG = 5,
	ACPI_RSC_6BITFLAG = 6,
	ACPI_RSC_ADDRESS = 7,
	ACPI_RSC_BITMASK = 8,
	ACPI_RSC_BITMASK16 = 9,
	ACPI_RSC_COUNT = 10,
	ACPI_RSC_COUNT16 = 11,
	ACPI_RSC_COUNT_GPIO_PIN = 12,
	ACPI_RSC_COUNT_GPIO_RES = 13,
	ACPI_RSC_COUNT_GPIO_VEN = 14,
	ACPI_RSC_COUNT_SERIAL_RES = 15,
	ACPI_RSC_COUNT_SERIAL_VEN = 16,
	ACPI_RSC_DATA8 = 17,
	ACPI_RSC_EXIT_EQ = 18,
	ACPI_RSC_EXIT_LE = 19,
	ACPI_RSC_EXIT_NE = 20,
	ACPI_RSC_LENGTH = 21,
	ACPI_RSC_MOVE_GPIO_PIN = 22,
	ACPI_RSC_MOVE_GPIO_RES = 23,
	ACPI_RSC_MOVE_SERIAL_RES = 24,
	ACPI_RSC_MOVE_SERIAL_VEN = 25,
	ACPI_RSC_MOVE8 = 26,
	ACPI_RSC_MOVE16 = 27,
	ACPI_RSC_MOVE32 = 28,
	ACPI_RSC_MOVE64 = 29,
	ACPI_RSC_SET8 = 30,
	ACPI_RSC_SOURCE = 31,
	ACPI_RSC_SOURCEX = 32,
};

typedef u16 acpi_rs_length;

typedef u32 acpi_rsdesc_size;

struct acpi_vendor_uuid {
	u8 subtype;
	u8 data[16];
};

typedef acpi_status (*acpi_walk_resource_callback)(struct acpi_resource *, void *);

struct acpi_vendor_walk_info {
	struct acpi_vendor_uuid *uuid;
	struct acpi_buffer *buffer;
	acpi_status status;
};

struct acpi_fadt_info {
	const char *name;
	u16 address64;
	u16 address32;
	u16 length;
	u8 default_length;
	u8 flags;
};

struct acpi_fadt_pm_info {
	struct acpi_generic_address *target;
	u16 source;
	u8 register_num;
};

struct acpi_table_rsdp {
	char signature[8];
	u8 checksum;
	char oem_id[6];
	u8 revision;
	u32 rsdt_physical_address;
	u32 length;
	u64 xsdt_physical_address;
	u8 extended_checksum;
	u8 reserved[3];
} __attribute__((packed));

struct acpi_pkg_info {
	u8 *free_space;
	acpi_size length;
	u32 object_space;
	u32 num_packages;
};

struct acpi_exception_info {
	char *name;
};

typedef acpi_status (*acpi_pkg_callback)(u8, union acpi_operand_object *, union acpi_generic_state *, void *);

typedef u32 acpi_mutex_handle;

typedef acpi_status (*acpi_walk_aml_callback)(u8 *, u32, u32, u8, void **);

struct acpi_table_mcfg {
	struct acpi_table_header header;
	u8 reserved[8];
};

struct acpi_mcfg_allocation {
	u64 address;
	u16 pci_segment;
	u8 start_bus_number;
	u8 end_bus_number;
	u32 reserved;
};

struct mcfg_entry {
	struct list_head list;
	phys_addr_t addr;
	u16 segment;
	u8 bus_start;
	u8 bus_end;
};

struct mcfg_fixup {
	char oem_id[7];
	char oem_table_id[9];
	u32 oem_revision;
	u16 segment;
	struct resource bus_range;
	const struct pci_ecam_ops *ops;
	struct resource cfgres;
};

enum led_brightness {
	LED_OFF = 0,
	LED_ON = 1,
	LED_HALF = 127,
	LED_FULL = 255,
};

struct led_hw_trigger_type {
	int dummy;
};

struct led_pattern;

struct led_trigger;

struct led_classdev {
	const char *name;
	unsigned int brightness;
	unsigned int max_brightness;
	int flags;
	long unsigned int work_flags;
	void (*brightness_set)(struct led_classdev *, enum led_brightness);
	int (*brightness_set_blocking)(struct led_classdev *, enum led_brightness);
	enum led_brightness (*brightness_get)(struct led_classdev *);
	int (*blink_set)(struct led_classdev *, long unsigned int *, long unsigned int *);
	int (*pattern_set)(struct led_classdev *, struct led_pattern *, u32, int);
	int (*pattern_clear)(struct led_classdev *);
	struct device *dev;
	const struct attribute_group **groups;
	struct list_head node;
	const char *default_trigger;
	long unsigned int blink_delay_on;
	long unsigned int blink_delay_off;
	struct timer_list blink_timer;
	int blink_brightness;
	int new_blink_brightness;
	void (*flash_resume)(struct led_classdev *);
	struct work_struct set_brightness_work;
	int delayed_set_value;
	struct rw_semaphore trigger_lock;
	struct led_trigger *trigger;
	struct list_head trig_list;
	void *trigger_data;
	bool activated;
	struct led_hw_trigger_type *trigger_type;
	int brightness_hw_changed;
	struct kernfs_node *brightness_hw_changed_kn;
	struct mutex led_access;
};

struct led_pattern {
	u32 delta_t;
	int brightness;
};

struct led_trigger {
	const char *name;
	int (*activate)(struct led_classdev *);
	void (*deactivate)(struct led_classdev *);
	struct led_hw_trigger_type *trigger_type;
	rwlock_t leddev_list_lock;
	struct list_head led_cdevs;
	struct list_head next_trig;
	const struct attribute_group **groups;
};

enum power_supply_property {
	POWER_SUPPLY_PROP_STATUS = 0,
	POWER_SUPPLY_PROP_CHARGE_TYPE = 1,
	POWER_SUPPLY_PROP_HEALTH = 2,
	POWER_SUPPLY_PROP_PRESENT = 3,
	POWER_SUPPLY_PROP_ONLINE = 4,
	POWER_SUPPLY_PROP_AUTHENTIC = 5,
	POWER_SUPPLY_PROP_TECHNOLOGY = 6,
	POWER_SUPPLY_PROP_CYCLE_COUNT = 7,
	POWER_SUPPLY_PROP_VOLTAGE_MAX = 8,
	POWER_SUPPLY_PROP_VOLTAGE_MIN = 9,
	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN = 10,
	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN = 11,
	POWER_SUPPLY_PROP_VOLTAGE_NOW = 12,
	POWER_SUPPLY_PROP_VOLTAGE_AVG = 13,
	POWER_SUPPLY_PROP_VOLTAGE_OCV = 14,
	POWER_SUPPLY_PROP_VOLTAGE_BOOT = 15,
	POWER_SUPPLY_PROP_CURRENT_MAX = 16,
	POWER_SUPPLY_PROP_CURRENT_NOW = 17,
	POWER_SUPPLY_PROP_CURRENT_AVG = 18,
	POWER_SUPPLY_PROP_CURRENT_BOOT = 19,
	POWER_SUPPLY_PROP_POWER_NOW = 20,
	POWER_SUPPLY_PROP_POWER_AVG = 21,
	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN = 22,
	POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN = 23,
	POWER_SUPPLY_PROP_CHARGE_FULL = 24,
	POWER_SUPPLY_PROP_CHARGE_EMPTY = 25,
	POWER_SUPPLY_PROP_CHARGE_NOW = 26,
	POWER_SUPPLY_PROP_CHARGE_AVG = 27,
	POWER_SUPPLY_PROP_CHARGE_COUNTER = 28,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT = 29,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX = 30,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE = 31,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX = 32,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT = 33,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX = 34,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_START_THRESHOLD = 35,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD = 36,
	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT = 37,
	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT = 38,
	POWER_SUPPLY_PROP_INPUT_POWER_LIMIT = 39,
	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN = 40,
	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN = 41,
	POWER_SUPPLY_PROP_ENERGY_FULL = 42,
	POWER_SUPPLY_PROP_ENERGY_EMPTY = 43,
	POWER_SUPPLY_PROP_ENERGY_NOW = 44,
	POWER_SUPPLY_PROP_ENERGY_AVG = 45,
	POWER_SUPPLY_PROP_CAPACITY = 46,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN = 47,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX = 48,
	POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN = 49,
	POWER_SUPPLY_PROP_CAPACITY_LEVEL = 50,
	POWER_SUPPLY_PROP_TEMP = 51,
	POWER_SUPPLY_PROP_TEMP_MAX = 52,
	POWER_SUPPLY_PROP_TEMP_MIN = 53,
	POWER_SUPPLY_PROP_TEMP_ALERT_MIN = 54,
	POWER_SUPPLY_PROP_TEMP_ALERT_MAX = 55,
	POWER_SUPPLY_PROP_TEMP_AMBIENT = 56,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN = 57,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX = 58,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW = 59,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG = 60,
	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW = 61,
	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG = 62,
	POWER_SUPPLY_PROP_TYPE = 63,
	POWER_SUPPLY_PROP_USB_TYPE = 64,
	POWER_SUPPLY_PROP_SCOPE = 65,
	POWER_SUPPLY_PROP_PRECHARGE_CURRENT = 66,
	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT = 67,
	POWER_SUPPLY_PROP_CALIBRATE = 68,
	POWER_SUPPLY_PROP_MANUFACTURE_YEAR = 69,
	POWER_SUPPLY_PROP_MANUFACTURE_MONTH = 70,
	POWER_SUPPLY_PROP_MANUFACTURE_DAY = 71,
	POWER_SUPPLY_PROP_MODEL_NAME = 72,
	POWER_SUPPLY_PROP_MANUFACTURER = 73,
	POWER_SUPPLY_PROP_SERIAL_NUMBER = 74,
};

enum power_supply_type {
	POWER_SUPPLY_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_TYPE_BATTERY = 1,
	POWER_SUPPLY_TYPE_UPS = 2,
	POWER_SUPPLY_TYPE_MAINS = 3,
	POWER_SUPPLY_TYPE_USB = 4,
	POWER_SUPPLY_TYPE_USB_DCP = 5,
	POWER_SUPPLY_TYPE_USB_CDP = 6,
	POWER_SUPPLY_TYPE_USB_ACA = 7,
	POWER_SUPPLY_TYPE_USB_TYPE_C = 8,
	POWER_SUPPLY_TYPE_USB_PD = 9,
	POWER_SUPPLY_TYPE_USB_PD_DRP = 10,
	POWER_SUPPLY_TYPE_APPLE_BRICK_ID = 11,
	POWER_SUPPLY_TYPE_WIRELESS = 12,
};

enum power_supply_usb_type {
	POWER_SUPPLY_USB_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_USB_TYPE_SDP = 1,
	POWER_SUPPLY_USB_TYPE_DCP = 2,
	POWER_SUPPLY_USB_TYPE_CDP = 3,
	POWER_SUPPLY_USB_TYPE_ACA = 4,
	POWER_SUPPLY_USB_TYPE_C = 5,
	POWER_SUPPLY_USB_TYPE_PD = 6,
	POWER_SUPPLY_USB_TYPE_PD_DRP = 7,
	POWER_SUPPLY_USB_TYPE_PD_PPS = 8,
	POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID = 9,
};

union power_supply_propval {
	int intval;
	const char *strval;
};

struct power_supply_config {
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	void *drv_data;
	const struct attribute_group **attr_grp;
	char **supplied_to;
	size_t num_supplicants;
};

struct power_supply;

struct power_supply_desc {
	const char *name;
	enum power_supply_type type;
	const enum power_supply_usb_type *usb_types;
	size_t num_usb_types;
	const enum power_supply_property *properties;
	size_t num_properties;
	int (*get_property)(struct power_supply *, enum power_supply_property, union power_supply_propval *);
	int (*set_property)(struct power_supply *, enum power_supply_property, const union power_supply_propval *);
	int (*property_is_writeable)(struct power_supply *, enum power_supply_property);
	void (*external_power_changed)(struct power_supply *);
	void (*set_charged)(struct power_supply *);
	bool no_thermal;
	int use_for_apm;
};

struct thermal_zone_device;

struct power_supply {
	const struct power_supply_desc *desc;
	char **supplied_to;
	size_t num_supplicants;
	char **supplied_from;
	size_t num_supplies;
	struct device_node *of_node;
	void *drv_data;
	struct device dev;
	struct work_struct changed_work;
	struct delayed_work deferred_register_work;
	spinlock_t changed_lock;
	bool changed;
	bool initialized;
	bool removing;
	atomic_t use_cnt;
	struct thermal_zone_device *tzd;
	struct thermal_cooling_device *tcd;
	struct led_trigger *charging_full_trig;
	char *charging_full_trig_name;
	struct led_trigger *charging_trig;
	char *charging_trig_name;
	struct led_trigger *full_trig;
	char *full_trig_name;
	struct led_trigger *online_trig;
	char *online_trig_name;
	struct led_trigger *charging_blink_full_solid_trig;
	char *charging_blink_full_solid_trig_name;
};

struct acpi_ac_bl {
	const char *hid;
	int hrv;
};

struct acpi_ac {
	struct power_supply *charger;
	struct power_supply_desc charger_desc;
	struct acpi_device *device;
	long long unsigned int state;
	struct notifier_block battery_nb;
};

struct input_id {
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
};

struct input_absinfo {
	__s32 value;
	__s32 minimum;
	__s32 maximum;
	__s32 fuzz;
	__s32 flat;
	__s32 resolution;
};

struct input_keymap_entry {
	__u8 flags;
	__u8 len;
	__u16 index;
	__u32 keycode;
	__u8 scancode[32];
};

struct ff_replay {
	__u16 length;
	__u16 delay;
};

struct ff_trigger {
	__u16 button;
	__u16 interval;
};

struct ff_envelope {
	__u16 attack_length;
	__u16 attack_level;
	__u16 fade_length;
	__u16 fade_level;
};

struct ff_constant_effect {
	__s16 level;
	struct ff_envelope envelope;
};

struct ff_ramp_effect {
	__s16 start_level;
	__s16 end_level;
	struct ff_envelope envelope;
};

struct ff_condition_effect {
	__u16 right_saturation;
	__u16 left_saturation;
	__s16 right_coeff;
	__s16 left_coeff;
	__u16 deadband;
	__s16 center;
};

struct ff_periodic_effect {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	__s16 *custom_data;
};

struct ff_rumble_effect {
	__u16 strong_magnitude;
	__u16 weak_magnitude;
};

struct ff_effect {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct input_device_id {
	kernel_ulong_t flags;
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
	kernel_ulong_t evbit[1];
	kernel_ulong_t keybit[12];
	kernel_ulong_t relbit[1];
	kernel_ulong_t absbit[1];
	kernel_ulong_t mscbit[1];
	kernel_ulong_t ledbit[1];
	kernel_ulong_t sndbit[1];
	kernel_ulong_t ffbit[2];
	kernel_ulong_t swbit[1];
	kernel_ulong_t propbit[1];
	kernel_ulong_t driver_info;
};

struct input_value {
	__u16 type;
	__u16 code;
	__s32 value;
};

enum input_clock_type {
	INPUT_CLK_REAL = 0,
	INPUT_CLK_MONO = 1,
	INPUT_CLK_BOOT = 2,
	INPUT_CLK_MAX = 3,
};

struct ff_device;

struct input_dev_poller;

struct input_mt;

struct input_handle;

struct input_dev {
	const char *name;
	const char *phys;
	const char *uniq;
	struct input_id id;
	long unsigned int propbit[1];
	long unsigned int evbit[1];
	long unsigned int keybit[12];
	long unsigned int relbit[1];
	long unsigned int absbit[1];
	long unsigned int mscbit[1];
	long unsigned int ledbit[1];
	long unsigned int sndbit[1];
	long unsigned int ffbit[2];
	long unsigned int swbit[1];
	unsigned int hint_events_per_packet;
	unsigned int keycodemax;
	unsigned int keycodesize;
	void *keycode;
	int (*setkeycode)(struct input_dev *, const struct input_keymap_entry *, unsigned int *);
	int (*getkeycode)(struct input_dev *, struct input_keymap_entry *);
	struct ff_device *ff;
	struct input_dev_poller *poller;
	unsigned int repeat_key;
	struct timer_list timer;
	int rep[2];
	struct input_mt *mt;
	struct input_absinfo *absinfo;
	long unsigned int key[12];
	long unsigned int led[1];
	long unsigned int snd[1];
	long unsigned int sw[1];
	int (*open)(struct input_dev *);
	void (*close)(struct input_dev *);
	int (*flush)(struct input_dev *, struct file *);
	int (*event)(struct input_dev *, unsigned int, unsigned int, int);
	struct input_handle *grab;
	spinlock_t event_lock;
	struct mutex mutex;
	unsigned int users;
	bool going_away;
	struct device dev;
	struct list_head h_list;
	struct list_head node;
	unsigned int num_vals;
	unsigned int max_vals;
	struct input_value *vals;
	bool devres_managed;
	ktime_t timestamp[3];
	bool inhibited;
};

struct ff_device {
	int (*upload)(struct input_dev *, struct ff_effect *, struct ff_effect *);
	int (*erase)(struct input_dev *, int);
	int (*playback)(struct input_dev *, int, int);
	void (*set_gain)(struct input_dev *, u16);
	void (*set_autocenter)(struct input_dev *, u16);
	void (*destroy)(struct ff_device *);
	void *private;
	long unsigned int ffbit[2];
	struct mutex mutex;
	int max_effects;
	struct ff_effect *effects;
	struct file *effect_owners[0];
};

struct input_handler;

struct input_handle {
	void *private;
	int open;
	const char *name;
	struct input_dev *dev;
	struct input_handler *handler;
	struct list_head d_node;
	struct list_head h_node;
};

struct input_handler {
	void *private;
	void (*event)(struct input_handle *, unsigned int, unsigned int, int);
	void (*events)(struct input_handle *, const struct input_value *, unsigned int);
	bool (*filter)(struct input_handle *, unsigned int, unsigned int, int);
	bool (*match)(struct input_handler *, struct input_dev *);
	int (*connect)(struct input_handler *, struct input_dev *, const struct input_device_id *);
	void (*disconnect)(struct input_handle *);
	void (*start)(struct input_handle *);
	bool legacy_minors;
	int minor;
	const char *name;
	const struct input_device_id *id_table;
	struct list_head h_list;
	struct list_head node;
};

enum {
	ACPI_BUTTON_LID_INIT_IGNORE = 0,
	ACPI_BUTTON_LID_INIT_OPEN = 1,
	ACPI_BUTTON_LID_INIT_METHOD = 2,
	ACPI_BUTTON_LID_INIT_DISABLED = 3,
};

struct acpi_button {
	unsigned int type;
	struct input_dev *input;
	char phys[32];
	long unsigned int pushed;
	int last_state;
	ktime_t last_time;
	bool suspended;
	bool lid_state_initialized;
};

struct acpi_fan_fps {
	u64 control;
	u64 trip_point;
	u64 speed;
	u64 noise_level;
	u64 power;
	char name[20];
	struct device_attribute dev_attr;
};

struct acpi_fan_fif {
	u64 revision;
	u64 fine_grain_ctrl;
	u64 step_size;
	u64 low_speed_notification;
};

struct acpi_fan {
	bool acpi4;
	struct acpi_fan_fif fif;
	struct acpi_fan_fps *fps;
	int fps_count;
	struct thermal_cooling_device *cdev;
};

struct acpi_pci_slot {
	struct pci_slot *pci_slot;
	struct list_head list;
};

struct acpi_power_register {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct acpi_lpi_states_array {
	unsigned int size;
	unsigned int composite_states_size;
	struct acpi_lpi_state *entries;
	struct acpi_lpi_state *composite_states[8];
};

struct container_dev {
	struct device dev;
	int (*offline)(struct container_dev *);
};

enum thermal_device_mode {
	THERMAL_DEVICE_DISABLED = 0,
	THERMAL_DEVICE_ENABLED = 1,
};

enum thermal_trip_type {
	THERMAL_TRIP_ACTIVE = 0,
	THERMAL_TRIP_PASSIVE = 1,
	THERMAL_TRIP_HOT = 2,
	THERMAL_TRIP_CRITICAL = 3,
};

enum thermal_trend {
	THERMAL_TREND_STABLE = 0,
	THERMAL_TREND_RAISING = 1,
	THERMAL_TREND_DROPPING = 2,
	THERMAL_TREND_RAISE_FULL = 3,
	THERMAL_TREND_DROP_FULL = 4,
};

enum thermal_notify_event {
	THERMAL_EVENT_UNSPECIFIED = 0,
	THERMAL_EVENT_TEMP_SAMPLE = 1,
	THERMAL_TRIP_VIOLATED = 2,
	THERMAL_TRIP_CHANGED = 3,
	THERMAL_DEVICE_DOWN = 4,
	THERMAL_DEVICE_UP = 5,
	THERMAL_DEVICE_POWER_CAPABILITY_CHANGED = 6,
	THERMAL_TABLE_CHANGED = 7,
	THERMAL_EVENT_KEEP_ALIVE = 8,
};

struct thermal_zone_device_ops {
	int (*bind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*unbind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*get_temp)(struct thermal_zone_device *, int *);
	int (*set_trips)(struct thermal_zone_device *, int, int);
	int (*change_mode)(struct thermal_zone_device *, enum thermal_device_mode);
	int (*get_trip_type)(struct thermal_zone_device *, int, enum thermal_trip_type *);
	int (*get_trip_temp)(struct thermal_zone_device *, int, int *);
	int (*set_trip_temp)(struct thermal_zone_device *, int, int);
	int (*get_trip_hyst)(struct thermal_zone_device *, int, int *);
	int (*set_trip_hyst)(struct thermal_zone_device *, int, int);
	int (*get_crit_temp)(struct thermal_zone_device *, int *);
	int (*set_emul_temp)(struct thermal_zone_device *, int);
	int (*get_trend)(struct thermal_zone_device *, int, enum thermal_trend *);
	void (*hot)(struct thermal_zone_device *);
	void (*critical)(struct thermal_zone_device *);
};

struct thermal_attr;

struct thermal_zone_params;

struct thermal_governor;

struct thermal_zone_device {
	int id;
	char type[20];
	struct device device;
	struct attribute_group trips_attribute_group;
	struct thermal_attr *trip_temp_attrs;
	struct thermal_attr *trip_type_attrs;
	struct thermal_attr *trip_hyst_attrs;
	enum thermal_device_mode mode;
	void *devdata;
	int trips;
	long unsigned int trips_disabled;
	long unsigned int passive_delay_jiffies;
	long unsigned int polling_delay_jiffies;
	int temperature;
	int last_temperature;
	int emul_temperature;
	int passive;
	int prev_low_trip;
	int prev_high_trip;
	atomic_t need_update;
	struct thermal_zone_device_ops *ops;
	struct thermal_zone_params *tzp;
	struct thermal_governor *governor;
	void *governor_data;
	struct list_head thermal_instances;
	struct ida ida;
	struct mutex lock;
	struct list_head node;
	struct delayed_work poll_queue;
	enum thermal_notify_event notify_event;
};

struct thermal_bind_params;

struct thermal_zone_params {
	char governor_name[20];
	bool no_hwmon;
	int num_tbps;
	struct thermal_bind_params *tbp;
	u32 sustainable_power;
	s32 k_po;
	s32 k_pu;
	s32 k_i;
	s32 k_d;
	s32 integral_cutoff;
	int slope;
	int offset;
};

struct thermal_governor {
	char name[20];
	int (*bind_to_tz)(struct thermal_zone_device *);
	void (*unbind_from_tz)(struct thermal_zone_device *);
	int (*throttle)(struct thermal_zone_device *, int);
	struct list_head governor_list;
};

struct thermal_bind_params {
	struct thermal_cooling_device *cdev;
	int weight;
	int trip_mask;
	long unsigned int *binding_limits;
	int (*match)(struct thermal_zone_device *, struct thermal_cooling_device *);
};

struct acpi_thermal_state {
	u8 critical: 1;
	u8 hot: 1;
	u8 passive: 1;
	u8 active: 1;
	u8 reserved: 4;
	int active_index;
};

struct acpi_thermal_state_flags {
	u8 valid: 1;
	u8 enabled: 1;
	u8 reserved: 6;
};

struct acpi_thermal_critical {
	struct acpi_thermal_state_flags flags;
	long unsigned int temperature;
};

struct acpi_thermal_hot {
	struct acpi_thermal_state_flags flags;
	long unsigned int temperature;
};

struct acpi_thermal_passive {
	struct acpi_thermal_state_flags flags;
	long unsigned int temperature;
	long unsigned int tc1;
	long unsigned int tc2;
	long unsigned int tsp;
	struct acpi_handle_list devices;
};

struct acpi_thermal_active {
	struct acpi_thermal_state_flags flags;
	long unsigned int temperature;
	struct acpi_handle_list devices;
};

struct acpi_thermal_trips {
	struct acpi_thermal_critical critical;
	struct acpi_thermal_hot hot;
	struct acpi_thermal_passive passive;
	struct acpi_thermal_active active[10];
};

struct acpi_thermal_flags {
	u8 cooling_mode: 1;
	u8 devices: 1;
	u8 reserved: 6;
};

struct acpi_thermal {
	struct acpi_device *device;
	acpi_bus_id name;
	long unsigned int temperature;
	long unsigned int last_temperature;
	long unsigned int polling_frequency;
	volatile u8 zombie;
	struct acpi_thermal_flags flags;
	struct acpi_thermal_state state;
	struct acpi_thermal_trips trips;
	struct acpi_handle_list devices;
	struct thermal_zone_device *thermal_zone;
	int kelvin_offset;
	struct work_struct thermal_check_work;
	struct mutex thermal_check_lock;
	refcount_t thermal_check_count;
};

struct acpi_table_slit {
	struct acpi_table_header header;
	u64 locality_count;
	u8 entry[1];
} __attribute__((packed));

struct acpi_table_srat {
	struct acpi_table_header header;
	u32 table_revision;
	u64 reserved;
};

struct acpi_srat_cpu_affinity {
	struct acpi_subtable_header header;
	u8 proximity_domain_lo;
	u8 apic_id;
	u32 flags;
	u8 local_sapic_eid;
	u8 proximity_domain_hi[3];
	u32 clock_domain;
};

struct acpi_srat_mem_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u16 reserved;
	u64 base_address;
	u64 length;
	u32 reserved1;
	u32 flags;
	u64 reserved2;
} __attribute__((packed));

struct acpi_srat_x2apic_cpu_affinity {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 proximity_domain;
	u32 apic_id;
	u32 flags;
	u32 clock_domain;
	u32 reserved2;
};

struct acpi_srat_generic_affinity {
	struct acpi_subtable_header header;
	u8 reserved;
	u8 device_handle_type;
	u32 proximity_domain;
	u8 device_handle[16];
	u32 flags;
	u32 reserved1;
};

enum acpi_hmat_type {
	ACPI_HMAT_TYPE_PROXIMITY = 0,
	ACPI_HMAT_TYPE_LOCALITY = 1,
	ACPI_HMAT_TYPE_CACHE = 2,
	ACPI_HMAT_TYPE_RESERVED = 3,
};

struct acpi_hmat_proximity_domain {
	struct acpi_hmat_structure header;
	u16 flags;
	u16 reserved1;
	u32 processor_PD;
	u32 memory_PD;
	u32 reserved2;
	u64 reserved3;
	u64 reserved4;
};

struct acpi_hmat_locality {
	struct acpi_hmat_structure header;
	u8 flags;
	u8 data_type;
	u8 min_transfer_size;
	u8 reserved1;
	u32 number_of_initiator_Pds;
	u32 number_of_target_Pds;
	u32 reserved2;
	u64 entry_base_unit;
};

struct acpi_hmat_cache {
	struct acpi_hmat_structure header;
	u32 memory_PD;
	u32 reserved1;
	u64 cache_size;
	u32 cache_attributes;
	u16 reserved2;
	u16 number_of_SMBIOShandles;
};

struct node_hmem_attrs {
	unsigned int read_bandwidth;
	unsigned int write_bandwidth;
	unsigned int read_latency;
	unsigned int write_latency;
};

enum cache_indexing {
	NODE_CACHE_DIRECT_MAP = 0,
	NODE_CACHE_INDEXED = 1,
	NODE_CACHE_OTHER = 2,
};

enum cache_write_policy {
	NODE_CACHE_WRITE_BACK = 0,
	NODE_CACHE_WRITE_THROUGH = 1,
	NODE_CACHE_WRITE_OTHER = 2,
};

struct node_cache_attrs {
	enum cache_indexing indexing;
	enum cache_write_policy write_policy;
	u64 size;
	u16 line_size;
	u8 level;
};

enum locality_types {
	WRITE_LATENCY = 0,
	READ_LATENCY = 1,
	WRITE_BANDWIDTH = 2,
	READ_BANDWIDTH = 3,
};

struct memory_locality {
	struct list_head node;
	struct acpi_hmat_locality *hmat_loc;
};

struct target_cache {
	struct list_head node;
	struct node_cache_attrs cache_attrs;
};

struct memory_target {
	struct list_head node;
	unsigned int memory_pxm;
	unsigned int processor_pxm;
	struct resource memregions;
	struct node_hmem_attrs hmem_attrs[2];
	struct list_head caches;
	struct node_cache_attrs cache_attrs;
	bool registered;
};

struct memory_initiator {
	struct list_head node;
	unsigned int processor_pxm;
	bool has_cpu;
};

struct acpi_memory_info {
	struct list_head list;
	u64 start_addr;
	u64 length;
	short unsigned int caching;
	short unsigned int write_protect;
	unsigned int enabled: 1;
};

struct acpi_memory_device {
	struct acpi_device *device;
	struct list_head res_list;
};

enum dmi_entry_type {
	DMI_ENTRY_BIOS = 0,
	DMI_ENTRY_SYSTEM = 1,
	DMI_ENTRY_BASEBOARD = 2,
	DMI_ENTRY_CHASSIS = 3,
	DMI_ENTRY_PROCESSOR = 4,
	DMI_ENTRY_MEM_CONTROLLER = 5,
	DMI_ENTRY_MEM_MODULE = 6,
	DMI_ENTRY_CACHE = 7,
	DMI_ENTRY_PORT_CONNECTOR = 8,
	DMI_ENTRY_SYSTEM_SLOT = 9,
	DMI_ENTRY_ONBOARD_DEVICE = 10,
	DMI_ENTRY_OEMSTRINGS = 11,
	DMI_ENTRY_SYSCONF = 12,
	DMI_ENTRY_BIOS_LANG = 13,
	DMI_ENTRY_GROUP_ASSOC = 14,
	DMI_ENTRY_SYSTEM_EVENT_LOG = 15,
	DMI_ENTRY_PHYS_MEM_ARRAY = 16,
	DMI_ENTRY_MEM_DEVICE = 17,
	DMI_ENTRY_32_MEM_ERROR = 18,
	DMI_ENTRY_MEM_ARRAY_MAPPED_ADDR = 19,
	DMI_ENTRY_MEM_DEV_MAPPED_ADDR = 20,
	DMI_ENTRY_BUILTIN_POINTING_DEV = 21,
	DMI_ENTRY_PORTABLE_BATTERY = 22,
	DMI_ENTRY_SYSTEM_RESET = 23,
	DMI_ENTRY_HW_SECURITY = 24,
	DMI_ENTRY_SYSTEM_POWER_CONTROLS = 25,
	DMI_ENTRY_VOLTAGE_PROBE = 26,
	DMI_ENTRY_COOLING_DEV = 27,
	DMI_ENTRY_TEMP_PROBE = 28,
	DMI_ENTRY_ELECTRICAL_CURRENT_PROBE = 29,
	DMI_ENTRY_OOB_REMOTE_ACCESS = 30,
	DMI_ENTRY_BIS_ENTRY = 31,
	DMI_ENTRY_SYSTEM_BOOT = 32,
	DMI_ENTRY_MGMT_DEV = 33,
	DMI_ENTRY_MGMT_DEV_COMPONENT = 34,
	DMI_ENTRY_MGMT_DEV_THRES = 35,
	DMI_ENTRY_MEM_CHANNEL = 36,
	DMI_ENTRY_IPMI_DEV = 37,
	DMI_ENTRY_SYS_POWER_SUPPLY = 38,
	DMI_ENTRY_ADDITIONAL = 39,
	DMI_ENTRY_ONBOARD_DEV_EXT = 40,
	DMI_ENTRY_MGMT_CONTROLLER_HOST = 41,
	DMI_ENTRY_INACTIVE = 126,
	DMI_ENTRY_END_OF_TABLE = 127,
};

enum {
	POWER_SUPPLY_STATUS_UNKNOWN = 0,
	POWER_SUPPLY_STATUS_CHARGING = 1,
	POWER_SUPPLY_STATUS_DISCHARGING = 2,
	POWER_SUPPLY_STATUS_NOT_CHARGING = 3,
	POWER_SUPPLY_STATUS_FULL = 4,
};

enum {
	POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0,
	POWER_SUPPLY_TECHNOLOGY_NiMH = 1,
	POWER_SUPPLY_TECHNOLOGY_LION = 2,
	POWER_SUPPLY_TECHNOLOGY_LIPO = 3,
	POWER_SUPPLY_TECHNOLOGY_LiFe = 4,
	POWER_SUPPLY_TECHNOLOGY_NiCd = 5,
	POWER_SUPPLY_TECHNOLOGY_LiMn = 6,
};

enum {
	POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN = 0,
	POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL = 1,
	POWER_SUPPLY_CAPACITY_LEVEL_LOW = 2,
	POWER_SUPPLY_CAPACITY_LEVEL_NORMAL = 3,
	POWER_SUPPLY_CAPACITY_LEVEL_HIGH = 4,
	POWER_SUPPLY_CAPACITY_LEVEL_FULL = 5,
};

struct acpi_battery_hook {
	const char *name;
	int (*add_battery)(struct power_supply *);
	int (*remove_battery)(struct power_supply *);
	struct list_head list;
};

enum {
	ACPI_BATTERY_ALARM_PRESENT = 0,
	ACPI_BATTERY_XINFO_PRESENT = 1,
	ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY = 2,
	ACPI_BATTERY_QUIRK_THINKPAD_MAH = 3,
	ACPI_BATTERY_QUIRK_DEGRADED_FULL_CHARGE = 4,
};

struct acpi_battery {
	struct mutex lock;
	struct mutex sysfs_lock;
	struct power_supply *bat;
	struct power_supply_desc bat_desc;
	struct acpi_device *device;
	struct notifier_block pm_nb;
	struct list_head list;
	long unsigned int update_time;
	int revision;
	int rate_now;
	int capacity_now;
	int voltage_now;
	int design_capacity;
	int full_charge_capacity;
	int technology;
	int design_voltage;
	int design_capacity_warning;
	int design_capacity_low;
	int cycle_count;
	int measurement_accuracy;
	int max_sampling_time;
	int min_sampling_time;
	int max_averaging_interval;
	int min_averaging_interval;
	int capacity_granularity_1;
	int capacity_granularity_2;
	int alarm;
	char model_number[32];
	char serial_number[32];
	char type[32];
	char oem_info[32];
	int state;
	int power_unit;
	long unsigned int flags;
};

struct acpi_offsets {
	size_t offset;
	u8 mode;
};

struct acpi_pcct_hw_reduced {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved;
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
} __attribute__((packed));

struct acpi_pcct_shared_memory {
	u32 signature;
	u16 command;
	u16 status;
};

struct mbox_chan;

struct mbox_chan_ops {
	int (*send_data)(struct mbox_chan *, void *);
	int (*flush)(struct mbox_chan *, long unsigned int);
	int (*startup)(struct mbox_chan *);
	void (*shutdown)(struct mbox_chan *);
	bool (*last_tx_done)(struct mbox_chan *);
	bool (*peek_data)(struct mbox_chan *);
};

struct mbox_controller;

struct mbox_client;

struct mbox_chan {
	struct mbox_controller *mbox;
	unsigned int txdone_method;
	struct mbox_client *cl;
	struct completion tx_complete;
	void *active_req;
	unsigned int msg_count;
	unsigned int msg_free;
	void *msg_data[20];
	spinlock_t lock;
	void *con_priv;
};

struct mbox_controller {
	struct device *dev;
	const struct mbox_chan_ops *ops;
	struct mbox_chan *chans;
	int num_chans;
	bool txdone_irq;
	bool txdone_poll;
	unsigned int txpoll_period;
	struct mbox_chan * (*of_xlate)(struct mbox_controller *, const struct of_phandle_args *);
	struct hrtimer poll_hrt;
	struct list_head node;
};

struct mbox_client {
	struct device *dev;
	bool tx_block;
	long unsigned int tx_tout;
	bool knows_txdone;
	void (*rx_callback)(struct mbox_client *, void *);
	void (*tx_prepare)(struct mbox_client *, void *);
	void (*tx_done)(struct mbox_client *, void *, int);
};

struct cpc_register_resource {
	acpi_object_type type;
	u64 *sys_mem_vaddr;
	union {
		struct cpc_reg reg;
		u64 int_value;
	} cpc_entry;
};

struct cpc_desc {
	int num_entries;
	int version;
	int cpu_id;
	int write_cmd_status;
	int write_cmd_id;
	struct cpc_register_resource cpc_regs[21];
	struct acpi_psd_package domain_info;
	struct kobject kobj;
};

enum cppc_regs {
	HIGHEST_PERF = 0,
	NOMINAL_PERF = 1,
	LOW_NON_LINEAR_PERF = 2,
	LOWEST_PERF = 3,
	GUARANTEED_PERF = 4,
	DESIRED_PERF = 5,
	MIN_PERF = 6,
	MAX_PERF = 7,
	PERF_REDUC_TOLERANCE = 8,
	TIME_WINDOW = 9,
	CTR_WRAP_TIME = 10,
	REFERENCE_CTR = 11,
	DELIVERED_CTR = 12,
	PERF_LIMITED = 13,
	ENABLE = 14,
	AUTO_SEL_ENABLE = 15,
	AUTO_ACT_WINDOW = 16,
	ENERGY_PERF = 17,
	REFERENCE_PERF = 18,
	LOWEST_FREQ = 19,
	NOMINAL_FREQ = 20,
};

struct cppc_perf_caps {
	u32 guaranteed_perf;
	u32 highest_perf;
	u32 nominal_perf;
	u32 lowest_perf;
	u32 lowest_nonlinear_perf;
	u32 lowest_freq;
	u32 nominal_freq;
};

struct cppc_perf_ctrls {
	u32 max_perf;
	u32 min_perf;
	u32 desired_perf;
};

struct cppc_perf_fb_ctrs {
	u64 reference;
	u64 delivered;
	u64 reference_perf;
	u64 wraparound_time;
};

struct cppc_cpudata {
	struct list_head node;
	struct cppc_perf_caps perf_caps;
	struct cppc_perf_ctrls perf_ctrls;
	struct cppc_perf_fb_ctrs perf_fb_ctrs;
	unsigned int shared_type;
	cpumask_var_t shared_cpu_map;
};

struct cppc_pcc_data {
	struct mbox_chan *pcc_channel;
	void *pcc_comm_addr;
	bool pcc_channel_acquired;
	unsigned int deadline_us;
	unsigned int pcc_mpar;
	unsigned int pcc_mrtt;
	unsigned int pcc_nominal;
	bool pending_pcc_write_cmd;
	bool platform_owns_pcc;
	unsigned int pcc_write_cnt;
	struct rw_semaphore pcc_lock;
	wait_queue_head_t pcc_write_wait_q;
	ktime_t last_cmd_cmpl_time;
	ktime_t last_mpar_reset;
	int mpar_count;
	int refcount;
};

enum acpi_pptt_type {
	ACPI_PPTT_TYPE_PROCESSOR = 0,
	ACPI_PPTT_TYPE_CACHE = 1,
	ACPI_PPTT_TYPE_ID = 2,
	ACPI_PPTT_TYPE_RESERVED = 3,
};

struct acpi_pptt_processor {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 flags;
	u32 parent;
	u32 acpi_processor_id;
	u32 number_of_priv_resources;
};

struct acpi_pptt_cache {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 flags;
	u32 next_level_of_cache;
	u32 size;
	u32 number_of_sets;
	u8 associativity;
	u8 attributes;
	u16 line_size;
};

struct acpi_whea_header {
	u8 action;
	u8 instruction;
	u8 flags;
	u8 reserved;
	struct acpi_generic_address register_region;
	u64 value;
	u64 mask;
} __attribute__((packed));

struct acpi_hest_header {
	u16 type;
	u16 source_id;
};

struct cper_sec_mem_err {
	u64 validation_bits;
	u64 error_status;
	u64 physical_addr;
	u64 physical_addr_mask;
	u16 node;
	u16 card;
	u16 module;
	u16 bank;
	u16 device;
	u16 row;
	u16 column;
	u16 bit_pos;
	u64 requestor_id;
	u64 responder_id;
	u64 target_id;
	u8 error_type;
	u8 extended;
	u16 rank;
	u16 mem_array_handle;
	u16 mem_dev_handle;
};

struct apei_exec_context;

typedef int (*apei_exec_ins_func_t)(struct apei_exec_context *, struct acpi_whea_header *);

struct apei_exec_ins_type;

struct apei_exec_context {
	u32 ip;
	u64 value;
	u64 var1;
	u64 var2;
	u64 src_base;
	u64 dst_base;
	struct apei_exec_ins_type *ins_table;
	u32 instructions;
	struct acpi_whea_header *action_table;
	u32 entries;
};

struct apei_exec_ins_type {
	u32 flags;
	apei_exec_ins_func_t run;
};

struct apei_resources {
	struct list_head iomem;
	struct list_head ioport;
};

typedef int (*apei_exec_entry_func_t)(struct apei_exec_context *, struct acpi_whea_header *, void *);

struct apei_res {
	struct list_head list;
	long unsigned int start;
	long unsigned int end;
};

struct acpi_table_hest {
	struct acpi_table_header header;
	u32 error_source_count;
};

enum acpi_hest_types {
	ACPI_HEST_TYPE_IA32_CHECK = 0,
	ACPI_HEST_TYPE_IA32_CORRECTED_CHECK = 1,
	ACPI_HEST_TYPE_IA32_NMI = 2,
	ACPI_HEST_TYPE_NOT_USED3 = 3,
	ACPI_HEST_TYPE_NOT_USED4 = 4,
	ACPI_HEST_TYPE_NOT_USED5 = 5,
	ACPI_HEST_TYPE_AER_ROOT_PORT = 6,
	ACPI_HEST_TYPE_AER_ENDPOINT = 7,
	ACPI_HEST_TYPE_AER_BRIDGE = 8,
	ACPI_HEST_TYPE_GENERIC_ERROR = 9,
	ACPI_HEST_TYPE_GENERIC_ERROR_V2 = 10,
	ACPI_HEST_TYPE_IA32_DEFERRED_CHECK = 11,
	ACPI_HEST_TYPE_RESERVED = 12,
};

struct acpi_hest_notify {
	u8 type;
	u8 length;
	u16 config_write_enable;
	u32 poll_interval;
	u32 vector;
	u32 polling_threshold_value;
	u32 polling_threshold_window;
	u32 error_threshold_value;
	u32 error_threshold_window;
};

struct acpi_hest_ia_machine_check {
	struct acpi_hest_header header;
	u16 reserved1;
	u8 flags;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	u64 global_capability_data;
	u64 global_control_data;
	u8 num_hardware_banks;
	u8 reserved3[7];
};

struct acpi_hest_ia_corrected {
	struct acpi_hest_header header;
	u16 reserved1;
	u8 flags;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	struct acpi_hest_notify notify;
	u8 num_hardware_banks;
	u8 reserved2[3];
};

struct acpi_hest_generic {
	struct acpi_hest_header header;
	u16 related_source_id;
	u8 reserved;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	u32 max_raw_data_length;
	struct acpi_generic_address error_status_address;
	struct acpi_hest_notify notify;
	u32 error_block_length;
} __attribute__((packed));

struct acpi_hest_ia_deferred_check {
	struct acpi_hest_header header;
	u16 reserved1;
	u8 flags;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	struct acpi_hest_notify notify;
	u8 num_hardware_banks;
	u8 reserved2[3];
};

enum hest_status {
	HEST_ENABLED = 0,
	HEST_DISABLED = 1,
	HEST_NOT_FOUND = 2,
};

typedef int (*apei_hest_func_t)(struct acpi_hest_header *, void *);

struct ghes_arr {
	struct platform_device **ghes_devs;
	unsigned int count;
};

struct acpi_table_erst {
	struct acpi_table_header header;
	u32 header_length;
	u32 reserved;
	u32 entries;
};

enum acpi_erst_actions {
	ACPI_ERST_BEGIN_WRITE = 0,
	ACPI_ERST_BEGIN_READ = 1,
	ACPI_ERST_BEGIN_CLEAR = 2,
	ACPI_ERST_END = 3,
	ACPI_ERST_SET_RECORD_OFFSET = 4,
	ACPI_ERST_EXECUTE_OPERATION = 5,
	ACPI_ERST_CHECK_BUSY_STATUS = 6,
	ACPI_ERST_GET_COMMAND_STATUS = 7,
	ACPI_ERST_GET_RECORD_ID = 8,
	ACPI_ERST_SET_RECORD_ID = 9,
	ACPI_ERST_GET_RECORD_COUNT = 10,
	ACPI_ERST_BEGIN_DUMMY_WRIITE = 11,
	ACPI_ERST_NOT_USED = 12,
	ACPI_ERST_GET_ERROR_RANGE = 13,
	ACPI_ERST_GET_ERROR_LENGTH = 14,
	ACPI_ERST_GET_ERROR_ATTRIBUTES = 15,
	ACPI_ERST_EXECUTE_TIMINGS = 16,
	ACPI_ERST_ACTION_RESERVED = 17,
};

enum acpi_erst_instructions {
	ACPI_ERST_READ_REGISTER = 0,
	ACPI_ERST_READ_REGISTER_VALUE = 1,
	ACPI_ERST_WRITE_REGISTER = 2,
	ACPI_ERST_WRITE_REGISTER_VALUE = 3,
	ACPI_ERST_NOOP = 4,
	ACPI_ERST_LOAD_VAR1 = 5,
	ACPI_ERST_LOAD_VAR2 = 6,
	ACPI_ERST_STORE_VAR1 = 7,
	ACPI_ERST_ADD = 8,
	ACPI_ERST_SUBTRACT = 9,
	ACPI_ERST_ADD_VALUE = 10,
	ACPI_ERST_SUBTRACT_VALUE = 11,
	ACPI_ERST_STALL = 12,
	ACPI_ERST_STALL_WHILE_TRUE = 13,
	ACPI_ERST_SKIP_NEXT_IF_TRUE = 14,
	ACPI_ERST_GOTO = 15,
	ACPI_ERST_SET_SRC_ADDRESS_BASE = 16,
	ACPI_ERST_SET_DST_ADDRESS_BASE = 17,
	ACPI_ERST_MOVE_DATA = 18,
	ACPI_ERST_INSTRUCTION_RESERVED = 19,
};

struct cper_record_header {
	char signature[4];
	u16 revision;
	u32 signature_end;
	u16 section_count;
	u32 error_severity;
	u32 validation_bits;
	u32 record_length;
	u64 timestamp;
	guid_t platform_id;
	guid_t partition_id;
	guid_t creator_id;
	guid_t notification_type;
	u64 record_id;
	u32 flags;
	u64 persistence_information;
	u8 reserved[12];
} __attribute__((packed));

struct cper_section_descriptor {
	u32 section_offset;
	u32 section_length;
	u16 revision;
	u8 validation_bits;
	u8 reserved;
	u32 flags;
	guid_t section_type;
	guid_t fru_id;
	u32 section_severity;
	u8 fru_text[20];
};

struct erst_erange {
	u64 base;
	u64 size;
	void *vaddr;
	u32 attr;
};

struct erst_record_id_cache {
	struct mutex lock;
	u64 *entries;
	int len;
	int size;
	int refcount;
};

struct cper_pstore_record {
	struct cper_record_header hdr;
	struct cper_section_descriptor sec_hdr;
	char data[0];
};

struct acpi_bert_region {
	u32 block_status;
	u32 raw_data_offset;
	u32 raw_data_length;
	u32 data_length;
	u32 error_severity;
};

struct acpi_hest_generic_status {
	u32 block_status;
	u32 raw_data_offset;
	u32 raw_data_length;
	u32 data_length;
	u32 error_severity;
};

enum acpi_hest_notify_types {
	ACPI_HEST_NOTIFY_POLLED = 0,
	ACPI_HEST_NOTIFY_EXTERNAL = 1,
	ACPI_HEST_NOTIFY_LOCAL = 2,
	ACPI_HEST_NOTIFY_SCI = 3,
	ACPI_HEST_NOTIFY_NMI = 4,
	ACPI_HEST_NOTIFY_CMCI = 5,
	ACPI_HEST_NOTIFY_MCE = 6,
	ACPI_HEST_NOTIFY_GPIO = 7,
	ACPI_HEST_NOTIFY_SEA = 8,
	ACPI_HEST_NOTIFY_SEI = 9,
	ACPI_HEST_NOTIFY_GSIV = 10,
	ACPI_HEST_NOTIFY_SOFTWARE_DELEGATED = 11,
	ACPI_HEST_NOTIFY_RESERVED = 12,
};

struct acpi_hest_generic_v2 {
	struct acpi_hest_header header;
	u16 related_source_id;
	u8 reserved;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	u32 max_raw_data_length;
	struct acpi_generic_address error_status_address;
	struct acpi_hest_notify notify;
	u32 error_block_length;
	struct acpi_generic_address read_ack_register;
	u64 read_ack_preserve;
	u64 read_ack_write;
} __attribute__((packed));

struct cper_sec_proc_arm {
	u32 validation_bits;
	u16 err_info_num;
	u16 context_info_num;
	u32 section_length;
	u8 affinity_level;
	u8 reserved[3];
	u64 mpidr;
	u64 midr;
	u32 running_state;
	u32 psci_state;
};

struct cper_arm_err_info {
	u8 version;
	u8 length;
	u16 validation_bits;
	u8 type;
	u16 multiple_error;
	u8 flags;
	u64 error_info;
	u64 virt_fault_addr;
	u64 physical_fault_addr;
} __attribute__((packed));

struct cper_sec_pcie {
	u64 validation_bits;
	u32 port_type;
	struct {
		u8 minor;
		u8 major;
		u8 reserved[2];
	} version;
	u16 command;
	u16 status;
	u32 reserved;
	struct {
		u16 vendor_id;
		u16 device_id;
		u8 class_code[3];
		u8 function;
		u8 device;
		u16 segment;
		u8 bus;
		u8 secondary_bus;
		u16 slot;
		u8 reserved;
	} __attribute__((packed)) device_id;
	struct {
		u32 lower;
		u32 upper;
	} serial_number;
	struct {
		u16 secondary_status;
		u16 control;
	} bridge;
	u8 capability[60];
	u8 aer_info[96];
};

struct ghes {
	union {
		struct acpi_hest_generic *generic;
		struct acpi_hest_generic_v2 *generic_v2;
	};
	struct acpi_hest_generic_status *estatus;
	long unsigned int flags;
	union {
		struct list_head list;
		struct timer_list timer;
		unsigned int irq;
	};
};

struct ghes_estatus_node {
	struct llist_node llnode;
	struct acpi_hest_generic *generic;
	struct ghes *ghes;
	int task_work_cpu;
	struct callback_head task_work;
};

struct ghes_estatus_cache {
	u32 estatus_len;
	atomic_t count;
	struct acpi_hest_generic *generic;
	long long unsigned int time_in;
	struct callback_head rcu;
};

enum {
	GHES_SEV_NO = 0,
	GHES_SEV_CORRECTED = 1,
	GHES_SEV_RECOVERABLE = 2,
	GHES_SEV_PANIC = 3,
};

struct ghes_vendor_record_entry {
	struct work_struct work;
	int error_severity;
	char vendor_record[0];
};

struct tps68470_pmic_table {
	u32 address;
	u32 reg;
	u32 bitmask;
};

struct tps68470_pmic_opregion {
	struct mutex lock;
	struct regmap *regmap;
};

struct acpi_table_iort {
	struct acpi_table_header header;
	u32 node_count;
	u32 node_offset;
	u32 reserved;
};

struct acpi_iort_node {
	u8 type;
	u16 length;
	u8 revision;
	u32 identifier;
	u32 mapping_count;
	u32 mapping_offset;
	char node_data[1];
} __attribute__((packed));

enum acpi_iort_node_type {
	ACPI_IORT_NODE_ITS_GROUP = 0,
	ACPI_IORT_NODE_NAMED_COMPONENT = 1,
	ACPI_IORT_NODE_PCI_ROOT_COMPLEX = 2,
	ACPI_IORT_NODE_SMMU = 3,
	ACPI_IORT_NODE_SMMU_V3 = 4,
	ACPI_IORT_NODE_PMCG = 5,
	ACPI_IORT_NODE_RMR = 6,
};

struct acpi_iort_id_mapping {
	u32 input_base;
	u32 id_count;
	u32 output_base;
	u32 output_reference;
	u32 flags;
};

struct acpi_iort_its_group {
	u32 its_count;
	u32 identifiers[1];
};

struct acpi_iort_named_component {
	u32 node_flags;
	u64 memory_properties;
	u8 memory_address_limit;
	char device_name[1];
} __attribute__((packed));

struct acpi_iort_root_complex {
	u64 memory_properties;
	u32 ats_attribute;
	u32 pci_segment_number;
	u8 memory_address_limit;
	u8 reserved[3];
} __attribute__((packed));

struct acpi_iort_smmu {
	u64 base_address;
	u64 span;
	u32 model;
	u32 flags;
	u32 global_interrupt_offset;
	u32 context_interrupt_count;
	u32 context_interrupt_offset;
	u32 pmu_interrupt_count;
	u32 pmu_interrupt_offset;
	u64 interrupts[1];
} __attribute__((packed));

struct acpi_iort_smmu_v3 {
	u64 base_address;
	u32 flags;
	u32 reserved;
	u64 vatos_address;
	u32 model;
	u32 event_gsiv;
	u32 pri_gsiv;
	u32 gerr_gsiv;
	u32 sync_gsiv;
	u32 pxm;
	u32 id_mapping_index;
} __attribute__((packed));

struct acpi_iort_pmcg {
	u64 page0_base_address;
	u32 overflow_gsiv;
	u32 node_reference;
	u64 page1_base_address;
};

struct iort_its_msi_chip {
	struct list_head list;
	struct fwnode_handle *fw_node;
	phys_addr_t base_addr;
	u32 translation_id;
};

struct iort_fwnode {
	struct list_head list;
	struct acpi_iort_node *iort_node;
	struct fwnode_handle *fwnode;
};

typedef acpi_status (*iort_find_node_callback)(struct acpi_iort_node *, void *);

struct iort_pci_alias_info {
	struct device *dev;
	struct acpi_iort_node *node;
};

struct iort_dev_config {
	const char *name;
	int (*dev_init)(struct acpi_iort_node *);
	void (*dev_dma_configure)(struct device *, struct acpi_iort_node *);
	int (*dev_count_resources)(struct acpi_iort_node *);
	void (*dev_init_resources)(struct resource *, struct acpi_iort_node *);
	int (*dev_set_proximity)(struct device *, struct acpi_iort_node *);
	int (*dev_add_platdata)(struct platform_device *);
};

enum arch_timer_ppi_nr {
	ARCH_TIMER_PHYS_SECURE_PPI = 0,
	ARCH_TIMER_PHYS_NONSECURE_PPI = 1,
	ARCH_TIMER_VIRT_PPI = 2,
	ARCH_TIMER_HYP_PPI = 3,
	ARCH_TIMER_HYP_VIRT_PPI = 4,
	ARCH_TIMER_MAX_TIMER_PPI = 5,
};

struct arch_timer_mem_frame {
	bool valid;
	phys_addr_t cntbase;
	size_t size;
	int phys_irq;
	int virt_irq;
};

struct arch_timer_mem {
	phys_addr_t cntctlbase;
	size_t size;
	struct arch_timer_mem_frame frame[8];
};

struct acpi_table_gtdt {
	struct acpi_table_header header;
	u64 counter_block_addresss;
	u32 reserved;
	u32 secure_el1_interrupt;
	u32 secure_el1_flags;
	u32 non_secure_el1_interrupt;
	u32 non_secure_el1_flags;
	u32 virtual_timer_interrupt;
	u32 virtual_timer_flags;
	u32 non_secure_el2_interrupt;
	u32 non_secure_el2_flags;
	u64 counter_read_block_address;
	u32 platform_timer_count;
	u32 platform_timer_offset;
} __attribute__((packed));

struct acpi_gtdt_header {
	u8 type;
	u16 length;
} __attribute__((packed));

enum acpi_gtdt_type {
	ACPI_GTDT_TYPE_TIMER_BLOCK = 0,
	ACPI_GTDT_TYPE_WATCHDOG = 1,
	ACPI_GTDT_TYPE_RESERVED = 2,
};

struct acpi_gtdt_timer_block {
	struct acpi_gtdt_header header;
	u8 reserved;
	u64 block_address;
	u32 timer_count;
	u32 timer_offset;
} __attribute__((packed));

struct acpi_gtdt_timer_entry {
	u8 frame_number;
	u8 reserved[3];
	u64 base_address;
	u64 el0_base_address;
	u32 timer_interrupt;
	u32 timer_flags;
	u32 virtual_timer_interrupt;
	u32 virtual_timer_flags;
	u32 common_flags;
} __attribute__((packed));

struct acpi_gtdt_watchdog {
	struct acpi_gtdt_header header;
	u8 reserved;
	u64 refresh_frame_address;
	u64 control_frame_address;
	u32 timer_interrupt;
	u32 timer_flags;
} __attribute__((packed));

struct acpi_gtdt_descriptor {
	struct acpi_table_gtdt *gtdt;
	void *gtdt_end;
	void *platform_timer;
};

struct pnp_device_id {
	__u8 id[8];
	kernel_ulong_t driver_data;
};

struct pnp_card_device_id {
	__u8 id[8];
	kernel_ulong_t driver_data;
	struct {
		__u8 id[8];
	} devs[8];
};

struct pnp_protocol;

struct pnp_id;

struct pnp_card {
	struct device dev;
	unsigned char number;
	struct list_head global_list;
	struct list_head protocol_list;
	struct list_head devices;
	struct pnp_protocol *protocol;
	struct pnp_id *id;
	char name[50];
	unsigned char pnpver;
	unsigned char productver;
	unsigned int serial;
	unsigned char checksum;
	struct proc_dir_entry *procdir;
};

struct pnp_dev;

struct pnp_protocol {
	struct list_head protocol_list;
	char *name;
	int (*get)(struct pnp_dev *);
	int (*set)(struct pnp_dev *);
	int (*disable)(struct pnp_dev *);
	bool (*can_wakeup)(struct pnp_dev *);
	int (*suspend)(struct pnp_dev *, pm_message_t);
	int (*resume)(struct pnp_dev *);
	unsigned char number;
	struct device dev;
	struct list_head cards;
	struct list_head devices;
};

struct pnp_id {
	char id[8];
	struct pnp_id *next;
};

struct pnp_card_driver;

struct pnp_card_link {
	struct pnp_card *card;
	struct pnp_card_driver *driver;
	void *driver_data;
	pm_message_t pm_state;
};

struct pnp_driver {
	const char *name;
	const struct pnp_device_id *id_table;
	unsigned int flags;
	int (*probe)(struct pnp_dev *, const struct pnp_device_id *);
	void (*remove)(struct pnp_dev *);
	void (*shutdown)(struct pnp_dev *);
	int (*suspend)(struct pnp_dev *, pm_message_t);
	int (*resume)(struct pnp_dev *);
	struct device_driver driver;
};

struct pnp_card_driver {
	struct list_head global_list;
	char *name;
	const struct pnp_card_device_id *id_table;
	unsigned int flags;
	int (*probe)(struct pnp_card_link *, const struct pnp_card_device_id *);
	void (*remove)(struct pnp_card_link *);
	int (*suspend)(struct pnp_card_link *, pm_message_t);
	int (*resume)(struct pnp_card_link *);
	struct pnp_driver link;
};

struct pnp_dev {
	struct device dev;
	u64 dma_mask;
	unsigned int number;
	int status;
	struct list_head global_list;
	struct list_head protocol_list;
	struct list_head card_list;
	struct list_head rdev_list;
	struct pnp_protocol *protocol;
	struct pnp_card *card;
	struct pnp_driver *driver;
	struct pnp_card_link *card_link;
	struct pnp_id *id;
	int active;
	int capabilities;
	unsigned int num_dependent_sets;
	struct list_head resources;
	struct list_head options;
	char name[50];
	int flags;
	struct proc_dir_entry *procent;
	void *data;
};

struct pnp_resource {
	struct list_head list;
	struct resource res;
};

struct pnp_port {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t size;
	unsigned char flags;
};

typedef struct {
	long unsigned int bits[4];
} pnp_irq_mask_t;

struct pnp_irq {
	pnp_irq_mask_t map;
	unsigned char flags;
};

struct pnp_dma {
	unsigned char map;
	unsigned char flags;
};

struct pnp_mem {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t size;
	unsigned char flags;
};

struct pnp_option {
	struct list_head list;
	unsigned int flags;
	long unsigned int type;
	union {
		struct pnp_port port;
		struct pnp_irq irq;
		struct pnp_dma dma;
		struct pnp_mem mem;
	} u;
};

struct pnp_info_buffer {
	char *buffer;
	char *curr;
	long unsigned int size;
	long unsigned int len;
	int stop;
	int error;
};

typedef struct pnp_info_buffer pnp_info_buffer_t;

struct pnp_fixup {
	char id[7];
	void (*quirk_function)(struct pnp_dev *);
};

struct acpipnp_parse_option_s {
	struct pnp_dev *dev;
	unsigned int option_flags;
};

struct deferred_device {
	struct amba_device *dev;
	struct resource *parent;
	struct list_head node;
};

struct find_data {
	struct amba_device *dev;
	struct device *parent;
	const char *busid;
	unsigned int id;
	unsigned int mask;
};

struct clk_bulk_devres {
	struct clk_bulk_data *clks;
	int num_clks;
};

struct clk_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct clk *clk;
	struct clk_hw *clk_hw;
};

struct clk_lookup_alloc {
	struct clk_lookup cl;
	char dev_id[20];
	char con_id[16];
};

struct clk_notifier {
	struct clk *clk;
	struct srcu_notifier_head notifier_head;
	struct list_head node;
};

struct clk {
	struct clk_core *core;
	struct device *dev;
	const char *dev_id;
	const char *con_id;
	long unsigned int min_rate;
	long unsigned int max_rate;
	unsigned int exclusive_count;
	struct hlist_node clks_node;
};

struct clk_notifier_data {
	struct clk *clk;
	long unsigned int old_rate;
	long unsigned int new_rate;
};

struct clk_parent_map;

struct clk_core {
	const char *name;
	const struct clk_ops *ops;
	struct clk_hw *hw;
	struct module *owner;
	struct device *dev;
	struct device_node *of_node;
	struct clk_core *parent;
	struct clk_parent_map *parents;
	u8 num_parents;
	u8 new_parent_index;
	long unsigned int rate;
	long unsigned int req_rate;
	long unsigned int new_rate;
	struct clk_core *new_parent;
	struct clk_core *new_child;
	long unsigned int flags;
	bool orphan;
	bool rpm_enabled;
	unsigned int enable_count;
	unsigned int prepare_count;
	unsigned int protect_count;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int accuracy;
	int phase;
	struct clk_duty duty;
	struct hlist_head children;
	struct hlist_node child_node;
	struct hlist_head clks;
	unsigned int notifier_count;
	struct dentry *dentry;
	struct hlist_node debug_node;
	struct kref ref;
};

struct clk_onecell_data {
	struct clk **clks;
	unsigned int clk_num;
};

struct clk_hw_onecell_data {
	unsigned int num;
	struct clk_hw *hws[0];
};

struct clk_parent_map {
	const struct clk_hw *hw;
	struct clk_core *core;
	const char *fw_name;
	const char *name;
	int index;
};

struct trace_event_raw_clk {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_clk_rate {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int rate;
	char __data[0];
};

struct trace_event_raw_clk_rate_range {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int min;
	long unsigned int max;
	char __data[0];
};

struct trace_event_raw_clk_parent {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_pname;
	char __data[0];
};

struct trace_event_raw_clk_phase {
	struct trace_entry ent;
	u32 __data_loc_name;
	int phase;
	char __data[0];
};

struct trace_event_raw_clk_duty_cycle {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int num;
	unsigned int den;
	char __data[0];
};

struct trace_event_data_offsets_clk {
	u32 name;
};

struct trace_event_data_offsets_clk_rate {
	u32 name;
};

struct trace_event_data_offsets_clk_rate_range {
	u32 name;
};

struct trace_event_data_offsets_clk_parent {
	u32 name;
	u32 pname;
};

struct trace_event_data_offsets_clk_phase {
	u32 name;
};

struct trace_event_data_offsets_clk_duty_cycle {
	u32 name;
};

typedef void (*btf_trace_clk_enable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_enable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_set_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_rate_complete)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_min_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_max_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_rate_range)(void *, struct clk_core *, long unsigned int, long unsigned int);

typedef void (*btf_trace_clk_set_parent)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_parent_complete)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_phase)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_phase_complete)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_duty_cycle)(void *, struct clk_core *, struct clk_duty *);

typedef void (*btf_trace_clk_set_duty_cycle_complete)(void *, struct clk_core *, struct clk_duty *);

struct clk_notifier_devres {
	struct clk *clk;
	struct notifier_block *nb;
};

struct of_clk_provider {
	struct list_head link;
	struct device_node *node;
	struct clk * (*get)(struct of_phandle_args *, void *);
	struct clk_hw * (*get_hw)(struct of_phandle_args *, void *);
	void *data;
};

struct clock_provider {
	void (*clk_init_cb)(struct device_node *);
	struct device_node *np;
	struct list_head node;
};

struct clk_div_table {
	unsigned int val;
	unsigned int div;
};

struct clk_divider {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	const struct clk_div_table *table;
	spinlock_t *lock;
};

typedef void (*of_init_fn_1)(struct device_node *);

struct clk_fixed_factor {
	struct clk_hw hw;
	unsigned int mult;
	unsigned int div;
};

struct clk_fixed_rate {
	struct clk_hw hw;
	long unsigned int fixed_rate;
	long unsigned int fixed_accuracy;
	long unsigned int flags;
};

struct clk_gate {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	u8 flags;
	spinlock_t *lock;
};

struct clk_multiplier {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	spinlock_t *lock;
};

struct clk_mux {
	struct clk_hw hw;
	void *reg;
	u32 *table;
	u32 mask;
	u8 shift;
	u8 flags;
	spinlock_t *lock;
};

struct clk_composite {
	struct clk_hw hw;
	struct clk_ops ops;
	struct clk_hw *mux_hw;
	struct clk_hw *rate_hw;
	struct clk_hw *gate_hw;
	const struct clk_ops *mux_ops;
	const struct clk_ops *rate_ops;
	const struct clk_ops *gate_ops;
};

struct clk_fractional_divider {
	struct clk_hw hw;
	void *reg;
	u8 mshift;
	u8 mwidth;
	u32 mmask;
	u8 nshift;
	u8 nwidth;
	u32 nmask;
	u8 flags;
	void (*approximation)(struct clk_hw *, long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *);
	spinlock_t *lock;
};

struct clk_gpio {
	struct clk_hw hw;
	struct gpio_desc *gpiod;
};

struct bm1880_clock_data {
	void *pll_base;
	void *sys_base;
	struct clk_hw_onecell_data hw_data;
};

struct bm1880_gate_clock {
	unsigned int id;
	const char *name;
	const char *parent;
	u32 gate_reg;
	s8 gate_shift;
	long unsigned int flags;
};

struct bm1880_mux_clock {
	unsigned int id;
	const char *name;
	const char * const *parents;
	s8 num_parents;
	u32 reg;
	s8 shift;
	long unsigned int flags;
};

struct bm1880_div_clock {
	unsigned int id;
	const char *name;
	u32 reg;
	u8 shift;
	u8 width;
	u32 initval;
	const struct clk_div_table *table;
	long unsigned int flags;
};

struct bm1880_div_hw_clock {
	struct bm1880_div_clock div;
	void *base;
	spinlock_t *lock;
	struct clk_hw hw;
	struct clk_init_data init;
};

struct bm1880_composite_clock {
	unsigned int id;
	const char *name;
	const char *parent;
	const char * const *parents;
	unsigned int num_parents;
	long unsigned int flags;
	u32 gate_reg;
	u32 mux_reg;
	u32 div_reg;
	s8 gate_shift;
	s8 mux_shift;
	s8 div_shift;
	s8 div_width;
	s16 div_initval;
	const struct clk_div_table *table;
};

struct bm1880_pll_clock {
	unsigned int id;
	const char *name;
	u32 reg;
	long unsigned int flags;
};

struct bm1880_pll_hw_clock {
	struct bm1880_pll_clock pll;
	void *base;
	struct clk_hw hw;
	struct clk_init_data init;
};

struct fsl_sai_clk {
	struct clk_divider div;
	struct clk_gate gate;
	spinlock_t lock;
};

struct ccsr_guts {
	u32 porpllsr;
	u32 porbmsr;
	u32 porimpscr;
	u32 pordevsr;
	u32 pordbgmsr;
	u32 pordevsr2;
	u8 res018[8];
	u32 porcir;
	u8 res024[12];
	u32 gpiocr;
	u8 res034[12];
	u32 gpoutdr;
	u8 res044[12];
	u32 gpindr;
	u8 res054[12];
	u32 pmuxcr;
	u32 pmuxcr2;
	u32 dmuxcr;
	u8 res06c[4];
	u32 devdisr;
	u32 devdisr2;
	u8 res078[4];
	u32 pmjcr;
	u32 powmgtcsr;
	u32 pmrccr;
	u32 pmpdccr;
	u32 pmcdr;
	u32 mcpsumr;
	u32 rstrscr;
	u32 ectrstcr;
	u32 autorstsr;
	u32 pvr;
	u32 svr;
	u8 res0a8[8];
	u32 rstcr;
	u8 res0b4[12];
	u32 iovselsr;
	u8 res0c4[60];
	u32 rcwsr[16];
	u8 res140[228];
	u32 iodelay1;
	u32 iodelay2;
	u8 res22c[984];
	u32 pamubypenr;
	u8 res608[504];
	u32 clkdvdr;
	u8 res804[252];
	u32 ircr;
	u8 res904[4];
	u32 dmacr;
	u8 res90c[8];
	u32 elbccr;
	u8 res918[520];
	u32 ddr1clkdr;
	u32 ddr2clkdr;
	u32 ddrclkdr;
	u8 resb2c[724];
	u32 clkocr;
	u8 rese04[12];
	u32 ddrdllcr;
	u8 rese14[12];
	u32 lbcdllcr;
	u32 cpfor;
	u8 rese28[220];
	u32 srds1cr0;
	u32 srds1cr1;
	u8 resf0c[32];
	u32 itcr;
	u8 resf30[16];
	u32 srds2cr0;
	u32 srds2cr1;
};

struct clockgen_pll_div {
	struct clk *clk;
	char name[32];
};

struct clockgen_pll {
	struct clockgen_pll_div div[32];
};

struct clockgen_sourceinfo {
	u32 flags;
	int pll;
	int div;
};

struct clockgen_muxinfo {
	struct clockgen_sourceinfo clksel[16];
};

struct clockgen;

struct clockgen_chipinfo {
	const char *compat;
	const char *guts_compat;
	const struct clockgen_muxinfo *cmux_groups[2];
	const struct clockgen_muxinfo *hwaccel[5];
	void (*init_periph)(struct clockgen *);
	int cmux_to_group[9];
	u32 pll_mask;
	u32 flags;
};

struct clockgen {
	struct device_node *node;
	void *regs;
	struct clockgen_chipinfo info;
	struct clk *sysclk;
	struct clk *coreclk;
	struct clockgen_pll pll[6];
	struct clk *cmux[8];
	struct clk *hwaccel[5];
	struct clk *fman[2];
	struct ccsr_guts *guts;
};

struct mux_hwclock {
	struct clk_hw hw;
	struct clockgen *cg;
	const struct clockgen_muxinfo *info;
	u32 *reg;
	u8 parent_to_clksel[16];
	s8 clksel_to_parent[16];
	int num_parents;
};

enum xgene_pll_type {
	PLL_TYPE_PCP = 0,
	PLL_TYPE_SOC = 1,
};

struct xgene_clk_pll {
	struct clk_hw hw;
	void *reg;
	spinlock_t *lock;
	u32 pll_offset;
	enum xgene_pll_type type;
	int version;
};

struct xgene_clk_pmd {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u32 mask;
	u64 denom;
	u32 flags;
	spinlock_t *lock;
};

struct xgene_dev_parameters {
	void *csr_reg;
	u32 reg_clk_offset;
	u32 reg_clk_mask;
	u32 reg_csr_offset;
	u32 reg_csr_mask;
	void *divider_reg;
	u32 reg_divider_offset;
	u32 reg_divider_shift;
	u32 reg_divider_width;
};

struct xgene_clk {
	struct clk_hw hw;
	spinlock_t *lock;
	struct xgene_dev_parameters param;
};

struct owl_clk_common {
	struct regmap *regmap;
	struct clk_hw hw;
};

struct owl_reset_map;

struct owl_clk_desc {
	struct owl_clk_common **clks;
	long unsigned int num_clks;
	struct clk_hw_onecell_data *hw_clks;
	const struct owl_reset_map *resets;
	long unsigned int num_resets;
	struct regmap *regmap;
};

struct owl_reset_map {
	u32 reg;
	u32 bit;
};

struct owl_gate_hw {
	u32 reg;
	u8 bit_idx;
	u8 gate_flags;
};

struct owl_gate {
	struct owl_gate_hw gate_hw;
	struct owl_clk_common common;
};

struct owl_mux_hw {
	u32 reg;
	u8 shift;
	u8 width;
};

struct owl_mux {
	struct owl_mux_hw mux_hw;
	struct owl_clk_common common;
};

struct owl_divider_hw {
	u32 reg;
	u8 shift;
	u8 width;
	u8 div_flags;
	struct clk_div_table *table;
};

struct owl_divider {
	struct owl_divider_hw div_hw;
	struct owl_clk_common common;
};

struct clk_factor_table {
	unsigned int val;
	unsigned int mul;
	unsigned int div;
};

struct owl_factor_hw {
	u32 reg;
	u8 shift;
	u8 width;
	u8 fct_flags;
	struct clk_factor_table *table;
};

struct owl_factor {
	struct owl_factor_hw factor_hw;
	struct owl_clk_common common;
};

union owl_rate {
	struct owl_divider_hw div_hw;
	struct owl_factor_hw factor_hw;
	struct clk_fixed_factor fix_fact_hw;
};

struct owl_composite {
	struct owl_mux_hw mux_hw;
	struct owl_gate_hw gate_hw;
	union owl_rate rate;
	const struct clk_ops *fix_fact_ops;
	struct owl_clk_common common;
};

struct clk_pll_table {
	unsigned int val;
	long unsigned int rate;
};

struct owl_pll_hw {
	u32 reg;
	u32 bfreq;
	u8 bit_idx;
	u8 shift;
	u8 width;
	u8 min_mul;
	u8 max_mul;
	u8 delay;
	const struct clk_pll_table *table;
};

struct owl_pll {
	struct owl_pll_hw pll_hw;
	struct owl_clk_common common;
};

struct reset_controller_dev;

struct reset_control_ops {
	int (*reset)(struct reset_controller_dev *, long unsigned int);
	int (*assert)(struct reset_controller_dev *, long unsigned int);
	int (*deassert)(struct reset_controller_dev *, long unsigned int);
	int (*status)(struct reset_controller_dev *, long unsigned int);
};

struct reset_controller_dev {
	const struct reset_control_ops *ops;
	struct module *owner;
	struct list_head list;
	struct list_head reset_control_head;
	struct device *dev;
	struct device_node *of_node;
	int of_reset_n_cells;
	int (*of_xlate)(struct reset_controller_dev *, const struct of_phandle_args *);
	unsigned int nr_resets;
};

struct owl_reset {
	struct reset_controller_dev rcdev;
	const struct owl_reset_map *reset_map;
	struct regmap *regmap;
};

enum iproc_arm_pll_fid {
	ARM_PLL_FID_CRYSTAL_CLK = 0,
	ARM_PLL_FID_SYS_CLK = 2,
	ARM_PLL_FID_CH0_SLOW_CLK = 6,
	ARM_PLL_FID_CH1_FAST_CLK = 7,
};

struct iproc_arm_pll {
	struct clk_hw hw;
	void *base;
	long unsigned int rate;
};

struct iproc_pll_vco_param {
	long unsigned int rate;
	unsigned int ndiv_int;
	unsigned int ndiv_frac;
	unsigned int pdiv;
};

struct iproc_clk_reg_op {
	unsigned int offset;
	unsigned int shift;
	unsigned int width;
};

struct iproc_asiu_gate {
	unsigned int offset;
	unsigned int en_shift;
};

struct iproc_pll_aon_pwr_ctrl {
	unsigned int offset;
	unsigned int pwr_width;
	unsigned int pwr_shift;
	unsigned int iso_shift;
};

struct iproc_pll_reset_ctrl {
	unsigned int offset;
	unsigned int reset_shift;
	unsigned int p_reset_shift;
};

struct iproc_pll_dig_filter_ctrl {
	unsigned int offset;
	unsigned int ki_shift;
	unsigned int ki_width;
	unsigned int kp_shift;
	unsigned int kp_width;
	unsigned int ka_shift;
	unsigned int ka_width;
};

struct iproc_pll_sw_ctrl {
	unsigned int offset;
	unsigned int shift;
};

struct iproc_pll_vco_ctrl {
	unsigned int u_offset;
	unsigned int l_offset;
};

struct iproc_pll_ctrl {
	long unsigned int flags;
	struct iproc_pll_aon_pwr_ctrl aon;
	struct iproc_asiu_gate asiu;
	struct iproc_pll_reset_ctrl reset;
	struct iproc_pll_dig_filter_ctrl dig_filter;
	struct iproc_pll_sw_ctrl sw_ctrl;
	struct iproc_clk_reg_op ndiv_int;
	struct iproc_clk_reg_op ndiv_frac;
	struct iproc_clk_reg_op pdiv;
	struct iproc_pll_vco_ctrl vco_ctrl;
	struct iproc_clk_reg_op status;
	struct iproc_clk_reg_op macro_mode;
};

struct iproc_clk_enable_ctrl {
	unsigned int offset;
	unsigned int enable_shift;
	unsigned int hold_shift;
	unsigned int bypass_shift;
};

struct iproc_clk_ctrl {
	unsigned int channel;
	long unsigned int flags;
	struct iproc_clk_enable_ctrl enable;
	struct iproc_clk_reg_op mdiv;
};

enum kp_band {
	KP_BAND_MID = 0,
	KP_BAND_HIGH = 1,
	KP_BAND_HIGH_HIGH = 2,
};

enum vco_freq_range {
	VCO_LOW = 700000000,
	VCO_MID = 1200000000,
	VCO_HIGH = 2200000000,
	VCO_HIGH_HIGH = 3100000000,
	VCO_MAX = 4000000000,
};

struct iproc_pll {
	void *status_base;
	void *control_base;
	void *pwr_base;
	void *asiu_base;
	const struct iproc_pll_ctrl *ctrl;
	const struct iproc_pll_vco_param *vco_param;
	unsigned int num_vco_entries;
};

struct iproc_clk {
	struct clk_hw hw;
	struct iproc_pll *pll;
	const struct iproc_clk_ctrl *ctrl;
};

struct iproc_asiu_div {
	unsigned int offset;
	unsigned int en_shift;
	unsigned int high_shift;
	unsigned int high_width;
	unsigned int low_shift;
	unsigned int low_width;
};

struct iproc_asiu;

struct iproc_asiu_clk {
	struct clk_hw hw;
	const char *name;
	struct iproc_asiu *asiu;
	long unsigned int rate;
	struct iproc_asiu_div div;
	struct iproc_asiu_gate gate;
};

struct iproc_asiu {
	void *div_base;
	void *gate_base;
	struct clk_hw_onecell_data *clk_data;
	struct iproc_asiu_clk *clks;
};

struct bcm2835_cprman {
	struct device *dev;
	void *regs;
	spinlock_t regs_lock;
	unsigned int soc;
	const char *real_parent_names[7];
	struct clk_hw_onecell_data onecell;
};

struct cprman_plat_data {
	unsigned int soc;
};

struct bcm2835_pll_ana_bits;

struct bcm2835_pll_data {
	const char *name;
	u32 cm_ctrl_reg;
	u32 a2w_ctrl_reg;
	u32 frac_reg;
	u32 ana_reg_base;
	u32 reference_enable_mask;
	u32 lock_mask;
	u32 flags;
	const struct bcm2835_pll_ana_bits *ana;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int max_fb_rate;
};

struct bcm2835_pll_ana_bits {
	u32 mask0;
	u32 set0;
	u32 mask1;
	u32 set1;
	u32 mask3;
	u32 set3;
	u32 fb_prediv_mask;
};

struct bcm2835_pll_divider_data {
	const char *name;
	const char *source_pll;
	u32 cm_reg;
	u32 a2w_reg;
	u32 load_mask;
	u32 hold_mask;
	u32 fixed_divider;
	u32 flags;
};

struct bcm2835_clock_data {
	const char *name;
	const char * const *parents;
	int num_mux_parents;
	unsigned int set_rate_parent;
	u32 ctl_reg;
	u32 div_reg;
	u32 int_bits;
	u32 frac_bits;
	u32 flags;
	bool is_vpu_clock;
	bool is_mash_clock;
	bool low_jitter;
	u32 tcnt_mux;
};

struct bcm2835_gate_data {
	const char *name;
	const char *parent;
	u32 ctl_reg;
};

struct bcm2835_pll {
	struct clk_hw hw;
	struct bcm2835_cprman *cprman;
	const struct bcm2835_pll_data *data;
};

struct bcm2835_pll_divider {
	struct clk_divider div;
	struct bcm2835_cprman *cprman;
	const struct bcm2835_pll_divider_data *data;
};

struct bcm2835_clock {
	struct clk_hw hw;
	struct bcm2835_cprman *cprman;
	const struct bcm2835_clock_data *data;
};

struct bcm2835_clk_desc {
	struct clk_hw * (*clk_register)(struct bcm2835_cprman *, const void *);
	unsigned int supported;
	const void *data;
};

struct berlin2_avpll_vco {
	struct clk_hw hw;
	void *base;
	u8 flags;
};

struct berlin2_avpll_channel {
	struct clk_hw hw;
	void *base;
	u8 flags;
	u8 index;
};

struct berlin2_pll_map {
	const u8 vcodiv[16];
	u8 mult;
	u8 fbdiv_shift;
	u8 rfdiv_shift;
	u8 divsel_shift;
};

struct berlin2_pll {
	struct clk_hw hw;
	void *base;
	struct berlin2_pll_map map;
};

struct berlin2_div_map {
	u16 pll_select_offs;
	u16 pll_switch_offs;
	u16 div_select_offs;
	u16 div_switch_offs;
	u16 div3_switch_offs;
	u16 gate_offs;
	u8 pll_select_shift;
	u8 pll_switch_shift;
	u8 div_select_shift;
	u8 div_switch_shift;
	u8 div3_switch_shift;
	u8 gate_shift;
};

struct berlin2_div {
	struct clk_hw hw;
	void *base;
	struct berlin2_div_map map;
	spinlock_t *lock;
};

struct hisi_clock_data {
	struct clk_onecell_data clk_data;
	void *base;
};

struct hisi_fixed_rate_clock {
	unsigned int id;
	char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int fixed_rate;
};

struct hisi_fixed_factor_clock {
	unsigned int id;
	char *name;
	const char *parent_name;
	long unsigned int mult;
	long unsigned int div;
	long unsigned int flags;
};

struct hisi_mux_clock {
	unsigned int id;
	const char *name;
	const char * const *parent_names;
	u8 num_parents;
	long unsigned int flags;
	long unsigned int offset;
	u8 shift;
	u8 width;
	u8 mux_flags;
	u32 *table;
	const char *alias;
};

struct hisi_phase_clock {
	unsigned int id;
	const char *name;
	const char *parent_names;
	long unsigned int flags;
	long unsigned int offset;
	u8 shift;
	u8 width;
	u32 *phase_degrees;
	u32 *phase_regvals;
	u8 phase_num;
};

struct hisi_divider_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int offset;
	u8 shift;
	u8 width;
	u8 div_flags;
	struct clk_div_table *table;
	const char *alias;
};

struct hi6220_divider_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int offset;
	u8 shift;
	u8 width;
	u32 mask_bit;
	const char *alias;
};

struct hisi_gate_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int offset;
	u8 bit_idx;
	u8 gate_flags;
	const char *alias;
};

struct clkgate_separated {
	struct clk_hw hw;
	void *enable;
	u8 bit_idx;
	u8 flags;
	spinlock_t *lock;
};

struct hi6220_clk_divider {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u32 mask;
	const struct clk_div_table *table;
	spinlock_t *lock;
};

struct clk_hisi_phase {
	struct clk_hw hw;
	void *reg;
	u32 *phase_degrees;
	u32 *phase_regvals;
	u8 phase_num;
	u32 mask;
	u8 shift;
	u8 flags;
	spinlock_t *lock;
};

struct hisi_reset_controller {
	spinlock_t lock;
	void *membase;
	struct reset_controller_dev rcdev;
};

struct mbox_chan___2;

struct hi6220_stub_clk {
	u32 id;
	struct device *dev;
	struct clk_hw hw;
	struct regmap *dfs_map;
	struct mbox_client cl;
	struct mbox_chan___2 *mbox;
};

struct hi6220_mbox_msg {
	unsigned char type;
	unsigned char cmd;
	unsigned char obj;
	unsigned char src;
	unsigned char para[4];
};

union hi6220_mbox_data {
	unsigned int data[8];
	struct hi6220_mbox_msg msg;
};

struct hi3660_stub_clk_chan {
	struct mbox_client cl;
	struct mbox_chan___2 *mbox;
};

struct hi3660_stub_clk {
	unsigned int id;
	struct clk_hw hw;
	unsigned int cmd;
	unsigned int msg[8];
	unsigned int rate;
};

enum imx_pll14xx_type {
	PLL_1416X = 0,
	PLL_1443X = 1,
};

struct imx_pll14xx_rate_table {
	unsigned int rate;
	unsigned int pdiv;
	unsigned int mdiv;
	unsigned int sdiv;
	unsigned int kdiv;
};

struct imx_pll14xx_clk {
	enum imx_pll14xx_type type;
	const struct imx_pll14xx_rate_table *rate_table;
	int rate_count;
	int flags;
};

struct clk_busy_divider {
	struct clk_divider div;
	const struct clk_ops *div_ops;
	void *reg;
	u8 shift;
};

struct clk_busy_mux {
	struct clk_mux mux;
	const struct clk_ops *mux_ops;
	void *reg;
	u8 shift;
};

struct clk_cpu {
	struct clk_hw hw;
	struct clk *div;
	struct clk *mux;
	struct clk *pll;
	struct clk *step;
};

struct clk_divider_gate {
	struct clk_divider divider;
	u32 cached_val;
};

struct clk_fixup_div {
	struct clk_divider divider;
	const struct clk_ops *ops;
	void (*fixup)(u32 *);
};

struct clk_fixup_mux {
	struct clk_mux mux;
	const struct clk_ops *ops;
	void (*fixup)(u32 *);
};

struct clk_frac_pll {
	struct clk_hw hw;
	void *base;
};

struct clk_gate2 {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	u8 cgr_val;
	u8 cgr_mask;
	u8 flags;
	spinlock_t *lock;
	unsigned int *share_count;
};

struct clk_gate_exclusive {
	struct clk_gate gate;
	u32 exclusive_mask;
};

struct clk_pfd {
	struct clk_hw hw;
	void *reg;
	u8 idx;
};

struct clk_pfdv2 {
	struct clk_hw hw;
	void *reg;
	u8 gate_bit;
	u8 vld_bit;
	u8 frac_off;
};

enum imx_pllv1_type {
	IMX_PLLV1_IMX1 = 0,
	IMX_PLLV1_IMX21 = 1,
	IMX_PLLV1_IMX25 = 2,
	IMX_PLLV1_IMX27 = 3,
	IMX_PLLV1_IMX31 = 4,
	IMX_PLLV1_IMX35 = 5,
};

struct clk_pllv1 {
	struct clk_hw hw;
	void *base;
	enum imx_pllv1_type type;
};

struct clk_pllv2 {
	struct clk_hw hw;
	void *base;
};

enum imx_pllv3_type {
	IMX_PLLV3_GENERIC = 0,
	IMX_PLLV3_SYS = 1,
	IMX_PLLV3_USB = 2,
	IMX_PLLV3_USB_VF610 = 3,
	IMX_PLLV3_AV = 4,
	IMX_PLLV3_ENET = 5,
	IMX_PLLV3_ENET_IMX7 = 6,
	IMX_PLLV3_SYS_VF610 = 7,
	IMX_PLLV3_DDR_IMX7 = 8,
	IMX_PLLV3_AV_IMX7 = 9,
};

struct clk_pllv3 {
	struct clk_hw hw;
	void *base;
	u32 power_bit;
	bool powerup_set;
	u32 div_mask;
	u32 div_shift;
	long unsigned int ref_clock;
	u32 num_offset;
	u32 denom_offset;
};

struct clk_pllv3_vf610_mf {
	u32 mfi;
	u32 mfn;
	u32 mfd;
};

struct clk_pllv4 {
	struct clk_hw hw;
	void *base;
};

struct clk_pll14xx {
	struct clk_hw hw;
	void *base;
	enum imx_pll14xx_type type;
	const struct imx_pll14xx_rate_table *rate_table;
	int rate_count;
};

struct clk_sscg_pll_setup {
	int divr1;
	int divf1;
	int divr2;
	int divf2;
	int divq;
	int bypass;
	uint64_t vco1;
	uint64_t vco2;
	uint64_t fout;
	uint64_t ref;
	uint64_t ref_div1;
	uint64_t ref_div2;
	uint64_t fout_request;
	int fout_error;
};

struct clk_sscg_pll {
	struct clk_hw hw;
	const struct clk_ops ops;
	void *base;
	struct clk_sscg_pll_setup setup;
	u8 parent;
	u8 bypass1;
	u8 bypass2;
};

enum imx_sc_pm_func {
	IMX_SC_PM_FUNC_UNKNOWN = 0,
	IMX_SC_PM_FUNC_SET_SYS_POWER_MODE = 19,
	IMX_SC_PM_FUNC_SET_PARTITION_POWER_MODE = 1,
	IMX_SC_PM_FUNC_GET_SYS_POWER_MODE = 2,
	IMX_SC_PM_FUNC_SET_RESOURCE_POWER_MODE = 3,
	IMX_SC_PM_FUNC_GET_RESOURCE_POWER_MODE = 4,
	IMX_SC_PM_FUNC_REQ_LOW_POWER_MODE = 16,
	IMX_SC_PM_FUNC_SET_CPU_RESUME_ADDR = 17,
	IMX_SC_PM_FUNC_REQ_SYS_IF_POWER_MODE = 18,
	IMX_SC_PM_FUNC_SET_CLOCK_RATE = 5,
	IMX_SC_PM_FUNC_GET_CLOCK_RATE = 6,
	IMX_SC_PM_FUNC_CLOCK_ENABLE = 7,
	IMX_SC_PM_FUNC_SET_CLOCK_PARENT = 14,
	IMX_SC_PM_FUNC_GET_CLOCK_PARENT = 15,
	IMX_SC_PM_FUNC_RESET = 13,
	IMX_SC_PM_FUNC_RESET_REASON = 10,
	IMX_SC_PM_FUNC_BOOT = 8,
	IMX_SC_PM_FUNC_REBOOT = 9,
	IMX_SC_PM_FUNC_REBOOT_PARTITION = 12,
	IMX_SC_PM_FUNC_CPU_START = 11,
};

struct imx_scu_clk_node {
	const char *name;
	u32 rsrc;
	u8 clk_type;
	const char * const *parents;
	int num_parents;
	struct clk_hw *hw;
	struct list_head node;
};

struct clk_scu {
	struct clk_hw hw;
	u16 rsrc_id;
	u8 clk_type;
	bool is_enabled;
	u32 rate;
};

struct imx_sc_msg_req_set_clock_rate {
	struct imx_sc_rpc_msg hdr;
	__le32 rate;
	__le16 resource;
	u8 clk;
};

struct req_get_clock_rate {
	__le16 resource;
	u8 clk;
};

struct resp_get_clock_rate {
	__le32 rate;
};

struct imx_sc_msg_get_clock_rate {
	struct imx_sc_rpc_msg hdr;
	union {
		struct req_get_clock_rate req;
		struct resp_get_clock_rate resp;
	} data;
};

struct req_get_clock_parent {
	__le16 resource;
	u8 clk;
};

struct resp_get_clock_parent {
	u8 parent;
};

struct imx_sc_msg_get_clock_parent {
	struct imx_sc_rpc_msg hdr;
	union {
		struct req_get_clock_parent req;
		struct resp_get_clock_parent resp;
	} data;
};

struct imx_sc_msg_set_clock_parent {
	struct imx_sc_rpc_msg hdr;
	__le16 resource;
	u8 clk;
	u8 parent;
};

struct imx_sc_msg_req_clock_enable {
	struct imx_sc_rpc_msg hdr;
	__le16 resource;
	u8 clk;
	u8 enable;
	u8 autog;
	int: 24;
};

struct clk_lpcg_scu {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	bool hw_gate;
	u32 state;
};

struct imx8qxp_lpcg_data {
	int id;
	char *name;
	char *parent;
	long unsigned int flags;
	u32 offset;
	u8 bit_idx;
	bool hw_gate;
};

struct imx8qxp_ss_lpcg {
	const struct imx8qxp_lpcg_data *lpcg;
	u8 num_lpcg;
	u8 num_max;
};

struct ti_syscon_gate_clk_priv {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 reg;
	u32 idx;
};

struct ti_syscon_gate_clk_data {
	char *name;
	u32 offset;
	u32 bit_idx;
};

struct mtk_fixed_clk {
	int id;
	const char *name;
	const char *parent;
	long unsigned int rate;
};

struct mtk_fixed_factor {
	int id;
	const char *name;
	const char *parent_name;
	int mult;
	int div;
};

struct mtk_composite {
	int id;
	const char *name;
	const char * const *parent_names;
	const char *parent;
	unsigned int flags;
	uint32_t mux_reg;
	uint32_t divider_reg;
	uint32_t gate_reg;
	signed char mux_shift;
	signed char mux_width;
	signed char gate_shift;
	signed char divider_shift;
	signed char divider_width;
	u8 mux_flags;
	signed char num_parents;
};

struct mtk_gate_regs {
	u32 sta_ofs;
	u32 clr_ofs;
	u32 set_ofs;
};

struct mtk_gate {
	int id;
	const char *name;
	const char *parent_name;
	const struct mtk_gate_regs *regs;
	int shift;
	const struct clk_ops *ops;
	long unsigned int flags;
};

struct mtk_clk_divider {
	int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	u32 div_reg;
	unsigned char div_shift;
	unsigned char div_width;
	unsigned char clk_divider_flags;
	const struct clk_div_table *clk_div_table;
};

struct mtk_pll_div_table {
	u32 div;
	long unsigned int freq;
};

struct mtk_pll_data {
	int id;
	const char *name;
	uint32_t reg;
	uint32_t pwr_reg;
	uint32_t en_mask;
	uint32_t pd_reg;
	uint32_t tuner_reg;
	uint32_t tuner_en_reg;
	uint8_t tuner_en_bit;
	int pd_shift;
	unsigned int flags;
	const struct clk_ops *ops;
	u32 rst_bar_mask;
	long unsigned int fmin;
	long unsigned int fmax;
	int pcwbits;
	int pcwibits;
	uint32_t pcw_reg;
	int pcw_shift;
	uint32_t pcw_chg_reg;
	const struct mtk_pll_div_table *div_table;
	const char *parent_name;
};

struct mtk_clk_pll {
	struct clk_hw hw;
	void *base_addr;
	void *pd_addr;
	void *pwr_addr;
	void *tuner_addr;
	void *tuner_en_addr;
	void *pcw_addr;
	void *pcw_chg_addr;
	const struct mtk_pll_data *data;
};

struct mtk_clk_gate {
	struct clk_hw hw;
	struct regmap *regmap;
	int set_ofs;
	int clr_ofs;
	int sta_ofs;
	u8 bit;
};

struct mtk_ref2usb_tx {
	struct clk_hw hw;
	void *base_addr;
};

struct mtk_clk_cpumux {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 reg;
	u32 mask;
	u8 shift;
};

struct mtk_reset {
	struct regmap *regmap;
	int regofs;
	struct reset_controller_dev rcdev;
};

struct mtk_mux;

struct mtk_clk_mux {
	struct clk_hw hw;
	struct regmap *regmap;
	const struct mtk_mux *data;
	spinlock_t *lock;
	bool reparent;
};

struct mtk_mux {
	int id;
	const char *name;
	const char * const *parent_names;
	unsigned int flags;
	u32 mux_ofs;
	u32 set_ofs;
	u32 clr_ofs;
	u32 upd_ofs;
	u8 mux_shift;
	u8 mux_width;
	u8 gate_shift;
	s8 upd_shift;
	signed char num_parents;
};

struct clk_mt8167_mm_driver_data {
	const struct mtk_gate *gates_clk;
	int gates_num;
};

struct mtk_clk_usb {
	int id;
	const char *name;
	const char *parent;
	u32 reg_ofs;
};

struct clk_mt8173_mm_driver_data {
	const struct mtk_gate *gates_clk;
	int gates_num;
};

struct clk_regmap {
	struct clk_hw hw;
	struct regmap *map;
	void *data;
};

struct meson_aoclk_data {
	const unsigned int reset_reg;
	const int num_reset;
	const unsigned int *reset;
	const int num_clks;
	struct clk_regmap **clks;
	const struct clk_hw_onecell_data *hw_data;
};

struct meson_aoclk_reset_controller {
	struct reset_controller_dev reset;
	const struct meson_aoclk_data *data;
	struct regmap *regmap;
};

struct parm {
	u16 reg_off;
	u8 shift;
	u8 width;
};

struct meson_clk_cpu_dyndiv_data {
	struct parm div;
	struct parm dyn;
};

struct meson_clk_dualdiv_param {
	unsigned int n1;
	unsigned int n2;
	unsigned int m1;
	unsigned int m2;
	unsigned int dual;
};

struct meson_clk_dualdiv_data {
	struct parm n1;
	struct parm n2;
	struct parm m1;
	struct parm m2;
	struct parm dual;
	const struct meson_clk_dualdiv_param *table;
};

struct reg_sequence {
	unsigned int reg;
	unsigned int def;
	unsigned int delay_us;
};

struct meson_eeclkc_data {
	struct clk_regmap * const *regmap_clks;
	unsigned int regmap_clk_num;
	const struct reg_sequence *init_regs;
	unsigned int init_count;
	struct clk_hw_onecell_data *hw_onecell_data;
};

struct meson_clk_mpll_data {
	struct parm sdm;
	struct parm sdm_en;
	struct parm n2;
	struct parm ssen;
	struct parm misc;
	const struct reg_sequence *init_regs;
	unsigned int init_count;
	spinlock_t *lock;
	u8 flags;
};

struct pll_params_table {
	unsigned int m;
	unsigned int n;
};

struct pll_mult_range {
	unsigned int min;
	unsigned int max;
};

struct meson_clk_pll_data {
	struct parm en;
	struct parm m;
	struct parm n;
	struct parm frac;
	struct parm l;
	struct parm rst;
	const struct reg_sequence *init_regs;
	unsigned int init_count;
	const struct pll_params_table *table;
	const struct pll_mult_range *range;
	u8 flags;
};

struct clk_regmap_gate_data {
	unsigned int offset;
	u8 bit_idx;
	u8 flags;
};

struct clk_regmap_div_data {
	unsigned int offset;
	u8 shift;
	u8 width;
	u8 flags;
	const struct clk_div_table *table;
};

struct clk_regmap_mux_data {
	unsigned int offset;
	u32 *table;
	u32 mask;
	u8 shift;
	u8 flags;
};

struct meson_vid_pll_div_data {
	struct parm val;
	struct parm sel;
};

struct vid_pll_div {
	unsigned int shift_val;
	unsigned int shift_sel;
	unsigned int divider;
	unsigned int multiplier;
};

struct g12a_cpu_clk_postmux_nb_data {
	struct notifier_block nb;
	struct clk_hw *xtal;
	struct clk_hw *cpu_clk_dyn;
	struct clk_hw *cpu_clk_postmux0;
	struct clk_hw *cpu_clk_postmux1;
	struct clk_hw *cpu_clk_premux1;
};

struct g12a_sys_pll_nb_data {
	struct notifier_block nb;
	struct clk_hw *sys_pll;
	struct clk_hw *cpu_clk;
	struct clk_hw *cpu_clk_dyn;
};

struct meson_g12a_data {
	const struct meson_eeclkc_data eeclkc_data;
	int (*dvfs_setup)(struct platform_device *);
};

struct tbg_def {
	char *name;
	u32 refdiv_offset;
	u32 fbdiv_offset;
	u32 vcodiv_reg;
	u32 vcodiv_offset;
};

struct clk_periph_driver_data {
	struct clk_hw_onecell_data *hw_data;
	spinlock_t lock;
	void *reg;
	u32 tbg_sel;
	u32 div_sel0;
	u32 div_sel1;
	u32 div_sel2;
	u32 clk_sel;
	u32 clk_dis;
};

struct clk_double_div {
	struct clk_hw hw;
	void *reg1;
	u8 shift1;
	void *reg2;
	u8 shift2;
};

struct clk_pm_cpu {
	struct clk_hw hw;
	void *reg_mux;
	u8 shift_mux;
	u32 mask_mux;
	void *reg_div;
	u8 shift_div;
	struct regmap *nb_pm_base;
	long unsigned int l1_expiration;
};

struct clk_periph_data {
	const char *name;
	const char * const *parent_names;
	int num_parents;
	struct clk_hw *mux_hw;
	struct clk_hw *rate_hw;
	struct clk_hw *gate_hw;
	struct clk_hw *muxrate_hw;
	bool is_double_div;
};

struct cpu_dfs_regs {
	unsigned int divider_reg;
	unsigned int force_reg;
	unsigned int ratio_reg;
	unsigned int ratio_state_reg;
	unsigned int divider_mask;
	unsigned int cluster_offset;
	unsigned int force_mask;
	int divider_offset;
	int divider_ratio;
	int ratio_offset;
	int ratio_state_offset;
	int ratio_state_cluster_offset;
};

struct ap_cpu_clk {
	unsigned int cluster;
	const char *clk_name;
	struct device *dev;
	struct clk_hw hw;
	struct regmap *pll_cr_base;
	const struct cpu_dfs_regs *pll_regs;
};

enum {
	CP110_CLK_TYPE_CORE = 0,
	CP110_CLK_TYPE_GATABLE = 1,
};

struct cp110_gate_clk {
	struct clk_hw hw;
	struct regmap *regmap;
	u8 bit_idx;
};

struct cpg_core_clk {
	const char *name;
	unsigned int id;
	unsigned int type;
	unsigned int parent;
	unsigned int div;
	unsigned int mult;
	unsigned int offset;
};

enum clk_types {
	CLK_TYPE_IN = 0,
	CLK_TYPE_FF = 1,
	CLK_TYPE_DIV6P1 = 2,
	CLK_TYPE_DIV6_RO = 3,
	CLK_TYPE_FR = 4,
	CLK_TYPE_CUSTOM = 5,
};

struct mssr_mod_clk {
	const char *name;
	unsigned int id;
	unsigned int parent;
};

enum clk_reg_layout {
	CLK_REG_LAYOUT_RCAR_GEN2_AND_GEN3 = 0,
	CLK_REG_LAYOUT_RZ_A = 1,
	CLK_REG_LAYOUT_RCAR_V3U = 2,
};

struct cpg_mssr_info {
	const struct cpg_core_clk *early_core_clks;
	unsigned int num_early_core_clks;
	const struct mssr_mod_clk *early_mod_clks;
	unsigned int num_early_mod_clks;
	const struct cpg_core_clk *core_clks;
	unsigned int num_core_clks;
	unsigned int last_dt_core_clk;
	unsigned int num_total_core_clks;
	enum clk_reg_layout reg_layout;
	const struct mssr_mod_clk *mod_clks;
	unsigned int num_mod_clks;
	unsigned int num_hw_mod_clks;
	const unsigned int *crit_mod_clks;
	unsigned int num_crit_mod_clks;
	const unsigned int *core_pm_clks;
	unsigned int num_core_pm_clks;
	int (*init)(struct device *);
	struct clk * (*cpg_clk_register)(struct device *, const struct cpg_core_clk *, const struct cpg_mssr_info *, struct clk **, void *, struct raw_notifier_head *);
};

enum rcar_gen3_clk_types {
	CLK_TYPE_GEN3_MAIN = 5,
	CLK_TYPE_GEN3_PLL0 = 6,
	CLK_TYPE_GEN3_PLL1 = 7,
	CLK_TYPE_GEN3_PLL2 = 8,
	CLK_TYPE_GEN3_PLL3 = 9,
	CLK_TYPE_GEN3_PLL4 = 10,
	CLK_TYPE_GEN3_SD = 11,
	CLK_TYPE_GEN3_R = 12,
	CLK_TYPE_GEN3_MDSEL = 13,
	CLK_TYPE_GEN3_Z = 14,
	CLK_TYPE_GEN3_OSC = 15,
	CLK_TYPE_GEN3_RCKSEL = 16,
	CLK_TYPE_GEN3_RPCSRC = 17,
	CLK_TYPE_GEN3_E3_RPCSRC = 18,
	CLK_TYPE_GEN3_RPC = 19,
	CLK_TYPE_GEN3_RPCD2 = 20,
	CLK_TYPE_GEN3_SOC_BASE = 21,
};

struct rcar_gen3_cpg_pll_config {
	u8 extal_div;
	u8 pll1_mult;
	u8 pll1_div;
	u8 pll3_mult;
	u8 pll3_div;
	u8 osc_prediv;
};

enum clk_ids {
	LAST_DT_CORE_CLK = 46,
	CLK_EXTAL = 47,
	CLK_EXTALR = 48,
	CLK_MAIN = 49,
	CLK_PLL0 = 50,
	CLK_PLL1 = 51,
	CLK_PLL2 = 52,
	CLK_PLL3 = 53,
	CLK_PLL4 = 54,
	CLK_PLL1_DIV2 = 55,
	CLK_PLL1_DIV4 = 56,
	CLK_S0 = 57,
	CLK_S1 = 58,
	CLK_S2 = 59,
	CLK_S3 = 60,
	CLK_SDSRC = 61,
	CLK_RPCSRC = 62,
	CLK_RINT = 63,
	MOD_CLK_BASE = 64,
};

enum clk_ids___2 {
	LAST_DT_CORE_CLK___2 = 44,
	CLK_EXTAL___2 = 45,
	CLK_EXTALR___2 = 46,
	CLK_MAIN___2 = 47,
	CLK_PLL0___2 = 48,
	CLK_PLL1___2 = 49,
	CLK_PLL3___2 = 50,
	CLK_PLL4___2 = 51,
	CLK_PLL1_DIV2___2 = 52,
	CLK_PLL1_DIV4___2 = 53,
	CLK_S0___2 = 54,
	CLK_S1___2 = 55,
	CLK_S2___2 = 56,
	CLK_S3___2 = 57,
	CLK_SDSRC___2 = 58,
	CLK_RPCSRC___2 = 59,
	CLK_RINT___2 = 60,
	MOD_CLK_BASE___2 = 61,
};

enum clk_ids___3 {
	LAST_DT_CORE_CLK___3 = 48,
	CLK_EXTAL___3 = 49,
	CLK_MAIN___3 = 50,
	CLK_PLL0___3 = 51,
	CLK_PLL1___3 = 52,
	CLK_PLL3___3 = 53,
	CLK_PLL0D4 = 54,
	CLK_PLL0D6 = 55,
	CLK_PLL0D8 = 56,
	CLK_PLL0D20 = 57,
	CLK_PLL0D24 = 58,
	CLK_PLL1D2 = 59,
	CLK_PE = 60,
	CLK_S0___3 = 61,
	CLK_S1___3 = 62,
	CLK_S2___3 = 63,
	CLK_S3___3 = 64,
	CLK_SDSRC___3 = 65,
	CLK_RPCSRC___3 = 66,
	CLK_RINT___3 = 67,
	CLK_OCO = 68,
	MOD_CLK_BASE___3 = 69,
};

struct mssr_mod_reparent {
	unsigned int clk;
	unsigned int parent;
};

enum clk_ids___4 {
	LAST_DT_CORE_CLK___4 = 51,
	CLK_EXTAL___4 = 52,
	CLK_EXTALR___3 = 53,
	CLK_MAIN___4 = 54,
	CLK_PLL0___4 = 55,
	CLK_PLL1___4 = 56,
	CLK_PLL2___2 = 57,
	CLK_PLL3___4 = 58,
	CLK_PLL4___3 = 59,
	CLK_PLL1_DIV2___3 = 60,
	CLK_PLL1_DIV4___3 = 61,
	CLK_S0___4 = 62,
	CLK_S1___4 = 63,
	CLK_S2___4 = 64,
	CLK_S3___4 = 65,
	CLK_SDSRC___4 = 66,
	CLK_SSPSRC = 67,
	CLK_RPCSRC___4 = 68,
	CLK_RINT___4 = 69,
	MOD_CLK_BASE___4 = 70,
};

enum clk_ids___5 {
	LAST_DT_CORE_CLK___5 = 52,
	CLK_EXTAL___5 = 53,
	CLK_EXTALR___4 = 54,
	CLK_MAIN___5 = 55,
	CLK_PLL0___5 = 56,
	CLK_PLL1___5 = 57,
	CLK_PLL2___3 = 58,
	CLK_PLL3___5 = 59,
	CLK_PLL4___4 = 60,
	CLK_PLL1_DIV2___4 = 61,
	CLK_PLL1_DIV4___4 = 62,
	CLK_S0___5 = 63,
	CLK_S1___5 = 64,
	CLK_S2___5 = 65,
	CLK_S3___5 = 66,
	CLK_SDSRC___5 = 67,
	CLK_SSPSRC___2 = 68,
	CLK_RPCSRC___5 = 69,
	CLK_RINT___5 = 70,
	MOD_CLK_BASE___5 = 71,
};

enum clk_ids___6 {
	LAST_DT_CORE_CLK___6 = 49,
	CLK_EXTAL___6 = 50,
	CLK_EXTALR___5 = 51,
	CLK_MAIN___6 = 52,
	CLK_PLL0___6 = 53,
	CLK_PLL1___6 = 54,
	CLK_PLL3___6 = 55,
	CLK_PLL4___5 = 56,
	CLK_PLL1_DIV2___5 = 57,
	CLK_PLL1_DIV4___5 = 58,
	CLK_S0___6 = 59,
	CLK_S1___6 = 60,
	CLK_S2___6 = 61,
	CLK_S3___6 = 62,
	CLK_SDSRC___6 = 63,
	CLK_SSPSRC___3 = 64,
	CLK_RPCSRC___6 = 65,
	CLK_RINT___6 = 66,
	MOD_CLK_BASE___6 = 67,
};

enum r8a77970_clk_types {
	CLK_TYPE_R8A77970_SD0H = 21,
	CLK_TYPE_R8A77970_SD0 = 22,
};

enum clk_ids___7 {
	LAST_DT_CORE_CLK___7 = 30,
	CLK_EXTAL___7 = 31,
	CLK_EXTALR___6 = 32,
	CLK_MAIN___7 = 33,
	CLK_PLL0___7 = 34,
	CLK_PLL1___7 = 35,
	CLK_PLL3___7 = 36,
	CLK_PLL1_DIV2___6 = 37,
	CLK_PLL1_DIV4___6 = 38,
	MOD_CLK_BASE___7 = 39,
};

enum clk_ids___8 {
	LAST_DT_CORE_CLK___8 = 37,
	CLK_EXTAL___8 = 38,
	CLK_EXTALR___7 = 39,
	CLK_MAIN___8 = 40,
	CLK_PLL1___8 = 41,
	CLK_PLL2___4 = 42,
	CLK_PLL3___8 = 43,
	CLK_PLL1_DIV2___7 = 44,
	CLK_PLL1_DIV4___7 = 45,
	CLK_S0___7 = 46,
	CLK_S1___7 = 47,
	CLK_S2___7 = 48,
	CLK_S3___7 = 49,
	CLK_SDSRC___7 = 50,
	CLK_RPCSRC___7 = 51,
	CLK_OCO___2 = 52,
	MOD_CLK_BASE___8 = 53,
};

enum clk_ids___9 {
	LAST_DT_CORE_CLK___9 = 49,
	CLK_EXTAL___9 = 50,
	CLK_MAIN___9 = 51,
	CLK_PLL0___8 = 52,
	CLK_PLL1___9 = 53,
	CLK_PLL3___9 = 54,
	CLK_PLL0D4___2 = 55,
	CLK_PLL0D6___2 = 56,
	CLK_PLL0D8___2 = 57,
	CLK_PLL0D20___2 = 58,
	CLK_PLL0D24___2 = 59,
	CLK_PLL1D2___2 = 60,
	CLK_PE___2 = 61,
	CLK_S0___8 = 62,
	CLK_S1___8 = 63,
	CLK_S2___8 = 64,
	CLK_S3___8 = 65,
	CLK_SDSRC___8 = 66,
	CLK_RINT___7 = 67,
	CLK_OCO___3 = 68,
	MOD_CLK_BASE___9 = 69,
};

enum clk_ids___10 {
	LAST_DT_CORE_CLK___10 = 41,
	CLK_EXTAL___10 = 42,
	CLK_MAIN___10 = 43,
	CLK_PLL0___9 = 44,
	CLK_PLL1___10 = 45,
	CLK_PLL3___10 = 46,
	CLK_PLL0D2 = 47,
	CLK_PLL0D3 = 48,
	CLK_PLL0D5 = 49,
	CLK_PLL1D2___3 = 50,
	CLK_PE___3 = 51,
	CLK_S0___9 = 52,
	CLK_S1___9 = 53,
	CLK_S2___9 = 54,
	CLK_S3___9 = 55,
	CLK_SDSRC___9 = 56,
	CLK_RINT___8 = 57,
	CLK_OCO___4 = 58,
	MOD_CLK_BASE___10 = 59,
};

enum rcar_r8a779a0_clk_types {
	CLK_TYPE_R8A779A0_MAIN = 5,
	CLK_TYPE_R8A779A0_PLL1 = 6,
	CLK_TYPE_R8A779A0_PLL2X_3X = 7,
	CLK_TYPE_R8A779A0_PLL5 = 8,
	CLK_TYPE_R8A779A0_SD = 9,
	CLK_TYPE_R8A779A0_MDSEL = 10,
	CLK_TYPE_R8A779A0_OSC = 11,
};

struct rcar_r8a779a0_cpg_pll_config {
	u8 extal_div;
	u8 pll1_mult;
	u8 pll1_div;
	u8 pll5_mult;
	u8 pll5_div;
	u8 osc_prediv;
};

enum clk_ids___11 {
	LAST_DT_CORE_CLK___11 = 42,
	CLK_EXTAL___11 = 43,
	CLK_EXTALR___8 = 44,
	CLK_MAIN___11 = 45,
	CLK_PLL1___11 = 46,
	CLK_PLL20 = 47,
	CLK_PLL21 = 48,
	CLK_PLL30 = 49,
	CLK_PLL31 = 50,
	CLK_PLL5 = 51,
	CLK_PLL1_DIV2___8 = 52,
	CLK_PLL20_DIV2 = 53,
	CLK_PLL21_DIV2 = 54,
	CLK_PLL30_DIV2 = 55,
	CLK_PLL31_DIV2 = 56,
	CLK_PLL5_DIV2 = 57,
	CLK_PLL5_DIV4 = 58,
	CLK_S1___10 = 59,
	CLK_S3___10 = 60,
	CLK_SDSRC___10 = 61,
	CLK_RPCSRC___8 = 62,
	CLK_OCO___5 = 63,
	MOD_CLK_BASE___11 = 64,
};

enum gpd_status {
	GENPD_STATE_ON = 0,
	GENPD_STATE_OFF = 1,
};

struct gpd_dev_ops {
	int (*start)(struct device *);
	int (*stop)(struct device *);
};

struct genpd_power_state {
	s64 power_off_latency_ns;
	s64 power_on_latency_ns;
	s64 residency_ns;
	u64 usage;
	u64 rejected;
	struct fwnode_handle *fwnode;
	ktime_t idle_time;
	void *data;
};

struct opp_table;

struct dev_pm_opp;

struct genpd_lock_ops;

struct generic_pm_domain {
	struct device dev;
	struct dev_pm_domain domain;
	struct list_head gpd_list_node;
	struct list_head parent_links;
	struct list_head child_links;
	struct list_head dev_list;
	struct dev_power_governor *gov;
	struct work_struct power_off_work;
	struct fwnode_handle *provider;
	bool has_provider;
	const char *name;
	atomic_t sd_count;
	enum gpd_status status;
	unsigned int device_count;
	unsigned int suspended_count;
	unsigned int prepared_count;
	unsigned int performance_state;
	cpumask_var_t cpus;
	int (*power_off)(struct generic_pm_domain *);
	int (*power_on)(struct generic_pm_domain *);
	struct raw_notifier_head power_notifiers;
	struct opp_table *opp_table;
	unsigned int (*opp_to_performance_state)(struct generic_pm_domain *, struct dev_pm_opp *);
	int (*set_performance_state)(struct generic_pm_domain *, unsigned int);
	struct gpd_dev_ops dev_ops;
	s64 max_off_time_ns;
	ktime_t next_wakeup;
	bool max_off_time_changed;
	bool cached_power_down_ok;
	bool cached_power_down_state_idx;
	int (*attach_dev)(struct generic_pm_domain *, struct device *);
	void (*detach_dev)(struct generic_pm_domain *, struct device *);
	unsigned int flags;
	struct genpd_power_state *states;
	void (*free_states)(struct genpd_power_state *, unsigned int);
	unsigned int state_count;
	unsigned int state_idx;
	ktime_t on_time;
	ktime_t accounting_time;
	const struct genpd_lock_ops *lock_ops;
	union {
		struct mutex mlock;
		struct {
			spinlock_t slock;
			long unsigned int lock_flags;
		};
	};
};

struct genpd_lock_ops {
	void (*lock)(struct generic_pm_domain *);
	void (*lock_nested)(struct generic_pm_domain *, int);
	int (*lock_interruptible)(struct generic_pm_domain *);
	void (*unlock)(struct generic_pm_domain *);
};

struct r9a06g032_gate {
	u16 gate;
	u16 reset;
	u16 ready;
	u16 midle;
	u16 scon;
	u16 mirack;
	u16 mistat;
};

struct r9a06g032_clkdesc {
	const char *name;
	uint32_t managed: 1;
	uint32_t type: 3;
	uint32_t index: 8;
	uint32_t source: 8;
	union {
		struct r9a06g032_gate gate;
		struct {
			unsigned int div_min: 10;
			unsigned int div_max: 10;
			unsigned int reg: 10;
			u16 div_table[4];
		};
		struct {
			u16 div;
			u16 mul;
		};
		unsigned int factor;
		unsigned int frequency;
		struct {
			uint16_t group: 1;
			uint16_t index: 3;
			u16 sel;
			u16 g1;
			u16 r1;
			u16 g2;
			u16 r2;
		} dual;
	};
};

enum {
	K_GATE = 0,
	K_FFC = 1,
	K_DIV = 2,
	K_BITSEL = 3,
	K_DUALGATE = 4,
};

struct r9a06g032_priv {
	struct clk_onecell_data data;
	spinlock_t lock;
	void *reg;
};

struct r9a06g032_clk_gate {
	struct clk_hw hw;
	struct r9a06g032_priv *clocks;
	u16 index;
	struct r9a06g032_gate gate;
};

struct r9a06g032_clk_div {
	struct clk_hw hw;
	struct r9a06g032_priv *clocks;
	u16 index;
	u16 reg;
	u16 min;
	u16 max;
	u8 table_size;
	u16 table[8];
};

struct r9a06g032_clk_bitsel {
	struct clk_hw hw;
	struct r9a06g032_priv *clocks;
	u16 index;
	u16 selector;
};

struct r9a06g032_clk_dualgate {
	struct clk_hw hw;
	struct r9a06g032_priv *clocks;
	u16 index;
	u16 selector;
	struct r9a06g032_gate gate[2];
};

struct cpg_simple_notifier {
	struct notifier_block nb;
	void *reg;
	u32 saved;
};

struct sd_div_table {
	u32 val;
	unsigned int div;
};

struct sd_clock {
	struct clk_hw hw;
	const struct sd_div_table *div_table;
	struct cpg_simple_notifier csn;
	unsigned int div_num;
	unsigned int cur_div_idx;
};

struct cpg_z_clk {
	struct clk_hw hw;
	void *reg;
	void *kick_reg;
	long unsigned int mask;
	unsigned int fixed_div;
};

struct rpc_clock {
	struct clk_divider div;
	struct clk_gate gate;
	struct cpg_simple_notifier csn;
};

struct rpcd2_clock {
	struct clk_fixed_factor fixed;
	struct clk_gate gate;
};

struct usb2_clock_sel_priv {
	void *base;
	struct clk_hw hw;
	struct clk_bulk_data clks[2];
	struct reset_control *rsts;
	bool extal;
	bool xtal;
};

struct cpg_mssr_priv {
	struct reset_controller_dev rcdev;
	struct device *dev;
	void *base;
	enum clk_reg_layout reg_layout;
	spinlock_t rmw_lock;
	struct device_node *np;
	unsigned int num_core_clks;
	unsigned int num_mod_clks;
	unsigned int last_dt_core_clk;
	struct raw_notifier_head notifiers;
	const u16 *status_regs;
	const u16 *control_regs;
	const u16 *reset_regs;
	const u16 *reset_clear_regs;
	struct {
		u32 mask;
		u32 val;
	} smstpcr_saved[15];
	struct clk *clks[0];
};

struct mstp_clock {
	struct clk_hw hw;
	u32 index;
	struct cpg_mssr_priv *priv;
};

struct cpg_mssr_clk_domain {
	struct generic_pm_domain genpd;
	unsigned int num_core_pm_clks;
	unsigned int core_pm_clks[0];
};

struct div6_clock {
	struct clk_hw hw;
	void *reg;
	unsigned int div;
	u32 src_shift;
	u32 src_width;
	struct notifier_block nb;
	u8 parents[0];
};

enum rockchip_pll_type {
	pll_rk3036 = 0,
	pll_rk3066 = 1,
	pll_rk3328 = 2,
	pll_rk3399 = 3,
};

struct rockchip_clk_provider {
	void *reg_base;
	struct clk_onecell_data clk_data;
	struct device_node *cru_node;
	struct regmap *grf;
	spinlock_t lock;
};

struct rockchip_pll_rate_table {
	long unsigned int rate;
	unsigned int nr;
	unsigned int nf;
	unsigned int no;
	unsigned int nb;
	unsigned int fbdiv;
	unsigned int postdiv1;
	unsigned int refdiv;
	unsigned int postdiv2;
	unsigned int dsmpd;
	unsigned int frac;
};

struct rockchip_pll_clock {
	unsigned int id;
	const char *name;
	const char * const *parent_names;
	u8 num_parents;
	long unsigned int flags;
	int con_offset;
	int mode_offset;
	int mode_shift;
	int lock_shift;
	enum rockchip_pll_type type;
	u8 pll_flags;
	struct rockchip_pll_rate_table *rate_table;
};

struct rockchip_cpuclk_clksel {
	int reg;
	u32 val;
};

struct rockchip_cpuclk_rate_table {
	long unsigned int prate;
	struct rockchip_cpuclk_clksel divs[5];
};

struct rockchip_cpuclk_reg_data {
	int core_reg[4];
	u8 div_core_shift[4];
	u32 div_core_mask[4];
	int num_cores;
	u8 mux_core_alt;
	u8 mux_core_main;
	u8 mux_core_shift;
	u32 mux_core_mask;
};

enum rockchip_clk_branch_type {
	branch_composite = 0,
	branch_mux = 1,
	branch_muxgrf = 2,
	branch_divider = 3,
	branch_fraction_divider = 4,
	branch_gate = 5,
	branch_mmc = 6,
	branch_inverter = 7,
	branch_factor = 8,
	branch_ddrclk = 9,
	branch_half_divider = 10,
};

struct rockchip_clk_branch {
	unsigned int id;
	enum rockchip_clk_branch_type branch_type;
	const char *name;
	const char * const *parent_names;
	u8 num_parents;
	long unsigned int flags;
	int muxdiv_offset;
	u8 mux_shift;
	u8 mux_width;
	u8 mux_flags;
	int div_offset;
	u8 div_shift;
	u8 div_width;
	u8 div_flags;
	struct clk_div_table *div_table;
	int gate_offset;
	u8 gate_shift;
	u8 gate_flags;
	struct rockchip_clk_branch *child;
};

struct rockchip_clk_frac {
	struct notifier_block clk_nb;
	struct clk_fractional_divider div;
	struct clk_gate gate;
	struct clk_mux mux;
	const struct clk_ops *mux_ops;
	int mux_frac_idx;
	bool rate_change_remuxed;
	int rate_change_idx;
};

struct rockchip_clk_pll {
	struct clk_hw hw;
	struct clk_mux pll_mux;
	const struct clk_ops *pll_mux_ops;
	struct notifier_block clk_nb;
	void *reg_base;
	int lock_offset;
	unsigned int lock_shift;
	enum rockchip_pll_type type;
	u8 flags;
	const struct rockchip_pll_rate_table *rate_table;
	unsigned int rate_count;
	spinlock_t *lock;
	struct rockchip_clk_provider *ctx;
};

struct rockchip_cpuclk {
	struct clk_hw hw;
	struct clk *alt_parent;
	void *reg_base;
	struct notifier_block clk_nb;
	unsigned int rate_count;
	struct rockchip_cpuclk_rate_table *rate_table;
	const struct rockchip_cpuclk_reg_data *reg_data;
	spinlock_t *lock;
};

struct rockchip_inv_clock {
	struct clk_hw hw;
	void *reg;
	int shift;
	int flags;
	spinlock_t *lock;
};

struct rockchip_mmc_clock {
	struct clk_hw hw;
	void *reg;
	int id;
	int shift;
	int cached_phase;
	struct notifier_block clk_rate_change_nb;
};

struct rockchip_muxgrf_clock {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 reg;
	u32 shift;
	u32 width;
	int flags;
};

struct rockchip_ddrclk {
	struct clk_hw hw;
	void *reg_base;
	int mux_offset;
	int mux_shift;
	int mux_width;
	int div_shift;
	int div_width;
	int ddr_flag;
	spinlock_t *lock;
};

struct rockchip_softrst {
	struct reset_controller_dev rcdev;
	void *reg_base;
	int num_regs;
	int num_per_reg;
	u8 flags;
	spinlock_t lock;
};

enum px30_plls {
	apll = 0,
	dpll = 1,
	cpll = 2,
	npll = 3,
	apll_b_h = 4,
	apll_b_l = 5,
};

enum px30_pmu_plls {
	gpll = 0,
};

enum rk3308_plls {
	apll___2 = 0,
	dpll___2 = 1,
	vpll0 = 2,
	vpll1 = 3,
};

enum rk3328_plls {
	apll___3 = 0,
	dpll___3 = 1,
	cpll___2 = 2,
	gpll___2 = 3,
	npll___2 = 4,
};

enum rk3368_plls {
	apllb = 0,
	aplll = 1,
	dpll___4 = 2,
	cpll___3 = 3,
	gpll___3 = 4,
	npll___3 = 5,
};

enum rk3399_plls {
	lpll = 0,
	bpll = 1,
	dpll___5 = 2,
	cpll___4 = 3,
	gpll___4 = 4,
	npll___4 = 5,
	vpll = 6,
};

enum rk3399_pmu_plls {
	ppll = 0,
};

struct clk_rk3399_inits {
	void (*inits)(struct device_node *);
};

struct clk_factors_config {
	u8 nshift;
	u8 nwidth;
	u8 kshift;
	u8 kwidth;
	u8 mshift;
	u8 mwidth;
	u8 pshift;
	u8 pwidth;
	u8 n_start;
};

struct factors_request {
	long unsigned int rate;
	long unsigned int parent_rate;
	u8 parent_index;
	u8 n;
	u8 k;
	u8 m;
	u8 p;
};

struct factors_data {
	int enable;
	int mux;
	int muxmask;
	const struct clk_factors_config *table;
	void (*getter)(struct factors_request *);
	void (*recalc)(struct factors_request *);
	const char *name;
};

struct clk_factors {
	struct clk_hw hw;
	void *reg;
	const struct clk_factors_config *config;
	void (*get_factors)(struct factors_request *);
	void (*recalc)(struct factors_request *);
	spinlock_t *lock;
	struct clk_mux *mux;
	struct clk_gate *gate;
};

struct mux_data {
	u8 shift;
};

struct div_data {
	u8 shift;
	u8 pow;
	u8 width;
	const struct clk_div_table *table;
};

struct divs_data {
	const struct factors_data *factors;
	int ndivs;
	struct {
		u8 self;
		u8 fixed;
		struct clk_div_table *table;
		u8 shift;
		u8 pow;
		u8 gate;
		bool critical;
	} div[4];
};

struct ve_reset_data {
	void *reg;
	spinlock_t *lock;
	struct reset_controller_dev rcdev;
};

struct mmc_phase {
	struct clk_hw hw;
	u8 offset;
	void *reg;
	spinlock_t *lock;
};

struct sun4i_a10_display_clk_data {
	bool has_div;
	u8 num_rst;
	u8 parents;
	u8 offset_en;
	u8 offset_div;
	u8 offset_mux;
	u8 offset_rst;
	u8 width_div;
	u8 width_mux;
	u32 flags;
};

struct reset_data {
	void *reg;
	spinlock_t *lock;
	struct reset_controller_dev rcdev;
	u8 offset;
};

struct tcon_ch1_clk {
	struct clk_hw hw;
	spinlock_t lock;
	void *reg;
};

enum {
	AHB1 = 0,
	AHB2 = 1,
	APB1 = 2,
	APB2 = 3,
	PARENT_MAX = 4,
};

struct sun9i_mmc_clk_data {
	spinlock_t lock;
	void *membase;
	struct clk *clk;
	struct reset_control *reset;
	struct clk_onecell_data clk_data;
	struct reset_controller_dev rcdev;
};

struct usb_reset_data {
	void *reg;
	spinlock_t *lock;
	struct clk *clk;
	struct reset_controller_dev rcdev;
};

struct usb_clk_data {
	u32 clk_mask;
	u32 reset_mask;
	bool reset_needs_clk;
};

struct sun9i_a80_cpus_clk {
	struct clk_hw hw;
	void *reg;
};

struct gates_data {
	long unsigned int mask[1];
};

struct ccu_common {
	void *base;
	u16 reg;
	u16 lock_reg;
	u32 prediv;
	long unsigned int features;
	spinlock_t *lock;
	struct clk_hw hw;
};

struct ccu_reset_map;

struct sunxi_ccu_desc {
	struct ccu_common **ccu_clks;
	long unsigned int num_ccu_clks;
	struct clk_hw_onecell_data *hw_clks;
	struct ccu_reset_map *resets;
	long unsigned int num_resets;
};

struct ccu_reset_map {
	u16 reg;
	u32 bit;
};

struct ccu_pll_nb {
	struct notifier_block clk_nb;
	struct ccu_common *common;
	u32 enable;
	u32 lock;
};

struct ccu_reset {
	void *base;
	struct ccu_reset_map *reset_map;
	spinlock_t *lock;
	struct reset_controller_dev rcdev;
};

struct sunxi_ccu {
	const struct sunxi_ccu_desc *desc;
	struct ccu_reset reset;
};

struct ccu_mux_fixed_prediv {
	u8 index;
	u16 div;
};

struct ccu_mux_var_prediv {
	u8 index;
	u8 shift;
	u8 width;
};

struct ccu_mux_internal {
	u8 shift;
	u8 width;
	const u8 *table;
	const struct ccu_mux_fixed_prediv *fixed_predivs;
	u8 n_predivs;
	const struct ccu_mux_var_prediv *var_predivs;
	u8 n_var_predivs;
};

struct ccu_div_internal {
	u8 shift;
	u8 width;
	u32 max;
	u32 offset;
	u32 flags;
	struct clk_div_table *table;
};

struct ccu_div {
	u32 enable;
	struct ccu_div_internal div;
	struct ccu_mux_internal mux;
	struct ccu_common common;
	unsigned int fixed_post_div;
};

struct ccu_frac_internal {
	u32 enable;
	u32 select;
	long unsigned int rates[2];
};

struct ccu_gate {
	u32 enable;
	struct ccu_common common;
};

struct ccu_mux {
	u16 reg;
	u32 enable;
	struct ccu_mux_internal mux;
	struct ccu_common common;
};

struct ccu_mux_nb {
	struct notifier_block clk_nb;
	struct ccu_common *common;
	struct ccu_mux_internal *cm;
	u32 delay_us;
	u8 bypass_index;
	u8 original_index;
};

struct ccu_mult_internal {
	u8 offset;
	u8 shift;
	u8 width;
	u8 min;
	u8 max;
};

struct ccu_mult {
	u32 enable;
	u32 lock;
	struct ccu_frac_internal frac;
	struct ccu_mult_internal mult;
	struct ccu_mux_internal mux;
	struct ccu_common common;
};

struct _ccu_mult {
	long unsigned int mult;
	long unsigned int min;
	long unsigned int max;
};

struct ccu_phase {
	u8 shift;
	u8 width;
	struct ccu_common common;
};

struct ccu_sdm_setting {
	long unsigned int rate;
	u32 pattern;
	u32 m;
	u32 n;
};

struct ccu_sdm_internal {
	struct ccu_sdm_setting *table;
	u32 table_size;
	u32 enable;
	u32 tuning_enable;
	u16 tuning_reg;
};

struct ccu_nk {
	u16 reg;
	u32 enable;
	u32 lock;
	struct ccu_mult_internal n;
	struct ccu_mult_internal k;
	unsigned int fixed_post_div;
	struct ccu_common common;
};

struct _ccu_nk {
	long unsigned int n;
	long unsigned int min_n;
	long unsigned int max_n;
	long unsigned int k;
	long unsigned int min_k;
	long unsigned int max_k;
};

struct ccu_nkm {
	u32 enable;
	u32 lock;
	struct ccu_mult_internal n;
	struct ccu_mult_internal k;
	struct ccu_div_internal m;
	struct ccu_mux_internal mux;
	unsigned int fixed_post_div;
	struct ccu_common common;
};

struct _ccu_nkm {
	long unsigned int n;
	long unsigned int min_n;
	long unsigned int max_n;
	long unsigned int k;
	long unsigned int min_k;
	long unsigned int max_k;
	long unsigned int m;
	long unsigned int min_m;
	long unsigned int max_m;
};

struct ccu_nkmp {
	u32 enable;
	u32 lock;
	struct ccu_mult_internal n;
	struct ccu_mult_internal k;
	struct ccu_div_internal m;
	struct ccu_div_internal p;
	unsigned int fixed_post_div;
	unsigned int max_rate;
	struct ccu_common common;
};

struct _ccu_nkmp {
	long unsigned int n;
	long unsigned int min_n;
	long unsigned int max_n;
	long unsigned int k;
	long unsigned int min_k;
	long unsigned int max_k;
	long unsigned int m;
	long unsigned int min_m;
	long unsigned int max_m;
	long unsigned int p;
	long unsigned int min_p;
	long unsigned int max_p;
};

struct ccu_nm {
	u32 enable;
	u32 lock;
	struct ccu_mult_internal n;
	struct ccu_div_internal m;
	struct ccu_frac_internal frac;
	struct ccu_sdm_internal sdm;
	unsigned int fixed_post_div;
	unsigned int min_rate;
	unsigned int max_rate;
	struct ccu_common common;
};

struct _ccu_nm {
	long unsigned int n;
	long unsigned int min_n;
	long unsigned int max_n;
	long unsigned int m;
	long unsigned int min_m;
	long unsigned int max_m;
};

struct ccu_mp {
	u32 enable;
	struct ccu_div_internal m;
	struct ccu_div_internal p;
	struct ccu_mux_internal mux;
	unsigned int fixed_post_div;
	struct ccu_common common;
};

struct icst_params {
	long unsigned int ref;
	long unsigned int vco_max;
	long unsigned int vco_min;
	short unsigned int vd_min;
	short unsigned int vd_max;
	unsigned char rd_min;
	unsigned char rd_max;
	const unsigned char *s2div;
	const unsigned char *idx2s;
};

struct icst_vco {
	short unsigned int v;
	unsigned char r;
	unsigned char s;
};

enum icst_control_type {
	ICST_VERSATILE = 0,
	ICST_INTEGRATOR_AP_CM = 1,
	ICST_INTEGRATOR_AP_SYS = 2,
	ICST_INTEGRATOR_AP_PCI = 3,
	ICST_INTEGRATOR_CP_CM_CORE = 4,
	ICST_INTEGRATOR_CP_CM_MEM = 5,
	ICST_INTEGRATOR_IM_PD1 = 6,
};

struct clk_icst_desc {
	const struct icst_params *params;
	u32 vco_offset;
	u32 lock_offset;
};

struct clk_icst {
	struct clk_hw hw;
	struct regmap *map;
	u32 vcoreg_off;
	u32 lockreg_off;
	struct icst_params *params;
	long unsigned int rate;
	enum icst_control_type ctype;
};

struct clk_sp810;

struct clk_sp810_timerclken {
	struct clk_hw hw;
	struct clk *clk;
	struct clk_sp810 *sp810;
	int channel;
};

struct clk_sp810 {
	struct device_node *node;
	void *base;
	spinlock_t lock;
	struct clk_sp810_timerclken timerclken[4];
};

struct vexpress_osc {
	struct regmap *reg;
	struct clk_hw hw;
	long unsigned int rate_min;
	long unsigned int rate_max;
};

struct clock_topology {
	u32 type;
	u32 flag;
	u32 type_flag;
	u8 custom_type_flag;
};

struct zynqmp_pll {
	struct clk_hw hw;
	u32 clk_id;
	bool set_pll_mode;
};

enum pll_mode {
	PLL_MODE_INT = 0,
	PLL_MODE_FRAC = 1,
	PLL_MODE_ERROR = 2,
};

struct zynqmp_clk_gate {
	struct clk_hw hw;
	u8 flags;
	u32 clk_id;
};

enum pm_query_id {
	PM_QID_INVALID = 0,
	PM_QID_CLOCK_GET_NAME = 1,
	PM_QID_CLOCK_GET_TOPOLOGY = 2,
	PM_QID_CLOCK_GET_FIXEDFACTOR_PARAMS = 3,
	PM_QID_CLOCK_GET_PARENTS = 4,
	PM_QID_CLOCK_GET_ATTRIBUTES = 5,
	PM_QID_PINCTRL_GET_NUM_PINS = 6,
	PM_QID_PINCTRL_GET_NUM_FUNCTIONS = 7,
	PM_QID_PINCTRL_GET_NUM_FUNCTION_GROUPS = 8,
	PM_QID_PINCTRL_GET_FUNCTION_NAME = 9,
	PM_QID_PINCTRL_GET_FUNCTION_GROUPS = 10,
	PM_QID_PINCTRL_GET_PIN_GROUPS = 11,
	PM_QID_CLOCK_GET_NUM_CLOCKS = 12,
	PM_QID_CLOCK_GET_MAX_DIVISOR = 13,
};

struct zynqmp_pm_query_data {
	u32 qid;
	u32 arg1;
	u32 arg2;
	u32 arg3;
};

enum topology_type {
	TYPE_INVALID = 0,
	TYPE_MUX = 1,
	TYPE_PLL = 2,
	TYPE_FIXEDFACTOR = 3,
	TYPE_DIV1 = 4,
	TYPE_DIV2 = 5,
	TYPE_GATE = 6,
};

struct zynqmp_clk_divider {
	struct clk_hw hw;
	u8 flags;
	bool is_frac;
	u32 clk_id;
	u32 div_type;
	u16 max_div;
};

struct zynqmp_clk_mux {
	struct clk_hw hw;
	u8 flags;
	u32 clk_id;
};

enum clk_type {
	CLK_TYPE_OUTPUT = 0,
	CLK_TYPE_EXTERNAL = 1,
};

struct clock_parent {
	char name[50];
	int id;
	u32 flag;
};

struct zynqmp_clock {
	char clk_name[50];
	u32 valid;
	enum clk_type type;
	struct clock_topology node[6];
	u32 num_nodes;
	struct clock_parent parent[100];
	u32 num_parents;
	u32 clk_id;
};

struct name_resp {
	char name[16];
};

struct topology_resp {
	u32 topology[3];
};

struct parents_resp {
	u32 parents[3];
};

struct attr_resp {
	u32 attr[1];
};

struct dma_chan_tbl_ent {
	struct dma_chan *chan;
};

struct dmaengine_unmap_pool {
	struct kmem_cache *cache;
	const char *name;
	mempool_t *pool;
	size_t size;
};

struct dmaengine_desc_callback {
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
};

struct virt_dma_desc {
	struct dma_async_tx_descriptor tx;
	struct dmaengine_result tx_result;
	struct list_head node;
};

struct virt_dma_chan {
	struct dma_chan chan;
	struct tasklet_struct task;
	void (*desc_free)(struct virt_dma_desc *);
	spinlock_t lock;
	struct list_head desc_allocated;
	struct list_head desc_submitted;
	struct list_head desc_issued;
	struct list_head desc_completed;
	struct list_head desc_terminated;
	struct virt_dma_desc *cyclic;
};

struct acpi_table_csrt {
	struct acpi_table_header header;
};

struct acpi_csrt_group {
	u32 length;
	u32 vendor_id;
	u32 subvendor_id;
	u16 device_id;
	u16 subdevice_id;
	u16 revision;
	u16 reserved;
	u32 shared_info_length;
};

struct acpi_csrt_shared_info {
	u16 major_version;
	u16 minor_version;
	u32 mmio_base_low;
	u32 mmio_base_high;
	u32 gsi_interrupt;
	u8 interrupt_polarity;
	u8 interrupt_mode;
	u8 num_channels;
	u8 dma_address_width;
	u16 base_request_line;
	u16 num_handshake_signals;
	u32 max_block_size;
};

struct acpi_dma_spec {
	int chan_id;
	int slave_id;
	struct device *dev;
};

struct acpi_dma {
	struct list_head dma_controllers;
	struct device *dev;
	struct dma_chan * (*acpi_dma_xlate)(struct acpi_dma_spec *, struct acpi_dma *);
	void *data;
	short unsigned int base_request_line;
	short unsigned int end_request_line;
};

struct acpi_dma_filter_info {
	dma_cap_mask_t dma_cap;
	dma_filter_fn filter_fn;
};

struct acpi_dma_parser_data {
	struct acpi_dma_spec dma_spec;
	size_t index;
	size_t n;
};

struct of_dma {
	struct list_head of_dma_controllers;
	struct device_node *of_node;
	struct dma_chan * (*of_dma_xlate)(struct of_phandle_args *, struct of_dma *);
	void * (*of_dma_route_allocate)(struct of_phandle_args *, struct of_dma *);
	struct dma_router *dma_router;
	void *of_dma_data;
};

struct of_dma_filter_info {
	dma_cap_mask_t dma_cap;
	dma_filter_fn filter_fn;
};

enum {
	PL08X_AHB1 = 1,
	PL08X_AHB2 = 2,
};

struct pl08x_channel_data {
	const char *bus_id;
	int min_signal;
	int max_signal;
	u32 muxval;
	dma_addr_t addr;
	bool single;
	u8 periph_buses;
};

enum pl08x_burst_size {
	PL08X_BURST_SZ_1 = 0,
	PL08X_BURST_SZ_4 = 1,
	PL08X_BURST_SZ_8 = 2,
	PL08X_BURST_SZ_16 = 3,
	PL08X_BURST_SZ_32 = 4,
	PL08X_BURST_SZ_64 = 5,
	PL08X_BURST_SZ_128 = 6,
	PL08X_BURST_SZ_256 = 7,
};

enum pl08x_bus_width {
	PL08X_BUS_WIDTH_8_BITS = 0,
	PL08X_BUS_WIDTH_16_BITS = 1,
	PL08X_BUS_WIDTH_32_BITS = 2,
};

struct pl08x_platform_data {
	struct pl08x_channel_data *slave_channels;
	unsigned int num_slave_channels;
	enum pl08x_burst_size memcpy_burst_size;
	enum pl08x_bus_width memcpy_bus_width;
	bool memcpy_prot_buff;
	bool memcpy_prot_cache;
	int (*get_xfer_signal)(const struct pl08x_channel_data *);
	void (*put_xfer_signal)(const struct pl08x_channel_data *, int);
	u8 lli_buses;
	u8 mem_buses;
	const struct dma_slave_map *slave_map;
	int slave_map_len;
};

struct vendor_data {
	u8 config_offset;
	u8 channels;
	u8 signals;
	bool dualmaster;
	bool nomadik;
	bool pl080s;
	bool ftdmac020;
	u32 max_transfer_size;
};

struct pl08x_bus_data {
	dma_addr_t addr;
	u8 maxwidth;
	u8 buswidth;
};

struct pl08x_dma_chan;

struct pl08x_phy_chan {
	unsigned int id;
	void *base;
	void *reg_config;
	void *reg_control;
	void *reg_src;
	void *reg_dst;
	void *reg_lli;
	void *reg_busy;
	spinlock_t lock;
	struct pl08x_dma_chan *serving;
	bool locked;
	bool ftdmac020;
	bool pl080s;
};

enum pl08x_dma_chan_state {
	PL08X_CHAN_IDLE = 0,
	PL08X_CHAN_RUNNING = 1,
	PL08X_CHAN_PAUSED = 2,
	PL08X_CHAN_WAITING = 3,
};

struct pl08x_txd;

struct pl08x_driver_data;

struct pl08x_dma_chan {
	struct virt_dma_chan vc;
	struct pl08x_phy_chan *phychan;
	const char *name;
	struct pl08x_channel_data *cd;
	struct dma_slave_config cfg;
	struct pl08x_txd *at;
	struct pl08x_driver_data *host;
	enum pl08x_dma_chan_state state;
	bool slave;
	int signal;
	unsigned int mux_use;
	long unsigned int waiting_at;
};

struct pl08x_sg {
	dma_addr_t src_addr;
	dma_addr_t dst_addr;
	size_t len;
	struct list_head node;
};

struct pl08x_txd {
	struct virt_dma_desc vd;
	struct list_head dsg_list;
	dma_addr_t llis_bus;
	u32 *llis_va;
	u32 cctl;
	u32 ccfg;
	bool done;
	bool cyclic;
};

struct dma_pool___2;

struct pl08x_driver_data {
	struct dma_device slave;
	struct dma_device memcpy;
	bool has_slave;
	void *base;
	struct amba_device *adev;
	const struct vendor_data *vd;
	struct pl08x_platform_data *pd;
	struct pl08x_phy_chan *phy_chans;
	struct dma_pool___2 *pool;
	u8 lli_buses;
	u8 mem_buses;
	u8 lli_words;
};

struct pl08x_lli_build_data {
	struct pl08x_txd *txd;
	struct pl08x_bus_data srcbus;
	struct pl08x_bus_data dstbus;
	size_t remainder;
	u32 lli_bus;
};

struct burst_table {
	u32 burstwords;
	u32 reg;
};

struct bcm2835_dmadev {
	struct dma_device ddev;
	void *base;
	dma_addr_t zero_page;
};

struct bcm2835_dma_cb {
	uint32_t info;
	uint32_t src;
	uint32_t dst;
	uint32_t length;
	uint32_t stride;
	uint32_t next;
	uint32_t pad[2];
};

struct bcm2835_cb_entry {
	struct bcm2835_dma_cb *cb;
	dma_addr_t paddr;
};

struct bcm2835_desc;

struct bcm2835_chan {
	struct virt_dma_chan vc;
	struct dma_slave_config cfg;
	unsigned int dreq;
	int ch;
	struct bcm2835_desc *desc;
	struct dma_pool___2 *cb_pool;
	void *chan_base;
	int irq_number;
	unsigned int irq_flags;
	bool is_lite_channel;
};

struct bcm2835_desc {
	struct bcm2835_chan *c;
	struct virt_dma_desc vd;
	enum dma_transfer_direction dir;
	unsigned int frames;
	size_t size;
	bool cyclic;
	struct bcm2835_cb_entry cb_list[0];
};

struct mbus_dram_window {
	u8 cs_index;
	u8 mbus_attr;
	u64 base;
	u64 size;
};

struct mbus_dram_target_info {
	u8 mbus_dram_target_id;
	int num_cs;
	struct mbus_dram_window cs[4];
};

struct mv_xor_channel_data {
	dma_cap_mask_t cap_mask;
};

struct mv_xor_platform_data {
	struct mv_xor_channel_data *channels;
};

struct mv_xor_chan;

struct mv_xor_device {
	void *xor_base;
	void *xor_high_base;
	struct clk *clk;
	struct mv_xor_chan *channels[2];
	int xor_type;
	u32 win_start[8];
	u32 win_end[8];
};

struct mv_xor_chan {
	int pending;
	spinlock_t lock;
	void *mmr_base;
	void *mmr_high_base;
	unsigned int idx;
	int irq;
	struct list_head chain;
	struct list_head free_slots;
	struct list_head allocated_slots;
	struct list_head completed_slots;
	dma_addr_t dma_desc_pool;
	void *dma_desc_pool_virt;
	size_t pool_size;
	struct dma_device dmadev;
	struct dma_chan dmachan;
	int slots_allocated;
	struct tasklet_struct irq_tasklet;
	int op_in_desc;
	char dummy_src[128];
	char dummy_dst[128];
	dma_addr_t dummy_src_addr;
	dma_addr_t dummy_dst_addr;
	u32 saved_config_reg;
	u32 saved_int_mask_reg;
	struct mv_xor_device *xordev;
};

struct mv_xor_desc_slot {
	struct list_head node;
	struct list_head sg_tx_list;
	enum dma_transaction_type type;
	void *hw_desc;
	u16 idx;
	struct dma_async_tx_descriptor async_tx;
};

struct mv_xor_desc {
	u32 status;
	u32 crc32_result;
	u32 desc_command;
	u32 phy_next_desc;
	u32 byte_count;
	u32 phy_dest_addr;
	u32 phy_src_addr[8];
	u32 reserved0;
	u32 reserved1;
};

enum mv_xor_type {
	XOR_ORION = 0,
	XOR_ARMADA_38X = 1,
	XOR_ARMADA_37XX = 2,
};

enum mv_xor_mode {
	XOR_MODE_IN_REG = 0,
	XOR_MODE_IN_DESC = 1,
};

struct mv_xor_v2_descriptor {
	u16 desc_id;
	u16 flags;
	u32 crc32_result;
	u32 desc_ctrl;
	u32 buff_size;
	u32 fill_pattern_src_addr[4];
	u32 data_buff_addr[12];
	u32 reserved[12];
};

struct mv_xor_v2_sw_desc;

struct mv_xor_v2_device {
	spinlock_t lock;
	void *dma_base;
	void *glob_base;
	struct clk *clk;
	struct clk *reg_clk;
	struct tasklet_struct irq_tasklet;
	struct list_head free_sw_desc;
	struct dma_device dmadev;
	struct dma_chan dmachan;
	dma_addr_t hw_desq;
	struct mv_xor_v2_descriptor *hw_desq_virt;
	struct mv_xor_v2_sw_desc *sw_desq;
	int desc_size;
	unsigned int npendings;
	unsigned int hw_queue_idx;
	struct msi_desc *msi_desc;
};

struct mv_xor_v2_sw_desc {
	int idx;
	struct dma_async_tx_descriptor async_tx;
	struct mv_xor_v2_descriptor hw_desc;
	struct list_head free_list;
};

struct mxs_dma_ccw {
	u32 next;
	u16 bits;
	u16 xfer_bytes;
	u32 bufaddr;
	u32 pio_words[16];
};

struct mxs_dma_engine;

struct mxs_dma_chan {
	struct mxs_dma_engine *mxs_dma;
	struct dma_chan chan;
	struct dma_async_tx_descriptor desc;
	struct tasklet_struct tasklet;
	unsigned int chan_irq;
	struct mxs_dma_ccw *ccw;
	dma_addr_t ccw_phys;
	int desc_count;
	enum dma_status status;
	unsigned int flags;
	bool reset;
};

enum mxs_dma_id {
	IMX23_DMA = 0,
	IMX28_DMA = 1,
};

enum mxs_dma_devtype {
	MXS_DMA_APBH = 0,
	MXS_DMA_APBX = 1,
};

struct mxs_dma_engine {
	enum mxs_dma_id dev_id;
	enum mxs_dma_devtype type;
	void *base;
	struct clk *clk;
	struct dma_device dma_device;
	struct mxs_dma_chan mxs_chans[16];
	struct platform_device *pdev;
	unsigned int nr_channels;
};

struct mxs_dma_type {
	enum mxs_dma_id id;
	enum mxs_dma_devtype type;
};

struct mxs_dma_filter_param {
	unsigned int chan_id;
};

struct idmac {
	struct dma_device dma;
};

struct ipu {
	void *reg_ipu;
	void *reg_ic;
	unsigned int irq_fn;
	unsigned int irq_err;
	unsigned int irq_base;
	long unsigned int channel_init_mask;
	spinlock_t lock;
	struct clk *ipu_clk;
	struct device *dev;
	struct idmac idmac;
	struct idmac_channel channel[32];
	struct tasklet_struct tasklet;
};

struct ipu_irq_bank {
	unsigned int control;
	unsigned int status;
	struct ipu *ipu;
};

struct ipu_irq_map {
	unsigned int irq;
	int source;
	struct ipu_irq_bank *bank;
	struct ipu *ipu;
};

enum ipu_color_space {
	IPU_COLORSPACE_RGB = 0,
	IPU_COLORSPACE_YCBCR = 1,
	IPU_COLORSPACE_YUV = 2,
};

enum ipu_rotate_mode {
	IPU_ROTATE_NONE = 0,
	IPU_ROTATE_VERT_FLIP = 1,
	IPU_ROTATE_HORIZ_FLIP = 2,
	IPU_ROTATE_180 = 3,
	IPU_ROTATE_90_RIGHT = 4,
	IPU_ROTATE_90_RIGHT_VFLIP = 5,
	IPU_ROTATE_90_RIGHT_HFLIP = 6,
	IPU_ROTATE_90_LEFT = 7,
};

struct chan_param_mem_planar {
	u32 xv: 10;
	u32 yv: 10;
	u32 xb: 12;
	u32 yb: 12;
	u32 res1: 2;
	u32 nsb: 1;
	u32 lnpb: 6;
	u32 ubo_l: 11;
	u32 ubo_h: 15;
	u32 vbo_l: 17;
	u32 vbo_h: 9;
	u32 res2: 3;
	u32 fw: 12;
	u32 fh_l: 8;
	u32 fh_h: 4;
	u32 res3: 28;
	u32 eba0;
	u32 eba1;
	u32 bpp: 3;
	u32 sl: 14;
	u32 pfs: 3;
	u32 bam: 3;
	u32 res4: 2;
	u32 npb: 6;
	u32 res5: 1;
	u32 sat: 2;
	u32 res6: 30;
};

struct chan_param_mem_interleaved {
	u32 xv: 10;
	u32 yv: 10;
	u32 xb: 12;
	u32 yb: 12;
	u32 sce: 1;
	u32 res1: 1;
	u32 nsb: 1;
	u32 lnpb: 6;
	u32 sx: 10;
	u32 sy_l: 1;
	u32 sy_h: 9;
	u32 ns: 10;
	u32 sm: 10;
	u32 sdx_l: 3;
	u32 sdx_h: 2;
	u32 sdy: 5;
	u32 sdrx: 1;
	u32 sdry: 1;
	u32 sdr1: 1;
	u32 res2: 2;
	u32 fw: 12;
	u32 fh_l: 8;
	u32 fh_h: 4;
	u32 res3: 28;
	u32 eba0;
	u32 eba1;
	u32 bpp: 3;
	u32 sl: 14;
	u32 pfs: 3;
	u32 bam: 3;
	u32 res4: 2;
	u32 npb: 6;
	u32 res5: 1;
	u32 sat: 2;
	u32 scc: 1;
	u32 ofs0: 5;
	u32 ofs1: 5;
	u32 ofs2: 5;
	u32 ofs3: 5;
	u32 wid0: 3;
	u32 wid1: 3;
	u32 wid2: 3;
	u32 wid3: 3;
	u32 dec_sel: 1;
	u32 res6: 28;
};

union chan_param_mem {
	struct chan_param_mem_planar pp;
	struct chan_param_mem_interleaved ip;
};

enum k3_ring_mode {
	K3_RINGACC_RING_MODE_RING = 0,
	K3_RINGACC_RING_MODE_MESSAGE = 1,
	K3_RINGACC_RING_MODE_CREDENTIALS = 2,
	K3_RINGACC_RING_MODE_INVALID = 3,
};

enum k3_ring_size {
	K3_RINGACC_RING_ELSIZE_4 = 0,
	K3_RINGACC_RING_ELSIZE_8 = 1,
	K3_RINGACC_RING_ELSIZE_16 = 2,
	K3_RINGACC_RING_ELSIZE_32 = 3,
	K3_RINGACC_RING_ELSIZE_64 = 4,
	K3_RINGACC_RING_ELSIZE_128 = 5,
	K3_RINGACC_RING_ELSIZE_256 = 6,
	K3_RINGACC_RING_ELSIZE_INVALID = 7,
};

struct k3_ring_cfg {
	u32 size;
	enum k3_ring_size elm_size;
	enum k3_ring_mode mode;
	u32 flags;
	struct device *dma_dev;
	u32 asel;
};

struct k3_ringacc_init_data {
	const struct ti_sci_handle *tisci;
	u32 tisci_dev_id;
	u32 num_rings;
};

struct k3_event_route_data {
	void *priv;
	int (*set_event)(void *, u32);
};

struct cppi5_desc_hdr_t {
	u32 pkt_info0;
	u32 pkt_info1;
	u32 pkt_info2;
	u32 src_dst_tag;
};

struct cppi5_host_desc_t {
	struct cppi5_desc_hdr_t hdr;
	u64 next_desc;
	u64 buf_ptr;
	u32 buf_info1;
	u32 org_buf_len;
	u64 org_buf_ptr;
	u32 epib[0];
};

enum cppi5_tr_types {
	CPPI5_TR_TYPE0 = 0,
	CPPI5_TR_TYPE1 = 1,
	CPPI5_TR_TYPE2 = 2,
	CPPI5_TR_TYPE3 = 3,
	CPPI5_TR_TYPE4 = 4,
	CPPI5_TR_TYPE5 = 5,
	CPPI5_TR_TYPE8 = 8,
	CPPI5_TR_TYPE9 = 9,
	CPPI5_TR_TYPE10 = 10,
	CPPI5_TR_TYPE11 = 11,
	CPPI5_TR_TYPE15 = 15,
	CPPI5_TR_TYPE_MAX = 16,
};

enum cppi5_tr_event_size {
	CPPI5_TR_EVENT_SIZE_COMPLETION = 0,
	CPPI5_TR_EVENT_SIZE_ICNT1_DEC = 1,
	CPPI5_TR_EVENT_SIZE_ICNT2_DEC = 2,
	CPPI5_TR_EVENT_SIZE_ICNT3_DEC = 3,
	CPPI5_TR_EVENT_SIZE_MAX = 4,
};

enum cppi5_tr_trigger {
	CPPI5_TR_TRIGGER_NONE = 0,
	CPPI5_TR_TRIGGER_GLOBAL0 = 1,
	CPPI5_TR_TRIGGER_GLOBAL1 = 2,
	CPPI5_TR_TRIGGER_LOCAL_EVENT = 3,
	CPPI5_TR_TRIGGER_MAX = 4,
};

enum cppi5_tr_trigger_type {
	CPPI5_TR_TRIGGER_TYPE_ICNT1_DEC = 0,
	CPPI5_TR_TRIGGER_TYPE_ICNT2_DEC = 1,
	CPPI5_TR_TRIGGER_TYPE_ICNT3_DEC = 2,
	CPPI5_TR_TRIGGER_TYPE_ALL = 3,
	CPPI5_TR_TRIGGER_TYPE_MAX = 4,
};

typedef u32 cppi5_tr_flags_t;

struct cppi5_tr_type1_t {
	cppi5_tr_flags_t flags;
	u16 icnt0;
	u16 icnt1;
	u64 addr;
	s32 dim1;
	long: 32;
	long: 64;
};

struct cppi5_tr_type15_t {
	cppi5_tr_flags_t flags;
	u16 icnt0;
	u16 icnt1;
	u64 addr;
	s32 dim1;
	u16 icnt2;
	u16 icnt3;
	s32 dim2;
	s32 dim3;
	u32 _reserved;
	s32 ddim1;
	u64 daddr;
	s32 ddim2;
	s32 ddim3;
	u16 dicnt0;
	u16 dicnt1;
	u16 dicnt2;
	u16 dicnt3;
};

struct cppi5_tr_resp_t {
	u8 status;
	u8 _reserved;
	u8 cmd_id;
	u8 flags;
};

enum udma_rm_range {
	RM_RANGE_BCHAN = 0,
	RM_RANGE_TCHAN = 1,
	RM_RANGE_RCHAN = 2,
	RM_RANGE_RFLOW = 3,
	RM_RANGE_TFLOW = 4,
	RM_RANGE_LAST = 5,
};

struct udma_tisci_rm {
	const struct ti_sci_handle *tisci;
	const struct ti_sci_rm_udmap_ops *tisci_udmap_ops;
	u32 tisci_dev_id;
	const struct ti_sci_rm_psil_ops *tisci_psil_ops;
	u32 tisci_navss_dev_id;
	struct ti_sci_resource *rm_ranges[5];
};

enum udma_tp_level {
	UDMA_TP_NORMAL = 0,
	UDMA_TP_HIGH = 1,
	UDMA_TP_ULTRAHIGH = 2,
	UDMA_TP_LAST = 3,
};

enum psil_endpoint_type {
	PSIL_EP_NATIVE = 0,
	PSIL_EP_PDMA_XY = 1,
	PSIL_EP_PDMA_MCAN = 2,
	PSIL_EP_PDMA_AASRC = 3,
};

struct psil_endpoint_config {
	enum psil_endpoint_type ep_type;
	enum udma_tp_level channel_tpl;
	unsigned int pkt_mode: 1;
	unsigned int notdpkt: 1;
	unsigned int needs_epib: 1;
	unsigned int pdma_acc32: 1;
	unsigned int pdma_burst: 1;
	u32 psd_size;
	s16 mapped_channel_id;
	u16 flow_start;
	u16 flow_num;
	s16 default_flow_id;
};

struct psil_ep {
	u32 thread_id;
	struct psil_endpoint_config ep_config;
};

struct psil_ep_map {
	char *name;
	struct psil_ep *src;
	int src_count;
	struct psil_ep *dst;
	int dst_count;
};

struct udma_static_tr {
	u8 elsize;
	u16 elcnt;
	u16 bstcnt;
};

enum k3_dma_type {
	DMA_TYPE_UDMA = 0,
	DMA_TYPE_BCDMA = 1,
	DMA_TYPE_PKTDMA = 2,
};

enum udma_mmr {
	MMR_GCFG = 0,
	MMR_BCHANRT = 1,
	MMR_RCHANRT = 2,
	MMR_TCHANRT = 3,
	MMR_LAST = 4,
};

struct k3_ring;

struct udma_tchan {
	void *reg_rt;
	int id;
	struct k3_ring *t_ring;
	struct k3_ring *tc_ring;
	int tflow_id;
};

struct udma_rflow {
	int id;
	struct k3_ring *fd_ring;
	struct k3_ring *r_ring;
};

struct udma_rchan {
	void *reg_rt;
	int id;
};

struct udma_oes_offsets {
	u32 udma_rchan;
	u32 bcdma_bchan_data;
	u32 bcdma_bchan_ring;
	u32 bcdma_tchan_data;
	u32 bcdma_tchan_ring;
	u32 bcdma_rchan_data;
	u32 bcdma_rchan_ring;
	u32 pktdma_tchan_flow;
	u32 pktdma_rchan_flow;
};

struct udma_match_data {
	enum k3_dma_type type;
	u32 psil_base;
	bool enable_memcpy_support;
	u32 flags;
	u32 statictr_z_mask;
	u8 burst_size[3];
};

struct udma_soc_data {
	struct udma_oes_offsets oes;
	u32 bcdma_trigger_event_offset;
};

struct udma_hwdesc {
	size_t cppi5_desc_size;
	void *cppi5_desc_vaddr;
	dma_addr_t cppi5_desc_paddr;
	void *tr_req_base;
	struct cppi5_tr_resp_t *tr_resp_base;
};

struct udma_rx_flush {
	struct udma_hwdesc hwdescs[2];
	size_t buffer_size;
	void *buffer_vaddr;
	dma_addr_t buffer_paddr;
};

struct udma_tpl {
	u8 levels;
	u32 start_idx[3];
};

struct k3_ringacc;

struct udma_chan;

struct udma_dev {
	struct dma_device ddev;
	struct device *dev;
	void *mmrs[4];
	const struct udma_match_data *match_data;
	const struct udma_soc_data *soc_data;
	struct udma_tpl bchan_tpl;
	struct udma_tpl tchan_tpl;
	struct udma_tpl rchan_tpl;
	size_t desc_align;
	struct udma_tisci_rm tisci_rm;
	struct k3_ringacc *ringacc;
	struct work_struct purge_work;
	struct list_head desc_to_purge;
	spinlock_t lock;
	struct udma_rx_flush rx_flush;
	int bchan_cnt;
	int tchan_cnt;
	int echan_cnt;
	int rchan_cnt;
	int rflow_cnt;
	int tflow_cnt;
	long unsigned int *bchan_map;
	long unsigned int *tchan_map;
	long unsigned int *rchan_map;
	long unsigned int *rflow_gp_map;
	long unsigned int *rflow_gp_map_allocated;
	long unsigned int *rflow_in_use;
	long unsigned int *tflow_map;
	struct udma_tchan *bchans;
	struct udma_tchan *tchans;
	struct udma_rchan *rchans;
	struct udma_rflow *rflows;
	struct udma_chan *channels;
	u32 psil_base;
	u32 atype;
	u32 asel;
};

enum udma_chan_state {
	UDMA_CHAN_IS_IDLE = 0,
	UDMA_CHAN_IS_ACTIVE = 1,
	UDMA_CHAN_IS_TERMINATING = 2,
};

struct udma_tx_drain {
	struct delayed_work work;
	ktime_t tstamp;
	u32 residue;
};

struct udma_chan_config {
	bool pkt_mode;
	bool needs_epib;
	u32 psd_size;
	u32 metadata_size;
	u32 hdesc_size;
	bool notdpkt;
	int remote_thread_id;
	u32 atype;
	u32 asel;
	u32 src_thread;
	u32 dst_thread;
	enum psil_endpoint_type ep_type;
	bool enable_acc32;
	bool enable_burst;
	enum udma_tp_level channel_tpl;
	u32 tr_trigger_type;
	int mapped_channel_id;
	int default_flow_id;
	enum dma_transfer_direction dir;
};

struct udma_desc;

struct udma_chan {
	struct virt_dma_chan vc;
	struct dma_slave_config cfg;
	struct udma_dev *ud;
	struct device *dma_dev;
	struct udma_desc *desc;
	struct udma_desc *terminated_desc;
	struct udma_static_tr static_tr;
	char *name;
	struct udma_tchan *bchan;
	struct udma_tchan *tchan;
	struct udma_rchan *rchan;
	struct udma_rflow *rflow;
	bool psil_paired;
	int irq_num_ring;
	int irq_num_udma;
	bool cyclic;
	bool paused;
	enum udma_chan_state state;
	struct completion teardown_completed;
	struct udma_tx_drain tx_drain;
	u32 bcnt;
	struct udma_chan_config config;
	bool use_dma_pool;
	struct dma_pool___2 *hdesc_pool;
	u32 id;
};

struct udma_desc {
	struct virt_dma_desc vd;
	bool terminated;
	enum dma_transfer_direction dir;
	struct udma_static_tr static_tr;
	u32 residue;
	unsigned int sglen;
	unsigned int desc_idx;
	unsigned int tr_idx;
	u32 metadata_size;
	void *metadata;
	unsigned int hwdesc_count;
	struct udma_hwdesc hwdesc[0];
};

struct udma_filter_param {
	int remote_thread_id;
	u32 atype;
	u32 asel;
	u32 tr_trigger_type;
};

struct k3_udma_glue_tx_channel_cfg {
	struct k3_ring_cfg tx_cfg;
	struct k3_ring_cfg txcq_cfg;
	bool tx_pause_on_err;
	bool tx_filt_einfo;
	bool tx_filt_pswords;
	bool tx_supr_tdpkt;
	u32 swdata_size;
};

struct k3_udma_glue_rx_flow_cfg {
	struct k3_ring_cfg rx_cfg;
	struct k3_ring_cfg rxfdq_cfg;
	int ring_rxq_id;
	int ring_rxfdq0_id;
	bool rx_error_handling;
	int src_tag_lo_sel;
};

struct k3_udma_glue_rx_channel_cfg {
	u32 swdata_size;
	int flow_id_base;
	int flow_id_num;
	bool flow_id_use_rxchan_id;
	bool remote;
	struct k3_udma_glue_rx_flow_cfg *def_flow_cfg;
};

struct udma_dev___2;

struct k3_udma_glue_common {
	struct device *dev;
	struct device chan_dev;
	struct udma_dev___2 *udmax;
	const struct udma_tisci_rm *tisci_rm;
	struct k3_ringacc *ringacc;
	u32 src_thread;
	u32 dst_thread;
	u32 hdesc_size;
	bool epib;
	u32 psdata_size;
	u32 swdata_size;
	u32 atype_asel;
	struct psil_endpoint_config *ep_config;
};

struct udma_tchan___2;

struct k3_udma_glue_tx_channel {
	struct k3_udma_glue_common common;
	struct udma_tchan___2 *udma_tchanx;
	int udma_tchan_id;
	struct k3_ring *ringtx;
	struct k3_ring *ringtxcq;
	bool psil_paired;
	int virq;
	atomic_t free_pkts;
	bool tx_pause_on_err;
	bool tx_filt_einfo;
	bool tx_filt_pswords;
	bool tx_supr_tdpkt;
	int udma_tflow_id;
};

struct udma_rflow___2;

struct k3_udma_glue_rx_flow {
	struct udma_rflow___2 *udma_rflow;
	int udma_rflow_id;
	struct k3_ring *ringrx;
	struct k3_ring *ringrxfdq;
	int virq;
};

struct udma_rchan___2;

struct k3_udma_glue_rx_channel {
	struct k3_udma_glue_common common;
	struct udma_rchan___2 *udma_rchanx;
	int udma_rchan_id;
	bool remote;
	bool psil_paired;
	u32 swdata_size;
	int flow_id_base;
	struct k3_udma_glue_rx_flow *flows;
	u32 flow_num;
	u32 flows_ready;
};

typedef struct generic_pm_domain * (*genpd_xlate_t)(struct of_phandle_args *, void *);

struct genpd_onecell_data {
	struct generic_pm_domain **domains;
	unsigned int num_domains;
	genpd_xlate_t xlate;
};

struct owl_sps_domain_info {
	const char *name;
	int pwr_bit;
	int ack_bit;
	unsigned int genpd_flags;
};

struct owl_sps_info {
	unsigned int num_domains;
	const struct owl_sps_domain_info *domains;
};

struct owl_sps {
	struct device *dev;
	const struct owl_sps_info *info;
	void *base;
	struct genpd_onecell_data genpd_data;
	struct generic_pm_domain *domains[0];
};

struct owl_sps_domain {
	struct generic_pm_domain genpd;
	const struct owl_sps_domain_info *info;
	struct owl_sps *sps;
};

struct bcm2835_pm {
	struct device *dev;
	void *base;
	void *asb;
};

struct bcm2835_power;

struct bcm2835_power_domain {
	struct generic_pm_domain base;
	struct bcm2835_power *power;
	u32 domain;
	struct clk *clk;
};

struct bcm2835_power {
	struct device *dev;
	void *base;
	void *asb;
	struct genpd_onecell_data pd_xlate;
	struct bcm2835_power_domain domains[13];
	struct reset_controller_dev reset;
};

enum rpi_firmware_property_tag {
	RPI_FIRMWARE_PROPERTY_END = 0,
	RPI_FIRMWARE_GET_FIRMWARE_REVISION = 1,
	RPI_FIRMWARE_SET_CURSOR_INFO = 32784,
	RPI_FIRMWARE_SET_CURSOR_STATE = 32785,
	RPI_FIRMWARE_GET_BOARD_MODEL = 65537,
	RPI_FIRMWARE_GET_BOARD_REVISION = 65538,
	RPI_FIRMWARE_GET_BOARD_MAC_ADDRESS = 65539,
	RPI_FIRMWARE_GET_BOARD_SERIAL = 65540,
	RPI_FIRMWARE_GET_ARM_MEMORY = 65541,
	RPI_FIRMWARE_GET_VC_MEMORY = 65542,
	RPI_FIRMWARE_GET_CLOCKS = 65543,
	RPI_FIRMWARE_GET_POWER_STATE = 131073,
	RPI_FIRMWARE_GET_TIMING = 131074,
	RPI_FIRMWARE_SET_POWER_STATE = 163841,
	RPI_FIRMWARE_GET_CLOCK_STATE = 196609,
	RPI_FIRMWARE_GET_CLOCK_RATE = 196610,
	RPI_FIRMWARE_GET_VOLTAGE = 196611,
	RPI_FIRMWARE_GET_MAX_CLOCK_RATE = 196612,
	RPI_FIRMWARE_GET_MAX_VOLTAGE = 196613,
	RPI_FIRMWARE_GET_TEMPERATURE = 196614,
	RPI_FIRMWARE_GET_MIN_CLOCK_RATE = 196615,
	RPI_FIRMWARE_GET_MIN_VOLTAGE = 196616,
	RPI_FIRMWARE_GET_TURBO = 196617,
	RPI_FIRMWARE_GET_MAX_TEMPERATURE = 196618,
	RPI_FIRMWARE_GET_STC = 196619,
	RPI_FIRMWARE_ALLOCATE_MEMORY = 196620,
	RPI_FIRMWARE_LOCK_MEMORY = 196621,
	RPI_FIRMWARE_UNLOCK_MEMORY = 196622,
	RPI_FIRMWARE_RELEASE_MEMORY = 196623,
	RPI_FIRMWARE_EXECUTE_CODE = 196624,
	RPI_FIRMWARE_EXECUTE_QPU = 196625,
	RPI_FIRMWARE_SET_ENABLE_QPU = 196626,
	RPI_FIRMWARE_GET_DISPMANX_RESOURCE_MEM_HANDLE = 196628,
	RPI_FIRMWARE_GET_EDID_BLOCK = 196640,
	RPI_FIRMWARE_GET_CUSTOMER_OTP = 196641,
	RPI_FIRMWARE_GET_DOMAIN_STATE = 196656,
	RPI_FIRMWARE_GET_THROTTLED = 196678,
	RPI_FIRMWARE_GET_CLOCK_MEASURED = 196679,
	RPI_FIRMWARE_NOTIFY_REBOOT = 196680,
	RPI_FIRMWARE_SET_CLOCK_STATE = 229377,
	RPI_FIRMWARE_SET_CLOCK_RATE = 229378,
	RPI_FIRMWARE_SET_VOLTAGE = 229379,
	RPI_FIRMWARE_SET_TURBO = 229385,
	RPI_FIRMWARE_SET_CUSTOMER_OTP = 229409,
	RPI_FIRMWARE_SET_DOMAIN_STATE = 229424,
	RPI_FIRMWARE_GET_GPIO_STATE = 196673,
	RPI_FIRMWARE_SET_GPIO_STATE = 229441,
	RPI_FIRMWARE_SET_SDHOST_CLOCK = 229442,
	RPI_FIRMWARE_GET_GPIO_CONFIG = 196675,
	RPI_FIRMWARE_SET_GPIO_CONFIG = 229443,
	RPI_FIRMWARE_GET_PERIPH_REG = 196677,
	RPI_FIRMWARE_SET_PERIPH_REG = 229445,
	RPI_FIRMWARE_GET_POE_HAT_VAL = 196681,
	RPI_FIRMWARE_SET_POE_HAT_VAL = 196688,
	RPI_FIRMWARE_NOTIFY_XHCI_RESET = 196696,
	RPI_FIRMWARE_FRAMEBUFFER_ALLOCATE = 262145,
	RPI_FIRMWARE_FRAMEBUFFER_BLANK = 262146,
	RPI_FIRMWARE_FRAMEBUFFER_GET_PHYSICAL_WIDTH_HEIGHT = 262147,
	RPI_FIRMWARE_FRAMEBUFFER_GET_VIRTUAL_WIDTH_HEIGHT = 262148,
	RPI_FIRMWARE_FRAMEBUFFER_GET_DEPTH = 262149,
	RPI_FIRMWARE_FRAMEBUFFER_GET_PIXEL_ORDER = 262150,
	RPI_FIRMWARE_FRAMEBUFFER_GET_ALPHA_MODE = 262151,
	RPI_FIRMWARE_FRAMEBUFFER_GET_PITCH = 262152,
	RPI_FIRMWARE_FRAMEBUFFER_GET_VIRTUAL_OFFSET = 262153,
	RPI_FIRMWARE_FRAMEBUFFER_GET_OVERSCAN = 262154,
	RPI_FIRMWARE_FRAMEBUFFER_GET_PALETTE = 262155,
	RPI_FIRMWARE_FRAMEBUFFER_GET_TOUCHBUF = 262159,
	RPI_FIRMWARE_FRAMEBUFFER_GET_GPIOVIRTBUF = 262160,
	RPI_FIRMWARE_FRAMEBUFFER_RELEASE = 294913,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_PHYSICAL_WIDTH_HEIGHT = 278531,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_VIRTUAL_WIDTH_HEIGHT = 278532,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_DEPTH = 278533,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_PIXEL_ORDER = 278534,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_ALPHA_MODE = 278535,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_VIRTUAL_OFFSET = 278537,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_OVERSCAN = 278538,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_PALETTE = 278539,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_VSYNC = 278542,
	RPI_FIRMWARE_FRAMEBUFFER_SET_PHYSICAL_WIDTH_HEIGHT = 294915,
	RPI_FIRMWARE_FRAMEBUFFER_SET_VIRTUAL_WIDTH_HEIGHT = 294916,
	RPI_FIRMWARE_FRAMEBUFFER_SET_DEPTH = 294917,
	RPI_FIRMWARE_FRAMEBUFFER_SET_PIXEL_ORDER = 294918,
	RPI_FIRMWARE_FRAMEBUFFER_SET_ALPHA_MODE = 294919,
	RPI_FIRMWARE_FRAMEBUFFER_SET_VIRTUAL_OFFSET = 294921,
	RPI_FIRMWARE_FRAMEBUFFER_SET_OVERSCAN = 294922,
	RPI_FIRMWARE_FRAMEBUFFER_SET_PALETTE = 294923,
	RPI_FIRMWARE_FRAMEBUFFER_SET_TOUCHBUF = 294943,
	RPI_FIRMWARE_FRAMEBUFFER_SET_GPIOVIRTBUF = 294944,
	RPI_FIRMWARE_FRAMEBUFFER_SET_VSYNC = 294926,
	RPI_FIRMWARE_FRAMEBUFFER_SET_BACKLIGHT = 294927,
	RPI_FIRMWARE_VCHIQ_INIT = 294928,
	RPI_FIRMWARE_GET_COMMAND_LINE = 327681,
	RPI_FIRMWARE_GET_DMA_CHANNELS = 393217,
};

struct rpi_firmware;

struct rpi_power_domain {
	u32 domain;
	bool enabled;
	bool old_interface;
	struct generic_pm_domain base;
	struct rpi_firmware *fw;
};

struct rpi_power_domains {
	bool has_new_interface;
	struct genpd_onecell_data xlate;
	struct rpi_firmware *fw;
	struct rpi_power_domain domains[23];
};

struct rpi_power_domain_packet {
	u32 domain;
	u32 on;
};

struct soc_device;

enum cpubiuctrl_regs {
	CPU_CREDIT_REG = 0,
	CPU_MCP_FLOW_REG = 1,
	CPU_WRITEBACK_CTRL_REG = 2,
	RAC_CONFIG0_REG = 3,
	RAC_CONFIG1_REG = 4,
	NUM_CPU_BIUCTRL_REGS = 5,
};

struct bman_hwerr_txt {
	u32 mask;
	const char *txt;
};

struct qman_portal;

enum qm_wq_class {
	qm_wq_portal = 0,
	qm_wq_pool = 1,
	qm_wq_fman0 = 2,
	qm_wq_fman1 = 3,
	qm_wq_caam = 4,
	qm_wq_pme = 5,
	qm_wq_first = 0,
	qm_wq_last = 5,
};

enum qm_memory {
	qm_memory_fqd = 0,
	qm_memory_pfdr = 1,
};

struct qm_ecir {
	u32 info;
};

struct qm_ecir2 {
	u32 info;
};

struct qm_eadr {
	u32 info;
};

struct qman_hwerr_txt {
	u32 mask;
	const char *txt;
};

struct qman_error_info_mdata {
	u16 addr_mask;
	u16 bits;
	const char *txt;
};

enum qm_dc_portal {
	qm_dc_portal_fman0 = 0,
	qm_dc_portal_fman1 = 1,
};

struct bm_portal_config {
	void *addr_virt_ce;
	void *addr_virt_ci;
	struct list_head list;
	struct device *dev;
	int cpu;
	int irq;
};

struct bman_portal;

struct qm_portal_config {
	void *addr_virt_ce;
	void *addr_virt_ci;
	struct device *dev;
	struct iommu_domain *iommu_domain;
	struct list_head list;
	int cpu;
	int irq;
	u16 channel;
	u32 pools;
};

struct bm_buffer {
	union {
		struct {
			__be16 bpid;
			__be16 hi;
			__be32 lo;
		};
		__be64 data;
	};
};

enum bm_rcr_pmode {
	bm_rcr_pci = 0,
	bm_rcr_pce = 1,
	bm_rcr_pvb = 2,
};

enum bm_rcr_cmode {
	bm_rcr_cci = 0,
	bm_rcr_cce = 1,
};

struct bm_rcr_entry {
	union {
		struct {
			u8 _ncw_verb;
			u8 bpid;
			u8 __reserved1[62];
		};
		struct bm_buffer bufs[8];
	};
};

struct bm_rcr {
	struct bm_rcr_entry *ring;
	struct bm_rcr_entry *cursor;
	u8 ci;
	u8 available;
	u8 ithresh;
	u8 vbit;
	u32 busy;
	enum bm_rcr_pmode pmode;
	enum bm_rcr_cmode cmode;
};

struct bm_mc_command {
	u8 _ncw_verb;
	u8 bpid;
	u8 __reserved[62];
};

union bm_mc_result {
	struct {
		u8 verb;
		u8 bpid;
		u8 __reserved[62];
	};
	struct bm_buffer bufs[8];
};

struct bm_mc {
	struct bm_mc_command *cr;
	union bm_mc_result *rr;
	u8 rridx;
	u8 vbit;
	enum {
		mc_idle = 0,
		mc_user = 1,
		mc_hw = 2,
	} state;
};

struct bm_addr {
	void *ce;
	__be32 *ce_be;
	void *ci;
};

struct bm_portal {
	struct bm_addr addr;
	struct bm_rcr rcr;
	struct bm_mc mc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bman_portal___2 {
	struct bm_portal p;
	long unsigned int irq_sources;
	const struct bm_portal_config *config;
	char irqname[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bman_pool {
	u32 bpid;
	struct bman_portal___2 *portal;
	struct bman_pool *next;
};

struct qm_fd {
	union {
		struct {
			u8 cfg8b_w1;
			u8 bpid;
			u8 cfg8b_w3;
			u8 addr_hi;
			__be32 addr_lo;
		};
		__be64 data;
	};
	__be32 cfg;
	union {
		__be32 cmd;
		__be32 status;
	};
};

struct qm_dqrr_entry {
	u8 verb;
	u8 stat;
	__be16 seqnum;
	u8 tok;
	u8 __reserved2[3];
	__be32 fqid;
	__be32 context_b;
	struct qm_fd fd;
	u8 __reserved4[32];
};

union qm_mr_entry {
	struct {
		u8 verb;
		u8 __reserved[63];
	};
	struct {
		u8 verb;
		u8 dca;
		__be16 seqnum;
		u8 rc;
		u8 __reserved[3];
		__be32 fqid;
		__be32 tag;
		struct qm_fd fd;
		u8 __reserved1[32];
	} ern;
	struct {
		u8 verb;
		u8 fqs;
		u8 __reserved1[6];
		__be32 fqid;
		__be32 context_b;
		u8 __reserved2[48];
	} fq;
};

struct qm_fqd_stashing {
	u8 exclusive;
	u8 cl;
};

struct qm_fqd_oac {
	u8 oac;
	s8 oal;
};

struct qm_fqd {
	u8 orpc;
	u8 cgid;
	__be16 fq_ctrl;
	__be16 dest_wq;
	__be16 ics_cred;
	union {
		__be16 td;
		struct qm_fqd_oac oac_init;
	};
	__be32 context_b;
	union {
		__be64 opaque;
		struct {
			__be32 hi;
			__be32 lo;
		};
		struct {
			struct qm_fqd_stashing stashing;
			__be16 context_hi;
			__be32 context_lo;
		};
	} context_a;
	struct qm_fqd_oac oac_query;
} __attribute__((packed));

struct qm_cgr_wr_parm {
	__be32 word;
};

struct qm_cgr_cs_thres {
	__be16 word;
};

struct __qm_mc_cgr {
	struct qm_cgr_wr_parm wr_parm_g;
	struct qm_cgr_wr_parm wr_parm_y;
	struct qm_cgr_wr_parm wr_parm_r;
	u8 wr_en_g;
	u8 wr_en_y;
	u8 wr_en_r;
	u8 cscn_en;
	union {
		struct {
			__be16 cscn_targ_upd_ctrl;
			__be16 cscn_targ_dcp_low;
		};
		__be32 cscn_targ;
	};
	u8 cstd_en;
	u8 cs;
	struct qm_cgr_cs_thres cs_thres;
	u8 mode;
} __attribute__((packed));

struct qm_mcc_initfq {
	u8 __reserved1[2];
	__be16 we_mask;
	__be32 fqid;
	__be16 count;
	struct qm_fqd fqd;
	u8 __reserved2[30];
} __attribute__((packed));

struct qm_mcc_initcgr {
	u8 __reserve1[2];
	__be16 we_mask;
	struct __qm_mc_cgr cgr;
	u8 __reserved2[2];
	u8 cgid;
	u8 __reserved3[32];
};

enum qman_cb_dqrr_result {
	qman_cb_dqrr_consume = 0,
	qman_cb_dqrr_park = 1,
	qman_cb_dqrr_defer = 2,
	qman_cb_dqrr_stop = 3,
	qman_cb_dqrr_consume_stop = 4,
};

struct qman_portal___2;

struct qman_fq;

typedef enum qman_cb_dqrr_result (*qman_cb_dqrr)(struct qman_portal___2 *, struct qman_fq *, const struct qm_dqrr_entry *, bool);

struct qm_addr {
	void *ce;
	__be32 *ce_be;
	void *ci;
};

enum qm_eqcr_pmode {
	qm_eqcr_pci = 0,
	qm_eqcr_pce = 1,
	qm_eqcr_pvb = 2,
};

struct qm_eqcr_entry;

struct qm_eqcr {
	struct qm_eqcr_entry *ring;
	struct qm_eqcr_entry *cursor;
	u8 ci;
	u8 available;
	u8 ithresh;
	u8 vbit;
	u32 busy;
	enum qm_eqcr_pmode pmode;
};

enum qm_dqrr_dmode {
	qm_dqrr_dpush = 0,
	qm_dqrr_dpull = 1,
};

enum qm_dqrr_pmode {
	qm_dqrr_pci = 0,
	qm_dqrr_pce = 1,
	qm_dqrr_pvb = 2,
};

enum qm_dqrr_cmode {
	qm_dqrr_cci = 0,
	qm_dqrr_cce = 1,
	qm_dqrr_cdc = 2,
};

struct qm_dqrr {
	const struct qm_dqrr_entry *ring;
	const struct qm_dqrr_entry *cursor;
	u8 pi;
	u8 ci;
	u8 fill;
	u8 ithresh;
	u8 vbit;
	enum qm_dqrr_dmode dmode;
	enum qm_dqrr_pmode pmode;
	enum qm_dqrr_cmode cmode;
};

enum qm_mr_pmode {
	qm_mr_pci = 0,
	qm_mr_pce = 1,
	qm_mr_pvb = 2,
};

enum qm_mr_cmode {
	qm_mr_cci = 0,
	qm_mr_cce = 1,
};

struct qm_mr {
	union qm_mr_entry *ring;
	union qm_mr_entry *cursor;
	u8 pi;
	u8 ci;
	u8 fill;
	u8 ithresh;
	u8 vbit;
	enum qm_mr_pmode pmode;
	enum qm_mr_cmode cmode;
};

union qm_mc_command;

union qm_mc_result;

struct qm_mc {
	union qm_mc_command *cr;
	union qm_mc_result *rr;
	u8 rridx;
	u8 vbit;
	enum {
		qman_mc_idle = 0,
		qman_mc_user = 1,
		qman_mc_hw = 2,
	} state;
};

struct qm_portal {
	struct qm_addr addr;
	struct qm_eqcr eqcr;
	struct qm_dqrr dqrr;
	struct qm_mr mr;
	struct qm_mc mc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct qman_cgrs;

struct qman_portal___2 {
	struct qm_portal p;
	long unsigned int bits;
	long unsigned int irq_sources;
	u32 use_eqcr_ci_stashing;
	struct qman_fq *vdqcr_owned;
	u32 sdqcr;
	const struct qm_portal_config *config;
	struct qman_cgrs *cgrs;
	struct list_head cgr_cbs;
	spinlock_t cgr_lock;
	struct work_struct congestion_work;
	struct work_struct mr_work;
	char irqname[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef void (*qman_cb_mr)(struct qman_portal___2 *, struct qman_fq *, const union qm_mr_entry *);

struct qman_fq_cb {
	qman_cb_dqrr dqrr;
	qman_cb_mr ern;
	qman_cb_mr fqs;
};

enum qman_fq_state {
	qman_fq_state_oos = 0,
	qman_fq_state_parked = 1,
	qman_fq_state_sched = 2,
	qman_fq_state_retired = 3,
};

struct qman_fq {
	struct qman_fq_cb cb;
	u32 fqid;
	u32 idx;
	long unsigned int flags;
	enum qman_fq_state state;
	int cgr_groupid;
};

struct qman_cgr;

typedef void (*qman_cb_cgr)(struct qman_portal___2 *, struct qman_cgr *, int);

struct qman_cgr {
	u32 cgrid;
	qman_cb_cgr cb;
	u16 chan;
	struct list_head node;
};

struct qm_mcr_queryfq_np {
	u8 verb;
	u8 result;
	u8 __reserved1;
	u8 state;
	u32 fqd_link;
	u16 odp_seq;
	u16 orp_nesn;
	u16 orp_ea_hseq;
	u16 orp_ea_tseq;
	u32 orp_ea_hptr;
	u32 orp_ea_tptr;
	u32 pfdr_hptr;
	u32 pfdr_tptr;
	u8 __reserved2[5];
	u8 is;
	u16 ics_surp;
	u32 byte_cnt;
	u32 frm_cnt;
	u32 __reserved3;
	u16 ra1_sfdr;
	u16 ra2_sfdr;
	u16 __reserved4;
	u16 od1_sfdr;
	u16 od2_sfdr;
	u16 od3_sfdr;
};

struct qm_mcr_querywq {
	u8 verb;
	u8 result;
	u16 channel_wq;
	u8 __reserved[28];
	u32 wq_len[8];
};

struct __qm_mcr_querycongestion {
	u32 state[8];
};

struct qm_mcr_querycongestion {
	u8 verb;
	u8 result;
	u8 __reserved[30];
	struct __qm_mcr_querycongestion state;
};

struct qm_mcr_querycgr {
	u8 verb;
	u8 result;
	u16 __reserved1;
	struct __qm_mc_cgr cgr;
	u8 __reserved2[6];
	u8 i_bcnt_hi;
	__be32 i_bcnt_lo;
	u8 __reserved3[3];
	u8 a_bcnt_hi;
	__be32 a_bcnt_lo;
	__be32 cscn_targ_swp[4];
};

struct qman_cgrs {
	struct __qm_mcr_querycongestion q;
};

struct qm_eqcr_entry {
	u8 _ncw_verb;
	u8 dca;
	__be16 seqnum;
	u8 __reserved[4];
	__be32 fqid;
	__be32 tag;
	struct qm_fd fd;
	u8 __reserved3[32];
};

struct qm_mcc_fq {
	u8 _ncw_verb;
	u8 __reserved1[3];
	__be32 fqid;
	u8 __reserved2[56];
};

struct qm_mcc_cgr {
	u8 _ncw_verb;
	u8 __reserved1[30];
	u8 cgid;
	u8 __reserved2[32];
};

union qm_mc_command {
	struct {
		u8 _ncw_verb;
		u8 __reserved[63];
	};
	struct qm_mcc_initfq initfq;
	struct qm_mcc_initcgr initcgr;
	struct qm_mcc_fq fq;
	struct qm_mcc_cgr cgr;
};

struct qm_mcr_queryfq {
	u8 verb;
	u8 result;
	u8 __reserved1[8];
	struct qm_fqd fqd;
	u8 __reserved2[30];
} __attribute__((packed));

struct qm_mcr_alterfq {
	u8 verb;
	u8 result;
	u8 fqs;
	u8 __reserved1[61];
};

union qm_mc_result {
	struct {
		u8 verb;
		u8 result;
		u8 __reserved1[62];
	};
	struct qm_mcr_queryfq queryfq;
	struct qm_mcr_alterfq alterfq;
	struct qm_mcr_querycgr querycgr;
	struct qm_mcr_querycongestion querycongestion;
	struct qm_mcr_querywq querywq;
	struct qm_mcr_queryfq_np queryfq_np;
};

struct qe_iram {
	__be32 iadd;
	__be32 idata;
	u8 res0[4];
	__be32 iready;
	u8 res1[112];
};

struct qe_ic_regs {
	__be32 qicr;
	__be32 qivec;
	__be32 qripnr;
	__be32 qipnr;
	__be32 qipxcc;
	__be32 qipycc;
	__be32 qipwcc;
	__be32 qipzcc;
	__be32 qimr;
	__be32 qrimr;
	__be32 qicnr;
	u8 res0[4];
	__be32 qiprta;
	__be32 qiprtb;
	u8 res1[4];
	__be32 qricr;
	u8 res2[32];
	__be32 qhivec;
	u8 res3[28];
};

struct cp_qe {
	__be32 cecr;
	__be32 ceccr;
	__be32 cecdr;
	u8 res0[10];
	__be16 ceter;
	u8 res1[2];
	__be16 cetmr;
	__be32 cetscr;
	__be32 cetsr1;
	__be32 cetsr2;
	u8 res2[8];
	__be32 cevter;
	__be32 cevtmr;
	__be16 cercr;
	u8 res3[2];
	u8 res4[36];
	__be16 ceexe1;
	u8 res5[2];
	__be16 ceexm1;
	u8 res6[2];
	__be16 ceexe2;
	u8 res7[2];
	__be16 ceexm2;
	u8 res8[2];
	__be16 ceexe3;
	u8 res9[2];
	__be16 ceexm3;
	u8 res10[2];
	__be16 ceexe4;
	u8 res11[2];
	__be16 ceexm4;
	u8 res12[58];
	__be32 ceurnr;
	u8 res13[580];
};

struct qe_mux {
	__be32 cmxgcr;
	__be32 cmxsi1cr_l;
	__be32 cmxsi1cr_h;
	__be32 cmxsi1syr;
	__be32 cmxucr[4];
	__be32 cmxupcr;
	u8 res0[28];
};

struct qe_timers {
	u8 gtcfr1;
	u8 res0[3];
	u8 gtcfr2;
	u8 res1[11];
	__be16 gtmdr1;
	__be16 gtmdr2;
	__be16 gtrfr1;
	__be16 gtrfr2;
	__be16 gtcpr1;
	__be16 gtcpr2;
	__be16 gtcnr1;
	__be16 gtcnr2;
	__be16 gtmdr3;
	__be16 gtmdr4;
	__be16 gtrfr3;
	__be16 gtrfr4;
	__be16 gtcpr3;
	__be16 gtcpr4;
	__be16 gtcnr3;
	__be16 gtcnr4;
	__be16 gtevr1;
	__be16 gtevr2;
	__be16 gtevr3;
	__be16 gtevr4;
	__be16 gtps;
	u8 res2[70];
};

struct qe_brg {
	__be32 brgc[16];
	u8 res0[64];
};

struct spi {
	u8 res0[32];
	__be32 spmode;
	u8 res1[2];
	u8 spie;
	u8 res2[1];
	u8 res3[2];
	u8 spim;
	u8 res4[1];
	u8 res5[1];
	u8 spcom;
	u8 res6[2];
	__be32 spitd;
	__be32 spird;
	u8 res7[8];
};

struct si1 {
	__be16 sixmr1[4];
	u8 siglmr1_h;
	u8 res0[1];
	u8 sicmdr1_h;
	u8 res2[1];
	u8 sistr1_h;
	u8 res3[1];
	__be16 sirsr1_h;
	u8 sitarc1;
	u8 sitbrc1;
	u8 sitcrc1;
	u8 sitdrc1;
	u8 sirarc1;
	u8 sirbrc1;
	u8 sircrc1;
	u8 sirdrc1;
	u8 res4[8];
	__be16 siemr1;
	__be16 sifmr1;
	__be16 sigmr1;
	__be16 sihmr1;
	u8 siglmg1_l;
	u8 res5[1];
	u8 sicmdr1_l;
	u8 res6[1];
	u8 sistr1_l;
	u8 res7[1];
	__be16 sirsr1_l;
	u8 siterc1;
	u8 sitfrc1;
	u8 sitgrc1;
	u8 sithrc1;
	u8 sirerc1;
	u8 sirfrc1;
	u8 sirgrc1;
	u8 sirhrc1;
	u8 res8[8];
	__be32 siml1;
	u8 siedm1;
	u8 res9[187];
};

struct sir {
	u8 tx[1024];
	u8 rx[1024];
	u8 res0[2048];
};

struct qe_usb_ctlr {
	u8 usb_usmod;
	u8 usb_usadr;
	u8 usb_uscom;
	u8 res1[1];
	__be16 usb_usep[4];
	u8 res2[4];
	__be16 usb_usber;
	u8 res3[2];
	__be16 usb_usbmr;
	u8 res4[1];
	u8 usb_usbs;
	__be16 usb_ussft;
	u8 res5[2];
	__be16 usb_usfrn;
	u8 res6[34];
};

struct qe_mcc {
	__be32 mcce;
	__be32 mccm;
	__be32 mccf;
	__be32 merl;
	u8 res0[240];
};

struct ucc_slow {
	__be32 gumr_l;
	__be32 gumr_h;
	__be16 upsmr;
	u8 res0[2];
	__be16 utodr;
	__be16 udsr;
	__be16 ucce;
	u8 res1[2];
	__be16 uccm;
	u8 res2[1];
	u8 uccs;
	u8 res3[36];
	__be16 utpt;
	u8 res4[82];
	u8 guemr;
} __attribute__((packed));

struct ucc_fast {
	__be32 gumr;
	__be32 upsmr;
	__be16 utodr;
	u8 res0[2];
	__be16 udsr;
	u8 res1[2];
	__be32 ucce;
	__be32 uccm;
	u8 uccs;
	u8 res2[7];
	__be32 urfb;
	__be16 urfs;
	u8 res3[2];
	__be16 urfet;
	__be16 urfset;
	__be32 utfb;
	__be16 utfs;
	u8 res4[2];
	__be16 utfet;
	u8 res5[2];
	__be16 utftt;
	u8 res6[2];
	__be16 utpt;
	u8 res7[2];
	__be32 urtry;
	u8 res8[76];
	u8 guemr;
} __attribute__((packed));

struct ucc {
	union {
		struct ucc_slow slow;
		struct ucc_fast fast;
		u8 res[512];
	};
};

struct upc {
	__be32 upgcr;
	__be32 uplpa;
	__be32 uphec;
	__be32 upuc;
	__be32 updc1;
	__be32 updc2;
	__be32 updc3;
	__be32 updc4;
	__be32 upstpa;
	u8 res0[12];
	__be32 updrs1_h;
	__be32 updrs1_l;
	__be32 updrs2_h;
	__be32 updrs2_l;
	__be32 updrs3_h;
	__be32 updrs3_l;
	__be32 updrs4_h;
	__be32 updrs4_l;
	__be32 updrp1;
	__be32 updrp2;
	__be32 updrp3;
	__be32 updrp4;
	__be32 upde1;
	__be32 upde2;
	__be32 upde3;
	__be32 upde4;
	__be16 uprp1;
	__be16 uprp2;
	__be16 uprp3;
	__be16 uprp4;
	u8 res1[8];
	__be16 uptirr1_0;
	__be16 uptirr1_1;
	__be16 uptirr1_2;
	__be16 uptirr1_3;
	__be16 uptirr2_0;
	__be16 uptirr2_1;
	__be16 uptirr2_2;
	__be16 uptirr2_3;
	__be16 uptirr3_0;
	__be16 uptirr3_1;
	__be16 uptirr3_2;
	__be16 uptirr3_3;
	__be16 uptirr4_0;
	__be16 uptirr4_1;
	__be16 uptirr4_2;
	__be16 uptirr4_3;
	__be32 uper1;
	__be32 uper2;
	__be32 uper3;
	__be32 uper4;
	u8 res2[336];
};

struct sdma {
	__be32 sdsr;
	__be32 sdmr;
	__be32 sdtr1;
	__be32 sdtr2;
	__be32 sdhy1;
	__be32 sdhy2;
	__be32 sdta1;
	__be32 sdta2;
	__be32 sdtm1;
	__be32 sdtm2;
	u8 res0[16];
	__be32 sdaqr;
	__be32 sdaqmr;
	u8 res1[4];
	__be32 sdebcr;
	u8 res2[56];
};

struct dbg {
	__be32 bpdcr;
	__be32 bpdsr;
	__be32 bpdmr;
	__be32 bprmrr0;
	__be32 bprmrr1;
	u8 res0[8];
	__be32 bprmtr0;
	__be32 bprmtr1;
	u8 res1[8];
	__be32 bprmir;
	__be32 bprmsr;
	__be32 bpemr;
	u8 res2[72];
};

struct rsp {
	__be32 tibcr[16];
	u8 res0[64];
	__be32 ibcr0;
	__be32 ibs0;
	__be32 ibcnr0;
	u8 res1[4];
	__be32 ibcr1;
	__be32 ibs1;
	__be32 ibcnr1;
	__be32 npcr;
	__be32 dbcr;
	__be32 dbar;
	__be32 dbamr;
	__be32 dbsr;
	__be32 dbcnr;
	u8 res2[12];
	__be32 dbdr_h;
	__be32 dbdr_l;
	__be32 dbdmr_h;
	__be32 dbdmr_l;
	__be32 bsr;
	__be32 bor;
	__be32 bior;
	u8 res3[4];
	__be32 iatr[4];
	__be32 eccr;
	__be32 eicr;
	u8 res4[8];
};

struct qe_immap {
	struct qe_iram iram;
	struct qe_ic_regs ic;
	struct cp_qe cp;
	struct qe_mux qmx;
	struct qe_timers qet;
	struct spi spi[2];
	struct qe_mcc mcc;
	struct qe_brg brg;
	struct qe_usb_ctlr usb;
	struct si1 si1;
	u8 res11[2048];
	struct sir sir;
	struct ucc ucc1;
	struct ucc ucc3;
	struct ucc ucc5;
	struct ucc ucc7;
	u8 res12[1536];
	struct upc upc1;
	struct ucc ucc2;
	struct ucc ucc4;
	struct ucc ucc6;
	struct ucc ucc8;
	u8 res13[1536];
	struct upc upc2;
	struct sdma sdma;
	struct dbg dbg;
	struct rsp rsp[2];
	u8 res14[768];
	u8 res15[14848];
	u8 res16[32768];
	u8 muram[49152];
	u8 res17[147456];
	u8 res18[786432];
};

enum qe_clock {
	QE_CLK_NONE = 0,
	QE_BRG1 = 1,
	QE_BRG2 = 2,
	QE_BRG3 = 3,
	QE_BRG4 = 4,
	QE_BRG5 = 5,
	QE_BRG6 = 6,
	QE_BRG7 = 7,
	QE_BRG8 = 8,
	QE_BRG9 = 9,
	QE_BRG10 = 10,
	QE_BRG11 = 11,
	QE_BRG12 = 12,
	QE_BRG13 = 13,
	QE_BRG14 = 14,
	QE_BRG15 = 15,
	QE_BRG16 = 16,
	QE_CLK1 = 17,
	QE_CLK2 = 18,
	QE_CLK3 = 19,
	QE_CLK4 = 20,
	QE_CLK5 = 21,
	QE_CLK6 = 22,
	QE_CLK7 = 23,
	QE_CLK8 = 24,
	QE_CLK9 = 25,
	QE_CLK10 = 26,
	QE_CLK11 = 27,
	QE_CLK12 = 28,
	QE_CLK13 = 29,
	QE_CLK14 = 30,
	QE_CLK15 = 31,
	QE_CLK16 = 32,
	QE_CLK17 = 33,
	QE_CLK18 = 34,
	QE_CLK19 = 35,
	QE_CLK20 = 36,
	QE_CLK21 = 37,
	QE_CLK22 = 38,
	QE_CLK23 = 39,
	QE_CLK24 = 40,
	QE_RSYNC_PIN = 41,
	QE_TSYNC_PIN = 42,
	QE_CLK_DUMMY = 43,
};

struct qe_header {
	__be32 length;
	u8 magic[3];
	u8 version;
};

struct qe_microcode {
	u8 id[32];
	__be32 traps[16];
	__be32 eccr;
	__be32 iram_offset;
	__be32 count;
	__be32 code_offset;
	u8 major;
	u8 minor;
	u8 revision;
	u8 padding;
	u8 reserved[4];
};

struct qe_firmware {
	struct qe_header header;
	u8 id[62];
	u8 split;
	u8 count;
	struct {
		__be16 model;
		u8 major;
		u8 minor;
	} soc;
	u8 padding[4];
	__be64 extended_modes;
	__be32 vtraps[8];
	u8 reserved[4];
	struct qe_microcode microcode[0];
} __attribute__((packed));

struct qe_firmware_info {
	char id[64];
	u32 vtraps[8];
	u64 extended_modes;
};

enum qe_fltr_tbl_lookup_key_size {
	QE_FLTR_TABLE_LOOKUP_KEY_SIZE_8_BYTES = 63,
	QE_FLTR_TABLE_LOOKUP_KEY_SIZE_16_BYTES = 95,
};

struct muram_block {
	struct list_head head;
	s32 start;
	int size;
};

struct qe_ic {
	__be32 *regs;
	struct irq_domain *irqhost;
	struct irq_chip hc_irq;
	int virq_high;
	int virq_low;
};

struct qe_ic_info {
	u32 mask;
	u32 mask_reg;
	u8 pri_code;
	u32 pri_reg;
};

struct qe_pio_regs {
	__be32 cpodr;
	__be32 cpdata;
	__be32 cpdir1;
	__be32 cpdir2;
	__be32 cppar1;
	__be32 cppar2;
};

enum comm_dir {
	COMM_DIR_NONE = 0,
	COMM_DIR_RX = 1,
	COMM_DIR_TX = 2,
	COMM_DIR_RX_AND_TX = 3,
};

enum ucc_speed_type {
	UCC_SPEED_TYPE_FAST = 3,
	UCC_SPEED_TYPE_SLOW = 0,
};

struct qe_bd {
	__be16 status;
	__be16 length;
	__be32 buf;
};

struct ucc_slow_pram {
	__be16 rbase;
	__be16 tbase;
	u8 rbmr;
	u8 tbmr;
	__be16 mrblr;
	__be32 rstate;
	__be32 rptr;
	__be16 rbptr;
	__be16 rcount;
	__be32 rtemp;
	__be32 tstate;
	__be32 tptr;
	__be16 tbptr;
	__be16 tcount;
	__be32 ttemp;
	__be32 rcrc;
	__be32 tcrc;
};

enum ucc_slow_channel_protocol_mode {
	UCC_SLOW_CHANNEL_PROTOCOL_MODE_QMC = 2,
	UCC_SLOW_CHANNEL_PROTOCOL_MODE_UART = 4,
	UCC_SLOW_CHANNEL_PROTOCOL_MODE_BISYNC = 8,
};

enum ucc_slow_transparent_tcrc {
	UCC_SLOW_TRANSPARENT_TCRC_CCITT_CRC16 = 0,
	UCC_SLOW_TRANSPARENT_TCRC_CRC16 = 16384,
	UCC_SLOW_TRANSPARENT_TCRC_CCITT_CRC32 = 32768,
};

enum ucc_slow_tx_oversampling_rate {
	UCC_SLOW_OVERSAMPLING_RATE_TX_TDCR_1 = 0,
	UCC_SLOW_OVERSAMPLING_RATE_TX_TDCR_8 = 65536,
	UCC_SLOW_OVERSAMPLING_RATE_TX_TDCR_16 = 131072,
	UCC_SLOW_OVERSAMPLING_RATE_TX_TDCR_32 = 196608,
};

enum ucc_slow_rx_oversampling_rate {
	UCC_SLOW_OVERSAMPLING_RATE_RX_RDCR_1 = 0,
	UCC_SLOW_OVERSAMPLING_RATE_RX_RDCR_8 = 16384,
	UCC_SLOW_OVERSAMPLING_RATE_RX_RDCR_16 = 32768,
	UCC_SLOW_OVERSAMPLING_RATE_RX_RDCR_32 = 49152,
};

enum ucc_slow_tx_encoding_method {
	UCC_SLOW_TRANSMITTER_ENCODING_METHOD_TENC_NRZ = 0,
	UCC_SLOW_TRANSMITTER_ENCODING_METHOD_TENC_NRZI = 256,
};

enum ucc_slow_rx_decoding_method {
	UCC_SLOW_RECEIVER_DECODING_METHOD_RENC_NRZ = 0,
	UCC_SLOW_RECEIVER_DECODING_METHOD_RENC_NRZI = 2048,
};

enum ucc_slow_diag_mode {
	UCC_SLOW_DIAG_MODE_NORMAL = 0,
	UCC_SLOW_DIAG_MODE_LOOPBACK = 64,
	UCC_SLOW_DIAG_MODE_ECHO = 128,
	UCC_SLOW_DIAG_MODE_LOOPBACK_ECHO = 192,
};

struct ucc_slow_info {
	int ucc_num;
	int protocol;
	enum qe_clock rx_clock;
	enum qe_clock tx_clock;
	phys_addr_t regs;
	int irq;
	u16 uccm_mask;
	int data_mem_part;
	int init_tx;
	int init_rx;
	u32 tx_bd_ring_len;
	u32 rx_bd_ring_len;
	int rx_interrupts;
	int brkpt_support;
	int grant_support;
	int tsa;
	int cdp;
	int cds;
	int ctsp;
	int ctss;
	int rinv;
	int tinv;
	int rtsm;
	int rfw;
	int tci;
	int tend;
	int tfl;
	int txsy;
	u16 max_rx_buf_length;
	enum ucc_slow_transparent_tcrc tcrc;
	enum ucc_slow_channel_protocol_mode mode;
	enum ucc_slow_diag_mode diag;
	enum ucc_slow_tx_oversampling_rate tdcr;
	enum ucc_slow_rx_oversampling_rate rdcr;
	enum ucc_slow_tx_encoding_method tenc;
	enum ucc_slow_rx_decoding_method renc;
};

struct ucc_slow_private {
	struct ucc_slow_info *us_info;
	struct ucc_slow *us_regs;
	struct ucc_slow_pram *us_pram;
	s32 us_pram_offset;
	int enabled_tx;
	int enabled_rx;
	int stopped_tx;
	int stopped_rx;
	struct list_head confQ;
	u32 first_tx_bd_mask;
	s32 tx_base_offset;
	s32 rx_base_offset;
	struct qe_bd *confBd;
	struct qe_bd *tx_bd;
	struct qe_bd *rx_bd;
	void *p_rx_frame;
	__be16 *p_ucce;
	__be16 *p_uccm;
	u16 saved_uccm;
	u32 tx_frames;
	u32 rx_frames;
	u32 rx_discarded;
};

enum ucc_fast_channel_protocol_mode {
	UCC_FAST_PROTOCOL_MODE_HDLC = 0,
	UCC_FAST_PROTOCOL_MODE_RESERVED01 = 1,
	UCC_FAST_PROTOCOL_MODE_RESERVED_QMC = 2,
	UCC_FAST_PROTOCOL_MODE_RESERVED02 = 3,
	UCC_FAST_PROTOCOL_MODE_RESERVED_UART = 4,
	UCC_FAST_PROTOCOL_MODE_RESERVED03 = 5,
	UCC_FAST_PROTOCOL_MODE_RESERVED_EX_MAC_1 = 6,
	UCC_FAST_PROTOCOL_MODE_RESERVED_EX_MAC_2 = 7,
	UCC_FAST_PROTOCOL_MODE_RESERVED_BISYNC = 8,
	UCC_FAST_PROTOCOL_MODE_RESERVED04 = 9,
	UCC_FAST_PROTOCOL_MODE_ATM = 10,
	UCC_FAST_PROTOCOL_MODE_RESERVED05 = 11,
	UCC_FAST_PROTOCOL_MODE_ETHERNET = 12,
	UCC_FAST_PROTOCOL_MODE_RESERVED06 = 13,
	UCC_FAST_PROTOCOL_MODE_POS = 14,
	UCC_FAST_PROTOCOL_MODE_RESERVED07 = 15,
};

enum ucc_fast_transparent_txrx {
	UCC_FAST_GUMR_TRANSPARENT_TTX_TRX_NORMAL = 0,
	UCC_FAST_GUMR_TRANSPARENT_TTX_TRX_TRANSPARENT = 402653184,
};

enum ucc_fast_sync_len {
	UCC_FAST_SYNC_LEN_NOT_USED = 0,
	UCC_FAST_SYNC_LEN_AUTOMATIC = 16384,
	UCC_FAST_SYNC_LEN_8_BIT = 32768,
	UCC_FAST_SYNC_LEN_16_BIT = 49152,
};

enum ucc_fast_rx_decoding_method {
	UCC_FAST_RX_ENCODING_NRZ = 0,
	UCC_FAST_RX_ENCODING_NRZI = 2048,
	UCC_FAST_RX_ENCODING_RESERVED0 = 4096,
	UCC_FAST_RX_ENCODING_RESERVED1 = 6144,
};

enum ucc_fast_tx_encoding_method {
	UCC_FAST_TX_ENCODING_NRZ = 0,
	UCC_FAST_TX_ENCODING_NRZI = 256,
	UCC_FAST_TX_ENCODING_RESERVED0 = 512,
	UCC_FAST_TX_ENCODING_RESERVED1 = 768,
};

enum ucc_fast_transparent_tcrc {
	UCC_FAST_16_BIT_CRC = 0,
	UCC_FAST_CRC_RESERVED0 = 64,
	UCC_FAST_32_BIT_CRC = 128,
	UCC_FAST_CRC_RESERVED1 = 192,
};

struct ucc_fast_info {
	int ucc_num;
	int tdm_num;
	enum qe_clock rx_clock;
	enum qe_clock tx_clock;
	enum qe_clock rx_sync;
	enum qe_clock tx_sync;
	resource_size_t regs;
	int irq;
	u32 uccm_mask;
	int brkpt_support;
	int grant_support;
	int tsa;
	int cdp;
	int cds;
	int ctsp;
	int ctss;
	int tci;
	int txsy;
	int rtsm;
	int revd;
	int rsyn;
	u16 max_rx_buf_length;
	u16 urfs;
	u16 urfet;
	u16 urfset;
	u16 utfs;
	u16 utfet;
	u16 utftt;
	u16 ufpt;
	enum ucc_fast_channel_protocol_mode mode;
	enum ucc_fast_transparent_txrx ttx_trx;
	enum ucc_fast_tx_encoding_method tenc;
	enum ucc_fast_rx_decoding_method renc;
	enum ucc_fast_transparent_tcrc tcrc;
	enum ucc_fast_sync_len synl;
};

struct ucc_fast_private {
	struct ucc_fast_info *uf_info;
	struct ucc_fast *uf_regs;
	__be32 *p_ucce;
	__be32 *p_uccm;
	int enabled_tx;
	int enabled_rx;
	int stopped_tx;
	int stopped_rx;
	s32 ucc_fast_tx_virtual_fifo_base_offset;
	s32 ucc_fast_rx_virtual_fifo_base_offset;
	u32 tx_frames;
	u32 rx_frames;
	u32 tx_discarded;
	u32 rx_discarded;
	u16 mrblr;
};

enum tdm_framer_t {
	TDM_FRAMER_T1 = 0,
	TDM_FRAMER_E1 = 1,
};

enum tdm_mode_t {
	TDM_INTERNAL_LOOPBACK = 0,
	TDM_NORMAL = 1,
};

struct si_mode_info {
	u8 simr_rfsd;
	u8 simr_tfsd;
	u8 simr_crt;
	u8 simr_sl;
	u8 simr_ce;
	u8 simr_fe;
	u8 simr_gm;
};

struct ucc_tdm_info {
	struct ucc_fast_info uf_info;
	struct si_mode_info si_info;
};

struct ucc_tdm {
	u16 tdm_port;
	u32 siram_entry_id;
	u16 *siram;
	struct si1 *si_regs;
	enum tdm_framer_t tdm_framer_type;
	enum tdm_mode_t tdm_mode;
	u8 num_of_ts;
	u32 tx_ts_mask;
	u32 rx_ts_mask;
};

struct rcpm {
	unsigned int wakeup_cells;
	void *ippdexpcr_base;
	bool little_endian;
};

struct guts {
	struct ccsr_guts *regs;
	bool little_endian;
};

struct fsl_soc_die_attr {
	char *die;
	u32 svr;
	u32 mask;
};

struct imx_pgc_domain {
	struct generic_pm_domain genpd;
	struct regmap *regmap;
	struct regulator *regulator;
	struct clk *clk[6];
	int num_clks;
	unsigned int pgc;
	const struct {
		u32 pxx;
		u32 map;
		u32 hsk;
	} bits;
	const int voltage;
	struct device *dev;
};

struct imx_pgc_domain_data {
	const struct imx_pgc_domain *domains;
	size_t domains_num;
	const struct regmap_access_table *reg_access_table;
};

struct imx8_soc_data {
	char *name;
	u32 (*soc_revision)();
};

enum clk_id {
	CLK_NONE = 0,
	CLK_MM = 1,
	CLK_MFG = 2,
	CLK_VENC = 3,
	CLK_VENC_LT = 4,
	CLK_ETHIF = 5,
	CLK_VDEC = 6,
	CLK_HIFSEL = 7,
	CLK_JPGDEC = 8,
	CLK_AUDIO = 9,
	CLK_MAX = 10,
};

struct scp_domain_data {
	const char *name;
	u32 sta_mask;
	int ctl_offs;
	u32 sram_pdn_bits;
	u32 sram_pdn_ack_bits;
	u32 bus_prot_mask;
	enum clk_id clk_id[3];
	u8 caps;
};

struct scp;

struct scp_domain {
	struct generic_pm_domain genpd;
	struct scp *scp;
	struct clk *clk[3];
	const struct scp_domain_data *data;
	struct regulator *supply;
};

struct scp_ctrl_reg {
	int pwr_sta_offs;
	int pwr_sta2nd_offs;
};

struct scp {
	struct scp_domain *domains;
	struct genpd_onecell_data pd_data;
	struct device *dev;
	void *base;
	struct regmap *infracfg;
	struct scp_ctrl_reg ctrl_reg;
	bool bus_prot_reg_update;
};

struct scp_subdomain {
	int origin;
	int subdomain;
};

struct scp_soc_data {
	const struct scp_domain_data *domains;
	int num_domains;
	const struct scp_subdomain *subdomains;
	int num_subdomains;
	const struct scp_ctrl_reg regs;
	bool bus_prot_reg_update;
};

struct scpsys_bus_prot_data {
	u32 bus_prot_mask;
	u32 bus_prot_set;
	u32 bus_prot_clr;
	u32 bus_prot_sta;
	bool bus_prot_reg_update;
	bool ignore_clr_ack;
};

struct scpsys_domain_data {
	const char *name;
	u32 sta_mask;
	int ctl_offs;
	u32 sram_pdn_bits;
	u32 sram_pdn_ack_bits;
	u8 caps;
	const struct scpsys_bus_prot_data bp_infracfg[5];
	const struct scpsys_bus_prot_data bp_smi[5];
};

struct scpsys_soc_data {
	const struct scpsys_domain_data *domains_data;
	int num_domains;
	int pwr_sta_offs;
	int pwr_sta2nd_offs;
};

struct scpsys;

struct scpsys_domain {
	struct generic_pm_domain genpd;
	const struct scpsys_domain_data *data;
	struct scpsys *scpsys;
	int num_clks;
	struct clk_bulk_data *clks;
	int num_subsys_clks;
	struct clk_bulk_data *subsys_clks;
	struct regmap *infracfg;
	struct regmap *smi;
	struct regulator *supply;
};

struct scpsys {
	struct device *dev;
	struct regmap *base;
	const struct scpsys_soc_data *soc_data;
	struct genpd_onecell_data pd_data;
	struct generic_pm_domain *domains[0];
};

enum mtk_ddp_comp_id {
	DDP_COMPONENT_AAL0 = 0,
	DDP_COMPONENT_AAL1 = 1,
	DDP_COMPONENT_BLS = 2,
	DDP_COMPONENT_CCORR = 3,
	DDP_COMPONENT_COLOR0 = 4,
	DDP_COMPONENT_COLOR1 = 5,
	DDP_COMPONENT_DITHER = 6,
	DDP_COMPONENT_DPI0 = 7,
	DDP_COMPONENT_DPI1 = 8,
	DDP_COMPONENT_DSI0 = 9,
	DDP_COMPONENT_DSI1 = 10,
	DDP_COMPONENT_DSI2 = 11,
	DDP_COMPONENT_DSI3 = 12,
	DDP_COMPONENT_GAMMA = 13,
	DDP_COMPONENT_OD0 = 14,
	DDP_COMPONENT_OD1 = 15,
	DDP_COMPONENT_OVL0 = 16,
	DDP_COMPONENT_OVL_2L0 = 17,
	DDP_COMPONENT_OVL_2L1 = 18,
	DDP_COMPONENT_OVL1 = 19,
	DDP_COMPONENT_PWM0 = 20,
	DDP_COMPONENT_PWM1 = 21,
	DDP_COMPONENT_PWM2 = 22,
	DDP_COMPONENT_RDMA0 = 23,
	DDP_COMPONENT_RDMA1 = 24,
	DDP_COMPONENT_RDMA2 = 25,
	DDP_COMPONENT_UFOE = 26,
	DDP_COMPONENT_WDMA0 = 27,
	DDP_COMPONENT_WDMA1 = 28,
	DDP_COMPONENT_ID_MAX = 29,
};

struct mtk_mmsys_routes {
	u32 from_comp;
	u32 to_comp;
	u32 addr;
	u32 mask;
	u32 val;
};

struct mtk_mmsys_driver_data {
	const char *clk_driver;
	const struct mtk_mmsys_routes *routes;
	const unsigned int num_routes;
};

struct mtk_mmsys {
	void *regs;
	const struct mtk_mmsys_driver_data *data;
};

struct mtk_mutex {
	int id;
	bool claimed;
};

enum mtk_mutex_sof_id {
	MUTEX_SOF_SINGLE_MODE = 0,
	MUTEX_SOF_DSI0 = 1,
	MUTEX_SOF_DSI1 = 2,
	MUTEX_SOF_DPI0 = 3,
	MUTEX_SOF_DPI1 = 4,
	MUTEX_SOF_DSI2 = 5,
	MUTEX_SOF_DSI3 = 6,
};

struct mtk_mutex_data {
	const unsigned int *mutex_mod;
	const unsigned int *mutex_sof;
	const unsigned int mutex_mod_reg;
	const unsigned int mutex_sof_reg;
	const bool no_clk;
};

struct mtk_mutex_ctx {
	struct device *dev;
	struct clk *clk;
	void *regs;
	struct mtk_mutex mutex[10];
	const struct mtk_mutex_data *data;
};

struct meson_msr;

struct meson_msr_id {
	struct meson_msr *priv;
	unsigned int id;
	const char *name;
};

struct meson_msr {
	struct regmap *regmap;
	struct meson_msr_id msr_table[128];
};

struct meson_gx_soc_id {
	const char *name;
	unsigned int id;
};

struct meson_gx_package_id {
	const char *name;
	unsigned int major_id;
	unsigned int pack_id;
	unsigned int pack_mask;
};

struct meson_gx_pwrc_vpu {
	struct generic_pm_domain genpd;
	struct regmap *regmap_ao;
	struct regmap *regmap_hhi;
	struct reset_control *rstc;
	struct clk *vpu_clk;
	struct clk *vapb_clk;
};

struct meson_ee_pwrc_mem_domain {
	unsigned int reg;
	unsigned int mask;
};

struct meson_ee_pwrc_top_domain {
	unsigned int sleep_reg;
	unsigned int sleep_mask;
	unsigned int iso_reg;
	unsigned int iso_mask;
};

struct meson_ee_pwrc_domain;

struct meson_ee_pwrc_domain_desc {
	char *name;
	unsigned int reset_names_count;
	unsigned int clk_names_count;
	struct meson_ee_pwrc_top_domain *top_pd;
	unsigned int mem_pd_count;
	struct meson_ee_pwrc_mem_domain *mem_pd;
	bool (*get_power)(struct meson_ee_pwrc_domain *);
};

struct meson_ee_pwrc;

struct meson_ee_pwrc_domain {
	struct generic_pm_domain base;
	bool enabled;
	struct meson_ee_pwrc *pwrc;
	struct meson_ee_pwrc_domain_desc desc;
	struct clk_bulk_data *clks;
	int num_clks;
	struct reset_control *rstc;
	int num_rstc;
};

struct meson_ee_pwrc_domain_data {
	unsigned int count;
	struct meson_ee_pwrc_domain_desc *domains;
};

struct meson_ee_pwrc {
	struct regmap *regmap_ao;
	struct regmap *regmap_hhi;
	struct meson_ee_pwrc_domain *domains;
	struct genpd_onecell_data xlate;
};

enum {
	SM_EFUSE_READ = 0,
	SM_EFUSE_WRITE = 1,
	SM_EFUSE_USER_MAX = 2,
	SM_GET_CHIP_ID = 3,
	SM_A1_PWRC_SET = 4,
	SM_A1_PWRC_GET = 5,
};

struct meson_secure_pwrc;

struct meson_secure_pwrc_domain {
	struct generic_pm_domain base;
	unsigned int index;
	struct meson_secure_pwrc *pwrc;
};

struct meson_sm_firmware;

struct meson_secure_pwrc {
	struct meson_secure_pwrc_domain *domains;
	struct genpd_onecell_data xlate;
	struct meson_sm_firmware *fw;
};

struct meson_secure_pwrc_domain_desc {
	unsigned int index;
	unsigned int flags;
	char *name;
	bool (*is_off)(struct meson_secure_pwrc_domain *);
};

struct meson_secure_pwrc_domain_data {
	unsigned int count;
	struct meson_secure_pwrc_domain_desc *domains;
};

enum cmd_db_hw_type {
	CMD_DB_HW_INVALID = 0,
	CMD_DB_HW_MIN = 3,
	CMD_DB_HW_ARC = 3,
	CMD_DB_HW_VRM = 4,
	CMD_DB_HW_BCM = 5,
	CMD_DB_HW_MAX = 5,
	CMD_DB_HW_ALL = 255,
};

struct entry_header {
	u8 id[8];
	__le32 priority[2];
	__le32 addr;
	__le16 len;
	__le16 offset;
};

struct rsc_hdr {
	__le16 slv_id;
	__le16 header_offset;
	__le16 data_offset;
	__le16 cnt;
	__le16 version;
	__le16 reserved[3];
};

struct cmd_db_header {
	__le32 version;
	u8 magic[4];
	struct rsc_hdr header[8];
	__le32 checksum;
	__le32 reserved;
	u8 data[0];
};

enum rpmh_state {
	RPMH_SLEEP_STATE = 0,
	RPMH_WAKE_ONLY_STATE = 1,
	RPMH_ACTIVE_ONLY_STATE = 2,
};

struct tcs_cmd {
	u32 addr;
	u32 data;
	u32 wait;
};

struct tcs_request {
	enum rpmh_state state;
	u32 wait_for_compl;
	u32 num_cmds;
	struct tcs_cmd *cmds;
};

struct rsc_drv;

struct tcs_group {
	struct rsc_drv *drv;
	int type;
	u32 mask;
	u32 offset;
	int num_tcs;
	int ncpt;
	const struct tcs_request *req[3];
	long unsigned int slots[1];
};

struct rpmh_ctrlr {
	struct list_head cache;
	spinlock_t cache_lock;
	bool dirty;
	struct list_head batch_cache;
};

struct rsc_drv {
	const char *name;
	void *tcs_base;
	int id;
	int num_tcs;
	struct notifier_block rsc_pm;
	atomic_t cpus_in_pm;
	struct tcs_group tcs[4];
	long unsigned int tcs_in_use[1];
	spinlock_t lock;
	wait_queue_head_t tcs_wait;
	struct rpmh_ctrlr client;
};

struct trace_event_raw_rpmh_tx_done {
	struct trace_entry ent;
	u32 __data_loc_name;
	int m;
	u32 addr;
	u32 data;
	int err;
	char __data[0];
};

struct trace_event_raw_rpmh_send_msg {
	struct trace_entry ent;
	u32 __data_loc_name;
	int m;
	int n;
	u32 hdr;
	u32 addr;
	u32 data;
	bool wait;
	char __data[0];
};

struct trace_event_data_offsets_rpmh_tx_done {
	u32 name;
};

struct trace_event_data_offsets_rpmh_send_msg {
	u32 name;
};

typedef void (*btf_trace_rpmh_tx_done)(void *, struct rsc_drv *, int, const struct tcs_request *, int);

typedef void (*btf_trace_rpmh_send_msg)(void *, struct rsc_drv *, int, int, u32, const struct tcs_cmd *);

struct tcs_type_config {
	u32 type;
	u32 n;
};

struct rpmh_request {
	struct tcs_request msg;
	struct tcs_cmd cmd[16];
	struct completion *completion;
	const struct device *dev;
	int err;
	bool needs_free;
};

struct cache_req {
	u32 addr;
	u32 sleep_val;
	u32 wake_val;
	struct list_head list;
};

struct batch_cache_req {
	struct list_head list;
	int count;
	struct rpmh_request rpm_msgs[0];
};

struct qcom_smem_state_ops {
	int (*update_bits)(void *, u32, u32);
};

struct qcom_smem_state {
	struct kref refcount;
	bool orphan;
	struct list_head list;
	struct device_node *of_node;
	void *priv;
	struct qcom_smem_state_ops ops;
};

struct rpmhpd {
	struct device *dev;
	struct generic_pm_domain pd;
	struct generic_pm_domain *parent;
	struct rpmhpd *peer;
	const bool active_only;
	unsigned int corner;
	unsigned int active_corner;
	unsigned int enable_corner;
	u32 level[16];
	size_t level_count;
	bool enabled;
	const char *res_name;
	u32 addr;
};

struct rpmhpd_desc {
	struct rpmhpd **rpmhpds;
	size_t num_pds;
};

struct renesas_family {
	const char name[16];
	u32 reg;
};

struct renesas_soc {
	const struct renesas_family *family;
	u8 id;
};

struct rcar_sysc_area {
	const char *name;
	u16 chan_offs;
	u8 chan_bit;
	u8 isr_bit;
	int parent;
	unsigned int flags;
};

struct rcar_sysc_info {
	int (*init)();
	const struct rcar_sysc_area *areas;
	unsigned int num_areas;
	u32 extmask_offs;
	u32 extmask_val;
};

struct r8a779a0_sysc_area {
	const char *name;
	u8 pdr;
	int parent;
	unsigned int flags;
};

struct r8a779a0_sysc_info {
	const struct r8a779a0_sysc_area *areas;
	unsigned int num_areas;
};

struct r8a779a0_sysc_pd {
	struct generic_pm_domain genpd;
	u8 pdr;
	unsigned int flags;
	char name[0];
};

struct r8a779a0_pm_domains {
	struct genpd_onecell_data onecell_data;
	struct generic_pm_domain *domains[65];
};

struct rst_config {
	unsigned int modemr;
	int (*configure)(void *);
};

struct rcar_sysc_ch {
	u16 chan_offs;
	u8 chan_bit;
	u8 isr_bit;
};

struct rcar_sysc_pd {
	struct generic_pm_domain genpd;
	struct rcar_sysc_ch ch;
	unsigned int flags;
	char name[0];
};

struct rcar_pm_domains {
	struct genpd_onecell_data onecell_data;
	struct generic_pm_domain *domains[33];
};

struct rockchip_grf_value {
	const char *desc;
	u32 reg;
	u32 val;
};

struct rockchip_grf_info {
	const struct rockchip_grf_value *values;
	int num_values;
};

struct rockchip_domain_info {
	int pwr_mask;
	int status_mask;
	int req_mask;
	int idle_mask;
	int ack_mask;
	bool active_wakeup;
	int pwr_w_mask;
	int req_w_mask;
};

struct rockchip_pmu_info {
	u32 pwr_offset;
	u32 status_offset;
	u32 req_offset;
	u32 idle_offset;
	u32 ack_offset;
	u32 core_pwrcnt_offset;
	u32 gpu_pwrcnt_offset;
	unsigned int core_power_transition_time;
	unsigned int gpu_power_transition_time;
	int num_domains;
	const struct rockchip_domain_info *domain_info;
};

struct rockchip_pmu;

struct rockchip_pm_domain {
	struct generic_pm_domain genpd;
	const struct rockchip_domain_info *info;
	struct rockchip_pmu *pmu;
	int num_qos;
	struct regmap **qos_regmap;
	u32 *qos_save_regs[5];
	int num_clks;
	struct clk_bulk_data *clks;
};

struct rockchip_pmu {
	struct device *dev;
	struct regmap *regmap;
	const struct rockchip_pmu_info *info;
	struct mutex mutex;
	struct genpd_onecell_data genpd_data;
	struct generic_pm_domain *domains[0];
};

struct sunxi_sram_func {
	char *func;
	u8 val;
	u32 reg_val;
};

struct sunxi_sram_data {
	char *name;
	u8 reg;
	u8 offset;
	u8 width;
	struct sunxi_sram_func *func;
	struct list_head list;
};

struct sunxi_sram_desc {
	struct sunxi_sram_data data;
	bool claimed;
};

struct sunxi_sramc_variant {
	int num_emac_clocks;
};

struct k3_ring_rt_regs {
	u32 resv_16[4];
	u32 db;
	u32 resv_4[1];
	u32 occ;
	u32 indx;
	u32 hwocc;
	u32 hwindx;
};

struct k3_ring_fifo_regs {
	u32 head_data[128];
	u32 tail_data[128];
	u32 peek_head_data[128];
	u32 peek_tail_data[128];
};

struct k3_ringacc_proxy_gcfg_regs {
	u32 revision;
	u32 config;
};

struct k3_ringacc_proxy_target_regs {
	u32 control;
	u32 status;
	u8 resv_512[504];
	u32 data[128];
};

enum k3_ringacc_proxy_access_mode {
	PROXY_ACCESS_MODE_HEAD = 0,
	PROXY_ACCESS_MODE_TAIL = 1,
	PROXY_ACCESS_MODE_PEEK_HEAD = 2,
	PROXY_ACCESS_MODE_PEEK_TAIL = 3,
};

struct k3_ring___2;

struct k3_ring_ops {
	int (*push_tail)(struct k3_ring___2 *, void *);
	int (*push_head)(struct k3_ring___2 *, void *);
	int (*pop_tail)(struct k3_ring___2 *, void *);
	int (*pop_head)(struct k3_ring___2 *, void *);
};

struct k3_ring_state {
	u32 free;
	u32 occ;
	u32 windex;
	u32 rindex;
	u32 tdown_complete: 1;
};

struct k3_ringacc___2;

struct k3_ring___2 {
	struct k3_ring_rt_regs *rt;
	struct k3_ring_fifo_regs *fifos;
	struct k3_ringacc_proxy_target_regs *proxy;
	dma_addr_t ring_mem_dma;
	void *ring_mem_virt;
	struct k3_ring_ops *ops;
	u32 size;
	enum k3_ring_size elm_size;
	enum k3_ring_mode mode;
	u32 flags;
	struct k3_ring_state state;
	u32 ring_id;
	struct k3_ringacc___2 *parent;
	u32 use_count;
	int proxy_id;
	struct device *dma_dev;
	u32 asel;
};

struct k3_ringacc_ops;

struct k3_ringacc___2 {
	struct device *dev;
	struct k3_ringacc_proxy_gcfg_regs *proxy_gcfg;
	void *proxy_target_base;
	u32 num_rings;
	long unsigned int *rings_inuse;
	struct ti_sci_resource *rm_gp_range;
	bool dma_ring_reset_quirk;
	u32 num_proxies;
	long unsigned int *proxy_inuse;
	struct k3_ring___2 *rings;
	struct list_head list;
	struct mutex req_lock;
	const struct ti_sci_handle *tisci;
	const struct ti_sci_rm_ringacc_ops *tisci_ring_ops;
	u32 tisci_dev_id;
	const struct k3_ringacc_ops *ops;
	bool dma_rings;
};

struct k3_ringacc_ops {
	int (*init)(struct platform_device *, struct k3_ringacc___2 *);
};

struct k3_ringacc_soc_data {
	unsigned int dma_ring_reset_quirk: 1;
};

enum k3_ringacc_access_mode {
	K3_RINGACC_ACCESS_MODE_PUSH_HEAD = 0,
	K3_RINGACC_ACCESS_MODE_POP_HEAD = 1,
	K3_RINGACC_ACCESS_MODE_PUSH_TAIL = 2,
	K3_RINGACC_ACCESS_MODE_POP_TAIL = 3,
	K3_RINGACC_ACCESS_MODE_PEEK_HEAD = 4,
	K3_RINGACC_ACCESS_MODE_PEEK_TAIL = 5,
};

struct ringacc_match_data {
	struct k3_ringacc_ops ops;
};

struct k3_soc_id {
	unsigned int id;
	const char *family_name;
};

enum zynqmp_pm_suspend_reason {
	SUSPEND_POWER_REQUEST = 201,
	SUSPEND_ALERT = 202,
	SUSPEND_SYSTEM_SHUTDOWN = 203,
};

struct zynqmp_ipi_message {
	size_t len;
	u8 data[0];
};

struct zynqmp_pm_work_struct {
	struct work_struct callback_work;
	u32 args[4];
};

enum pm_suspend_mode {
	PM_SUSPEND_MODE_FIRST = 0,
	PM_SUSPEND_MODE_STD = 0,
	PM_SUSPEND_MODE_POWER_OFF = 1,
};

enum pm_api_cb_id {
	PM_INIT_SUSPEND_CB = 30,
	PM_ACKNOWLEDGE_CB = 31,
	PM_NOTIFY_CB = 32,
};

enum zynqmp_pm_request_ack {
	ZYNQMP_PM_REQUEST_ACK_NO = 1,
	ZYNQMP_PM_REQUEST_ACK_BLOCKING = 2,
	ZYNQMP_PM_REQUEST_ACK_NON_BLOCKING = 3,
};

struct zynqmp_pm_domain {
	struct generic_pm_domain gpd;
	u32 node_id;
	u8 flags;
};

struct virtio_driver {
	struct device_driver driver;
	const struct virtio_device_id *id_table;
	const unsigned int *feature_table;
	unsigned int feature_table_size;
	const unsigned int *feature_table_legacy;
	unsigned int feature_table_size_legacy;
	int (*validate)(struct virtio_device *);
	int (*probe)(struct virtio_device *);
	void (*scan)(struct virtio_device *);
	void (*remove)(struct virtio_device *);
	void (*config_changed)(struct virtio_device *);
	int (*freeze)(struct virtio_device *);
	int (*restore)(struct virtio_device *);
};

typedef __u16 __virtio16;

typedef __u32 __virtio32;

typedef __u64 __virtio64;

struct vring_desc {
	__virtio64 addr;
	__virtio32 len;
	__virtio16 flags;
	__virtio16 next;
};

struct vring_avail {
	__virtio16 flags;
	__virtio16 idx;
	__virtio16 ring[0];
};

struct vring_used_elem {
	__virtio32 id;
	__virtio32 len;
};

typedef struct vring_used_elem vring_used_elem_t;

struct vring_used {
	__virtio16 flags;
	__virtio16 idx;
	vring_used_elem_t ring[0];
};

typedef struct vring_desc vring_desc_t;

typedef struct vring_avail vring_avail_t;

typedef struct vring_used vring_used_t;

struct vring {
	unsigned int num;
	vring_desc_t *desc;
	vring_avail_t *avail;
	vring_used_t *used;
};

struct vring_packed_desc_event {
	__le16 off_wrap;
	__le16 flags;
};

struct vring_packed_desc {
	__le64 addr;
	__le32 len;
	__le16 id;
	__le16 flags;
};

struct vring_desc_state_split {
	void *data;
	struct vring_desc *indir_desc;
};

struct vring_desc_state_packed {
	void *data;
	struct vring_packed_desc *indir_desc;
	u16 num;
	u16 next;
	u16 last;
};

struct vring_desc_extra_packed {
	dma_addr_t addr;
	u32 len;
	u16 flags;
};

struct vring_virtqueue {
	struct virtqueue vq;
	bool packed_ring;
	bool use_dma_api;
	bool weak_barriers;
	bool broken;
	bool indirect;
	bool event;
	unsigned int free_head;
	unsigned int num_added;
	u16 last_used_idx;
	union {
		struct {
			struct vring vring;
			u16 avail_flags_shadow;
			u16 avail_idx_shadow;
			struct vring_desc_state_split *desc_state;
			dma_addr_t queue_dma_addr;
			size_t queue_size_in_bytes;
		} split;
		struct {
			struct {
				unsigned int num;
				struct vring_packed_desc *desc;
				struct vring_packed_desc_event *driver;
				struct vring_packed_desc_event *device;
			} vring;
			bool avail_wrap_counter;
			bool used_wrap_counter;
			u16 avail_used_flags;
			u16 next_avail_idx;
			u16 event_flags_shadow;
			struct vring_desc_state_packed *desc_state;
			struct vring_desc_extra_packed *desc_extra;
			dma_addr_t ring_dma_addr;
			dma_addr_t driver_event_dma_addr;
			dma_addr_t device_event_dma_addr;
			size_t ring_size_in_bytes;
			size_t event_size_in_bytes;
		} packed;
	};
	bool (*notify)(struct virtqueue *);
	bool we_own_ring;
};

struct virtio_pci_common_cfg {
	__le32 device_feature_select;
	__le32 device_feature;
	__le32 guest_feature_select;
	__le32 guest_feature;
	__le16 msix_config;
	__le16 num_queues;
	__u8 device_status;
	__u8 config_generation;
	__le16 queue_select;
	__le16 queue_size;
	__le16 queue_msix_vector;
	__le16 queue_enable;
	__le16 queue_notify_off;
	__le32 queue_desc_lo;
	__le32 queue_desc_hi;
	__le32 queue_avail_lo;
	__le32 queue_avail_hi;
	__le32 queue_used_lo;
	__le32 queue_used_hi;
};

struct virtio_pci_modern_device {
	struct pci_dev *pci_dev;
	struct virtio_pci_common_cfg *common;
	void *device;
	void *notify_base;
	resource_size_t notify_pa;
	u8 *isr;
	size_t notify_len;
	size_t device_len;
	int notify_map_cap;
	u32 notify_offset_multiplier;
	int modern_bars;
	struct virtio_device_id id;
};

struct virtio_mmio_device {
	struct virtio_device vdev;
	struct platform_device *pdev;
	void *base;
	long unsigned int version;
	spinlock_t lock;
	struct list_head virtqueues;
};

struct virtio_mmio_vq_info {
	struct virtqueue *vq;
	struct list_head node;
};

struct virtio_pci_vq_info {
	struct virtqueue *vq;
	struct list_head node;
	unsigned int msix_vector;
};

struct virtio_pci_device {
	struct virtio_device vdev;
	struct pci_dev *pci_dev;
	struct virtio_pci_modern_device mdev;
	u8 *isr;
	void *ioaddr;
	spinlock_t lock;
	struct list_head virtqueues;
	struct virtio_pci_vq_info **vqs;
	int msix_enabled;
	int intx_enabled;
	cpumask_var_t *msix_affinity_masks;
	char (*msix_names)[256];
	unsigned int msix_vectors;
	unsigned int msix_used_vectors;
	bool per_vq_vectors;
	struct virtqueue * (*setup_vq)(struct virtio_pci_device *, struct virtio_pci_vq_info *, unsigned int, void (*)(struct virtqueue *), const char *, bool, u16);
	void (*del_vq)(struct virtio_pci_vq_info *);
	u16 (*config_vector)(struct virtio_pci_device *, u16);
};

enum {
	VP_MSIX_CONFIG_VECTOR = 0,
	VP_MSIX_VQ_VECTOR = 1,
};

struct virtio_balloon_config {
	__le32 num_pages;
	__le32 actual;
	union {
		__le32 free_page_hint_cmd_id;
		__le32 free_page_report_cmd_id;
	};
	__le32 poison_val;
};

struct virtio_balloon_stat {
	__virtio16 tag;
	__virtio64 val;
} __attribute__((packed));

enum virtio_balloon_vq {
	VIRTIO_BALLOON_VQ_INFLATE = 0,
	VIRTIO_BALLOON_VQ_DEFLATE = 1,
	VIRTIO_BALLOON_VQ_STATS = 2,
	VIRTIO_BALLOON_VQ_FREE_PAGE = 3,
	VIRTIO_BALLOON_VQ_REPORTING = 4,
	VIRTIO_BALLOON_VQ_MAX = 5,
};

enum virtio_balloon_config_read {
	VIRTIO_BALLOON_CONFIG_READ_CMD_ID = 0,
};

struct virtio_balloon {
	struct virtio_device *vdev;
	struct virtqueue *inflate_vq;
	struct virtqueue *deflate_vq;
	struct virtqueue *stats_vq;
	struct virtqueue *free_page_vq;
	struct workqueue_struct *balloon_wq;
	struct work_struct report_free_page_work;
	struct work_struct update_balloon_stats_work;
	struct work_struct update_balloon_size_work;
	spinlock_t stop_update_lock;
	bool stop_update;
	int: 24;
	long unsigned int config_read_bitmap;
	struct list_head free_page_list;
	spinlock_t free_page_list_lock;
	int: 32;
	long unsigned int num_free_page_blocks;
	u32 cmd_id_received_cache;
	__virtio32 cmd_id_active;
	__virtio32 cmd_id_stop;
	int: 32;
	wait_queue_head_t acked;
	unsigned int num_pages;
	int: 32;
	struct balloon_dev_info vb_dev_info;
	struct mutex balloon_lock;
	unsigned int num_pfns;
	__virtio32 pfns[256];
	struct virtio_balloon_stat stats[10];
	struct shrinker shrinker;
	struct notifier_block oom_nb;
	struct virtqueue *reporting_vq;
	struct page_reporting_dev_info pr_dev_info;
} __attribute__((packed));

struct xenbus_watch {
	struct list_head list;
	const char *node;
	unsigned int nr_pending;
	bool (*will_handle)(struct xenbus_watch *, const char *, const char *);
	void (*callback)(struct xenbus_watch *, const char *, const char *);
};

struct xenbus_transaction {
	u32 id;
};

typedef struct {
	union {
		xen_pfn_t *p;
		uint64_t q;
	};
} __guest_handle_xen_pfn_t;

struct grant_entry_v1 {
	uint16_t flags;
	domid_t domid;
	uint32_t frame;
};

struct grant_entry_header {
	uint16_t flags;
	domid_t domid;
};

union grant_entry_v2 {
	struct grant_entry_header hdr;
	struct {
		struct grant_entry_header hdr;
		uint32_t pad0;
		uint64_t frame;
	} full_page;
	struct {
		struct grant_entry_header hdr;
		uint16_t page_off;
		uint16_t length;
		uint64_t frame;
	} sub_page;
	struct {
		struct grant_entry_header hdr;
		domid_t trans_domid;
		uint16_t pad0;
		grant_ref_t gref;
	} transitive;
	uint32_t __spacer[4];
};

struct gnttab_setup_table {
	domid_t dom;
	uint32_t nr_frames;
	int16_t status;
	__guest_handle_xen_pfn_t frame_list;
};

struct gnttab_copy {
	struct {
		union {
			grant_ref_t ref;
			xen_pfn_t gmfn;
		} u;
		domid_t domid;
		uint16_t offset;
	} source;
	struct {
		union {
			grant_ref_t ref;
			xen_pfn_t gmfn;
		} u;
		domid_t domid;
		uint16_t offset;
	} dest;
	uint16_t len;
	uint16_t flags;
	int16_t status;
};

struct gnttab_query_size {
	domid_t dom;
	uint32_t nr_frames;
	uint32_t max_nr_frames;
	int16_t status;
};

struct gnttab_set_version {
	uint32_t version;
};

struct gnttab_get_status_frames {
	uint32_t nr_frames;
	domid_t dom;
	int16_t status;
	__guest_handle_uint64_t frame_list;
};

struct gnttab_free_callback {
	struct gnttab_free_callback *next;
	void (*fn)(void *);
	void *arg;
	u16 count;
};

struct gntab_unmap_queue_data;

typedef void (*gnttab_unmap_refs_done)(int, struct gntab_unmap_queue_data *);

struct gntab_unmap_queue_data {
	struct delayed_work gnttab_work;
	void *data;
	gnttab_unmap_refs_done done;
	struct gnttab_unmap_grant_ref *unmap_ops;
	struct gnttab_unmap_grant_ref *kunmap_ops;
	struct page **pages;
	unsigned int count;
	unsigned int age;
};

struct gnttab_page_cache {
	spinlock_t lock;
	struct list_head pages;
	unsigned int num_pages;
};

struct gnttab_dma_alloc_args {
	struct device *dev;
	bool coherent;
	int nr_pages;
	struct page **pages;
	xen_pfn_t *frames;
	void *vaddr;
	dma_addr_t dev_bus_addr;
};

struct xen_page_foreign {
	domid_t domid;
	grant_ref_t gref;
};

typedef void (*xen_grant_fn_t)(long unsigned int, unsigned int, unsigned int, void *);

struct gnttab_ops {
	unsigned int version;
	unsigned int grefs_per_grant_frame;
	int (*map_frames)(xen_pfn_t *, unsigned int);
	void (*unmap_frames)();
	void (*update_entry)(grant_ref_t, domid_t, long unsigned int, unsigned int);
	int (*end_foreign_access_ref)(grant_ref_t, int);
	long unsigned int (*end_foreign_transfer_ref)(grant_ref_t);
	int (*query_foreign_access)(grant_ref_t);
};

struct unmap_refs_callback_data {
	struct completion completion;
	int result;
};

struct deferred_entry {
	struct list_head list;
	grant_ref_t ref;
	bool ro;
	uint16_t warn_delay;
	struct page *page;
};

struct xen_feature_info {
	unsigned int submap_idx;
	uint32_t submap;
};

enum bp_state {
	BP_DONE = 0,
	BP_WAIT = 1,
	BP_EAGAIN = 2,
	BP_ECANCELED = 3,
};

enum shutdown_state {
	SHUTDOWN_INVALID = 4294967295,
	SHUTDOWN_POWEROFF = 0,
	SHUTDOWN_SUSPEND = 2,
	SHUTDOWN_HALT = 4,
};

enum suspend_modes {
	NO_SUSPEND = 0,
	XEN_SUSPEND = 1,
	PM_SUSPEND = 2,
	PM_HIBERNATION = 3,
};

struct shutdown_handler {
	const char command[11];
	bool flag;
	void (*cb)();
};

struct vcpu_runstate_info {
	int state;
	uint64_t state_entry_time;
	uint64_t time[4];
};

typedef struct {
	union {
		struct vcpu_runstate_info *p;
		uint64_t q;
	};
} __guest_handle_vcpu_runstate_info;

struct vcpu_register_runstate_memory_area {
	union {
		__guest_handle_vcpu_runstate_info h;
		struct vcpu_runstate_info *v;
		uint64_t p;
	} addr;
};

struct xen_memory_reservation {
	__guest_handle_xen_pfn_t extent_start;
	xen_ulong_t nr_extents;
	unsigned int extent_order;
	unsigned int address_bits;
	domid_t domid;
};

typedef uint32_t evtchn_port_t;

typedef struct {
	union {
		evtchn_port_t *p;
		uint64_t q;
	};
} __guest_handle_evtchn_port_t;

struct evtchn_bind_interdomain {
	domid_t remote_dom;
	evtchn_port_t remote_port;
	evtchn_port_t local_port;
};

struct evtchn_bind_virq {
	uint32_t virq;
	uint32_t vcpu;
	evtchn_port_t port;
};

struct evtchn_bind_pirq {
	uint32_t pirq;
	uint32_t flags;
	evtchn_port_t port;
};

struct evtchn_bind_ipi {
	uint32_t vcpu;
	evtchn_port_t port;
};

struct evtchn_close {
	evtchn_port_t port;
};

struct evtchn_send {
	evtchn_port_t port;
};

struct evtchn_status {
	domid_t dom;
	evtchn_port_t port;
	uint32_t status;
	uint32_t vcpu;
	union {
		struct {
			domid_t dom;
		} unbound;
		struct {
			domid_t dom;
			evtchn_port_t port;
		} interdomain;
		uint32_t pirq;
		uint32_t virq;
	} u;
};

struct evtchn_bind_vcpu {
	evtchn_port_t port;
	uint32_t vcpu;
};

struct evtchn_set_priority {
	evtchn_port_t port;
	uint32_t priority;
};

struct sched_poll {
	__guest_handle_evtchn_port_t ports;
	unsigned int nr_ports;
	uint64_t timeout;
};

enum ipi_vector {
	XEN_PLACEHOLDER_VECTOR = 0,
	XEN_NR_IPIS = 1,
};

struct physdev_eoi {
	uint32_t irq;
};

struct physdev_irq_status_query {
	uint32_t irq;
	uint32_t flags;
};

struct physdev_irq {
	uint32_t irq;
	uint32_t vector;
};

struct physdev_map_pirq {
	domid_t domid;
	int type;
	int index;
	int pirq;
	int bus;
	int devfn;
	int entry_nr;
	uint64_t table_base;
};

struct physdev_unmap_pirq {
	domid_t domid;
	int pirq;
};

struct physdev_get_free_pirq {
	int type;
	uint32_t pirq;
};

enum xenbus_state {
	XenbusStateUnknown = 0,
	XenbusStateInitialising = 1,
	XenbusStateInitWait = 2,
	XenbusStateInitialised = 3,
	XenbusStateConnected = 4,
	XenbusStateClosing = 5,
	XenbusStateClosed = 6,
	XenbusStateReconfiguring = 7,
	XenbusStateReconfigured = 8,
};

struct xenbus_device {
	const char *devicetype;
	const char *nodename;
	const char *otherend;
	int otherend_id;
	struct xenbus_watch otherend_watch;
	struct device dev;
	enum xenbus_state state;
	struct completion down;
	struct work_struct work;
	struct semaphore reclaim_sem;
	atomic_t event_channels;
	atomic_t events;
	atomic_t spurious_events;
	atomic_t jiffies_eoi_delayed;
	unsigned int spurious_threshold;
};

struct evtchn_loop_ctrl;

struct evtchn_ops {
	unsigned int (*max_channels)();
	unsigned int (*nr_channels)();
	int (*setup)(evtchn_port_t);
	void (*remove)(evtchn_port_t, unsigned int);
	void (*bind_to_cpu)(evtchn_port_t, unsigned int, unsigned int);
	void (*clear_pending)(evtchn_port_t);
	void (*set_pending)(evtchn_port_t);
	bool (*is_pending)(evtchn_port_t);
	void (*mask)(evtchn_port_t);
	void (*unmask)(evtchn_port_t);
	void (*handle_events)(unsigned int, struct evtchn_loop_ctrl *);
	void (*resume)();
	int (*percpu_init)(unsigned int);
	int (*percpu_deinit)(unsigned int);
};

struct evtchn_loop_ctrl {
	ktime_t timeout;
	unsigned int count;
	bool defer_eoi;
};

enum xen_irq_type {
	IRQT_UNBOUND = 0,
	IRQT_PIRQ = 1,
	IRQT_VIRQ = 2,
	IRQT_IPI = 3,
	IRQT_EVTCHN = 4,
};

struct irq_info {
	struct list_head list;
	struct list_head eoi_list;
	short int refcnt;
	u8 spurious_cnt;
	u8 is_accounted;
	short int type;
	u8 mask_reason;
	u8 is_active;
	unsigned int irq;
	evtchn_port_t evtchn;
	short unsigned int cpu;
	short unsigned int eoi_cpu;
	unsigned int irq_epoch;
	u64 eoi_time;
	raw_spinlock_t lock;
	union {
		short unsigned int virq;
		enum ipi_vector ipi;
		struct {
			short unsigned int pirq;
			short unsigned int gsi;
			unsigned char vector;
			unsigned char flags;
			uint16_t domid;
		} pirq;
		struct xenbus_device *interdomain;
	} u;
};

struct lateeoi_work {
	struct delayed_work delayed;
	spinlock_t eoi_list_lock;
	struct list_head eoi_list;
};

struct evtchn_unmask {
	evtchn_port_t port;
};

struct evtchn_init_control {
	uint64_t control_gfn;
	uint32_t offset;
	uint32_t vcpu;
	uint8_t link_bits;
	uint8_t _pad[7];
};

struct evtchn_expand_array {
	uint64_t array_gfn;
};

typedef uint32_t event_word_t;

struct evtchn_fifo_control_block {
	uint32_t ready;
	uint32_t _rsvd;
	event_word_t head[16];
};

struct evtchn_fifo_queue {
	uint32_t head[16];
};

struct evtchn_alloc_unbound {
	domid_t dom;
	domid_t remote_dom;
	evtchn_port_t port;
};

enum xenstore_init {
	XS_UNKNOWN = 0,
	XS_PV = 1,
	XS_HVM = 2,
	XS_LOCAL = 3,
};

struct xenbus_map_node {
	struct list_head next;
	union {
		struct {
			struct vm_struct *area;
		} pv;
		struct {
			struct page *pages[16];
			long unsigned int addrs[16];
			void *addr;
		} hvm;
	};
	grant_handle_t handles[16];
	unsigned int nr_handles;
};

struct map_ring_valloc {
	struct xenbus_map_node *node;
	long unsigned int addrs[16];
	phys_addr_t phys_addrs[16];
	struct gnttab_map_grant_ref map[16];
	struct gnttab_unmap_grant_ref unmap[16];
	unsigned int idx;
};

struct xenbus_ring_ops {
	int (*map)(struct xenbus_device *, struct map_ring_valloc *, grant_ref_t *, unsigned int, void **);
	int (*unmap)(struct xenbus_device *, void *);
};

struct unmap_ring_hvm {
	unsigned int idx;
	long unsigned int addrs[16];
};

enum xsd_sockmsg_type {
	XS_DEBUG = 0,
	XS_DIRECTORY = 1,
	XS_READ = 2,
	XS_GET_PERMS = 3,
	XS_WATCH = 4,
	XS_UNWATCH = 5,
	XS_TRANSACTION_START = 6,
	XS_TRANSACTION_END = 7,
	XS_INTRODUCE = 8,
	XS_RELEASE = 9,
	XS_GET_DOMAIN_PATH = 10,
	XS_WRITE = 11,
	XS_MKDIR = 12,
	XS_RM = 13,
	XS_SET_PERMS = 14,
	XS_WATCH_EVENT = 15,
	XS_ERROR = 16,
	XS_IS_DOMAIN_INTRODUCED = 17,
	XS_RESUME = 18,
	XS_SET_TARGET = 19,
	XS_RESTRICT = 20,
	XS_RESET_WATCHES = 21,
};

struct xsd_sockmsg {
	uint32_t type;
	uint32_t req_id;
	uint32_t tx_id;
	uint32_t len;
};

struct xs_watch_event {
	struct list_head list;
	unsigned int len;
	struct xenbus_watch *handle;
	const char *path;
	const char *token;
	char body[0];
};

enum xb_req_state {
	xb_req_state_queued = 0,
	xb_req_state_wait_reply = 1,
	xb_req_state_got_reply = 2,
	xb_req_state_aborted = 3,
};

struct xb_req_data {
	struct list_head list;
	wait_queue_head_t wq;
	struct xsd_sockmsg msg;
	uint32_t caller_req_id;
	enum xsd_sockmsg_type type;
	char *body;
	const struct kvec *vec;
	int num_vecs;
	int err;
	enum xb_req_state state;
	bool user_req;
	void (*cb)(struct xb_req_data *);
	void *par;
};

struct xenbus_device_id {
	char devicetype[32];
};

struct xenbus_driver {
	const char *name;
	const struct xenbus_device_id *ids;
	bool allow_rebind;
	int (*probe)(struct xenbus_device *, const struct xenbus_device_id *);
	void (*otherend_changed)(struct xenbus_device *, enum xenbus_state);
	int (*remove)(struct xenbus_device *);
	int (*suspend)(struct xenbus_device *);
	int (*resume)(struct xenbus_device *);
	int (*freeze)(struct xenbus_device *);
	int (*thaw)(struct xenbus_device *);
	int (*restore)(struct xenbus_device *);
	int (*uevent)(struct xenbus_device *, struct kobj_uevent_env *);
	struct device_driver driver;
	int (*read_otherend_details)(struct xenbus_device *);
	int (*is_ready)(struct xenbus_device *);
	void (*reclaim_memory)(struct xenbus_device *);
};

struct xen_bus_type {
	char *root;
	unsigned int levels;
	int (*get_bus_id)(char *, const char *);
	int (*probe)(struct xen_bus_type *, const char *, const char *);
	bool (*otherend_will_handle)(struct xenbus_watch *, const char *, const char *);
	void (*otherend_changed)(struct xenbus_watch *, const char *, const char *);
	struct bus_type bus;
};

struct xb_find_info {
	struct xenbus_device *dev;
	const char *nodename;
};

struct xenbus_transaction_holder {
	struct list_head list;
	struct xenbus_transaction handle;
	unsigned int generation_id;
};

struct read_buffer {
	struct list_head list;
	unsigned int cons;
	unsigned int len;
	char msg[0];
};

struct xenbus_file_priv {
	struct mutex msgbuffer_mutex;
	struct list_head transactions;
	struct list_head watches;
	unsigned int len;
	union {
		struct xsd_sockmsg msg;
		char buffer[4096];
	} u;
	struct mutex reply_mutex;
	struct list_head read_buffers;
	wait_queue_head_t read_waitq;
	struct kref kref;
	struct work_struct wq;
};

struct watch_adapter {
	struct list_head list;
	struct xenbus_watch watch;
	struct xenbus_file_priv *dev_data;
	char *token;
};

typedef struct {
	union {
		int *p;
		uint64_t q;
	};
} __guest_handle_int;

typedef struct {
	union {
		xen_ulong_t *p;
		uint64_t q;
	};
} __guest_handle_xen_ulong_t;

struct xen_add_to_physmap_range {
	domid_t domid;
	uint16_t space;
	uint16_t size;
	domid_t foreign_domid;
	__guest_handle_xen_ulong_t idxs;
	__guest_handle_xen_pfn_t gpfns;
	__guest_handle_int errs;
};

struct xen_remove_from_physmap {
	domid_t domid;
	xen_pfn_t gpfn;
};

struct physdev_manage_pci {
	uint8_t bus;
	uint8_t devfn;
};

struct physdev_manage_pci_ext {
	uint8_t bus;
	uint8_t devfn;
	unsigned int is_extfn;
	unsigned int is_virtfn;
	struct {
		uint8_t bus;
		uint8_t devfn;
	} physfn;
};

struct physdev_pci_device_add {
	uint16_t seg;
	uint8_t bus;
	uint8_t devfn;
	uint32_t flags;
	struct {
		uint8_t bus;
		uint8_t devfn;
	} physfn;
	uint32_t optarr[0];
};

struct physdev_pci_device {
	uint16_t seg;
	uint8_t bus;
	uint8_t devfn;
};

struct usb_device_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__le16 idVendor;
	__le16 idProduct;
	__le16 bcdDevice;
	__u8 iManufacturer;
	__u8 iProduct;
	__u8 iSerialNumber;
	__u8 bNumConfigurations;
};

struct usb_config_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumInterfaces;
	__u8 bConfigurationValue;
	__u8 iConfiguration;
	__u8 bmAttributes;
	__u8 bMaxPower;
} __attribute__((packed));

struct usb_interface_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bInterfaceNumber;
	__u8 bAlternateSetting;
	__u8 bNumEndpoints;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 iInterface;
};

struct usb_endpoint_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bEndpointAddress;
	__u8 bmAttributes;
	__le16 wMaxPacketSize;
	__u8 bInterval;
	__u8 bRefresh;
	__u8 bSynchAddress;
} __attribute__((packed));

struct usb_ssp_isoc_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wReseved;
	__le32 dwBytesPerInterval;
};

struct usb_ss_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bMaxBurst;
	__u8 bmAttributes;
	__le16 wBytesPerInterval;
};

struct usb_interface_assoc_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bFirstInterface;
	__u8 bInterfaceCount;
	__u8 bFunctionClass;
	__u8 bFunctionSubClass;
	__u8 bFunctionProtocol;
	__u8 iFunction;
};

struct usb_bos_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumDeviceCaps;
} __attribute__((packed));

struct usb_ext_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__le32 bmAttributes;
} __attribute__((packed));

struct usb_ss_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bmAttributes;
	__le16 wSpeedSupported;
	__u8 bFunctionalitySupport;
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
};

struct usb_ss_container_id_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__u8 ContainerID[16];
};

struct usb_ssp_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__le32 bmAttributes;
	__le16 wFunctionalitySupport;
	__le16 wReserved;
	__le32 bmSublinkSpeedAttr[1];
};

struct usb_ptm_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

enum usb_device_speed {
	USB_SPEED_UNKNOWN = 0,
	USB_SPEED_LOW = 1,
	USB_SPEED_FULL = 2,
	USB_SPEED_HIGH = 3,
	USB_SPEED_WIRELESS = 4,
	USB_SPEED_SUPER = 5,
	USB_SPEED_SUPER_PLUS = 6,
};

enum usb_device_state {
	USB_STATE_NOTATTACHED = 0,
	USB_STATE_ATTACHED = 1,
	USB_STATE_POWERED = 2,
	USB_STATE_RECONNECTING = 3,
	USB_STATE_UNAUTHENTICATED = 4,
	USB_STATE_DEFAULT = 5,
	USB_STATE_ADDRESS = 6,
	USB_STATE_CONFIGURED = 7,
	USB_STATE_SUSPENDED = 8,
};

enum usb3_link_state {
	USB3_LPM_U0 = 0,
	USB3_LPM_U1 = 1,
	USB3_LPM_U2 = 2,
	USB3_LPM_U3 = 3,
};

enum usb_ssp_rate {
	USB_SSP_GEN_UNKNOWN = 0,
	USB_SSP_GEN_2x1 = 1,
	USB_SSP_GEN_1x2 = 2,
	USB_SSP_GEN_2x2 = 3,
};

struct ep_device;

struct usb_host_endpoint {
	struct usb_endpoint_descriptor desc;
	struct usb_ss_ep_comp_descriptor ss_ep_comp;
	struct usb_ssp_isoc_ep_comp_descriptor ssp_isoc_ep_comp;
	char: 8;
	struct list_head urb_list;
	void *hcpriv;
	struct ep_device *ep_dev;
	unsigned char *extra;
	int extralen;
	int enabled;
	int streams;
	int: 32;
} __attribute__((packed));

struct usb_host_interface {
	struct usb_interface_descriptor desc;
	int extralen;
	unsigned char *extra;
	struct usb_host_endpoint *endpoint;
	char *string;
};

enum usb_interface_condition {
	USB_INTERFACE_UNBOUND = 0,
	USB_INTERFACE_BINDING = 1,
	USB_INTERFACE_BOUND = 2,
	USB_INTERFACE_UNBINDING = 3,
};

struct usb_interface {
	struct usb_host_interface *altsetting;
	struct usb_host_interface *cur_altsetting;
	unsigned int num_altsetting;
	struct usb_interface_assoc_descriptor *intf_assoc;
	int minor;
	enum usb_interface_condition condition;
	unsigned int sysfs_files_created: 1;
	unsigned int ep_devs_created: 1;
	unsigned int unregistering: 1;
	unsigned int needs_remote_wakeup: 1;
	unsigned int needs_altsetting0: 1;
	unsigned int needs_binding: 1;
	unsigned int resetting_device: 1;
	unsigned int authorized: 1;
	struct device dev;
	struct device *usb_dev;
	struct work_struct reset_ws;
};

struct usb_interface_cache {
	unsigned int num_altsetting;
	struct kref ref;
	struct usb_host_interface altsetting[0];
};

struct usb_host_config {
	struct usb_config_descriptor desc;
	char *string;
	struct usb_interface_assoc_descriptor *intf_assoc[16];
	struct usb_interface *interface[32];
	struct usb_interface_cache *intf_cache[32];
	unsigned char *extra;
	int extralen;
};

struct usb_host_bos {
	struct usb_bos_descriptor *desc;
	struct usb_ext_cap_descriptor *ext_cap;
	struct usb_ss_cap_descriptor *ss_cap;
	struct usb_ssp_cap_descriptor *ssp_cap;
	struct usb_ss_container_id_descriptor *ss_id;
	struct usb_ptm_cap_descriptor *ptm_cap;
};

struct usb_devmap {
	long unsigned int devicemap[2];
};

struct mon_bus;

struct usb_device;

struct usb_bus {
	struct device *controller;
	struct device *sysdev;
	int busnum;
	const char *bus_name;
	u8 uses_pio_for_control;
	u8 otg_port;
	unsigned int is_b_host: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int no_stop_on_short: 1;
	unsigned int no_sg_constraint: 1;
	unsigned int sg_tablesize;
	int devnum_next;
	struct mutex devnum_next_mutex;
	struct usb_devmap devmap;
	struct usb_device *root_hub;
	struct usb_bus *hs_companion;
	int bandwidth_allocated;
	int bandwidth_int_reqs;
	int bandwidth_isoc_reqs;
	unsigned int resuming_ports;
	struct mon_bus *mon_bus;
	int monitored;
};

struct wusb_dev;

enum usb_device_removable {
	USB_DEVICE_REMOVABLE_UNKNOWN = 0,
	USB_DEVICE_REMOVABLE = 1,
	USB_DEVICE_FIXED = 2,
};

struct usb2_lpm_parameters {
	unsigned int besl;
	int timeout;
};

struct usb3_lpm_parameters {
	unsigned int mel;
	unsigned int pel;
	unsigned int sel;
	int timeout;
};

struct usb_tt;

struct usb_device {
	int devnum;
	char devpath[16];
	u32 route;
	enum usb_device_state state;
	enum usb_device_speed speed;
	unsigned int rx_lanes;
	unsigned int tx_lanes;
	enum usb_ssp_rate ssp_rate;
	struct usb_tt *tt;
	int ttport;
	unsigned int toggle[2];
	struct usb_device *parent;
	struct usb_bus *bus;
	struct usb_host_endpoint ep0;
	struct device dev;
	struct usb_device_descriptor descriptor;
	struct usb_host_bos *bos;
	struct usb_host_config *config;
	struct usb_host_config *actconfig;
	struct usb_host_endpoint *ep_in[16];
	struct usb_host_endpoint *ep_out[16];
	char **rawdescriptors;
	short unsigned int bus_mA;
	u8 portnum;
	u8 level;
	u8 devaddr;
	unsigned int can_submit: 1;
	unsigned int persist_enabled: 1;
	unsigned int have_langid: 1;
	unsigned int authorized: 1;
	unsigned int authenticated: 1;
	unsigned int wusb: 1;
	unsigned int lpm_capable: 1;
	unsigned int usb2_hw_lpm_capable: 1;
	unsigned int usb2_hw_lpm_besl_capable: 1;
	unsigned int usb2_hw_lpm_enabled: 1;
	unsigned int usb2_hw_lpm_allowed: 1;
	unsigned int usb3_lpm_u1_enabled: 1;
	unsigned int usb3_lpm_u2_enabled: 1;
	int string_langid;
	char *product;
	char *manufacturer;
	char *serial;
	struct list_head filelist;
	int maxchild;
	u32 quirks;
	atomic_t urbnum;
	long unsigned int active_duration;
	long unsigned int connect_time;
	unsigned int do_remote_wakeup: 1;
	unsigned int reset_resume: 1;
	unsigned int port_is_suspended: 1;
	struct wusb_dev *wusb_dev;
	int slot_id;
	enum usb_device_removable removable;
	struct usb2_lpm_parameters l1_params;
	struct usb3_lpm_parameters u1_params;
	struct usb3_lpm_parameters u2_params;
	unsigned int lpm_disable_count;
	u16 hub_delay;
	unsigned int use_generic_driver: 1;
};

struct usb_tt {
	struct usb_device *hub;
	int multi;
	unsigned int think_time;
	void *hcpriv;
	spinlock_t lock;
	struct list_head clear_list;
	struct work_struct clear_work;
};

struct usb_iso_packet_descriptor {
	unsigned int offset;
	unsigned int length;
	unsigned int actual_length;
	int status;
};

struct usb_anchor {
	struct list_head urb_list;
	wait_queue_head_t wait;
	spinlock_t lock;
	atomic_t suspend_wakeups;
	unsigned int poisoned: 1;
};

struct urb;

typedef void (*usb_complete_t)(struct urb *);

struct urb {
	struct kref kref;
	int unlinked;
	void *hcpriv;
	atomic_t use_count;
	atomic_t reject;
	struct list_head urb_list;
	struct list_head anchor_list;
	struct usb_anchor *anchor;
	struct usb_device *dev;
	struct usb_host_endpoint *ep;
	unsigned int pipe;
	unsigned int stream_id;
	int status;
	unsigned int transfer_flags;
	void *transfer_buffer;
	dma_addr_t transfer_dma;
	struct scatterlist *sg;
	int num_mapped_sgs;
	int num_sgs;
	u32 transfer_buffer_length;
	u32 actual_length;
	unsigned char *setup_packet;
	dma_addr_t setup_dma;
	int start_frame;
	int number_of_packets;
	int interval;
	int error_count;
	void *context;
	usb_complete_t complete;
	struct usb_iso_packet_descriptor iso_frame_desc[0];
};

struct giveback_urb_bh {
	bool running;
	spinlock_t lock;
	struct list_head head;
	struct tasklet_struct bh;
	struct usb_host_endpoint *completing_ep;
};

enum usb_dev_authorize_policy {
	USB_DEVICE_AUTHORIZE_NONE = 0,
	USB_DEVICE_AUTHORIZE_ALL = 1,
	USB_DEVICE_AUTHORIZE_INTERNAL = 2,
};

struct usb_phy_roothub;

struct hc_driver;

struct usb_phy;

struct usb_hcd {
	struct usb_bus self;
	struct kref kref;
	const char *product_desc;
	int speed;
	char irq_descr[24];
	struct timer_list rh_timer;
	struct urb *status_urb;
	struct work_struct wakeup_work;
	struct work_struct died_work;
	const struct hc_driver *driver;
	struct usb_phy *usb_phy;
	struct usb_phy_roothub *phy_roothub;
	long unsigned int flags;
	enum usb_dev_authorize_policy dev_policy;
	unsigned int rh_registered: 1;
	unsigned int rh_pollable: 1;
	unsigned int msix_enabled: 1;
	unsigned int msi_enabled: 1;
	unsigned int skip_phy_initialization: 1;
	unsigned int uses_new_polling: 1;
	unsigned int wireless: 1;
	unsigned int has_tt: 1;
	unsigned int amd_resume_bug: 1;
	unsigned int can_do_streams: 1;
	unsigned int tpl_support: 1;
	unsigned int cant_recv_wakeups: 1;
	unsigned int irq;
	void *regs;
	resource_size_t rsrc_start;
	resource_size_t rsrc_len;
	unsigned int power_budget;
	struct giveback_urb_bh high_prio_bh;
	struct giveback_urb_bh low_prio_bh;
	struct mutex *address0_mutex;
	struct mutex *bandwidth_mutex;
	struct usb_hcd *shared_hcd;
	struct usb_hcd *primary_hcd;
	struct dma_pool___2 *pool[4];
	int state;
	struct gen_pool *localmem_pool;
	long unsigned int hcd_priv[0];
};

struct hc_driver {
	const char *description;
	const char *product_desc;
	size_t hcd_priv_size;
	irqreturn_t (*irq)(struct usb_hcd *);
	int flags;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*pci_suspend)(struct usb_hcd *, bool);
	int (*pci_resume)(struct usb_hcd *, bool);
	void (*stop)(struct usb_hcd *);
	void (*shutdown)(struct usb_hcd *);
	int (*get_frame_number)(struct usb_hcd *);
	int (*urb_enqueue)(struct usb_hcd *, struct urb *, gfp_t);
	int (*urb_dequeue)(struct usb_hcd *, struct urb *, int);
	int (*map_urb_for_dma)(struct usb_hcd *, struct urb *, gfp_t);
	void (*unmap_urb_for_dma)(struct usb_hcd *, struct urb *);
	void (*endpoint_disable)(struct usb_hcd *, struct usb_host_endpoint *);
	void (*endpoint_reset)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*hub_status_data)(struct usb_hcd *, char *);
	int (*hub_control)(struct usb_hcd *, u16, u16, u16, char *, u16);
	int (*bus_suspend)(struct usb_hcd *);
	int (*bus_resume)(struct usb_hcd *);
	int (*start_port_reset)(struct usb_hcd *, unsigned int);
	long unsigned int (*get_resuming_ports)(struct usb_hcd *);
	void (*relinquish_port)(struct usb_hcd *, int);
	int (*port_handed_over)(struct usb_hcd *, int);
	void (*clear_tt_buffer_complete)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*alloc_dev)(struct usb_hcd *, struct usb_device *);
	void (*free_dev)(struct usb_hcd *, struct usb_device *);
	int (*alloc_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, unsigned int, gfp_t);
	int (*free_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, gfp_t);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*address_device)(struct usb_hcd *, struct usb_device *);
	int (*enable_device)(struct usb_hcd *, struct usb_device *);
	int (*update_hub_device)(struct usb_hcd *, struct usb_device *, struct usb_tt *, gfp_t);
	int (*reset_device)(struct usb_hcd *, struct usb_device *);
	int (*update_device)(struct usb_hcd *, struct usb_device *);
	int (*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);
	int (*enable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*disable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*find_raw_port_number)(struct usb_hcd *, int);
	int (*port_power)(struct usb_hcd *, int, bool);
};

struct usb_mon_operations {
	void (*urb_submit)(struct usb_bus *, struct urb *);
	void (*urb_submit_error)(struct usb_bus *, struct urb *, int);
	void (*urb_complete)(struct usb_bus *, struct urb *, int);
};

struct physdev_dbgp_op {
	uint8_t op;
	uint8_t bus;
	union {
		struct physdev_pci_device pci;
	} u;
};

struct dev_ext_attribute {
	struct device_attribute attr;
	void *var;
};

typedef uint8_t xen_domain_handle_t[16];

struct xen_compile_info {
	char compiler[64];
	char compile_by[16];
	char compile_domain[32];
	char compile_date[32];
};

struct xen_platform_parameters {
	xen_ulong_t virt_start;
};

struct xen_build_id {
	uint32_t len;
	unsigned char buf[0];
};

struct hyp_sysfs_attr {
	struct attribute attr;
	ssize_t (*show)(struct hyp_sysfs_attr *, char *);
	ssize_t (*store)(struct hyp_sysfs_attr *, const char *, size_t);
	void *hyp_attr_data;
};

enum xen_swiotlb_err {
	XEN_SWIOTLB_UNKNOWN = 0,
	XEN_SWIOTLB_ENOMEM = 1,
	XEN_SWIOTLB_EFIXUP = 2,
};

typedef void (*xen_gfn_fn_t)(long unsigned int, void *);

struct xen_remap_gfn_info;

struct remap_data {
	xen_pfn_t *fgfn;
	int nr_fgfn;
	pgprot_t prot;
	domid_t domid;
	struct vm_area_struct *vma;
	int index;
	struct page **pages;
	struct xen_remap_gfn_info *info;
	int *err_ptr;
	int mapped;
	int h_errs[1];
	xen_ulong_t h_idxs[1];
	xen_pfn_t h_gpfns[1];
	int h_iter;
};

struct map_balloon_pages {
	xen_pfn_t *pfns;
	unsigned int idx;
};

struct remap_pfn {
	struct mm_struct *mm;
	struct page **pages;
	pgprot_t prot;
	long unsigned int i;
};

struct ww_class {
	atomic_long_t stamp;
	struct lock_class_key acquire_key;
	struct lock_class_key mutex_key;
	const char *acquire_name;
	const char *mutex_name;
	unsigned int is_wait_die;
};

struct pre_voltage_change_data {
	long unsigned int old_uV;
	long unsigned int min_uV;
	long unsigned int max_uV;
};

struct regulator_voltage {
	int min_uV;
	int max_uV;
};

struct regulator {
	struct device *dev;
	struct list_head list;
	unsigned int always_on: 1;
	unsigned int bypass: 1;
	unsigned int device_link: 1;
	int uA_load;
	unsigned int enable_count;
	unsigned int deferred_disables;
	struct regulator_voltage voltage[5];
	const char *supply_name;
	struct device_attribute dev_attr;
	struct regulator_dev *rdev;
	struct dentry *debugfs;
};

struct regulator_coupler {
	struct list_head list;
	int (*attach_regulator)(struct regulator_coupler *, struct regulator_dev *);
	int (*detach_regulator)(struct regulator_coupler *, struct regulator_dev *);
	int (*balance_voltage)(struct regulator_coupler *, struct regulator_dev *, suspend_state_t);
};

enum regulator_status {
	REGULATOR_STATUS_OFF = 0,
	REGULATOR_STATUS_ON = 1,
	REGULATOR_STATUS_ERROR = 2,
	REGULATOR_STATUS_FAST = 3,
	REGULATOR_STATUS_NORMAL = 4,
	REGULATOR_STATUS_IDLE = 5,
	REGULATOR_STATUS_STANDBY = 6,
	REGULATOR_STATUS_BYPASS = 7,
	REGULATOR_STATUS_UNDEFINED = 8,
};

struct regulator_enable_gpio {
	struct list_head list;
	struct gpio_desc *gpiod;
	u32 enable_count;
	u32 request_count;
};

enum regulator_active_discharge {
	REGULATOR_ACTIVE_DISCHARGE_DEFAULT = 0,
	REGULATOR_ACTIVE_DISCHARGE_DISABLE = 1,
	REGULATOR_ACTIVE_DISCHARGE_ENABLE = 2,
};

struct regulator_consumer_supply {
	const char *dev_name;
	const char *supply;
};

struct trace_event_raw_regulator_basic {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regulator_range {
	struct trace_entry ent;
	u32 __data_loc_name;
	int min;
	int max;
	char __data[0];
};

struct trace_event_raw_regulator_value {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int val;
	char __data[0];
};

struct trace_event_data_offsets_regulator_basic {
	u32 name;
};

struct trace_event_data_offsets_regulator_range {
	u32 name;
};

struct trace_event_data_offsets_regulator_value {
	u32 name;
};

typedef void (*btf_trace_regulator_enable)(void *, const char *);

typedef void (*btf_trace_regulator_enable_delay)(void *, const char *);

typedef void (*btf_trace_regulator_enable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_disable)(void *, const char *);

typedef void (*btf_trace_regulator_disable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_enable)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_enable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_disable)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_disable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_set_voltage)(void *, const char *, int, int);

typedef void (*btf_trace_regulator_set_voltage_complete)(void *, const char *, unsigned int);

enum regulator_get_type {
	NORMAL_GET = 0,
	EXCLUSIVE_GET = 1,
	OPTIONAL_GET = 2,
	MAX_GET_TYPE = 3,
};

struct regulator_map {
	struct list_head list;
	const char *dev_name;
	const char *supply;
	struct regulator_dev *regulator;
};

struct regulator_supply_alias {
	struct list_head list;
	struct device *src_dev;
	const char *src_supply;
	struct device *alias_dev;
	const char *alias_supply;
};

struct summary_data {
	struct seq_file *s;
	struct regulator_dev *parent;
	int level;
};

struct summary_lock_data {
	struct ww_acquire_ctx *ww_ctx;
	struct regulator_dev **new_contended_rdev;
	struct regulator_dev **old_contended_rdev;
};

struct fixed_voltage_config {
	const char *supply_name;
	const char *input_supply;
	int microvolts;
	unsigned int startup_delay;
	unsigned int off_on_delay;
	unsigned int enabled_at_boot: 1;
	struct regulator_init_data *init_data;
};

struct fixed_regulator_data {
	struct fixed_voltage_config cfg;
	struct regulator_init_data init_data;
	struct platform_device pdev;
};

struct regulator_bulk_devres {
	struct regulator_bulk_data *consumers;
	int num_consumers;
};

struct regulator_supply_alias_match {
	struct device *dev;
	const char *id;
};

struct regulator_notifier_match {
	struct regulator *regulator;
	struct notifier_block *nb;
};

struct of_regulator_match___2 {
	const char *name;
	void *driver_data;
	struct regulator_init_data *init_data;
	struct device_node *of_node;
	const struct regulator_desc *desc;
};

struct devm_of_regulator_matches {
	struct of_regulator_match___2 *matches;
	unsigned int num_matches;
};

struct reset_control___2;

struct reset_control_bulk_data {
	const char *id;
	struct reset_control___2 *rstc;
};

struct reset_control___2 {
	struct reset_controller_dev *rcdev;
	struct list_head list;
	unsigned int id;
	struct kref refcnt;
	bool acquired;
	bool shared;
	bool array;
	atomic_t deassert_count;
	atomic_t triggered_count;
};

struct reset_control_lookup {
	struct list_head list;
	const char *provider;
	unsigned int index;
	const char *dev_id;
	const char *con_id;
};

struct reset_control_array {
	struct reset_control___2 base;
	unsigned int num_rstcs;
	struct reset_control___2 *rstc[0];
};

struct reset_control_bulk_devres {
	int num_rstcs;
	struct reset_control_bulk_data *rstcs;
};

struct berlin_reset_priv {
	struct regmap *regmap;
	struct reset_controller_dev rcdev;
};

struct brcm_rescal_reset {
	void *base;
	struct device *dev;
	struct reset_controller_dev rcdev;
};

struct imx7_src_signal {
	unsigned int offset;
	unsigned int bit;
};

struct imx7_src_variant {
	const struct imx7_src_signal *signals;
	unsigned int signals_num;
	struct reset_control_ops ops;
};

struct imx7_src {
	struct reset_controller_dev rcdev;
	struct regmap *regmap;
	const struct imx7_src_signal *signals;
};

enum imx7_src_registers {
	SRC_A7RCR0 = 4,
	SRC_M4RCR = 12,
	SRC_ERCR = 20,
	SRC_HSICPHY_RCR = 28,
	SRC_USBOPHY1_RCR = 32,
	SRC_USBOPHY2_RCR = 36,
	SRC_MIPIPHY_RCR = 40,
	SRC_PCIEPHY_RCR = 44,
	SRC_DDRC_RCR = 4096,
};

enum imx8mq_src_registers {
	SRC_A53RCR0 = 4,
	SRC_HDMI_RCR = 48,
	SRC_DISP_RCR = 52,
	SRC_GPU_RCR = 64,
	SRC_VPU_RCR = 68,
	SRC_PCIE2_RCR = 72,
	SRC_MIPIPHY1_RCR = 76,
	SRC_MIPIPHY2_RCR = 80,
	SRC_DDRC2_RCR = 4100,
};

enum imx8mp_src_registers {
	SRC_SUPERMIX_RCR = 24,
	SRC_AUDIOMIX_RCR = 28,
	SRC_MLMIX_RCR = 40,
	SRC_GPU2D_RCR = 56,
	SRC_GPU3D_RCR = 60,
	SRC_VPU_G1_RCR = 72,
	SRC_VPU_G2_RCR = 76,
	SRC_VPUVC8KE_RCR = 80,
	SRC_NOC_RCR = 84,
};

struct meson_reset_param {
	int reg_count;
	int level_offset;
};

struct meson_reset {
	void *reg_base;
	const struct meson_reset_param *param;
	struct reset_controller_dev rcdev;
	spinlock_t lock;
};

struct qcom_aoss_reset_map {
	unsigned int reg;
};

struct qcom_aoss_desc {
	const struct qcom_aoss_reset_map *resets;
	size_t num_resets;
};

struct qcom_aoss_reset_data {
	struct reset_controller_dev rcdev;
	void *base;
	const struct qcom_aoss_desc *desc;
};

struct reset_simple_data {
	spinlock_t lock;
	void *membase;
	struct reset_controller_dev rcdev;
	bool active_low;
	bool status_active_low;
	unsigned int reset_us;
};

struct reset_simple_devdata {
	u32 reg_offset;
	u32 nr_resets;
	bool active_low;
	bool status_active_low;
};

enum zynqmp_pm_reset_action {
	PM_RESET_ACTION_RELEASE = 0,
	PM_RESET_ACTION_ASSERT = 1,
	PM_RESET_ACTION_PULSE = 2,
};

enum zynqmp_pm_reset {
	ZYNQMP_PM_RESET_START = 1000,
	ZYNQMP_PM_RESET_PCIE_CFG = 1000,
	ZYNQMP_PM_RESET_PCIE_BRIDGE = 1001,
	ZYNQMP_PM_RESET_PCIE_CTRL = 1002,
	ZYNQMP_PM_RESET_DP = 1003,
	ZYNQMP_PM_RESET_SWDT_CRF = 1004,
	ZYNQMP_PM_RESET_AFI_FM5 = 1005,
	ZYNQMP_PM_RESET_AFI_FM4 = 1006,
	ZYNQMP_PM_RESET_AFI_FM3 = 1007,
	ZYNQMP_PM_RESET_AFI_FM2 = 1008,
	ZYNQMP_PM_RESET_AFI_FM1 = 1009,
	ZYNQMP_PM_RESET_AFI_FM0 = 1010,
	ZYNQMP_PM_RESET_GDMA = 1011,
	ZYNQMP_PM_RESET_GPU_PP1 = 1012,
	ZYNQMP_PM_RESET_GPU_PP0 = 1013,
	ZYNQMP_PM_RESET_GPU = 1014,
	ZYNQMP_PM_RESET_GT = 1015,
	ZYNQMP_PM_RESET_SATA = 1016,
	ZYNQMP_PM_RESET_ACPU3_PWRON = 1017,
	ZYNQMP_PM_RESET_ACPU2_PWRON = 1018,
	ZYNQMP_PM_RESET_ACPU1_PWRON = 1019,
	ZYNQMP_PM_RESET_ACPU0_PWRON = 1020,
	ZYNQMP_PM_RESET_APU_L2 = 1021,
	ZYNQMP_PM_RESET_ACPU3 = 1022,
	ZYNQMP_PM_RESET_ACPU2 = 1023,
	ZYNQMP_PM_RESET_ACPU1 = 1024,
	ZYNQMP_PM_RESET_ACPU0 = 1025,
	ZYNQMP_PM_RESET_DDR = 1026,
	ZYNQMP_PM_RESET_APM_FPD = 1027,
	ZYNQMP_PM_RESET_SOFT = 1028,
	ZYNQMP_PM_RESET_GEM0 = 1029,
	ZYNQMP_PM_RESET_GEM1 = 1030,
	ZYNQMP_PM_RESET_GEM2 = 1031,
	ZYNQMP_PM_RESET_GEM3 = 1032,
	ZYNQMP_PM_RESET_QSPI = 1033,
	ZYNQMP_PM_RESET_UART0 = 1034,
	ZYNQMP_PM_RESET_UART1 = 1035,
	ZYNQMP_PM_RESET_SPI0 = 1036,
	ZYNQMP_PM_RESET_SPI1 = 1037,
	ZYNQMP_PM_RESET_SDIO0 = 1038,
	ZYNQMP_PM_RESET_SDIO1 = 1039,
	ZYNQMP_PM_RESET_CAN0 = 1040,
	ZYNQMP_PM_RESET_CAN1 = 1041,
	ZYNQMP_PM_RESET_I2C0 = 1042,
	ZYNQMP_PM_RESET_I2C1 = 1043,
	ZYNQMP_PM_RESET_TTC0 = 1044,
	ZYNQMP_PM_RESET_TTC1 = 1045,
	ZYNQMP_PM_RESET_TTC2 = 1046,
	ZYNQMP_PM_RESET_TTC3 = 1047,
	ZYNQMP_PM_RESET_SWDT_CRL = 1048,
	ZYNQMP_PM_RESET_NAND = 1049,
	ZYNQMP_PM_RESET_ADMA = 1050,
	ZYNQMP_PM_RESET_GPIO = 1051,
	ZYNQMP_PM_RESET_IOU_CC = 1052,
	ZYNQMP_PM_RESET_TIMESTAMP = 1053,
	ZYNQMP_PM_RESET_RPU_R50 = 1054,
	ZYNQMP_PM_RESET_RPU_R51 = 1055,
	ZYNQMP_PM_RESET_RPU_AMBA = 1056,
	ZYNQMP_PM_RESET_OCM = 1057,
	ZYNQMP_PM_RESET_RPU_PGE = 1058,
	ZYNQMP_PM_RESET_USB0_CORERESET = 1059,
	ZYNQMP_PM_RESET_USB1_CORERESET = 1060,
	ZYNQMP_PM_RESET_USB0_HIBERRESET = 1061,
	ZYNQMP_PM_RESET_USB1_HIBERRESET = 1062,
	ZYNQMP_PM_RESET_USB0_APB = 1063,
	ZYNQMP_PM_RESET_USB1_APB = 1064,
	ZYNQMP_PM_RESET_IPI = 1065,
	ZYNQMP_PM_RESET_APM_LPD = 1066,
	ZYNQMP_PM_RESET_RTC = 1067,
	ZYNQMP_PM_RESET_SYSMON = 1068,
	ZYNQMP_PM_RESET_AFI_FM6 = 1069,
	ZYNQMP_PM_RESET_LPD_SWDT = 1070,
	ZYNQMP_PM_RESET_FPD = 1071,
	ZYNQMP_PM_RESET_RPU_DBG1 = 1072,
	ZYNQMP_PM_RESET_RPU_DBG0 = 1073,
	ZYNQMP_PM_RESET_DBG_LPD = 1074,
	ZYNQMP_PM_RESET_DBG_FPD = 1075,
	ZYNQMP_PM_RESET_APLL = 1076,
	ZYNQMP_PM_RESET_DPLL = 1077,
	ZYNQMP_PM_RESET_VPLL = 1078,
	ZYNQMP_PM_RESET_IOPLL = 1079,
	ZYNQMP_PM_RESET_RPLL = 1080,
	ZYNQMP_PM_RESET_GPO3_PL_0 = 1081,
	ZYNQMP_PM_RESET_GPO3_PL_1 = 1082,
	ZYNQMP_PM_RESET_GPO3_PL_2 = 1083,
	ZYNQMP_PM_RESET_GPO3_PL_3 = 1084,
	ZYNQMP_PM_RESET_GPO3_PL_4 = 1085,
	ZYNQMP_PM_RESET_GPO3_PL_5 = 1086,
	ZYNQMP_PM_RESET_GPO3_PL_6 = 1087,
	ZYNQMP_PM_RESET_GPO3_PL_7 = 1088,
	ZYNQMP_PM_RESET_GPO3_PL_8 = 1089,
	ZYNQMP_PM_RESET_GPO3_PL_9 = 1090,
	ZYNQMP_PM_RESET_GPO3_PL_10 = 1091,
	ZYNQMP_PM_RESET_GPO3_PL_11 = 1092,
	ZYNQMP_PM_RESET_GPO3_PL_12 = 1093,
	ZYNQMP_PM_RESET_GPO3_PL_13 = 1094,
	ZYNQMP_PM_RESET_GPO3_PL_14 = 1095,
	ZYNQMP_PM_RESET_GPO3_PL_15 = 1096,
	ZYNQMP_PM_RESET_GPO3_PL_16 = 1097,
	ZYNQMP_PM_RESET_GPO3_PL_17 = 1098,
	ZYNQMP_PM_RESET_GPO3_PL_18 = 1099,
	ZYNQMP_PM_RESET_GPO3_PL_19 = 1100,
	ZYNQMP_PM_RESET_GPO3_PL_20 = 1101,
	ZYNQMP_PM_RESET_GPO3_PL_21 = 1102,
	ZYNQMP_PM_RESET_GPO3_PL_22 = 1103,
	ZYNQMP_PM_RESET_GPO3_PL_23 = 1104,
	ZYNQMP_PM_RESET_GPO3_PL_24 = 1105,
	ZYNQMP_PM_RESET_GPO3_PL_25 = 1106,
	ZYNQMP_PM_RESET_GPO3_PL_26 = 1107,
	ZYNQMP_PM_RESET_GPO3_PL_27 = 1108,
	ZYNQMP_PM_RESET_GPO3_PL_28 = 1109,
	ZYNQMP_PM_RESET_GPO3_PL_29 = 1110,
	ZYNQMP_PM_RESET_GPO3_PL_30 = 1111,
	ZYNQMP_PM_RESET_GPO3_PL_31 = 1112,
	ZYNQMP_PM_RESET_RPU_LS = 1113,
	ZYNQMP_PM_RESET_PS_ONLY = 1114,
	ZYNQMP_PM_RESET_PL = 1115,
	ZYNQMP_PM_RESET_PS_PL0 = 1116,
	ZYNQMP_PM_RESET_PS_PL1 = 1117,
	ZYNQMP_PM_RESET_PS_PL2 = 1118,
	ZYNQMP_PM_RESET_PS_PL3 = 1119,
	ZYNQMP_PM_RESET_END = 1119,
};

struct zynqmp_reset_soc_data {
	u32 reset_id;
	u32 num_resets;
};

struct zynqmp_reset_data {
	struct reset_controller_dev rcdev;
	const struct zynqmp_reset_soc_data *data;
};

struct serial_struct32 {
	compat_int_t type;
	compat_int_t line;
	compat_uint_t port;
	compat_int_t irq;
	compat_int_t flags;
	compat_int_t xmit_fifo_size;
	compat_int_t custom_divisor;
	compat_int_t baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char;
	compat_int_t hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	compat_uint_t iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	compat_int_t reserved;
};

struct n_tty_data {
	size_t read_head;
	size_t commit_head;
	size_t canon_head;
	size_t echo_head;
	size_t echo_commit;
	size_t echo_mark;
	long unsigned int char_map[4];
	long unsigned int overrun_time;
	int num_overrun;
	bool no_room;
	unsigned char lnext: 1;
	unsigned char erasing: 1;
	unsigned char raw: 1;
	unsigned char real_raw: 1;
	unsigned char icanon: 1;
	unsigned char push: 1;
	char read_buf[4096];
	long unsigned int read_flags[64];
	unsigned char echo_buf[4096];
	size_t read_tail;
	size_t line_start;
	unsigned int column;
	unsigned int canon_column;
	size_t echo_tail;
	struct mutex atomic_read_lock;
	struct mutex output_lock;
};

enum {
	ERASE = 0,
	WERASE = 1,
	KILL = 2,
};

struct termios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
};

struct termios2 {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct termio {
	short unsigned int c_iflag;
	short unsigned int c_oflag;
	short unsigned int c_cflag;
	short unsigned int c_lflag;
	unsigned char c_line;
	unsigned char c_cc[8];
};

struct ldsem_waiter {
	struct list_head list;
	struct task_struct *task;
};

struct pts_fs_info___2;

struct tty_audit_buf {
	struct mutex mutex;
	dev_t dev;
	unsigned int icanon: 1;
	size_t valid;
	unsigned char *data;
};

struct sysrq_state {
	struct input_handle handle;
	struct work_struct reinject_work;
	long unsigned int key_down[12];
	unsigned int alt;
	unsigned int alt_use;
	unsigned int shift;
	unsigned int shift_use;
	bool active;
	bool need_reinject;
	bool reinjecting;
	bool reset_canceled;
	bool reset_requested;
	long unsigned int reset_keybit[12];
	int reset_seq_len;
	int reset_seq_cnt;
	int reset_seq_version;
	struct timer_list keyreset_timer;
};

struct unipair {
	short unsigned int unicode;
	short unsigned int fontpos;
};

struct unimapdesc {
	short unsigned int entry_ct;
	struct unipair *entries;
};

struct kbdiacruc {
	unsigned int diacr;
	unsigned int base;
	unsigned int result;
};

struct kbd_repeat {
	int delay;
	int period;
};

struct console_font_op {
	unsigned int op;
	unsigned int flags;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_stat {
	short unsigned int v_active;
	short unsigned int v_signal;
	short unsigned int v_state;
};

struct vt_sizes {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_scrollsize;
};

struct vt_consize {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_vlin;
	short unsigned int v_clin;
	short unsigned int v_vcol;
	short unsigned int v_ccol;
};

struct vt_event {
	unsigned int event;
	unsigned int oldev;
	unsigned int newev;
	unsigned int pad[4];
};

struct vt_setactivate {
	unsigned int console;
	struct vt_mode mode;
};

struct vt_event_wait {
	struct list_head list;
	struct vt_event event;
	int done;
};

struct compat_console_font_op {
	compat_uint_t op;
	compat_uint_t flags;
	compat_uint_t width;
	compat_uint_t height;
	compat_uint_t charcount;
	compat_caddr_t data;
};

struct compat_unimapdesc {
	short unsigned int entry_ct;
	compat_caddr_t entries;
};

struct vt_notifier_param {
	struct vc_data *vc;
	unsigned int c;
};

struct vcs_poll_data {
	struct notifier_block notifier;
	unsigned int cons_num;
	int event;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
};

struct tiocl_selection {
	short unsigned int xs;
	short unsigned int ys;
	short unsigned int xe;
	short unsigned int ye;
	short unsigned int sel_mode;
};

struct vc_selection {
	struct mutex lock;
	struct vc_data *cons;
	char *buffer;
	unsigned int buf_len;
	volatile int start;
	int end;
};

struct kbentry {
	unsigned char kb_table;
	unsigned char kb_index;
	short unsigned int kb_value;
};

struct kbsentry {
	unsigned char kb_func;
	unsigned char kb_string[512];
};

struct kbdiacr {
	unsigned char diacr;
	unsigned char base;
	unsigned char result;
};

struct kbdiacrs {
	unsigned int kb_cnt;
	struct kbdiacr kbdiacr[256];
};

struct kbdiacrsuc {
	unsigned int kb_cnt;
	struct kbdiacruc kbdiacruc[256];
};

struct kbkeycode {
	unsigned int scancode;
	unsigned int keycode;
};

struct keyboard_notifier_param {
	struct vc_data *vc;
	int down;
	int shift;
	int ledstate;
	unsigned int value;
};

struct kbd_struct {
	unsigned char lockstate;
	unsigned char slockstate;
	unsigned char ledmode: 1;
	unsigned char ledflagstate: 4;
	char: 3;
	unsigned char default_ledflagstate: 4;
	unsigned char kbdmode: 3;
	char: 1;
	unsigned char modeflags: 5;
};

typedef void k_handler_fn(struct vc_data *, unsigned char, char);

typedef void fn_handler_fn(struct vc_data *);

struct getset_keycode_data {
	struct input_keymap_entry ke;
	int error;
};

struct kbd_led_trigger {
	struct led_trigger trigger;
	unsigned int mask;
};

struct uni_pagedir {
	u16 **uni_pgdir[32];
	long unsigned int refcount;
	long unsigned int sum;
	unsigned char *inverse_translations[4];
	u16 *inverse_trans_unicode;
};

typedef uint32_t char32_t;

struct uni_screen {
	char32_t *lines[0];
};

struct con_driver {
	const struct consw *con;
	const char *desc;
	struct device *dev;
	int node;
	int first;
	int last;
	int flag;
};

enum {
	blank_off = 0,
	blank_normal_wait = 1,
	blank_vesa_wait = 2,
};

enum {
	EPecma = 0,
	EPdec = 1,
	EPeq = 2,
	EPgt = 3,
	EPlt = 4,
};

struct rgb {
	u8 r;
	u8 g;
	u8 b;
};

enum {
	ESnormal = 0,
	ESesc = 1,
	ESsquare = 2,
	ESgetpars = 3,
	ESfunckey = 4,
	EShash = 5,
	ESsetG0 = 6,
	ESsetG1 = 7,
	ESpercent = 8,
	EScsiignore = 9,
	ESnonstd = 10,
	ESpalette = 11,
	ESosc = 12,
	ESapc = 13,
	ESpm = 14,
	ESdcs = 15,
};

struct interval {
	uint32_t first;
	uint32_t last;
};

struct vc_draw_region {
	long unsigned int from;
	long unsigned int to;
	int x;
};

struct hv_ops;

struct hvc_struct {
	struct tty_port port;
	spinlock_t lock;
	int index;
	int do_wakeup;
	char *outbuf;
	int outbuf_size;
	int n_outbuf;
	uint32_t vtermno;
	const struct hv_ops *ops;
	int irq_requested;
	int data;
	struct winsize ws;
	struct work_struct tty_resize;
	struct list_head next;
	long unsigned int flags;
};

struct hv_ops {
	int (*get_chars)(uint32_t, char *, int);
	int (*put_chars)(uint32_t, const char *, int);
	int (*flush)(uint32_t, bool);
	int (*notifier_add)(struct hvc_struct *, int);
	void (*notifier_del)(struct hvc_struct *, int);
	void (*notifier_hangup)(struct hvc_struct *, int);
	int (*tiocmget)(struct hvc_struct *);
	int (*tiocmset)(struct hvc_struct *, unsigned int, unsigned int);
	void (*dtr_rts)(struct hvc_struct *, int);
};

typedef uint32_t XENCONS_RING_IDX;

struct xencons_interface {
	char in[1024];
	char out[2048];
	XENCONS_RING_IDX in_cons;
	XENCONS_RING_IDX in_prod;
	XENCONS_RING_IDX out_cons;
	XENCONS_RING_IDX out_prod;
};

struct xencons_info {
	struct list_head list;
	struct xenbus_device *xbdev;
	struct xencons_interface *intf;
	unsigned int evtchn;
	XENCONS_RING_IDX out_cons;
	unsigned int out_cons_same;
	struct hvc_struct *hvc;
	int irq;
	int vtermno;
	grant_ref_t gntref;
};

struct uart_driver {
	struct module *owner;
	const char *driver_name;
	const char *dev_name;
	int major;
	int minor;
	int nr;
	struct console *cons;
	struct uart_state *state;
	struct tty_driver *tty_driver;
};

struct uart_match {
	struct uart_port *port;
	struct uart_driver *driver;
};

enum hwparam_type {
	hwparam_ioport = 0,
	hwparam_iomem = 1,
	hwparam_ioport_or_iomem = 2,
	hwparam_irq = 3,
	hwparam_dma = 4,
	hwparam_dma_addr = 5,
	hwparam_other = 6,
};

enum {
	PLAT8250_DEV_LEGACY = 4294967295,
	PLAT8250_DEV_PLATFORM = 0,
	PLAT8250_DEV_PLATFORM1 = 1,
	PLAT8250_DEV_PLATFORM2 = 2,
	PLAT8250_DEV_FOURPORT = 3,
	PLAT8250_DEV_ACCENT = 4,
	PLAT8250_DEV_BOCA = 5,
	PLAT8250_DEV_EXAR_ST16C554 = 6,
	PLAT8250_DEV_HUB6 = 7,
	PLAT8250_DEV_AU1X00 = 8,
	PLAT8250_DEV_SM501 = 9,
};

struct uart_8250_port;

struct uart_8250_ops {
	int (*setup_irq)(struct uart_8250_port *);
	void (*release_irq)(struct uart_8250_port *);
};

struct mctrl_gpios;

struct uart_8250_dma;

struct uart_8250_em485;

struct uart_8250_port {
	struct uart_port port;
	struct timer_list timer;
	struct list_head list;
	u32 capabilities;
	short unsigned int bugs;
	bool fifo_bug;
	unsigned int tx_loadsz;
	unsigned char acr;
	unsigned char fcr;
	unsigned char ier;
	unsigned char lcr;
	unsigned char mcr;
	unsigned char mcr_mask;
	unsigned char mcr_force;
	unsigned char cur_iotype;
	unsigned int rpm_tx_active;
	unsigned char canary;
	unsigned char probe;
	struct mctrl_gpios *gpios;
	unsigned char lsr_saved_flags;
	unsigned char msr_saved_flags;
	struct uart_8250_dma *dma;
	const struct uart_8250_ops *ops;
	int (*dl_read)(struct uart_8250_port *);
	void (*dl_write)(struct uart_8250_port *, int);
	struct uart_8250_em485 *em485;
	void (*rs485_start_tx)(struct uart_8250_port *);
	void (*rs485_stop_tx)(struct uart_8250_port *);
	struct delayed_work overrun_backoff;
	u32 overrun_backoff_time_ms;
};

struct uart_8250_em485 {
	struct hrtimer start_tx_timer;
	struct hrtimer stop_tx_timer;
	struct hrtimer *active_timer;
	struct uart_8250_port *port;
	unsigned int tx_stopped: 1;
};

struct uart_8250_dma {
	int (*tx_dma)(struct uart_8250_port *);
	int (*rx_dma)(struct uart_8250_port *);
	dma_filter_fn fn;
	void *rx_param;
	void *tx_param;
	struct dma_slave_config rxconf;
	struct dma_slave_config txconf;
	struct dma_chan *rxchan;
	struct dma_chan *txchan;
	phys_addr_t rx_dma_addr;
	phys_addr_t tx_dma_addr;
	dma_addr_t rx_addr;
	dma_addr_t tx_addr;
	dma_cookie_t rx_cookie;
	dma_cookie_t tx_cookie;
	void *rx_buf;
	size_t rx_size;
	size_t tx_size;
	unsigned char tx_running;
	unsigned char tx_err;
	unsigned char rx_running;
};

struct old_serial_port {
	unsigned int uart;
	unsigned int baud_base;
	unsigned int port;
	unsigned int irq;
	upf_t flags;
	unsigned char io_type;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
};

struct irq_info___2 {
	struct hlist_node node;
	int irq;
	spinlock_t lock;
	struct list_head *head;
};

struct serial8250_config {
	const char *name;
	short unsigned int fifo_size;
	short unsigned int tx_loadsz;
	unsigned char fcr;
	unsigned char rxtrig_bytes[4];
	unsigned int flags;
};

struct dw8250_port_data {
	int line;
	struct uart_8250_dma dma;
	u8 dlf_size;
};

struct fintek_8250 {
	u16 pid;
	u16 base_port;
	u8 index;
	u8 key;
};

struct pciserial_board {
	unsigned int flags;
	unsigned int num_ports;
	unsigned int base_baud;
	unsigned int uart_offset;
	unsigned int reg_shift;
	unsigned int first_offset;
};

struct serial_private;

struct pci_serial_quirk {
	u32 vendor;
	u32 device;
	u32 subvendor;
	u32 subdevice;
	int (*probe)(struct pci_dev *);
	int (*init)(struct pci_dev *);
	int (*setup)(struct serial_private *, const struct pciserial_board *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct serial_private {
	struct pci_dev *dev;
	unsigned int nr;
	struct pci_serial_quirk *quirk;
	const struct pciserial_board *board;
	int line[0];
};

struct f815xxa_data {
	spinlock_t lock;
	int idx;
};

struct timedia_struct {
	int num;
	const short unsigned int *ids;
};

struct quatech_feature {
	u16 devid;
	bool amcc;
};

enum pci_board_num_t {
	pbn_default = 0,
	pbn_b0_1_115200 = 1,
	pbn_b0_2_115200 = 2,
	pbn_b0_4_115200 = 3,
	pbn_b0_5_115200 = 4,
	pbn_b0_8_115200 = 5,
	pbn_b0_1_921600 = 6,
	pbn_b0_2_921600 = 7,
	pbn_b0_4_921600 = 8,
	pbn_b0_2_1130000 = 9,
	pbn_b0_4_1152000 = 10,
	pbn_b0_4_1250000 = 11,
	pbn_b0_2_1843200 = 12,
	pbn_b0_4_1843200 = 13,
	pbn_b0_1_4000000 = 14,
	pbn_b0_bt_1_115200 = 15,
	pbn_b0_bt_2_115200 = 16,
	pbn_b0_bt_4_115200 = 17,
	pbn_b0_bt_8_115200 = 18,
	pbn_b0_bt_1_460800 = 19,
	pbn_b0_bt_2_460800 = 20,
	pbn_b0_bt_4_460800 = 21,
	pbn_b0_bt_1_921600 = 22,
	pbn_b0_bt_2_921600 = 23,
	pbn_b0_bt_4_921600 = 24,
	pbn_b0_bt_8_921600 = 25,
	pbn_b1_1_115200 = 26,
	pbn_b1_2_115200 = 27,
	pbn_b1_4_115200 = 28,
	pbn_b1_8_115200 = 29,
	pbn_b1_16_115200 = 30,
	pbn_b1_1_921600 = 31,
	pbn_b1_2_921600 = 32,
	pbn_b1_4_921600 = 33,
	pbn_b1_8_921600 = 34,
	pbn_b1_2_1250000 = 35,
	pbn_b1_bt_1_115200 = 36,
	pbn_b1_bt_2_115200 = 37,
	pbn_b1_bt_4_115200 = 38,
	pbn_b1_bt_2_921600 = 39,
	pbn_b1_1_1382400 = 40,
	pbn_b1_2_1382400 = 41,
	pbn_b1_4_1382400 = 42,
	pbn_b1_8_1382400 = 43,
	pbn_b2_1_115200 = 44,
	pbn_b2_2_115200 = 45,
	pbn_b2_4_115200 = 46,
	pbn_b2_8_115200 = 47,
	pbn_b2_1_460800 = 48,
	pbn_b2_4_460800 = 49,
	pbn_b2_8_460800 = 50,
	pbn_b2_16_460800 = 51,
	pbn_b2_1_921600 = 52,
	pbn_b2_4_921600 = 53,
	pbn_b2_8_921600 = 54,
	pbn_b2_8_1152000 = 55,
	pbn_b2_bt_1_115200 = 56,
	pbn_b2_bt_2_115200 = 57,
	pbn_b2_bt_4_115200 = 58,
	pbn_b2_bt_2_921600 = 59,
	pbn_b2_bt_4_921600 = 60,
	pbn_b3_2_115200 = 61,
	pbn_b3_4_115200 = 62,
	pbn_b3_8_115200 = 63,
	pbn_b4_bt_2_921600 = 64,
	pbn_b4_bt_4_921600 = 65,
	pbn_b4_bt_8_921600 = 66,
	pbn_panacom = 67,
	pbn_panacom2 = 68,
	pbn_panacom4 = 69,
	pbn_plx_romulus = 70,
	pbn_endrun_2_4000000 = 71,
	pbn_oxsemi = 72,
	pbn_oxsemi_1_4000000 = 73,
	pbn_oxsemi_2_4000000 = 74,
	pbn_oxsemi_4_4000000 = 75,
	pbn_oxsemi_8_4000000 = 76,
	pbn_intel_i960 = 77,
	pbn_sgi_ioc3 = 78,
	pbn_computone_4 = 79,
	pbn_computone_6 = 80,
	pbn_computone_8 = 81,
	pbn_sbsxrsio = 82,
	pbn_pasemi_1682M = 83,
	pbn_ni8430_2 = 84,
	pbn_ni8430_4 = 85,
	pbn_ni8430_8 = 86,
	pbn_ni8430_16 = 87,
	pbn_ADDIDATA_PCIe_1_3906250 = 88,
	pbn_ADDIDATA_PCIe_2_3906250 = 89,
	pbn_ADDIDATA_PCIe_4_3906250 = 90,
	pbn_ADDIDATA_PCIe_8_3906250 = 91,
	pbn_ce4100_1_115200 = 92,
	pbn_omegapci = 93,
	pbn_NETMOS9900_2s_115200 = 94,
	pbn_brcm_trumanage = 95,
	pbn_fintek_4 = 96,
	pbn_fintek_8 = 97,
	pbn_fintek_12 = 98,
	pbn_fintek_F81504A = 99,
	pbn_fintek_F81508A = 100,
	pbn_fintek_F81512A = 101,
	pbn_wch382_2 = 102,
	pbn_wch384_4 = 103,
	pbn_wch384_8 = 104,
	pbn_pericom_PI7C9X7951 = 105,
	pbn_pericom_PI7C9X7952 = 106,
	pbn_pericom_PI7C9X7954 = 107,
	pbn_pericom_PI7C9X7958 = 108,
	pbn_sunix_pci_1s = 109,
	pbn_sunix_pci_2s = 110,
	pbn_sunix_pci_4s = 111,
	pbn_sunix_pci_8s = 112,
	pbn_sunix_pci_16s = 113,
	pbn_moxa8250_2p = 114,
	pbn_moxa8250_4p = 115,
	pbn_moxa8250_8p = 116,
};

struct fsl8250_data {
	int line;
};

struct dw8250_data {
	struct dw8250_port_data data;
	u8 usr_reg;
	int msr_mask_on;
	int msr_mask_off;
	struct clk *clk;
	struct clk *pclk;
	struct notifier_block clk_notifier;
	struct work_struct clk_work;
	struct reset_control *rst;
	unsigned int skip_autocfg: 1;
	unsigned int uart_16550_compatible: 1;
};

enum dma_rx_status {
	DMA_RX_START = 0,
	DMA_RX_RUNNING = 1,
	DMA_RX_SHUTDOWN = 2,
};

struct mtk8250_data {
	int line;
	unsigned int rx_pos;
	unsigned int clk_count;
	struct clk *uart_clk;
	struct clk *bus_clk;
	struct uart_8250_dma *dma;
	enum dma_rx_status rx_status;
	int rx_wakeup_irq;
};

enum {
	MTK_UART_FC_NONE = 0,
	MTK_UART_FC_SW = 1,
	MTK_UART_FC_HW = 2,
};

struct of_serial_info {
	struct clk *clk;
	struct reset_control *rst;
	int type;
	int line;
};

enum amba_vendor {
	AMBA_VENDOR_ARM = 65,
	AMBA_VENDOR_ST = 128,
	AMBA_VENDOR_QCOM = 81,
	AMBA_VENDOR_LSI = 182,
	AMBA_VENDOR_LINUX = 254,
};

struct amba_pl011_data {
	bool (*dma_filter)(struct dma_chan *, void *);
	void *dma_rx_param;
	void *dma_tx_param;
	bool dma_rx_poll_enable;
	unsigned int dma_rx_poll_rate;
	unsigned int dma_rx_poll_timeout;
	void (*init)();
	void (*exit)();
};

enum {
	REG_DR = 0,
	REG_ST_DMAWM = 1,
	REG_ST_TIMEOUT = 2,
	REG_FR = 3,
	REG_LCRH_RX = 4,
	REG_LCRH_TX = 5,
	REG_IBRD = 6,
	REG_FBRD = 7,
	REG_CR = 8,
	REG_IFLS = 9,
	REG_IMSC = 10,
	REG_RIS = 11,
	REG_MIS = 12,
	REG_ICR = 13,
	REG_DMACR = 14,
	REG_ST_XFCR = 15,
	REG_ST_XON1 = 16,
	REG_ST_XON2 = 17,
	REG_ST_XOFF1 = 18,
	REG_ST_XOFF2 = 19,
	REG_ST_ITCR = 20,
	REG_ST_ITIP = 21,
	REG_ST_ABCR = 22,
	REG_ST_ABIMSC = 23,
	REG_ARRAY_SIZE = 24,
};

struct vendor_data___2 {
	const u16 *reg_offset;
	unsigned int ifls;
	unsigned int fr_busy;
	unsigned int fr_dsr;
	unsigned int fr_cts;
	unsigned int fr_ri;
	unsigned int inv_fr;
	bool access_32b;
	bool oversampling;
	bool dma_threshold;
	bool cts_event_workaround;
	bool always_enabled;
	bool fixed_options;
	unsigned int (*get_fifosize)(struct amba_device *);
};

struct pl011_sgbuf {
	struct scatterlist sg;
	char *buf;
};

struct pl011_dmarx_data {
	struct dma_chan *chan;
	struct completion complete;
	bool use_buf_b;
	struct pl011_sgbuf sgbuf_a;
	struct pl011_sgbuf sgbuf_b;
	dma_cookie_t cookie;
	bool running;
	struct timer_list timer;
	unsigned int last_residue;
	long unsigned int last_jiffies;
	bool auto_poll_rate;
	unsigned int poll_rate;
	unsigned int poll_timeout;
};

struct pl011_dmatx_data {
	struct dma_chan *chan;
	struct scatterlist sg;
	char *buf;
	bool queued;
};

struct uart_amba_port {
	struct uart_port port;
	const u16 *reg_offset;
	struct clk *clk;
	const struct vendor_data___2 *vendor;
	unsigned int dmacr;
	unsigned int im;
	unsigned int old_status;
	unsigned int fifosize;
	unsigned int old_cr;
	unsigned int fixed_baud;
	char type[12];
	bool using_tx_dma;
	bool using_rx_dma;
	struct pl011_dmarx_data dmarx;
	struct pl011_dmatx_data dmatx;
	bool dma_probed;
};

struct spi_device_id {
	char name[32];
	kernel_ulong_t driver_data;
};

struct ptp_system_timestamp {
	struct timespec64 pre_ts;
	struct timespec64 post_ts;
};

struct spi_statistics {
	spinlock_t lock;
	long unsigned int messages;
	long unsigned int transfers;
	long unsigned int errors;
	long unsigned int timedout;
	long unsigned int spi_sync;
	long unsigned int spi_sync_immediate;
	long unsigned int spi_async;
	long long unsigned int bytes;
	long long unsigned int bytes_rx;
	long long unsigned int bytes_tx;
	long unsigned int transfer_bytes_histo[17];
	long unsigned int transfers_split_maxsize;
};

struct spi_delay {
	u16 value;
	u8 unit;
};

struct spi_controller;

struct spi_device {
	struct device dev;
	struct spi_controller *controller;
	struct spi_controller *master;
	u32 max_speed_hz;
	u8 chip_select;
	u8 bits_per_word;
	bool rt;
	u32 mode;
	int irq;
	void *controller_state;
	void *controller_data;
	char modalias[32];
	const char *driver_override;
	int cs_gpio;
	struct gpio_desc *cs_gpiod;
	struct spi_delay word_delay;
	struct spi_statistics statistics;
};

struct spi_message;

struct spi_transfer;

struct spi_controller_mem_ops;

struct spi_controller {
	struct device dev;
	struct list_head list;
	s16 bus_num;
	u16 num_chipselect;
	u16 dma_alignment;
	u32 mode_bits;
	u32 buswidth_override_bits;
	u32 bits_per_word_mask;
	u32 min_speed_hz;
	u32 max_speed_hz;
	u16 flags;
	bool devm_allocated;
	bool slave;
	size_t (*max_transfer_size)(struct spi_device *);
	size_t (*max_message_size)(struct spi_device *);
	struct mutex io_mutex;
	struct mutex add_lock;
	spinlock_t bus_lock_spinlock;
	struct mutex bus_lock_mutex;
	bool bus_lock_flag;
	int (*setup)(struct spi_device *);
	int (*set_cs_timing)(struct spi_device *, struct spi_delay *, struct spi_delay *, struct spi_delay *);
	int (*transfer)(struct spi_device *, struct spi_message *);
	void (*cleanup)(struct spi_device *);
	bool (*can_dma)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	bool queued;
	struct kthread_worker *kworker;
	struct kthread_work pump_messages;
	spinlock_t queue_lock;
	struct list_head queue;
	struct spi_message *cur_msg;
	bool idling;
	bool busy;
	bool running;
	bool rt;
	bool auto_runtime_pm;
	bool cur_msg_prepared;
	bool cur_msg_mapped;
	bool last_cs_enable;
	bool last_cs_mode_high;
	bool fallback;
	struct completion xfer_completion;
	size_t max_dma_len;
	int (*prepare_transfer_hardware)(struct spi_controller *);
	int (*transfer_one_message)(struct spi_controller *, struct spi_message *);
	int (*unprepare_transfer_hardware)(struct spi_controller *);
	int (*prepare_message)(struct spi_controller *, struct spi_message *);
	int (*unprepare_message)(struct spi_controller *, struct spi_message *);
	int (*slave_abort)(struct spi_controller *);
	void (*set_cs)(struct spi_device *, bool);
	int (*transfer_one)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	void (*handle_err)(struct spi_controller *, struct spi_message *);
	const struct spi_controller_mem_ops *mem_ops;
	struct spi_delay cs_setup;
	struct spi_delay cs_hold;
	struct spi_delay cs_inactive;
	int *cs_gpios;
	struct gpio_desc **cs_gpiods;
	bool use_gpio_descriptors;
	s8 unused_native_cs;
	s8 max_native_cs;
	struct spi_statistics statistics;
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	void *dummy_rx;
	void *dummy_tx;
	int (*fw_translate_cs)(struct spi_controller *, unsigned int);
	bool ptp_sts_supported;
	long unsigned int irq_flags;
};

struct spi_driver {
	const struct spi_device_id *id_table;
	int (*probe)(struct spi_device *);
	int (*remove)(struct spi_device *);
	void (*shutdown)(struct spi_device *);
	struct device_driver driver;
};

struct spi_message {
	struct list_head transfers;
	struct spi_device *spi;
	unsigned int is_dma_mapped: 1;
	void (*complete)(void *);
	void *context;
	unsigned int frame_length;
	unsigned int actual_length;
	int status;
	struct list_head queue;
	void *state;
	struct list_head resources;
};

struct spi_transfer {
	const void *tx_buf;
	void *rx_buf;
	unsigned int len;
	dma_addr_t tx_dma;
	dma_addr_t rx_dma;
	struct sg_table tx_sg;
	struct sg_table rx_sg;
	unsigned int dummy_data: 1;
	unsigned int cs_change: 1;
	unsigned int tx_nbits: 3;
	unsigned int rx_nbits: 3;
	u8 bits_per_word;
	struct spi_delay delay;
	struct spi_delay cs_change_delay;
	struct spi_delay word_delay;
	u32 speed_hz;
	u32 effective_speed_hz;
	unsigned int ptp_sts_word_pre;
	unsigned int ptp_sts_word_post;
	struct ptp_system_timestamp *ptp_sts;
	bool timestamped;
	struct list_head transfer_list;
	u16 error;
};

struct spi_mem;

struct spi_mem_op;

struct spi_mem_dirmap_desc;

struct spi_controller_mem_ops {
	int (*adjust_op_size)(struct spi_mem *, struct spi_mem_op *);
	bool (*supports_op)(struct spi_mem *, const struct spi_mem_op *);
	int (*exec_op)(struct spi_mem *, const struct spi_mem_op *);
	const char * (*get_name)(struct spi_mem *);
	int (*dirmap_create)(struct spi_mem_dirmap_desc *);
	void (*dirmap_destroy)(struct spi_mem_dirmap_desc *);
	ssize_t (*dirmap_read)(struct spi_mem_dirmap_desc *, u64, size_t, void *);
	ssize_t (*dirmap_write)(struct spi_mem_dirmap_desc *, u64, size_t, const void *);
};

struct max310x_devtype {
	char name[9];
	int nr;
	u8 mode1;
	int (*detect)(struct device *);
	void (*power)(struct uart_port *, int);
};

struct max310x_one {
	struct uart_port port;
	struct work_struct tx_work;
	struct work_struct md_work;
	struct work_struct rs_work;
	u8 wr_header;
	u8 rd_header;
	u8 rx_buf[128];
};

struct max310x_port {
	const struct max310x_devtype *devtype;
	struct regmap *regmap;
	struct clk *clk;
	struct gpio_chip gpio;
	struct max310x_one p[0];
};

enum imx_uart_type {
	IMX1_UART = 0,
	IMX21_UART = 1,
	IMX53_UART = 2,
	IMX6Q_UART = 3,
};

struct imx_uart_data {
	unsigned int uts_reg;
	enum imx_uart_type devtype;
};

enum imx_tx_state {
	OFF = 0,
	WAIT_AFTER_RTS = 1,
	SEND = 2,
	WAIT_AFTER_SEND = 3,
};

struct imx_port {
	struct uart_port port;
	struct timer_list timer;
	unsigned int old_status;
	unsigned int have_rtscts: 1;
	unsigned int have_rtsgpio: 1;
	unsigned int dte_mode: 1;
	unsigned int inverted_tx: 1;
	unsigned int inverted_rx: 1;
	struct clk *clk_ipg;
	struct clk *clk_per;
	const struct imx_uart_data *devdata;
	struct mctrl_gpios *gpios;
	unsigned int ucr1;
	unsigned int ucr2;
	unsigned int ucr3;
	unsigned int ucr4;
	unsigned int ufcr;
	unsigned int dma_is_enabled: 1;
	unsigned int dma_is_rxing: 1;
	unsigned int dma_is_txing: 1;
	struct dma_chan *dma_chan_rx;
	struct dma_chan *dma_chan_tx;
	struct scatterlist rx_sgl;
	struct scatterlist tx_sgl[2];
	void *rx_buf;
	struct circ_buf rx_ring;
	unsigned int rx_periods;
	dma_cookie_t rx_cookie;
	unsigned int tx_bytes;
	unsigned int dma_tx_nents;
	unsigned int saved_reg[10];
	bool context_saved;
	enum imx_tx_state tx_state;
	struct hrtimer trigger_start_tx;
	struct hrtimer trigger_stop_tx;
};

struct imx_port_ucrs {
	unsigned int ucr1;
	unsigned int ucr2;
	unsigned int ucr3;
};

struct sccnxp_pdata {
	const u8 reg_shift;
	const u32 mctrl_cfg[2];
	const unsigned int poll_time_us;
};

struct sccnxp_chip {
	const char *name;
	unsigned int nr;
	long unsigned int freq_min;
	long unsigned int freq_std;
	long unsigned int freq_max;
	unsigned int flags;
	unsigned int fifosize;
	unsigned int trwd;
};

struct sccnxp_port {
	struct uart_driver uart;
	struct uart_port port[2];
	bool opened[2];
	int irq;
	u8 imr;
	struct sccnxp_chip *chip;
	struct console console;
	spinlock_t lock;
	bool poll;
	struct timer_list timer;
	struct sccnxp_pdata pdata;
	struct regulator *regulator;
};

enum {
	UARTDM_1P1 = 1,
	UARTDM_1P2 = 2,
	UARTDM_1P3 = 3,
	UARTDM_1P4 = 4,
};

struct msm_dma {
	struct dma_chan *chan;
	enum dma_data_direction dir;
	dma_addr_t phys;
	unsigned char *virt;
	dma_cookie_t cookie;
	u32 enable_bit;
	unsigned int count;
	struct dma_async_tx_descriptor *desc;
};

struct msm_port {
	struct uart_port uart;
	char name[16];
	struct clk *clk;
	struct clk *pclk;
	unsigned int imr;
	int is_uartdm;
	unsigned int old_snap_state;
	bool break_detected;
	struct msm_dma tx_dma;
	struct msm_dma rx_dma;
};

struct msm_baud_map {
	u16 divisor;
	u8 code;
	u8 rxstale;
};

enum {
	UART_IRQ_SUM = 0,
	UART_RX_IRQ = 0,
	UART_TX_IRQ = 1,
	UART_IRQ_COUNT = 2,
};

struct uart_regs_layout {
	unsigned int rbr;
	unsigned int tsh;
	unsigned int ctrl;
	unsigned int intr;
};

struct uart_flags {
	unsigned int ctrl_tx_rdy_int;
	unsigned int ctrl_rx_rdy_int;
	unsigned int stat_tx_rdy;
	unsigned int stat_rx_rdy;
};

struct mvebu_uart_driver_data {
	bool is_ext;
	struct uart_regs_layout regs;
	struct uart_flags flags;
};

struct mvebu_uart_pm_regs {
	unsigned int rbr;
	unsigned int tsh;
	unsigned int ctrl;
	unsigned int intr;
	unsigned int stat;
	unsigned int brdv;
	unsigned int osamp;
};

struct mvebu_uart {
	struct uart_port *port;
	struct clk *clk;
	int irq[2];
	unsigned char *nb;
	struct mvebu_uart_driver_data *data;
	struct mvebu_uart_pm_regs pm_regs;
};

struct owl_uart_info {
	unsigned int tx_fifosize;
};

struct owl_uart_port {
	struct uart_port port;
	struct clk *clk;
};

enum mctrl_gpio_idx {
	UART_GPIO_CTS = 0,
	UART_GPIO_DSR = 1,
	UART_GPIO_DCD = 2,
	UART_GPIO_RNG = 3,
	UART_GPIO_RI = 3,
	UART_GPIO_RTS = 4,
	UART_GPIO_DTR = 5,
	UART_GPIO_MAX = 6,
};

struct mctrl_gpios___2 {
	struct uart_port *port;
	struct gpio_desc *gpio[6];
	int irq[6];
	unsigned int mctrl_prev;
	bool mctrl_on;
};

typedef unsigned char unchar;

struct kgdb_nmi_tty_priv {
	struct tty_port port;
	struct timer_list timer;
	struct {
		union {
			struct __kfifo kfifo;
			char *type;
			const char *const_type;
			char (*rectype)[0];
			char *ptr;
			const char *ptr_const;
		};
		char buf[64];
	} fifo;
};

struct serdev_device;

struct serdev_device_ops {
	int (*receive_buf)(struct serdev_device *, const unsigned char *, size_t);
	void (*write_wakeup)(struct serdev_device *);
};

struct serdev_controller;

struct serdev_device {
	struct device dev;
	int nr;
	struct serdev_controller *ctrl;
	const struct serdev_device_ops *ops;
	struct completion write_comp;
	struct mutex write_lock;
};

struct serdev_controller_ops;

struct serdev_controller {
	struct device dev;
	unsigned int nr;
	struct serdev_device *serdev;
	const struct serdev_controller_ops *ops;
};

struct serdev_device_driver {
	struct device_driver driver;
	int (*probe)(struct serdev_device *);
	void (*remove)(struct serdev_device *);
};

enum serdev_parity {
	SERDEV_PARITY_NONE = 0,
	SERDEV_PARITY_EVEN = 1,
	SERDEV_PARITY_ODD = 2,
};

struct serdev_controller_ops {
	int (*write_buf)(struct serdev_controller *, const unsigned char *, size_t);
	void (*write_flush)(struct serdev_controller *);
	int (*write_room)(struct serdev_controller *);
	int (*open)(struct serdev_controller *);
	void (*close)(struct serdev_controller *);
	void (*set_flow_control)(struct serdev_controller *, bool);
	int (*set_parity)(struct serdev_controller *, enum serdev_parity);
	unsigned int (*set_baudrate)(struct serdev_controller *, unsigned int);
	void (*wait_until_sent)(struct serdev_controller *, long int);
	int (*get_tiocm)(struct serdev_controller *);
	int (*set_tiocm)(struct serdev_controller *, unsigned int, unsigned int);
};

struct acpi_serdev_lookup {
	acpi_handle device_handle;
	acpi_handle controller_handle;
	int n;
	int index;
};

struct serport {
	struct tty_port *port;
	struct tty_struct *tty;
	struct tty_driver *tty_drv;
	int tty_idx;
	long unsigned int flags;
};

struct memdev {
	const char *name;
	umode_t mode;
	const struct file_operations *fops;
	fmode_t fmode;
};

struct timer_rand_state {
	cycles_t last_time;
	long int last_delta;
	long int last_delta2;
};

struct trace_event_raw_add_device_randomness {
	struct trace_entry ent;
	int bytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random__mix_pool_bytes {
	struct trace_entry ent;
	const char *pool_name;
	int bytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_credit_entropy_bits {
	struct trace_entry ent;
	const char *pool_name;
	int bits;
	int entropy_count;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_debit_entropy {
	struct trace_entry ent;
	const char *pool_name;
	int debit_bits;
	char __data[0];
};

struct trace_event_raw_add_input_randomness {
	struct trace_entry ent;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_add_disk_randomness {
	struct trace_entry ent;
	dev_t dev;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_random__get_random_bytes {
	struct trace_entry ent;
	int nbytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random__extract_entropy {
	struct trace_entry ent;
	const char *pool_name;
	int nbytes;
	int entropy_count;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_urandom_read {
	struct trace_entry ent;
	int got_bits;
	int pool_left;
	int input_left;
	char __data[0];
};

struct trace_event_raw_prandom_u32 {
	struct trace_entry ent;
	unsigned int ret;
	char __data[0];
};

struct trace_event_data_offsets_add_device_randomness {};

struct trace_event_data_offsets_random__mix_pool_bytes {};

struct trace_event_data_offsets_credit_entropy_bits {};

struct trace_event_data_offsets_debit_entropy {};

struct trace_event_data_offsets_add_input_randomness {};

struct trace_event_data_offsets_add_disk_randomness {};

struct trace_event_data_offsets_random__get_random_bytes {};

struct trace_event_data_offsets_random__extract_entropy {};

struct trace_event_data_offsets_urandom_read {};

struct trace_event_data_offsets_prandom_u32 {};

typedef void (*btf_trace_add_device_randomness)(void *, int, long unsigned int);

typedef void (*btf_trace_mix_pool_bytes)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_mix_pool_bytes_nolock)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_credit_entropy_bits)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_debit_entropy)(void *, const char *, int);

typedef void (*btf_trace_add_input_randomness)(void *, int);

typedef void (*btf_trace_add_disk_randomness)(void *, dev_t, int);

typedef void (*btf_trace_get_random_bytes)(void *, int, long unsigned int);

typedef void (*btf_trace_get_random_bytes_arch)(void *, int, long unsigned int);

typedef void (*btf_trace_extract_entropy)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_urandom_read)(void *, int, int, int);

typedef void (*btf_trace_prandom_u32)(void *, unsigned int);

struct poolinfo {
	int poolbitshift;
	int poolwords;
	int poolbytes;
	int poolfracbits;
	int tap1;
	int tap2;
	int tap3;
	int tap4;
	int tap5;
};

struct crng_state {
	__u32 state[16];
	long unsigned int init_time;
	spinlock_t lock;
};

struct entropy_store {
	const struct poolinfo *poolinfo;
	__u32 *pool;
	const char *name;
	spinlock_t lock;
	short unsigned int add_ptr;
	short unsigned int input_rotate;
	int entropy_count;
	unsigned int last_data_init: 1;
	__u8 last_data[10];
};

struct fast_pool {
	__u32 pool[4];
	long unsigned int last;
	short unsigned int reg_idx;
	unsigned char count;
};

struct batched_entropy {
	union {
		u64 entropy_u64[8];
		u32 entropy_u32[16];
	};
	unsigned int position;
	spinlock_t batch_lock;
};

struct ttyprintk_port {
	struct tty_port port;
	spinlock_t spinlock;
};

struct console___2;

struct kgdb_io___2 {
	const char *name;
	int (*read_char)();
	void (*write_char)(u8);
	void (*flush)();
	int (*init)();
	void (*deinit)();
	void (*pre_exception)();
	void (*post_exception)();
	struct console___2 *cons;
};

struct console___2 {
	struct list_head list;
	struct hvc_struct *hvc;
	struct winsize ws;
	u32 vtermno;
};

struct virtio_console_config {
	__virtio16 cols;
	__virtio16 rows;
	__virtio32 max_nr_ports;
	__virtio32 emerg_wr;
};

struct virtio_console_control {
	__virtio32 id;
	__virtio16 event;
	__virtio16 value;
};

struct ports_driver_data {
	struct class *class;
	struct dentry *debugfs_dir;
	struct list_head portdevs;
	unsigned int next_vtermno;
	struct list_head consoles;
};

struct port_buffer {
	char *buf;
	size_t size;
	size_t len;
	size_t offset;
	dma_addr_t dma;
	struct device *dev;
	struct list_head list;
	unsigned int sgpages;
	struct scatterlist sg[0];
};

struct ports_device {
	struct list_head list;
	struct work_struct control_work;
	struct work_struct config_work;
	struct list_head ports;
	spinlock_t ports_lock;
	spinlock_t c_ivq_lock;
	spinlock_t c_ovq_lock;
	u32 max_nr_ports;
	struct virtio_device *vdev;
	struct virtqueue *c_ivq;
	struct virtqueue *c_ovq;
	struct virtio_console_control cpkt;
	struct virtqueue **in_vqs;
	struct virtqueue **out_vqs;
	int chr_major;
};

struct port_stats {
	long unsigned int bytes_sent;
	long unsigned int bytes_received;
	long unsigned int bytes_discarded;
};

struct port {
	struct list_head list;
	struct ports_device *portdev;
	struct port_buffer *inbuf;
	spinlock_t inbuf_lock;
	spinlock_t outvq_lock;
	struct virtqueue *in_vq;
	struct virtqueue *out_vq;
	struct dentry *debugfs_file;
	struct port_stats stats;
	struct console___2 cons;
	struct cdev *cdev;
	struct device *dev;
	struct kref kref;
	wait_queue_head_t waitqueue;
	char *name;
	struct fasync_struct *async_queue;
	u32 id;
	bool outvq_full;
	bool host_connected;
	bool guest_connected;
};

struct sg_list {
	unsigned int n;
	unsigned int size;
	size_t len;
	struct scatterlist *sg;
};

enum tpm2_startup_types {
	TPM2_SU_CLEAR = 0,
	TPM2_SU_STATE = 1,
};

enum tpm_chip_flags {
	TPM_CHIP_FLAG_TPM2 = 2,
	TPM_CHIP_FLAG_IRQ = 4,
	TPM_CHIP_FLAG_VIRTUAL = 8,
	TPM_CHIP_FLAG_HAVE_TIMEOUTS = 16,
	TPM_CHIP_FLAG_ALWAYS_POWERED = 32,
	TPM_CHIP_FLAG_FIRMWARE_POWER_MANAGED = 64,
};

struct file_priv {
	struct tpm_chip *chip;
	struct tpm_space *space;
	struct mutex buffer_mutex;
	struct timer_list user_read_timer;
	struct work_struct timeout_work;
	struct work_struct async_work;
	wait_queue_head_t async_wait;
	ssize_t response_length;
	bool response_read;
	bool command_enqueued;
	u8 data_buffer[4096];
};

enum TPM_OPS_FLAGS {
	TPM_OPS_AUTO_STARTUP = 1,
};

enum tpm2_timeouts {
	TPM2_TIMEOUT_A = 750,
	TPM2_TIMEOUT_B = 2000,
	TPM2_TIMEOUT_C = 200,
	TPM2_TIMEOUT_D = 30,
	TPM2_DURATION_SHORT = 20,
	TPM2_DURATION_MEDIUM = 750,
	TPM2_DURATION_LONG = 2000,
	TPM2_DURATION_LONG_LONG = 300000,
	TPM2_DURATION_DEFAULT = 120000,
};

enum tpm_timeout {
	TPM_TIMEOUT = 5,
	TPM_TIMEOUT_RETRY = 100,
	TPM_TIMEOUT_RANGE_US = 300,
	TPM_TIMEOUT_POLL = 1,
	TPM_TIMEOUT_USECS_MIN = 100,
	TPM_TIMEOUT_USECS_MAX = 500,
};

struct stclear_flags_t {
	__be16 tag;
	u8 deactivated;
	u8 disableForceClear;
	u8 physicalPresence;
	u8 physicalPresenceLock;
	u8 bGlobalLock;
} __attribute__((packed));

struct tpm1_version {
	u8 major;
	u8 minor;
	u8 rev_major;
	u8 rev_minor;
};

struct tpm1_version2 {
	__be16 tag;
	struct tpm1_version version;
};

struct timeout_t {
	__be32 a;
	__be32 b;
	__be32 c;
	__be32 d;
};

struct duration_t {
	__be32 tpm_short;
	__be32 tpm_medium;
	__be32 tpm_long;
};

struct permanent_flags_t {
	__be16 tag;
	u8 disable;
	u8 ownership;
	u8 deactivated;
	u8 readPubek;
	u8 disableOwnerClear;
	u8 allowMaintenance;
	u8 physicalPresenceLifetimeLock;
	u8 physicalPresenceHWEnable;
	u8 physicalPresenceCMDEnable;
	u8 CEKPUsed;
	u8 TPMpost;
	u8 TPMpostLock;
	u8 FIPS;
	u8 operator;
	u8 enableRevokeEK;
	u8 nvLocked;
	u8 readSRKPub;
	u8 tpmEstablished;
	u8 maintenanceDone;
	u8 disableFullDALogicInfo;
};

typedef union {
	struct permanent_flags_t perm_flags;
	struct stclear_flags_t stclear_flags;
	__u8 owned;
	__be32 num_pcrs;
	struct tpm1_version version1;
	struct tpm1_version2 version2;
	__be32 manufacturer_id;
	struct timeout_t timeout;
	struct duration_t duration;
} cap_t;

enum tpm_capabilities {
	TPM_CAP_FLAG = 4,
	TPM_CAP_PROP = 5,
	TPM_CAP_VERSION_1_1 = 6,
	TPM_CAP_VERSION_1_2 = 26,
};

enum tpm_sub_capabilities {
	TPM_CAP_PROP_PCR = 257,
	TPM_CAP_PROP_MANUFACTURER = 259,
	TPM_CAP_FLAG_PERM = 264,
	TPM_CAP_FLAG_VOL = 265,
	TPM_CAP_PROP_OWNER = 273,
	TPM_CAP_PROP_TIS_TIMEOUT = 277,
	TPM_CAP_PROP_TIS_DURATION = 288,
};

struct tpm1_get_random_out {
	__be32 rng_data_len;
	u8 rng_data[128];
};

enum tpm2_const {
	TPM2_PLATFORM_PCR = 24,
	TPM2_PCR_SELECT_MIN = 3,
};

enum tpm2_capabilities {
	TPM2_CAP_HANDLES = 1,
	TPM2_CAP_COMMANDS = 2,
	TPM2_CAP_PCRS = 5,
	TPM2_CAP_TPM_PROPERTIES = 6,
};

enum tpm2_properties {
	TPM_PT_TOTAL_COMMANDS = 297,
};

enum tpm2_cc_attrs {
	TPM2_CC_ATTR_CHANDLES = 25,
	TPM2_CC_ATTR_RHANDLE = 28,
};

struct tpm2_pcr_read_out {
	__be32 update_cnt;
	__be32 pcr_selects_cnt;
	__be16 hash_alg;
	u8 pcr_select_size;
	u8 pcr_select[3];
	__be32 digests_cnt;
	__be16 digest_size;
	u8 digest[0];
} __attribute__((packed));

struct tpm2_null_auth_area {
	__be32 handle;
	__be16 nonce_size;
	u8 attributes;
	__be16 auth_size;
} __attribute__((packed));

struct tpm2_get_random_out {
	__be16 size;
	u8 buffer[128];
};

struct tpm2_get_cap_out {
	u8 more_data;
	__be32 subcap_id;
	__be32 property_cnt;
	__be32 property_id;
	__be32 value;
} __attribute__((packed));

struct tpm2_pcr_selection {
	__be16 hash_alg;
	u8 size_of_select;
	u8 pcr_select[3];
};

struct tpmrm_priv {
	struct file_priv priv;
	struct tpm_space space;
};

enum tpm2_handle_types {
	TPM2_HT_HMAC_SESSION = 33554432,
	TPM2_HT_POLICY_SESSION = 50331648,
	TPM2_HT_TRANSIENT = 2147483648,
};

struct tpm2_context {
	__be64 sequence;
	__be32 saved_handle;
	__be32 hierarchy;
	__be16 blob_size;
} __attribute__((packed));

struct tpm2_cap_handles {
	u8 more_data;
	__be32 capability;
	__be32 count;
	__be32 handles[0];
} __attribute__((packed));

struct tpm_readpubek_out {
	u8 algorithm[4];
	u8 encscheme[2];
	u8 sigscheme[2];
	__be32 paramsize;
	u8 parameters[12];
	__be32 keysize;
	u8 modulus[256];
	u8 checksum[20];
};

struct tpm_pcr_attr {
	int alg_id;
	int pcr;
	struct device_attribute attr;
};

struct tcpa_event {
	u32 pcr_index;
	u32 event_type;
	u8 pcr_value[20];
	u32 event_size;
	u8 event_data[0];
};

enum tcpa_event_types {
	PREBOOT = 0,
	POST_CODE = 1,
	UNUSED = 2,
	NO_ACTION = 3,
	SEPARATOR = 4,
	ACTION = 5,
	EVENT_TAG = 6,
	SCRTM_CONTENTS = 7,
	SCRTM_VERSION = 8,
	CPU_MICROCODE = 9,
	PLATFORM_CONFIG_FLAGS = 10,
	TABLE_OF_DEVICES = 11,
	COMPACT_HASH = 12,
	IPL = 13,
	IPL_PARTITION_DATA = 14,
	NONHOST_CODE = 15,
	NONHOST_CONFIG = 16,
	NONHOST_INFO = 17,
};

struct tcpa_pc_event {
	u32 event_id;
	u32 event_size;
	u8 event_data[0];
};

enum tcpa_pc_event_ids {
	SMBIOS = 1,
	BIS_CERT = 2,
	POST_BIOS_ROM = 3,
	ESCD = 4,
	CMOS = 5,
	NVRAM = 6,
	OPTION_ROM_EXEC = 7,
	OPTION_ROM_CONFIG = 8,
	OPTION_ROM_MICROCODE = 10,
	S_CRTM_VERSION = 11,
	S_CRTM_CONTENTS = 12,
	POST_CONTENTS = 13,
	HOST_TABLE_OF_DEVICES = 14,
};

struct tcg_efi_specid_event_algs {
	u16 alg_id;
	u16 digest_size;
};

struct tcg_efi_specid_event_head {
	u8 signature[16];
	u32 platform_class;
	u8 spec_version_minor;
	u8 spec_version_major;
	u8 spec_errata;
	u8 uintnsize;
	u32 num_algs;
	struct tcg_efi_specid_event_algs digest_sizes[0];
};

struct tcg_pcr_event {
	u32 pcr_idx;
	u32 event_type;
	u8 digest[20];
	u32 event_size;
	u8 event[0];
};

struct tcg_event_field {
	u32 event_size;
	u8 event[0];
};

struct tcg_pcr_event2_head {
	u32 pcr_idx;
	u32 event_type;
	u32 count;
	struct tpm_digest digests[0];
};

struct acpi_table_tpm2 {
	struct acpi_table_header header;
	u16 platform_class;
	u16 reserved;
	u64 control_address;
	u32 start_method;
} __attribute__((packed));

struct acpi_tpm2_phy {
	u8 start_method_specific[12];
	u32 log_area_minimum_length;
	u64 log_area_start_address;
};

enum bios_platform_class {
	BIOS_CLIENT = 0,
	BIOS_SERVER = 1,
};

struct client_hdr {
	u32 log_max_len;
	u64 log_start_addr;
} __attribute__((packed));

struct server_hdr {
	u16 reserved;
	u64 log_max_len;
	u64 log_start_addr;
} __attribute__((packed));

struct acpi_tcpa {
	struct acpi_table_header hdr;
	u16 platform_class;
	union {
		struct client_hdr client;
		struct server_hdr server;
	};
} __attribute__((packed));

struct linux_efi_tpm_eventlog {
	u32 size;
	u32 final_events_preboot_size;
	u8 version;
	u8 log[0];
};

struct efi_tcg2_final_events_table {
	u64 version;
	u64 nr_events;
	u8 events[0];
};

enum tis_access {
	TPM_ACCESS_VALID = 128,
	TPM_ACCESS_ACTIVE_LOCALITY = 32,
	TPM_ACCESS_REQUEST_PENDING = 4,
	TPM_ACCESS_REQUEST_USE = 2,
};

enum tis_status {
	TPM_STS_VALID = 128,
	TPM_STS_COMMAND_READY = 64,
	TPM_STS_GO = 32,
	TPM_STS_DATA_AVAIL = 16,
	TPM_STS_DATA_EXPECT = 8,
	TPM_STS_READ_ZERO = 35,
};

enum tis_int_flags {
	TPM_GLOBAL_INT_ENABLE = 2147483648,
	TPM_INTF_BURST_COUNT_STATIC = 256,
	TPM_INTF_CMD_READY_INT = 128,
	TPM_INTF_INT_EDGE_FALLING = 64,
	TPM_INTF_INT_EDGE_RISING = 32,
	TPM_INTF_INT_LEVEL_LOW = 16,
	TPM_INTF_INT_LEVEL_HIGH = 8,
	TPM_INTF_LOCALITY_CHANGE_INT = 4,
	TPM_INTF_STS_VALID_INT = 2,
	TPM_INTF_DATA_AVAIL_INT = 1,
};

enum tis_defaults {
	TIS_MEM_LEN = 20480,
	TIS_SHORT_TIMEOUT = 750,
	TIS_LONG_TIMEOUT = 2000,
	TIS_TIMEOUT_MIN_ATML = 14700,
	TIS_TIMEOUT_MAX_ATML = 15000,
};

enum tpm_tis_flags {
	TPM_TIS_ITPM_WORKAROUND = 1,
	TPM_TIS_INVALID_STATUS = 2,
};

struct tpm_tis_phy_ops;

struct tpm_tis_data {
	u16 manufacturer_id;
	int locality;
	int irq;
	bool irq_tested;
	long unsigned int flags;
	void *ilb_base_addr;
	u16 clkrun_enabled;
	wait_queue_head_t int_queue;
	wait_queue_head_t read_queue;
	const struct tpm_tis_phy_ops *phy_ops;
	short unsigned int rng_quality;
	unsigned int timeout_min;
	unsigned int timeout_max;
};

struct tpm_tis_phy_ops {
	int (*read_bytes)(struct tpm_tis_data *, u32, u16, u8 *);
	int (*write_bytes)(struct tpm_tis_data *, u32, u16, const u8 *);
	int (*read16)(struct tpm_tis_data *, u32, u16 *);
	int (*read32)(struct tpm_tis_data *, u32, u32 *);
	int (*write32)(struct tpm_tis_data *, u32, u32);
};

struct tis_vendor_durations_override {
	u32 did_vid;
	struct tpm1_version version;
	long unsigned int durations[3];
};

struct tis_vendor_timeout_override {
	u32 did_vid;
	long unsigned int timeout_us[4];
};

struct tpm_info {
	struct resource res;
	int irq;
};

struct tpm_tis_tcg_phy {
	struct tpm_tis_data priv;
	void *iobase;
};

enum crb_defaults {
	CRB_ACPI_START_REVISION_ID = 1,
	CRB_ACPI_START_INDEX = 1,
};

enum crb_loc_ctrl {
	CRB_LOC_CTRL_REQUEST_ACCESS = 1,
	CRB_LOC_CTRL_RELINQUISH = 2,
};

enum crb_loc_state {
	CRB_LOC_STATE_LOC_ASSIGNED = 2,
	CRB_LOC_STATE_TPM_REG_VALID_STS = 128,
};

enum crb_ctrl_req {
	CRB_CTRL_REQ_CMD_READY = 1,
	CRB_CTRL_REQ_GO_IDLE = 2,
};

enum crb_ctrl_sts {
	CRB_CTRL_STS_ERROR = 1,
	CRB_CTRL_STS_TPM_IDLE = 2,
};

enum crb_start {
	CRB_START_INVOKE = 1,
};

enum crb_cancel {
	CRB_CANCEL_INVOKE = 1,
};

struct crb_regs_head {
	u32 loc_state;
	u32 reserved1;
	u32 loc_ctrl;
	u32 loc_sts;
	u8 reserved2[32];
	u64 intf_id;
	u64 ctrl_ext;
};

struct crb_regs_tail {
	u32 ctrl_req;
	u32 ctrl_sts;
	u32 ctrl_cancel;
	u32 ctrl_start;
	u32 ctrl_int_enable;
	u32 ctrl_int_sts;
	u32 ctrl_cmd_size;
	u32 ctrl_cmd_pa_low;
	u32 ctrl_cmd_pa_high;
	u32 ctrl_rsp_size;
	u64 ctrl_rsp_pa;
};

enum crb_status {
	CRB_DRV_STS_COMPLETE = 1,
};

struct crb_priv {
	u32 sm;
	const char *hid;
	struct crb_regs_head *regs_h;
	struct crb_regs_tail *regs_t;
	u8 *cmd;
	u8 *rsp;
	u32 cmd_size;
	u32 smc_func_id;
};

struct tpm2_crb_smc {
	u32 interrupt;
	u8 interrupt_flags;
	u8 op_flags;
	u16 reserved2;
	u32 smc_func_id;
};

enum io_pgtable_fmt {
	ARM_32_LPAE_S1 = 0,
	ARM_32_LPAE_S2 = 1,
	ARM_64_LPAE_S1 = 2,
	ARM_64_LPAE_S2 = 3,
	ARM_V7S = 4,
	ARM_MALI_LPAE = 5,
	AMD_IOMMU_V1 = 6,
	IO_PGTABLE_NUM_FMTS = 7,
};

struct iommu_flush_ops {
	void (*tlb_flush_all)(void *);
	void (*tlb_flush_walk)(long unsigned int, size_t, size_t, void *);
	void (*tlb_add_page)(struct iommu_iotlb_gather *, long unsigned int, size_t, void *);
};

struct io_pgtable_cfg {
	long unsigned int quirks;
	long unsigned int pgsize_bitmap;
	unsigned int ias;
	unsigned int oas;
	bool coherent_walk;
	const struct iommu_flush_ops *tlb;
	struct device *iommu_dev;
	union {
		struct {
			u64 ttbr;
			struct {
				u32 ips: 3;
				u32 tg: 2;
				u32 sh: 2;
				u32 orgn: 2;
				u32 irgn: 2;
				u32 tsz: 6;
			} tcr;
			u64 mair;
		} arm_lpae_s1_cfg;
		struct {
			u64 vttbr;
			struct {
				u32 ps: 3;
				u32 tg: 2;
				u32 sh: 2;
				u32 orgn: 2;
				u32 irgn: 2;
				u32 sl: 2;
				u32 tsz: 6;
			} vtcr;
		} arm_lpae_s2_cfg;
		struct {
			u32 ttbr;
			u32 tcr;
			u32 nmrr;
			u32 prrr;
		} arm_v7s_cfg;
		struct {
			u64 transtab;
			u64 memattr;
		} arm_mali_lpae_cfg;
	};
};

struct io_pgtable_ops {
	int (*map)(struct io_pgtable_ops *, long unsigned int, phys_addr_t, size_t, int, gfp_t);
	size_t (*unmap)(struct io_pgtable_ops *, long unsigned int, size_t, struct iommu_iotlb_gather *);
	phys_addr_t (*iova_to_phys)(struct io_pgtable_ops *, long unsigned int);
};

struct io_pgtable {
	enum io_pgtable_fmt fmt;
	void *cookie;
	struct io_pgtable_cfg cfg;
	struct io_pgtable_ops ops;
};

struct io_pgtable_init_fns {
	struct io_pgtable * (*alloc)(struct io_pgtable_cfg *, void *);
	void (*free)(struct io_pgtable *);
};

enum qcom_iommu_clk {
	CLK_IFACE = 0,
	CLK_BUS = 1,
	CLK_TBU = 2,
	CLK_NUM = 3,
};

struct qcom_iommu_ctx;

struct qcom_iommu_dev {
	struct iommu_device iommu;
	struct device *dev;
	struct clk_bulk_data clks[3];
	void *local_base;
	u32 sec_id;
	u8 num_ctxs;
	struct qcom_iommu_ctx *ctxs[0];
};

struct qcom_iommu_ctx {
	struct device *dev;
	void *base;
	bool secure_init;
	u8 asid;
	struct iommu_domain *domain;
};

struct qcom_iommu_domain {
	struct io_pgtable_ops *pgtbl_ops;
	spinlock_t pgtbl_lock;
	struct mutex init_mutex;
	struct iommu_domain domain;
	struct qcom_iommu_dev *iommu;
	struct iommu_fwspec *fwspec;
};

enum arm_smmu_s2cr_privcfg {
	S2CR_PRIVCFG_DEFAULT = 0,
	S2CR_PRIVCFG_DIPAN = 1,
	S2CR_PRIVCFG_UNPRIV = 2,
	S2CR_PRIVCFG_PRIV = 3,
};

enum arm_smmu_s2cr_type {
	S2CR_TYPE_TRANS = 0,
	S2CR_TYPE_BYPASS = 1,
	S2CR_TYPE_FAULT = 2,
};

enum arm_smmu_cbar_type {
	CBAR_TYPE_S2_TRANS = 0,
	CBAR_TYPE_S1_TRANS_S2_BYPASS = 1,
	CBAR_TYPE_S1_TRANS_S2_FAULT = 2,
	CBAR_TYPE_S1_TRANS_S2_TRANS = 3,
};

enum arm_smmu_arch_version {
	ARM_SMMU_V1 = 0,
	ARM_SMMU_V1_64K = 1,
	ARM_SMMU_V2 = 2,
};

enum arm_smmu_implementation {
	GENERIC_SMMU = 0,
	ARM_MMU500 = 1,
	CAVIUM_SMMUV2 = 2,
	QCOM_SMMUV2 = 3,
};

struct arm_smmu_s2cr {
	struct iommu_group *group;
	int count;
	enum arm_smmu_s2cr_type type;
	enum arm_smmu_s2cr_privcfg privcfg;
	u8 cbndx;
};

struct arm_smmu_smr {
	u16 mask;
	u16 id;
	bool valid;
	bool pinned;
};

struct arm_smmu_impl;

struct arm_smmu_cb;

struct arm_smmu_device {
	struct device *dev;
	void *base;
	unsigned int numpage;
	unsigned int pgshift;
	u32 features;
	enum arm_smmu_arch_version version;
	enum arm_smmu_implementation model;
	const struct arm_smmu_impl *impl;
	u32 num_context_banks;
	u32 num_s2_context_banks;
	long unsigned int context_map[2];
	struct arm_smmu_cb *cbs;
	atomic_t irptndx;
	u32 num_mapping_groups;
	u16 streamid_mask;
	u16 smr_mask_mask;
	struct arm_smmu_smr *smrs;
	struct arm_smmu_s2cr *s2crs;
	struct mutex stream_map_mutex;
	long unsigned int va_size;
	long unsigned int ipa_size;
	long unsigned int pa_size;
	long unsigned int pgsize_bitmap;
	u32 num_global_irqs;
	u32 num_context_irqs;
	unsigned int *irqs;
	struct clk_bulk_data *clks;
	int num_clks;
	spinlock_t global_sync_lock;
	struct iommu_device iommu;
};

struct arm_smmu_domain;

struct arm_smmu_impl {
	u32 (*read_reg)(struct arm_smmu_device *, int, int);
	void (*write_reg)(struct arm_smmu_device *, int, int, u32);
	u64 (*read_reg64)(struct arm_smmu_device *, int, int);
	void (*write_reg64)(struct arm_smmu_device *, int, int, u64);
	int (*cfg_probe)(struct arm_smmu_device *);
	int (*reset)(struct arm_smmu_device *);
	int (*init_context)(struct arm_smmu_domain *, struct io_pgtable_cfg *, struct device *);
	void (*tlb_sync)(struct arm_smmu_device *, int, int, int);
	int (*def_domain_type)(struct device *);
	irqreturn_t (*global_fault)(int, void *);
	irqreturn_t (*context_fault)(int, void *);
	int (*alloc_context_bank)(struct arm_smmu_domain *, struct arm_smmu_device *, struct device *, int);
	void (*write_s2cr)(struct arm_smmu_device *, int);
	void (*write_sctlr)(struct arm_smmu_device *, int, u32);
};

struct arm_smmu_cfg;

struct arm_smmu_cb {
	u64 ttbr[2];
	u32 tcr[2];
	u32 mair[2];
	struct arm_smmu_cfg *cfg;
};

enum arm_smmu_context_fmt {
	ARM_SMMU_CTX_FMT_NONE = 0,
	ARM_SMMU_CTX_FMT_AARCH64 = 1,
	ARM_SMMU_CTX_FMT_AARCH32_L = 2,
	ARM_SMMU_CTX_FMT_AARCH32_S = 3,
};

struct arm_smmu_cfg {
	u8 cbndx;
	u8 irptndx;
	union {
		u16 asid;
		u16 vmid;
	};
	enum arm_smmu_cbar_type cbar;
	enum arm_smmu_context_fmt fmt;
};

enum arm_smmu_domain_stage {
	ARM_SMMU_DOMAIN_S1 = 0,
	ARM_SMMU_DOMAIN_S2 = 1,
	ARM_SMMU_DOMAIN_NESTED = 2,
	ARM_SMMU_DOMAIN_BYPASS = 3,
};

struct arm_smmu_domain {
	struct arm_smmu_device *smmu;
	struct io_pgtable_ops *pgtbl_ops;
	long unsigned int pgtbl_quirks;
	const struct iommu_flush_ops *flush_ops;
	struct arm_smmu_cfg cfg;
	enum arm_smmu_domain_stage stage;
	struct mutex init_mutex;
	spinlock_t cb_lock;
	struct iommu_domain domain;
};

struct arm_smmu_master_cfg {
	struct arm_smmu_device *smmu;
	s16 smendx[0];
};

struct arm_smmu_match_data {
	enum arm_smmu_arch_version version;
	enum arm_smmu_implementation model;
};

struct cavium_smmu {
	struct arm_smmu_device smmu;
	u32 id_base;
};

struct nvidia_smmu {
	struct arm_smmu_device smmu;
	void *bases[2];
};

struct adreno_smmu_priv {
	const void *cookie;
	const struct io_pgtable_cfg * (*get_ttbr1_cfg)(const void *);
	int (*set_ttbr0_cfg)(const void *, const struct io_pgtable_cfg *);
};

struct qcom_smmu {
	struct arm_smmu_device smmu;
	bool bypass_quirk;
	u8 bypass_cbndx;
};

enum pri_resp {
	PRI_RESP_DENY = 0,
	PRI_RESP_FAIL = 1,
	PRI_RESP_SUCC = 2,
};

struct arm_smmu_cmdq_ent {
	u8 opcode;
	bool substream_valid;
	union {
		struct {
			u32 sid;
		} prefetch;
		struct {
			u32 sid;
			u32 ssid;
			union {
				bool leaf;
				u8 span;
			};
		} cfgi;
		struct {
			u8 num;
			u8 scale;
			u16 asid;
			u16 vmid;
			bool leaf;
			u8 ttl;
			u8 tg;
			u64 addr;
		} tlbi;
		struct {
			u32 sid;
			u32 ssid;
			u64 addr;
			u8 size;
			bool global;
		} atc;
		struct {
			u32 sid;
			u32 ssid;
			u16 grpid;
			enum pri_resp resp;
		} pri;
		struct {
			u64 msiaddr;
		} sync;
	};
};

struct arm_smmu_ll_queue {
	union {
		u64 val;
		struct {
			u32 prod;
			u32 cons;
		};
		struct {
			atomic_t prod;
			atomic_t cons;
		} atomic;
		u8 __pad[64];
	};
	u32 max_n_shift;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct arm_smmu_queue {
	struct arm_smmu_ll_queue llq;
	int irq;
	__le64 *base;
	dma_addr_t base_dma;
	u64 q_base;
	size_t ent_dwords;
	u32 *prod_reg;
	u32 *cons_reg;
	long: 64;
};

struct arm_smmu_queue_poll {
	ktime_t timeout;
	unsigned int delay;
	unsigned int spin_cnt;
	bool wfe;
};

struct arm_smmu_cmdq {
	struct arm_smmu_queue q;
	atomic_long_t *valid_map;
	atomic_t owner_prod;
	atomic_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct arm_smmu_cmdq_batch {
	u64 cmds[128];
	int num;
};

struct arm_smmu_evtq {
	struct arm_smmu_queue q;
	u32 max_stalls;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct arm_smmu_priq {
	struct arm_smmu_queue q;
};

struct arm_smmu_strtab_l1_desc {
	u8 span;
	__le64 *l2ptr;
	dma_addr_t l2ptr_dma;
};

struct arm_smmu_ctx_desc {
	u16 asid;
	u64 ttbr;
	u64 tcr;
	u64 mair;
	refcount_t refs;
	struct mm_struct *mm;
};

struct arm_smmu_l1_ctx_desc {
	__le64 *l2ptr;
	dma_addr_t l2ptr_dma;
};

struct arm_smmu_ctx_desc_cfg {
	__le64 *cdtab;
	dma_addr_t cdtab_dma;
	struct arm_smmu_l1_ctx_desc *l1_desc;
	unsigned int num_l1_ents;
};

struct arm_smmu_s1_cfg {
	struct arm_smmu_ctx_desc_cfg cdcfg;
	struct arm_smmu_ctx_desc cd;
	u8 s1fmt;
	u8 s1cdmax;
};

struct arm_smmu_s2_cfg {
	u16 vmid;
	u64 vttbr;
	u64 vtcr;
};

struct arm_smmu_strtab_cfg {
	__le64 *strtab;
	dma_addr_t strtab_dma;
	struct arm_smmu_strtab_l1_desc *l1_desc;
	unsigned int num_l1_ents;
	u64 strtab_base;
	u32 strtab_base_cfg;
};

struct arm_smmu_device___2 {
	struct device *dev;
	void *base;
	void *page1;
	u32 features;
	u32 options;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct arm_smmu_cmdq cmdq;
	struct arm_smmu_evtq evtq;
	struct arm_smmu_priq priq;
	int gerr_irq;
	int combined_irq;
	long unsigned int ias;
	long unsigned int oas;
	long unsigned int pgsize_bitmap;
	unsigned int asid_bits;
	unsigned int vmid_bits;
	long unsigned int vmid_map[1024];
	unsigned int ssid_bits;
	unsigned int sid_bits;
	struct arm_smmu_strtab_cfg strtab_cfg;
	struct iommu_device iommu;
	struct rb_root streams;
	struct mutex streams_mutex;
	long: 64;
	long: 64;
};

struct arm_smmu_master;

struct arm_smmu_stream {
	u32 id;
	struct arm_smmu_master *master;
	struct rb_node node;
};

struct arm_smmu_domain___2;

struct arm_smmu_master {
	struct arm_smmu_device___2 *smmu;
	struct device *dev;
	struct arm_smmu_domain___2 *domain;
	struct list_head domain_head;
	struct arm_smmu_stream *streams;
	unsigned int num_streams;
	bool ats_enabled;
	bool sva_enabled;
	struct list_head bonds;
	unsigned int ssid_bits;
};

struct arm_smmu_domain___2 {
	struct arm_smmu_device___2 *smmu;
	struct mutex init_mutex;
	struct io_pgtable_ops *pgtbl_ops;
	atomic_t nr_ats_masters;
	enum arm_smmu_domain_stage stage;
	union {
		struct arm_smmu_s1_cfg s1_cfg;
		struct arm_smmu_s2_cfg s2_cfg;
	};
	struct iommu_domain domain;
	struct list_head devices;
	spinlock_t devices_lock;
	struct list_head mmu_notifiers;
};

enum arm_smmu_msi_index {
	EVTQ_MSI_INDEX = 0,
	GERROR_MSI_INDEX = 1,
	PRIQ_MSI_INDEX = 2,
	ARM_SMMU_MAX_MSIS = 3,
};

struct arm_smmu_option_prop {
	u32 opt;
	const char *prop;
};

struct arm_smmu_mmu_notifier {
	struct mmu_notifier mn;
	struct arm_smmu_ctx_desc *cd;
	bool cleared;
	refcount_t refs;
	struct list_head list;
	struct arm_smmu_domain___2 *domain;
};

struct arm_smmu_bond {
	struct iommu_sva sva;
	struct mm_struct *mm;
	struct arm_smmu_mmu_notifier *smmu_mn;
	struct list_head list;
	refcount_t refs;
};

struct iommu_group {
	struct kobject kobj;
	struct kobject *devices_kobj;
	struct list_head devices;
	struct mutex mutex;
	struct blocking_notifier_head notifier;
	void *iommu_data;
	void (*iommu_data_release)(void *);
	char *name;
	int id;
	struct iommu_domain *default_domain;
	struct iommu_domain *domain;
	struct list_head entry;
};

typedef unsigned int ioasid_t;

enum iommu_fault_type {
	IOMMU_FAULT_DMA_UNRECOV = 1,
	IOMMU_FAULT_PAGE_REQ = 2,
};

enum iommu_inv_granularity {
	IOMMU_INV_GRANU_DOMAIN = 0,
	IOMMU_INV_GRANU_PASID = 1,
	IOMMU_INV_GRANU_ADDR = 2,
	IOMMU_INV_GRANU_NR = 3,
};

struct group_device {
	struct list_head list;
	struct device *dev;
	char *name;
};

struct iommu_group_attribute {
	struct attribute attr;
	ssize_t (*show)(struct iommu_group *, char *);
	ssize_t (*store)(struct iommu_group *, const char *, size_t);
};

struct group_for_pci_data {
	struct pci_dev *pdev;
	struct iommu_group *group;
};

struct __group_domain_type {
	struct device *dev;
	unsigned int type;
};

struct trace_event_raw_iommu_group_event {
	struct trace_entry ent;
	int gid;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_iommu_device_event {
	struct trace_entry ent;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_map {
	struct trace_entry ent;
	u64 iova;
	u64 paddr;
	size_t size;
	char __data[0];
};

struct trace_event_raw_unmap {
	struct trace_entry ent;
	u64 iova;
	size_t size;
	size_t unmapped_size;
	char __data[0];
};

struct trace_event_raw_iommu_error {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u64 iova;
	int flags;
	char __data[0];
};

struct trace_event_data_offsets_iommu_group_event {
	u32 device;
};

struct trace_event_data_offsets_iommu_device_event {
	u32 device;
};

struct trace_event_data_offsets_map {};

struct trace_event_data_offsets_unmap {};

struct trace_event_data_offsets_iommu_error {
	u32 device;
	u32 driver;
};

typedef void (*btf_trace_add_device_to_group)(void *, int, struct device *);

typedef void (*btf_trace_remove_device_from_group)(void *, int, struct device *);

typedef void (*btf_trace_attach_device_to_domain)(void *, struct device *);

typedef void (*btf_trace_detach_device_from_domain)(void *, struct device *);

typedef void (*btf_trace_map)(void *, long unsigned int, phys_addr_t, size_t);

typedef void (*btf_trace_unmap)(void *, long unsigned int, size_t, size_t);

typedef void (*btf_trace_io_page_fault)(void *, struct device *, long unsigned int, int);

struct iova {
	struct rb_node node;
	long unsigned int pfn_hi;
	long unsigned int pfn_lo;
};

struct iova_magazine;

struct iova_cpu_rcache;

struct iova_rcache {
	spinlock_t lock;
	long unsigned int depot_size;
	struct iova_magazine *depot[32];
	struct iova_cpu_rcache *cpu_rcaches;
};

struct iova_domain;

typedef void (*iova_flush_cb)(struct iova_domain *);

typedef void (*iova_entry_dtor)(long unsigned int);

struct iova_fq;

struct iova_domain {
	spinlock_t iova_rbtree_lock;
	struct rb_root rbroot;
	struct rb_node *cached_node;
	struct rb_node *cached32_node;
	long unsigned int granule;
	long unsigned int start_pfn;
	long unsigned int dma_32bit_pfn;
	long unsigned int max32_alloc_size;
	struct iova_fq *fq;
	atomic64_t fq_flush_start_cnt;
	atomic64_t fq_flush_finish_cnt;
	struct iova anchor;
	struct iova_rcache rcaches[6];
	iova_flush_cb flush_cb;
	iova_entry_dtor entry_dtor;
	struct timer_list fq_timer;
	atomic_t fq_timer_on;
	struct hlist_node cpuhp_dead;
};

struct iova_fq_entry {
	long unsigned int iova_pfn;
	long unsigned int pages;
	long unsigned int data;
	u64 counter;
};

struct iova_fq {
	struct iova_fq_entry entries[256];
	unsigned int head;
	unsigned int tail;
	spinlock_t lock;
};

struct iommu_dma_msi_page {
	struct list_head list;
	dma_addr_t iova;
	phys_addr_t phys;
};

enum iommu_dma_cookie_type {
	IOMMU_DMA_IOVA_COOKIE = 0,
	IOMMU_DMA_MSI_COOKIE = 1,
};

struct iommu_dma_cookie {
	enum iommu_dma_cookie_type type;
	union {
		struct iova_domain iovad;
		dma_addr_t msi_iova;
	};
	struct list_head msi_page_list;
	struct iommu_domain *fq_domain;
};

struct arm_lpae_io_pgtable {
	struct io_pgtable iop;
	int pgd_bits;
	int start_level;
	int bits_per_level;
	void *pgd;
};

typedef u64 arm_lpae_iopte;

typedef ioasid_t (*ioasid_alloc_fn_t)(ioasid_t, ioasid_t, void *);

typedef void (*ioasid_free_fn_t)(ioasid_t, void *);

struct ioasid_set {
	int dummy;
};

struct ioasid_allocator_ops {
	ioasid_alloc_fn_t alloc;
	ioasid_free_fn_t free;
	struct list_head list;
	void *pdata;
};

struct ioasid_data {
	ioasid_t id;
	struct ioasid_set *set;
	void *private;
	struct callback_head rcu;
	refcount_t refs;
};

struct ioasid_allocator_data {
	struct ioasid_allocator_ops *ops;
	struct list_head list;
	struct list_head slist;
	long unsigned int flags;
	struct xarray xa;
	struct callback_head rcu;
};

struct iova_magazine {
	long unsigned int size;
	long unsigned int pfns[128];
};

struct iova_cpu_rcache {
	spinlock_t lock;
	struct iova_magazine *loaded;
	struct iova_magazine *prev;
};

struct of_pci_iommu_alias_info {
	struct device *dev;
	struct device_node *np;
};

struct rk_iommu_domain {
	struct list_head iommus;
	u32 *dt;
	dma_addr_t dt_dma;
	spinlock_t iommus_lock;
	spinlock_t dt_lock;
	struct iommu_domain domain;
};

struct rk_iommu {
	struct device *dev;
	void **bases;
	int num_mmu;
	int num_irq;
	struct clk_bulk_data *clocks;
	int num_clocks;
	bool reset_disabled;
	struct iommu_device iommu;
	struct list_head node;
	struct iommu_domain *domain;
	struct iommu_group *group;
};

struct rk_iommudata {
	struct device_link *link;
	struct rk_iommu *iommu;
};

struct sun50i_iommu {
	struct iommu_device iommu;
	spinlock_t iommu_lock;
	struct device *dev;
	void *base;
	struct reset_control *reset;
	struct clk *clk;
	struct iommu_domain *domain;
	struct iommu_group *group;
	struct kmem_cache *pt_pool;
};

struct sun50i_iommu_domain {
	struct iommu_domain domain;
	refcount_t refcnt;
	u32 *dt;
	dma_addr_t dt_dma;
	struct sun50i_iommu *iommu;
};

enum sun50i_iommu_aci {
	SUN50I_IOMMU_ACI_DO_NOT_USE = 0,
	SUN50I_IOMMU_ACI_NONE = 1,
	SUN50I_IOMMU_ACI_RD = 2,
	SUN50I_IOMMU_ACI_WR = 3,
	SUN50I_IOMMU_ACI_RD_WR = 4,
};

struct virtio_iommu_range_64 {
	__le64 start;
	__le64 end;
};

struct virtio_iommu_range_32 {
	__le32 start;
	__le32 end;
};

struct virtio_iommu_config {
	__le64 page_size_mask;
	struct virtio_iommu_range_64 input_range;
	struct virtio_iommu_range_32 domain_range;
	__le32 probe_size;
};

struct virtio_iommu_req_head {
	__u8 type;
	__u8 reserved[3];
};

struct virtio_iommu_req_tail {
	__u8 status;
	__u8 reserved[3];
};

struct virtio_iommu_req_attach {
	struct virtio_iommu_req_head head;
	__le32 domain;
	__le32 endpoint;
	__u8 reserved[8];
	struct virtio_iommu_req_tail tail;
};

struct virtio_iommu_req_map {
	struct virtio_iommu_req_head head;
	__le32 domain;
	__le64 virt_start;
	__le64 virt_end;
	__le64 phys_start;
	__le32 flags;
	struct virtio_iommu_req_tail tail;
};

struct virtio_iommu_req_unmap {
	struct virtio_iommu_req_head head;
	__le32 domain;
	__le64 virt_start;
	__le64 virt_end;
	__u8 reserved[4];
	struct virtio_iommu_req_tail tail;
};

struct virtio_iommu_probe_property {
	__le16 type;
	__le16 length;
};

struct virtio_iommu_probe_resv_mem {
	struct virtio_iommu_probe_property head;
	__u8 subtype;
	__u8 reserved[3];
	__le64 start;
	__le64 end;
};

struct virtio_iommu_req_probe {
	struct virtio_iommu_req_head head;
	__le32 endpoint;
	__u8 reserved[64];
	__u8 properties[0];
};

struct virtio_iommu_fault {
	__u8 reason;
	__u8 reserved[3];
	__le32 flags;
	__le32 endpoint;
	__u8 reserved2[4];
	__le64 address;
};

struct viommu_dev {
	struct iommu_device iommu;
	struct device *dev;
	struct virtio_device *vdev;
	struct ida domain_ids;
	struct virtqueue *vqs[2];
	spinlock_t request_lock;
	struct list_head requests;
	void *evts;
	struct iommu_domain_geometry geometry;
	u64 pgsize_bitmap;
	u32 first_domain;
	u32 last_domain;
	u32 map_flags;
	u32 probe_size;
};

struct viommu_mapping {
	phys_addr_t paddr;
	struct interval_tree_node iova;
	u32 flags;
};

struct viommu_domain {
	struct iommu_domain domain;
	struct viommu_dev *viommu;
	struct mutex mutex;
	unsigned int id;
	u32 map_flags;
	spinlock_t mappings_lock;
	struct rb_root_cached mappings;
	long unsigned int nr_endpoints;
};

struct viommu_endpoint {
	struct device *dev;
	struct viommu_dev *viommu;
	struct viommu_domain *vdomain;
	struct list_head resv_regions;
};

struct viommu_request {
	struct list_head list;
	void *writeback;
	unsigned int write_offset;
	unsigned int len;
	char buf[0];
};

struct viommu_event {
	union {
		u32 head;
		struct virtio_iommu_fault fault;
	};
};

enum iommu_page_response_code {
	IOMMU_PAGE_RESP_SUCCESS = 0,
	IOMMU_PAGE_RESP_INVALID = 1,
	IOMMU_PAGE_RESP_FAILURE = 2,
};

struct iopf_queue;

struct iopf_device_param {
	struct device *dev;
	struct iopf_queue *queue;
	struct list_head queue_list;
	struct list_head partial;
};

struct iopf_queue {
	struct workqueue_struct *wq;
	struct list_head devices;
	struct mutex lock;
};

struct iopf_fault {
	struct iommu_fault fault;
	struct list_head list;
};

struct iopf_group {
	struct iopf_fault last_fault;
	struct list_head faults;
	struct work_struct work;
	struct device *dev;
};

struct cb_id {
	__u32 idx;
	__u32 val;
};

struct cn_msg {
	struct cb_id id;
	__u32 seq;
	__u32 ack;
	__u16 len;
	__u16 flags;
	__u8 data[0];
};

struct cn_queue_dev {
	atomic_t refcnt;
	unsigned char name[32];
	struct list_head queue_list;
	spinlock_t queue_lock;
	struct sock *nls;
};

struct cn_callback_id {
	unsigned char name[32];
	struct cb_id id;
};

struct cn_callback_entry {
	struct list_head callback_entry;
	refcount_t refcnt;
	struct cn_queue_dev *pdev;
	struct cn_callback_id id;
	void (*callback)(struct cn_msg *, struct netlink_skb_parms *);
	u32 seq;
	u32 group;
};

struct cn_dev {
	struct cb_id id;
	u32 seq;
	u32 groups;
	struct sock *nls;
	struct cn_queue_dev *cbdev;
};

enum proc_cn_mcast_op {
	PROC_CN_MCAST_LISTEN = 1,
	PROC_CN_MCAST_IGNORE = 2,
};

struct fork_proc_event {
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
	__kernel_pid_t child_pid;
	__kernel_pid_t child_tgid;
};

struct exec_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
};

struct id_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	union {
		__u32 ruid;
		__u32 rgid;
	} r;
	union {
		__u32 euid;
		__u32 egid;
	} e;
};

struct sid_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
};

struct ptrace_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__kernel_pid_t tracer_pid;
	__kernel_pid_t tracer_tgid;
};

struct comm_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	char comm[16];
};

struct coredump_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
};

struct exit_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__u32 exit_code;
	__u32 exit_signal;
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
};

struct proc_event {
	enum what what;
	__u32 cpu;
	__u64 timestamp_ns;
	union {
		struct {
			__u32 err;
		} ack;
		struct fork_proc_event fork;
		struct exec_proc_event exec;
		struct id_proc_event id;
		struct sid_proc_event sid;
		struct ptrace_proc_event ptrace;
		struct comm_proc_event comm;
		struct coredump_proc_event coredump;
		struct exit_proc_event exit;
	} event_data;
};

struct local_event {
	local_lock_t lock;
	__u32 count;
};

struct nvm_ioctl_info_tgt {
	__u32 version[3];
	__u32 reserved;
	char tgtname[48];
};

struct nvm_ioctl_info {
	__u32 version[3];
	__u16 tgtsize;
	__u16 reserved16;
	__u32 reserved[12];
	struct nvm_ioctl_info_tgt tgts[63];
};

struct nvm_ioctl_device_info {
	char devname[32];
	char bmname[48];
	__u32 bmversion[3];
	__u32 flags;
	__u32 reserved[8];
};

struct nvm_ioctl_get_devices {
	__u32 nr_devices;
	__u32 reserved[31];
	struct nvm_ioctl_device_info info[31];
};

struct nvm_ioctl_create_simple {
	__u32 lun_begin;
	__u32 lun_end;
};

struct nvm_ioctl_create_extended {
	__u16 lun_begin;
	__u16 lun_end;
	__u16 op;
	__u16 rsv;
};

enum {
	NVM_CONFIG_TYPE_SIMPLE = 0,
	NVM_CONFIG_TYPE_EXTENDED = 1,
};

struct nvm_ioctl_create_conf {
	__u32 type;
	union {
		struct nvm_ioctl_create_simple s;
		struct nvm_ioctl_create_extended e;
	};
};

enum {
	NVM_TARGET_FACTORY = 1,
};

struct nvm_ioctl_create {
	char dev[32];
	char tgttype[48];
	char tgtname[32];
	__u32 flags;
	struct nvm_ioctl_create_conf conf;
};

struct nvm_ioctl_remove {
	char tgtname[32];
	__u32 flags;
};

struct nvm_ioctl_dev_init {
	char dev[32];
	char mmtype[8];
	__u32 flags;
};

enum {
	NVM_FACTORY_ERASE_ONLY_USER = 1,
	NVM_FACTORY_RESET_HOST_BLKS = 2,
	NVM_FACTORY_RESET_GRWN_BBLKS = 4,
	NVM_FACTORY_NR_BITS = 8,
};

struct nvm_ioctl_dev_factory {
	char dev[32];
	__u32 flags;
};

enum {
	NVM_INFO_CMD = 32,
	NVM_GET_DEVICES_CMD = 33,
	NVM_DEV_CREATE_CMD = 34,
	NVM_DEV_REMOVE_CMD = 35,
	NVM_DEV_INIT_CMD = 36,
	NVM_DEV_FACTORY_CMD = 37,
	NVM_DEV_VIO_ADMIN_CMD = 65,
	NVM_DEV_VIO_CMD = 66,
	NVM_DEV_VIO_USER_CMD = 67,
};

enum {
	NVM_OCSSD_SPEC_12 = 12,
	NVM_OCSSD_SPEC_20 = 20,
};

struct ppa_addr {
	union {
		struct {
			u64 ch: 8;
			u64 lun: 8;
			u64 blk: 16;
			u64 reserved: 32;
		} a;
		struct {
			u64 ch: 8;
			u64 lun: 8;
			u64 blk: 16;
			u64 pg: 16;
			u64 pl: 4;
			u64 sec: 4;
			u64 reserved: 8;
		} g;
		struct {
			u64 grp: 8;
			u64 pu: 8;
			u64 chk: 16;
			u64 sec: 24;
			u64 reserved: 8;
		} m;
		struct {
			u64 line: 63;
			u64 is_cached: 1;
		} c;
		u64 ppa;
	};
};

struct nvm_dev;

typedef int nvm_id_fn(struct nvm_dev *);

struct nvm_addrf {
	u8 ch_len;
	u8 lun_len;
	u8 chk_len;
	u8 sec_len;
	u8 rsv_len[2];
	u8 ch_offset;
	u8 lun_offset;
	u8 chk_offset;
	u8 sec_offset;
	u8 rsv_off[2];
	u64 ch_mask;
	u64 lun_mask;
	u64 chk_mask;
	u64 sec_mask;
	u64 rsv_mask[2];
};

struct nvm_geo {
	u8 major_ver_id;
	u8 minor_ver_id;
	u8 version;
	int num_ch;
	int num_lun;
	int all_luns;
	int all_chunks;
	int op;
	sector_t total_secs;
	u32 num_chk;
	u32 clba;
	u16 csecs;
	u16 sos;
	bool ext;
	u32 mdts;
	u32 ws_min;
	u32 ws_opt;
	u32 mw_cunits;
	u32 maxoc;
	u32 maxocpu;
	u32 mccap;
	u32 trdt;
	u32 trdm;
	u32 tprt;
	u32 tprm;
	u32 tbet;
	u32 tbem;
	struct nvm_addrf addrf;
	u8 vmnt;
	u32 cap;
	u32 dom;
	u8 mtype;
	u8 fmtype;
	u16 cpar;
	u32 mpos;
	u8 num_pln;
	u8 pln_mode;
	u16 num_pg;
	u16 fpg_sz;
};

struct nvm_dev_ops;

struct nvm_dev {
	struct nvm_dev_ops *ops;
	struct list_head devices;
	struct nvm_geo geo;
	long unsigned int *lun_map;
	void *dma_pool;
	struct request_queue *q;
	char name[32];
	void *private_data;
	struct kref ref;
	void *rmap;
	struct mutex mlock;
	spinlock_t lock;
	struct list_head area_list;
	struct list_head targets;
};

typedef int nvm_op_bb_tbl_fn(struct nvm_dev *, struct ppa_addr, u8 *);

typedef int nvm_op_set_bb_fn(struct nvm_dev *, struct ppa_addr *, int, int);

struct nvm_chk_meta;

typedef int nvm_get_chk_meta_fn(struct nvm_dev *, sector_t, int, struct nvm_chk_meta *);

struct nvm_chk_meta {
	u8 state;
	u8 type;
	u8 wi;
	u8 rsvd[5];
	u64 slba;
	u64 cnlb;
	u64 wp;
};

struct nvm_rq;

typedef int nvm_submit_io_fn(struct nvm_dev *, struct nvm_rq *, void *);

typedef void nvm_end_io_fn(struct nvm_rq *);

struct nvm_tgt_dev;

struct nvm_rq {
	struct nvm_tgt_dev *dev;
	struct bio *bio;
	union {
		struct ppa_addr ppa_addr;
		dma_addr_t dma_ppa_list;
	};
	struct ppa_addr *ppa_list;
	void *meta_list;
	dma_addr_t dma_meta_list;
	nvm_end_io_fn *end_io;
	uint8_t opcode;
	uint16_t nr_ppas;
	uint16_t flags;
	u64 ppa_status;
	int error;
	int is_seq;
	void *private;
};

typedef void *nvm_create_dma_pool_fn(struct nvm_dev *, char *, int);

typedef void nvm_destroy_dma_pool_fn(void *);

typedef void *nvm_dev_dma_alloc_fn(struct nvm_dev *, void *, gfp_t, dma_addr_t *);

typedef void nvm_dev_dma_free_fn(void *, void *, dma_addr_t);

struct nvm_dev_ops {
	nvm_id_fn *identity;
	nvm_op_bb_tbl_fn *get_bb_tbl;
	nvm_op_set_bb_fn *set_bb_tbl;
	nvm_get_chk_meta_fn *get_chk_meta;
	nvm_submit_io_fn *submit_io;
	nvm_create_dma_pool_fn *create_dma_pool;
	nvm_destroy_dma_pool_fn *destroy_dma_pool;
	nvm_dev_dma_alloc_fn *dev_dma_alloc;
	nvm_dev_dma_free_fn *dev_dma_free;
};

enum {
	NVM_RSP_L2P = 1,
	NVM_RSP_ECC = 2,
	NVM_ADDRMODE_LINEAR = 0,
	NVM_ADDRMODE_CHANNEL = 1,
	NVM_PLANE_SINGLE = 1,
	NVM_PLANE_DOUBLE = 2,
	NVM_PLANE_QUAD = 4,
	NVM_RSP_SUCCESS = 0,
	NVM_RSP_NOT_CHANGEABLE = 1,
	NVM_RSP_ERR_FAILWRITE = 16639,
	NVM_RSP_ERR_EMPTYPAGE = 17151,
	NVM_RSP_ERR_FAILECC = 17025,
	NVM_RSP_ERR_FAILCRC = 16388,
	NVM_RSP_WARN_HIGHECC = 18176,
	NVM_OP_PWRITE = 145,
	NVM_OP_PREAD = 146,
	NVM_OP_ERASE = 144,
	NVM_IO_SNGL_ACCESS = 0,
	NVM_IO_DUAL_ACCESS = 1,
	NVM_IO_QUAD_ACCESS = 2,
	NVM_IO_SUSPEND = 128,
	NVM_IO_SLC_MODE = 256,
	NVM_IO_SCRAMBLE_ENABLE = 512,
	NVM_BLK_T_FREE = 0,
	NVM_BLK_T_BAD = 1,
	NVM_BLK_T_GRWN_BAD = 2,
	NVM_BLK_T_DEV = 4,
	NVM_BLK_T_HOST = 8,
	NVM_ID_CAP_SLC = 1,
	NVM_ID_CAP_CMD_SUSPEND = 2,
	NVM_ID_CAP_SCRAMBLE = 4,
	NVM_ID_CAP_ENCRYPT = 8,
	NVM_ID_FMTYPE_SLC = 0,
	NVM_ID_FMTYPE_MLC = 1,
	NVM_ID_DCAP_BBLKMGMT = 1,
	NVM_UD_DCAP_ECC = 2,
};

struct nvm_addrf_12 {
	u8 ch_len;
	u8 lun_len;
	u8 blk_len;
	u8 pg_len;
	u8 pln_len;
	u8 sec_len;
	u8 ch_offset;
	u8 lun_offset;
	u8 blk_offset;
	u8 pg_offset;
	u8 pln_offset;
	u8 sec_offset;
	u64 ch_mask;
	u64 lun_mask;
	u64 blk_mask;
	u64 pg_mask;
	u64 pln_mask;
	u64 sec_mask;
};

enum {
	NVM_CHK_ST_FREE = 1,
	NVM_CHK_ST_CLOSED = 2,
	NVM_CHK_ST_OPEN = 4,
	NVM_CHK_ST_OFFLINE = 8,
	NVM_CHK_TP_W_SEQ = 1,
	NVM_CHK_TP_W_RAN = 2,
	NVM_CHK_TP_SZ_SPEC = 16,
};

struct nvm_tgt_type;

struct nvm_target {
	struct list_head list;
	struct nvm_tgt_dev *dev;
	struct nvm_tgt_type *type;
	struct gendisk *disk;
};

struct nvm_tgt_dev {
	struct nvm_geo geo;
	struct ppa_addr *luns;
	struct request_queue *q;
	struct nvm_dev *parent;
	void *map;
};

typedef sector_t nvm_tgt_capacity_fn(void *);

typedef void *nvm_tgt_init_fn(struct nvm_tgt_dev *, struct gendisk *, int);

typedef void nvm_tgt_exit_fn(void *, bool);

typedef int nvm_tgt_sysfs_init_fn(struct gendisk *);

typedef void nvm_tgt_sysfs_exit_fn(struct gendisk *);

struct nvm_tgt_type {
	const char *name;
	unsigned int version[3];
	int flags;
	const struct block_device_operations *bops;
	nvm_tgt_capacity_fn *capacity;
	nvm_tgt_init_fn *init;
	nvm_tgt_exit_fn *exit;
	nvm_tgt_sysfs_init_fn *sysfs_init;
	nvm_tgt_sysfs_exit_fn *sysfs_exit;
	struct list_head list;
	struct module *owner;
};

enum {
	NVM_TGT_F_DEV_L2P = 0,
	NVM_TGT_F_HOST_L2P = 1,
};

struct nvm_ch_map {
	int ch_off;
	int num_lun;
	int *lun_offs;
};

struct nvm_dev_map {
	struct nvm_ch_map *chnls;
	int num_ch;
};

struct component_ops {
	int (*bind)(struct device *, struct device *, void *);
	void (*unbind)(struct device *, struct device *, void *);
};

struct component_master_ops {
	int (*bind)(struct device *);
	void (*unbind)(struct device *);
};

struct component;

struct component_match_array {
	void *data;
	int (*compare)(struct device *, void *);
	int (*compare_typed)(struct device *, int, void *);
	void (*release)(struct device *, void *);
	struct component *component;
	bool duplicate;
};

struct master;

struct component {
	struct list_head node;
	struct master *master;
	bool bound;
	const struct component_ops *ops;
	int subcomponent;
	struct device *dev;
};

struct component_match {
	size_t alloc;
	size_t num;
	struct component_match_array *compare;
};

struct master {
	struct list_head node;
	bool bound;
	const struct component_master_ops *ops;
	struct device *dev;
	struct component_match *match;
};

struct fwnode_link {
	struct fwnode_handle *supplier;
	struct list_head s_hook;
	struct fwnode_handle *consumer;
	struct list_head c_hook;
};

struct wake_irq {
	struct device *dev;
	unsigned int status;
	int irq;
	const char *name;
};

enum dpm_order {
	DPM_ORDER_NONE = 0,
	DPM_ORDER_DEV_AFTER_PARENT = 1,
	DPM_ORDER_PARENT_BEFORE_DEV = 2,
	DPM_ORDER_DEV_LAST = 3,
};

struct subsys_private {
	struct kset subsys;
	struct kset *devices_kset;
	struct list_head interfaces;
	struct mutex mutex;
	struct kset *drivers_kset;
	struct klist klist_devices;
	struct klist klist_drivers;
	struct blocking_notifier_head bus_notifier;
	unsigned int drivers_autoprobe: 1;
	struct bus_type *bus;
	struct kset glue_dirs;
	struct class *class;
};

struct driver_private {
	struct kobject kobj;
	struct klist klist_devices;
	struct klist_node knode_bus;
	struct module_kobject *mkobj;
	struct device_driver *driver;
};

struct device_private {
	struct klist klist_children;
	struct klist_node knode_parent;
	struct klist_node knode_driver;
	struct klist_node knode_bus;
	struct klist_node knode_class;
	struct list_head deferred_probe;
	struct device_driver *async_driver;
	char *deferred_probe_reason;
	struct device *device;
	u8 dead: 1;
};

union device_attr_group_devres {
	const struct attribute_group *group;
	const struct attribute_group **groups;
};

struct class_dir {
	struct kobject kobj;
	struct class *class;
};

struct root_device {
	struct device dev;
	struct module *owner;
};

struct subsys_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

struct subsys_interface {
	const char *name;
	struct bus_type *subsys;
	struct list_head node;
	int (*add_dev)(struct device *, struct subsys_interface *);
	void (*remove_dev)(struct device *, struct subsys_interface *);
};

struct device_attach_data {
	struct device *dev;
	bool check_async;
	bool want_async;
	bool have_async;
};

struct class_attribute_string {
	struct class_attribute attr;
	char *str;
};

struct class_compat {
	struct kobject *kobj;
};

struct irq_affinity_devres {
	unsigned int count;
	unsigned int irq[0];
};

struct platform_object {
	struct platform_device pdev;
	char name[0];
};

struct cpu_attr {
	struct device_attribute attr;
	const struct cpumask * const map;
};

typedef struct kobject *kobj_probe_t(dev_t, int *, void *);

struct probe {
	struct probe *next;
	dev_t dev;
	long unsigned int range;
	struct module *owner;
	kobj_probe_t *get;
	int (*lock)(dev_t, void *);
	void *data;
};

struct kobj_map___2 {
	struct probe *probes[255];
	struct mutex *lock;
};

typedef int (*dr_match_t)(struct device *, void *, void *);

struct devres_node {
	struct list_head entry;
	dr_release_t release;
};

struct devres___2 {
	struct devres_node node;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 data[0];
};

struct devres_group {
	struct devres_node node[2];
	void *id;
	int color;
};

struct action_devres {
	void *data;
	void (*action)(void *);
};

struct pages_devres {
	long unsigned int addr;
	unsigned int order;
};

struct attribute_container {
	struct list_head node;
	struct klist containers;
	struct class *class;
	const struct attribute_group *grp;
	struct device_attribute **attrs;
	int (*match)(struct attribute_container *, struct device *);
	long unsigned int flags;
};

struct internal_container {
	struct klist_node node;
	struct attribute_container *cont;
	struct device classdev;
};

struct transport_container;

struct transport_class {
	struct class class;
	int (*setup)(struct transport_container *, struct device *, struct device *);
	int (*configure)(struct transport_container *, struct device *, struct device *);
	int (*remove)(struct transport_container *, struct device *, struct device *);
};

struct transport_container {
	struct attribute_container ac;
	const struct attribute_group *statistics;
};

struct anon_transport_class {
	struct transport_class tclass;
	struct attribute_container container;
};

typedef void * (*devcon_match_fn_t)(struct fwnode_handle *, const char *, void *);

struct cache_type_info {
	const char *size_prop;
	const char *line_size_props[2];
	const char *nr_sets_prop;
};

struct software_node_ref_args {
	const struct software_node *node;
	unsigned int nargs;
	u64 args[8];
};

struct swnode {
	struct kobject kobj;
	struct fwnode_handle fwnode;
	const struct software_node *node;
	int id;
	struct ida child_ids;
	struct list_head entry;
	struct list_head children;
	struct swnode *parent;
	unsigned int allocated: 1;
	unsigned int managed: 1;
};

struct auxiliary_device_id {
	char name[32];
	kernel_ulong_t driver_data;
};

struct auxiliary_device {
	struct device dev;
	const char *name;
	u32 id;
};

struct auxiliary_driver {
	int (*probe)(struct auxiliary_device *, const struct auxiliary_device_id *);
	void (*remove)(struct auxiliary_device *);
	void (*shutdown)(struct auxiliary_device *);
	int (*suspend)(struct auxiliary_device *, pm_message_t);
	int (*resume)(struct auxiliary_device *);
	const char *name;
	struct device_driver driver;
	const struct auxiliary_device_id *id_table;
};

struct req {
	struct req *next;
	struct completion done;
	int err;
	const char *name;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	struct device *dev;
};

typedef int (*pm_callback_t)(struct device *);

enum genpd_notication {
	GENPD_NOTIFY_PRE_OFF = 0,
	GENPD_NOTIFY_OFF = 1,
	GENPD_NOTIFY_PRE_ON = 2,
	GENPD_NOTIFY_ON = 3,
};

struct gpd_link {
	struct generic_pm_domain *parent;
	struct list_head parent_node;
	struct generic_pm_domain *child;
	struct list_head child_node;
	unsigned int performance_state;
	unsigned int prev_performance_state;
};

struct gpd_timing_data {
	s64 suspend_latency_ns;
	s64 resume_latency_ns;
	s64 effective_constraint_ns;
	bool constraint_changed;
	bool cached_suspend_ok;
};

struct generic_pm_domain_data {
	struct pm_domain_data base;
	struct gpd_timing_data td;
	struct notifier_block nb;
	struct notifier_block *power_nb;
	int cpu;
	unsigned int performance_state;
	ktime_t next_wakeup;
	void *data;
};

struct of_genpd_provider {
	struct list_head link;
	struct device_node *node;
	genpd_xlate_t xlate;
	void *data;
};

struct pm_clk_notifier_block {
	struct notifier_block nb;
	struct dev_pm_domain *pm_domain;
	char *con_ids[0];
};

enum pce_status {
	PCE_STATUS_NONE = 0,
	PCE_STATUS_ACQUIRED = 1,
	PCE_STATUS_PREPARED = 2,
	PCE_STATUS_ENABLED = 3,
	PCE_STATUS_ERROR = 4,
};

struct pm_clock_entry {
	struct list_head node;
	char *con_id;
	struct clk *clk;
	enum pce_status status;
	bool enabled_when_prepared;
};

struct firmware_fallback_config {
	unsigned int force_sysfs_fallback;
	unsigned int ignore_sysfs_fallback;
	int old_timeout;
	int loading_timeout;
};

struct builtin_fw {
	char *name;
	void *data;
	long unsigned int size;
};

enum fw_opt {
	FW_OPT_UEVENT = 1,
	FW_OPT_NOWAIT = 2,
	FW_OPT_USERHELPER = 4,
	FW_OPT_NO_WARN = 8,
	FW_OPT_NOCACHE = 16,
	FW_OPT_NOFALLBACK_SYSFS = 32,
	FW_OPT_FALLBACK_PLATFORM = 64,
	FW_OPT_PARTIAL = 128,
};

enum fw_status {
	FW_STATUS_UNKNOWN = 0,
	FW_STATUS_LOADING = 1,
	FW_STATUS_DONE = 2,
	FW_STATUS_ABORTED = 3,
};

struct fw_state {
	struct completion completion;
	enum fw_status status;
};

struct firmware_cache;

struct fw_priv {
	struct kref ref;
	struct list_head list;
	struct firmware_cache *fwc;
	struct fw_state fw_st;
	void *data;
	size_t size;
	size_t allocated_size;
	size_t offset;
	u32 opt_flags;
	bool is_paged_buf;
	struct page **pages;
	int nr_pages;
	int page_array_size;
	bool need_uevent;
	struct list_head pending_list;
	const char *fw_name;
};

struct firmware_cache {
	spinlock_t lock;
	struct list_head head;
	int state;
	spinlock_t name_lock;
	struct list_head fw_names;
	struct delayed_work work;
	struct notifier_block pm_notify;
};

struct fw_cache_entry {
	struct list_head list;
	const char *name;
};

struct fw_name_devm {
	long unsigned int magic;
	const char *name;
};

struct firmware_work {
	struct work_struct work;
	struct module *module;
	const char *name;
	struct device *device;
	void *context;
	void (*cont)(const struct firmware *, void *);
	u32 opt_flags;
};

struct fw_sysfs {
	bool nowait;
	struct device dev;
	struct fw_priv *fw_priv;
	struct firmware *fw;
};

typedef void (*node_registration_func_t)(struct node *);

typedef int (*walk_memory_blocks_func_t)(struct memory_block *, void *);

struct node_access_nodes {
	struct device dev;
	struct list_head list_node;
	unsigned int access;
	struct node_hmem_attrs hmem_attrs;
};

struct node_cache_info {
	struct device dev;
	struct list_head node;
	struct node_cache_attrs cache_attrs;
};

struct node_attr {
	struct device_attribute attr;
	enum node_states state;
};

struct for_each_memory_block_cb_data {
	walk_memory_blocks_func_t func;
	void *arg;
};

typedef int (*regmap_hw_write)(void *, const void *, size_t);

typedef int (*regmap_hw_gather_write)(void *, const void *, size_t, const void *, size_t);

struct regmap_async;

typedef int (*regmap_hw_async_write)(void *, const void *, size_t, const void *, size_t, struct regmap_async *);

struct regmap___2;

struct regmap_async {
	struct list_head list;
	struct regmap___2 *map;
	void *work_buf;
};

typedef int (*regmap_hw_read)(void *, const void *, size_t, void *, size_t);

typedef int (*regmap_hw_reg_read)(void *, unsigned int, unsigned int *);

typedef int (*regmap_hw_reg_write)(void *, unsigned int, unsigned int);

typedef int (*regmap_hw_reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);

typedef struct regmap_async * (*regmap_hw_async_alloc)();

typedef void (*regmap_hw_free_context)(void *);

struct regmap_bus {
	bool fast_io;
	regmap_hw_write write;
	regmap_hw_gather_write gather_write;
	regmap_hw_async_write async_write;
	regmap_hw_reg_write reg_write;
	regmap_hw_reg_update_bits reg_update_bits;
	regmap_hw_read read;
	regmap_hw_reg_read reg_read;
	regmap_hw_free_context free_context;
	regmap_hw_async_alloc async_alloc;
	u8 read_flag_mask;
	enum regmap_endian reg_format_endian_default;
	enum regmap_endian val_format_endian_default;
	size_t max_raw_read;
	size_t max_raw_write;
};

struct reg_field {
	unsigned int reg;
	unsigned int lsb;
	unsigned int msb;
	unsigned int id_size;
	unsigned int id_offset;
};

struct regmap_format {
	size_t buf_size;
	size_t reg_bytes;
	size_t pad_bytes;
	size_t val_bytes;
	void (*format_write)(struct regmap___2 *, unsigned int, unsigned int);
	void (*format_reg)(void *, unsigned int, unsigned int);
	void (*format_val)(void *, unsigned int, unsigned int);
	unsigned int (*parse_val)(const void *);
	void (*parse_inplace)(void *);
};

struct hwspinlock;

struct regcache_ops;

struct regmap___2 {
	union {
		struct mutex mutex;
		struct {
			spinlock_t spinlock;
			long unsigned int spinlock_flags;
		};
	};
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	gfp_t alloc_flags;
	struct device *dev;
	void *work_buf;
	struct regmap_format format;
	const struct regmap_bus *bus;
	void *bus_context;
	const char *name;
	bool async;
	spinlock_t async_lock;
	wait_queue_head_t async_waitq;
	struct list_head async_list;
	struct list_head async_free;
	int async_ret;
	bool debugfs_disable;
	struct dentry *debugfs;
	const char *debugfs_name;
	unsigned int debugfs_reg_len;
	unsigned int debugfs_val_len;
	unsigned int debugfs_tot_len;
	struct list_head debugfs_off_cache;
	struct mutex cache_lock;
	unsigned int max_register;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
	bool defer_caching;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	int reg_shift;
	int reg_stride;
	int reg_stride_order;
	const struct regcache_ops *cache_ops;
	enum regcache_type cache_type;
	unsigned int cache_size_raw;
	unsigned int cache_word_size;
	unsigned int num_reg_defaults;
	unsigned int num_reg_defaults_raw;
	bool cache_only;
	bool cache_bypass;
	bool cache_free;
	struct reg_default *reg_defaults;
	const void *reg_defaults_raw;
	void *cache;
	bool cache_dirty;
	bool no_sync_defaults;
	struct reg_sequence *patch;
	int patch_regs;
	bool use_single_read;
	bool use_single_write;
	bool can_multi_write;
	size_t max_raw_read;
	size_t max_raw_write;
	struct rb_root range_tree;
	void *selector_work_buf;
	struct hwspinlock *hwlock;
	bool can_sleep;
};

struct regcache_ops {
	const char *name;
	enum regcache_type type;
	int (*init)(struct regmap___2 *);
	int (*exit)(struct regmap___2 *);
	void (*debugfs_init)(struct regmap___2 *);
	int (*read)(struct regmap___2 *, unsigned int, unsigned int *);
	int (*write)(struct regmap___2 *, unsigned int, unsigned int);
	int (*sync)(struct regmap___2 *, unsigned int, unsigned int);
	int (*drop)(struct regmap___2 *, unsigned int, unsigned int);
};

struct regmap_range_node {
	struct rb_node node;
	const char *name;
	struct regmap___2 *map;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct regmap_field {
	struct regmap___2 *regmap;
	unsigned int mask;
	unsigned int shift;
	unsigned int reg;
	unsigned int id_size;
	unsigned int id_offset;
};

struct trace_event_raw_regmap_reg {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	unsigned int val;
	char __data[0];
};

struct trace_event_raw_regmap_block {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	int count;
	char __data[0];
};

struct trace_event_raw_regcache_sync {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_status;
	u32 __data_loc_type;
	char __data[0];
};

struct trace_event_raw_regmap_bool {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flag;
	char __data[0];
};

struct trace_event_raw_regmap_async {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regcache_drop_region {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int from;
	unsigned int to;
	char __data[0];
};

struct trace_event_data_offsets_regmap_reg {
	u32 name;
};

struct trace_event_data_offsets_regmap_block {
	u32 name;
};

struct trace_event_data_offsets_regcache_sync {
	u32 name;
	u32 status;
	u32 type;
};

struct trace_event_data_offsets_regmap_bool {
	u32 name;
};

struct trace_event_data_offsets_regmap_async {
	u32 name;
};

struct trace_event_data_offsets_regcache_drop_region {
	u32 name;
};

typedef void (*btf_trace_regmap_reg_write)(void *, struct regmap___2 *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read)(void *, struct regmap___2 *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read_cache)(void *, struct regmap___2 *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_hw_read_start)(void *, struct regmap___2 *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_read_done)(void *, struct regmap___2 *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_start)(void *, struct regmap___2 *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_done)(void *, struct regmap___2 *, unsigned int, int);

typedef void (*btf_trace_regcache_sync)(void *, struct regmap___2 *, const char *, const char *);

typedef void (*btf_trace_regmap_cache_only)(void *, struct regmap___2 *, bool);

typedef void (*btf_trace_regmap_cache_bypass)(void *, struct regmap___2 *, bool);

typedef void (*btf_trace_regmap_async_write_start)(void *, struct regmap___2 *, unsigned int, int);

typedef void (*btf_trace_regmap_async_io_complete)(void *, struct regmap___2 *);

typedef void (*btf_trace_regmap_async_complete_start)(void *, struct regmap___2 *);

typedef void (*btf_trace_regmap_async_complete_done)(void *, struct regmap___2 *);

typedef void (*btf_trace_regcache_drop_region)(void *, struct regmap___2 *, unsigned int, unsigned int);

struct regcache_rbtree_node {
	void *block;
	long int *cache_present;
	unsigned int base_reg;
	unsigned int blklen;
	struct rb_node node;
};

struct regcache_rbtree_ctx {
	struct rb_root root;
	struct regcache_rbtree_node *cached_rbnode;
};

struct regmap_debugfs_off_cache {
	struct list_head list;
	off_t min;
	off_t max;
	unsigned int base_reg;
	unsigned int max_reg;
};

struct regmap_debugfs_node {
	struct regmap___2 *map;
	struct list_head link;
};

struct regmap_async_spi {
	struct regmap_async core;
	struct spi_message m;
	struct spi_transfer t[2];
};

struct regmap_mmio_context {
	void *regs;
	unsigned int val_bytes;
	bool relaxed_mmio;
	bool attached_clk;
	struct clk *clk;
	void (*reg_write)(struct regmap_mmio_context *, unsigned int, unsigned int);
	unsigned int (*reg_read)(struct regmap_mmio_context *, unsigned int);
};

struct regmap_irq_type {
	unsigned int type_reg_offset;
	unsigned int type_reg_mask;
	unsigned int type_rising_val;
	unsigned int type_falling_val;
	unsigned int type_level_low_val;
	unsigned int type_level_high_val;
	unsigned int types_supported;
};

struct regmap_irq {
	unsigned int reg_offset;
	unsigned int mask;
	struct regmap_irq_type type;
};

struct regmap_irq_sub_irq_map {
	unsigned int num_regs;
	unsigned int *offset;
};

struct regmap_irq_chip {
	const char *name;
	unsigned int main_status;
	unsigned int num_main_status_bits;
	struct regmap_irq_sub_irq_map *sub_reg_offsets;
	int num_main_regs;
	unsigned int status_base;
	unsigned int mask_base;
	unsigned int unmask_base;
	unsigned int ack_base;
	unsigned int wake_base;
	unsigned int type_base;
	unsigned int *virt_reg_base;
	unsigned int irq_reg_stride;
	bool mask_writeonly: 1;
	bool init_ack_masked: 1;
	bool mask_invert: 1;
	bool use_ack: 1;
	bool ack_invert: 1;
	bool clear_ack: 1;
	bool wake_invert: 1;
	bool runtime_pm: 1;
	bool type_invert: 1;
	bool type_in_mask: 1;
	bool clear_on_unmask: 1;
	bool not_fixed_stride: 1;
	int num_regs;
	const struct regmap_irq *irqs;
	int num_irqs;
	int num_type_reg;
	int num_virt_regs;
	unsigned int type_reg_stride;
	int (*handle_pre_irq)(void *);
	int (*handle_post_irq)(void *);
	int (*set_type_virt)(unsigned int **, unsigned int, long unsigned int, int);
	void *irq_drv_data;
};

struct regmap_irq_chip_data___2 {
	struct mutex lock;
	struct irq_chip irq_chip;
	struct regmap___2 *map;
	const struct regmap_irq_chip *chip;
	int irq_base;
	struct irq_domain *domain;
	int irq;
	int wake_count;
	void *status_reg_buf;
	unsigned int *main_status_buf;
	unsigned int *status_buf;
	unsigned int *mask_buf;
	unsigned int *mask_buf_def;
	unsigned int *wake_buf;
	unsigned int *type_buf;
	unsigned int *type_buf_def;
	unsigned int **virt_buf;
	unsigned int irq_reg_stride;
	unsigned int type_reg_stride;
	bool clear_status: 1;
};

struct soc_device___2 {
	struct device dev;
	struct soc_device_attribute *attr;
	int soc_dev_num;
};

struct devcd_entry {
	struct device devcd_dev;
	void *data;
	size_t datalen;
	struct module *owner;
	ssize_t (*read)(char *, loff_t, size_t, void *, size_t);
	void (*free)(void *);
	struct delayed_work del_wk;
	struct device *failing_dev;
};

typedef void (*irq_write_msi_msg_t)(struct msi_desc *, struct msi_msg *);

struct platform_msi_priv_data {
	struct device *dev;
	void *host_data;
	msi_alloc_info_t arg;
	irq_write_msi_msg_t write_msg;
	int devid;
};

typedef unsigned int __kernel_old_dev_t;

enum {
	LO_FLAGS_READ_ONLY = 1,
	LO_FLAGS_AUTOCLEAR = 4,
	LO_FLAGS_PARTSCAN = 8,
	LO_FLAGS_DIRECT_IO = 16,
};

struct loop_info {
	int lo_number;
	__kernel_old_dev_t lo_device;
	long unsigned int lo_inode;
	__kernel_old_dev_t lo_rdevice;
	int lo_offset;
	int lo_encrypt_type;
	int lo_encrypt_key_size;
	int lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	long unsigned int lo_init[2];
	char reserved[4];
};

struct loop_info64 {
	__u64 lo_device;
	__u64 lo_inode;
	__u64 lo_rdevice;
	__u64 lo_offset;
	__u64 lo_sizelimit;
	__u32 lo_number;
	__u32 lo_encrypt_type;
	__u32 lo_encrypt_key_size;
	__u32 lo_flags;
	__u8 lo_file_name[64];
	__u8 lo_crypt_name[64];
	__u8 lo_encrypt_key[32];
	__u64 lo_init[2];
};

struct loop_config {
	__u32 fd;
	__u32 block_size;
	struct loop_info64 info;
	__u64 __reserved[8];
};

enum {
	Lo_unbound = 0,
	Lo_bound = 1,
	Lo_rundown = 2,
	Lo_deleting = 3,
};

struct loop_func_table;

struct loop_device {
	int lo_number;
	atomic_t lo_refcnt;
	loff_t lo_offset;
	loff_t lo_sizelimit;
	int lo_flags;
	int (*transfer)(struct loop_device *, int, struct page *, unsigned int, struct page *, unsigned int, int, sector_t);
	char lo_file_name[64];
	char lo_crypt_name[64];
	char lo_encrypt_key[32];
	int lo_encrypt_key_size;
	struct loop_func_table *lo_encryption;
	__u32 lo_init[2];
	kuid_t lo_key_owner;
	int (*ioctl)(struct loop_device *, int, long unsigned int);
	struct file *lo_backing_file;
	struct file *lo_backing_virt_file;
	struct block_device *lo_device;
	void *key_data;
	gfp_t old_gfp_mask;
	spinlock_t lo_lock;
	int lo_state;
	struct kthread_worker worker;
	struct task_struct *worker_task;
	bool use_dio;
	bool sysfs_inited;
	struct request_queue *lo_queue;
	struct blk_mq_tag_set tag_set;
	struct gendisk *lo_disk;
	struct mutex lo_mutex;
};

struct loop_func_table {
	int number;
	int (*transfer)(struct loop_device *, int, struct page *, unsigned int, struct page *, unsigned int, int, sector_t);
	int (*init)(struct loop_device *, const struct loop_info64 *);
	int (*release)(struct loop_device *);
	int (*ioctl)(struct loop_device *, int, long unsigned int);
	struct module *owner;
};

struct loop_cmd {
	struct kthread_work work;
	bool use_aio;
	atomic_t ref;
	long int ret;
	struct kiocb iocb;
	struct bio_vec *bvec;
	struct cgroup_subsys_state *css;
};

struct compat_loop_info {
	compat_int_t lo_number;
	compat_dev_t lo_device;
	compat_ulong_t lo_inode;
	compat_dev_t lo_rdevice;
	compat_int_t lo_offset;
	compat_int_t lo_encrypt_type;
	compat_int_t lo_encrypt_key_size;
	compat_int_t lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	compat_ulong_t lo_init[2];
	char reserved[4];
};

typedef unsigned int RING_IDX;

typedef uint16_t blkif_vdev_t;

typedef uint64_t blkif_sector_t;

struct blkif_request_segment {
	grant_ref_t gref;
	uint8_t first_sect;
	uint8_t last_sect;
};

struct blkif_request_rw {
	uint8_t nr_segments;
	blkif_vdev_t handle;
	uint32_t _pad1;
	uint64_t id;
	blkif_sector_t sector_number;
	struct blkif_request_segment seg[11];
} __attribute__((packed));

struct blkif_request_discard {
	uint8_t flag;
	blkif_vdev_t _pad1;
	uint32_t _pad2;
	uint64_t id;
	blkif_sector_t sector_number;
	uint64_t nr_sectors;
	uint8_t _pad3;
} __attribute__((packed));

struct blkif_request_other {
	uint8_t _pad1;
	blkif_vdev_t _pad2;
	uint32_t _pad3;
	uint64_t id;
} __attribute__((packed));

struct blkif_request_indirect {
	uint8_t indirect_op;
	uint16_t nr_segments;
	uint32_t _pad1;
	uint64_t id;
	blkif_sector_t sector_number;
	blkif_vdev_t handle;
	uint16_t _pad2;
	grant_ref_t indirect_grefs[8];
	uint32_t _pad3;
} __attribute__((packed));

struct blkif_request {
	uint8_t operation;
	union {
		struct blkif_request_rw rw;
		struct blkif_request_discard discard;
		struct blkif_request_other other;
		struct blkif_request_indirect indirect;
	} u;
} __attribute__((packed));

struct blkif_response {
	uint64_t id;
	uint8_t operation;
	int16_t status;
};

union blkif_sring_entry {
	struct blkif_request req;
	struct blkif_response rsp;
};

struct blkif_sring {
	RING_IDX req_prod;
	RING_IDX req_event;
	RING_IDX rsp_prod;
	RING_IDX rsp_event;
	uint8_t __pad[48];
	union blkif_sring_entry ring[1];
};

struct blkif_front_ring {
	RING_IDX req_prod_pvt;
	RING_IDX rsp_cons;
	unsigned int nr_ents;
	struct blkif_sring *sring;
};

enum blkif_state {
	BLKIF_STATE_DISCONNECTED = 0,
	BLKIF_STATE_CONNECTED = 1,
	BLKIF_STATE_SUSPENDED = 2,
	BLKIF_STATE_ERROR = 3,
	BLKIF_STATE_FREEZING = 4,
	BLKIF_STATE_FROZEN = 5,
};

struct grant {
	grant_ref_t gref;
	struct page *page;
	struct list_head node;
};

enum blk_req_status {
	REQ_PROCESSING = 0,
	REQ_WAITING = 1,
	REQ_DONE = 2,
	REQ_ERROR = 3,
	REQ_EOPNOTSUPP = 4,
};

struct blk_shadow {
	struct blkif_request req;
	struct request *request;
	struct grant **grants_used;
	struct grant **indirect_grants;
	struct scatterlist *sg;
	unsigned int num_sg;
	enum blk_req_status status;
	long unsigned int associated_id;
};

struct blkif_req {
	blk_status_t error;
};

struct blkfront_info;

struct blkfront_ring_info {
	spinlock_t ring_lock;
	struct blkif_front_ring ring;
	unsigned int ring_ref[16];
	unsigned int evtchn;
	unsigned int irq;
	struct work_struct work;
	struct gnttab_free_callback callback;
	struct list_head indirect_pages;
	struct list_head grants;
	unsigned int persistent_gnts_c;
	long unsigned int shadow_free;
	struct blkfront_info *dev_info;
	struct blk_shadow shadow[0];
};

struct blkfront_info {
	struct mutex mutex;
	struct xenbus_device *xbdev;
	struct gendisk *gd;
	u16 sector_size;
	unsigned int physical_sector_size;
	int vdevice;
	blkif_vdev_t handle;
	enum blkif_state connected;
	unsigned int nr_ring_pages;
	struct request_queue *rq;
	unsigned int feature_flush: 1;
	unsigned int feature_fua: 1;
	unsigned int feature_discard: 1;
	unsigned int feature_secdiscard: 1;
	unsigned int feature_persistent: 1;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	unsigned int max_indirect_segments;
	int is_ready;
	struct blk_mq_tag_set tag_set;
	struct blkfront_ring_info *rinfo;
	unsigned int nr_rings;
	unsigned int rinfo_size;
	struct list_head requests;
	struct bio_list bio_list;
	struct list_head info_list;
	struct completion wait_backend_disconnected;
};

struct setup_rw_req {
	unsigned int grant_idx;
	struct blkif_request_segment *segments;
	struct blkfront_ring_info *rinfo;
	struct blkif_request *ring_req;
	grant_ref_t gref_head;
	unsigned int id;
	bool need_copy;
	unsigned int bvec_off;
	char *bvec_data;
	bool require_extra_req;
	struct blkif_request *extra_ring_req;
};

struct copy_from_grant {
	const struct blk_shadow *s;
	unsigned int grant_idx;
	unsigned int bvec_offset;
	char *bvec_data;
};

struct sram_partition {
	void *base;
	struct gen_pool *pool;
	struct bin_attribute battr;
	struct mutex lock;
	struct list_head list;
};

struct sram_dev {
	struct device *dev;
	void *virt_base;
	struct gen_pool *pool;
	struct clk *clk;
	struct sram_partition *partition;
	u32 partitions;
};

struct sram_reserve {
	struct list_head list;
	u32 start;
	u32 size;
	bool export;
	bool pool;
	bool protect_exec;
	const char *label;
};

struct mfd_cell_acpi_match;

struct mfd_cell {
	const char *name;
	int id;
	int level;
	int (*enable)(struct platform_device *);
	int (*disable)(struct platform_device *);
	int (*suspend)(struct platform_device *);
	int (*resume)(struct platform_device *);
	void *platform_data;
	size_t pdata_size;
	const struct software_node *swnode;
	const char *of_compatible;
	const u64 of_reg;
	bool use_of_reg;
	const struct mfd_cell_acpi_match *acpi_match;
	int num_resources;
	const struct resource *resources;
	bool ignore_resource_conflicts;
	bool pm_runtime_no_callbacks;
	const char * const *parent_supplies;
	int num_parent_supplies;
};

struct mfd_cell_acpi_match {
	const char *pnpid;
	const long long unsigned int adr;
};

enum {
	CHIP_INVALID = 0,
	CHIP_PM8606 = 1,
	CHIP_PM8607 = 2,
	CHIP_MAX = 3,
};

enum pm8606_ref_gp_and_osc_clients {
	REF_GP_NO_CLIENTS = 0,
	WLED1_DUTY = 1,
	WLED2_DUTY = 2,
	WLED3_DUTY = 4,
	RGB1_ENABLE = 8,
	RGB2_ENABLE = 16,
	LDO_VBR_EN = 32,
	REF_GP_MAX_CLIENT = 65535,
};

enum {
	PM8607_IRQ_ONKEY = 0,
	PM8607_IRQ_EXTON = 1,
	PM8607_IRQ_CHG = 2,
	PM8607_IRQ_BAT = 3,
	PM8607_IRQ_RTC = 4,
	PM8607_IRQ_CC = 5,
	PM8607_IRQ_VBAT = 6,
	PM8607_IRQ_VCHG = 7,
	PM8607_IRQ_VSYS = 8,
	PM8607_IRQ_TINT = 9,
	PM8607_IRQ_GPADC0 = 10,
	PM8607_IRQ_GPADC1 = 11,
	PM8607_IRQ_GPADC2 = 12,
	PM8607_IRQ_GPADC3 = 13,
	PM8607_IRQ_AUDIO_SHORT = 14,
	PM8607_IRQ_PEN = 15,
	PM8607_IRQ_HEADSET = 16,
	PM8607_IRQ_HOOK = 17,
	PM8607_IRQ_MICIN = 18,
	PM8607_IRQ_CHG_FAIL = 19,
	PM8607_IRQ_CHG_DONE = 20,
	PM8607_IRQ_CHG_FAULT = 21,
};

struct pm860x_chip {
	struct device *dev;
	struct mutex irq_lock;
	struct mutex osc_lock;
	struct i2c_client *client;
	struct i2c_client *companion;
	struct regmap *regmap;
	struct regmap *regmap_companion;
	int buck3_double;
	int companion_addr;
	short unsigned int osc_vote;
	int id;
	int irq_mode;
	int irq_base;
	int core_irq;
	unsigned char chip_version;
	unsigned char osc_status;
	unsigned int wakeup_flag;
};

enum {
	GI2C_PORT = 0,
	PI2C_PORT = 1,
};

struct pm860x_backlight_pdata {
	int pwm;
	int iset;
};

struct pm860x_led_pdata {
	int iset;
};

struct pm860x_rtc_pdata {
	int (*sync)(unsigned int);
	int vrtc;
};

struct pm860x_touch_pdata {
	int gpadc_prebias;
	int slot_cycle;
	int off_scale;
	int sw_cal;
	int tsi_prebias;
	int pen_prebias;
	int pen_prechg;
	int res_x;
	long unsigned int flags;
};

struct pm860x_power_pdata {
	int max_capacity;
	int resistor;
};

struct charger_desc;

struct pm860x_platform_data {
	struct pm860x_backlight_pdata *backlight;
	struct pm860x_led_pdata *led;
	struct pm860x_rtc_pdata *rtc;
	struct pm860x_touch_pdata *touch;
	struct pm860x_power_pdata *power;
	struct regulator_init_data *buck1;
	struct regulator_init_data *buck2;
	struct regulator_init_data *buck3;
	struct regulator_init_data *ldo1;
	struct regulator_init_data *ldo2;
	struct regulator_init_data *ldo3;
	struct regulator_init_data *ldo4;
	struct regulator_init_data *ldo5;
	struct regulator_init_data *ldo6;
	struct regulator_init_data *ldo7;
	struct regulator_init_data *ldo8;
	struct regulator_init_data *ldo9;
	struct regulator_init_data *ldo10;
	struct regulator_init_data *ldo12;
	struct regulator_init_data *ldo_vibrator;
	struct regulator_init_data *ldo14;
	struct charger_desc *chg_desc;
	int companion_addr;
	int i2c_port;
	int irq_mode;
	int irq_base;
	int num_leds;
	int num_backlights;
};

enum polling_modes {
	CM_POLL_DISABLE = 0,
	CM_POLL_ALWAYS = 1,
	CM_POLL_EXTERNAL_POWER_ONLY = 2,
	CM_POLL_CHARGING_ONLY = 3,
};

enum data_source {
	CM_BATTERY_PRESENT = 0,
	CM_NO_BATTERY = 1,
	CM_FUEL_GAUGE = 2,
	CM_CHARGER_STAT = 3,
};

struct charger_regulator;

struct charger_desc {
	const char *psy_name;
	enum polling_modes polling_mode;
	unsigned int polling_interval_ms;
	unsigned int fullbatt_vchkdrop_uV;
	unsigned int fullbatt_uV;
	unsigned int fullbatt_soc;
	unsigned int fullbatt_full_capacity;
	enum data_source battery_present;
	const char **psy_charger_stat;
	int num_charger_regulators;
	struct charger_regulator *charger_regulators;
	const struct attribute_group **sysfs_groups;
	const char *psy_fuel_gauge;
	const char *thermal_zone;
	int temp_min;
	int temp_max;
	int temp_diff;
	bool measure_battery_temp;
	u32 charging_max_duration_ms;
	u32 discharging_max_duration_ms;
};

struct charger_manager;

struct charger_cable {
	const char *extcon_name;
	const char *name;
	struct extcon_dev *extcon_dev;
	u64 extcon_type;
	struct work_struct wq;
	struct notifier_block nb;
	bool attached;
	struct charger_regulator *charger;
	int min_uA;
	int max_uA;
	struct charger_manager *cm;
};

struct charger_regulator {
	const char *regulator_name;
	struct regulator *consumer;
	int externally_control;
	struct charger_cable *cables;
	int num_cables;
	struct attribute_group attr_grp;
	struct device_attribute attr_name;
	struct device_attribute attr_state;
	struct device_attribute attr_externally_control;
	struct attribute *attrs[4];
	struct charger_manager *cm;
};

struct charger_manager {
	struct list_head entry;
	struct device *dev;
	struct charger_desc *desc;
	struct thermal_zone_device *tzd_batt;
	bool charger_enabled;
	int emergency_stop;
	char psy_name_buf[31];
	struct power_supply_desc charger_psy_desc;
	struct power_supply *charger_psy;
	u64 charging_start_time;
	u64 charging_end_time;
	int battery_status;
};

struct pm860x_irq_data {
	int reg;
	int mask_reg;
	int enable;
	int offs;
};

struct htcpld_chip_platform_data {
	unsigned int addr;
	unsigned int reset;
	unsigned int num_gpios;
	unsigned int gpio_out_base;
	unsigned int gpio_in_base;
	unsigned int irq_base;
	unsigned int num_irqs;
};

struct htcpld_core_platform_data {
	unsigned int int_reset_gpio_hi;
	unsigned int int_reset_gpio_lo;
	unsigned int i2c_adapter_id;
	struct htcpld_chip_platform_data *chip;
	unsigned int num_chip;
};

struct htcpld_chip {
	spinlock_t lock;
	u8 reset;
	u8 addr;
	struct device *dev;
	struct i2c_client *client;
	u8 cache_out;
	struct gpio_chip chip_out;
	u8 cache_in;
	struct gpio_chip chip_in;
	u16 irqs_enabled;
	uint irq_start;
	int nirqs;
	unsigned int flow_type;
	struct work_struct set_val_work;
};

struct htcpld_data {
	u16 irqs_enabled;
	uint irq_start;
	int nirqs;
	uint chained_irq;
	unsigned int int_reset_gpio_hi;
	unsigned int int_reset_gpio_lo;
	struct htcpld_chip *chip;
	unsigned int nchips;
};

struct stmpe_client_info {
	void *data;
	int irq;
	void *client;
	struct device *dev;
	int (*read_byte)(struct stmpe *, u8);
	int (*write_byte)(struct stmpe *, u8, u8);
	int (*read_block)(struct stmpe *, u8, u8, u8 *);
	int (*write_block)(struct stmpe *, u8, u8, const u8 *);
	void (*init)(struct stmpe *);
};

struct stmpe_variant_block;

struct stmpe_variant_info {
	const char *name;
	u16 id_val;
	u16 id_mask;
	int num_gpios;
	int af_bits;
	const u8 *regs;
	struct stmpe_variant_block *blocks;
	int num_blocks;
	int num_irqs;
	int (*enable)(struct stmpe *, unsigned int, bool);
	int (*get_altfunc)(struct stmpe *, enum stmpe_block);
	int (*enable_autosleep)(struct stmpe *, int);
};

struct stmpe_platform_data {
	int id;
	unsigned int blocks;
	unsigned int irq_trigger;
	bool autosleep;
	bool irq_over_gpio;
	int irq_gpio;
	int autosleep_timeout;
};

struct stmpe_variant_block {
	const struct mfd_cell *cell;
	int irq;
	enum stmpe_block block;
};

struct prcm_data {
	int nsubdevs;
	const struct mfd_cell *subdevs;
};

enum tx3589x_block {
	TC3589x_BLOCK_GPIO = 1,
	TC3589x_BLOCK_KEYPAD = 2,
};

enum tc3589x_version {
	TC3589X_TC35890 = 0,
	TC3589X_TC35892 = 1,
	TC3589X_TC35893 = 2,
	TC3589X_TC35894 = 3,
	TC3589X_TC35895 = 4,
	TC3589X_TC35896 = 5,
	TC3589X_UNKNOWN = 6,
};

enum lochnagar_type {
	LOCHNAGAR1 = 0,
	LOCHNAGAR2 = 1,
};

struct lochnagar {
	enum lochnagar_type type;
	struct device *dev;
	struct regmap *regmap;
	struct mutex analogue_config_lock;
};

struct lochnagar_config {
	int id;
	const char * const name;
	enum lochnagar_type type;
	const struct regmap_config *regmap;
	const struct reg_sequence *patch;
	int npatch;
};

struct arizona_ldo1_pdata {
	const struct regulator_init_data *init_data;
};

struct arizona_micsupp_pdata {
	const struct regulator_init_data *init_data;
};

struct arizona_micbias {
	int mV;
	unsigned int ext_cap: 1;
	unsigned int discharge: 1;
	unsigned int soft_start: 1;
	unsigned int bypass: 1;
};

struct arizona_micd_config {
	unsigned int src;
	unsigned int bias;
	bool gpio;
};

struct arizona_micd_range {
	int max;
	int key;
};

struct arizona_pdata {
	struct gpio_desc *reset;
	struct arizona_micsupp_pdata micvdd;
	struct arizona_ldo1_pdata ldo1;
	int clk32k_src;
	unsigned int irq_flags;
	int gpio_base;
	unsigned int gpio_defaults[5];
	unsigned int max_channels_clocked[3];
	bool jd_gpio5;
	bool jd_gpio5_nopull;
	bool jd_invert;
	bool hpdet_acc_id;
	bool hpdet_acc_id_line;
	int hpdet_id_gpio;
	unsigned int hpdet_channel;
	bool micd_software_compare;
	unsigned int micd_detect_debounce;
	int micd_pol_gpio;
	unsigned int micd_bias_start_time;
	unsigned int micd_rate;
	unsigned int micd_dbtime;
	unsigned int micd_timeout;
	bool micd_force_micbias;
	const struct arizona_micd_range *micd_ranges;
	int num_micd_ranges;
	struct arizona_micd_config *micd_configs;
	int num_micd_configs;
	int dmic_ref[4];
	struct arizona_micbias micbias[3];
	int inmode[4];
	int out_mono[6];
	unsigned int out_vol_limit[12];
	unsigned int spk_mute[2];
	unsigned int spk_fmt[2];
	unsigned int hap_act;
	int irq_gpio;
	unsigned int gpsw;
};

enum {
	ARIZONA_MCLK1 = 0,
	ARIZONA_MCLK2 = 1,
	ARIZONA_NUM_MCLK = 2,
};

enum arizona_type {
	WM5102 = 1,
	WM5110 = 2,
	WM8997 = 3,
	WM8280 = 4,
	WM8998 = 5,
	WM1814 = 6,
	WM1831 = 7,
	CS47L24 = 8,
};

struct snd_soc_dapm_context;

struct arizona {
	struct regmap *regmap;
	struct device *dev;
	enum arizona_type type;
	unsigned int rev;
	int num_core_supplies;
	struct regulator_bulk_data core_supplies[2];
	struct regulator *dcvdd;
	bool has_fully_powered_off;
	struct arizona_pdata pdata;
	unsigned int external_dcvdd: 1;
	int irq;
	struct irq_domain *virq;
	struct regmap_irq_chip_data *aod_irq_chip;
	struct regmap_irq_chip_data *irq_chip;
	bool hpdet_clamp;
	unsigned int hp_ena;
	struct mutex clk_lock;
	int clk32k_ref;
	struct clk *mclk[2];
	bool ctrlif_error;
	struct snd_soc_dapm_context *dapm;
	int tdm_width[3];
	int tdm_slots[3];
	uint16_t dac_comp_coeff;
	uint8_t dac_comp_enabled;
	struct mutex dac_comp_lock;
	struct blocking_notifier_head notifier;
};

struct arizona_sysclk_state {
	unsigned int fll;
	unsigned int sysclk;
};

struct wm8400_platform_data {
	int (*platform_init)(struct device *);
};

struct wm8400 {
	struct device *dev;
	struct regmap *regmap;
	struct platform_device regulators[6];
};

enum wm831x_auxadc {
	WM831X_AUX_CAL = 15,
	WM831X_AUX_BKUP_BATT = 10,
	WM831X_AUX_WALL = 9,
	WM831X_AUX_BATT = 8,
	WM831X_AUX_USB = 7,
	WM831X_AUX_SYSVDD = 6,
	WM831X_AUX_BATT_TEMP = 5,
	WM831X_AUX_CHIP_TEMP = 4,
	WM831X_AUX_AUX4 = 3,
	WM831X_AUX_AUX3 = 2,
	WM831X_AUX_AUX2 = 1,
	WM831X_AUX_AUX1 = 0,
};

struct wm831x_backlight_pdata {
	int isink;
	int max_uA;
};

struct wm831x_backup_pdata {
	int charger_enable;
	int no_constant_voltage;
	int vlim;
	int ilim;
};

struct wm831x_battery_pdata {
	int enable;
	int fast_enable;
	int off_mask;
	int trickle_ilim;
	int vsel;
	int eoc_iterm;
	int fast_ilim;
	int timeout;
};

enum wm831x_status_src {
	WM831X_STATUS_PRESERVE = 0,
	WM831X_STATUS_OTP = 1,
	WM831X_STATUS_POWER = 2,
	WM831X_STATUS_CHARGER = 3,
	WM831X_STATUS_MANUAL = 4,
};

struct wm831x_status_pdata {
	enum wm831x_status_src default_src;
	const char *name;
	const char *default_trigger;
};

struct wm831x_touch_pdata {
	int fivewire;
	int isel;
	int rpu;
	int pressure;
	unsigned int data_irq;
	int data_irqf;
	unsigned int pd_irq;
	int pd_irqf;
};

enum wm831x_watchdog_action {
	WM831X_WDOG_NONE = 0,
	WM831X_WDOG_INTERRUPT = 1,
	WM831X_WDOG_RESET = 2,
	WM831X_WDOG_WAKE = 3,
};

struct wm831x_watchdog_pdata {
	enum wm831x_watchdog_action primary;
	enum wm831x_watchdog_action secondary;
	unsigned int software: 1;
};

struct wm831x;

struct wm831x_pdata {
	int wm831x_num;
	int (*pre_init)(struct wm831x *);
	int (*post_init)(struct wm831x *);
	bool irq_cmos;
	bool disable_touch;
	bool soft_shutdown;
	int irq_base;
	int gpio_base;
	int gpio_defaults[16];
	struct wm831x_backlight_pdata *backlight;
	struct wm831x_backup_pdata *backup;
	struct wm831x_battery_pdata *battery;
	struct wm831x_touch_pdata *touch;
	struct wm831x_watchdog_pdata *watchdog;
	struct wm831x_status_pdata *status[2];
	struct regulator_init_data *dcdc[4];
	struct regulator_init_data *epe[2];
	struct regulator_init_data *ldo[11];
	struct regulator_init_data *isink[2];
};

enum wm831x_parent {
	WM8310 = 33552,
	WM8311 = 33553,
	WM8312 = 33554,
	WM8320 = 33568,
	WM8321 = 33569,
	WM8325 = 33573,
	WM8326 = 33574,
};

typedef int (*wm831x_auxadc_read_fn)(struct wm831x *, enum wm831x_auxadc);

struct wm831x {
	struct mutex io_lock;
	struct device *dev;
	struct regmap *regmap;
	struct wm831x_pdata pdata;
	enum wm831x_parent type;
	int irq;
	struct mutex irq_lock;
	struct irq_domain *irq_domain;
	int irq_masks_cur[5];
	int irq_masks_cache[5];
	bool soft_shutdown;
	unsigned int has_gpio_ena: 1;
	unsigned int has_cs_sts: 1;
	unsigned int charger_irq_wake: 1;
	int num_gpio;
	int gpio_update[16];
	bool gpio_level_high[16];
	bool gpio_level_low[16];
	struct mutex auxadc_lock;
	struct list_head auxadc_pending;
	u16 auxadc_active;
	wm831x_auxadc_read_fn auxadc_read;
	struct mutex key_lock;
	unsigned int locked: 1;
};

struct wm831x_irq_data {
	int primary;
	int reg;
	int mask;
};

struct wm831x_auxadc_req {
	struct list_head list;
	enum wm831x_auxadc input;
	int val;
	struct completion done;
};

struct wm8350_audio_platform_data {
	int vmid_discharge_msecs;
	int drain_msecs;
	int cap_discharge_msecs;
	int vmid_charge_msecs;
	u32 vmid_s_curve: 2;
	u32 dis_out4: 2;
	u32 dis_out3: 2;
	u32 dis_out2: 2;
	u32 dis_out1: 2;
	u32 vroi_out4: 1;
	u32 vroi_out3: 1;
	u32 vroi_out2: 1;
	u32 vroi_out1: 1;
	u32 vroi_enable: 1;
	u32 codec_current_on: 2;
	u32 codec_current_standby: 2;
	u32 codec_current_charge: 2;
};

struct wm8350_codec {
	struct platform_device *pdev;
	struct wm8350_audio_platform_data *platform_data;
};

struct wm8350_gpio {
	struct platform_device *pdev;
};

struct wm8350_led {
	struct platform_device *pdev;
	struct work_struct work;
	spinlock_t value_lock;
	enum led_brightness value;
	struct led_classdev cdev;
	int max_uA_index;
	int enabled;
	struct regulator *isink;
	struct regulator_consumer_supply isink_consumer;
	struct regulator_init_data isink_init;
	struct regulator *dcdc;
	struct regulator_consumer_supply dcdc_consumer;
	struct regulator_init_data dcdc_init;
};

struct wm8350_pmic {
	int max_dcdc;
	int max_isink;
	int isink_A_dcdc;
	int isink_B_dcdc;
	u16 dcdc1_hib_mode;
	u16 dcdc3_hib_mode;
	u16 dcdc4_hib_mode;
	u16 dcdc6_hib_mode;
	struct platform_device *pdev[12];
	struct wm8350_led led[2];
};

struct wm8350_rtc {
	struct platform_device *pdev;
	struct rtc_device *rtc;
	int alarm_enabled;
	int update_enabled;
};

struct wm8350_charger_policy {
	int eoc_mA;
	int charge_mV;
	int fast_limit_mA;
	int fast_limit_USB_mA;
	int charge_timeout;
	int trickle_start_mV;
	int trickle_charge_mA;
	int trickle_charge_USB_mA;
};

struct wm8350_power {
	struct platform_device *pdev;
	struct power_supply *battery;
	struct power_supply *usb;
	struct power_supply *ac;
	struct wm8350_charger_policy *policy;
	int rev_g_coeff;
};

struct wm8350_wdt {
	struct platform_device *pdev;
};

struct wm8350_hwmon {
	struct platform_device *pdev;
	struct device *classdev;
};

struct wm8350 {
	struct device *dev;
	struct regmap *regmap;
	bool unlocked;
	struct mutex auxadc_mutex;
	struct completion auxadc_done;
	struct mutex irq_lock;
	int chip_irq;
	int irq_base;
	u16 irq_masks[7];
	struct wm8350_codec codec;
	struct wm8350_gpio gpio;
	struct wm8350_hwmon hwmon;
	struct wm8350_pmic pmic;
	struct wm8350_power power;
	struct wm8350_rtc rtc;
	struct wm8350_wdt wdt;
};

struct wm8350_platform_data {
	int (*init)(struct wm8350 *);
	int irq_high;
	int irq_base;
	int gpio_base;
};

struct wm8350_reg_access {
	u16 readable;
	u16 writable;
	u16 vol;
};

struct wm8350_irq_data {
	int primary;
	int reg;
	int mask;
	int primary_only;
};

struct tps65910_platform_data {
	int irq;
	int irq_base;
};

enum tps65912_irqs {
	TPS65912_IRQ_PWRHOLD_F = 0,
	TPS65912_IRQ_VMON = 1,
	TPS65912_IRQ_PWRON = 2,
	TPS65912_IRQ_PWRON_LP = 3,
	TPS65912_IRQ_PWRHOLD_R = 4,
	TPS65912_IRQ_HOTDIE = 5,
	TPS65912_IRQ_GPIO1_R = 6,
	TPS65912_IRQ_GPIO1_F = 7,
	TPS65912_IRQ_GPIO2_R = 8,
	TPS65912_IRQ_GPIO2_F = 9,
	TPS65912_IRQ_GPIO3_R = 10,
	TPS65912_IRQ_GPIO3_F = 11,
	TPS65912_IRQ_GPIO4_R = 12,
	TPS65912_IRQ_GPIO4_F = 13,
	TPS65912_IRQ_GPIO5_R = 14,
	TPS65912_IRQ_GPIO5_F = 15,
	TPS65912_IRQ_PGOOD_DCDC1 = 16,
	TPS65912_IRQ_PGOOD_DCDC2 = 17,
	TPS65912_IRQ_PGOOD_DCDC3 = 18,
	TPS65912_IRQ_PGOOD_DCDC4 = 19,
	TPS65912_IRQ_PGOOD_LDO1 = 20,
	TPS65912_IRQ_PGOOD_LDO2 = 21,
	TPS65912_IRQ_PGOOD_LDO3 = 22,
	TPS65912_IRQ_PGOOD_LDO4 = 23,
	TPS65912_IRQ_PGOOD_LDO5 = 24,
	TPS65912_IRQ_PGOOD_LDO6 = 25,
	TPS65912_IRQ_PGOOD_LDO7 = 26,
	TPS65912_IRQ_PGOOD_LDO8 = 27,
	TPS65912_IRQ_PGOOD_LDO9 = 28,
	TPS65912_IRQ_PGOOD_LDO10 = 29,
};

struct tps65912 {
	struct device *dev;
	struct regmap *regmap;
	int irq;
	struct regmap_irq_chip_data *irq_data;
};

enum chips {
	TPS80031 = 1,
	TPS80032 = 2,
};

enum {
	TPS80031_INT_PWRON = 0,
	TPS80031_INT_RPWRON = 1,
	TPS80031_INT_SYS_VLOW = 2,
	TPS80031_INT_RTC_ALARM = 3,
	TPS80031_INT_RTC_PERIOD = 4,
	TPS80031_INT_HOT_DIE = 5,
	TPS80031_INT_VXX_SHORT = 6,
	TPS80031_INT_SPDURATION = 7,
	TPS80031_INT_WATCHDOG = 8,
	TPS80031_INT_BAT = 9,
	TPS80031_INT_SIM = 10,
	TPS80031_INT_MMC = 11,
	TPS80031_INT_RES = 12,
	TPS80031_INT_GPADC_RT = 13,
	TPS80031_INT_GPADC_SW2_EOC = 14,
	TPS80031_INT_CC_AUTOCAL = 15,
	TPS80031_INT_ID_WKUP = 16,
	TPS80031_INT_VBUSS_WKUP = 17,
	TPS80031_INT_ID = 18,
	TPS80031_INT_VBUS = 19,
	TPS80031_INT_CHRG_CTRL = 20,
	TPS80031_INT_EXT_CHRG = 21,
	TPS80031_INT_INT_CHRG = 22,
	TPS80031_INT_RES2 = 23,
	TPS80031_INT_BAT_TEMP_OVRANGE = 24,
	TPS80031_INT_BAT_REMOVED = 25,
	TPS80031_INT_VBUS_DET = 26,
	TPS80031_INT_VAC_DET = 27,
	TPS80031_INT_FAULT_WDG = 28,
	TPS80031_INT_LINCH_GATED = 29,
	TPS80031_INT_NR = 30,
};

enum {
	TPS80031_REGULATOR_VIO = 0,
	TPS80031_REGULATOR_SMPS1 = 1,
	TPS80031_REGULATOR_SMPS2 = 2,
	TPS80031_REGULATOR_SMPS3 = 3,
	TPS80031_REGULATOR_SMPS4 = 4,
	TPS80031_REGULATOR_VANA = 5,
	TPS80031_REGULATOR_LDO1 = 6,
	TPS80031_REGULATOR_LDO2 = 7,
	TPS80031_REGULATOR_LDO3 = 8,
	TPS80031_REGULATOR_LDO4 = 9,
	TPS80031_REGULATOR_LDO5 = 10,
	TPS80031_REGULATOR_LDO6 = 11,
	TPS80031_REGULATOR_LDO7 = 12,
	TPS80031_REGULATOR_LDOLN = 13,
	TPS80031_REGULATOR_LDOUSB = 14,
	TPS80031_REGULATOR_VBUS = 15,
	TPS80031_REGULATOR_REGEN1 = 16,
	TPS80031_REGULATOR_REGEN2 = 17,
	TPS80031_REGULATOR_SYSEN = 18,
	TPS80031_REGULATOR_MAX = 19,
};

enum tps80031_ext_control {
	TPS80031_PWR_REQ_INPUT_NONE = 0,
	TPS80031_PWR_REQ_INPUT_PREQ1 = 1,
	TPS80031_PWR_REQ_INPUT_PREQ2 = 2,
	TPS80031_PWR_REQ_INPUT_PREQ3 = 4,
	TPS80031_PWR_OFF_ON_SLEEP = 8,
	TPS80031_PWR_ON_ON_SLEEP = 16,
};

enum tps80031_pupd_pins {
	TPS80031_PREQ1 = 0,
	TPS80031_PREQ2A = 1,
	TPS80031_PREQ2B = 2,
	TPS80031_PREQ2C = 3,
	TPS80031_PREQ3 = 4,
	TPS80031_NRES_WARM = 5,
	TPS80031_PWM_FORCE = 6,
	TPS80031_CHRG_EXT_CHRG_STATZ = 7,
	TPS80031_SIM = 8,
	TPS80031_MMC = 9,
	TPS80031_GPADC_START = 10,
	TPS80031_DVSI2C_SCL = 11,
	TPS80031_DVSI2C_SDA = 12,
	TPS80031_CTLI2C_SCL = 13,
	TPS80031_CTLI2C_SDA = 14,
};

enum tps80031_pupd_settings {
	TPS80031_PUPD_NORMAL = 0,
	TPS80031_PUPD_PULLDOWN = 1,
	TPS80031_PUPD_PULLUP = 2,
};

struct tps80031 {
	struct device *dev;
	long unsigned int chip_info;
	int es_version;
	struct i2c_client *clients[4];
	struct regmap *regmap[4];
	struct regmap_irq_chip_data *irq_data;
};

struct tps80031_pupd_init_data {
	int input_pin;
	int setting;
};

struct tps80031_regulator_platform_data {
	struct regulator_init_data *reg_init_data;
	unsigned int ext_ctrl_flag;
	unsigned int config_flags;
};

struct tps80031_platform_data {
	int irq_base;
	bool use_power_off;
	struct tps80031_pupd_init_data *pupd_init_data;
	int pupd_init_data_size;
	struct tps80031_regulator_platform_data *regulator_pdata[19];
};

struct tps80031_pupd_data {
	u8 reg;
	u8 pullup_bit;
	u8 pulldown_bit;
};

struct matrix_keymap_data {
	const uint32_t *keymap;
	unsigned int keymap_size;
};

enum twl_module_ids {
	TWL_MODULE_USB = 0,
	TWL_MODULE_PIH = 1,
	TWL_MODULE_MAIN_CHARGE = 2,
	TWL_MODULE_PM_MASTER = 3,
	TWL_MODULE_PM_RECEIVER = 4,
	TWL_MODULE_RTC = 5,
	TWL_MODULE_PWM = 6,
	TWL_MODULE_LED = 7,
	TWL_MODULE_SECURED_REG = 8,
	TWL_MODULE_LAST = 9,
};

enum twl4030_module_ids {
	TWL4030_MODULE_AUDIO_VOICE = 9,
	TWL4030_MODULE_GPIO = 10,
	TWL4030_MODULE_INTBR = 11,
	TWL4030_MODULE_TEST = 12,
	TWL4030_MODULE_KEYPAD = 13,
	TWL4030_MODULE_MADC = 14,
	TWL4030_MODULE_INTERRUPTS = 15,
	TWL4030_MODULE_PRECHARGE = 16,
	TWL4030_MODULE_BACKUP = 17,
	TWL4030_MODULE_INT = 18,
	TWL5031_MODULE_ACCESSORY = 19,
	TWL5031_MODULE_INTERRUPTS = 20,
	TWL4030_MODULE_LAST = 21,
};

enum twl6030_module_ids {
	TWL6030_MODULE_ID0 = 9,
	TWL6030_MODULE_ID1 = 10,
	TWL6030_MODULE_ID2 = 11,
	TWL6030_MODULE_GPADC = 12,
	TWL6030_MODULE_GASGAUGE = 13,
	TWL6030_MODULE_LAST = 14,
};

struct twl4030_clock_init_data {
	bool ck32k_lowpwr_enable;
};

struct twl4030_bci_platform_data {
	int *battery_tmp_tbl;
	unsigned int tblsize;
	int bb_uvolt;
	int bb_uamp;
};

struct twl4030_gpio_platform_data {
	bool use_leds;
	u8 mmc_cd;
	u32 debounce;
	u32 pullups;
	u32 pulldowns;
	int (*setup)(struct device *, unsigned int, unsigned int);
	int (*teardown)(struct device *, unsigned int, unsigned int);
};

struct twl4030_madc_platform_data {
	int irq_line;
};

struct twl4030_keypad_data {
	const struct matrix_keymap_data *keymap_data;
	unsigned int rows;
	unsigned int cols;
	bool rep;
};

enum twl4030_usb_mode {
	T2_USB_MODE_ULPI = 1,
	T2_USB_MODE_CEA2011_3PIN = 2,
};

struct twl4030_usb_data {
	enum twl4030_usb_mode usb_mode;
	long unsigned int features;
	int (*phy_init)(struct device *);
	int (*phy_exit)(struct device *);
	int (*phy_power)(struct device *, int, int);
	int (*phy_set_clock)(struct device *, int);
	int (*phy_suspend)(struct device *, int);
};

struct twl4030_ins {
	u16 pmb_message;
	u8 delay;
};

struct twl4030_script {
	struct twl4030_ins *script;
	unsigned int size;
	u8 flags;
};

struct twl4030_resconfig {
	u8 resource;
	u8 devgroup;
	u8 type;
	u8 type2;
	u8 remap_off;
	u8 remap_sleep;
};

struct twl4030_power_data {
	struct twl4030_script **scripts;
	unsigned int num;
	struct twl4030_resconfig *resource_config;
	struct twl4030_resconfig *board_config;
	bool use_poweroff;
	bool ac_charger_quirk;
};

struct twl4030_codec_data {
	unsigned int digimic_delay;
	unsigned int ramp_delay_value;
	unsigned int offset_cncl_path;
	unsigned int hs_extmute: 1;
	int hs_extmute_gpio;
};

struct twl4030_vibra_data {
	unsigned int coexist;
};

struct twl4030_audio_data {
	unsigned int audio_mclk;
	struct twl4030_codec_data *codec;
	struct twl4030_vibra_data *vibra;
	int audpwron_gpio;
	int naudint_irq;
	unsigned int irq_base;
};

struct twl4030_platform_data {
	struct twl4030_clock_init_data *clock;
	struct twl4030_bci_platform_data *bci;
	struct twl4030_gpio_platform_data *gpio;
	struct twl4030_madc_platform_data *madc;
	struct twl4030_keypad_data *keypad;
	struct twl4030_usb_data *usb;
	struct twl4030_power_data *power;
	struct twl4030_audio_data *audio;
	struct regulator_init_data *vdac;
	struct regulator_init_data *vaux1;
	struct regulator_init_data *vaux2;
	struct regulator_init_data *vaux3;
	struct regulator_init_data *vdd1;
	struct regulator_init_data *vdd2;
	struct regulator_init_data *vdd3;
	struct regulator_init_data *vpll1;
	struct regulator_init_data *vpll2;
	struct regulator_init_data *vmmc1;
	struct regulator_init_data *vmmc2;
	struct regulator_init_data *vsim;
	struct regulator_init_data *vaux4;
	struct regulator_init_data *vio;
	struct regulator_init_data *vintana1;
	struct regulator_init_data *vintana2;
	struct regulator_init_data *vintdig;
	struct regulator_init_data *vmmc;
	struct regulator_init_data *vpp;
	struct regulator_init_data *vusim;
	struct regulator_init_data *vana;
	struct regulator_init_data *vcxio;
	struct regulator_init_data *vusb;
	struct regulator_init_data *clk32kg;
	struct regulator_init_data *v1v8;
	struct regulator_init_data *v2v1;
	struct regulator_init_data *ldo1;
	struct regulator_init_data *ldo2;
	struct regulator_init_data *ldo3;
	struct regulator_init_data *ldo4;
	struct regulator_init_data *ldo5;
	struct regulator_init_data *ldo6;
	struct regulator_init_data *ldo7;
	struct regulator_init_data *ldoln;
	struct regulator_init_data *ldousb;
	struct regulator_init_data *smps3;
	struct regulator_init_data *smps4;
	struct regulator_init_data *vio6025;
};

struct twl_regulator_driver_data {
	int (*set_voltage)(void *, int);
	int (*get_voltage)(void *);
	void *data;
	long unsigned int features;
};

struct twl_client {
	struct i2c_client *client;
	struct regmap *regmap;
};

struct twl_mapping {
	unsigned char sid;
	unsigned char base;
};

struct twl_private {
	bool ready;
	u32 twl_idcode;
	unsigned int twl_id;
	struct twl_mapping *twl_map;
	struct twl_client *twl_modules;
};

struct sih_irq_data {
	u8 isr_offset;
	u8 imr_offset;
};

struct sih {
	char name[8];
	u8 module;
	u8 control_offset;
	bool set_cor;
	u8 bits;
	u8 bytes_ixr;
	u8 edr_offset;
	u8 bytes_edr;
	u8 irq_lines;
	struct sih_irq_data mask[2];
};

struct sih_agent {
	int irq_base;
	const struct sih *sih;
	u32 imr;
	bool imr_change_pending;
	u32 edge_change;
	struct mutex irq_lock;
	char *irq_name;
};

struct twl6030_irq {
	unsigned int irq_base;
	int twl_irq;
	bool irq_wake_enabled;
	atomic_t wakeirqs;
	struct notifier_block pm_nb;
	struct irq_chip irq_chip;
	struct irq_domain *irq_domain;
	const int *irq_mapping_tbl;
};

enum twl4030_audio_res {
	TWL4030_AUDIO_RES_POWER = 0,
	TWL4030_AUDIO_RES_APLL = 1,
	TWL4030_AUDIO_RES_MAX = 2,
};

struct twl4030_audio_resource {
	int request_count;
	u8 reg;
	u8 mask;
};

struct twl4030_audio {
	unsigned int audio_mclk;
	struct mutex mutex;
	struct twl4030_audio_resource resource[2];
	struct mfd_cell cells[2];
};

struct twl6040 {
	struct device *dev;
	struct regmap *regmap;
	struct regmap_irq_chip_data *irq_data;
	struct regulator_bulk_data supplies[2];
	struct clk *clk32k;
	struct clk *mclk;
	struct mutex mutex;
	struct mutex irq_mutex;
	struct mfd_cell cells[4];
	struct completion ready;
	int audpwron;
	int power_count;
	int rev;
	int pll;
	unsigned int sysclk_rate;
	unsigned int mclk_rate;
	unsigned int irq;
	unsigned int irq_ready;
	unsigned int irq_th;
};

struct mfd_of_node_entry {
	struct list_head list;
	struct device *dev;
	struct device_node *np;
};

struct pcap_subdev {
	int id;
	const char *name;
	void *platform_data;
};

struct pcap_platform_data {
	unsigned int irq_base;
	unsigned int config;
	int gpio;
	void (*init)(void *);
	int num_subdevs;
	struct pcap_subdev *subdevs;
};

struct pcap_adc_request {
	u8 bank;
	u8 ch[2];
	u32 flags;
	void (*callback)(void *, u16 *);
	void *data;
};

struct pcap_adc_sync_request {
	u16 res[2];
	struct completion completion;
};

struct pcap_chip {
	struct spi_device *spi;
	u32 buf;
	spinlock_t io_lock;
	unsigned int irq_base;
	u32 msr;
	struct work_struct isr_work;
	struct work_struct msr_work;
	struct workqueue_struct *workqueue;
	struct pcap_adc_request *adc_queue[8];
	u8 adc_head;
	u8 adc_tail;
	spinlock_t adc_lock;
};

struct da903x_subdev_info {
	int id;
	const char *name;
	void *platform_data;
};

struct da903x_platform_data {
	int num_subdevs;
	struct da903x_subdev_info *subdevs;
};

struct da903x_chip;

struct da903x_chip_ops {
	int (*init_chip)(struct da903x_chip *);
	int (*unmask_events)(struct da903x_chip *, unsigned int);
	int (*mask_events)(struct da903x_chip *, unsigned int);
	int (*read_events)(struct da903x_chip *, unsigned int *);
	int (*read_status)(struct da903x_chip *, unsigned int *);
};

struct da903x_chip {
	struct i2c_client *client;
	struct device *dev;
	const struct da903x_chip_ops *ops;
	int type;
	uint32_t events_mask;
	struct mutex lock;
	struct work_struct irq_work;
	struct blocking_notifier_head notifier_list;
};

struct da9052 {
	struct device *dev;
	struct regmap *regmap;
	struct mutex auxadc_lock;
	struct completion done;
	int irq_base;
	struct regmap_irq_chip_data *irq_data;
	u8 chip_id;
	int chip_irq;
	int (*fix_io)(struct da9052 *, unsigned char);
};

struct led_platform_data;

struct da9052_pdata {
	struct led_platform_data *pled;
	int (*init)(struct da9052 *);
	int irq_base;
	int gpio_base;
	int use_for_apm;
	struct regulator_init_data *regulators[14];
};

enum da9052_chip_id {
	DA9052 = 0,
	DA9053_AA = 1,
	DA9053_BA = 2,
	DA9053_BB = 3,
	DA9053_BC = 4,
};

enum lp8788_int_id {
	LP8788_INT_TSDL = 0,
	LP8788_INT_TSDH = 1,
	LP8788_INT_UVLO = 2,
	LP8788_INT_FLAGMON = 3,
	LP8788_INT_PWRON_TIME = 4,
	LP8788_INT_PWRON = 5,
	LP8788_INT_COMP1 = 6,
	LP8788_INT_COMP2 = 7,
	LP8788_INT_CHG_INPUT_STATE = 8,
	LP8788_INT_CHG_STATE = 9,
	LP8788_INT_EOC = 10,
	LP8788_INT_CHG_RESTART = 11,
	LP8788_INT_RESTART_TIMEOUT = 12,
	LP8788_INT_FULLCHG_TIMEOUT = 13,
	LP8788_INT_PRECHG_TIMEOUT = 14,
	LP8788_INT_RTC_ALARM1 = 17,
	LP8788_INT_RTC_ALARM2 = 18,
	LP8788_INT_ENTER_SYS_SUPPORT = 19,
	LP8788_INT_EXIT_SYS_SUPPORT = 20,
	LP8788_INT_BATT_LOW = 21,
	LP8788_INT_NO_BATT = 22,
	LP8788_INT_MAX = 24,
};

enum lp8788_dvs_sel {
	DVS_SEL_V0 = 0,
	DVS_SEL_V1 = 1,
	DVS_SEL_V2 = 2,
	DVS_SEL_V3 = 3,
};

enum lp8788_charger_event {
	NO_CHARGER = 0,
	CHARGER_DETECTED = 1,
};

enum lp8788_bl_ctrl_mode {
	LP8788_BL_REGISTER_ONLY = 0,
	LP8788_BL_COMB_PWM_BASED = 1,
	LP8788_BL_COMB_REGISTER_BASED = 2,
};

enum lp8788_bl_dim_mode {
	LP8788_DIM_EXPONENTIAL = 0,
	LP8788_DIM_LINEAR = 1,
};

enum lp8788_bl_full_scale_current {
	LP8788_FULLSCALE_5000uA = 0,
	LP8788_FULLSCALE_8500uA = 1,
	LP8788_FULLSCALE_1200uA = 2,
	LP8788_FULLSCALE_1550uA = 3,
	LP8788_FULLSCALE_1900uA = 4,
	LP8788_FULLSCALE_2250uA = 5,
	LP8788_FULLSCALE_2600uA = 6,
	LP8788_FULLSCALE_2950uA = 7,
};

enum lp8788_bl_ramp_step {
	LP8788_RAMP_8us = 0,
	LP8788_RAMP_1024us = 1,
	LP8788_RAMP_2048us = 2,
	LP8788_RAMP_4096us = 3,
	LP8788_RAMP_8192us = 4,
	LP8788_RAMP_16384us = 5,
	LP8788_RAMP_32768us = 6,
	LP8788_RAMP_65538us = 7,
};

enum lp8788_isink_scale {
	LP8788_ISINK_SCALE_100mA = 0,
	LP8788_ISINK_SCALE_120mA = 1,
};

enum lp8788_isink_number {
	LP8788_ISINK_1 = 0,
	LP8788_ISINK_2 = 1,
	LP8788_ISINK_3 = 2,
};

enum lp8788_alarm_sel {
	LP8788_ALARM_1 = 0,
	LP8788_ALARM_2 = 1,
	LP8788_ALARM_MAX = 2,
};

struct lp8788_buck1_dvs {
	int gpio;
	enum lp8788_dvs_sel vsel;
};

struct lp8788_buck2_dvs {
	int gpio[2];
	enum lp8788_dvs_sel vsel;
};

struct lp8788_chg_param {
	u8 addr;
	u8 val;
};

struct lp8788;

struct lp8788_charger_platform_data {
	const char *adc_vbatt;
	const char *adc_batt_temp;
	unsigned int max_vbatt_mv;
	struct lp8788_chg_param *chg_params;
	int num_chg_params;
	void (*charger_event)(struct lp8788 *, enum lp8788_charger_event);
};

struct lp8788_platform_data;

struct lp8788 {
	struct device *dev;
	struct regmap *regmap;
	struct irq_domain *irqdm;
	int irq;
	struct lp8788_platform_data *pdata;
};

struct lp8788_backlight_platform_data {
	char *name;
	int initial_brightness;
	enum lp8788_bl_ctrl_mode bl_mode;
	enum lp8788_bl_dim_mode dim_mode;
	enum lp8788_bl_full_scale_current full_scale;
	enum lp8788_bl_ramp_step rise_time;
	enum lp8788_bl_ramp_step fall_time;
	enum pwm_polarity pwm_pol;
	unsigned int period_ns;
};

struct lp8788_led_platform_data {
	char *name;
	enum lp8788_isink_scale scale;
	enum lp8788_isink_number num;
	int iout_code;
};

struct lp8788_vib_platform_data {
	char *name;
	enum lp8788_isink_scale scale;
	enum lp8788_isink_number num;
	int iout_code;
	int pwm_code;
};

struct iio_map;

struct lp8788_platform_data {
	int (*init_func)(struct lp8788 *);
	struct regulator_init_data *buck_data[4];
	struct regulator_init_data *dldo_data[12];
	struct regulator_init_data *aldo_data[10];
	struct lp8788_buck1_dvs *buck1_dvs;
	struct lp8788_buck2_dvs *buck2_dvs;
	struct lp8788_charger_platform_data *chg_pdata;
	enum lp8788_alarm_sel alarm_sel;
	struct lp8788_backlight_platform_data *bl_pdata;
	struct lp8788_led_platform_data *led_pdata;
	struct lp8788_vib_platform_data *vib_pdata;
	struct iio_map *adc_pdata;
};

struct lp8788_irq_data {
	struct lp8788 *lp;
	struct mutex irq_lock;
	struct irq_domain *domain;
	int enabled[24];
};

struct da9055 {
	struct regmap *regmap;
	struct regmap_irq_chip_data *irq_data;
	struct device *dev;
	struct i2c_client *i2c_client;
	int irq_base;
	int chip_irq;
};

enum gpio_select {
	NO_GPIO = 0,
	GPIO_1 = 1,
	GPIO_2 = 2,
};

struct da9055_pdata {
	int (*init)(struct da9055 *);
	int irq_base;
	int gpio_base;
	struct regulator_init_data *regulators[8];
	bool reset_enable;
	int *gpio_ren;
	int *gpio_rsel;
	enum gpio_select *reg_ren;
	enum gpio_select *reg_rsel;
	struct gpio_desc **ena_gpiods;
};

enum da9063_type {
	PMIC_TYPE_DA9063 = 0,
	PMIC_TYPE_DA9063L = 1,
};

enum da9063_irqs {
	DA9063_IRQ_ONKEY = 0,
	DA9063_IRQ_ALARM = 1,
	DA9063_IRQ_TICK = 2,
	DA9063_IRQ_ADC_RDY = 3,
	DA9063_IRQ_SEQ_RDY = 4,
	DA9063_IRQ_WAKE = 5,
	DA9063_IRQ_TEMP = 6,
	DA9063_IRQ_COMP_1V2 = 7,
	DA9063_IRQ_LDO_LIM = 8,
	DA9063_IRQ_REG_UVOV = 9,
	DA9063_IRQ_DVC_RDY = 10,
	DA9063_IRQ_VDD_MON = 11,
	DA9063_IRQ_WARN = 12,
	DA9063_IRQ_GPI0 = 13,
	DA9063_IRQ_GPI1 = 14,
	DA9063_IRQ_GPI2 = 15,
	DA9063_IRQ_GPI3 = 16,
	DA9063_IRQ_GPI4 = 17,
	DA9063_IRQ_GPI5 = 18,
	DA9063_IRQ_GPI6 = 19,
	DA9063_IRQ_GPI7 = 20,
	DA9063_IRQ_GPI8 = 21,
	DA9063_IRQ_GPI9 = 22,
	DA9063_IRQ_GPI10 = 23,
	DA9063_IRQ_GPI11 = 24,
	DA9063_IRQ_GPI12 = 25,
	DA9063_IRQ_GPI13 = 26,
	DA9063_IRQ_GPI14 = 27,
	DA9063_IRQ_GPI15 = 28,
};

struct da9063 {
	struct device *dev;
	enum da9063_type type;
	unsigned char variant_code;
	unsigned int flags;
	struct regmap *regmap;
	int chip_irq;
	unsigned int irq_base;
	struct regmap_irq_chip_data *regmap_irq;
};

enum da9063_variant_codes {
	PMIC_DA9063_AD = 3,
	PMIC_DA9063_BB = 5,
	PMIC_DA9063_CA = 6,
	PMIC_DA9063_DA = 7,
};

enum da9063_page_sel_buf_fmt {
	DA9063_PAGE_SEL_BUF_PAGE_REG = 0,
	DA9063_PAGE_SEL_BUF_PAGE_VAL = 1,
	DA9063_PAGE_SEL_BUF_SIZE = 2,
};

enum da9063_paged_read_msgs {
	DA9063_PAGED_READ_MSG_PAGE_SEL = 0,
	DA9063_PAGED_READ_MSG_REG_SEL = 1,
	DA9063_PAGED_READ_MSG_DATA = 2,
	DA9063_PAGED_READ_MSG_CNT = 3,
};

enum {
	DA9063_DEV_ID_REG = 0,
	DA9063_VAR_ID_REG = 1,
	DA9063_CHIP_ID_REGS = 2,
};

struct max14577_regulator_platform_data {
	int id;
	struct regulator_init_data *initdata;
	struct device_node *of_node;
};

struct max14577_platform_data {
	int irq_base;
	int gpio_pogo_vbatt_en;
	int gpio_pogo_vbus_en;
	int (*set_gpio_pogo_vbatt_en)(int);
	int (*set_gpio_pogo_vbus_en)(int);
	int (*set_gpio_pogo_cb)(int);
	struct max14577_regulator_platform_data *regulators;
};

struct maxim_charger_current {
	unsigned int min;
	unsigned int high_start;
	unsigned int high_step;
	unsigned int max;
};

enum maxim_device_type {
	MAXIM_DEVICE_TYPE_UNKNOWN = 0,
	MAXIM_DEVICE_TYPE_MAX14577 = 1,
	MAXIM_DEVICE_TYPE_MAX77836 = 2,
	MAXIM_DEVICE_TYPE_NUM = 3,
};

enum max14577_reg {
	MAX14577_REG_DEVICEID = 0,
	MAX14577_REG_INT1 = 1,
	MAX14577_REG_INT2 = 2,
	MAX14577_REG_INT3 = 3,
	MAX14577_REG_STATUS1 = 4,
	MAX14577_REG_STATUS2 = 5,
	MAX14577_REG_STATUS3 = 6,
	MAX14577_REG_INTMASK1 = 7,
	MAX14577_REG_INTMASK2 = 8,
	MAX14577_REG_INTMASK3 = 9,
	MAX14577_REG_CDETCTRL1 = 10,
	MAX14577_REG_RFU = 11,
	MAX14577_REG_CONTROL1 = 12,
	MAX14577_REG_CONTROL2 = 13,
	MAX14577_REG_CONTROL3 = 14,
	MAX14577_REG_CHGCTRL1 = 15,
	MAX14577_REG_CHGCTRL2 = 16,
	MAX14577_REG_CHGCTRL3 = 17,
	MAX14577_REG_CHGCTRL4 = 18,
	MAX14577_REG_CHGCTRL5 = 19,
	MAX14577_REG_CHGCTRL6 = 20,
	MAX14577_REG_CHGCTRL7 = 21,
	MAX14577_REG_END = 22,
};

enum max77836_pmic_reg {
	MAX77836_PMIC_REG_PMIC_ID = 32,
	MAX77836_PMIC_REG_PMIC_REV = 33,
	MAX77836_PMIC_REG_INTSRC = 34,
	MAX77836_PMIC_REG_INTSRC_MASK = 35,
	MAX77836_PMIC_REG_TOPSYS_INT = 36,
	MAX77836_PMIC_REG_TOPSYS_INT_MASK = 38,
	MAX77836_PMIC_REG_TOPSYS_STAT = 40,
	MAX77836_PMIC_REG_MRSTB_CNTL = 42,
	MAX77836_PMIC_REG_LSCNFG = 43,
	MAX77836_LDO_REG_CNFG1_LDO1 = 81,
	MAX77836_LDO_REG_CNFG2_LDO1 = 82,
	MAX77836_LDO_REG_CNFG1_LDO2 = 83,
	MAX77836_LDO_REG_CNFG2_LDO2 = 84,
	MAX77836_LDO_REG_CNFG_LDO_BIAS = 85,
	MAX77836_COMP_REG_COMP1 = 96,
	MAX77836_PMIC_REG_END = 97,
};

enum max77836_fg_reg {
	MAX77836_FG_REG_VCELL_MSB = 2,
	MAX77836_FG_REG_VCELL_LSB = 3,
	MAX77836_FG_REG_SOC_MSB = 4,
	MAX77836_FG_REG_SOC_LSB = 5,
	MAX77836_FG_REG_MODE_H = 6,
	MAX77836_FG_REG_MODE_L = 7,
	MAX77836_FG_REG_VERSION_MSB = 8,
	MAX77836_FG_REG_VERSION_LSB = 9,
	MAX77836_FG_REG_HIBRT_H = 10,
	MAX77836_FG_REG_HIBRT_L = 11,
	MAX77836_FG_REG_CONFIG_H = 12,
	MAX77836_FG_REG_CONFIG_L = 13,
	MAX77836_FG_REG_VALRT_MIN = 20,
	MAX77836_FG_REG_VALRT_MAX = 21,
	MAX77836_FG_REG_CRATE_MSB = 22,
	MAX77836_FG_REG_CRATE_LSB = 23,
	MAX77836_FG_REG_VRESET = 24,
	MAX77836_FG_REG_FGID = 25,
	MAX77836_FG_REG_STATUS_H = 26,
	MAX77836_FG_REG_STATUS_L = 27,
	MAX77836_FG_REG_END = 28,
};

struct max14577 {
	struct device *dev;
	struct i2c_client *i2c;
	struct i2c_client *i2c_pmic;
	enum maxim_device_type dev_type;
	struct regmap *regmap;
	struct regmap *regmap_pmic;
	struct regmap_irq_chip_data *irq_data;
	struct regmap_irq_chip_data *irq_data_pmic;
	int irq;
};

enum {
	MAX77620_IRQ_TOP_GLBL = 0,
	MAX77620_IRQ_TOP_SD = 1,
	MAX77620_IRQ_TOP_LDO = 2,
	MAX77620_IRQ_TOP_GPIO = 3,
	MAX77620_IRQ_TOP_RTC = 4,
	MAX77620_IRQ_TOP_32K = 5,
	MAX77620_IRQ_TOP_ONOFF = 6,
	MAX77620_IRQ_LBT_MBATLOW = 7,
	MAX77620_IRQ_LBT_TJALRM1 = 8,
	MAX77620_IRQ_LBT_TJALRM2 = 9,
};

enum max77620_chip_id {
	MAX77620 = 0,
	MAX20024 = 1,
	MAX77663 = 2,
};

struct max77620_chip {
	struct device *dev;
	struct regmap *rmap;
	int chip_irq;
	enum max77620_chip_id chip_id;
	bool sleep_enable;
	bool enable_global_lpm;
	int shutdown_fps_period[3];
	int suspend_fps_period[3];
	struct regmap_irq_chip_data *top_irq_data;
	struct regmap_irq_chip_data *gpio_irq_data;
};

enum max77686_pmic_reg {
	MAX77686_REG_DEVICE_ID = 0,
	MAX77686_REG_INTSRC = 1,
	MAX77686_REG_INT1 = 2,
	MAX77686_REG_INT2 = 3,
	MAX77686_REG_INT1MSK = 4,
	MAX77686_REG_INT2MSK = 5,
	MAX77686_REG_STATUS1 = 6,
	MAX77686_REG_STATUS2 = 7,
	MAX77686_REG_PWRON = 8,
	MAX77686_REG_ONOFF_DELAY = 9,
	MAX77686_REG_MRSTB = 10,
	MAX77686_REG_BUCK1CTRL = 16,
	MAX77686_REG_BUCK1OUT = 17,
	MAX77686_REG_BUCK2CTRL1 = 18,
	MAX77686_REG_BUCK234FREQ = 19,
	MAX77686_REG_BUCK2DVS1 = 20,
	MAX77686_REG_BUCK2DVS2 = 21,
	MAX77686_REG_BUCK2DVS3 = 22,
	MAX77686_REG_BUCK2DVS4 = 23,
	MAX77686_REG_BUCK2DVS5 = 24,
	MAX77686_REG_BUCK2DVS6 = 25,
	MAX77686_REG_BUCK2DVS7 = 26,
	MAX77686_REG_BUCK2DVS8 = 27,
	MAX77686_REG_BUCK3CTRL1 = 28,
	MAX77686_REG_BUCK3DVS1 = 30,
	MAX77686_REG_BUCK3DVS2 = 31,
	MAX77686_REG_BUCK3DVS3 = 32,
	MAX77686_REG_BUCK3DVS4 = 33,
	MAX77686_REG_BUCK3DVS5 = 34,
	MAX77686_REG_BUCK3DVS6 = 35,
	MAX77686_REG_BUCK3DVS7 = 36,
	MAX77686_REG_BUCK3DVS8 = 37,
	MAX77686_REG_BUCK4CTRL1 = 38,
	MAX77686_REG_BUCK4DVS1 = 40,
	MAX77686_REG_BUCK4DVS2 = 41,
	MAX77686_REG_BUCK4DVS3 = 42,
	MAX77686_REG_BUCK4DVS4 = 43,
	MAX77686_REG_BUCK4DVS5 = 44,
	MAX77686_REG_BUCK4DVS6 = 45,
	MAX77686_REG_BUCK4DVS7 = 46,
	MAX77686_REG_BUCK4DVS8 = 47,
	MAX77686_REG_BUCK5CTRL = 48,
	MAX77686_REG_BUCK5OUT = 49,
	MAX77686_REG_BUCK6CTRL = 50,
	MAX77686_REG_BUCK6OUT = 51,
	MAX77686_REG_BUCK7CTRL = 52,
	MAX77686_REG_BUCK7OUT = 53,
	MAX77686_REG_BUCK8CTRL = 54,
	MAX77686_REG_BUCK8OUT = 55,
	MAX77686_REG_BUCK9CTRL = 56,
	MAX77686_REG_BUCK9OUT = 57,
	MAX77686_REG_LDO1CTRL1 = 64,
	MAX77686_REG_LDO2CTRL1 = 65,
	MAX77686_REG_LDO3CTRL1 = 66,
	MAX77686_REG_LDO4CTRL1 = 67,
	MAX77686_REG_LDO5CTRL1 = 68,
	MAX77686_REG_LDO6CTRL1 = 69,
	MAX77686_REG_LDO7CTRL1 = 70,
	MAX77686_REG_LDO8CTRL1 = 71,
	MAX77686_REG_LDO9CTRL1 = 72,
	MAX77686_REG_LDO10CTRL1 = 73,
	MAX77686_REG_LDO11CTRL1 = 74,
	MAX77686_REG_LDO12CTRL1 = 75,
	MAX77686_REG_LDO13CTRL1 = 76,
	MAX77686_REG_LDO14CTRL1 = 77,
	MAX77686_REG_LDO15CTRL1 = 78,
	MAX77686_REG_LDO16CTRL1 = 79,
	MAX77686_REG_LDO17CTRL1 = 80,
	MAX77686_REG_LDO18CTRL1 = 81,
	MAX77686_REG_LDO19CTRL1 = 82,
	MAX77686_REG_LDO20CTRL1 = 83,
	MAX77686_REG_LDO21CTRL1 = 84,
	MAX77686_REG_LDO22CTRL1 = 85,
	MAX77686_REG_LDO23CTRL1 = 86,
	MAX77686_REG_LDO24CTRL1 = 87,
	MAX77686_REG_LDO25CTRL1 = 88,
	MAX77686_REG_LDO26CTRL1 = 89,
	MAX77686_REG_LDO1CTRL2 = 96,
	MAX77686_REG_LDO2CTRL2 = 97,
	MAX77686_REG_LDO3CTRL2 = 98,
	MAX77686_REG_LDO4CTRL2 = 99,
	MAX77686_REG_LDO5CTRL2 = 100,
	MAX77686_REG_LDO6CTRL2 = 101,
	MAX77686_REG_LDO7CTRL2 = 102,
	MAX77686_REG_LDO8CTRL2 = 103,
	MAX77686_REG_LDO9CTRL2 = 104,
	MAX77686_REG_LDO10CTRL2 = 105,
	MAX77686_REG_LDO11CTRL2 = 106,
	MAX77686_REG_LDO12CTRL2 = 107,
	MAX77686_REG_LDO13CTRL2 = 108,
	MAX77686_REG_LDO14CTRL2 = 109,
	MAX77686_REG_LDO15CTRL2 = 110,
	MAX77686_REG_LDO16CTRL2 = 111,
	MAX77686_REG_LDO17CTRL2 = 112,
	MAX77686_REG_LDO18CTRL2 = 113,
	MAX77686_REG_LDO19CTRL2 = 114,
	MAX77686_REG_LDO20CTRL2 = 115,
	MAX77686_REG_LDO21CTRL2 = 116,
	MAX77686_REG_LDO22CTRL2 = 117,
	MAX77686_REG_LDO23CTRL2 = 118,
	MAX77686_REG_LDO24CTRL2 = 119,
	MAX77686_REG_LDO25CTRL2 = 120,
	MAX77686_REG_LDO26CTRL2 = 121,
	MAX77686_REG_BBAT_CHG = 126,
	MAX77686_REG_32KHZ = 127,
	MAX77686_REG_PMIC_END = 128,
};

enum max77802_pmic_reg {
	MAX77802_REG_DEVICE_ID = 0,
	MAX77802_REG_INTSRC = 1,
	MAX77802_REG_INT1 = 2,
	MAX77802_REG_INT2 = 3,
	MAX77802_REG_INT1MSK = 4,
	MAX77802_REG_INT2MSK = 5,
	MAX77802_REG_STATUS1 = 6,
	MAX77802_REG_STATUS2 = 7,
	MAX77802_REG_PWRON = 8,
	MAX77802_REG_MRSTB = 10,
	MAX77802_REG_EPWRHOLD = 11,
	MAX77802_REG_BOOSTCTRL = 14,
	MAX77802_REG_BOOSTOUT = 15,
	MAX77802_REG_BUCK1CTRL = 16,
	MAX77802_REG_BUCK1DVS1 = 17,
	MAX77802_REG_BUCK1DVS2 = 18,
	MAX77802_REG_BUCK1DVS3 = 19,
	MAX77802_REG_BUCK1DVS4 = 20,
	MAX77802_REG_BUCK1DVS5 = 21,
	MAX77802_REG_BUCK1DVS6 = 22,
	MAX77802_REG_BUCK1DVS7 = 23,
	MAX77802_REG_BUCK1DVS8 = 24,
	MAX77802_REG_BUCK2CTRL1 = 26,
	MAX77802_REG_BUCK2CTRL2 = 27,
	MAX77802_REG_BUCK2PHTRAN = 28,
	MAX77802_REG_BUCK2DVS1 = 29,
	MAX77802_REG_BUCK2DVS2 = 30,
	MAX77802_REG_BUCK2DVS3 = 31,
	MAX77802_REG_BUCK2DVS4 = 32,
	MAX77802_REG_BUCK2DVS5 = 33,
	MAX77802_REG_BUCK2DVS6 = 34,
	MAX77802_REG_BUCK2DVS7 = 35,
	MAX77802_REG_BUCK2DVS8 = 36,
	MAX77802_REG_BUCK3CTRL1 = 39,
	MAX77802_REG_BUCK3DVS1 = 40,
	MAX77802_REG_BUCK3DVS2 = 41,
	MAX77802_REG_BUCK3DVS3 = 42,
	MAX77802_REG_BUCK3DVS4 = 43,
	MAX77802_REG_BUCK3DVS5 = 44,
	MAX77802_REG_BUCK3DVS6 = 45,
	MAX77802_REG_BUCK3DVS7 = 46,
	MAX77802_REG_BUCK3DVS8 = 47,
	MAX77802_REG_BUCK4CTRL1 = 55,
	MAX77802_REG_BUCK4DVS1 = 56,
	MAX77802_REG_BUCK4DVS2 = 57,
	MAX77802_REG_BUCK4DVS3 = 58,
	MAX77802_REG_BUCK4DVS4 = 59,
	MAX77802_REG_BUCK4DVS5 = 60,
	MAX77802_REG_BUCK4DVS6 = 61,
	MAX77802_REG_BUCK4DVS7 = 62,
	MAX77802_REG_BUCK4DVS8 = 63,
	MAX77802_REG_BUCK5CTRL = 65,
	MAX77802_REG_BUCK5OUT = 66,
	MAX77802_REG_BUCK6CTRL = 68,
	MAX77802_REG_BUCK6DVS1 = 69,
	MAX77802_REG_BUCK6DVS2 = 70,
	MAX77802_REG_BUCK6DVS3 = 71,
	MAX77802_REG_BUCK6DVS4 = 72,
	MAX77802_REG_BUCK6DVS5 = 73,
	MAX77802_REG_BUCK6DVS6 = 74,
	MAX77802_REG_BUCK6DVS7 = 75,
	MAX77802_REG_BUCK6DVS8 = 76,
	MAX77802_REG_BUCK7CTRL = 78,
	MAX77802_REG_BUCK7OUT = 79,
	MAX77802_REG_BUCK8CTRL = 81,
	MAX77802_REG_BUCK8OUT = 82,
	MAX77802_REG_BUCK9CTRL = 84,
	MAX77802_REG_BUCK9OUT = 85,
	MAX77802_REG_BUCK10CTRL = 87,
	MAX77802_REG_BUCK10OUT = 88,
	MAX77802_REG_LDO1CTRL1 = 96,
	MAX77802_REG_LDO2CTRL1 = 97,
	MAX77802_REG_LDO3CTRL1 = 98,
	MAX77802_REG_LDO4CTRL1 = 99,
	MAX77802_REG_LDO5CTRL1 = 100,
	MAX77802_REG_LDO6CTRL1 = 101,
	MAX77802_REG_LDO7CTRL1 = 102,
	MAX77802_REG_LDO8CTRL1 = 103,
	MAX77802_REG_LDO9CTRL1 = 104,
	MAX77802_REG_LDO10CTRL1 = 105,
	MAX77802_REG_LDO11CTRL1 = 106,
	MAX77802_REG_LDO12CTRL1 = 107,
	MAX77802_REG_LDO13CTRL1 = 108,
	MAX77802_REG_LDO14CTRL1 = 109,
	MAX77802_REG_LDO15CTRL1 = 110,
	MAX77802_REG_LDO17CTRL1 = 112,
	MAX77802_REG_LDO18CTRL1 = 113,
	MAX77802_REG_LDO19CTRL1 = 114,
	MAX77802_REG_LDO20CTRL1 = 115,
	MAX77802_REG_LDO21CTRL1 = 116,
	MAX77802_REG_LDO22CTRL1 = 117,
	MAX77802_REG_LDO23CTRL1 = 118,
	MAX77802_REG_LDO24CTRL1 = 119,
	MAX77802_REG_LDO25CTRL1 = 120,
	MAX77802_REG_LDO26CTRL1 = 121,
	MAX77802_REG_LDO27CTRL1 = 122,
	MAX77802_REG_LDO28CTRL1 = 123,
	MAX77802_REG_LDO29CTRL1 = 124,
	MAX77802_REG_LDO30CTRL1 = 125,
	MAX77802_REG_LDO32CTRL1 = 127,
	MAX77802_REG_LDO33CTRL1 = 128,
	MAX77802_REG_LDO34CTRL1 = 129,
	MAX77802_REG_LDO35CTRL1 = 130,
	MAX77802_REG_LDO1CTRL2 = 144,
	MAX77802_REG_LDO2CTRL2 = 145,
	MAX77802_REG_LDO3CTRL2 = 146,
	MAX77802_REG_LDO4CTRL2 = 147,
	MAX77802_REG_LDO5CTRL2 = 148,
	MAX77802_REG_LDO6CTRL2 = 149,
	MAX77802_REG_LDO7CTRL2 = 150,
	MAX77802_REG_LDO8CTRL2 = 151,
	MAX77802_REG_LDO9CTRL2 = 152,
	MAX77802_REG_LDO10CTRL2 = 153,
	MAX77802_REG_LDO11CTRL2 = 154,
	MAX77802_REG_LDO12CTRL2 = 155,
	MAX77802_REG_LDO13CTRL2 = 156,
	MAX77802_REG_LDO14CTRL2 = 157,
	MAX77802_REG_LDO15CTRL2 = 158,
	MAX77802_REG_LDO17CTRL2 = 160,
	MAX77802_REG_LDO18CTRL2 = 161,
	MAX77802_REG_LDO19CTRL2 = 162,
	MAX77802_REG_LDO20CTRL2 = 163,
	MAX77802_REG_LDO21CTRL2 = 164,
	MAX77802_REG_LDO22CTRL2 = 165,
	MAX77802_REG_LDO23CTRL2 = 166,
	MAX77802_REG_LDO24CTRL2 = 167,
	MAX77802_REG_LDO25CTRL2 = 168,
	MAX77802_REG_LDO26CTRL2 = 169,
	MAX77802_REG_LDO27CTRL2 = 170,
	MAX77802_REG_LDO28CTRL2 = 171,
	MAX77802_REG_LDO29CTRL2 = 172,
	MAX77802_REG_LDO30CTRL2 = 173,
	MAX77802_REG_LDO32CTRL2 = 175,
	MAX77802_REG_LDO33CTRL2 = 176,
	MAX77802_REG_LDO34CTRL2 = 177,
	MAX77802_REG_LDO35CTRL2 = 178,
	MAX77802_REG_BBAT_CHG = 180,
	MAX77802_REG_32KHZ = 181,
	MAX77802_REG_PMIC_END = 182,
};

enum max77802_rtc_reg {
	MAX77802_RTC_INT = 192,
	MAX77802_RTC_INTM = 193,
	MAX77802_RTC_CONTROLM = 194,
	MAX77802_RTC_CONTROL = 195,
	MAX77802_RTC_UPDATE0 = 196,
	MAX77802_RTC_UPDATE1 = 197,
	MAX77802_WTSR_SMPL_CNTL = 198,
	MAX77802_RTC_SEC = 199,
	MAX77802_RTC_MIN = 200,
	MAX77802_RTC_HOUR = 201,
	MAX77802_RTC_WEEKDAY = 202,
	MAX77802_RTC_MONTH = 203,
	MAX77802_RTC_YEAR = 204,
	MAX77802_RTC_DATE = 205,
	MAX77802_RTC_AE1 = 206,
	MAX77802_ALARM1_SEC = 207,
	MAX77802_ALARM1_MIN = 208,
	MAX77802_ALARM1_HOUR = 209,
	MAX77802_ALARM1_WEEKDAY = 210,
	MAX77802_ALARM1_MONTH = 211,
	MAX77802_ALARM1_YEAR = 212,
	MAX77802_ALARM1_DATE = 213,
	MAX77802_RTC_AE2 = 214,
	MAX77802_ALARM2_SEC = 215,
	MAX77802_ALARM2_MIN = 216,
	MAX77802_ALARM2_HOUR = 217,
	MAX77802_ALARM2_WEEKDAY = 218,
	MAX77802_ALARM2_MONTH = 219,
	MAX77802_ALARM2_YEAR = 220,
	MAX77802_ALARM2_DATE = 221,
	MAX77802_RTC_END = 223,
};

enum max77686_irq_source {
	PMIC_INT1 = 0,
	PMIC_INT2 = 1,
	RTC_INT = 2,
	MAX77686_IRQ_GROUP_NR = 3,
};

struct max77686_dev {
	struct device *dev;
	struct i2c_client *i2c;
	long unsigned int type;
	struct regmap *regmap;
	struct regmap_irq_chip_data *irq_data;
	int irq;
	struct mutex irqlock;
	int irq_masks_cur[3];
	int irq_masks_cache[3];
};

enum max77686_types {
	TYPE_MAX77686 = 0,
	TYPE_MAX77802 = 1,
};

enum max77693_types {
	TYPE_MAX77693_UNKNOWN = 0,
	TYPE_MAX77693 = 1,
	TYPE_MAX77843 = 2,
	TYPE_MAX77693_NUM = 3,
};

struct max77693_dev {
	struct device *dev;
	struct i2c_client *i2c;
	struct i2c_client *i2c_muic;
	struct i2c_client *i2c_haptic;
	struct i2c_client *i2c_chg;
	enum max77693_types type;
	struct regmap *regmap;
	struct regmap *regmap_muic;
	struct regmap *regmap_haptic;
	struct regmap *regmap_chg;
	struct regmap_irq_chip_data *irq_data_led;
	struct regmap_irq_chip_data *irq_data_topsys;
	struct regmap_irq_chip_data *irq_data_chg;
	struct regmap_irq_chip_data *irq_data_muic;
	int irq;
};

enum max77693_pmic_reg {
	MAX77693_LED_REG_IFLASH1 = 0,
	MAX77693_LED_REG_IFLASH2 = 1,
	MAX77693_LED_REG_ITORCH = 2,
	MAX77693_LED_REG_ITORCHTIMER = 3,
	MAX77693_LED_REG_FLASH_TIMER = 4,
	MAX77693_LED_REG_FLASH_EN = 5,
	MAX77693_LED_REG_MAX_FLASH1 = 6,
	MAX77693_LED_REG_MAX_FLASH2 = 7,
	MAX77693_LED_REG_MAX_FLASH3 = 8,
	MAX77693_LED_REG_MAX_FLASH4 = 9,
	MAX77693_LED_REG_VOUT_CNTL = 10,
	MAX77693_LED_REG_VOUT_FLASH1 = 11,
	MAX77693_LED_REG_VOUT_FLASH2 = 12,
	MAX77693_LED_REG_FLASH_INT = 14,
	MAX77693_LED_REG_FLASH_INT_MASK = 15,
	MAX77693_LED_REG_FLASH_STATUS = 16,
	MAX77693_PMIC_REG_PMIC_ID1 = 32,
	MAX77693_PMIC_REG_PMIC_ID2 = 33,
	MAX77693_PMIC_REG_INTSRC = 34,
	MAX77693_PMIC_REG_INTSRC_MASK = 35,
	MAX77693_PMIC_REG_TOPSYS_INT = 36,
	MAX77693_PMIC_REG_TOPSYS_INT_MASK = 38,
	MAX77693_PMIC_REG_TOPSYS_STAT = 40,
	MAX77693_PMIC_REG_MAINCTRL1 = 42,
	MAX77693_PMIC_REG_LSCNFG = 43,
	MAX77693_CHG_REG_CHG_INT = 176,
	MAX77693_CHG_REG_CHG_INT_MASK = 177,
	MAX77693_CHG_REG_CHG_INT_OK = 178,
	MAX77693_CHG_REG_CHG_DETAILS_00 = 179,
	MAX77693_CHG_REG_CHG_DETAILS_01 = 180,
	MAX77693_CHG_REG_CHG_DETAILS_02 = 181,
	MAX77693_CHG_REG_CHG_DETAILS_03 = 182,
	MAX77693_CHG_REG_CHG_CNFG_00 = 183,
	MAX77693_CHG_REG_CHG_CNFG_01 = 184,
	MAX77693_CHG_REG_CHG_CNFG_02 = 185,
	MAX77693_CHG_REG_CHG_CNFG_03 = 186,
	MAX77693_CHG_REG_CHG_CNFG_04 = 187,
	MAX77693_CHG_REG_CHG_CNFG_05 = 188,
	MAX77693_CHG_REG_CHG_CNFG_06 = 189,
	MAX77693_CHG_REG_CHG_CNFG_07 = 190,
	MAX77693_CHG_REG_CHG_CNFG_08 = 191,
	MAX77693_CHG_REG_CHG_CNFG_09 = 192,
	MAX77693_CHG_REG_CHG_CNFG_10 = 193,
	MAX77693_CHG_REG_CHG_CNFG_11 = 194,
	MAX77693_CHG_REG_CHG_CNFG_12 = 195,
	MAX77693_CHG_REG_CHG_CNFG_13 = 196,
	MAX77693_CHG_REG_CHG_CNFG_14 = 197,
	MAX77693_CHG_REG_SAFEOUT_CTRL = 198,
	MAX77693_PMIC_REG_END = 199,
};

enum max77693_muic_reg {
	MAX77693_MUIC_REG_ID = 0,
	MAX77693_MUIC_REG_INT1 = 1,
	MAX77693_MUIC_REG_INT2 = 2,
	MAX77693_MUIC_REG_INT3 = 3,
	MAX77693_MUIC_REG_STATUS1 = 4,
	MAX77693_MUIC_REG_STATUS2 = 5,
	MAX77693_MUIC_REG_STATUS3 = 6,
	MAX77693_MUIC_REG_INTMASK1 = 7,
	MAX77693_MUIC_REG_INTMASK2 = 8,
	MAX77693_MUIC_REG_INTMASK3 = 9,
	MAX77693_MUIC_REG_CDETCTRL1 = 10,
	MAX77693_MUIC_REG_CDETCTRL2 = 11,
	MAX77693_MUIC_REG_CTRL1 = 12,
	MAX77693_MUIC_REG_CTRL2 = 13,
	MAX77693_MUIC_REG_CTRL3 = 14,
	MAX77693_MUIC_REG_END = 15,
};

enum max77693_haptic_reg {
	MAX77693_HAPTIC_REG_STATUS = 0,
	MAX77693_HAPTIC_REG_CONFIG1 = 1,
	MAX77693_HAPTIC_REG_CONFIG2 = 2,
	MAX77693_HAPTIC_REG_CONFIG_CHNL = 3,
	MAX77693_HAPTIC_REG_CONFG_CYC1 = 4,
	MAX77693_HAPTIC_REG_CONFG_CYC2 = 5,
	MAX77693_HAPTIC_REG_CONFIG_PER1 = 6,
	MAX77693_HAPTIC_REG_CONFIG_PER2 = 7,
	MAX77693_HAPTIC_REG_CONFIG_PER3 = 8,
	MAX77693_HAPTIC_REG_CONFIG_PER4 = 9,
	MAX77693_HAPTIC_REG_CONFIG_DUTY1 = 10,
	MAX77693_HAPTIC_REG_CONFIG_DUTY2 = 11,
	MAX77693_HAPTIC_REG_CONFIG_PWM1 = 12,
	MAX77693_HAPTIC_REG_CONFIG_PWM2 = 13,
	MAX77693_HAPTIC_REG_CONFIG_PWM3 = 14,
	MAX77693_HAPTIC_REG_CONFIG_PWM4 = 15,
	MAX77693_HAPTIC_REG_REV = 16,
	MAX77693_HAPTIC_REG_END = 17,
};

enum max77843_sys_reg {
	MAX77843_SYS_REG_PMICID = 0,
	MAX77843_SYS_REG_PMICREV = 1,
	MAX77843_SYS_REG_MAINCTRL1 = 2,
	MAX77843_SYS_REG_INTSRC = 34,
	MAX77843_SYS_REG_INTSRCMASK = 35,
	MAX77843_SYS_REG_SYSINTSRC = 36,
	MAX77843_SYS_REG_SYSINTMASK = 38,
	MAX77843_SYS_REG_TOPSYS_STAT = 40,
	MAX77843_SYS_REG_SAFEOUTCTRL = 198,
	MAX77843_SYS_REG_END = 199,
};

enum max77843_charger_reg {
	MAX77843_CHG_REG_CHG_INT = 176,
	MAX77843_CHG_REG_CHG_INT_MASK = 177,
	MAX77843_CHG_REG_CHG_INT_OK = 178,
	MAX77843_CHG_REG_CHG_DTLS_00 = 179,
	MAX77843_CHG_REG_CHG_DTLS_01 = 180,
	MAX77843_CHG_REG_CHG_DTLS_02 = 181,
	MAX77843_CHG_REG_CHG_CNFG_00 = 183,
	MAX77843_CHG_REG_CHG_CNFG_01 = 184,
	MAX77843_CHG_REG_CHG_CNFG_02 = 185,
	MAX77843_CHG_REG_CHG_CNFG_03 = 186,
	MAX77843_CHG_REG_CHG_CNFG_04 = 187,
	MAX77843_CHG_REG_CHG_CNFG_06 = 189,
	MAX77843_CHG_REG_CHG_CNFG_07 = 190,
	MAX77843_CHG_REG_CHG_CNFG_09 = 192,
	MAX77843_CHG_REG_CHG_CNFG_10 = 193,
	MAX77843_CHG_REG_CHG_CNFG_11 = 194,
	MAX77843_CHG_REG_CHG_CNFG_12 = 195,
	MAX77843_CHG_REG_END = 196,
};

enum {
	MAX8925_IRQ_VCHG_DC_OVP = 0,
	MAX8925_IRQ_VCHG_DC_F = 1,
	MAX8925_IRQ_VCHG_DC_R = 2,
	MAX8925_IRQ_VCHG_THM_OK_R = 3,
	MAX8925_IRQ_VCHG_THM_OK_F = 4,
	MAX8925_IRQ_VCHG_SYSLOW_F = 5,
	MAX8925_IRQ_VCHG_SYSLOW_R = 6,
	MAX8925_IRQ_VCHG_RST = 7,
	MAX8925_IRQ_VCHG_DONE = 8,
	MAX8925_IRQ_VCHG_TOPOFF = 9,
	MAX8925_IRQ_VCHG_TMR_FAULT = 10,
	MAX8925_IRQ_GPM_RSTIN = 11,
	MAX8925_IRQ_GPM_MPL = 12,
	MAX8925_IRQ_GPM_SW_3SEC = 13,
	MAX8925_IRQ_GPM_EXTON_F = 14,
	MAX8925_IRQ_GPM_EXTON_R = 15,
	MAX8925_IRQ_GPM_SW_1SEC = 16,
	MAX8925_IRQ_GPM_SW_F = 17,
	MAX8925_IRQ_GPM_SW_R = 18,
	MAX8925_IRQ_GPM_SYSCKEN_F = 19,
	MAX8925_IRQ_GPM_SYSCKEN_R = 20,
	MAX8925_IRQ_RTC_ALARM1 = 21,
	MAX8925_IRQ_RTC_ALARM0 = 22,
	MAX8925_IRQ_TSC_STICK = 23,
	MAX8925_IRQ_TSC_NSTICK = 24,
	MAX8925_NR_IRQS = 25,
};

struct max8925_chip {
	struct device *dev;
	struct i2c_client *i2c;
	struct i2c_client *adc;
	struct i2c_client *rtc;
	struct mutex io_lock;
	struct mutex irq_lock;
	int irq_base;
	int core_irq;
	int tsc_irq;
	unsigned int wakeup_flag;
};

struct max8925_backlight_pdata {
	int lxw_scl;
	int lxw_freq;
	int dual_string;
};

struct max8925_touch_pdata {
	unsigned int flags;
};

struct max8925_power_pdata {
	int (*set_charger)(int);
	unsigned int batt_detect: 1;
	unsigned int topoff_threshold: 2;
	unsigned int fast_charge: 3;
	unsigned int no_temp_support: 1;
	unsigned int no_insert_detect: 1;
	char **supplied_to;
	int num_supplicants;
};

struct max8925_platform_data {
	struct max8925_backlight_pdata *backlight;
	struct max8925_touch_pdata *touch;
	struct max8925_power_pdata *power;
	struct regulator_init_data *sd1;
	struct regulator_init_data *sd2;
	struct regulator_init_data *sd3;
	struct regulator_init_data *ldo1;
	struct regulator_init_data *ldo2;
	struct regulator_init_data *ldo3;
	struct regulator_init_data *ldo4;
	struct regulator_init_data *ldo5;
	struct regulator_init_data *ldo6;
	struct regulator_init_data *ldo7;
	struct regulator_init_data *ldo8;
	struct regulator_init_data *ldo9;
	struct regulator_init_data *ldo10;
	struct regulator_init_data *ldo11;
	struct regulator_init_data *ldo12;
	struct regulator_init_data *ldo13;
	struct regulator_init_data *ldo14;
	struct regulator_init_data *ldo15;
	struct regulator_init_data *ldo16;
	struct regulator_init_data *ldo17;
	struct regulator_init_data *ldo18;
	struct regulator_init_data *ldo19;
	struct regulator_init_data *ldo20;
	int irq_base;
	int tsc_irq;
};

enum {
	FLAGS_ADC = 1,
	FLAGS_RTC = 2,
};

struct max8925_irq_data {
	int reg;
	int mask_reg;
	int enable;
	int offs;
	int flags;
	int tsc_irq;
};

struct max8997_regulator_data {
	int id;
	struct regulator_init_data *initdata;
	struct device_node *reg_node;
};

struct max8997_muic_reg_data {
	u8 addr;
	u8 data;
};

struct max8997_muic_platform_data {
	struct max8997_muic_reg_data *init_data;
	int num_init_data;
	int detcable_delay_ms;
	int path_usb;
	int path_uart;
};

enum max8997_haptic_motor_type {
	MAX8997_HAPTIC_ERM = 0,
	MAX8997_HAPTIC_LRA = 1,
};

enum max8997_haptic_pulse_mode {
	MAX8997_EXTERNAL_MODE = 0,
	MAX8997_INTERNAL_MODE = 1,
};

enum max8997_haptic_pwm_divisor {
	MAX8997_PWM_DIVISOR_32 = 0,
	MAX8997_PWM_DIVISOR_64 = 1,
	MAX8997_PWM_DIVISOR_128 = 2,
	MAX8997_PWM_DIVISOR_256 = 3,
};

struct max8997_haptic_platform_data {
	unsigned int pwm_channel_id;
	unsigned int pwm_period;
	enum max8997_haptic_motor_type type;
	enum max8997_haptic_pulse_mode mode;
	enum max8997_haptic_pwm_divisor pwm_divisor;
	unsigned int internal_mode_pattern;
	unsigned int pattern_cycle;
	unsigned int pattern_signal_period;
};

enum max8997_led_mode {
	MAX8997_NONE = 0,
	MAX8997_FLASH_MODE = 1,
	MAX8997_MOVIE_MODE = 2,
	MAX8997_FLASH_PIN_CONTROL_MODE = 3,
	MAX8997_MOVIE_PIN_CONTROL_MODE = 4,
};

struct max8997_led_platform_data {
	enum max8997_led_mode mode[2];
	u8 brightness[2];
};

struct max8997_platform_data {
	int ono;
	struct max8997_regulator_data *regulators;
	int num_regulators;
	bool ignore_gpiodvs_side_effect;
	int buck125_gpios[3];
	int buck125_default_idx;
	unsigned int buck1_voltage[8];
	bool buck1_gpiodvs;
	unsigned int buck2_voltage[8];
	bool buck2_gpiodvs;
	unsigned int buck5_voltage[8];
	bool buck5_gpiodvs;
	int eoc_mA;
	int timeout;
	struct max8997_muic_platform_data *muic_pdata;
	struct max8997_haptic_platform_data *haptic_pdata;
	struct max8997_led_platform_data *led_pdata;
};

enum max8997_pmic_reg {
	MAX8997_REG_PMIC_ID0 = 0,
	MAX8997_REG_PMIC_ID1 = 1,
	MAX8997_REG_INTSRC = 2,
	MAX8997_REG_INT1 = 3,
	MAX8997_REG_INT2 = 4,
	MAX8997_REG_INT3 = 5,
	MAX8997_REG_INT4 = 6,
	MAX8997_REG_INT1MSK = 8,
	MAX8997_REG_INT2MSK = 9,
	MAX8997_REG_INT3MSK = 10,
	MAX8997_REG_INT4MSK = 11,
	MAX8997_REG_STATUS1 = 13,
	MAX8997_REG_STATUS2 = 14,
	MAX8997_REG_STATUS3 = 15,
	MAX8997_REG_STATUS4 = 16,
	MAX8997_REG_MAINCON1 = 19,
	MAX8997_REG_MAINCON2 = 20,
	MAX8997_REG_BUCKRAMP = 21,
	MAX8997_REG_BUCK1CTRL = 24,
	MAX8997_REG_BUCK1DVS1 = 25,
	MAX8997_REG_BUCK1DVS2 = 26,
	MAX8997_REG_BUCK1DVS3 = 27,
	MAX8997_REG_BUCK1DVS4 = 28,
	MAX8997_REG_BUCK1DVS5 = 29,
	MAX8997_REG_BUCK1DVS6 = 30,
	MAX8997_REG_BUCK1DVS7 = 31,
	MAX8997_REG_BUCK1DVS8 = 32,
	MAX8997_REG_BUCK2CTRL = 33,
	MAX8997_REG_BUCK2DVS1 = 34,
	MAX8997_REG_BUCK2DVS2 = 35,
	MAX8997_REG_BUCK2DVS3 = 36,
	MAX8997_REG_BUCK2DVS4 = 37,
	MAX8997_REG_BUCK2DVS5 = 38,
	MAX8997_REG_BUCK2DVS6 = 39,
	MAX8997_REG_BUCK2DVS7 = 40,
	MAX8997_REG_BUCK2DVS8 = 41,
	MAX8997_REG_BUCK3CTRL = 42,
	MAX8997_REG_BUCK3DVS = 43,
	MAX8997_REG_BUCK4CTRL = 44,
	MAX8997_REG_BUCK4DVS = 45,
	MAX8997_REG_BUCK5CTRL = 46,
	MAX8997_REG_BUCK5DVS1 = 47,
	MAX8997_REG_BUCK5DVS2 = 48,
	MAX8997_REG_BUCK5DVS3 = 49,
	MAX8997_REG_BUCK5DVS4 = 50,
	MAX8997_REG_BUCK5DVS5 = 51,
	MAX8997_REG_BUCK5DVS6 = 52,
	MAX8997_REG_BUCK5DVS7 = 53,
	MAX8997_REG_BUCK5DVS8 = 54,
	MAX8997_REG_BUCK6CTRL = 55,
	MAX8997_REG_BUCK6BPSKIPCTRL = 56,
	MAX8997_REG_BUCK7CTRL = 57,
	MAX8997_REG_BUCK7DVS = 58,
	MAX8997_REG_LDO1CTRL = 59,
	MAX8997_REG_LDO2CTRL = 60,
	MAX8997_REG_LDO3CTRL = 61,
	MAX8997_REG_LDO4CTRL = 62,
	MAX8997_REG_LDO5CTRL = 63,
	MAX8997_REG_LDO6CTRL = 64,
	MAX8997_REG_LDO7CTRL = 65,
	MAX8997_REG_LDO8CTRL = 66,
	MAX8997_REG_LDO9CTRL = 67,
	MAX8997_REG_LDO10CTRL = 68,
	MAX8997_REG_LDO11CTRL = 69,
	MAX8997_REG_LDO12CTRL = 70,
	MAX8997_REG_LDO13CTRL = 71,
	MAX8997_REG_LDO14CTRL = 72,
	MAX8997_REG_LDO15CTRL = 73,
	MAX8997_REG_LDO16CTRL = 74,
	MAX8997_REG_LDO17CTRL = 75,
	MAX8997_REG_LDO18CTRL = 76,
	MAX8997_REG_LDO21CTRL = 77,
	MAX8997_REG_MBCCTRL1 = 80,
	MAX8997_REG_MBCCTRL2 = 81,
	MAX8997_REG_MBCCTRL3 = 82,
	MAX8997_REG_MBCCTRL4 = 83,
	MAX8997_REG_MBCCTRL5 = 84,
	MAX8997_REG_MBCCTRL6 = 85,
	MAX8997_REG_OTPCGHCVS = 86,
	MAX8997_REG_SAFEOUTCTRL = 90,
	MAX8997_REG_LBCNFG1 = 94,
	MAX8997_REG_LBCNFG2 = 95,
	MAX8997_REG_BBCCTRL = 96,
	MAX8997_REG_FLASH1_CUR = 99,
	MAX8997_REG_FLASH2_CUR = 100,
	MAX8997_REG_MOVIE_CUR = 101,
	MAX8997_REG_GSMB_CUR = 102,
	MAX8997_REG_BOOST_CNTL = 103,
	MAX8997_REG_LEN_CNTL = 104,
	MAX8997_REG_FLASH_CNTL = 105,
	MAX8997_REG_WDT_CNTL = 106,
	MAX8997_REG_MAXFLASH1 = 107,
	MAX8997_REG_MAXFLASH2 = 108,
	MAX8997_REG_FLASHSTATUS = 109,
	MAX8997_REG_FLASHSTATUSMASK = 110,
	MAX8997_REG_GPIOCNTL1 = 112,
	MAX8997_REG_GPIOCNTL2 = 113,
	MAX8997_REG_GPIOCNTL3 = 114,
	MAX8997_REG_GPIOCNTL4 = 115,
	MAX8997_REG_GPIOCNTL5 = 116,
	MAX8997_REG_GPIOCNTL6 = 117,
	MAX8997_REG_GPIOCNTL7 = 118,
	MAX8997_REG_GPIOCNTL8 = 119,
	MAX8997_REG_GPIOCNTL9 = 120,
	MAX8997_REG_GPIOCNTL10 = 121,
	MAX8997_REG_GPIOCNTL11 = 122,
	MAX8997_REG_GPIOCNTL12 = 123,
	MAX8997_REG_LDO1CONFIG = 128,
	MAX8997_REG_LDO2CONFIG = 129,
	MAX8997_REG_LDO3CONFIG = 130,
	MAX8997_REG_LDO4CONFIG = 131,
	MAX8997_REG_LDO5CONFIG = 132,
	MAX8997_REG_LDO6CONFIG = 133,
	MAX8997_REG_LDO7CONFIG = 134,
	MAX8997_REG_LDO8CONFIG = 135,
	MAX8997_REG_LDO9CONFIG = 136,
	MAX8997_REG_LDO10CONFIG = 137,
	MAX8997_REG_LDO11CONFIG = 138,
	MAX8997_REG_LDO12CONFIG = 139,
	MAX8997_REG_LDO13CONFIG = 140,
	MAX8997_REG_LDO14CONFIG = 141,
	MAX8997_REG_LDO15CONFIG = 142,
	MAX8997_REG_LDO16CONFIG = 143,
	MAX8997_REG_LDO17CONFIG = 144,
	MAX8997_REG_LDO18CONFIG = 145,
	MAX8997_REG_LDO21CONFIG = 146,
	MAX8997_REG_DVSOKTIMER1 = 151,
	MAX8997_REG_DVSOKTIMER2 = 152,
	MAX8997_REG_DVSOKTIMER4 = 153,
	MAX8997_REG_DVSOKTIMER5 = 154,
	MAX8997_REG_PMIC_END = 155,
};

enum max8997_muic_reg {
	MAX8997_MUIC_REG_ID = 0,
	MAX8997_MUIC_REG_INT1 = 1,
	MAX8997_MUIC_REG_INT2 = 2,
	MAX8997_MUIC_REG_INT3 = 3,
	MAX8997_MUIC_REG_STATUS1 = 4,
	MAX8997_MUIC_REG_STATUS2 = 5,
	MAX8997_MUIC_REG_STATUS3 = 6,
	MAX8997_MUIC_REG_INTMASK1 = 7,
	MAX8997_MUIC_REG_INTMASK2 = 8,
	MAX8997_MUIC_REG_INTMASK3 = 9,
	MAX8997_MUIC_REG_CDETCTRL = 10,
	MAX8997_MUIC_REG_CONTROL1 = 12,
	MAX8997_MUIC_REG_CONTROL2 = 13,
	MAX8997_MUIC_REG_CONTROL3 = 14,
	MAX8997_MUIC_REG_END = 15,
};

enum max8997_haptic_reg {
	MAX8997_HAPTIC_REG_GENERAL = 0,
	MAX8997_HAPTIC_REG_CONF1 = 1,
	MAX8997_HAPTIC_REG_CONF2 = 2,
	MAX8997_HAPTIC_REG_DRVCONF = 3,
	MAX8997_HAPTIC_REG_CYCLECONF1 = 4,
	MAX8997_HAPTIC_REG_CYCLECONF2 = 5,
	MAX8997_HAPTIC_REG_SIGCONF1 = 6,
	MAX8997_HAPTIC_REG_SIGCONF2 = 7,
	MAX8997_HAPTIC_REG_SIGCONF3 = 8,
	MAX8997_HAPTIC_REG_SIGCONF4 = 9,
	MAX8997_HAPTIC_REG_SIGDC1 = 10,
	MAX8997_HAPTIC_REG_SIGDC2 = 11,
	MAX8997_HAPTIC_REG_SIGPWMDC1 = 12,
	MAX8997_HAPTIC_REG_SIGPWMDC2 = 13,
	MAX8997_HAPTIC_REG_SIGPWMDC3 = 14,
	MAX8997_HAPTIC_REG_SIGPWMDC4 = 15,
	MAX8997_HAPTIC_REG_MTR_REV = 16,
	MAX8997_HAPTIC_REG_END = 17,
};

enum max8997_irq_source {
	PMIC_INT1___2 = 0,
	PMIC_INT2___2 = 1,
	PMIC_INT3 = 2,
	PMIC_INT4 = 3,
	FUEL_GAUGE = 4,
	MUIC_INT1 = 5,
	MUIC_INT2 = 6,
	MUIC_INT3 = 7,
	GPIO_LOW = 8,
	GPIO_HI = 9,
	FLASH_STATUS = 10,
	MAX8997_IRQ_GROUP_NR = 11,
};

struct max8997_dev {
	struct device *dev;
	struct max8997_platform_data *pdata;
	struct i2c_client *i2c;
	struct i2c_client *rtc;
	struct i2c_client *haptic;
	struct i2c_client *muic;
	struct mutex iolock;
	long unsigned int type;
	struct platform_device *battery;
	int irq;
	int ono;
	struct irq_domain *irq_domain;
	struct mutex irqlock;
	int irq_masks_cur[11];
	int irq_masks_cache[11];
	u8 reg_dump[187];
	bool gpio_status[12];
};

enum max8997_types {
	TYPE_MAX8997 = 0,
	TYPE_MAX8966 = 1,
};

enum max8997_irq {
	MAX8997_PMICIRQ_PWRONR = 0,
	MAX8997_PMICIRQ_PWRONF = 1,
	MAX8997_PMICIRQ_PWRON1SEC = 2,
	MAX8997_PMICIRQ_JIGONR = 3,
	MAX8997_PMICIRQ_JIGONF = 4,
	MAX8997_PMICIRQ_LOWBAT2 = 5,
	MAX8997_PMICIRQ_LOWBAT1 = 6,
	MAX8997_PMICIRQ_JIGR = 7,
	MAX8997_PMICIRQ_JIGF = 8,
	MAX8997_PMICIRQ_MR = 9,
	MAX8997_PMICIRQ_DVS1OK = 10,
	MAX8997_PMICIRQ_DVS2OK = 11,
	MAX8997_PMICIRQ_DVS3OK = 12,
	MAX8997_PMICIRQ_DVS4OK = 13,
	MAX8997_PMICIRQ_CHGINS = 14,
	MAX8997_PMICIRQ_CHGRM = 15,
	MAX8997_PMICIRQ_DCINOVP = 16,
	MAX8997_PMICIRQ_TOPOFFR = 17,
	MAX8997_PMICIRQ_CHGRSTF = 18,
	MAX8997_PMICIRQ_MBCHGTMEXPD = 19,
	MAX8997_PMICIRQ_RTC60S = 20,
	MAX8997_PMICIRQ_RTCA1 = 21,
	MAX8997_PMICIRQ_RTCA2 = 22,
	MAX8997_PMICIRQ_SMPL_INT = 23,
	MAX8997_PMICIRQ_RTC1S = 24,
	MAX8997_PMICIRQ_WTSR = 25,
	MAX8997_MUICIRQ_ADCError = 26,
	MAX8997_MUICIRQ_ADCLow = 27,
	MAX8997_MUICIRQ_ADC = 28,
	MAX8997_MUICIRQ_VBVolt = 29,
	MAX8997_MUICIRQ_DBChg = 30,
	MAX8997_MUICIRQ_DCDTmr = 31,
	MAX8997_MUICIRQ_ChgDetRun = 32,
	MAX8997_MUICIRQ_ChgTyp = 33,
	MAX8997_MUICIRQ_OVP = 34,
	MAX8997_IRQ_NR = 35,
};

struct max8997_irq_data {
	int mask;
	enum max8997_irq_source group;
};

struct max8998_regulator_data {
	int id;
	struct regulator_init_data *initdata;
	struct device_node *reg_node;
};

struct max8998_platform_data {
	struct max8998_regulator_data *regulators;
	int num_regulators;
	unsigned int irq_base;
	int ono;
	bool buck_voltage_lock;
	int buck1_voltage[4];
	int buck2_voltage[2];
	int buck1_set1;
	int buck1_set2;
	int buck1_default_idx;
	int buck2_set3;
	int buck2_default_idx;
	bool wakeup;
	bool rtc_delay;
	int eoc;
	int restart;
	int timeout;
};

enum {
	MAX8998_REG_IRQ1 = 0,
	MAX8998_REG_IRQ2 = 1,
	MAX8998_REG_IRQ3 = 2,
	MAX8998_REG_IRQ4 = 3,
	MAX8998_REG_IRQM1 = 4,
	MAX8998_REG_IRQM2 = 5,
	MAX8998_REG_IRQM3 = 6,
	MAX8998_REG_IRQM4 = 7,
	MAX8998_REG_STATUS1 = 8,
	MAX8998_REG_STATUS2 = 9,
	MAX8998_REG_STATUSM1 = 10,
	MAX8998_REG_STATUSM2 = 11,
	MAX8998_REG_CHGR1 = 12,
	MAX8998_REG_CHGR2 = 13,
	MAX8998_REG_LDO_ACTIVE_DISCHARGE1 = 14,
	MAX8998_REG_LDO_ACTIVE_DISCHARGE2 = 15,
	MAX8998_REG_BUCK_ACTIVE_DISCHARGE3 = 16,
	MAX8998_REG_ONOFF1 = 17,
	MAX8998_REG_ONOFF2 = 18,
	MAX8998_REG_ONOFF3 = 19,
	MAX8998_REG_ONOFF4 = 20,
	MAX8998_REG_BUCK1_VOLTAGE1 = 21,
	MAX8998_REG_BUCK1_VOLTAGE2 = 22,
	MAX8998_REG_BUCK1_VOLTAGE3 = 23,
	MAX8998_REG_BUCK1_VOLTAGE4 = 24,
	MAX8998_REG_BUCK2_VOLTAGE1 = 25,
	MAX8998_REG_BUCK2_VOLTAGE2 = 26,
	MAX8998_REG_BUCK3 = 27,
	MAX8998_REG_BUCK4 = 28,
	MAX8998_REG_LDO2_LDO3 = 29,
	MAX8998_REG_LDO4 = 30,
	MAX8998_REG_LDO5 = 31,
	MAX8998_REG_LDO6 = 32,
	MAX8998_REG_LDO7 = 33,
	MAX8998_REG_LDO8_LDO9 = 34,
	MAX8998_REG_LDO10_LDO11 = 35,
	MAX8998_REG_LDO12 = 36,
	MAX8998_REG_LDO13 = 37,
	MAX8998_REG_LDO14 = 38,
	MAX8998_REG_LDO15 = 39,
	MAX8998_REG_LDO16 = 40,
	MAX8998_REG_LDO17 = 41,
	MAX8998_REG_BKCHR = 42,
	MAX8998_REG_LBCNFG1 = 43,
	MAX8998_REG_LBCNFG2 = 44,
};

enum {
	TYPE_MAX8998 = 0,
	TYPE_LP3974 = 1,
	TYPE_LP3979 = 2,
};

struct max8998_dev {
	struct device *dev;
	struct max8998_platform_data *pdata;
	struct i2c_client *i2c;
	struct i2c_client *rtc;
	struct mutex iolock;
	struct mutex irqlock;
	unsigned int irq_base;
	struct irq_domain *irq_domain;
	int irq;
	int ono;
	u8 irq_masks_cur[4];
	u8 irq_masks_cache[4];
	long unsigned int type;
	bool wakeup;
};

struct max8998_reg_dump {
	u8 addr;
	u8 val;
};

enum {
	MAX8998_IRQ_DCINF = 0,
	MAX8998_IRQ_DCINR = 1,
	MAX8998_IRQ_JIGF = 2,
	MAX8998_IRQ_JIGR = 3,
	MAX8998_IRQ_PWRONF = 4,
	MAX8998_IRQ_PWRONR = 5,
	MAX8998_IRQ_WTSREVNT = 6,
	MAX8998_IRQ_SMPLEVNT = 7,
	MAX8998_IRQ_ALARM1 = 8,
	MAX8998_IRQ_ALARM0 = 9,
	MAX8998_IRQ_ONKEY1S = 10,
	MAX8998_IRQ_TOPOFFR = 11,
	MAX8998_IRQ_DCINOVPR = 12,
	MAX8998_IRQ_CHGRSTF = 13,
	MAX8998_IRQ_DONER = 14,
	MAX8998_IRQ_CHGFAULT = 15,
	MAX8998_IRQ_LOBAT1 = 16,
	MAX8998_IRQ_LOBAT2 = 17,
	MAX8998_IRQ_NR = 18,
};

struct max8998_irq_data {
	int reg;
	int mask;
};

struct max8997_dev___2;

struct adp5520_gpio_platform_data {
	unsigned int gpio_start;
	u8 gpio_en_mask;
	u8 gpio_pullup_mask;
};

struct adp5520_keys_platform_data {
	int rows_en_mask;
	int cols_en_mask;
	const short unsigned int *keymap;
	short unsigned int keymapsize;
	unsigned int repeat: 1;
};

struct led_info;

struct adp5520_leds_platform_data {
	int num_leds;
	struct led_info *leds;
	u8 fade_in;
	u8 fade_out;
	u8 led_on_time;
};

struct adp5520_backlight_platform_data {
	u8 fade_in;
	u8 fade_out;
	u8 fade_led_law;
	u8 en_ambl_sens;
	u8 abml_filt;
	u8 l1_daylight_max;
	u8 l1_daylight_dim;
	u8 l2_office_max;
	u8 l2_office_dim;
	u8 l3_dark_max;
	u8 l3_dark_dim;
	u8 l2_trip;
	u8 l2_hyst;
	u8 l3_trip;
	u8 l3_hyst;
};

struct adp5520_platform_data {
	struct adp5520_keys_platform_data *keys;
	struct adp5520_gpio_platform_data *gpio;
	struct adp5520_leds_platform_data *leds;
	struct adp5520_backlight_platform_data *backlight;
};

struct adp5520_chip {
	struct i2c_client *client;
	struct device *dev;
	struct mutex lock;
	struct blocking_notifier_head notifier_list;
	int irq;
	long unsigned int id;
	uint8_t mode;
};

struct tps6586x_irq_data {
	u8 mask_reg;
	u8 mask_mask;
};

struct tps6586x {
	struct device *dev;
	struct i2c_client *client;
	struct regmap *regmap;
	int version;
	int irq;
	struct irq_chip irq_chip;
	struct mutex irq_lock;
	int irq_base;
	u32 irq_en;
	u8 mask_reg[5];
	struct irq_domain *irq_domain;
};

enum {
	TPS65090_IRQ_INTERRUPT = 0,
	TPS65090_IRQ_VAC_STATUS_CHANGE = 1,
	TPS65090_IRQ_VSYS_STATUS_CHANGE = 2,
	TPS65090_IRQ_BAT_STATUS_CHANGE = 3,
	TPS65090_IRQ_CHARGING_STATUS_CHANGE = 4,
	TPS65090_IRQ_CHARGING_COMPLETE = 5,
	TPS65090_IRQ_OVERLOAD_DCDC1 = 6,
	TPS65090_IRQ_OVERLOAD_DCDC2 = 7,
	TPS65090_IRQ_OVERLOAD_DCDC3 = 8,
	TPS65090_IRQ_OVERLOAD_FET1 = 9,
	TPS65090_IRQ_OVERLOAD_FET2 = 10,
	TPS65090_IRQ_OVERLOAD_FET3 = 11,
	TPS65090_IRQ_OVERLOAD_FET4 = 12,
	TPS65090_IRQ_OVERLOAD_FET5 = 13,
	TPS65090_IRQ_OVERLOAD_FET6 = 14,
	TPS65090_IRQ_OVERLOAD_FET7 = 15,
};

enum {
	TPS65090_REGULATOR_DCDC1 = 0,
	TPS65090_REGULATOR_DCDC2 = 1,
	TPS65090_REGULATOR_DCDC3 = 2,
	TPS65090_REGULATOR_FET1 = 3,
	TPS65090_REGULATOR_FET2 = 4,
	TPS65090_REGULATOR_FET3 = 5,
	TPS65090_REGULATOR_FET4 = 6,
	TPS65090_REGULATOR_FET5 = 7,
	TPS65090_REGULATOR_FET6 = 8,
	TPS65090_REGULATOR_FET7 = 9,
	TPS65090_REGULATOR_LDO1 = 10,
	TPS65090_REGULATOR_LDO2 = 11,
	TPS65090_REGULATOR_MAX = 12,
};

struct tps65090 {
	struct device *dev;
	struct regmap *rmap;
	struct regmap_irq_chip_data *irq_data;
};

struct tps65090_regulator_plat_data {
	struct regulator_init_data *reg_init_data;
	bool enable_ext_control;
	struct gpio_desc *gpiod;
	bool overcurrent_wait_valid;
	int overcurrent_wait;
};

struct tps65090_platform_data {
	int irq_base;
	char **supplied_to;
	size_t num_supplicants;
	int enable_low_current_chrg;
	struct tps65090_regulator_plat_data *reg_pdata[12];
};

enum tps65090_cells {
	PMIC = 0,
	CHARGER = 1,
};

enum aat2870_id {
	AAT2870_ID_BL = 0,
	AAT2870_ID_LDOA = 1,
	AAT2870_ID_LDOB = 2,
	AAT2870_ID_LDOC = 3,
	AAT2870_ID_LDOD = 4,
};

struct aat2870_register {
	bool readable;
	bool writeable;
	u8 value;
};

struct aat2870_data {
	struct device *dev;
	struct i2c_client *client;
	struct mutex io_lock;
	struct aat2870_register *reg_cache;
	int en_pin;
	bool is_enable;
	int (*init)(struct aat2870_data *);
	void (*uninit)(struct aat2870_data *);
	int (*read)(struct aat2870_data *, u8, u8 *);
	int (*write)(struct aat2870_data *, u8, u8);
	int (*update)(struct aat2870_data *, u8, u8, u8);
	struct dentry *dentry_root;
};

struct aat2870_subdev_info {
	int id;
	const char *name;
	void *platform_data;
};

struct aat2870_platform_data {
	int en_pin;
	struct aat2870_subdev_info *subdevs;
	int num_subdevs;
	int (*init)(struct aat2870_data *);
	void (*uninit)(struct aat2870_data *);
};

enum {
	PALMAS_EXT_CONTROL_ENABLE1 = 1,
	PALMAS_EXT_CONTROL_ENABLE2 = 2,
	PALMAS_EXT_CONTROL_NSLEEP = 4,
};

enum palmas_external_requestor_id {
	PALMAS_EXTERNAL_REQSTR_ID_REGEN1 = 0,
	PALMAS_EXTERNAL_REQSTR_ID_REGEN2 = 1,
	PALMAS_EXTERNAL_REQSTR_ID_SYSEN1 = 2,
	PALMAS_EXTERNAL_REQSTR_ID_SYSEN2 = 3,
	PALMAS_EXTERNAL_REQSTR_ID_CLK32KG = 4,
	PALMAS_EXTERNAL_REQSTR_ID_CLK32KGAUDIO = 5,
	PALMAS_EXTERNAL_REQSTR_ID_REGEN3 = 6,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS12 = 7,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS3 = 8,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS45 = 9,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS6 = 10,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS7 = 11,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS8 = 12,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS9 = 13,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS10 = 14,
	PALMAS_EXTERNAL_REQSTR_ID_LDO1 = 15,
	PALMAS_EXTERNAL_REQSTR_ID_LDO2 = 16,
	PALMAS_EXTERNAL_REQSTR_ID_LDO3 = 17,
	PALMAS_EXTERNAL_REQSTR_ID_LDO4 = 18,
	PALMAS_EXTERNAL_REQSTR_ID_LDO5 = 19,
	PALMAS_EXTERNAL_REQSTR_ID_LDO6 = 20,
	PALMAS_EXTERNAL_REQSTR_ID_LDO7 = 21,
	PALMAS_EXTERNAL_REQSTR_ID_LDO8 = 22,
	PALMAS_EXTERNAL_REQSTR_ID_LDO9 = 23,
	PALMAS_EXTERNAL_REQSTR_ID_LDOLN = 24,
	PALMAS_EXTERNAL_REQSTR_ID_LDOUSB = 25,
	PALMAS_EXTERNAL_REQSTR_ID_MAX = 26,
};

enum tps65917_irqs {
	TPS65917_RESERVED1 = 0,
	TPS65917_PWRON_IRQ = 1,
	TPS65917_LONG_PRESS_KEY_IRQ = 2,
	TPS65917_RESERVED2 = 3,
	TPS65917_PWRDOWN_IRQ = 4,
	TPS65917_HOTDIE_IRQ = 5,
	TPS65917_VSYS_MON_IRQ = 6,
	TPS65917_RESERVED3 = 7,
	TPS65917_RESERVED4 = 8,
	TPS65917_OTP_ERROR_IRQ = 9,
	TPS65917_WDT_IRQ = 10,
	TPS65917_RESERVED5 = 11,
	TPS65917_RESET_IN_IRQ = 12,
	TPS65917_FSD_IRQ = 13,
	TPS65917_SHORT_IRQ = 14,
	TPS65917_RESERVED6 = 15,
	TPS65917_GPADC_AUTO_0_IRQ = 16,
	TPS65917_GPADC_AUTO_1_IRQ = 17,
	TPS65917_GPADC_EOC_SW_IRQ = 18,
	TPS65917_RESREVED6 = 19,
	TPS65917_RESERVED7 = 20,
	TPS65917_RESERVED8 = 21,
	TPS65917_RESERVED9 = 22,
	TPS65917_VBUS_IRQ = 23,
	TPS65917_GPIO_0_IRQ = 24,
	TPS65917_GPIO_1_IRQ = 25,
	TPS65917_GPIO_2_IRQ = 26,
	TPS65917_GPIO_3_IRQ = 27,
	TPS65917_GPIO_4_IRQ = 28,
	TPS65917_GPIO_5_IRQ = 29,
	TPS65917_GPIO_6_IRQ = 30,
	TPS65917_RESERVED10 = 31,
	TPS65917_NUM_IRQ = 32,
};

struct palmas_driver_data {
	unsigned int *features;
	struct regmap_irq_chip *irq_chip;
};

enum {
	RC5T583_DS_NONE = 0,
	RC5T583_DS_DC0 = 1,
	RC5T583_DS_DC1 = 2,
	RC5T583_DS_DC2 = 3,
	RC5T583_DS_DC3 = 4,
	RC5T583_DS_LDO0 = 5,
	RC5T583_DS_LDO1 = 6,
	RC5T583_DS_LDO2 = 7,
	RC5T583_DS_LDO3 = 8,
	RC5T583_DS_LDO4 = 9,
	RC5T583_DS_LDO5 = 10,
	RC5T583_DS_LDO6 = 11,
	RC5T583_DS_LDO7 = 12,
	RC5T583_DS_LDO8 = 13,
	RC5T583_DS_LDO9 = 14,
	RC5T583_DS_PSO0 = 15,
	RC5T583_DS_PSO1 = 16,
	RC5T583_DS_PSO2 = 17,
	RC5T583_DS_PSO3 = 18,
	RC5T583_DS_PSO4 = 19,
	RC5T583_DS_PSO5 = 20,
	RC5T583_DS_PSO6 = 21,
	RC5T583_DS_PSO7 = 22,
	RC5T583_DS_MAX = 23,
};

enum {
	RC5T583_EXT_PWRREQ1_CONTROL = 1,
	RC5T583_EXT_PWRREQ2_CONTROL = 2,
};

struct deepsleep_control_data {
	u8 reg_add;
	u8 ds_pos_bit;
};

enum int_type {
	SYS_INT = 1,
	DCDC_INT = 2,
	RTC_INT___2 = 4,
	ADC_INT = 8,
	GPIO_INT = 16,
};

struct rc5t583_irq_data {
	u8 int_type;
	u8 master_bit;
	u8 int_en_bit;
	u8 mask_reg_index;
	int grp_index;
};

enum sec_device_type {
	S5M8751X = 0,
	S5M8763X = 1,
	S5M8767X = 2,
	S2MPA01 = 3,
	S2MPS11X = 4,
	S2MPS13X = 5,
	S2MPS14X = 6,
	S2MPS15X = 7,
	S2MPU02 = 8,
};

struct sec_platform_data;

struct sec_pmic_dev {
	struct device *dev;
	struct sec_platform_data *pdata;
	struct regmap *regmap_pmic;
	struct i2c_client *i2c;
	long unsigned int device_type;
	int irq_base;
	int irq;
	struct regmap_irq_chip_data *irq_data;
	bool wakeup;
};

struct sec_regulator_data;

struct sec_opmode_data;

struct sec_platform_data {
	struct sec_regulator_data *regulators;
	struct sec_opmode_data *opmode;
	int device_type;
	int num_regulators;
	int irq_base;
	int (*cfg_pmic_irq)();
	bool wakeup;
	bool buck_voltage_lock;
	int buck_gpios[3];
	int buck_ds[3];
	unsigned int buck2_voltage[8];
	bool buck2_gpiodvs;
	unsigned int buck3_voltage[8];
	bool buck3_gpiodvs;
	unsigned int buck4_voltage[8];
	bool buck4_gpiodvs;
	int buck_set1;
	int buck_set2;
	int buck_set3;
	int buck2_enable;
	int buck3_enable;
	int buck4_enable;
	int buck_default_idx;
	int buck2_default_idx;
	int buck3_default_idx;
	int buck4_default_idx;
	int buck_ramp_delay;
	int buck2_ramp_delay;
	int buck34_ramp_delay;
	int buck5_ramp_delay;
	int buck16_ramp_delay;
	int buck7810_ramp_delay;
	int buck9_ramp_delay;
	int buck24_ramp_delay;
	int buck3_ramp_delay;
	int buck7_ramp_delay;
	int buck8910_ramp_delay;
	bool buck1_ramp_enable;
	bool buck2_ramp_enable;
	bool buck3_ramp_enable;
	bool buck4_ramp_enable;
	bool buck6_ramp_enable;
	int buck2_init;
	int buck3_init;
	int buck4_init;
	bool manual_poweroff;
	bool disable_wrstbi;
};

struct sec_regulator_data {
	int id;
	struct regulator_init_data *initdata;
	struct device_node *reg_node;
	struct gpio_desc *ext_control_gpiod;
};

struct sec_opmode_data {
	int id;
	unsigned int mode;
};

enum s2mpa01_reg {
	S2MPA01_REG_ID = 0,
	S2MPA01_REG_INT1 = 1,
	S2MPA01_REG_INT2 = 2,
	S2MPA01_REG_INT3 = 3,
	S2MPA01_REG_INT1M = 4,
	S2MPA01_REG_INT2M = 5,
	S2MPA01_REG_INT3M = 6,
	S2MPA01_REG_ST1 = 7,
	S2MPA01_REG_ST2 = 8,
	S2MPA01_REG_PWRONSRC = 9,
	S2MPA01_REG_OFFSRC = 10,
	S2MPA01_REG_RTC_BUF = 11,
	S2MPA01_REG_CTRL1 = 12,
	S2MPA01_REG_ETC_TEST = 13,
	S2MPA01_REG_RSVD1 = 14,
	S2MPA01_REG_BU_CHG = 15,
	S2MPA01_REG_RAMP1 = 16,
	S2MPA01_REG_RAMP2 = 17,
	S2MPA01_REG_LDO_DSCH1 = 18,
	S2MPA01_REG_LDO_DSCH2 = 19,
	S2MPA01_REG_LDO_DSCH3 = 20,
	S2MPA01_REG_LDO_DSCH4 = 21,
	S2MPA01_REG_OTP_ADRL = 22,
	S2MPA01_REG_OTP_ADRH = 23,
	S2MPA01_REG_OTP_DATA = 24,
	S2MPA01_REG_MON1SEL = 25,
	S2MPA01_REG_MON2SEL = 26,
	S2MPA01_REG_LEE = 27,
	S2MPA01_REG_RSVD2 = 28,
	S2MPA01_REG_RSVD3 = 29,
	S2MPA01_REG_RSVD4 = 30,
	S2MPA01_REG_RSVD5 = 31,
	S2MPA01_REG_RSVD6 = 32,
	S2MPA01_REG_TOP_RSVD = 33,
	S2MPA01_REG_DVS_SEL = 34,
	S2MPA01_REG_DVS_PTR = 35,
	S2MPA01_REG_DVS_DATA = 36,
	S2MPA01_REG_RSVD_NO = 37,
	S2MPA01_REG_UVLO = 38,
	S2MPA01_REG_LEE_NO = 39,
	S2MPA01_REG_B1CTRL1 = 40,
	S2MPA01_REG_B1CTRL2 = 41,
	S2MPA01_REG_B2CTRL1 = 42,
	S2MPA01_REG_B2CTRL2 = 43,
	S2MPA01_REG_B3CTRL1 = 44,
	S2MPA01_REG_B3CTRL2 = 45,
	S2MPA01_REG_B4CTRL1 = 46,
	S2MPA01_REG_B4CTRL2 = 47,
	S2MPA01_REG_B5CTRL1 = 48,
	S2MPA01_REG_B5CTRL2 = 49,
	S2MPA01_REG_B5CTRL3 = 50,
	S2MPA01_REG_B5CTRL4 = 51,
	S2MPA01_REG_B5CTRL5 = 52,
	S2MPA01_REG_B5CTRL6 = 53,
	S2MPA01_REG_B6CTRL1 = 54,
	S2MPA01_REG_B6CTRL2 = 55,
	S2MPA01_REG_B7CTRL1 = 56,
	S2MPA01_REG_B7CTRL2 = 57,
	S2MPA01_REG_B8CTRL1 = 58,
	S2MPA01_REG_B8CTRL2 = 59,
	S2MPA01_REG_B9CTRL1 = 60,
	S2MPA01_REG_B9CTRL2 = 61,
	S2MPA01_REG_B10CTRL1 = 62,
	S2MPA01_REG_B10CTRL2 = 63,
	S2MPA01_REG_L1CTRL = 64,
	S2MPA01_REG_L2CTRL = 65,
	S2MPA01_REG_L3CTRL = 66,
	S2MPA01_REG_L4CTRL = 67,
	S2MPA01_REG_L5CTRL = 68,
	S2MPA01_REG_L6CTRL = 69,
	S2MPA01_REG_L7CTRL = 70,
	S2MPA01_REG_L8CTRL = 71,
	S2MPA01_REG_L9CTRL = 72,
	S2MPA01_REG_L10CTRL = 73,
	S2MPA01_REG_L11CTRL = 74,
	S2MPA01_REG_L12CTRL = 75,
	S2MPA01_REG_L13CTRL = 76,
	S2MPA01_REG_L14CTRL = 77,
	S2MPA01_REG_L15CTRL = 78,
	S2MPA01_REG_L16CTRL = 79,
	S2MPA01_REG_L17CTRL = 80,
	S2MPA01_REG_L18CTRL = 81,
	S2MPA01_REG_L19CTRL = 82,
	S2MPA01_REG_L20CTRL = 83,
	S2MPA01_REG_L21CTRL = 84,
	S2MPA01_REG_L22CTRL = 85,
	S2MPA01_REG_L23CTRL = 86,
	S2MPA01_REG_L24CTRL = 87,
	S2MPA01_REG_L25CTRL = 88,
	S2MPA01_REG_L26CTRL = 89,
	S2MPA01_REG_LDO_OVCB1 = 90,
	S2MPA01_REG_LDO_OVCB2 = 91,
	S2MPA01_REG_LDO_OVCB3 = 92,
	S2MPA01_REG_LDO_OVCB4 = 93,
};

enum s2mps11_reg {
	S2MPS11_REG_ID = 0,
	S2MPS11_REG_INT1 = 1,
	S2MPS11_REG_INT2 = 2,
	S2MPS11_REG_INT3 = 3,
	S2MPS11_REG_INT1M = 4,
	S2MPS11_REG_INT2M = 5,
	S2MPS11_REG_INT3M = 6,
	S2MPS11_REG_ST1 = 7,
	S2MPS11_REG_ST2 = 8,
	S2MPS11_REG_OFFSRC = 9,
	S2MPS11_REG_PWRONSRC = 10,
	S2MPS11_REG_RTC_CTRL = 11,
	S2MPS11_REG_CTRL1 = 12,
	S2MPS11_REG_ETC_TEST = 13,
	S2MPS11_REG_RSVD3 = 14,
	S2MPS11_REG_BU_CHG = 15,
	S2MPS11_REG_RAMP = 16,
	S2MPS11_REG_RAMP_BUCK = 17,
	S2MPS11_REG_LDO1_8 = 18,
	S2MPS11_REG_LDO9_16 = 19,
	S2MPS11_REG_LDO17_24 = 20,
	S2MPS11_REG_LDO25_32 = 21,
	S2MPS11_REG_LDO33_38 = 22,
	S2MPS11_REG_LDO1_8_1 = 23,
	S2MPS11_REG_LDO9_16_1 = 24,
	S2MPS11_REG_LDO17_24_1 = 25,
	S2MPS11_REG_LDO25_32_1 = 26,
	S2MPS11_REG_LDO33_38_1 = 27,
	S2MPS11_REG_OTP_ADRL = 28,
	S2MPS11_REG_OTP_ADRH = 29,
	S2MPS11_REG_OTP_DATA = 30,
	S2MPS11_REG_MON1SEL = 31,
	S2MPS11_REG_MON2SEL = 32,
	S2MPS11_REG_LEE = 33,
	S2MPS11_REG_RSVD_NO = 34,
	S2MPS11_REG_UVLO = 35,
	S2MPS11_REG_LEE_NO = 36,
	S2MPS11_REG_B1CTRL1 = 37,
	S2MPS11_REG_B1CTRL2 = 38,
	S2MPS11_REG_B2CTRL1 = 39,
	S2MPS11_REG_B2CTRL2 = 40,
	S2MPS11_REG_B3CTRL1 = 41,
	S2MPS11_REG_B3CTRL2 = 42,
	S2MPS11_REG_B4CTRL1 = 43,
	S2MPS11_REG_B4CTRL2 = 44,
	S2MPS11_REG_B5CTRL1 = 45,
	S2MPS11_REG_BUCK5_SW = 46,
	S2MPS11_REG_B5CTRL2 = 47,
	S2MPS11_REG_B5CTRL3 = 48,
	S2MPS11_REG_B5CTRL4 = 49,
	S2MPS11_REG_B5CTRL5 = 50,
	S2MPS11_REG_B6CTRL1 = 51,
	S2MPS11_REG_B6CTRL2 = 52,
	S2MPS11_REG_B7CTRL1 = 53,
	S2MPS11_REG_B7CTRL2 = 54,
	S2MPS11_REG_B8CTRL1 = 55,
	S2MPS11_REG_B8CTRL2 = 56,
	S2MPS11_REG_B9CTRL1 = 57,
	S2MPS11_REG_B9CTRL2 = 58,
	S2MPS11_REG_B10CTRL1 = 59,
	S2MPS11_REG_B10CTRL2 = 60,
	S2MPS11_REG_L1CTRL = 61,
	S2MPS11_REG_L2CTRL = 62,
	S2MPS11_REG_L3CTRL = 63,
	S2MPS11_REG_L4CTRL = 64,
	S2MPS11_REG_L5CTRL = 65,
	S2MPS11_REG_L6CTRL = 66,
	S2MPS11_REG_L7CTRL = 67,
	S2MPS11_REG_L8CTRL = 68,
	S2MPS11_REG_L9CTRL = 69,
	S2MPS11_REG_L10CTRL = 70,
	S2MPS11_REG_L11CTRL = 71,
	S2MPS11_REG_L12CTRL = 72,
	S2MPS11_REG_L13CTRL = 73,
	S2MPS11_REG_L14CTRL = 74,
	S2MPS11_REG_L15CTRL = 75,
	S2MPS11_REG_L16CTRL = 76,
	S2MPS11_REG_L17CTRL = 77,
	S2MPS11_REG_L18CTRL = 78,
	S2MPS11_REG_L19CTRL = 79,
	S2MPS11_REG_L20CTRL = 80,
	S2MPS11_REG_L21CTRL = 81,
	S2MPS11_REG_L22CTRL = 82,
	S2MPS11_REG_L23CTRL = 83,
	S2MPS11_REG_L24CTRL = 84,
	S2MPS11_REG_L25CTRL = 85,
	S2MPS11_REG_L26CTRL = 86,
	S2MPS11_REG_L27CTRL = 87,
	S2MPS11_REG_L28CTRL = 88,
	S2MPS11_REG_L29CTRL = 89,
	S2MPS11_REG_L30CTRL = 90,
	S2MPS11_REG_L31CTRL = 91,
	S2MPS11_REG_L32CTRL = 92,
	S2MPS11_REG_L33CTRL = 93,
	S2MPS11_REG_L34CTRL = 94,
	S2MPS11_REG_L35CTRL = 95,
	S2MPS11_REG_L36CTRL = 96,
	S2MPS11_REG_L37CTRL = 97,
	S2MPS11_REG_L38CTRL = 98,
};

enum s2mps13_reg {
	S2MPS13_REG_ID = 0,
	S2MPS13_REG_INT1 = 1,
	S2MPS13_REG_INT2 = 2,
	S2MPS13_REG_INT3 = 3,
	S2MPS13_REG_INT1M = 4,
	S2MPS13_REG_INT2M = 5,
	S2MPS13_REG_INT3M = 6,
	S2MPS13_REG_ST1 = 7,
	S2MPS13_REG_ST2 = 8,
	S2MPS13_REG_PWRONSRC = 9,
	S2MPS13_REG_OFFSRC = 10,
	S2MPS13_REG_BU_CHG = 11,
	S2MPS13_REG_RTCCTRL = 12,
	S2MPS13_REG_CTRL1 = 13,
	S2MPS13_REG_CTRL2 = 14,
	S2MPS13_REG_RSVD1 = 15,
	S2MPS13_REG_RSVD2 = 16,
	S2MPS13_REG_RSVD3 = 17,
	S2MPS13_REG_RSVD4 = 18,
	S2MPS13_REG_RSVD5 = 19,
	S2MPS13_REG_RSVD6 = 20,
	S2MPS13_REG_CTRL3 = 21,
	S2MPS13_REG_RSVD7 = 22,
	S2MPS13_REG_RSVD8 = 23,
	S2MPS13_REG_WRSTBI = 24,
	S2MPS13_REG_B1CTRL = 25,
	S2MPS13_REG_B1OUT = 26,
	S2MPS13_REG_B2CTRL = 27,
	S2MPS13_REG_B2OUT = 28,
	S2MPS13_REG_B3CTRL = 29,
	S2MPS13_REG_B3OUT = 30,
	S2MPS13_REG_B4CTRL = 31,
	S2MPS13_REG_B4OUT = 32,
	S2MPS13_REG_B5CTRL = 33,
	S2MPS13_REG_B5OUT = 34,
	S2MPS13_REG_B6CTRL = 35,
	S2MPS13_REG_B6OUT = 36,
	S2MPS13_REG_B7CTRL = 37,
	S2MPS13_REG_B7SW = 38,
	S2MPS13_REG_B7OUT = 39,
	S2MPS13_REG_B8CTRL = 40,
	S2MPS13_REG_B8OUT = 41,
	S2MPS13_REG_B9CTRL = 42,
	S2MPS13_REG_B9OUT = 43,
	S2MPS13_REG_B10CTRL = 44,
	S2MPS13_REG_B10OUT = 45,
	S2MPS13_REG_BB1CTRL = 46,
	S2MPS13_REG_BB1OUT = 47,
	S2MPS13_REG_BUCK_RAMP1 = 48,
	S2MPS13_REG_BUCK_RAMP2 = 49,
	S2MPS13_REG_LDO_DVS1 = 50,
	S2MPS13_REG_LDO_DVS2 = 51,
	S2MPS13_REG_LDO_DVS3 = 52,
	S2MPS13_REG_B6OUT2 = 53,
	S2MPS13_REG_L1CTRL = 54,
	S2MPS13_REG_L2CTRL = 55,
	S2MPS13_REG_L3CTRL = 56,
	S2MPS13_REG_L4CTRL = 57,
	S2MPS13_REG_L5CTRL = 58,
	S2MPS13_REG_L6CTRL = 59,
	S2MPS13_REG_L7CTRL = 60,
	S2MPS13_REG_L8CTRL = 61,
	S2MPS13_REG_L9CTRL = 62,
	S2MPS13_REG_L10CTRL = 63,
	S2MPS13_REG_L11CTRL = 64,
	S2MPS13_REG_L12CTRL = 65,
	S2MPS13_REG_L13CTRL = 66,
	S2MPS13_REG_L14CTRL = 67,
	S2MPS13_REG_L15CTRL = 68,
	S2MPS13_REG_L16CTRL = 69,
	S2MPS13_REG_L17CTRL = 70,
	S2MPS13_REG_L18CTRL = 71,
	S2MPS13_REG_L19CTRL = 72,
	S2MPS13_REG_L20CTRL = 73,
	S2MPS13_REG_L21CTRL = 74,
	S2MPS13_REG_L22CTRL = 75,
	S2MPS13_REG_L23CTRL = 76,
	S2MPS13_REG_L24CTRL = 77,
	S2MPS13_REG_L25CTRL = 78,
	S2MPS13_REG_L26CTRL = 79,
	S2MPS13_REG_L27CTRL = 80,
	S2MPS13_REG_L28CTRL = 81,
	S2MPS13_REG_L29CTRL = 82,
	S2MPS13_REG_L30CTRL = 83,
	S2MPS13_REG_L31CTRL = 84,
	S2MPS13_REG_L32CTRL = 85,
	S2MPS13_REG_L33CTRL = 86,
	S2MPS13_REG_L34CTRL = 87,
	S2MPS13_REG_L35CTRL = 88,
	S2MPS13_REG_L36CTRL = 89,
	S2MPS13_REG_L37CTRL = 90,
	S2MPS13_REG_L38CTRL = 91,
	S2MPS13_REG_L39CTRL = 92,
	S2MPS13_REG_L40CTRL = 93,
	S2MPS13_REG_LDODSCH1 = 94,
	S2MPS13_REG_LDODSCH2 = 95,
	S2MPS13_REG_LDODSCH3 = 96,
	S2MPS13_REG_LDODSCH4 = 97,
	S2MPS13_REG_LDODSCH5 = 98,
};

enum s2mps14_reg {
	S2MPS14_REG_ID = 0,
	S2MPS14_REG_INT1 = 1,
	S2MPS14_REG_INT2 = 2,
	S2MPS14_REG_INT3 = 3,
	S2MPS14_REG_INT1M = 4,
	S2MPS14_REG_INT2M = 5,
	S2MPS14_REG_INT3M = 6,
	S2MPS14_REG_ST1 = 7,
	S2MPS14_REG_ST2 = 8,
	S2MPS14_REG_PWRONSRC = 9,
	S2MPS14_REG_OFFSRC = 10,
	S2MPS14_REG_BU_CHG = 11,
	S2MPS14_REG_RTCCTRL = 12,
	S2MPS14_REG_CTRL1 = 13,
	S2MPS14_REG_CTRL2 = 14,
	S2MPS14_REG_RSVD1 = 15,
	S2MPS14_REG_RSVD2 = 16,
	S2MPS14_REG_RSVD3 = 17,
	S2MPS14_REG_RSVD4 = 18,
	S2MPS14_REG_RSVD5 = 19,
	S2MPS14_REG_RSVD6 = 20,
	S2MPS14_REG_CTRL3 = 21,
	S2MPS14_REG_RSVD7 = 22,
	S2MPS14_REG_RSVD8 = 23,
	S2MPS14_REG_WRSTBI = 24,
	S2MPS14_REG_B1CTRL1 = 25,
	S2MPS14_REG_B1CTRL2 = 26,
	S2MPS14_REG_B2CTRL1 = 27,
	S2MPS14_REG_B2CTRL2 = 28,
	S2MPS14_REG_B3CTRL1 = 29,
	S2MPS14_REG_B3CTRL2 = 30,
	S2MPS14_REG_B4CTRL1 = 31,
	S2MPS14_REG_B4CTRL2 = 32,
	S2MPS14_REG_B5CTRL1 = 33,
	S2MPS14_REG_B5CTRL2 = 34,
	S2MPS14_REG_L1CTRL = 35,
	S2MPS14_REG_L2CTRL = 36,
	S2MPS14_REG_L3CTRL = 37,
	S2MPS14_REG_L4CTRL = 38,
	S2MPS14_REG_L5CTRL = 39,
	S2MPS14_REG_L6CTRL = 40,
	S2MPS14_REG_L7CTRL = 41,
	S2MPS14_REG_L8CTRL = 42,
	S2MPS14_REG_L9CTRL = 43,
	S2MPS14_REG_L10CTRL = 44,
	S2MPS14_REG_L11CTRL = 45,
	S2MPS14_REG_L12CTRL = 46,
	S2MPS14_REG_L13CTRL = 47,
	S2MPS14_REG_L14CTRL = 48,
	S2MPS14_REG_L15CTRL = 49,
	S2MPS14_REG_L16CTRL = 50,
	S2MPS14_REG_L17CTRL = 51,
	S2MPS14_REG_L18CTRL = 52,
	S2MPS14_REG_L19CTRL = 53,
	S2MPS14_REG_L20CTRL = 54,
	S2MPS14_REG_L21CTRL = 55,
	S2MPS14_REG_L22CTRL = 56,
	S2MPS14_REG_L23CTRL = 57,
	S2MPS14_REG_L24CTRL = 58,
	S2MPS14_REG_L25CTRL = 59,
	S2MPS14_REG_LDODSCH1 = 60,
	S2MPS14_REG_LDODSCH2 = 61,
	S2MPS14_REG_LDODSCH3 = 62,
};

enum s2mps15_reg {
	S2MPS15_REG_ID = 0,
	S2MPS15_REG_INT1 = 1,
	S2MPS15_REG_INT2 = 2,
	S2MPS15_REG_INT3 = 3,
	S2MPS15_REG_INT1M = 4,
	S2MPS15_REG_INT2M = 5,
	S2MPS15_REG_INT3M = 6,
	S2MPS15_REG_ST1 = 7,
	S2MPS15_REG_ST2 = 8,
	S2MPS15_REG_PWRONSRC = 9,
	S2MPS15_REG_OFFSRC = 10,
	S2MPS15_REG_BU_CHG = 11,
	S2MPS15_REG_RTC_BUF = 12,
	S2MPS15_REG_CTRL1 = 13,
	S2MPS15_REG_CTRL2 = 14,
	S2MPS15_REG_RSVD1 = 15,
	S2MPS15_REG_RSVD2 = 16,
	S2MPS15_REG_RSVD3 = 17,
	S2MPS15_REG_RSVD4 = 18,
	S2MPS15_REG_RSVD5 = 19,
	S2MPS15_REG_RSVD6 = 20,
	S2MPS15_REG_CTRL3 = 21,
	S2MPS15_REG_RSVD7 = 22,
	S2MPS15_REG_RSVD8 = 23,
	S2MPS15_REG_RSVD9 = 24,
	S2MPS15_REG_B1CTRL1 = 25,
	S2MPS15_REG_B1CTRL2 = 26,
	S2MPS15_REG_B2CTRL1 = 27,
	S2MPS15_REG_B2CTRL2 = 28,
	S2MPS15_REG_B3CTRL1 = 29,
	S2MPS15_REG_B3CTRL2 = 30,
	S2MPS15_REG_B4CTRL1 = 31,
	S2MPS15_REG_B4CTRL2 = 32,
	S2MPS15_REG_B5CTRL1 = 33,
	S2MPS15_REG_B5CTRL2 = 34,
	S2MPS15_REG_B6CTRL1 = 35,
	S2MPS15_REG_B6CTRL2 = 36,
	S2MPS15_REG_B7CTRL1 = 37,
	S2MPS15_REG_B7CTRL2 = 38,
	S2MPS15_REG_B8CTRL1 = 39,
	S2MPS15_REG_B8CTRL2 = 40,
	S2MPS15_REG_B9CTRL1 = 41,
	S2MPS15_REG_B9CTRL2 = 42,
	S2MPS15_REG_B10CTRL1 = 43,
	S2MPS15_REG_B10CTRL2 = 44,
	S2MPS15_REG_BBCTRL1 = 45,
	S2MPS15_REG_BBCTRL2 = 46,
	S2MPS15_REG_BRAMP = 47,
	S2MPS15_REG_LDODVS1 = 48,
	S2MPS15_REG_LDODVS2 = 49,
	S2MPS15_REG_LDODVS3 = 50,
	S2MPS15_REG_LDODVS4 = 51,
	S2MPS15_REG_L1CTRL = 52,
	S2MPS15_REG_L2CTRL = 53,
	S2MPS15_REG_L3CTRL = 54,
	S2MPS15_REG_L4CTRL = 55,
	S2MPS15_REG_L5CTRL = 56,
	S2MPS15_REG_L6CTRL = 57,
	S2MPS15_REG_L7CTRL = 58,
	S2MPS15_REG_L8CTRL = 59,
	S2MPS15_REG_L9CTRL = 60,
	S2MPS15_REG_L10CTRL = 61,
	S2MPS15_REG_L11CTRL = 62,
	S2MPS15_REG_L12CTRL = 63,
	S2MPS15_REG_L13CTRL = 64,
	S2MPS15_REG_L14CTRL = 65,
	S2MPS15_REG_L15CTRL = 66,
	S2MPS15_REG_L16CTRL = 67,
	S2MPS15_REG_L17CTRL = 68,
	S2MPS15_REG_L18CTRL = 69,
	S2MPS15_REG_L19CTRL = 70,
	S2MPS15_REG_L20CTRL = 71,
	S2MPS15_REG_L21CTRL = 72,
	S2MPS15_REG_L22CTRL = 73,
	S2MPS15_REG_L23CTRL = 74,
	S2MPS15_REG_L24CTRL = 75,
	S2MPS15_REG_L25CTRL = 76,
	S2MPS15_REG_L26CTRL = 77,
	S2MPS15_REG_L27CTRL = 78,
	S2MPS15_REG_LDODSCH1 = 79,
	S2MPS15_REG_LDODSCH2 = 80,
	S2MPS15_REG_LDODSCH3 = 81,
	S2MPS15_REG_LDODSCH4 = 82,
};

enum S2MPU02_reg {
	S2MPU02_REG_ID = 0,
	S2MPU02_REG_INT1 = 1,
	S2MPU02_REG_INT2 = 2,
	S2MPU02_REG_INT3 = 3,
	S2MPU02_REG_INT1M = 4,
	S2MPU02_REG_INT2M = 5,
	S2MPU02_REG_INT3M = 6,
	S2MPU02_REG_ST1 = 7,
	S2MPU02_REG_ST2 = 8,
	S2MPU02_REG_PWRONSRC = 9,
	S2MPU02_REG_OFFSRC = 10,
	S2MPU02_REG_BU_CHG = 11,
	S2MPU02_REG_RTCCTRL = 12,
	S2MPU02_REG_PMCTRL1 = 13,
	S2MPU02_REG_RSVD1 = 14,
	S2MPU02_REG_RSVD2 = 15,
	S2MPU02_REG_RSVD3 = 16,
	S2MPU02_REG_RSVD4 = 17,
	S2MPU02_REG_RSVD5 = 18,
	S2MPU02_REG_RSVD6 = 19,
	S2MPU02_REG_RSVD7 = 20,
	S2MPU02_REG_WRSTEN = 21,
	S2MPU02_REG_RSVD8 = 22,
	S2MPU02_REG_RSVD9 = 23,
	S2MPU02_REG_RSVD10 = 24,
	S2MPU02_REG_B1CTRL1 = 25,
	S2MPU02_REG_B1CTRL2 = 26,
	S2MPU02_REG_B2CTRL1 = 27,
	S2MPU02_REG_B2CTRL2 = 28,
	S2MPU02_REG_B3CTRL1 = 29,
	S2MPU02_REG_B3CTRL2 = 30,
	S2MPU02_REG_B4CTRL1 = 31,
	S2MPU02_REG_B4CTRL2 = 32,
	S2MPU02_REG_B5CTRL1 = 33,
	S2MPU02_REG_B5CTRL2 = 34,
	S2MPU02_REG_B5CTRL3 = 35,
	S2MPU02_REG_B5CTRL4 = 36,
	S2MPU02_REG_B5CTRL5 = 37,
	S2MPU02_REG_B6CTRL1 = 38,
	S2MPU02_REG_B6CTRL2 = 39,
	S2MPU02_REG_B7CTRL1 = 40,
	S2MPU02_REG_B7CTRL2 = 41,
	S2MPU02_REG_RAMP1 = 42,
	S2MPU02_REG_RAMP2 = 43,
	S2MPU02_REG_L1CTRL = 44,
	S2MPU02_REG_L2CTRL1 = 45,
	S2MPU02_REG_L2CTRL2 = 46,
	S2MPU02_REG_L2CTRL3 = 47,
	S2MPU02_REG_L2CTRL4 = 48,
	S2MPU02_REG_L3CTRL = 49,
	S2MPU02_REG_L4CTRL = 50,
	S2MPU02_REG_L5CTRL = 51,
	S2MPU02_REG_L6CTRL = 52,
	S2MPU02_REG_L7CTRL = 53,
	S2MPU02_REG_L8CTRL = 54,
	S2MPU02_REG_L9CTRL = 55,
	S2MPU02_REG_L10CTRL = 56,
	S2MPU02_REG_L11CTRL = 57,
	S2MPU02_REG_L12CTRL = 58,
	S2MPU02_REG_L13CTRL = 59,
	S2MPU02_REG_L14CTRL = 60,
	S2MPU02_REG_L15CTRL = 61,
	S2MPU02_REG_L16CTRL = 62,
	S2MPU02_REG_L17CTRL = 63,
	S2MPU02_REG_L18CTRL = 64,
	S2MPU02_REG_L19CTRL = 65,
	S2MPU02_REG_L20CTRL = 66,
	S2MPU02_REG_L21CTRL = 67,
	S2MPU02_REG_L22CTRL = 68,
	S2MPU02_REG_L23CTRL = 69,
	S2MPU02_REG_L24CTRL = 70,
	S2MPU02_REG_L25CTRL = 71,
	S2MPU02_REG_L26CTRL = 72,
	S2MPU02_REG_L27CTRL = 73,
	S2MPU02_REG_L28CTRL = 74,
	S2MPU02_REG_LDODSCH1 = 75,
	S2MPU02_REG_LDODSCH2 = 76,
	S2MPU02_REG_LDODSCH3 = 77,
	S2MPU02_REG_LDODSCH4 = 78,
	S2MPU02_REG_SELMIF = 79,
	S2MPU02_REG_RSVD11 = 80,
	S2MPU02_REG_RSVD12 = 81,
	S2MPU02_REG_RSVD13 = 82,
	S2MPU02_REG_DVSSEL = 83,
	S2MPU02_REG_DVSPTR = 84,
	S2MPU02_REG_DVSDATA = 85,
};

enum s5m8763_reg {
	S5M8763_REG_IRQ1 = 0,
	S5M8763_REG_IRQ2 = 1,
	S5M8763_REG_IRQ3 = 2,
	S5M8763_REG_IRQ4 = 3,
	S5M8763_REG_IRQM1 = 4,
	S5M8763_REG_IRQM2 = 5,
	S5M8763_REG_IRQM3 = 6,
	S5M8763_REG_IRQM4 = 7,
	S5M8763_REG_STATUS1 = 8,
	S5M8763_REG_STATUS2 = 9,
	S5M8763_REG_STATUSM1 = 10,
	S5M8763_REG_STATUSM2 = 11,
	S5M8763_REG_CHGR1 = 12,
	S5M8763_REG_CHGR2 = 13,
	S5M8763_REG_LDO_ACTIVE_DISCHARGE1 = 14,
	S5M8763_REG_LDO_ACTIVE_DISCHARGE2 = 15,
	S5M8763_REG_BUCK_ACTIVE_DISCHARGE3 = 16,
	S5M8763_REG_ONOFF1 = 17,
	S5M8763_REG_ONOFF2 = 18,
	S5M8763_REG_ONOFF3 = 19,
	S5M8763_REG_ONOFF4 = 20,
	S5M8763_REG_BUCK1_VOLTAGE1 = 21,
	S5M8763_REG_BUCK1_VOLTAGE2 = 22,
	S5M8763_REG_BUCK1_VOLTAGE3 = 23,
	S5M8763_REG_BUCK1_VOLTAGE4 = 24,
	S5M8763_REG_BUCK2_VOLTAGE1 = 25,
	S5M8763_REG_BUCK2_VOLTAGE2 = 26,
	S5M8763_REG_BUCK3 = 27,
	S5M8763_REG_BUCK4 = 28,
	S5M8763_REG_LDO1_LDO2 = 29,
	S5M8763_REG_LDO3 = 30,
	S5M8763_REG_LDO4 = 31,
	S5M8763_REG_LDO5 = 32,
	S5M8763_REG_LDO6 = 33,
	S5M8763_REG_LDO7 = 34,
	S5M8763_REG_LDO7_LDO8 = 35,
	S5M8763_REG_LDO9_LDO10 = 36,
	S5M8763_REG_LDO11 = 37,
	S5M8763_REG_LDO12 = 38,
	S5M8763_REG_LDO13 = 39,
	S5M8763_REG_LDO14 = 40,
	S5M8763_REG_LDO15 = 41,
	S5M8763_REG_LDO16 = 42,
	S5M8763_REG_BKCHR = 43,
	S5M8763_REG_LBCNFG1 = 44,
	S5M8763_REG_LBCNFG2 = 45,
};

enum s5m8767_reg {
	S5M8767_REG_ID = 0,
	S5M8767_REG_INT1 = 1,
	S5M8767_REG_INT2 = 2,
	S5M8767_REG_INT3 = 3,
	S5M8767_REG_INT1M = 4,
	S5M8767_REG_INT2M = 5,
	S5M8767_REG_INT3M = 6,
	S5M8767_REG_STATUS1 = 7,
	S5M8767_REG_STATUS2 = 8,
	S5M8767_REG_STATUS3 = 9,
	S5M8767_REG_CTRL1 = 10,
	S5M8767_REG_CTRL2 = 11,
	S5M8767_REG_LOWBAT1 = 12,
	S5M8767_REG_LOWBAT2 = 13,
	S5M8767_REG_BUCHG = 14,
	S5M8767_REG_DVSRAMP = 15,
	S5M8767_REG_DVSTIMER2 = 16,
	S5M8767_REG_DVSTIMER3 = 17,
	S5M8767_REG_DVSTIMER4 = 18,
	S5M8767_REG_LDO1 = 19,
	S5M8767_REG_LDO2 = 20,
	S5M8767_REG_LDO3 = 21,
	S5M8767_REG_LDO4 = 22,
	S5M8767_REG_LDO5 = 23,
	S5M8767_REG_LDO6 = 24,
	S5M8767_REG_LDO7 = 25,
	S5M8767_REG_LDO8 = 26,
	S5M8767_REG_LDO9 = 27,
	S5M8767_REG_LDO10 = 28,
	S5M8767_REG_LDO11 = 29,
	S5M8767_REG_LDO12 = 30,
	S5M8767_REG_LDO13 = 31,
	S5M8767_REG_LDO14 = 32,
	S5M8767_REG_LDO15 = 33,
	S5M8767_REG_LDO16 = 34,
	S5M8767_REG_LDO17 = 35,
	S5M8767_REG_LDO18 = 36,
	S5M8767_REG_LDO19 = 37,
	S5M8767_REG_LDO20 = 38,
	S5M8767_REG_LDO21 = 39,
	S5M8767_REG_LDO22 = 40,
	S5M8767_REG_LDO23 = 41,
	S5M8767_REG_LDO24 = 42,
	S5M8767_REG_LDO25 = 43,
	S5M8767_REG_LDO26 = 44,
	S5M8767_REG_LDO27 = 45,
	S5M8767_REG_LDO28 = 46,
	S5M8767_REG_UVLO = 49,
	S5M8767_REG_BUCK1CTRL1 = 50,
	S5M8767_REG_BUCK1CTRL2 = 51,
	S5M8767_REG_BUCK2CTRL = 52,
	S5M8767_REG_BUCK2DVS1 = 53,
	S5M8767_REG_BUCK2DVS2 = 54,
	S5M8767_REG_BUCK2DVS3 = 55,
	S5M8767_REG_BUCK2DVS4 = 56,
	S5M8767_REG_BUCK2DVS5 = 57,
	S5M8767_REG_BUCK2DVS6 = 58,
	S5M8767_REG_BUCK2DVS7 = 59,
	S5M8767_REG_BUCK2DVS8 = 60,
	S5M8767_REG_BUCK3CTRL = 61,
	S5M8767_REG_BUCK3DVS1 = 62,
	S5M8767_REG_BUCK3DVS2 = 63,
	S5M8767_REG_BUCK3DVS3 = 64,
	S5M8767_REG_BUCK3DVS4 = 65,
	S5M8767_REG_BUCK3DVS5 = 66,
	S5M8767_REG_BUCK3DVS6 = 67,
	S5M8767_REG_BUCK3DVS7 = 68,
	S5M8767_REG_BUCK3DVS8 = 69,
	S5M8767_REG_BUCK4CTRL = 70,
	S5M8767_REG_BUCK4DVS1 = 71,
	S5M8767_REG_BUCK4DVS2 = 72,
	S5M8767_REG_BUCK4DVS3 = 73,
	S5M8767_REG_BUCK4DVS4 = 74,
	S5M8767_REG_BUCK4DVS5 = 75,
	S5M8767_REG_BUCK4DVS6 = 76,
	S5M8767_REG_BUCK4DVS7 = 77,
	S5M8767_REG_BUCK4DVS8 = 78,
	S5M8767_REG_BUCK5CTRL1 = 79,
	S5M8767_REG_BUCK5CTRL2 = 80,
	S5M8767_REG_BUCK5CTRL3 = 81,
	S5M8767_REG_BUCK5CTRL4 = 82,
	S5M8767_REG_BUCK5CTRL5 = 83,
	S5M8767_REG_BUCK6CTRL1 = 84,
	S5M8767_REG_BUCK6CTRL2 = 85,
	S5M8767_REG_BUCK7CTRL1 = 86,
	S5M8767_REG_BUCK7CTRL2 = 87,
	S5M8767_REG_BUCK8CTRL1 = 88,
	S5M8767_REG_BUCK8CTRL2 = 89,
	S5M8767_REG_BUCK9CTRL1 = 90,
	S5M8767_REG_BUCK9CTRL2 = 91,
	S5M8767_REG_LDO1CTRL = 92,
	S5M8767_REG_LDO2_1CTRL = 93,
	S5M8767_REG_LDO2_2CTRL = 94,
	S5M8767_REG_LDO2_3CTRL = 95,
	S5M8767_REG_LDO2_4CTRL = 96,
	S5M8767_REG_LDO3CTRL = 97,
	S5M8767_REG_LDO4CTRL = 98,
	S5M8767_REG_LDO5CTRL = 99,
	S5M8767_REG_LDO6CTRL = 100,
	S5M8767_REG_LDO7CTRL = 101,
	S5M8767_REG_LDO8CTRL = 102,
	S5M8767_REG_LDO9CTRL = 103,
	S5M8767_REG_LDO10CTRL = 104,
	S5M8767_REG_LDO11CTRL = 105,
	S5M8767_REG_LDO12CTRL = 106,
	S5M8767_REG_LDO13CTRL = 107,
	S5M8767_REG_LDO14CTRL = 108,
	S5M8767_REG_LDO15CTRL = 109,
	S5M8767_REG_LDO16CTRL = 110,
	S5M8767_REG_LDO17CTRL = 111,
	S5M8767_REG_LDO18CTRL = 112,
	S5M8767_REG_LDO19CTRL = 113,
	S5M8767_REG_LDO20CTRL = 114,
	S5M8767_REG_LDO21CTRL = 115,
	S5M8767_REG_LDO22CTRL = 116,
	S5M8767_REG_LDO23CTRL = 117,
	S5M8767_REG_LDO24CTRL = 118,
	S5M8767_REG_LDO25CTRL = 119,
	S5M8767_REG_LDO26CTRL = 120,
	S5M8767_REG_LDO27CTRL = 121,
	S5M8767_REG_LDO28CTRL = 122,
};

enum s2mps11_irq {
	S2MPS11_IRQ_PWRONF = 0,
	S2MPS11_IRQ_PWRONR = 1,
	S2MPS11_IRQ_JIGONBF = 2,
	S2MPS11_IRQ_JIGONBR = 3,
	S2MPS11_IRQ_ACOKBF = 4,
	S2MPS11_IRQ_ACOKBR = 5,
	S2MPS11_IRQ_PWRON1S = 6,
	S2MPS11_IRQ_MRB = 7,
	S2MPS11_IRQ_RTC60S = 8,
	S2MPS11_IRQ_RTCA1 = 9,
	S2MPS11_IRQ_RTCA0 = 10,
	S2MPS11_IRQ_SMPL = 11,
	S2MPS11_IRQ_RTC1S = 12,
	S2MPS11_IRQ_WTSR = 13,
	S2MPS11_IRQ_INT120C = 14,
	S2MPS11_IRQ_INT140C = 15,
	S2MPS11_IRQ_NR = 16,
};

enum s2mps14_irq {
	S2MPS14_IRQ_PWRONF = 0,
	S2MPS14_IRQ_PWRONR = 1,
	S2MPS14_IRQ_JIGONBF = 2,
	S2MPS14_IRQ_JIGONBR = 3,
	S2MPS14_IRQ_ACOKBF = 4,
	S2MPS14_IRQ_ACOKBR = 5,
	S2MPS14_IRQ_PWRON1S = 6,
	S2MPS14_IRQ_MRB = 7,
	S2MPS14_IRQ_RTC60S = 8,
	S2MPS14_IRQ_RTCA1 = 9,
	S2MPS14_IRQ_RTCA0 = 10,
	S2MPS14_IRQ_SMPL = 11,
	S2MPS14_IRQ_RTC1S = 12,
	S2MPS14_IRQ_WTSR = 13,
	S2MPS14_IRQ_INT120C = 14,
	S2MPS14_IRQ_INT140C = 15,
	S2MPS14_IRQ_TSD = 16,
	S2MPS14_IRQ_NR = 17,
};

enum s2mpu02_irq {
	S2MPU02_IRQ_PWRONF = 0,
	S2MPU02_IRQ_PWRONR = 1,
	S2MPU02_IRQ_JIGONBF = 2,
	S2MPU02_IRQ_JIGONBR = 3,
	S2MPU02_IRQ_ACOKBF = 4,
	S2MPU02_IRQ_ACOKBR = 5,
	S2MPU02_IRQ_PWRON1S = 6,
	S2MPU02_IRQ_MRB = 7,
	S2MPU02_IRQ_RTC60S = 8,
	S2MPU02_IRQ_RTCA1 = 9,
	S2MPU02_IRQ_RTCA0 = 10,
	S2MPU02_IRQ_SMPL = 11,
	S2MPU02_IRQ_RTC1S = 12,
	S2MPU02_IRQ_WTSR = 13,
	S2MPU02_IRQ_INT120C = 14,
	S2MPU02_IRQ_INT140C = 15,
	S2MPU02_IRQ_TSD = 16,
	S2MPU02_IRQ_NR = 17,
};

enum s5m8767_irq {
	S5M8767_IRQ_PWRR = 0,
	S5M8767_IRQ_PWRF = 1,
	S5M8767_IRQ_PWR1S = 2,
	S5M8767_IRQ_JIGR = 3,
	S5M8767_IRQ_JIGF = 4,
	S5M8767_IRQ_LOWBAT2 = 5,
	S5M8767_IRQ_LOWBAT1 = 6,
	S5M8767_IRQ_MRB = 7,
	S5M8767_IRQ_DVSOK2 = 8,
	S5M8767_IRQ_DVSOK3 = 9,
	S5M8767_IRQ_DVSOK4 = 10,
	S5M8767_IRQ_RTC60S = 11,
	S5M8767_IRQ_RTCA1 = 12,
	S5M8767_IRQ_RTCA2 = 13,
	S5M8767_IRQ_SMPL = 14,
	S5M8767_IRQ_RTC1S = 15,
	S5M8767_IRQ_WTSR = 16,
	S5M8767_IRQ_NR = 17,
};

enum s5m8763_irq {
	S5M8763_IRQ_DCINF = 0,
	S5M8763_IRQ_DCINR = 1,
	S5M8763_IRQ_JIGF = 2,
	S5M8763_IRQ_JIGR = 3,
	S5M8763_IRQ_PWRONF = 4,
	S5M8763_IRQ_PWRONR = 5,
	S5M8763_IRQ_WTSREVNT = 6,
	S5M8763_IRQ_SMPLEVNT = 7,
	S5M8763_IRQ_ALARM1 = 8,
	S5M8763_IRQ_ALARM0 = 9,
	S5M8763_IRQ_ONKEY1S = 10,
	S5M8763_IRQ_TOPOFFR = 11,
	S5M8763_IRQ_DCINOVPR = 12,
	S5M8763_IRQ_CHGRSTF = 13,
	S5M8763_IRQ_DONER = 14,
	S5M8763_IRQ_CHGFAULT = 15,
	S5M8763_IRQ_LOBAT1 = 16,
	S5M8763_IRQ_LOBAT2 = 17,
	S5M8763_IRQ_NR = 18,
};

struct syscon_platform_data {
	const char *label;
};

struct syscon {
	struct device_node *np;
	struct regmap *regmap;
	struct list_head list;
};

enum {
	AS3711_REGULATOR_SD_1 = 0,
	AS3711_REGULATOR_SD_2 = 1,
	AS3711_REGULATOR_SD_3 = 2,
	AS3711_REGULATOR_SD_4 = 3,
	AS3711_REGULATOR_LDO_1 = 4,
	AS3711_REGULATOR_LDO_2 = 5,
	AS3711_REGULATOR_LDO_3 = 6,
	AS3711_REGULATOR_LDO_4 = 7,
	AS3711_REGULATOR_LDO_5 = 8,
	AS3711_REGULATOR_LDO_6 = 9,
	AS3711_REGULATOR_LDO_7 = 10,
	AS3711_REGULATOR_LDO_8 = 11,
	AS3711_REGULATOR_MAX = 12,
};

struct as3711 {
	struct device *dev;
	struct regmap *regmap;
};

enum as3711_su2_feedback {
	AS3711_SU2_VOLTAGE = 0,
	AS3711_SU2_CURR1 = 1,
	AS3711_SU2_CURR2 = 2,
	AS3711_SU2_CURR3 = 3,
	AS3711_SU2_CURR_AUTO = 4,
};

enum as3711_su2_fbprot {
	AS3711_SU2_LX_SD4 = 0,
	AS3711_SU2_GPIO2 = 1,
	AS3711_SU2_GPIO3 = 2,
	AS3711_SU2_GPIO4 = 3,
};

struct as3711_regulator_pdata {
	struct regulator_init_data *init_data[12];
};

struct as3711_bl_pdata {
	bool su1_fb;
	int su1_max_uA;
	bool su2_fb;
	int su2_max_uA;
	enum as3711_su2_feedback su2_feedback;
	enum as3711_su2_fbprot su2_fbprot;
	bool su2_auto_curr1;
	bool su2_auto_curr2;
	bool su2_auto_curr3;
};

struct as3711_platform_data {
	struct as3711_regulator_pdata regulator;
	struct as3711_bl_pdata backlight;
};

enum {
	AS3711_REGULATOR = 0,
	AS3711_BACKLIGHT = 1,
};

enum as3722_irq {
	AS3722_IRQ_LID = 0,
	AS3722_IRQ_ACOK = 1,
	AS3722_IRQ_ENABLE1 = 2,
	AS3722_IRQ_OCCUR_ALARM_SD0 = 3,
	AS3722_IRQ_ONKEY_LONG_PRESS = 4,
	AS3722_IRQ_ONKEY = 5,
	AS3722_IRQ_OVTMP = 6,
	AS3722_IRQ_LOWBAT = 7,
	AS3722_IRQ_SD0_LV = 8,
	AS3722_IRQ_SD1_LV = 9,
	AS3722_IRQ_SD2_LV = 10,
	AS3722_IRQ_PWM1_OV_PROT = 11,
	AS3722_IRQ_PWM2_OV_PROT = 12,
	AS3722_IRQ_ENABLE2 = 13,
	AS3722_IRQ_SD6_LV = 14,
	AS3722_IRQ_RTC_REP = 15,
	AS3722_IRQ_RTC_ALARM = 16,
	AS3722_IRQ_GPIO1 = 17,
	AS3722_IRQ_GPIO2 = 18,
	AS3722_IRQ_GPIO3 = 19,
	AS3722_IRQ_GPIO4 = 20,
	AS3722_IRQ_GPIO5 = 21,
	AS3722_IRQ_WATCHDOG = 22,
	AS3722_IRQ_ENABLE3 = 23,
	AS3722_IRQ_TEMP_SD0_SHUTDOWN = 24,
	AS3722_IRQ_TEMP_SD1_SHUTDOWN = 25,
	AS3722_IRQ_TEMP_SD2_SHUTDOWN = 26,
	AS3722_IRQ_TEMP_SD0_ALARM = 27,
	AS3722_IRQ_TEMP_SD1_ALARM = 28,
	AS3722_IRQ_TEMP_SD6_ALARM = 29,
	AS3722_IRQ_OCCUR_ALARM_SD6 = 30,
	AS3722_IRQ_ADC = 31,
	AS3722_IRQ_MAX = 32,
};

struct badrange {
	struct list_head list;
	spinlock_t lock;
};

enum {
	NDD_ALIASING = 0,
	NDD_UNARMED = 1,
	NDD_LOCKED = 2,
	NDD_SECURITY_OVERWRITE = 3,
	NDD_WORK_PENDING = 4,
	NDD_NOBLK = 5,
	NDD_LABELING = 6,
	ND_IOCTL_MAX_BUFLEN = 4194304,
	ND_CMD_MAX_ELEM = 5,
	ND_CMD_MAX_ENVELOPE = 256,
	ND_MAX_MAPPINGS = 32,
	ND_REGION_PAGEMAP = 0,
	ND_REGION_PERSIST_CACHE = 1,
	ND_REGION_PERSIST_MEMCTRL = 2,
	ND_REGION_ASYNC = 3,
	DPA_RESOURCE_ADJUSTED = 1,
};

struct nvdimm_bus_descriptor;

struct nvdimm;

typedef int (*ndctl_fn)(struct nvdimm_bus_descriptor *, struct nvdimm *, unsigned int, void *, unsigned int, int *);

struct nvdimm_bus_fw_ops;

struct nvdimm_bus_descriptor {
	const struct attribute_group **attr_groups;
	long unsigned int cmd_mask;
	long unsigned int dimm_family_mask;
	long unsigned int bus_family_mask;
	struct module *module;
	char *provider_name;
	struct device_node *of_node;
	ndctl_fn ndctl;
	int (*flush_probe)(struct nvdimm_bus_descriptor *);
	int (*clear_to_send)(struct nvdimm_bus_descriptor *, struct nvdimm *, unsigned int, void *);
	const struct nvdimm_bus_fw_ops *fw_ops;
};

struct nvdimm_security_ops;

struct nvdimm_fw_ops;

struct nvdimm {
	long unsigned int flags;
	void *provider_data;
	long unsigned int cmd_mask;
	struct device dev;
	atomic_t busy;
	int id;
	int num_flush;
	struct resource *flush_wpq;
	const char *dimm_id;
	struct {
		const struct nvdimm_security_ops *ops;
		long unsigned int flags;
		long unsigned int ext_flags;
		unsigned int overwrite_tmo;
		struct kernfs_node *overwrite_state;
	} sec;
	struct delayed_work dwork;
	const struct nvdimm_fw_ops *fw_ops;
};

enum nvdimm_fwa_state {
	NVDIMM_FWA_INVALID = 0,
	NVDIMM_FWA_IDLE = 1,
	NVDIMM_FWA_ARMED = 2,
	NVDIMM_FWA_BUSY = 3,
	NVDIMM_FWA_ARM_OVERFLOW = 4,
};

enum nvdimm_fwa_capability {
	NVDIMM_FWA_CAP_INVALID = 0,
	NVDIMM_FWA_CAP_NONE = 1,
	NVDIMM_FWA_CAP_QUIESCE = 2,
	NVDIMM_FWA_CAP_LIVE = 3,
};

struct nvdimm_bus_fw_ops {
	enum nvdimm_fwa_state (*activate_state)(struct nvdimm_bus_descriptor *);
	enum nvdimm_fwa_capability (*capability)(struct nvdimm_bus_descriptor *);
	int (*activate)(struct nvdimm_bus_descriptor *);
};

struct nvdimm_bus {
	struct nvdimm_bus_descriptor *nd_desc;
	wait_queue_head_t wait;
	struct list_head list;
	struct device dev;
	int id;
	int probe_active;
	atomic_t ioctl_active;
	struct list_head mapping_list;
	struct mutex reconfig_mutex;
	struct badrange badrange;
};

struct nvdimm_key_data {
	u8 data[32];
};

enum nvdimm_passphrase_type {
	NVDIMM_USER = 0,
	NVDIMM_MASTER = 1,
};

struct nvdimm_security_ops {
	long unsigned int (*get_flags)(struct nvdimm *, enum nvdimm_passphrase_type);
	int (*freeze)(struct nvdimm *);
	int (*change_key)(struct nvdimm *, const struct nvdimm_key_data *, const struct nvdimm_key_data *, enum nvdimm_passphrase_type);
	int (*unlock)(struct nvdimm *, const struct nvdimm_key_data *);
	int (*disable)(struct nvdimm *, const struct nvdimm_key_data *);
	int (*erase)(struct nvdimm *, const struct nvdimm_key_data *, enum nvdimm_passphrase_type);
	int (*overwrite)(struct nvdimm *, const struct nvdimm_key_data *);
	int (*query_overwrite)(struct nvdimm *);
};

enum nvdimm_fwa_trigger {
	NVDIMM_FWA_ARM = 0,
	NVDIMM_FWA_DISARM = 1,
};

enum nvdimm_fwa_result {
	NVDIMM_FWA_RESULT_INVALID = 0,
	NVDIMM_FWA_RESULT_NONE = 1,
	NVDIMM_FWA_RESULT_SUCCESS = 2,
	NVDIMM_FWA_RESULT_NOTSTAGED = 3,
	NVDIMM_FWA_RESULT_NEEDRESET = 4,
	NVDIMM_FWA_RESULT_FAIL = 5,
};

struct nvdimm_fw_ops {
	enum nvdimm_fwa_state (*activate_state)(struct nvdimm *);
	enum nvdimm_fwa_result (*activate_result)(struct nvdimm *);
	int (*arm)(struct nvdimm *, enum nvdimm_fwa_trigger);
};

enum {
	ND_CMD_IMPLEMENTED = 0,
	ND_CMD_ARS_CAP = 1,
	ND_CMD_ARS_START = 2,
	ND_CMD_ARS_STATUS = 3,
	ND_CMD_CLEAR_ERROR = 4,
	ND_CMD_SMART = 1,
	ND_CMD_SMART_THRESHOLD = 2,
	ND_CMD_DIMM_FLAGS = 3,
	ND_CMD_GET_CONFIG_SIZE = 4,
	ND_CMD_GET_CONFIG_DATA = 5,
	ND_CMD_SET_CONFIG_DATA = 6,
	ND_CMD_VENDOR_EFFECT_LOG_SIZE = 7,
	ND_CMD_VENDOR_EFFECT_LOG = 8,
	ND_CMD_VENDOR = 9,
	ND_CMD_CALL = 10,
};

enum {
	NSINDEX_SIG_LEN = 16,
	NSINDEX_ALIGN = 256,
	NSINDEX_SEQ_MASK = 3,
	NSLABEL_UUID_LEN = 16,
	NSLABEL_NAME_LEN = 64,
	NSLABEL_FLAG_ROLABEL = 1,
	NSLABEL_FLAG_LOCAL = 2,
	NSLABEL_FLAG_BTT = 4,
	NSLABEL_FLAG_UPDATING = 8,
	BTT_ALIGN = 4096,
	BTTINFO_SIG_LEN = 16,
	BTTINFO_UUID_LEN = 16,
	BTTINFO_FLAG_ERROR = 1,
	BTTINFO_MAJOR_VERSION = 1,
	ND_LABEL_MIN_SIZE = 1024,
	ND_LABEL_ID_SIZE = 50,
	ND_NSINDEX_INIT = 1,
};

struct nvdimm_map {
	struct nvdimm_bus *nvdimm_bus;
	struct list_head list;
	resource_size_t offset;
	long unsigned int flags;
	size_t size;
	union {
		void *mem;
		void *iomem;
	};
	struct kref kref;
};

struct badrange_entry {
	u64 start;
	u64 length;
	struct list_head list;
};

struct nd_cmd_desc {
	int in_num;
	int out_num;
	u32 in_sizes[5];
	int out_sizes[5];
};

struct nd_interleave_set {
	u64 cookie1;
	u64 cookie2;
	u64 altcookie;
	guid_t type_guid;
};

struct nvdimm_drvdata;

struct nd_mapping {
	struct nvdimm *nvdimm;
	u64 start;
	u64 size;
	int position;
	struct list_head labels;
	struct mutex lock;
	struct nvdimm_drvdata *ndd;
};

struct nd_percpu_lane;

struct nd_region {
	struct device dev;
	struct ida ns_ida;
	struct ida btt_ida;
	struct ida pfn_ida;
	struct ida dax_ida;
	long unsigned int flags;
	struct device *ns_seed;
	struct device *btt_seed;
	struct device *pfn_seed;
	struct device *dax_seed;
	long unsigned int align;
	u16 ndr_mappings;
	u64 ndr_size;
	u64 ndr_start;
	int id;
	int num_lanes;
	int ro;
	int numa_node;
	int target_node;
	void *provider_data;
	struct kernfs_node *bb_state;
	struct badblocks bb;
	struct nd_interleave_set *nd_set;
	struct nd_percpu_lane *lane;
	int (*flush)(struct nd_region *, struct bio *);
	struct nd_mapping mapping[0];
};

enum nvdimm_security_bits {
	NVDIMM_SECURITY_DISABLED = 0,
	NVDIMM_SECURITY_UNLOCKED = 1,
	NVDIMM_SECURITY_LOCKED = 2,
	NVDIMM_SECURITY_FROZEN = 3,
	NVDIMM_SECURITY_OVERWRITE = 4,
};

struct nd_cmd_get_config_size {
	__u32 status;
	__u32 config_size;
	__u32 max_xfer;
};

struct nd_cmd_set_config_hdr {
	__u32 in_offset;
	__u32 in_length;
	__u8 in_buf[0];
};

struct nd_cmd_vendor_hdr {
	__u32 opcode;
	__u32 in_length;
	__u8 in_buf[0];
};

struct nd_cmd_ars_cap {
	__u64 address;
	__u64 length;
	__u32 status;
	__u32 max_ars_out;
	__u32 clear_err_unit;
	__u16 flags;
	__u16 reserved;
};

struct nd_cmd_clear_error {
	__u64 address;
	__u64 length;
	__u32 status;
	__u8 reserved[4];
	__u64 cleared;
};

struct nd_cmd_pkg {
	__u64 nd_family;
	__u64 nd_command;
	__u32 nd_size_in;
	__u32 nd_size_out;
	__u32 nd_reserved2[9];
	__u32 nd_fw_size;
	unsigned char nd_payload[0];
};

enum nvdimm_event {
	NVDIMM_REVALIDATE_POISON = 0,
	NVDIMM_REVALIDATE_REGION = 1,
};

enum nvdimm_claim_class {
	NVDIMM_CCLASS_NONE = 0,
	NVDIMM_CCLASS_BTT = 1,
	NVDIMM_CCLASS_BTT2 = 2,
	NVDIMM_CCLASS_PFN = 3,
	NVDIMM_CCLASS_DAX = 4,
	NVDIMM_CCLASS_UNKNOWN = 5,
};

struct nd_device_driver {
	struct device_driver drv;
	long unsigned int type;
	int (*probe)(struct device *);
	void (*remove)(struct device *);
	void (*shutdown)(struct device *);
	void (*notify)(struct device *, enum nvdimm_event);
};

struct nd_namespace_common {
	int force_raw;
	struct device dev;
	struct device *claim;
	enum nvdimm_claim_class claim_class;
	int (*rw_bytes)(struct nd_namespace_common *, resource_size_t, void *, size_t, int, long unsigned int);
};

struct nd_namespace_io {
	struct nd_namespace_common common;
	struct resource res;
	resource_size_t size;
	void *addr;
	struct badblocks bb;
};

struct nvdimm_drvdata {
	struct device *dev;
	int nslabel_size;
	struct nd_cmd_get_config_size nsarea;
	void *data;
	int ns_current;
	int ns_next;
	struct resource dpa;
	struct kref kref;
};

struct nd_percpu_lane {
	int count;
	spinlock_t lock;
};

struct btt;

struct nd_btt {
	struct device dev;
	struct nd_namespace_common *ndns;
	struct btt *btt;
	long unsigned int lbasize;
	u64 size;
	u8 *uuid;
	int id;
	int initial_offset;
	u16 version_major;
	u16 version_minor;
};

enum nd_pfn_mode {
	PFN_MODE_NONE = 0,
	PFN_MODE_RAM = 1,
	PFN_MODE_PMEM = 2,
};

struct nd_pfn_sb;

struct nd_pfn {
	int id;
	u8 *uuid;
	struct device dev;
	long unsigned int align;
	long unsigned int npfns;
	enum nd_pfn_mode mode;
	struct nd_pfn_sb *pfn_sb;
	struct nd_namespace_common *ndns;
};

struct nd_pfn_sb {
	u8 signature[16];
	u8 uuid[16];
	u8 parent_uuid[16];
	__le32 flags;
	__le16 version_major;
	__le16 version_minor;
	__le64 dataoff;
	__le64 npfns;
	__le32 mode;
	__le32 start_pad;
	__le32 end_trunc;
	__le32 align;
	__le32 page_size;
	__le16 page_struct_size;
	u8 padding[3994];
	__le64 checksum;
};

struct nd_dax {
	struct nd_pfn nd_pfn;
};

enum nd_async_mode {
	ND_SYNC = 0,
	ND_ASYNC = 1,
};

struct clear_badblocks_context {
	resource_size_t phys;
	resource_size_t cleared;
};

enum nd_ioctl_mode {
	BUS_IOCTL = 0,
	DIMM_IOCTL = 1,
};

struct nd_cmd_get_config_data_hdr {
	__u32 in_offset;
	__u32 in_length;
	__u32 status;
	__u8 out_buf[0];
};

struct nd_blk_region {
	int (*enable)(struct nvdimm_bus *, struct device *);
	int (*do_io)(struct nd_blk_region *, resource_size_t, void *, u64, int);
	void *blk_provider_data;
	struct nd_region nd_region;
};

struct nd_label_id {
	char id[50];
};

struct blk_alloc_info {
	struct nd_mapping *nd_mapping;
	resource_size_t available;
	resource_size_t busy;
	struct resource *res;
};

enum nd_driver_flags {
	ND_DRIVER_DIMM = 2,
	ND_DRIVER_REGION_PMEM = 4,
	ND_DRIVER_REGION_BLK = 8,
	ND_DRIVER_NAMESPACE_IO = 16,
	ND_DRIVER_NAMESPACE_PMEM = 32,
	ND_DRIVER_NAMESPACE_BLK = 64,
	ND_DRIVER_DAX_PMEM = 128,
};

struct nd_mapping_desc {
	struct nvdimm *nvdimm;
	u64 start;
	u64 size;
	int position;
};

struct nd_region_desc {
	struct resource *res;
	struct nd_mapping_desc *mapping;
	u16 num_mappings;
	const struct attribute_group **attr_groups;
	struct nd_interleave_set *nd_set;
	void *provider_data;
	int num_lanes;
	int numa_node;
	int target_node;
	long unsigned int flags;
	struct device_node *of_node;
	int (*flush)(struct nd_region *, struct bio *);
};

struct nd_blk_region_desc {
	int (*enable)(struct nvdimm_bus *, struct device *);
	int (*do_io)(struct nd_blk_region *, resource_size_t, void *, u64, int);
	struct nd_region_desc ndr_desc;
};

struct nd_namespace_index {
	u8 sig[16];
	u8 flags[3];
	u8 labelsize;
	__le32 seq;
	__le64 myoff;
	__le64 mysize;
	__le64 otheroff;
	__le64 labeloff;
	__le32 nslot;
	__le16 major;
	__le16 minor;
	__le64 checksum;
	u8 free[0];
};

struct nd_namespace_label {
	u8 uuid[16];
	u8 name[64];
	__le32 flags;
	__le16 nlabel;
	__le16 position;
	__le64 isetcookie;
	__le64 lbasize;
	__le64 dpa;
	__le64 rawsize;
	__le32 slot;
	u8 align;
	u8 reserved[3];
	guid_t type_guid;
	guid_t abstraction_guid;
	u8 reserved2[88];
	__le64 checksum;
};

enum {
	ND_MAX_LANES = 256,
	INT_LBASIZE_ALIGNMENT = 64,
	NVDIMM_IO_ATOMIC = 1,
};

struct nd_region_data {
	int ns_count;
	int ns_active;
	unsigned int hints_shift;
	void *flush_wpq[0];
};

struct nd_label_ent {
	struct list_head list;
	long unsigned int flags;
	struct nd_namespace_label *label;
};

struct conflict_context {
	struct nd_region *nd_region;
	resource_size_t start;
	resource_size_t size;
};

enum {
	ND_MIN_NAMESPACE_SIZE = 4096,
};

struct nd_namespace_pmem {
	struct nd_namespace_io nsio;
	long unsigned int lbasize;
	char *alt_name;
	u8 *uuid;
	int id;
};

struct nd_namespace_blk {
	struct nd_namespace_common common;
	char *alt_name;
	u8 *uuid;
	int id;
	long unsigned int lbasize;
	resource_size_t size;
	int num_resources;
	struct resource **res;
};

enum nd_label_flags {
	ND_LABEL_REAP = 0,
};

enum alloc_loc {
	ALLOC_ERR = 0,
	ALLOC_BEFORE = 1,
	ALLOC_MID = 2,
	ALLOC_AFTER = 3,
};

struct btt {
	struct gendisk *btt_disk;
	struct request_queue *btt_queue;
	struct list_head arena_list;
	struct dentry *debugfs_dir;
	struct nd_btt *nd_btt;
	u64 nlba;
	long long unsigned int rawsize;
	u32 lbasize;
	u32 sector_size;
	struct nd_region *nd_region;
	struct mutex init_lock;
	int init_state;
	int num_arenas;
	struct badblocks *phys_bb;
};

struct nd_gen_sb {
	char reserved[4088];
	__le64 checksum;
};

struct btt_sb {
	u8 signature[16];
	u8 uuid[16];
	u8 parent_uuid[16];
	__le32 flags;
	__le16 version_major;
	__le16 version_minor;
	__le32 external_lbasize;
	__le32 external_nlba;
	__le32 internal_lbasize;
	__le32 internal_nlba;
	__le32 nfree;
	__le32 infosize;
	__le64 nextoff;
	__le64 dataoff;
	__le64 mapoff;
	__le64 logoff;
	__le64 info2off;
	u8 padding[3968];
	__le64 checksum;
};

enum nvdimmsec_op_ids {
	OP_FREEZE = 0,
	OP_DISABLE = 1,
	OP_UPDATE = 2,
	OP_ERASE = 3,
	OP_OVERWRITE = 4,
	OP_MASTER_UPDATE = 5,
	OP_MASTER_ERASE = 6,
};

struct dax_operations {
	long int (*direct_access)(struct dax_device *, long unsigned int, long int, void **, pfn_t *);
	bool (*dax_supported)(struct dax_device *, struct block_device *, int, sector_t, sector_t);
	size_t (*copy_from_iter)(struct dax_device *, long unsigned int, void *, size_t, struct iov_iter *);
	size_t (*copy_to_iter)(struct dax_device *, long unsigned int, void *, size_t, struct iov_iter *);
	int (*zero_page_range)(struct dax_device *, long unsigned int, size_t);
};

struct dax_device {
	struct hlist_node list;
	struct inode inode;
	struct cdev cdev;
	const char *host;
	void *private;
	long unsigned int flags;
	const struct dax_operations *ops;
};

enum dax_device_flags {
	DAXDEV_ALIVE = 0,
	DAXDEV_WRITE_CACHE = 1,
	DAXDEV_SYNC = 2,
};

struct dax_region {
	int id;
	int target_node;
	struct kref kref;
	struct device *dev;
	unsigned int align;
	struct ida ida;
	struct resource res;
	struct device *seed;
	struct device *youngest;
};

struct dax_mapping {
	struct device dev;
	int range_id;
	int id;
};

struct dev_dax_range {
	long unsigned int pgoff;
	struct range range;
	struct dax_mapping *mapping;
};

struct dev_dax {
	struct dax_region *region;
	struct dax_device *dax_dev;
	unsigned int align;
	int target_node;
	int id;
	struct ida ida;
	struct device dev;
	struct dev_pagemap *pgmap;
	int nr_range;
	struct dev_dax_range *ranges;
};

enum dev_dax_subsys {
	DEV_DAX_BUS = 0,
	DEV_DAX_CLASS = 1,
};

struct dev_dax_data {
	struct dax_region *dax_region;
	struct dev_pagemap *pgmap;
	enum dev_dax_subsys subsys;
	resource_size_t size;
	int id;
};

struct dax_device_driver {
	struct device_driver drv;
	struct list_head ids;
	int match_always;
	int (*probe)(struct dev_dax *);
	void (*remove)(struct dev_dax *);
};

struct dax_id {
	struct list_head list;
	char dev_name[30];
};

enum id_action {
	ID_REMOVE = 0,
	ID_ADD = 1,
};

struct memregion_info {
	int target_node;
};

struct seqcount_ww_mutex {
	seqcount_t seqcount;
};

typedef struct seqcount_ww_mutex seqcount_ww_mutex_t;

struct dma_buf_map {
	union {
		void *vaddr_iomem;
		void *vaddr;
	};
	bool is_iomem;
};

struct dma_fence_ops;

struct dma_fence {
	spinlock_t *lock;
	const struct dma_fence_ops *ops;
	union {
		struct list_head cb_list;
		ktime_t timestamp;
		struct callback_head rcu;
	};
	u64 context;
	u64 seqno;
	long unsigned int flags;
	struct kref refcount;
	int error;
};

struct dma_fence_ops {
	bool use_64bit_seqno;
	const char * (*get_driver_name)(struct dma_fence *);
	const char * (*get_timeline_name)(struct dma_fence *);
	bool (*enable_signaling)(struct dma_fence *);
	bool (*signaled)(struct dma_fence *);
	long int (*wait)(struct dma_fence *, bool, long int);
	void (*release)(struct dma_fence *);
	void (*fence_value_str)(struct dma_fence *, char *, int);
	void (*timeline_value_str)(struct dma_fence *, char *, int);
};

enum dma_fence_flag_bits {
	DMA_FENCE_FLAG_SIGNALED_BIT = 0,
	DMA_FENCE_FLAG_TIMESTAMP_BIT = 1,
	DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT = 2,
	DMA_FENCE_FLAG_USER_BITS = 3,
};

struct dma_fence_cb;

typedef void (*dma_fence_func_t)(struct dma_fence *, struct dma_fence_cb *);

struct dma_fence_cb {
	struct list_head node;
	dma_fence_func_t func;
};

struct dma_buf;

struct dma_buf_attachment;

struct dma_buf_ops {
	bool cache_sgt_mapping;
	int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
	void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
	int (*pin)(struct dma_buf_attachment *);
	void (*unpin)(struct dma_buf_attachment *);
	struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
	void (*unmap_dma_buf)(struct dma_buf_attachment *, struct sg_table *, enum dma_data_direction);
	void (*release)(struct dma_buf *);
	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*mmap)(struct dma_buf *, struct vm_area_struct *);
	int (*vmap)(struct dma_buf *, struct dma_buf_map *);
	void (*vunmap)(struct dma_buf *, struct dma_buf_map *);
};

struct dma_buf_poll_cb_t {
	struct dma_fence_cb cb;
	wait_queue_head_t *poll;
	__poll_t active;
};

struct dma_resv;

struct dma_buf {
	size_t size;
	struct file *file;
	struct list_head attachments;
	const struct dma_buf_ops *ops;
	struct mutex lock;
	unsigned int vmapping_counter;
	struct dma_buf_map vmap_ptr;
	const char *exp_name;
	const char *name;
	spinlock_t name_lock;
	struct module *owner;
	struct list_head list_node;
	void *priv;
	struct dma_resv *resv;
	wait_queue_head_t poll;
	struct dma_buf_poll_cb_t cb_excl;
	struct dma_buf_poll_cb_t cb_shared;
};

struct dma_buf_attach_ops;

struct dma_buf_attachment {
	struct dma_buf *dmabuf;
	struct device *dev;
	struct list_head node;
	struct sg_table *sgt;
	enum dma_data_direction dir;
	bool peer2peer;
	const struct dma_buf_attach_ops *importer_ops;
	void *importer_priv;
	void *priv;
};

struct dma_resv_list;

struct dma_resv {
	struct ww_mutex lock;
	seqcount_ww_mutex_t seq;
	struct dma_fence *fence_excl;
	struct dma_resv_list *fence;
};

struct dma_buf_attach_ops {
	bool allow_peer2peer;
	void (*move_notify)(struct dma_buf_attachment *);
};

struct dma_buf_export_info {
	const char *exp_name;
	struct module *owner;
	const struct dma_buf_ops *ops;
	size_t size;
	int flags;
	struct dma_resv *resv;
	void *priv;
};

struct dma_resv_list {
	struct callback_head rcu;
	u32 shared_count;
	u32 shared_max;
	struct dma_fence *shared[0];
};

struct dma_buf_sync {
	__u64 flags;
};

struct dma_buf_list {
	struct list_head head;
	struct mutex lock;
};

struct trace_event_raw_dma_fence {
	struct trace_entry ent;
	u32 __data_loc_driver;
	u32 __data_loc_timeline;
	unsigned int context;
	unsigned int seqno;
	char __data[0];
};

struct trace_event_data_offsets_dma_fence {
	u32 driver;
	u32 timeline;
};

typedef void (*btf_trace_dma_fence_emit)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_init)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_destroy)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_enable_signal)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_signaled)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_start)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_end)(void *, struct dma_fence *);

struct default_wait_cb {
	struct dma_fence_cb base;
	struct task_struct *task;
};

struct dma_fence_array;

struct dma_fence_array_cb {
	struct dma_fence_cb cb;
	struct dma_fence_array *array;
};

struct dma_fence_array {
	struct dma_fence base;
	spinlock_t lock;
	unsigned int num_fences;
	atomic_t num_pending;
	struct dma_fence **fences;
	struct irq_work work;
};

struct dma_fence_chain {
	struct dma_fence base;
	spinlock_t lock;
	struct dma_fence *prev;
	u64 prev_seqno;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
	struct irq_work work;
};

enum seqno_fence_condition {
	SEQNO_FENCE_WAIT_GEQUAL = 0,
	SEQNO_FENCE_WAIT_NONZERO = 1,
};

struct seqno_fence {
	struct dma_fence base;
	const struct dma_fence_ops *ops;
	struct dma_buf *sync_buf;
	uint32_t seqno_ofs;
	enum seqno_fence_condition condition;
};

struct dma_heap;

struct dma_heap_ops {
	struct dma_buf * (*allocate)(struct dma_heap *, long unsigned int, long unsigned int, long unsigned int);
};

struct dma_heap {
	const char *name;
	const struct dma_heap_ops *ops;
	void *priv;
	dev_t heap_devt;
	struct list_head list;
	struct cdev heap_cdev;
};

struct dma_heap_export_info {
	const char *name;
	const struct dma_heap_ops *ops;
	void *priv;
};

struct dma_heap_allocation_data {
	__u64 len;
	__u32 fd;
	__u32 fd_flags;
	__u64 heap_flags;
};

struct system_heap_buffer {
	struct dma_heap *heap;
	struct list_head attachments;
	struct mutex lock;
	long unsigned int len;
	struct sg_table sg_table;
	int vmap_cnt;
	void *vaddr;
};

struct dma_heap_attachment {
	struct device *dev;
	struct sg_table *table;
	struct list_head list;
	bool mapped;
};

struct cma_heap {
	struct dma_heap *heap;
	struct cma *cma;
};

struct cma_heap_buffer {
	struct cma_heap *heap;
	struct list_head attachments;
	struct mutex lock;
	long unsigned int len;
	struct page *cma_pages;
	struct page **pages;
	long unsigned int pagecount;
	int vmap_cnt;
	void *vaddr;
};

struct dma_heap_attachment___2 {
	struct device *dev;
	struct sg_table table;
	struct list_head list;
	bool mapped;
};

struct sync_file {
	struct file *file;
	char user_name[32];
	struct list_head sync_file_list;
	wait_queue_head_t wq;
	long unsigned int flags;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
};

struct sync_merge_data {
	char name[32];
	__s32 fd2;
	__s32 fence;
	__u32 flags;
	__u32 pad;
};

struct sync_fence_info {
	char obj_name[32];
	char driver_name[32];
	__s32 status;
	__u32 flags;
	__u64 timestamp_ns;
};

struct sync_file_info {
	char name[32];
	__s32 status;
	__u32 flags;
	__u32 num_fences;
	__u32 pad;
	__u64 sync_fence_info;
};

struct sync_timeline {
	struct kref kref;
	char name[32];
	u64 context;
	int value;
	struct rb_root pt_tree;
	struct list_head pt_list;
	spinlock_t lock;
	struct list_head sync_timeline_list;
};

struct sync_pt {
	struct dma_fence base;
	struct list_head link;
	struct rb_node node;
};

struct trace_event_raw_sync_timeline {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 value;
	char __data[0];
};

struct trace_event_data_offsets_sync_timeline {
	u32 name;
};

typedef void (*btf_trace_sync_timeline)(void *, struct sync_timeline *);

struct sw_sync_create_fence_data {
	__u32 value;
	char name[32];
	__s32 fence;
};

struct udmabuf_create {
	__u32 memfd;
	__u32 flags;
	__u64 offset;
	__u64 size;
};

struct udmabuf_create_item {
	__u32 memfd;
	__u32 __pad;
	__u64 offset;
	__u64 size;
};

struct udmabuf_create_list {
	__u32 flags;
	__u32 count;
	struct udmabuf_create_item list[0];
};

struct udmabuf {
	long unsigned int pagecount;
	struct page **pages;
	struct sg_table *sg;
	struct miscdevice *device;
};

enum scsi_disposition {
	NEEDS_RETRY = 8193,
	SUCCESS = 8194,
	FAILED = 8195,
	QUEUED = 8196,
	SOFT_ERROR = 8197,
	ADD_TO_MLQUEUE = 8198,
	TIMEOUT_ERROR = 8199,
	SCSI_RETURN_NOT_HANDLED = 8200,
	FAST_IO_FAIL = 8201,
};

typedef __u64 blist_flags_t;

enum scsi_device_state {
	SDEV_CREATED = 1,
	SDEV_RUNNING = 2,
	SDEV_CANCEL = 3,
	SDEV_DEL = 4,
	SDEV_QUIESCE = 5,
	SDEV_OFFLINE = 6,
	SDEV_TRANSPORT_OFFLINE = 7,
	SDEV_BLOCK = 8,
	SDEV_CREATED_BLOCK = 9,
};

struct scsi_vpd {
	struct callback_head rcu;
	int len;
	unsigned char data[0];
};

struct Scsi_Host;

struct scsi_target;

struct scsi_device_handler;

struct scsi_device {
	struct Scsi_Host *host;
	struct request_queue *request_queue;
	struct list_head siblings;
	struct list_head same_target_siblings;
	struct sbitmap budget_map;
	atomic_t device_blocked;
	atomic_t restarts;
	spinlock_t list_lock;
	struct list_head starved_entry;
	short unsigned int queue_depth;
	short unsigned int max_queue_depth;
	short unsigned int last_queue_full_depth;
	short unsigned int last_queue_full_count;
	long unsigned int last_queue_full_time;
	long unsigned int queue_ramp_up_period;
	long unsigned int last_queue_ramp_up;
	unsigned int id;
	unsigned int channel;
	u64 lun;
	unsigned int manufacturer;
	unsigned int sector_size;
	void *hostdata;
	unsigned char type;
	char scsi_level;
	char inq_periph_qual;
	struct mutex inquiry_mutex;
	unsigned char inquiry_len;
	unsigned char *inquiry;
	const char *vendor;
	const char *model;
	const char *rev;
	struct scsi_vpd *vpd_pg0;
	struct scsi_vpd *vpd_pg83;
	struct scsi_vpd *vpd_pg80;
	struct scsi_vpd *vpd_pg89;
	unsigned char current_tag;
	struct scsi_target *sdev_target;
	blist_flags_t sdev_bflags;
	unsigned int eh_timeout;
	unsigned int removable: 1;
	unsigned int changed: 1;
	unsigned int busy: 1;
	unsigned int lockable: 1;
	unsigned int locked: 1;
	unsigned int borken: 1;
	unsigned int disconnect: 1;
	unsigned int soft_reset: 1;
	unsigned int sdtr: 1;
	unsigned int wdtr: 1;
	unsigned int ppr: 1;
	unsigned int tagged_supported: 1;
	unsigned int simple_tags: 1;
	unsigned int was_reset: 1;
	unsigned int expecting_cc_ua: 1;
	unsigned int use_10_for_rw: 1;
	unsigned int use_10_for_ms: 1;
	unsigned int set_dbd_for_ms: 1;
	unsigned int no_report_opcodes: 1;
	unsigned int no_write_same: 1;
	unsigned int use_16_for_rw: 1;
	unsigned int skip_ms_page_8: 1;
	unsigned int skip_ms_page_3f: 1;
	unsigned int skip_vpd_pages: 1;
	unsigned int try_vpd_pages: 1;
	unsigned int use_192_bytes_for_3f: 1;
	unsigned int no_start_on_add: 1;
	unsigned int allow_restart: 1;
	unsigned int manage_start_stop: 1;
	unsigned int start_stop_pwr_cond: 1;
	unsigned int no_uld_attach: 1;
	unsigned int select_no_atn: 1;
	unsigned int fix_capacity: 1;
	unsigned int guess_capacity: 1;
	unsigned int retry_hwerror: 1;
	unsigned int last_sector_bug: 1;
	unsigned int no_read_disc_info: 1;
	unsigned int no_read_capacity_16: 1;
	unsigned int try_rc_10_first: 1;
	unsigned int security_supported: 1;
	unsigned int is_visible: 1;
	unsigned int wce_default_on: 1;
	unsigned int no_dif: 1;
	unsigned int broken_fua: 1;
	unsigned int lun_in_cdb: 1;
	unsigned int unmap_limit_for_ws: 1;
	unsigned int rpm_autosuspend: 1;
	bool offline_already;
	atomic_t disk_events_disable_depth;
	long unsigned int supported_events[1];
	long unsigned int pending_events[1];
	struct list_head event_list;
	struct work_struct event_work;
	unsigned int max_device_blocked;
	atomic_t iorequest_cnt;
	atomic_t iodone_cnt;
	atomic_t ioerr_cnt;
	struct device sdev_gendev;
	struct device sdev_dev;
	struct execute_work ew;
	struct work_struct requeue_work;
	struct scsi_device_handler *handler;
	void *handler_data;
	size_t dma_drain_len;
	void *dma_drain_buf;
	unsigned char access_state;
	struct mutex state_mutex;
	enum scsi_device_state sdev_state;
	struct task_struct *quiesced_by;
	long unsigned int sdev_data[0];
};

enum scsi_host_state {
	SHOST_CREATED = 1,
	SHOST_RUNNING = 2,
	SHOST_CANCEL = 3,
	SHOST_DEL = 4,
	SHOST_RECOVERY = 5,
	SHOST_CANCEL_RECOVERY = 6,
	SHOST_DEL_RECOVERY = 7,
};

struct scsi_host_template;

struct scsi_transport_template;

struct Scsi_Host {
	struct list_head __devices;
	struct list_head __targets;
	struct list_head starved_list;
	spinlock_t default_lock;
	spinlock_t *host_lock;
	struct mutex scan_mutex;
	struct list_head eh_abort_list;
	struct list_head eh_cmd_q;
	struct task_struct *ehandler;
	struct completion *eh_action;
	wait_queue_head_t host_wait;
	struct scsi_host_template *hostt;
	struct scsi_transport_template *transportt;
	struct blk_mq_tag_set tag_set;
	atomic_t host_blocked;
	unsigned int host_failed;
	unsigned int host_eh_scheduled;
	unsigned int host_no;
	int eh_deadline;
	long unsigned int last_reset;
	unsigned int max_channel;
	unsigned int max_id;
	u64 max_lun;
	unsigned int unique_id;
	short unsigned int max_cmd_len;
	int this_id;
	int can_queue;
	short int cmd_per_lun;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	unsigned int nr_hw_queues;
	unsigned int nr_maps;
	unsigned int active_mode: 2;
	unsigned int host_self_blocked: 1;
	unsigned int reverse_ordering: 1;
	unsigned int tmf_in_progress: 1;
	unsigned int async_scan: 1;
	unsigned int eh_noresume: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int short_inquiry: 1;
	unsigned int no_scsi2_lun_in_cdb: 1;
	char work_q_name[20];
	struct workqueue_struct *work_q;
	struct workqueue_struct *tmf_work_q;
	unsigned int max_host_blocked;
	unsigned int prot_capabilities;
	unsigned char prot_guard_type;
	long unsigned int base;
	long unsigned int io_port;
	unsigned char n_io_port;
	unsigned char dma_channel;
	unsigned int irq;
	enum scsi_host_state shost_state;
	struct device shost_gendev;
	struct device shost_dev;
	void *shost_data;
	struct device *dma_dev;
	long unsigned int hostdata[0];
};

enum scsi_target_state {
	STARGET_CREATED = 1,
	STARGET_RUNNING = 2,
	STARGET_REMOVE = 3,
	STARGET_CREATED_REMOVE = 4,
	STARGET_DEL = 5,
};

struct scsi_target {
	struct scsi_device *starget_sdev_user;
	struct list_head siblings;
	struct list_head devices;
	struct device dev;
	struct kref reap_ref;
	unsigned int channel;
	unsigned int id;
	unsigned int create: 1;
	unsigned int single_lun: 1;
	unsigned int pdt_1f_for_no_lun: 1;
	unsigned int no_report_luns: 1;
	unsigned int expecting_lun_change: 1;
	atomic_t target_busy;
	atomic_t target_blocked;
	unsigned int can_queue;
	unsigned int max_target_blocked;
	char scsi_level;
	enum scsi_target_state state;
	void *hostdata;
	long unsigned int starget_data[0];
};

struct scsi_host_cmd_pool;

struct scsi_cmnd;

struct scsi_host_template {
	unsigned int cmd_size;
	int (*queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
	void (*commit_rqs)(struct Scsi_Host *, u16);
	struct module *module;
	const char *name;
	const char * (*info)(struct Scsi_Host *);
	int (*ioctl)(struct scsi_device *, unsigned int, void *);
	int (*compat_ioctl)(struct scsi_device *, unsigned int, void *);
	int (*init_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*exit_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*eh_abort_handler)(struct scsi_cmnd *);
	int (*eh_device_reset_handler)(struct scsi_cmnd *);
	int (*eh_target_reset_handler)(struct scsi_cmnd *);
	int (*eh_bus_reset_handler)(struct scsi_cmnd *);
	int (*eh_host_reset_handler)(struct scsi_cmnd *);
	int (*slave_alloc)(struct scsi_device *);
	int (*slave_configure)(struct scsi_device *);
	void (*slave_destroy)(struct scsi_device *);
	int (*target_alloc)(struct scsi_target *);
	void (*target_destroy)(struct scsi_target *);
	int (*scan_finished)(struct Scsi_Host *, long unsigned int);
	void (*scan_start)(struct Scsi_Host *);
	int (*change_queue_depth)(struct scsi_device *, int);
	int (*map_queues)(struct Scsi_Host *);
	int (*mq_poll)(struct Scsi_Host *, unsigned int);
	bool (*dma_need_drain)(struct request *);
	int (*bios_param)(struct scsi_device *, struct block_device *, sector_t, int *);
	void (*unlock_native_capacity)(struct scsi_device *);
	int (*show_info)(struct seq_file *, struct Scsi_Host *);
	int (*write_info)(struct Scsi_Host *, char *, int);
	enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd *);
	bool (*eh_should_retry_cmd)(struct scsi_cmnd *);
	int (*host_reset)(struct Scsi_Host *, int);
	const char *proc_name;
	struct proc_dir_entry *proc_dir;
	int can_queue;
	int this_id;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	short int cmd_per_lun;
	unsigned char present;
	int tag_alloc_policy;
	unsigned int track_queue_depth: 1;
	unsigned int supported_mode: 2;
	unsigned int emulated: 1;
	unsigned int skip_settle_delay: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int max_host_blocked;
	struct device_attribute **shost_attrs;
	struct device_attribute **sdev_attrs;
	const struct attribute_group **sdev_groups;
	u64 vendor_id;
	struct scsi_host_cmd_pool *cmd_pool;
	int rpm_autosuspend_delay;
};

struct scsi_data_buffer {
	struct sg_table table;
	unsigned int length;
};

struct scsi_pointer {
	char *ptr;
	int this_residual;
	struct scatterlist *buffer;
	int buffers_residual;
	dma_addr_t dma_handle;
	volatile int Status;
	volatile int Message;
	volatile int have_data_in;
	volatile int sent_command;
	volatile int phase;
};

struct scsi_cmnd {
	struct scsi_request req;
	struct scsi_device *device;
	struct list_head eh_entry;
	struct delayed_work abort_work;
	struct callback_head rcu;
	int eh_eflags;
	int budget_token;
	long unsigned int jiffies_at_alloc;
	int retries;
	int allowed;
	unsigned char prot_op;
	unsigned char prot_type;
	unsigned char prot_flags;
	short unsigned int cmd_len;
	enum dma_data_direction sc_data_direction;
	unsigned char *cmnd;
	struct scsi_data_buffer sdb;
	struct scsi_data_buffer *prot_sdb;
	unsigned int underflow;
	unsigned int transfersize;
	struct request *request;
	unsigned char *sense_buffer;
	void (*scsi_done)(struct scsi_cmnd *);
	struct scsi_pointer SCp;
	unsigned char *host_scribble;
	int result;
	int flags;
	long unsigned int state;
	unsigned char tag;
	unsigned int extra_len;
};

enum scsi_prot_operations {
	SCSI_PROT_NORMAL = 0,
	SCSI_PROT_READ_INSERT = 1,
	SCSI_PROT_WRITE_STRIP = 2,
	SCSI_PROT_READ_STRIP = 3,
	SCSI_PROT_WRITE_INSERT = 4,
	SCSI_PROT_READ_PASS = 5,
	SCSI_PROT_WRITE_PASS = 6,
};

struct scsi_driver {
	struct device_driver gendrv;
	void (*rescan)(struct device *);
	blk_status_t (*init_command)(struct scsi_cmnd *);
	void (*uninit_command)(struct scsi_cmnd *);
	int (*done)(struct scsi_cmnd *);
	int (*eh_action)(struct scsi_cmnd *, int);
	void (*eh_reset)(struct scsi_cmnd *);
};

struct trace_event_raw_scsi_dispatch_cmd_start {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_dispatch_cmd_error {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int rtn;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_cmd_done_timeout_template {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int result;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_eh_wakeup {
	struct trace_entry ent;
	unsigned int host_no;
	char __data[0];
};

struct trace_event_data_offsets_scsi_dispatch_cmd_start {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_dispatch_cmd_error {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_cmd_done_timeout_template {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_eh_wakeup {};

typedef void (*btf_trace_scsi_dispatch_cmd_start)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_error)(void *, struct scsi_cmnd *, int);

typedef void (*btf_trace_scsi_dispatch_cmd_done)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_timeout)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_eh_wakeup)(void *, struct Scsi_Host *);

struct scsi_transport_template {
	struct transport_container host_attrs;
	struct transport_container target_attrs;
	struct transport_container device_attrs;
	int (*user_scan)(struct Scsi_Host *, uint, uint, u64);
	int device_size;
	int device_private_offset;
	int target_size;
	int target_private_offset;
	int host_size;
	unsigned int create_work_queue: 1;
	void (*eh_strategy_handler)(struct Scsi_Host *);
};

struct scsi_host_busy_iter_data {
	bool (*fn)(struct scsi_cmnd *, void *, bool);
	void *priv;
};

struct scsi_idlun {
	__u32 dev_id;
	__u32 host_unique_id;
};

typedef void (*activate_complete)(void *, int);

struct scsi_device_handler {
	struct list_head list;
	struct module *module;
	const char *name;
	enum scsi_disposition (*check_sense)(struct scsi_device *, struct scsi_sense_hdr *);
	int (*attach)(struct scsi_device *);
	void (*detach)(struct scsi_device *);
	int (*activate)(struct scsi_device *, activate_complete, void *);
	blk_status_t (*prep_fn)(struct scsi_device *, struct request *);
	int (*set_params)(struct scsi_device *, const char *);
	void (*rescan)(struct scsi_device *);
};

struct scsi_eh_save {
	int result;
	unsigned int resid_len;
	int eh_eflags;
	enum dma_data_direction data_direction;
	unsigned int underflow;
	unsigned char cmd_len;
	unsigned char prot_op;
	unsigned char *cmnd;
	struct scsi_data_buffer sdb;
	unsigned char eh_cmnd[16];
	struct scatterlist sense_sgl;
};

struct scsi_mode_data {
	__u32 length;
	__u16 block_descriptor_length;
	__u8 medium_type;
	__u8 device_specific;
	__u8 header_length;
	__u8 longlba: 1;
};

struct scsi_event {
	enum scsi_device_event evt_type;
	struct list_head node;
};

enum scsi_host_prot_capabilities {
	SHOST_DIF_TYPE1_PROTECTION = 1,
	SHOST_DIF_TYPE2_PROTECTION = 2,
	SHOST_DIF_TYPE3_PROTECTION = 4,
	SHOST_DIX_TYPE0_PROTECTION = 8,
	SHOST_DIX_TYPE1_PROTECTION = 16,
	SHOST_DIX_TYPE2_PROTECTION = 32,
	SHOST_DIX_TYPE3_PROTECTION = 64,
};

enum {
	ACTION_FAIL = 0,
	ACTION_REPREP = 1,
	ACTION_RETRY = 2,
	ACTION_DELAYED_RETRY = 3,
};

struct value_name_pair;

struct sa_name_list {
	int opcode;
	const struct value_name_pair *arr;
	int arr_sz;
};

struct value_name_pair {
	int value;
	const char *name;
};

struct error_info {
	short unsigned int code12;
	short unsigned int size;
};

struct error_info2 {
	unsigned char code1;
	unsigned char code2_min;
	unsigned char code2_max;
	const char *str;
	const char *fmt;
};

struct scsi_lun {
	__u8 scsi_lun[8];
};

enum scsi_timeouts {
	SCSI_DEFAULT_EH_TIMEOUT = 2500,
};

enum scsi_scan_mode {
	SCSI_SCAN_INITIAL = 0,
	SCSI_SCAN_RESCAN = 1,
	SCSI_SCAN_MANUAL = 2,
};

struct async_scan_data {
	struct list_head list;
	struct Scsi_Host *shost;
	struct completion prev_finished;
};

enum scsi_devinfo_key {
	SCSI_DEVINFO_GLOBAL = 0,
	SCSI_DEVINFO_SPI = 1,
};

struct scsi_dev_info_list {
	struct list_head dev_info_list;
	char vendor[8];
	char model[16];
	blist_flags_t flags;
	unsigned int compatible;
};

struct scsi_dev_info_list_table {
	struct list_head node;
	struct list_head scsi_dev_info_list;
	const char *name;
	int key;
};

struct double_list {
	struct list_head *top;
	struct list_head *bottom;
};

struct scsi_nl_hdr {
	__u8 version;
	__u8 transport;
	__u16 magic;
	__u16 msgtype;
	__u16 msglen;
};

struct scsi_varlen_cdb_hdr {
	__u8 opcode;
	__u8 control;
	__u8 misc[5];
	__u8 additional_cdb_length;
	__be16 service_action;
};

enum {
	SCSI_DH_OK = 0,
	SCSI_DH_DEV_FAILED = 1,
	SCSI_DH_DEV_TEMP_BUSY = 2,
	SCSI_DH_DEV_UNSUPP = 3,
	SCSI_DH_DEVICE_MAX = 4,
	SCSI_DH_NOTCONN = 5,
	SCSI_DH_CONN_FAILURE = 6,
	SCSI_DH_TRANSPORT_MAX = 7,
	SCSI_DH_IO = 8,
	SCSI_DH_INVALID_IO = 9,
	SCSI_DH_RETRY = 10,
	SCSI_DH_IMM_RETRY = 11,
	SCSI_DH_TIMED_OUT = 12,
	SCSI_DH_RES_TEMP_UNAVAIL = 13,
	SCSI_DH_DEV_OFFLINED = 14,
	SCSI_DH_NOMEM = 15,
	SCSI_DH_NOSYS = 16,
	SCSI_DH_DRIVER_MAX = 17,
};

struct scsi_dh_blist {
	const char *vendor;
	const char *model;
	const char *driver;
};

enum scsi_prot_flags {
	SCSI_PROT_TRANSFER_PI = 1,
	SCSI_PROT_GUARD_CHECK = 2,
	SCSI_PROT_REF_CHECK = 4,
	SCSI_PROT_REF_INCREMENT = 8,
	SCSI_PROT_IP_CHECKSUM = 16,
};

enum {
	SD_EXT_CDB_SIZE = 32,
	SD_MEMPOOL_SIZE = 2,
};

enum {
	SD_DEF_XFER_BLOCKS = 65535,
	SD_MAX_XFER_BLOCKS = 4294967295,
	SD_MAX_WS10_BLOCKS = 65535,
	SD_MAX_WS16_BLOCKS = 8388607,
};

enum {
	SD_LBP_FULL = 0,
	SD_LBP_UNMAP = 1,
	SD_LBP_WS16 = 2,
	SD_LBP_WS10 = 3,
	SD_LBP_ZERO = 4,
	SD_LBP_DISABLE = 5,
};

enum {
	SD_ZERO_WRITE = 0,
	SD_ZERO_WS = 1,
	SD_ZERO_WS16_UNMAP = 2,
	SD_ZERO_WS10_UNMAP = 3,
};

struct opal_dev___2;

struct scsi_disk {
	struct scsi_driver *driver;
	struct scsi_device *device;
	struct device dev;
	struct gendisk *disk;
	struct opal_dev___2 *opal_dev;
	u32 nr_zones;
	u32 rev_nr_zones;
	u32 zone_blocks;
	u32 rev_zone_blocks;
	u32 zones_optimal_open;
	u32 zones_optimal_nonseq;
	u32 zones_max_open;
	u32 *zones_wp_offset;
	spinlock_t zones_wp_offset_lock;
	u32 *rev_wp_offset;
	struct mutex rev_mutex;
	struct work_struct zone_wp_offset_work;
	char *zone_wp_update_buf;
	atomic_t openers;
	sector_t capacity;
	int max_retries;
	u32 max_xfer_blocks;
	u32 opt_xfer_blocks;
	u32 max_ws_blocks;
	u32 max_unmap_blocks;
	u32 unmap_granularity;
	u32 unmap_alignment;
	u32 index;
	unsigned int physical_block_size;
	unsigned int max_medium_access_timeouts;
	unsigned int medium_access_timed_out;
	u8 media_present;
	u8 write_prot;
	u8 protection_type;
	u8 provisioning_mode;
	u8 zeroing_mode;
	unsigned int ATO: 1;
	unsigned int cache_override: 1;
	unsigned int WCE: 1;
	unsigned int RCD: 1;
	unsigned int DPOFUA: 1;
	unsigned int first_scan: 1;
	unsigned int lbpme: 1;
	unsigned int lbprz: 1;
	unsigned int lbpu: 1;
	unsigned int lbpws: 1;
	unsigned int lbpws10: 1;
	unsigned int lbpvpd: 1;
	unsigned int ws10: 1;
	unsigned int ws16: 1;
	unsigned int rc_basis: 2;
	unsigned int zoned: 2;
	unsigned int urswrz: 1;
	unsigned int security: 1;
	unsigned int ignore_medium_access_errors: 1;
};

enum scsi_host_guard_type {
	SHOST_DIX_GUARD_CRC = 1,
	SHOST_DIX_GUARD_IP = 2,
};

enum zbc_zone_type {
	ZBC_ZONE_TYPE_CONV = 1,
	ZBC_ZONE_TYPE_SEQWRITE_REQ = 2,
	ZBC_ZONE_TYPE_SEQWRITE_PREF = 3,
};

enum zbc_zone_cond {
	ZBC_ZONE_COND_NO_WP = 0,
	ZBC_ZONE_COND_EMPTY = 1,
	ZBC_ZONE_COND_IMP_OPEN = 2,
	ZBC_ZONE_COND_EXP_OPEN = 3,
	ZBC_ZONE_COND_CLOSED = 4,
	ZBC_ZONE_COND_READONLY = 13,
	ZBC_ZONE_COND_FULL = 14,
	ZBC_ZONE_COND_OFFLINE = 15,
};

enum {
	mechtype_caddy = 0,
	mechtype_tray = 1,
	mechtype_popup = 2,
	mechtype_individual_changer = 4,
	mechtype_cartridge_changer = 5,
};

struct event_header {
	__be16 data_len;
	__u8 notification_class: 3;
	__u8 reserved1: 4;
	__u8 nea: 1;
	__u8 supp_event_class;
};

struct media_event_desc {
	__u8 media_event_code: 4;
	__u8 reserved1: 4;
	__u8 door_open: 1;
	__u8 media_present: 1;
	__u8 reserved2: 6;
	__u8 start_slot;
	__u8 end_slot;
};

struct scsi_cd {
	struct scsi_driver *driver;
	unsigned int capacity;
	struct scsi_device *device;
	unsigned int vendor;
	long unsigned int ms_offset;
	unsigned int writeable: 1;
	unsigned int use: 1;
	unsigned int xa_flag: 1;
	unsigned int readcd_known: 1;
	unsigned int readcd_cdda: 1;
	unsigned int media_present: 1;
	int tur_mismatch;
	bool tur_changed: 1;
	bool get_event_changed: 1;
	bool ignore_get_event: 1;
	struct cdrom_device_info cdi;
	struct mutex lock;
	struct kref kref;
	struct gendisk *disk;
};

struct cdrom_ti {
	__u8 cdti_trk0;
	__u8 cdti_ind0;
	__u8 cdti_trk1;
	__u8 cdti_ind1;
};

struct cdrom_tochdr {
	__u8 cdth_trk0;
	__u8 cdth_trk1;
};

struct cdrom_tocentry {
	__u8 cdte_track;
	__u8 cdte_adr: 4;
	__u8 cdte_ctrl: 4;
	__u8 cdte_format;
	union cdrom_addr cdte_addr;
	__u8 cdte_datamode;
};

typedef struct scsi_cd Scsi_CD;

struct ccs_modesel_head {
	__u8 _r1;
	__u8 medium;
	__u8 _r2;
	__u8 block_desc_length;
	__u8 density;
	__u8 number_blocks_hi;
	__u8 number_blocks_med;
	__u8 number_blocks_lo;
	__u8 _r3;
	__u8 block_length_hi;
	__u8 block_length_med;
	__u8 block_length_lo;
};

typedef struct sg_io_hdr sg_io_hdr_t;

struct sg_scsi_id {
	int host_no;
	int channel;
	int scsi_id;
	int lun;
	int scsi_type;
	short int h_cmd_per_lun;
	short int d_queue_depth;
	int unused[2];
};

typedef struct sg_scsi_id sg_scsi_id_t;

struct sg_req_info {
	char req_state;
	char orphan;
	char sg_io_owned;
	char problem;
	int pack_id;
	void *usr_ptr;
	unsigned int duration;
	int unused;
};

typedef struct sg_req_info sg_req_info_t;

struct sg_header {
	int pack_len;
	int reply_len;
	int pack_id;
	int result;
	unsigned int twelve_byte: 1;
	unsigned int target_status: 5;
	unsigned int host_status: 8;
	unsigned int driver_status: 8;
	unsigned int other_flags: 10;
	unsigned char sense_buffer[16];
};

struct sg_scatter_hold {
	short unsigned int k_use_sg;
	unsigned int sglist_len;
	unsigned int bufflen;
	struct page **pages;
	int page_order;
	char dio_in_use;
	unsigned char cmd_opcode;
};

typedef struct sg_scatter_hold Sg_scatter_hold;

struct sg_fd;

struct sg_request {
	struct list_head entry;
	struct sg_fd *parentfp;
	Sg_scatter_hold data;
	sg_io_hdr_t header;
	unsigned char sense_b[96];
	char res_used;
	char orphan;
	char sg_io_owned;
	char done;
	struct request *rq;
	struct bio *bio;
	struct execute_work ew;
};

typedef struct sg_request Sg_request;

struct sg_device;

struct sg_fd {
	struct list_head sfd_siblings;
	struct sg_device *parentdp;
	wait_queue_head_t read_wait;
	rwlock_t rq_list_lock;
	struct mutex f_mutex;
	int timeout;
	int timeout_user;
	Sg_scatter_hold reserve;
	struct list_head rq_list;
	struct fasync_struct *async_qp;
	Sg_request req_arr[16];
	char force_packid;
	char cmd_q;
	unsigned char next_cmd_len;
	char keep_orphan;
	char mmap_called;
	char res_in_use;
	struct kref f_ref;
	struct execute_work ew;
};

struct sg_device {
	struct scsi_device *device;
	wait_queue_head_t open_wait;
	struct mutex open_rel_lock;
	int sg_tablesize;
	u32 index;
	struct list_head sfds;
	rwlock_t sfd_lock;
	atomic_t detaching;
	bool exclude;
	int open_cnt;
	char sgdebug;
	struct gendisk *disk;
	struct cdev *cdev;
	struct kref d_ref;
};

typedef struct sg_fd Sg_fd;

typedef struct sg_device Sg_device;

struct compat_sg_req_info {
	char req_state;
	char orphan;
	char sg_io_owned;
	char problem;
	int pack_id;
	compat_uptr_t usr_ptr;
	unsigned int duration;
	int unused;
};

struct sg_proc_deviter {
	loff_t index;
	size_t max;
};

struct nvme_id_power_state {
	__le16 max_power;
	__u8 rsvd2;
	__u8 flags;
	__le32 entry_lat;
	__le32 exit_lat;
	__u8 read_tput;
	__u8 read_lat;
	__u8 write_tput;
	__u8 write_lat;
	__le16 idle_power;
	__u8 idle_scale;
	__u8 rsvd19;
	__le16 active_power;
	__u8 active_work_scale;
	__u8 rsvd23[9];
};

enum {
	NVME_PS_FLAGS_MAX_POWER_SCALE = 1,
	NVME_PS_FLAGS_NON_OP_STATE = 2,
};

enum nvme_ctrl_attr {
	NVME_CTRL_ATTR_HID_128_BIT = 1,
	NVME_CTRL_ATTR_TBKAS = 64,
};

struct nvme_id_ctrl {
	__le16 vid;
	__le16 ssvid;
	char sn[20];
	char mn[40];
	char fr[8];
	__u8 rab;
	__u8 ieee[3];
	__u8 cmic;
	__u8 mdts;
	__le16 cntlid;
	__le32 ver;
	__le32 rtd3r;
	__le32 rtd3e;
	__le32 oaes;
	__le32 ctratt;
	__u8 rsvd100[28];
	__le16 crdt1;
	__le16 crdt2;
	__le16 crdt3;
	__u8 rsvd134[122];
	__le16 oacs;
	__u8 acl;
	__u8 aerl;
	__u8 frmw;
	__u8 lpa;
	__u8 elpe;
	__u8 npss;
	__u8 avscc;
	__u8 apsta;
	__le16 wctemp;
	__le16 cctemp;
	__le16 mtfa;
	__le32 hmpre;
	__le32 hmmin;
	__u8 tnvmcap[16];
	__u8 unvmcap[16];
	__le32 rpmbs;
	__le16 edstt;
	__u8 dsto;
	__u8 fwug;
	__le16 kas;
	__le16 hctma;
	__le16 mntmt;
	__le16 mxtmt;
	__le32 sanicap;
	__le32 hmminds;
	__le16 hmmaxd;
	__u8 rsvd338[4];
	__u8 anatt;
	__u8 anacap;
	__le32 anagrpmax;
	__le32 nanagrpid;
	__u8 rsvd352[160];
	__u8 sqes;
	__u8 cqes;
	__le16 maxcmd;
	__le32 nn;
	__le16 oncs;
	__le16 fuses;
	__u8 fna;
	__u8 vwc;
	__le16 awun;
	__le16 awupf;
	__u8 nvscc;
	__u8 nwpc;
	__le16 acwu;
	__u8 rsvd534[2];
	__le32 sgls;
	__le32 mnan;
	__u8 rsvd544[224];
	char subnqn[256];
	__u8 rsvd1024[768];
	__le32 ioccsz;
	__le32 iorcsz;
	__le16 icdoff;
	__u8 ctrattr;
	__u8 msdbd;
	__u8 rsvd1804[244];
	struct nvme_id_power_state psd[32];
	__u8 vs[1024];
};

enum {
	NVME_CTRL_CMIC_MULTI_CTRL = 2,
	NVME_CTRL_CMIC_ANA = 8,
	NVME_CTRL_ONCS_COMPARE = 1,
	NVME_CTRL_ONCS_WRITE_UNCORRECTABLE = 2,
	NVME_CTRL_ONCS_DSM = 4,
	NVME_CTRL_ONCS_WRITE_ZEROES = 8,
	NVME_CTRL_ONCS_RESERVATIONS = 32,
	NVME_CTRL_ONCS_TIMESTAMP = 64,
	NVME_CTRL_VWC_PRESENT = 1,
	NVME_CTRL_OACS_SEC_SUPP = 1,
	NVME_CTRL_OACS_DIRECTIVES = 32,
	NVME_CTRL_OACS_DBBUF_SUPP = 256,
	NVME_CTRL_LPA_CMD_EFFECTS_LOG = 2,
	NVME_CTRL_CTRATT_128_ID = 1,
	NVME_CTRL_CTRATT_NON_OP_PSP = 2,
	NVME_CTRL_CTRATT_NVM_SETS = 4,
	NVME_CTRL_CTRATT_READ_RECV_LVLS = 8,
	NVME_CTRL_CTRATT_ENDURANCE_GROUPS = 16,
	NVME_CTRL_CTRATT_PREDICTABLE_LAT = 32,
	NVME_CTRL_CTRATT_NAMESPACE_GRANULARITY = 128,
	NVME_CTRL_CTRATT_UUID_LIST = 512,
};

struct nvme_lbaf {
	__le16 ms;
	__u8 ds;
	__u8 rp;
};

struct nvme_id_ns {
	__le64 nsze;
	__le64 ncap;
	__le64 nuse;
	__u8 nsfeat;
	__u8 nlbaf;
	__u8 flbas;
	__u8 mc;
	__u8 dpc;
	__u8 dps;
	__u8 nmic;
	__u8 rescap;
	__u8 fpi;
	__u8 dlfeat;
	__le16 nawun;
	__le16 nawupf;
	__le16 nacwu;
	__le16 nabsn;
	__le16 nabo;
	__le16 nabspf;
	__le16 noiob;
	__u8 nvmcap[16];
	__le16 npwg;
	__le16 npwa;
	__le16 npdg;
	__le16 npda;
	__le16 nows;
	__u8 rsvd74[18];
	__le32 anagrpid;
	__u8 rsvd96[3];
	__u8 nsattr;
	__le16 nvmsetid;
	__le16 endgid;
	__u8 nguid[16];
	__u8 eui64[8];
	struct nvme_lbaf lbaf[16];
	__u8 rsvd192[192];
	__u8 vs[3712];
};

struct nvme_id_ctrl_nvm {
	__u8 vsl;
	__u8 wzsl;
	__u8 wusl;
	__u8 dmrl;
	__le32 dmrsl;
	__le64 dmsl;
	__u8 rsvd16[4080];
};

enum {
	NVME_ID_CNS_NS = 0,
	NVME_ID_CNS_CTRL = 1,
	NVME_ID_CNS_NS_ACTIVE_LIST = 2,
	NVME_ID_CNS_NS_DESC_LIST = 3,
	NVME_ID_CNS_CS_NS = 5,
	NVME_ID_CNS_CS_CTRL = 6,
	NVME_ID_CNS_NS_PRESENT_LIST = 16,
	NVME_ID_CNS_NS_PRESENT = 17,
	NVME_ID_CNS_CTRL_NS_LIST = 18,
	NVME_ID_CNS_CTRL_LIST = 19,
	NVME_ID_CNS_SCNDRY_CTRL_LIST = 21,
	NVME_ID_CNS_NS_GRANULARITY = 22,
	NVME_ID_CNS_UUID_LIST = 23,
};

enum {
	NVME_CSI_NVM = 0,
	NVME_CSI_ZNS = 2,
};

enum {
	NVME_DIR_IDENTIFY = 0,
	NVME_DIR_STREAMS = 1,
	NVME_DIR_SND_ID_OP_ENABLE = 1,
	NVME_DIR_SND_ST_OP_REL_ID = 1,
	NVME_DIR_SND_ST_OP_REL_RSC = 2,
	NVME_DIR_RCV_ID_OP_PARAM = 1,
	NVME_DIR_RCV_ST_OP_PARAM = 1,
	NVME_DIR_RCV_ST_OP_STATUS = 2,
	NVME_DIR_RCV_ST_OP_RESOURCE = 3,
	NVME_DIR_ENDIR = 1,
};

enum {
	NVME_NS_FEAT_THIN = 1,
	NVME_NS_FEAT_ATOMICS = 2,
	NVME_NS_FEAT_IO_OPT = 16,
	NVME_NS_ATTR_RO = 1,
	NVME_NS_FLBAS_LBA_MASK = 15,
	NVME_NS_FLBAS_META_EXT = 16,
	NVME_NS_NMIC_SHARED = 1,
	NVME_LBAF_RP_BEST = 0,
	NVME_LBAF_RP_BETTER = 1,
	NVME_LBAF_RP_GOOD = 2,
	NVME_LBAF_RP_DEGRADED = 3,
	NVME_NS_DPC_PI_LAST = 16,
	NVME_NS_DPC_PI_FIRST = 8,
	NVME_NS_DPC_PI_TYPE3 = 4,
	NVME_NS_DPC_PI_TYPE2 = 2,
	NVME_NS_DPC_PI_TYPE1 = 1,
	NVME_NS_DPS_PI_FIRST = 8,
	NVME_NS_DPS_PI_MASK = 7,
	NVME_NS_DPS_PI_TYPE1 = 1,
	NVME_NS_DPS_PI_TYPE2 = 2,
	NVME_NS_DPS_PI_TYPE3 = 3,
};

struct nvme_ns_id_desc {
	__u8 nidt;
	__u8 nidl;
	__le16 reserved;
};

enum {
	NVME_NIDT_EUI64 = 1,
	NVME_NIDT_NGUID = 2,
	NVME_NIDT_UUID = 3,
	NVME_NIDT_CSI = 4,
};

struct nvme_fw_slot_info_log {
	__u8 afi;
	__u8 rsvd1[7];
	__le64 frs[7];
	__u8 rsvd64[448];
};

enum {
	NVME_CMD_EFFECTS_CSUPP = 1,
	NVME_CMD_EFFECTS_LBCC = 2,
	NVME_CMD_EFFECTS_NCC = 4,
	NVME_CMD_EFFECTS_NIC = 8,
	NVME_CMD_EFFECTS_CCC = 16,
	NVME_CMD_EFFECTS_CSE_MASK = 196608,
	NVME_CMD_EFFECTS_UUID_SEL = 524288,
};

struct nvme_effects_log {
	__le32 acs[256];
	__le32 iocs[256];
	__u8 resv[2048];
};

enum nvme_ana_state {
	NVME_ANA_OPTIMIZED = 1,
	NVME_ANA_NONOPTIMIZED = 2,
	NVME_ANA_INACCESSIBLE = 3,
	NVME_ANA_PERSISTENT_LOSS = 4,
	NVME_ANA_CHANGE = 15,
};

struct nvme_ana_rsp_hdr {
	__le64 chgcnt;
	__le16 ngrps;
	__le16 rsvd10[3];
};

enum {
	NVME_AER_ERROR = 0,
	NVME_AER_SMART = 1,
	NVME_AER_NOTICE = 2,
	NVME_AER_CSS = 6,
	NVME_AER_VS = 7,
};

enum {
	NVME_AER_NOTICE_NS_CHANGED = 0,
	NVME_AER_NOTICE_FW_ACT_STARTING = 1,
	NVME_AER_NOTICE_ANA = 3,
	NVME_AER_NOTICE_DISC_CHANGED = 240,
};

enum {
	NVME_AEN_CFG_NS_ATTR = 256,
	NVME_AEN_CFG_FW_ACT = 512,
	NVME_AEN_CFG_ANA_CHANGE = 2048,
	NVME_AEN_CFG_DISC_CHANGE = 2147483648,
};

enum nvme_opcode {
	nvme_cmd_flush = 0,
	nvme_cmd_write = 1,
	nvme_cmd_read = 2,
	nvme_cmd_write_uncor = 4,
	nvme_cmd_compare = 5,
	nvme_cmd_write_zeroes = 8,
	nvme_cmd_dsm = 9,
	nvme_cmd_verify = 12,
	nvme_cmd_resv_register = 13,
	nvme_cmd_resv_report = 14,
	nvme_cmd_resv_acquire = 17,
	nvme_cmd_resv_release = 21,
	nvme_cmd_zone_mgmt_send = 121,
	nvme_cmd_zone_mgmt_recv = 122,
	nvme_cmd_zone_append = 125,
};

struct nvme_sgl_desc {
	__le64 addr;
	__le32 length;
	__u8 rsvd[3];
	__u8 type;
};

struct nvme_keyed_sgl_desc {
	__le64 addr;
	__u8 length[3];
	__u8 key[4];
	__u8 type;
};

union nvme_data_ptr {
	struct {
		__le64 prp1;
		__le64 prp2;
	};
	struct nvme_sgl_desc sgl;
	struct nvme_keyed_sgl_desc ksgl;
};

enum {
	NVME_CMD_FUSE_FIRST = 1,
	NVME_CMD_FUSE_SECOND = 2,
	NVME_CMD_SGL_METABUF = 64,
	NVME_CMD_SGL_METASEG = 128,
	NVME_CMD_SGL_ALL = 192,
};

struct nvme_common_command {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le32 cdw2[2];
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le32 cdw10;
	__le32 cdw11;
	__le32 cdw12;
	__le32 cdw13;
	__le32 cdw14;
	__le32 cdw15;
};

struct nvme_rw_command {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2;
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le64 slba;
	__le16 length;
	__le16 control;
	__le32 dsmgmt;
	__le32 reftag;
	__le16 apptag;
	__le16 appmask;
};

enum {
	NVME_RW_LR = 32768,
	NVME_RW_FUA = 16384,
	NVME_RW_APPEND_PIREMAP = 512,
	NVME_RW_DSM_FREQ_UNSPEC = 0,
	NVME_RW_DSM_FREQ_TYPICAL = 1,
	NVME_RW_DSM_FREQ_RARE = 2,
	NVME_RW_DSM_FREQ_READS = 3,
	NVME_RW_DSM_FREQ_WRITES = 4,
	NVME_RW_DSM_FREQ_RW = 5,
	NVME_RW_DSM_FREQ_ONCE = 6,
	NVME_RW_DSM_FREQ_PREFETCH = 7,
	NVME_RW_DSM_FREQ_TEMP = 8,
	NVME_RW_DSM_LATENCY_NONE = 0,
	NVME_RW_DSM_LATENCY_IDLE = 16,
	NVME_RW_DSM_LATENCY_NORM = 32,
	NVME_RW_DSM_LATENCY_LOW = 48,
	NVME_RW_DSM_SEQ_REQ = 64,
	NVME_RW_DSM_COMPRESSED = 128,
	NVME_RW_PRINFO_PRCHK_REF = 1024,
	NVME_RW_PRINFO_PRCHK_APP = 2048,
	NVME_RW_PRINFO_PRCHK_GUARD = 4096,
	NVME_RW_PRINFO_PRACT = 8192,
	NVME_RW_DTYPE_STREAMS = 16,
};

struct nvme_dsm_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le32 nr;
	__le32 attributes;
	__u32 rsvd12[4];
};

enum {
	NVME_DSMGMT_IDR = 1,
	NVME_DSMGMT_IDW = 2,
	NVME_DSMGMT_AD = 4,
};

struct nvme_dsm_range {
	__le32 cattr;
	__le32 nlb;
	__le64 slba;
};

struct nvme_write_zeroes_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2;
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le64 slba;
	__le16 length;
	__le16 control;
	__le32 dsmgmt;
	__le32 reftag;
	__le16 apptag;
	__le16 appmask;
};

enum nvme_zone_mgmt_action {
	NVME_ZONE_CLOSE = 1,
	NVME_ZONE_FINISH = 2,
	NVME_ZONE_OPEN = 3,
	NVME_ZONE_RESET = 4,
	NVME_ZONE_OFFLINE = 5,
	NVME_ZONE_SET_DESC_EXT = 16,
};

struct nvme_zone_mgmt_send_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le32 cdw2[2];
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le64 slba;
	__le32 cdw12;
	__u8 zsa;
	__u8 select_all;
	__u8 rsvd13[2];
	__le32 cdw14[2];
};

struct nvme_zone_mgmt_recv_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le64 slba;
	__le32 numd;
	__u8 zra;
	__u8 zrasf;
	__u8 pr;
	__u8 rsvd13;
	__le32 cdw14[2];
};

struct nvme_feat_auto_pst {
	__le64 entries[32];
};

struct nvme_feat_host_behavior {
	__u8 acre;
	__u8 resv1[511];
};

enum {
	NVME_ENABLE_ACRE = 1,
};

enum nvme_admin_opcode {
	nvme_admin_delete_sq = 0,
	nvme_admin_create_sq = 1,
	nvme_admin_get_log_page = 2,
	nvme_admin_delete_cq = 4,
	nvme_admin_create_cq = 5,
	nvme_admin_identify = 6,
	nvme_admin_abort_cmd = 8,
	nvme_admin_set_features = 9,
	nvme_admin_get_features = 10,
	nvme_admin_async_event = 12,
	nvme_admin_ns_mgmt = 13,
	nvme_admin_activate_fw = 16,
	nvme_admin_download_fw = 17,
	nvme_admin_dev_self_test = 20,
	nvme_admin_ns_attach = 21,
	nvme_admin_keep_alive = 24,
	nvme_admin_directive_send = 25,
	nvme_admin_directive_recv = 26,
	nvme_admin_virtual_mgmt = 28,
	nvme_admin_nvme_mi_send = 29,
	nvme_admin_nvme_mi_recv = 30,
	nvme_admin_dbbuf = 124,
	nvme_admin_format_nvm = 128,
	nvme_admin_security_send = 129,
	nvme_admin_security_recv = 130,
	nvme_admin_sanitize_nvm = 132,
	nvme_admin_get_lba_status = 134,
	nvme_admin_vendor_start = 192,
};

enum {
	NVME_QUEUE_PHYS_CONTIG = 1,
	NVME_CQ_IRQ_ENABLED = 2,
	NVME_SQ_PRIO_URGENT = 0,
	NVME_SQ_PRIO_HIGH = 2,
	NVME_SQ_PRIO_MEDIUM = 4,
	NVME_SQ_PRIO_LOW = 6,
	NVME_FEAT_ARBITRATION = 1,
	NVME_FEAT_POWER_MGMT = 2,
	NVME_FEAT_LBA_RANGE = 3,
	NVME_FEAT_TEMP_THRESH = 4,
	NVME_FEAT_ERR_RECOVERY = 5,
	NVME_FEAT_VOLATILE_WC = 6,
	NVME_FEAT_NUM_QUEUES = 7,
	NVME_FEAT_IRQ_COALESCE = 8,
	NVME_FEAT_IRQ_CONFIG = 9,
	NVME_FEAT_WRITE_ATOMIC = 10,
	NVME_FEAT_ASYNC_EVENT = 11,
	NVME_FEAT_AUTO_PST = 12,
	NVME_FEAT_HOST_MEM_BUF = 13,
	NVME_FEAT_TIMESTAMP = 14,
	NVME_FEAT_KATO = 15,
	NVME_FEAT_HCTM = 16,
	NVME_FEAT_NOPSC = 17,
	NVME_FEAT_RRL = 18,
	NVME_FEAT_PLM_CONFIG = 19,
	NVME_FEAT_PLM_WINDOW = 20,
	NVME_FEAT_HOST_BEHAVIOR = 22,
	NVME_FEAT_SANITIZE = 23,
	NVME_FEAT_SW_PROGRESS = 128,
	NVME_FEAT_HOST_ID = 129,
	NVME_FEAT_RESV_MASK = 130,
	NVME_FEAT_RESV_PERSIST = 131,
	NVME_FEAT_WRITE_PROTECT = 132,
	NVME_FEAT_VENDOR_START = 192,
	NVME_FEAT_VENDOR_END = 255,
	NVME_LOG_ERROR = 1,
	NVME_LOG_SMART = 2,
	NVME_LOG_FW_SLOT = 3,
	NVME_LOG_CHANGED_NS = 4,
	NVME_LOG_CMD_EFFECTS = 5,
	NVME_LOG_DEVICE_SELF_TEST = 6,
	NVME_LOG_TELEMETRY_HOST = 7,
	NVME_LOG_TELEMETRY_CTRL = 8,
	NVME_LOG_ENDURANCE_GROUP = 9,
	NVME_LOG_ANA = 12,
	NVME_LOG_DISC = 112,
	NVME_LOG_RESERVATION = 128,
	NVME_FWACT_REPL = 0,
	NVME_FWACT_REPL_ACTV = 8,
	NVME_FWACT_ACTV = 16,
};

struct nvme_identify {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__u8 cns;
	__u8 rsvd3;
	__le16 ctrlid;
	__u8 rsvd11[3];
	__u8 csi;
	__u32 rsvd12[4];
};

struct nvme_features {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le32 fid;
	__le32 dword11;
	__le32 dword12;
	__le32 dword13;
	__le32 dword14;
	__le32 dword15;
};

struct nvme_create_cq {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	__le64 prp1;
	__u64 rsvd8;
	__le16 cqid;
	__le16 qsize;
	__le16 cq_flags;
	__le16 irq_vector;
	__u32 rsvd12[4];
};

struct nvme_create_sq {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	__le64 prp1;
	__u64 rsvd8;
	__le16 sqid;
	__le16 qsize;
	__le16 sq_flags;
	__le16 cqid;
	__u32 rsvd12[4];
};

struct nvme_delete_queue {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[9];
	__le16 qid;
	__u16 rsvd10;
	__u32 rsvd11[5];
};

struct nvme_abort_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[9];
	__le16 sqid;
	__u16 cid;
	__u32 rsvd11[5];
};

struct nvme_download_firmware {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	union nvme_data_ptr dptr;
	__le32 numd;
	__le32 offset;
	__u32 rsvd12[4];
};

struct nvme_format_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[4];
	__le32 cdw10;
	__u32 rsvd11[5];
};

struct nvme_get_log_page_command {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__u8 lid;
	__u8 lsp;
	__le16 numdl;
	__le16 numdu;
	__u16 rsvd11;
	union {
		struct {
			__le32 lpol;
			__le32 lpou;
		};
		__le64 lpo;
	};
	__u8 rsvd14[3];
	__u8 csi;
	__u32 rsvd15;
};

struct nvme_directive_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le32 numd;
	__u8 doper;
	__u8 dtype;
	__le16 dspec;
	__u8 endir;
	__u8 tdtype;
	__u16 rsvd15;
	__u32 rsvd16[3];
};

enum nvmf_fabrics_opcode {
	nvme_fabrics_command = 127,
};

enum nvmf_capsule_command {
	nvme_fabrics_type_property_set = 0,
	nvme_fabrics_type_connect = 1,
	nvme_fabrics_type_property_get = 4,
};

struct nvmf_common_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[35];
	__u8 ts[24];
};

struct nvmf_connect_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[19];
	union nvme_data_ptr dptr;
	__le16 recfmt;
	__le16 qid;
	__le16 sqsize;
	__u8 cattr;
	__u8 resv3;
	__le32 kato;
	__u8 resv4[12];
};

struct nvmf_property_set_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[35];
	__u8 attrib;
	__u8 resv3[3];
	__le32 offset;
	__le64 value;
	__u8 resv4[8];
};

struct nvmf_property_get_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[35];
	__u8 attrib;
	__u8 resv3[3];
	__le32 offset;
	__u8 resv4[16];
};

struct nvme_dbbuf {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	__le64 prp1;
	__le64 prp2;
	__u32 rsvd12[6];
};

struct streams_directive_params {
	__le16 msl;
	__le16 nssa;
	__le16 nsso;
	__u8 rsvd[10];
	__le32 sws;
	__le16 sgs;
	__le16 nsa;
	__le16 nso;
	__u8 rsvd2[6];
};

struct nvme_command {
	union {
		struct nvme_common_command common;
		struct nvme_rw_command rw;
		struct nvme_identify identify;
		struct nvme_features features;
		struct nvme_create_cq create_cq;
		struct nvme_create_sq create_sq;
		struct nvme_delete_queue delete_queue;
		struct nvme_download_firmware dlfw;
		struct nvme_format_cmd format;
		struct nvme_dsm_cmd dsm;
		struct nvme_write_zeroes_cmd write_zeroes;
		struct nvme_zone_mgmt_send_cmd zms;
		struct nvme_zone_mgmt_recv_cmd zmr;
		struct nvme_abort_cmd abort;
		struct nvme_get_log_page_command get_log_page;
		struct nvmf_common_command fabrics;
		struct nvmf_connect_command connect;
		struct nvmf_property_set_command prop_set;
		struct nvmf_property_get_command prop_get;
		struct nvme_dbbuf dbbuf;
		struct nvme_directive_cmd directive;
	};
};

enum {
	NVME_SC_SUCCESS = 0,
	NVME_SC_INVALID_OPCODE = 1,
	NVME_SC_INVALID_FIELD = 2,
	NVME_SC_CMDID_CONFLICT = 3,
	NVME_SC_DATA_XFER_ERROR = 4,
	NVME_SC_POWER_LOSS = 5,
	NVME_SC_INTERNAL = 6,
	NVME_SC_ABORT_REQ = 7,
	NVME_SC_ABORT_QUEUE = 8,
	NVME_SC_FUSED_FAIL = 9,
	NVME_SC_FUSED_MISSING = 10,
	NVME_SC_INVALID_NS = 11,
	NVME_SC_CMD_SEQ_ERROR = 12,
	NVME_SC_SGL_INVALID_LAST = 13,
	NVME_SC_SGL_INVALID_COUNT = 14,
	NVME_SC_SGL_INVALID_DATA = 15,
	NVME_SC_SGL_INVALID_METADATA = 16,
	NVME_SC_SGL_INVALID_TYPE = 17,
	NVME_SC_CMB_INVALID_USE = 18,
	NVME_SC_PRP_INVALID_OFFSET = 19,
	NVME_SC_ATOMIC_WU_EXCEEDED = 20,
	NVME_SC_OP_DENIED = 21,
	NVME_SC_SGL_INVALID_OFFSET = 22,
	NVME_SC_RESERVED = 23,
	NVME_SC_HOST_ID_INCONSIST = 24,
	NVME_SC_KA_TIMEOUT_EXPIRED = 25,
	NVME_SC_KA_TIMEOUT_INVALID = 26,
	NVME_SC_ABORTED_PREEMPT_ABORT = 27,
	NVME_SC_SANITIZE_FAILED = 28,
	NVME_SC_SANITIZE_IN_PROGRESS = 29,
	NVME_SC_SGL_INVALID_GRANULARITY = 30,
	NVME_SC_CMD_NOT_SUP_CMB_QUEUE = 31,
	NVME_SC_NS_WRITE_PROTECTED = 32,
	NVME_SC_CMD_INTERRUPTED = 33,
	NVME_SC_TRANSIENT_TR_ERR = 34,
	NVME_SC_LBA_RANGE = 128,
	NVME_SC_CAP_EXCEEDED = 129,
	NVME_SC_NS_NOT_READY = 130,
	NVME_SC_RESERVATION_CONFLICT = 131,
	NVME_SC_FORMAT_IN_PROGRESS = 132,
	NVME_SC_CQ_INVALID = 256,
	NVME_SC_QID_INVALID = 257,
	NVME_SC_QUEUE_SIZE = 258,
	NVME_SC_ABORT_LIMIT = 259,
	NVME_SC_ABORT_MISSING = 260,
	NVME_SC_ASYNC_LIMIT = 261,
	NVME_SC_FIRMWARE_SLOT = 262,
	NVME_SC_FIRMWARE_IMAGE = 263,
	NVME_SC_INVALID_VECTOR = 264,
	NVME_SC_INVALID_LOG_PAGE = 265,
	NVME_SC_INVALID_FORMAT = 266,
	NVME_SC_FW_NEEDS_CONV_RESET = 267,
	NVME_SC_INVALID_QUEUE = 268,
	NVME_SC_FEATURE_NOT_SAVEABLE = 269,
	NVME_SC_FEATURE_NOT_CHANGEABLE = 270,
	NVME_SC_FEATURE_NOT_PER_NS = 271,
	NVME_SC_FW_NEEDS_SUBSYS_RESET = 272,
	NVME_SC_FW_NEEDS_RESET = 273,
	NVME_SC_FW_NEEDS_MAX_TIME = 274,
	NVME_SC_FW_ACTIVATE_PROHIBITED = 275,
	NVME_SC_OVERLAPPING_RANGE = 276,
	NVME_SC_NS_INSUFFICIENT_CAP = 277,
	NVME_SC_NS_ID_UNAVAILABLE = 278,
	NVME_SC_NS_ALREADY_ATTACHED = 280,
	NVME_SC_NS_IS_PRIVATE = 281,
	NVME_SC_NS_NOT_ATTACHED = 282,
	NVME_SC_THIN_PROV_NOT_SUPP = 283,
	NVME_SC_CTRL_LIST_INVALID = 284,
	NVME_SC_SELT_TEST_IN_PROGRESS = 285,
	NVME_SC_BP_WRITE_PROHIBITED = 286,
	NVME_SC_CTRL_ID_INVALID = 287,
	NVME_SC_SEC_CTRL_STATE_INVALID = 288,
	NVME_SC_CTRL_RES_NUM_INVALID = 289,
	NVME_SC_RES_ID_INVALID = 290,
	NVME_SC_PMR_SAN_PROHIBITED = 291,
	NVME_SC_ANA_GROUP_ID_INVALID = 292,
	NVME_SC_ANA_ATTACH_FAILED = 293,
	NVME_SC_BAD_ATTRIBUTES = 384,
	NVME_SC_INVALID_PI = 385,
	NVME_SC_READ_ONLY = 386,
	NVME_SC_ONCS_NOT_SUPPORTED = 387,
	NVME_SC_CONNECT_FORMAT = 384,
	NVME_SC_CONNECT_CTRL_BUSY = 385,
	NVME_SC_CONNECT_INVALID_PARAM = 386,
	NVME_SC_CONNECT_RESTART_DISC = 387,
	NVME_SC_CONNECT_INVALID_HOST = 388,
	NVME_SC_DISCOVERY_RESTART = 400,
	NVME_SC_AUTH_REQUIRED = 401,
	NVME_SC_ZONE_BOUNDARY_ERROR = 440,
	NVME_SC_ZONE_FULL = 441,
	NVME_SC_ZONE_READ_ONLY = 442,
	NVME_SC_ZONE_OFFLINE = 443,
	NVME_SC_ZONE_INVALID_WRITE = 444,
	NVME_SC_ZONE_TOO_MANY_ACTIVE = 445,
	NVME_SC_ZONE_TOO_MANY_OPEN = 446,
	NVME_SC_ZONE_INVALID_TRANSITION = 447,
	NVME_SC_WRITE_FAULT = 640,
	NVME_SC_READ_ERROR = 641,
	NVME_SC_GUARD_CHECK = 642,
	NVME_SC_APPTAG_CHECK = 643,
	NVME_SC_REFTAG_CHECK = 644,
	NVME_SC_COMPARE_FAILED = 645,
	NVME_SC_ACCESS_DENIED = 646,
	NVME_SC_UNWRITTEN_BLOCK = 647,
	NVME_SC_ANA_PERSISTENT_LOSS = 769,
	NVME_SC_ANA_INACCESSIBLE = 770,
	NVME_SC_ANA_TRANSITION = 771,
	NVME_SC_HOST_PATH_ERROR = 880,
	NVME_SC_HOST_ABORTED_CMD = 881,
	NVME_SC_CRD = 6144,
	NVME_SC_DNR = 16384,
};

union nvme_result {
	__le16 u16;
	__le32 u32;
	__le64 u64;
};

enum nvme_quirks {
	NVME_QUIRK_STRIPE_SIZE = 1,
	NVME_QUIRK_IDENTIFY_CNS = 2,
	NVME_QUIRK_DEALLOCATE_ZEROES = 4,
	NVME_QUIRK_DELAY_BEFORE_CHK_RDY = 8,
	NVME_QUIRK_NO_APST = 16,
	NVME_QUIRK_NO_DEEPEST_PS = 32,
	NVME_QUIRK_LIGHTNVM = 64,
	NVME_QUIRK_MEDIUM_PRIO_SQ = 128,
	NVME_QUIRK_IGNORE_DEV_SUBNQN = 256,
	NVME_QUIRK_DISABLE_WRITE_ZEROES = 512,
	NVME_QUIRK_SIMPLE_SUSPEND = 1024,
	NVME_QUIRK_SINGLE_VECTOR = 2048,
	NVME_QUIRK_128_BYTES_SQES = 4096,
	NVME_QUIRK_SHARED_TAGS = 8192,
	NVME_QUIRK_NO_TEMP_THRESH_CHANGE = 16384,
	NVME_QUIRK_NO_NS_DESC_LIST = 32768,
	NVME_QUIRK_DMA_ADDRESS_BITS_48 = 65536,
	NVME_QUIRK_SKIP_CID_GEN = 131072,
};

struct nvme_ctrl;

struct nvme_request {
	struct nvme_command *cmd;
	union nvme_result result;
	u8 genctr;
	u8 retries;
	u8 flags;
	u16 status;
	struct nvme_ctrl *ctrl;
};

enum nvme_ctrl_state {
	NVME_CTRL_NEW = 0,
	NVME_CTRL_LIVE = 1,
	NVME_CTRL_RESETTING = 2,
	NVME_CTRL_CONNECTING = 3,
	NVME_CTRL_DELETING = 4,
	NVME_CTRL_DELETING_NOIO = 5,
	NVME_CTRL_DEAD = 6,
};

struct nvme_fault_inject {};

struct nvme_ctrl_ops;

struct nvme_subsystem;

struct nvmf_ctrl_options;

struct nvme_ctrl {
	bool comp_seen;
	enum nvme_ctrl_state state;
	bool identified;
	spinlock_t lock;
	struct mutex scan_lock;
	const struct nvme_ctrl_ops *ops;
	struct request_queue *admin_q;
	struct request_queue *connect_q;
	struct request_queue *fabrics_q;
	struct device *dev;
	int instance;
	int numa_node;
	struct blk_mq_tag_set *tagset;
	struct blk_mq_tag_set *admin_tagset;
	struct list_head namespaces;
	struct rw_semaphore namespaces_rwsem;
	struct device ctrl_device;
	struct device *device;
	struct device *hwmon_device;
	struct cdev cdev;
	struct work_struct reset_work;
	struct work_struct delete_work;
	wait_queue_head_t state_wq;
	struct nvme_subsystem *subsys;
	struct list_head subsys_entry;
	struct opal_dev___2 *opal_dev;
	char name[12];
	u16 cntlid;
	u32 ctrl_config;
	u16 mtfa;
	u32 queue_count;
	u64 cap;
	u32 max_hw_sectors;
	u32 max_segments;
	u32 max_integrity_segments;
	u32 max_discard_sectors;
	u32 max_discard_segments;
	u32 max_zeroes_sectors;
	u32 max_zone_append;
	u16 crdt[3];
	u16 oncs;
	u16 oacs;
	u16 nssa;
	u16 nr_streams;
	u16 sqsize;
	u32 max_namespaces;
	atomic_t abort_limit;
	u8 vwc;
	u32 vs;
	u32 sgls;
	u16 kas;
	u8 npss;
	u8 apsta;
	u16 wctemp;
	u16 cctemp;
	u32 oaes;
	u32 aen_result;
	u32 ctratt;
	unsigned int shutdown_timeout;
	unsigned int kato;
	bool subsystem;
	long unsigned int quirks;
	struct nvme_id_power_state psd[32];
	struct nvme_effects_log *effects;
	struct xarray cels;
	struct work_struct scan_work;
	struct work_struct async_event_work;
	struct delayed_work ka_work;
	struct delayed_work failfast_work;
	struct nvme_command ka_cmd;
	struct work_struct fw_act_work;
	long unsigned int events;
	u8 anacap;
	u8 anatt;
	u32 anagrpmax;
	u32 nanagrpid;
	struct mutex ana_lock;
	struct nvme_ana_rsp_hdr *ana_log_buf;
	size_t ana_log_size;
	struct timer_list anatt_timer;
	struct work_struct ana_work;
	u64 ps_max_latency_us;
	bool apst_enabled;
	u32 hmpre;
	u32 hmmin;
	u32 hmminds;
	u16 hmmaxd;
	u32 ioccsz;
	u32 iorcsz;
	u16 icdoff;
	u16 maxcmd;
	int nr_reconnects;
	long unsigned int flags;
	struct nvmf_ctrl_options *opts;
	struct page *discard_page;
	long unsigned int discard_page_busy;
	struct nvme_fault_inject fault_inject;
};

enum {
	NVME_REQ_CANCELLED = 1,
	NVME_REQ_USERCMD = 2,
};

struct nvme_ctrl_ops {
	const char *name;
	struct module *module;
	unsigned int flags;
	int (*reg_read32)(struct nvme_ctrl *, u32, u32 *);
	int (*reg_write32)(struct nvme_ctrl *, u32, u32);
	int (*reg_read64)(struct nvme_ctrl *, u32, u64 *);
	void (*free_ctrl)(struct nvme_ctrl *);
	void (*submit_async_event)(struct nvme_ctrl *);
	void (*delete_ctrl)(struct nvme_ctrl *);
	int (*get_address)(struct nvme_ctrl *, char *, int);
};

enum nvme_iopolicy {
	NVME_IOPOLICY_NUMA = 0,
	NVME_IOPOLICY_RR = 1,
};

struct nvme_subsystem {
	int instance;
	struct device dev;
	struct kref ref;
	struct list_head entry;
	struct mutex lock;
	struct list_head ctrls;
	struct list_head nsheads;
	char subnqn[223];
	char serial[20];
	char model[40];
	char firmware_rev[8];
	u8 cmic;
	u16 vendor_id;
	u16 awupf;
	struct ida ns_ida;
	enum nvme_iopolicy iopolicy;
};

struct nvmf_host;

struct nvmf_ctrl_options {
	unsigned int mask;
	char *transport;
	char *subsysnqn;
	char *traddr;
	char *trsvcid;
	char *host_traddr;
	size_t queue_size;
	unsigned int nr_io_queues;
	unsigned int reconnect_delay;
	bool discovery_nqn;
	bool duplicate_connect;
	unsigned int kato;
	struct nvmf_host *host;
	int max_reconnects;
	bool disable_sqflow;
	bool hdr_digest;
	bool data_digest;
	unsigned int nr_write_queues;
	unsigned int nr_poll_queues;
	int tos;
	int fast_io_fail_tmo;
};

struct nvme_ns_ids {
	u8 eui64[8];
	u8 nguid[16];
	uuid_t uuid;
	u8 csi;
};

struct nvme_ns;

struct nvme_ns_head {
	struct list_head list;
	struct srcu_struct srcu;
	struct nvme_subsystem *subsys;
	unsigned int ns_id;
	struct nvme_ns_ids ids;
	struct list_head entry;
	struct kref ref;
	bool shared;
	int instance;
	struct nvme_effects_log *effects;
	struct cdev cdev;
	struct device cdev_device;
	struct gendisk *disk;
	struct bio_list requeue_list;
	spinlock_t requeue_lock;
	struct work_struct requeue_work;
	struct mutex lock;
	long unsigned int flags;
	struct nvme_ns *current_path[0];
};

struct nvme_ns {
	struct list_head list;
	struct nvme_ctrl *ctrl;
	struct request_queue *queue;
	struct gendisk *disk;
	enum nvme_ana_state ana_state;
	u32 ana_grpid;
	struct list_head siblings;
	struct nvm_dev *ndev;
	struct kref kref;
	struct nvme_ns_head *head;
	int lba_shift;
	u16 ms;
	u16 sgs;
	u32 sws;
	u8 pi_type;
	u64 zsze;
	long unsigned int features;
	long unsigned int flags;
	struct cdev cdev;
	struct device cdev_device;
	struct nvme_fault_inject fault_inject;
};

enum nvme_ns_features {
	NVME_NS_EXT_LBAS = 1,
	NVME_NS_METADATA_SUPPORTED = 2,
};

struct nvmf_host {
	struct kref ref;
	struct list_head list;
	char nqn[223];
	uuid_t id;
};

struct trace_event_raw_nvme_setup_cmd {
	struct trace_entry ent;
	char disk[32];
	int ctrl_id;
	int qid;
	u8 opcode;
	u8 flags;
	u8 fctype;
	u16 cid;
	u32 nsid;
	bool metadata;
	u8 cdw10[24];
	char __data[0];
};

struct trace_event_raw_nvme_complete_rq {
	struct trace_entry ent;
	char disk[32];
	int ctrl_id;
	int qid;
	int cid;
	u64 result;
	u8 retries;
	u8 flags;
	u16 status;
	char __data[0];
};

struct trace_event_raw_nvme_async_event {
	struct trace_entry ent;
	int ctrl_id;
	u32 result;
	char __data[0];
};

struct trace_event_raw_nvme_sq {
	struct trace_entry ent;
	int ctrl_id;
	char disk[32];
	int qid;
	u16 sq_head;
	u16 sq_tail;
	char __data[0];
};

struct trace_event_data_offsets_nvme_setup_cmd {};

struct trace_event_data_offsets_nvme_complete_rq {};

struct trace_event_data_offsets_nvme_async_event {};

struct trace_event_data_offsets_nvme_sq {};

typedef void (*btf_trace_nvme_setup_cmd)(void *, struct request *, struct nvme_command *);

typedef void (*btf_trace_nvme_complete_rq)(void *, struct request *);

typedef void (*btf_trace_nvme_async_event)(void *, struct nvme_ctrl *, u32);

typedef void (*btf_trace_nvme_sq)(void *, struct request *, __le16, int);

enum nvme_disposition {
	COMPLETE = 0,
	RETRY = 1,
	FAILOVER = 2,
};

struct nvme_core_quirk_entry {
	u16 vid;
	const char *mn;
	const char *fr;
	long unsigned int quirks;
};

struct nvme_user_io {
	__u8 opcode;
	__u8 flags;
	__u16 control;
	__u16 nblocks;
	__u16 rsvd;
	__u64 metadata;
	__u64 addr;
	__u64 slba;
	__u32 dsmgmt;
	__u32 reftag;
	__u16 apptag;
	__u16 appmask;
};

struct nvme_passthru_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 rsvd1;
	__u32 nsid;
	__u32 cdw2;
	__u32 cdw3;
	__u64 metadata;
	__u64 addr;
	__u32 metadata_len;
	__u32 data_len;
	__u32 cdw10;
	__u32 cdw11;
	__u32 cdw12;
	__u32 cdw13;
	__u32 cdw14;
	__u32 cdw15;
	__u32 timeout_ms;
	__u32 result;
};

struct nvme_passthru_cmd64 {
	__u8 opcode;
	__u8 flags;
	__u16 rsvd1;
	__u32 nsid;
	__u32 cdw2;
	__u32 cdw3;
	__u64 metadata;
	__u64 addr;
	__u32 metadata_len;
	__u32 data_len;
	__u32 cdw10;
	__u32 cdw11;
	__u32 cdw12;
	__u32 cdw13;
	__u32 cdw14;
	__u32 cdw15;
	__u32 timeout_ms;
	__u32 rsvd2;
	__u64 result;
};

struct nvme_ana_group_desc {
	__le32 grpid;
	__le32 nnsids;
	__le64 chgcnt;
	__u8 state;
	__u8 rsvd17[15];
	__le32 nsids[0];
};

struct nvm_user_vio {
	__u8 opcode;
	__u8 flags;
	__u16 control;
	__u16 nppas;
	__u16 rsvd;
	__u64 metadata;
	__u64 addr;
	__u64 ppa_list;
	__u32 metadata_len;
	__u32 data_len;
	__u64 status;
	__u32 result;
	__u32 rsvd3[3];
};

struct nvm_passthru_vio {
	__u8 opcode;
	__u8 flags;
	__u8 rsvd[2];
	__u32 nsid;
	__u32 cdw2;
	__u32 cdw3;
	__u64 metadata;
	__u64 addr;
	__u32 metadata_len;
	__u32 data_len;
	__u64 ppa_list;
	__u16 nppas;
	__u16 control;
	__u32 cdw13;
	__u32 cdw14;
	__u32 cdw15;
	__u64 status;
	__u32 result;
	__u32 timeout_ms;
};

enum nvme_nvm_admin_opcode {
	nvme_nvm_admin_identity = 226,
	nvme_nvm_admin_get_bb_tbl = 242,
	nvme_nvm_admin_set_bb_tbl = 241,
};

enum nvme_nvm_log_page {
	NVME_NVM_LOG_REPORT_CHUNK = 202,
};

struct nvme_nvm_ph_rw {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2;
	__le64 metadata;
	__le64 prp1;
	__le64 prp2;
	__le64 spba;
	__le16 length;
	__le16 control;
	__le32 dsmgmt;
	__le64 resv;
};

struct nvme_nvm_erase_blk {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd[2];
	__le64 prp1;
	__le64 prp2;
	__le64 spba;
	__le16 length;
	__le16 control;
	__le32 dsmgmt;
	__le64 resv;
};

struct nvme_nvm_identity {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd[2];
	__le64 prp1;
	__le64 prp2;
	__u32 rsvd11[6];
};

struct nvme_nvm_getbbtbl {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd[2];
	__le64 prp1;
	__le64 prp2;
	__le64 spba;
	__u32 rsvd4[4];
};

struct nvme_nvm_setbbtbl {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le64 rsvd[2];
	__le64 prp1;
	__le64 prp2;
	__le64 spba;
	__le16 nlb;
	__u8 value;
	__u8 rsvd3;
	__u32 rsvd4[3];
};

struct nvme_nvm_command {
	union {
		struct nvme_common_command common;
		struct nvme_nvm_ph_rw ph_rw;
		struct nvme_nvm_erase_blk erase;
		struct nvme_nvm_identity identity;
		struct nvme_nvm_getbbtbl get_bb;
		struct nvme_nvm_setbbtbl set_bb;
	};
};

struct nvme_nvm_id12_grp {
	__u8 mtype;
	__u8 fmtype;
	__le16 res16;
	__u8 num_ch;
	__u8 num_lun;
	__u8 num_pln;
	__u8 rsvd1;
	__le16 num_chk;
	__le16 num_pg;
	__le16 fpg_sz;
	__le16 csecs;
	__le16 sos;
	__le16 rsvd2;
	__le32 trdt;
	__le32 trdm;
	__le32 tprt;
	__le32 tprm;
	__le32 tbet;
	__le32 tbem;
	__le32 mpos;
	__le32 mccap;
	__le16 cpar;
	__u8 reserved[906];
};

struct nvme_nvm_id12_addrf {
	__u8 ch_offset;
	__u8 ch_len;
	__u8 lun_offset;
	__u8 lun_len;
	__u8 pln_offset;
	__u8 pln_len;
	__u8 blk_offset;
	__u8 blk_len;
	__u8 pg_offset;
	__u8 pg_len;
	__u8 sec_offset;
	__u8 sec_len;
	__u8 res[4];
};

struct nvme_nvm_id12 {
	__u8 ver_id;
	__u8 vmnt;
	__u8 cgrps;
	__u8 res;
	__le32 cap;
	__le32 dom;
	struct nvme_nvm_id12_addrf ppaf;
	__u8 resv[228];
	struct nvme_nvm_id12_grp grp;
	__u8 resv2[2880];
};

struct nvme_nvm_bb_tbl {
	__u8 tblid[4];
	__le16 verid;
	__le16 revid;
	__le32 rvsd1;
	__le32 tblks;
	__le32 tfact;
	__le32 tgrown;
	__le32 tdresv;
	__le32 thresv;
	__le32 rsvd2[8];
	__u8 blk[0];
};

struct nvme_nvm_id20_addrf {
	__u8 grp_len;
	__u8 pu_len;
	__u8 chk_len;
	__u8 lba_len;
	__u8 resv[4];
};

struct nvme_nvm_id20 {
	__u8 mjr;
	__u8 mnr;
	__u8 resv[6];
	struct nvme_nvm_id20_addrf lbaf;
	__le32 mccap;
	__u8 resv2[12];
	__u8 wit;
	__u8 resv3[31];
	__le16 num_grp;
	__le16 num_pu;
	__le32 num_chk;
	__le32 clba;
	__u8 resv4[52];
	__le32 ws_min;
	__le32 ws_opt;
	__le32 mw_cunits;
	__le32 maxoc;
	__le32 maxocpu;
	__u8 resv5[44];
	__le32 trdt;
	__le32 trdm;
	__le32 twrt;
	__le32 twrm;
	__le32 tcrst;
	__le32 tcrsm;
	__u8 resv6[40];
	__u8 resv7[2816];
	__u8 vs[1024];
};

struct nvme_nvm_chk_meta {
	__u8 state;
	__u8 type;
	__u8 wi;
	__u8 rsvd[5];
	__le64 slba;
	__le64 cnlb;
	__le64 wp;
};

struct nvme_zns_lbafe {
	__le64 zsze;
	__u8 zdes;
	__u8 rsvd9[7];
};

struct nvme_id_ns_zns {
	__le16 zoc;
	__le16 ozcs;
	__le32 mar;
	__le32 mor;
	__le32 rrl;
	__le32 frl;
	__u8 rsvd20[2796];
	struct nvme_zns_lbafe lbafe[16];
	__u8 rsvd3072[768];
	__u8 vs[256];
};

struct nvme_id_ctrl_zns {
	__u8 zasl;
	__u8 rsvd1[4095];
};

struct nvme_zone_descriptor {
	__u8 zt;
	__u8 zs;
	__u8 za;
	__u8 rsvd3[5];
	__le64 zcap;
	__le64 zslba;
	__le64 wp;
	__u8 rsvd32[32];
};

enum {
	NVME_ZONE_TYPE_SEQWRITE_REQ = 2,
};

struct nvme_zone_report {
	__le64 nr_zones;
	__u8 resv8[56];
	struct nvme_zone_descriptor entries[0];
};

enum {
	NVME_ZRA_ZONE_REPORT = 0,
	NVME_ZRASF_ZONE_REPORT_ALL = 0,
	NVME_REPORT_ZONE_PARTIAL = 1,
};

enum hwmon_sensor_types {
	hwmon_chip = 0,
	hwmon_temp = 1,
	hwmon_in = 2,
	hwmon_curr = 3,
	hwmon_power = 4,
	hwmon_energy = 5,
	hwmon_humidity = 6,
	hwmon_fan = 7,
	hwmon_pwm = 8,
	hwmon_intrusion = 9,
	hwmon_max = 10,
};

enum hwmon_chip_attributes {
	hwmon_chip_temp_reset_history = 0,
	hwmon_chip_in_reset_history = 1,
	hwmon_chip_curr_reset_history = 2,
	hwmon_chip_power_reset_history = 3,
	hwmon_chip_register_tz = 4,
	hwmon_chip_update_interval = 5,
	hwmon_chip_alarms = 6,
	hwmon_chip_samples = 7,
	hwmon_chip_curr_samples = 8,
	hwmon_chip_in_samples = 9,
	hwmon_chip_power_samples = 10,
	hwmon_chip_temp_samples = 11,
};

enum hwmon_temp_attributes {
	hwmon_temp_enable = 0,
	hwmon_temp_input = 1,
	hwmon_temp_type = 2,
	hwmon_temp_lcrit = 3,
	hwmon_temp_lcrit_hyst = 4,
	hwmon_temp_min = 5,
	hwmon_temp_min_hyst = 6,
	hwmon_temp_max = 7,
	hwmon_temp_max_hyst = 8,
	hwmon_temp_crit = 9,
	hwmon_temp_crit_hyst = 10,
	hwmon_temp_emergency = 11,
	hwmon_temp_emergency_hyst = 12,
	hwmon_temp_alarm = 13,
	hwmon_temp_lcrit_alarm = 14,
	hwmon_temp_min_alarm = 15,
	hwmon_temp_max_alarm = 16,
	hwmon_temp_crit_alarm = 17,
	hwmon_temp_emergency_alarm = 18,
	hwmon_temp_fault = 19,
	hwmon_temp_offset = 20,
	hwmon_temp_label = 21,
	hwmon_temp_lowest = 22,
	hwmon_temp_highest = 23,
	hwmon_temp_reset_history = 24,
	hwmon_temp_rated_min = 25,
	hwmon_temp_rated_max = 26,
};

struct hwmon_ops {
	umode_t (*is_visible)(const void *, enum hwmon_sensor_types, u32, int);
	int (*read)(struct device *, enum hwmon_sensor_types, u32, int, long int *);
	int (*read_string)(struct device *, enum hwmon_sensor_types, u32, int, const char **);
	int (*write)(struct device *, enum hwmon_sensor_types, u32, int, long int);
};

struct hwmon_channel_info {
	enum hwmon_sensor_types type;
	const u32 *config;
};

struct hwmon_chip_info {
	const struct hwmon_ops *ops;
	const struct hwmon_channel_info **info;
};

struct nvme_smart_log {
	__u8 critical_warning;
	__u8 temperature[2];
	__u8 avail_spare;
	__u8 spare_thresh;
	__u8 percent_used;
	__u8 endu_grp_crit_warn_sumry;
	__u8 rsvd7[25];
	__u8 data_units_read[16];
	__u8 data_units_written[16];
	__u8 host_reads[16];
	__u8 host_writes[16];
	__u8 ctrl_busy_time[16];
	__u8 power_cycles[16];
	__u8 power_on_hours[16];
	__u8 unsafe_shutdowns[16];
	__u8 media_errors[16];
	__u8 num_err_log_entries[16];
	__le32 warning_temp_time;
	__le32 critical_comp_time;
	__le16 temp_sensor[8];
	__le32 thm_temp1_trans_count;
	__le32 thm_temp2_trans_count;
	__le32 thm_temp1_total_time;
	__le32 thm_temp2_total_time;
	__u8 rsvd232[280];
};

enum {
	NVME_SMART_CRIT_SPARE = 1,
	NVME_SMART_CRIT_TEMPERATURE = 2,
	NVME_SMART_CRIT_RELIABILITY = 4,
	NVME_SMART_CRIT_MEDIA = 8,
	NVME_SMART_CRIT_VOLATILE_MEMORY = 16,
};

enum {
	NVME_TEMP_THRESH_MASK = 65535,
	NVME_TEMP_THRESH_SELECT_SHIFT = 16,
	NVME_TEMP_THRESH_TYPE_UNDER = 1048576,
};

struct nvme_hwmon_data {
	struct nvme_ctrl *ctrl;
	struct nvme_smart_log log;
	struct mutex read_lock;
};

enum {
	NVME_CMBSZ_SQS = 1,
	NVME_CMBSZ_CQS = 2,
	NVME_CMBSZ_LISTS = 4,
	NVME_CMBSZ_RDS = 8,
	NVME_CMBSZ_WDS = 16,
	NVME_CMBSZ_SZ_SHIFT = 12,
	NVME_CMBSZ_SZ_MASK = 1048575,
	NVME_CMBSZ_SZU_SHIFT = 8,
	NVME_CMBSZ_SZU_MASK = 15,
};

enum {
	NVME_SGL_FMT_DATA_DESC = 0,
	NVME_SGL_FMT_SEG_DESC = 2,
	NVME_SGL_FMT_LAST_SEG_DESC = 3,
	NVME_KEY_SGL_FMT_DATA_DESC = 4,
	NVME_TRANSPORT_SGL_DATA_DESC = 5,
};

enum {
	NVME_HOST_MEM_ENABLE = 1,
	NVME_HOST_MEM_RETURN = 2,
};

struct nvme_host_mem_buf_desc {
	__le64 addr;
	__le32 size;
	__u32 rsvd;
};

struct nvme_completion {
	union nvme_result result;
	__le16 sq_head;
	__le16 sq_id;
	__u16 command_id;
	__le16 status;
};

struct nvme_queue;

struct nvme_dev {
	struct nvme_queue *queues;
	struct blk_mq_tag_set tagset;
	struct blk_mq_tag_set admin_tagset;
	u32 *dbs;
	struct device *dev;
	struct dma_pool___2 *prp_page_pool;
	struct dma_pool___2 *prp_small_pool;
	unsigned int online_queues;
	unsigned int max_qid;
	unsigned int io_queues[3];
	unsigned int num_vecs;
	u32 q_depth;
	int io_sqes;
	u32 db_stride;
	void *bar;
	long unsigned int bar_mapped_size;
	struct work_struct remove_work;
	struct mutex shutdown_lock;
	bool subsystem;
	u64 cmb_size;
	bool cmb_use_sqes;
	u32 cmbsz;
	u32 cmbloc;
	struct nvme_ctrl ctrl;
	u32 last_ps;
	bool hmb;
	mempool_t *iod_mempool;
	u32 *dbbuf_dbs;
	dma_addr_t dbbuf_dbs_dma_addr;
	u32 *dbbuf_eis;
	dma_addr_t dbbuf_eis_dma_addr;
	u64 host_mem_size;
	u32 nr_host_mem_descs;
	dma_addr_t host_mem_descs_dma;
	struct nvme_host_mem_buf_desc *host_mem_descs;
	void **host_mem_desc_bufs;
	unsigned int nr_allocated_queues;
	unsigned int nr_write_queues;
	unsigned int nr_poll_queues;
	bool attrs_added;
};

struct nvme_queue {
	struct nvme_dev *dev;
	spinlock_t sq_lock;
	void *sq_cmds;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t cq_poll_lock;
	struct nvme_completion *cqes;
	dma_addr_t sq_dma_addr;
	dma_addr_t cq_dma_addr;
	u32 *q_db;
	u32 q_depth;
	u16 cq_vector;
	u16 sq_tail;
	u16 last_sq_tail;
	u16 cq_head;
	u16 qid;
	u8 cq_phase;
	u8 sqes;
	long unsigned int flags;
	u32 *dbbuf_sq_db;
	u32 *dbbuf_cq_db;
	u32 *dbbuf_sq_ei;
	u32 *dbbuf_cq_ei;
	struct completion delete_done;
};

struct nvme_iod {
	struct nvme_request req;
	struct nvme_command cmd;
	struct nvme_queue *nvmeq;
	bool use_sgl;
	int aborted;
	int npages;
	int nents;
	dma_addr_t first_dma;
	unsigned int dma_len;
	dma_addr_t meta_dma;
	struct scatterlist *sg;
};

enum {
	ATA_MAX_DEVICES = 2,
	ATA_MAX_PRD = 256,
	ATA_SECT_SIZE = 512,
	ATA_MAX_SECTORS_128 = 128,
	ATA_MAX_SECTORS = 256,
	ATA_MAX_SECTORS_1024 = 1024,
	ATA_MAX_SECTORS_LBA48 = 65535,
	ATA_MAX_SECTORS_TAPE = 65535,
	ATA_MAX_TRIM_RNUM = 64,
	ATA_ID_WORDS = 256,
	ATA_ID_CONFIG = 0,
	ATA_ID_CYLS = 1,
	ATA_ID_HEADS = 3,
	ATA_ID_SECTORS = 6,
	ATA_ID_SERNO = 10,
	ATA_ID_BUF_SIZE = 21,
	ATA_ID_FW_REV = 23,
	ATA_ID_PROD = 27,
	ATA_ID_MAX_MULTSECT = 47,
	ATA_ID_DWORD_IO = 48,
	ATA_ID_TRUSTED = 48,
	ATA_ID_CAPABILITY = 49,
	ATA_ID_OLD_PIO_MODES = 51,
	ATA_ID_OLD_DMA_MODES = 52,
	ATA_ID_FIELD_VALID = 53,
	ATA_ID_CUR_CYLS = 54,
	ATA_ID_CUR_HEADS = 55,
	ATA_ID_CUR_SECTORS = 56,
	ATA_ID_MULTSECT = 59,
	ATA_ID_LBA_CAPACITY = 60,
	ATA_ID_SWDMA_MODES = 62,
	ATA_ID_MWDMA_MODES = 63,
	ATA_ID_PIO_MODES = 64,
	ATA_ID_EIDE_DMA_MIN = 65,
	ATA_ID_EIDE_DMA_TIME = 66,
	ATA_ID_EIDE_PIO = 67,
	ATA_ID_EIDE_PIO_IORDY = 68,
	ATA_ID_ADDITIONAL_SUPP = 69,
	ATA_ID_QUEUE_DEPTH = 75,
	ATA_ID_SATA_CAPABILITY = 76,
	ATA_ID_SATA_CAPABILITY_2 = 77,
	ATA_ID_FEATURE_SUPP = 78,
	ATA_ID_MAJOR_VER = 80,
	ATA_ID_COMMAND_SET_1 = 82,
	ATA_ID_COMMAND_SET_2 = 83,
	ATA_ID_CFSSE = 84,
	ATA_ID_CFS_ENABLE_1 = 85,
	ATA_ID_CFS_ENABLE_2 = 86,
	ATA_ID_CSF_DEFAULT = 87,
	ATA_ID_UDMA_MODES = 88,
	ATA_ID_HW_CONFIG = 93,
	ATA_ID_SPG = 98,
	ATA_ID_LBA_CAPACITY_2 = 100,
	ATA_ID_SECTOR_SIZE = 106,
	ATA_ID_WWN = 108,
	ATA_ID_LOGICAL_SECTOR_SIZE = 117,
	ATA_ID_COMMAND_SET_3 = 119,
	ATA_ID_COMMAND_SET_4 = 120,
	ATA_ID_LAST_LUN = 126,
	ATA_ID_DLF = 128,
	ATA_ID_CSFO = 129,
	ATA_ID_CFA_POWER = 160,
	ATA_ID_CFA_KEY_MGMT = 162,
	ATA_ID_CFA_MODES = 163,
	ATA_ID_DATA_SET_MGMT = 169,
	ATA_ID_SCT_CMD_XPORT = 206,
	ATA_ID_ROT_SPEED = 217,
	ATA_ID_PIO4 = 2,
	ATA_ID_SERNO_LEN = 20,
	ATA_ID_FW_REV_LEN = 8,
	ATA_ID_PROD_LEN = 40,
	ATA_ID_WWN_LEN = 8,
	ATA_PCI_CTL_OFS = 2,
	ATA_PIO0 = 1,
	ATA_PIO1 = 3,
	ATA_PIO2 = 7,
	ATA_PIO3 = 15,
	ATA_PIO4 = 31,
	ATA_PIO5 = 63,
	ATA_PIO6 = 127,
	ATA_PIO4_ONLY = 16,
	ATA_SWDMA0 = 1,
	ATA_SWDMA1 = 3,
	ATA_SWDMA2 = 7,
	ATA_SWDMA2_ONLY = 4,
	ATA_MWDMA0 = 1,
	ATA_MWDMA1 = 3,
	ATA_MWDMA2 = 7,
	ATA_MWDMA3 = 15,
	ATA_MWDMA4 = 31,
	ATA_MWDMA12_ONLY = 6,
	ATA_MWDMA2_ONLY = 4,
	ATA_UDMA0 = 1,
	ATA_UDMA1 = 3,
	ATA_UDMA2 = 7,
	ATA_UDMA3 = 15,
	ATA_UDMA4 = 31,
	ATA_UDMA5 = 63,
	ATA_UDMA6 = 127,
	ATA_UDMA7 = 255,
	ATA_UDMA24_ONLY = 20,
	ATA_UDMA_MASK_40C = 7,
	ATA_PRD_SZ = 8,
	ATA_PRD_TBL_SZ = 2048,
	ATA_PRD_EOT = 2147483648,
	ATA_DMA_TABLE_OFS = 4,
	ATA_DMA_STATUS = 2,
	ATA_DMA_CMD = 0,
	ATA_DMA_WR = 8,
	ATA_DMA_START = 1,
	ATA_DMA_INTR = 4,
	ATA_DMA_ERR = 2,
	ATA_DMA_ACTIVE = 1,
	ATA_HOB = 128,
	ATA_NIEN = 2,
	ATA_LBA = 64,
	ATA_DEV1 = 16,
	ATA_DEVICE_OBS = 160,
	ATA_DEVCTL_OBS = 8,
	ATA_BUSY = 128,
	ATA_DRDY = 64,
	ATA_DF = 32,
	ATA_DSC = 16,
	ATA_DRQ = 8,
	ATA_CORR = 4,
	ATA_SENSE = 2,
	ATA_ERR = 1,
	ATA_SRST = 4,
	ATA_ICRC = 128,
	ATA_BBK = 128,
	ATA_UNC = 64,
	ATA_MC = 32,
	ATA_IDNF = 16,
	ATA_MCR = 8,
	ATA_ABORTED = 4,
	ATA_TRK0NF = 2,
	ATA_AMNF = 1,
	ATAPI_LFS = 240,
	ATAPI_EOM = 2,
	ATAPI_ILI = 1,
	ATAPI_IO = 2,
	ATAPI_COD = 1,
	ATA_REG_DATA = 0,
	ATA_REG_ERR = 1,
	ATA_REG_NSECT = 2,
	ATA_REG_LBAL = 3,
	ATA_REG_LBAM = 4,
	ATA_REG_LBAH = 5,
	ATA_REG_DEVICE = 6,
	ATA_REG_STATUS = 7,
	ATA_REG_FEATURE = 1,
	ATA_REG_CMD = 7,
	ATA_REG_BYTEL = 4,
	ATA_REG_BYTEH = 5,
	ATA_REG_DEVSEL = 6,
	ATA_REG_IRQ = 2,
	ATA_CMD_DEV_RESET = 8,
	ATA_CMD_CHK_POWER = 229,
	ATA_CMD_STANDBY = 226,
	ATA_CMD_IDLE = 227,
	ATA_CMD_EDD = 144,
	ATA_CMD_DOWNLOAD_MICRO = 146,
	ATA_CMD_DOWNLOAD_MICRO_DMA = 147,
	ATA_CMD_NOP = 0,
	ATA_CMD_FLUSH = 231,
	ATA_CMD_FLUSH_EXT = 234,
	ATA_CMD_ID_ATA = 236,
	ATA_CMD_ID_ATAPI = 161,
	ATA_CMD_SERVICE = 162,
	ATA_CMD_READ = 200,
	ATA_CMD_READ_EXT = 37,
	ATA_CMD_READ_QUEUED = 38,
	ATA_CMD_READ_STREAM_EXT = 43,
	ATA_CMD_READ_STREAM_DMA_EXT = 42,
	ATA_CMD_WRITE = 202,
	ATA_CMD_WRITE_EXT = 53,
	ATA_CMD_WRITE_QUEUED = 54,
	ATA_CMD_WRITE_STREAM_EXT = 59,
	ATA_CMD_WRITE_STREAM_DMA_EXT = 58,
	ATA_CMD_WRITE_FUA_EXT = 61,
	ATA_CMD_WRITE_QUEUED_FUA_EXT = 62,
	ATA_CMD_FPDMA_READ = 96,
	ATA_CMD_FPDMA_WRITE = 97,
	ATA_CMD_NCQ_NON_DATA = 99,
	ATA_CMD_FPDMA_SEND = 100,
	ATA_CMD_FPDMA_RECV = 101,
	ATA_CMD_PIO_READ = 32,
	ATA_CMD_PIO_READ_EXT = 36,
	ATA_CMD_PIO_WRITE = 48,
	ATA_CMD_PIO_WRITE_EXT = 52,
	ATA_CMD_READ_MULTI = 196,
	ATA_CMD_READ_MULTI_EXT = 41,
	ATA_CMD_WRITE_MULTI = 197,
	ATA_CMD_WRITE_MULTI_EXT = 57,
	ATA_CMD_WRITE_MULTI_FUA_EXT = 206,
	ATA_CMD_SET_FEATURES = 239,
	ATA_CMD_SET_MULTI = 198,
	ATA_CMD_PACKET = 160,
	ATA_CMD_VERIFY = 64,
	ATA_CMD_VERIFY_EXT = 66,
	ATA_CMD_WRITE_UNCORR_EXT = 69,
	ATA_CMD_STANDBYNOW1 = 224,
	ATA_CMD_IDLEIMMEDIATE = 225,
	ATA_CMD_SLEEP = 230,
	ATA_CMD_INIT_DEV_PARAMS = 145,
	ATA_CMD_READ_NATIVE_MAX = 248,
	ATA_CMD_READ_NATIVE_MAX_EXT = 39,
	ATA_CMD_SET_MAX = 249,
	ATA_CMD_SET_MAX_EXT = 55,
	ATA_CMD_READ_LOG_EXT = 47,
	ATA_CMD_WRITE_LOG_EXT = 63,
	ATA_CMD_READ_LOG_DMA_EXT = 71,
	ATA_CMD_WRITE_LOG_DMA_EXT = 87,
	ATA_CMD_TRUSTED_NONDATA = 91,
	ATA_CMD_TRUSTED_RCV = 92,
	ATA_CMD_TRUSTED_RCV_DMA = 93,
	ATA_CMD_TRUSTED_SND = 94,
	ATA_CMD_TRUSTED_SND_DMA = 95,
	ATA_CMD_PMP_READ = 228,
	ATA_CMD_PMP_READ_DMA = 233,
	ATA_CMD_PMP_WRITE = 232,
	ATA_CMD_PMP_WRITE_DMA = 235,
	ATA_CMD_CONF_OVERLAY = 177,
	ATA_CMD_SEC_SET_PASS = 241,
	ATA_CMD_SEC_UNLOCK = 242,
	ATA_CMD_SEC_ERASE_PREP = 243,
	ATA_CMD_SEC_ERASE_UNIT = 244,
	ATA_CMD_SEC_FREEZE_LOCK = 245,
	ATA_CMD_SEC_DISABLE_PASS = 246,
	ATA_CMD_CONFIG_STREAM = 81,
	ATA_CMD_SMART = 176,
	ATA_CMD_MEDIA_LOCK = 222,
	ATA_CMD_MEDIA_UNLOCK = 223,
	ATA_CMD_DSM = 6,
	ATA_CMD_CHK_MED_CRD_TYP = 209,
	ATA_CMD_CFA_REQ_EXT_ERR = 3,
	ATA_CMD_CFA_WRITE_NE = 56,
	ATA_CMD_CFA_TRANS_SECT = 135,
	ATA_CMD_CFA_ERASE = 192,
	ATA_CMD_CFA_WRITE_MULT_NE = 205,
	ATA_CMD_REQ_SENSE_DATA = 11,
	ATA_CMD_SANITIZE_DEVICE = 180,
	ATA_CMD_ZAC_MGMT_IN = 74,
	ATA_CMD_ZAC_MGMT_OUT = 159,
	ATA_CMD_RESTORE = 16,
	ATA_SUBCMD_FPDMA_RECV_RD_LOG_DMA_EXT = 1,
	ATA_SUBCMD_FPDMA_RECV_ZAC_MGMT_IN = 2,
	ATA_SUBCMD_FPDMA_SEND_DSM = 0,
	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 2,
	ATA_SUBCMD_NCQ_NON_DATA_ABORT_QUEUE = 0,
	ATA_SUBCMD_NCQ_NON_DATA_SET_FEATURES = 5,
	ATA_SUBCMD_NCQ_NON_DATA_ZERO_EXT = 6,
	ATA_SUBCMD_NCQ_NON_DATA_ZAC_MGMT_OUT = 7,
	ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES = 0,
	ATA_SUBCMD_ZAC_MGMT_OUT_CLOSE_ZONE = 1,
	ATA_SUBCMD_ZAC_MGMT_OUT_FINISH_ZONE = 2,
	ATA_SUBCMD_ZAC_MGMT_OUT_OPEN_ZONE = 3,
	ATA_SUBCMD_ZAC_MGMT_OUT_RESET_WRITE_POINTER = 4,
	ATA_LOG_DIRECTORY = 0,
	ATA_LOG_SATA_NCQ = 16,
	ATA_LOG_NCQ_NON_DATA = 18,
	ATA_LOG_NCQ_SEND_RECV = 19,
	ATA_LOG_IDENTIFY_DEVICE = 48,
	ATA_LOG_SECURITY = 6,
	ATA_LOG_SATA_SETTINGS = 8,
	ATA_LOG_ZONED_INFORMATION = 9,
	ATA_LOG_DEVSLP_OFFSET = 48,
	ATA_LOG_DEVSLP_SIZE = 8,
	ATA_LOG_DEVSLP_MDAT = 0,
	ATA_LOG_DEVSLP_MDAT_MASK = 31,
	ATA_LOG_DEVSLP_DETO = 1,
	ATA_LOG_DEVSLP_VALID = 7,
	ATA_LOG_DEVSLP_VALID_MASK = 128,
	ATA_LOG_NCQ_PRIO_OFFSET = 9,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_DSM = 1,
	ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET = 4,
	ATA_LOG_NCQ_SEND_RECV_DSM_TRIM = 1,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET = 8,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_OFFSET = 12,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OFFSET = 16,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OUT_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED = 2,
	ATA_LOG_NCQ_SEND_RECV_SIZE = 20,
	ATA_LOG_NCQ_NON_DATA_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_NCQ = 1,
	ATA_LOG_NCQ_NON_DATA_ABORT_ALL = 2,
	ATA_LOG_NCQ_NON_DATA_ABORT_STREAMING = 4,
	ATA_LOG_NCQ_NON_DATA_ABORT_NON_STREAMING = 8,
	ATA_LOG_NCQ_NON_DATA_ABORT_SELECTED = 16,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OFFSET = 28,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OUT = 1,
	ATA_LOG_NCQ_NON_DATA_SIZE = 64,
	ATA_CMD_READ_LONG = 34,
	ATA_CMD_READ_LONG_ONCE = 35,
	ATA_CMD_WRITE_LONG = 50,
	ATA_CMD_WRITE_LONG_ONCE = 51,
	SETFEATURES_XFER = 3,
	XFER_UDMA_7 = 71,
	XFER_UDMA_6 = 70,
	XFER_UDMA_5 = 69,
	XFER_UDMA_4 = 68,
	XFER_UDMA_3 = 67,
	XFER_UDMA_2 = 66,
	XFER_UDMA_1 = 65,
	XFER_UDMA_0 = 64,
	XFER_MW_DMA_4 = 36,
	XFER_MW_DMA_3 = 35,
	XFER_MW_DMA_2 = 34,
	XFER_MW_DMA_1 = 33,
	XFER_MW_DMA_0 = 32,
	XFER_SW_DMA_2 = 18,
	XFER_SW_DMA_1 = 17,
	XFER_SW_DMA_0 = 16,
	XFER_PIO_6 = 14,
	XFER_PIO_5 = 13,
	XFER_PIO_4 = 12,
	XFER_PIO_3 = 11,
	XFER_PIO_2 = 10,
	XFER_PIO_1 = 9,
	XFER_PIO_0 = 8,
	XFER_PIO_SLOW = 0,
	SETFEATURES_WC_ON = 2,
	SETFEATURES_WC_OFF = 130,
	SETFEATURES_RA_ON = 170,
	SETFEATURES_RA_OFF = 85,
	SETFEATURES_AAM_ON = 66,
	SETFEATURES_AAM_OFF = 194,
	SETFEATURES_SPINUP = 7,
	SETFEATURES_SPINUP_TIMEOUT = 30000,
	SETFEATURES_SATA_ENABLE = 16,
	SETFEATURES_SATA_DISABLE = 144,
	SATA_FPDMA_OFFSET = 1,
	SATA_FPDMA_AA = 2,
	SATA_DIPM = 3,
	SATA_FPDMA_IN_ORDER = 4,
	SATA_AN = 5,
	SATA_SSP = 6,
	SATA_DEVSLP = 9,
	SETFEATURE_SENSE_DATA = 195,
	ATA_SET_MAX_ADDR = 0,
	ATA_SET_MAX_PASSWD = 1,
	ATA_SET_MAX_LOCK = 2,
	ATA_SET_MAX_UNLOCK = 3,
	ATA_SET_MAX_FREEZE_LOCK = 4,
	ATA_SET_MAX_PASSWD_DMA = 5,
	ATA_SET_MAX_UNLOCK_DMA = 6,
	ATA_DCO_RESTORE = 192,
	ATA_DCO_FREEZE_LOCK = 193,
	ATA_DCO_IDENTIFY = 194,
	ATA_DCO_SET = 195,
	ATA_SMART_ENABLE = 216,
	ATA_SMART_READ_VALUES = 208,
	ATA_SMART_READ_THRESHOLDS = 209,
	ATA_DSM_TRIM = 1,
	ATA_SMART_LBAM_PASS = 79,
	ATA_SMART_LBAH_PASS = 194,
	ATAPI_PKT_DMA = 1,
	ATAPI_DMADIR = 4,
	ATAPI_CDB_LEN = 16,
	SATA_PMP_MAX_PORTS = 15,
	SATA_PMP_CTRL_PORT = 15,
	SATA_PMP_GSCR_DWORDS = 128,
	SATA_PMP_GSCR_PROD_ID = 0,
	SATA_PMP_GSCR_REV = 1,
	SATA_PMP_GSCR_PORT_INFO = 2,
	SATA_PMP_GSCR_ERROR = 32,
	SATA_PMP_GSCR_ERROR_EN = 33,
	SATA_PMP_GSCR_FEAT = 64,
	SATA_PMP_GSCR_FEAT_EN = 96,
	SATA_PMP_PSCR_STATUS = 0,
	SATA_PMP_PSCR_ERROR = 1,
	SATA_PMP_PSCR_CONTROL = 2,
	SATA_PMP_FEAT_BIST = 1,
	SATA_PMP_FEAT_PMREQ = 2,
	SATA_PMP_FEAT_DYNSSC = 4,
	SATA_PMP_FEAT_NOTIFY = 8,
	ATA_CBL_NONE = 0,
	ATA_CBL_PATA40 = 1,
	ATA_CBL_PATA80 = 2,
	ATA_CBL_PATA40_SHORT = 3,
	ATA_CBL_PATA_UNK = 4,
	ATA_CBL_PATA_IGN = 5,
	ATA_CBL_SATA = 6,
	SCR_STATUS = 0,
	SCR_ERROR = 1,
	SCR_CONTROL = 2,
	SCR_ACTIVE = 3,
	SCR_NOTIFICATION = 4,
	SERR_DATA_RECOVERED = 1,
	SERR_COMM_RECOVERED = 2,
	SERR_DATA = 256,
	SERR_PERSISTENT = 512,
	SERR_PROTOCOL = 1024,
	SERR_INTERNAL = 2048,
	SERR_PHYRDY_CHG = 65536,
	SERR_PHY_INT_ERR = 131072,
	SERR_COMM_WAKE = 262144,
	SERR_10B_8B_ERR = 524288,
	SERR_DISPARITY = 1048576,
	SERR_CRC = 2097152,
	SERR_HANDSHAKE = 4194304,
	SERR_LINK_SEQ_ERR = 8388608,
	SERR_TRANS_ST_ERROR = 16777216,
	SERR_UNRECOG_FIS = 33554432,
	SERR_DEV_XCHG = 67108864,
};

enum ata_prot_flags {
	ATA_PROT_FLAG_PIO = 1,
	ATA_PROT_FLAG_DMA = 2,
	ATA_PROT_FLAG_NCQ = 4,
	ATA_PROT_FLAG_ATAPI = 8,
	ATA_PROT_UNKNOWN = 255,
	ATA_PROT_NODATA = 0,
	ATA_PROT_PIO = 1,
	ATA_PROT_DMA = 2,
	ATA_PROT_NCQ_NODATA = 4,
	ATA_PROT_NCQ = 6,
	ATAPI_PROT_NODATA = 8,
	ATAPI_PROT_PIO = 9,
	ATAPI_PROT_DMA = 10,
};

struct ata_bmdma_prd {
	__le32 addr;
	__le32 flags_len;
};

enum {
	ATA_MSG_DRV = 1,
	ATA_MSG_INFO = 2,
	ATA_MSG_PROBE = 4,
	ATA_MSG_WARN = 8,
	ATA_MSG_MALLOC = 16,
	ATA_MSG_CTL = 32,
	ATA_MSG_INTR = 64,
	ATA_MSG_ERR = 128,
};

enum {
	LIBATA_MAX_PRD = 128,
	LIBATA_DUMB_MAX_PRD = 64,
	ATA_DEF_QUEUE = 1,
	ATA_MAX_QUEUE = 32,
	ATA_TAG_INTERNAL = 32,
	ATA_SHORT_PAUSE = 16,
	ATAPI_MAX_DRAIN = 16384,
	ATA_ALL_DEVICES = 3,
	ATA_SHT_EMULATED = 1,
	ATA_SHT_THIS_ID = 4294967295,
	ATA_TFLAG_LBA48 = 1,
	ATA_TFLAG_ISADDR = 2,
	ATA_TFLAG_DEVICE = 4,
	ATA_TFLAG_WRITE = 8,
	ATA_TFLAG_LBA = 16,
	ATA_TFLAG_FUA = 32,
	ATA_TFLAG_POLLING = 64,
	ATA_DFLAG_LBA = 1,
	ATA_DFLAG_LBA48 = 2,
	ATA_DFLAG_CDB_INTR = 4,
	ATA_DFLAG_NCQ = 8,
	ATA_DFLAG_FLUSH_EXT = 16,
	ATA_DFLAG_ACPI_PENDING = 32,
	ATA_DFLAG_ACPI_FAILED = 64,
	ATA_DFLAG_AN = 128,
	ATA_DFLAG_TRUSTED = 256,
	ATA_DFLAG_DMADIR = 1024,
	ATA_DFLAG_CFG_MASK = 4095,
	ATA_DFLAG_PIO = 4096,
	ATA_DFLAG_NCQ_OFF = 8192,
	ATA_DFLAG_SLEEPING = 32768,
	ATA_DFLAG_DUBIOUS_XFER = 65536,
	ATA_DFLAG_NO_UNLOAD = 131072,
	ATA_DFLAG_UNLOCK_HPA = 262144,
	ATA_DFLAG_NCQ_SEND_RECV = 524288,
	ATA_DFLAG_NCQ_PRIO = 1048576,
	ATA_DFLAG_NCQ_PRIO_ENABLE = 2097152,
	ATA_DFLAG_INIT_MASK = 16777215,
	ATA_DFLAG_DETACH = 16777216,
	ATA_DFLAG_DETACHED = 33554432,
	ATA_DFLAG_DA = 67108864,
	ATA_DFLAG_DEVSLP = 134217728,
	ATA_DFLAG_ACPI_DISABLED = 268435456,
	ATA_DFLAG_D_SENSE = 536870912,
	ATA_DFLAG_ZAC = 1073741824,
	ATA_DEV_UNKNOWN = 0,
	ATA_DEV_ATA = 1,
	ATA_DEV_ATA_UNSUP = 2,
	ATA_DEV_ATAPI = 3,
	ATA_DEV_ATAPI_UNSUP = 4,
	ATA_DEV_PMP = 5,
	ATA_DEV_PMP_UNSUP = 6,
	ATA_DEV_SEMB = 7,
	ATA_DEV_SEMB_UNSUP = 8,
	ATA_DEV_ZAC = 9,
	ATA_DEV_ZAC_UNSUP = 10,
	ATA_DEV_NONE = 11,
	ATA_LFLAG_NO_HRST = 2,
	ATA_LFLAG_NO_SRST = 4,
	ATA_LFLAG_ASSUME_ATA = 8,
	ATA_LFLAG_ASSUME_SEMB = 16,
	ATA_LFLAG_ASSUME_CLASS = 24,
	ATA_LFLAG_NO_RETRY = 32,
	ATA_LFLAG_DISABLED = 64,
	ATA_LFLAG_SW_ACTIVITY = 128,
	ATA_LFLAG_NO_LPM = 256,
	ATA_LFLAG_RST_ONCE = 512,
	ATA_LFLAG_CHANGED = 1024,
	ATA_LFLAG_NO_DB_DELAY = 2048,
	ATA_FLAG_SLAVE_POSS = 1,
	ATA_FLAG_SATA = 2,
	ATA_FLAG_NO_LPM = 4,
	ATA_FLAG_NO_LOG_PAGE = 32,
	ATA_FLAG_NO_ATAPI = 64,
	ATA_FLAG_PIO_DMA = 128,
	ATA_FLAG_PIO_LBA48 = 256,
	ATA_FLAG_PIO_POLLING = 512,
	ATA_FLAG_NCQ = 1024,
	ATA_FLAG_NO_POWEROFF_SPINDOWN = 2048,
	ATA_FLAG_NO_HIBERNATE_SPINDOWN = 4096,
	ATA_FLAG_DEBUGMSG = 8192,
	ATA_FLAG_FPDMA_AA = 16384,
	ATA_FLAG_IGN_SIMPLEX = 32768,
	ATA_FLAG_NO_IORDY = 65536,
	ATA_FLAG_ACPI_SATA = 131072,
	ATA_FLAG_AN = 262144,
	ATA_FLAG_PMP = 524288,
	ATA_FLAG_FPDMA_AUX = 1048576,
	ATA_FLAG_EM = 2097152,
	ATA_FLAG_SW_ACTIVITY = 4194304,
	ATA_FLAG_NO_DIPM = 8388608,
	ATA_FLAG_SAS_HOST = 16777216,
	ATA_PFLAG_EH_PENDING = 1,
	ATA_PFLAG_EH_IN_PROGRESS = 2,
	ATA_PFLAG_FROZEN = 4,
	ATA_PFLAG_RECOVERED = 8,
	ATA_PFLAG_LOADING = 16,
	ATA_PFLAG_SCSI_HOTPLUG = 64,
	ATA_PFLAG_INITIALIZING = 128,
	ATA_PFLAG_RESETTING = 256,
	ATA_PFLAG_UNLOADING = 512,
	ATA_PFLAG_UNLOADED = 1024,
	ATA_PFLAG_SUSPENDED = 131072,
	ATA_PFLAG_PM_PENDING = 262144,
	ATA_PFLAG_INIT_GTM_VALID = 524288,
	ATA_PFLAG_PIO32 = 1048576,
	ATA_PFLAG_PIO32CHANGE = 2097152,
	ATA_PFLAG_EXTERNAL = 4194304,
	ATA_QCFLAG_ACTIVE = 1,
	ATA_QCFLAG_DMAMAP = 2,
	ATA_QCFLAG_IO = 8,
	ATA_QCFLAG_RESULT_TF = 16,
	ATA_QCFLAG_CLEAR_EXCL = 32,
	ATA_QCFLAG_QUIET = 64,
	ATA_QCFLAG_RETRY = 128,
	ATA_QCFLAG_FAILED = 65536,
	ATA_QCFLAG_SENSE_VALID = 131072,
	ATA_QCFLAG_EH_SCHEDULED = 262144,
	ATA_HOST_SIMPLEX = 1,
	ATA_HOST_STARTED = 2,
	ATA_HOST_PARALLEL_SCAN = 4,
	ATA_HOST_IGNORE_ATA = 8,
	ATA_TMOUT_BOOT = 30000,
	ATA_TMOUT_BOOT_QUICK = 7000,
	ATA_TMOUT_INTERNAL_QUICK = 5000,
	ATA_TMOUT_MAX_PARK = 30000,
	ATA_TMOUT_FF_WAIT_LONG = 2000,
	ATA_TMOUT_FF_WAIT = 800,
	ATA_WAIT_AFTER_RESET = 150,
	ATA_TMOUT_PMP_SRST_WAIT = 5000,
	ATA_TMOUT_SPURIOUS_PHY = 10000,
	BUS_UNKNOWN = 0,
	BUS_DMA = 1,
	BUS_IDLE = 2,
	BUS_NOINTR = 3,
	BUS_NODATA = 4,
	BUS_TIMER = 5,
	BUS_PIO = 6,
	BUS_EDD = 7,
	BUS_IDENTIFY = 8,
	BUS_PACKET = 9,
	PORT_UNKNOWN = 0,
	PORT_ENABLED = 1,
	PORT_DISABLED = 2,
	ATA_NR_PIO_MODES = 7,
	ATA_NR_MWDMA_MODES = 5,
	ATA_NR_UDMA_MODES = 8,
	ATA_SHIFT_PIO = 0,
	ATA_SHIFT_MWDMA = 7,
	ATA_SHIFT_UDMA = 12,
	ATA_SHIFT_PRIO = 6,
	ATA_PRIO_HIGH = 2,
	ATA_DMA_PAD_SZ = 4,
	ATA_ERING_SIZE = 32,
	ATA_DEFER_LINK = 1,
	ATA_DEFER_PORT = 2,
	ATA_EH_DESC_LEN = 80,
	ATA_EH_REVALIDATE = 1,
	ATA_EH_SOFTRESET = 2,
	ATA_EH_HARDRESET = 4,
	ATA_EH_RESET = 6,
	ATA_EH_ENABLE_LINK = 8,
	ATA_EH_PARK = 32,
	ATA_EH_PERDEV_MASK = 33,
	ATA_EH_ALL_ACTIONS = 15,
	ATA_EHI_HOTPLUGGED = 1,
	ATA_EHI_NO_AUTOPSY = 4,
	ATA_EHI_QUIET = 8,
	ATA_EHI_NO_RECOVERY = 16,
	ATA_EHI_DID_SOFTRESET = 65536,
	ATA_EHI_DID_HARDRESET = 131072,
	ATA_EHI_PRINTINFO = 262144,
	ATA_EHI_SETMODE = 524288,
	ATA_EHI_POST_SETMODE = 1048576,
	ATA_EHI_DID_RESET = 196608,
	ATA_EHI_TO_SLAVE_MASK = 12,
	ATA_EH_MAX_TRIES = 5,
	ATA_LINK_RESUME_TRIES = 5,
	ATA_PROBE_MAX_TRIES = 3,
	ATA_EH_DEV_TRIES = 3,
	ATA_EH_PMP_TRIES = 5,
	ATA_EH_PMP_LINK_TRIES = 3,
	SATA_PMP_RW_TIMEOUT = 3000,
	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 7,
	ATA_HORKAGE_DIAGNOSTIC = 1,
	ATA_HORKAGE_NODMA = 2,
	ATA_HORKAGE_NONCQ = 4,
	ATA_HORKAGE_MAX_SEC_128 = 8,
	ATA_HORKAGE_BROKEN_HPA = 16,
	ATA_HORKAGE_DISABLE = 32,
	ATA_HORKAGE_HPA_SIZE = 64,
	ATA_HORKAGE_IVB = 256,
	ATA_HORKAGE_STUCK_ERR = 512,
	ATA_HORKAGE_BRIDGE_OK = 1024,
	ATA_HORKAGE_ATAPI_MOD16_DMA = 2048,
	ATA_HORKAGE_FIRMWARE_WARN = 4096,
	ATA_HORKAGE_1_5_GBPS = 8192,
	ATA_HORKAGE_NOSETXFER = 16384,
	ATA_HORKAGE_BROKEN_FPDMA_AA = 32768,
	ATA_HORKAGE_DUMP_ID = 65536,
	ATA_HORKAGE_MAX_SEC_LBA48 = 131072,
	ATA_HORKAGE_ATAPI_DMADIR = 262144,
	ATA_HORKAGE_NO_NCQ_TRIM = 524288,
	ATA_HORKAGE_NOLPM = 1048576,
	ATA_HORKAGE_WD_BROKEN_LPM = 2097152,
	ATA_HORKAGE_ZERO_AFTER_TRIM = 4194304,
	ATA_HORKAGE_NO_DMA_LOG = 8388608,
	ATA_HORKAGE_NOTRIM = 16777216,
	ATA_HORKAGE_MAX_SEC_1024 = 33554432,
	ATA_HORKAGE_MAX_TRIM_128M = 67108864,
	ATA_HORKAGE_NO_NCQ_ON_ATI = 134217728,
	ATA_DMA_MASK_ATA = 1,
	ATA_DMA_MASK_ATAPI = 2,
	ATA_DMA_MASK_CFA = 4,
	ATAPI_READ = 0,
	ATAPI_WRITE = 1,
	ATAPI_READ_CD = 2,
	ATAPI_PASS_THRU = 3,
	ATAPI_MISC = 4,
	ATA_TIMING_SETUP = 1,
	ATA_TIMING_ACT8B = 2,
	ATA_TIMING_REC8B = 4,
	ATA_TIMING_CYC8B = 8,
	ATA_TIMING_8BIT = 14,
	ATA_TIMING_ACTIVE = 16,
	ATA_TIMING_RECOVER = 32,
	ATA_TIMING_DMACK_HOLD = 64,
	ATA_TIMING_CYCLE = 128,
	ATA_TIMING_UDMA = 256,
	ATA_TIMING_ALL = 511,
	ATA_ACPI_FILTER_SETXFER = 1,
	ATA_ACPI_FILTER_LOCK = 2,
	ATA_ACPI_FILTER_DIPM = 4,
	ATA_ACPI_FILTER_FPDMA_OFFSET = 8,
	ATA_ACPI_FILTER_FPDMA_AA = 16,
	ATA_ACPI_FILTER_DEFAULT = 7,
};

enum ata_xfer_mask {
	ATA_MASK_PIO = 127,
	ATA_MASK_MWDMA = 3968,
	ATA_MASK_UDMA = 1044480,
};

enum ata_completion_errors {
	AC_ERR_OK = 0,
	AC_ERR_DEV = 1,
	AC_ERR_HSM = 2,
	AC_ERR_TIMEOUT = 4,
	AC_ERR_MEDIA = 8,
	AC_ERR_ATA_BUS = 16,
	AC_ERR_HOST_BUS = 32,
	AC_ERR_SYSTEM = 64,
	AC_ERR_INVALID = 128,
	AC_ERR_OTHER = 256,
	AC_ERR_NODEV_HINT = 512,
	AC_ERR_NCQ = 1024,
};

enum ata_lpm_policy {
	ATA_LPM_UNKNOWN = 0,
	ATA_LPM_MAX_POWER = 1,
	ATA_LPM_MED_POWER = 2,
	ATA_LPM_MED_POWER_WITH_DIPM = 3,
	ATA_LPM_MIN_POWER_WITH_PARTIAL = 4,
	ATA_LPM_MIN_POWER = 5,
};

struct ata_queued_cmd;

typedef void (*ata_qc_cb_t)(struct ata_queued_cmd *);

struct ata_taskfile {
	long unsigned int flags;
	u8 protocol;
	u8 ctl;
	u8 hob_feature;
	u8 hob_nsect;
	u8 hob_lbal;
	u8 hob_lbam;
	u8 hob_lbah;
	u8 feature;
	u8 nsect;
	u8 lbal;
	u8 lbam;
	u8 lbah;
	u8 device;
	u8 command;
	u32 auxiliary;
};

struct ata_port;

struct ata_device;

struct ata_queued_cmd {
	struct ata_port *ap;
	struct ata_device *dev;
	struct scsi_cmnd *scsicmd;
	void (*scsidone)(struct scsi_cmnd *);
	struct ata_taskfile tf;
	u8 cdb[16];
	long unsigned int flags;
	unsigned int tag;
	unsigned int hw_tag;
	unsigned int n_elem;
	unsigned int orig_n_elem;
	int dma_dir;
	unsigned int sect_size;
	unsigned int nbytes;
	unsigned int extrabytes;
	unsigned int curbytes;
	struct scatterlist sgent;
	struct scatterlist *sg;
	struct scatterlist *cursg;
	unsigned int cursg_ofs;
	unsigned int err_mask;
	struct ata_taskfile result_tf;
	ata_qc_cb_t complete_fn;
	void *private_data;
	void *lldd_task;
};

struct ata_link;

typedef int (*ata_prereset_fn_t)(struct ata_link *, long unsigned int);

struct ata_eh_info {
	struct ata_device *dev;
	u32 serror;
	unsigned int err_mask;
	unsigned int action;
	unsigned int dev_action[2];
	unsigned int flags;
	unsigned int probe_mask;
	char desc[80];
	int desc_len;
};

struct ata_eh_context {
	struct ata_eh_info i;
	int tries[2];
	int cmd_timeout_idx[14];
	unsigned int classes[2];
	unsigned int did_probe_mask;
	unsigned int unloaded_mask;
	unsigned int saved_ncq_enabled;
	u8 saved_xfer_mode[2];
	long unsigned int last_reset;
};

struct ata_ering_entry {
	unsigned int eflags;
	unsigned int err_mask;
	u64 timestamp;
};

struct ata_ering {
	int cursor;
	struct ata_ering_entry ring[32];
};

struct ata_device {
	struct ata_link *link;
	unsigned int devno;
	unsigned int horkage;
	long unsigned int flags;
	struct scsi_device *sdev;
	void *private_data;
	union acpi_object *gtf_cache;
	unsigned int gtf_filter;
	void *zpodd;
	struct device tdev;
	u64 n_sectors;
	u64 n_native_sectors;
	unsigned int class;
	long unsigned int unpark_deadline;
	u8 pio_mode;
	u8 dma_mode;
	u8 xfer_mode;
	unsigned int xfer_shift;
	unsigned int multi_count;
	unsigned int max_sectors;
	unsigned int cdb_len;
	long unsigned int pio_mask;
	long unsigned int mwdma_mask;
	long unsigned int udma_mask;
	u16 cylinders;
	u16 heads;
	u16 sectors;
	long: 16;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		u16 id[256];
		u32 gscr[128];
	};
	u8 devslp_timing[8];
	u8 ncq_send_recv_cmds[20];
	u8 ncq_non_data_cmds[64];
	u32 zac_zoned_cap;
	u32 zac_zones_optimal_open;
	u32 zac_zones_optimal_nonseq;
	u32 zac_zones_max_open;
	int spdn_cnt;
	struct ata_ering ering;
	long: 64;
};

struct ata_link {
	struct ata_port *ap;
	int pmp;
	struct device tdev;
	unsigned int active_tag;
	u32 sactive;
	unsigned int flags;
	u32 saved_scontrol;
	unsigned int hw_sata_spd_limit;
	unsigned int sata_spd_limit;
	unsigned int sata_spd;
	enum ata_lpm_policy lpm_policy;
	struct ata_eh_info eh_info;
	struct ata_eh_context eh_context;
	long: 64;
	long: 64;
	struct ata_device device[2];
	long unsigned int last_lpm_change;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef int (*ata_reset_fn_t)(struct ata_link *, unsigned int *, long unsigned int);

typedef void (*ata_postreset_fn_t)(struct ata_link *, unsigned int *);

enum sw_activity {
	OFF___2 = 0,
	BLINK_ON = 1,
	BLINK_OFF = 2,
};

struct ata_ioports {
	void *cmd_addr;
	void *data_addr;
	void *error_addr;
	void *feature_addr;
	void *nsect_addr;
	void *lbal_addr;
	void *lbam_addr;
	void *lbah_addr;
	void *device_addr;
	void *status_addr;
	void *command_addr;
	void *altstatus_addr;
	void *ctl_addr;
	void *bmdma_addr;
	void *scr_addr;
};

struct ata_port_operations;

struct ata_host {
	spinlock_t lock;
	struct device *dev;
	void * const *iomap;
	unsigned int n_ports;
	unsigned int n_tags;
	void *private_data;
	struct ata_port_operations *ops;
	long unsigned int flags;
	struct kref kref;
	struct mutex eh_mutex;
	struct task_struct *eh_owner;
	struct ata_port *simplex_claimed;
	struct ata_port *ports[0];
};

struct ata_port_operations {
	int (*qc_defer)(struct ata_queued_cmd *);
	int (*check_atapi_dma)(struct ata_queued_cmd *);
	enum ata_completion_errors (*qc_prep)(struct ata_queued_cmd *);
	unsigned int (*qc_issue)(struct ata_queued_cmd *);
	bool (*qc_fill_rtf)(struct ata_queued_cmd *);
	int (*cable_detect)(struct ata_port *);
	long unsigned int (*mode_filter)(struct ata_device *, long unsigned int);
	void (*set_piomode)(struct ata_port *, struct ata_device *);
	void (*set_dmamode)(struct ata_port *, struct ata_device *);
	int (*set_mode)(struct ata_link *, struct ata_device **);
	unsigned int (*read_id)(struct ata_device *, struct ata_taskfile *, u16 *);
	void (*dev_config)(struct ata_device *);
	void (*freeze)(struct ata_port *);
	void (*thaw)(struct ata_port *);
	ata_prereset_fn_t prereset;
	ata_reset_fn_t softreset;
	ata_reset_fn_t hardreset;
	ata_postreset_fn_t postreset;
	ata_prereset_fn_t pmp_prereset;
	ata_reset_fn_t pmp_softreset;
	ata_reset_fn_t pmp_hardreset;
	ata_postreset_fn_t pmp_postreset;
	void (*error_handler)(struct ata_port *);
	void (*lost_interrupt)(struct ata_port *);
	void (*post_internal_cmd)(struct ata_queued_cmd *);
	void (*sched_eh)(struct ata_port *);
	void (*end_eh)(struct ata_port *);
	int (*scr_read)(struct ata_link *, unsigned int, u32 *);
	int (*scr_write)(struct ata_link *, unsigned int, u32);
	void (*pmp_attach)(struct ata_port *);
	void (*pmp_detach)(struct ata_port *);
	int (*set_lpm)(struct ata_link *, enum ata_lpm_policy, unsigned int);
	int (*port_suspend)(struct ata_port *, pm_message_t);
	int (*port_resume)(struct ata_port *);
	int (*port_start)(struct ata_port *);
	void (*port_stop)(struct ata_port *);
	void (*host_stop)(struct ata_host *);
	void (*sff_dev_select)(struct ata_port *, unsigned int);
	void (*sff_set_devctl)(struct ata_port *, u8);
	u8 (*sff_check_status)(struct ata_port *);
	u8 (*sff_check_altstatus)(struct ata_port *);
	void (*sff_tf_load)(struct ata_port *, const struct ata_taskfile *);
	void (*sff_tf_read)(struct ata_port *, struct ata_taskfile *);
	void (*sff_exec_command)(struct ata_port *, const struct ata_taskfile *);
	unsigned int (*sff_data_xfer)(struct ata_queued_cmd *, unsigned char *, unsigned int, int);
	void (*sff_irq_on)(struct ata_port *);
	bool (*sff_irq_check)(struct ata_port *);
	void (*sff_irq_clear)(struct ata_port *);
	void (*sff_drain_fifo)(struct ata_queued_cmd *);
	void (*bmdma_setup)(struct ata_queued_cmd *);
	void (*bmdma_start)(struct ata_queued_cmd *);
	void (*bmdma_stop)(struct ata_queued_cmd *);
	u8 (*bmdma_status)(struct ata_port *);
	ssize_t (*em_show)(struct ata_port *, char *);
	ssize_t (*em_store)(struct ata_port *, const char *, size_t);
	ssize_t (*sw_activity_show)(struct ata_device *, char *);
	ssize_t (*sw_activity_store)(struct ata_device *, enum sw_activity);
	ssize_t (*transmit_led_message)(struct ata_port *, u32, ssize_t);
	void (*phy_reset)(struct ata_port *);
	void (*eng_timeout)(struct ata_port *);
	const struct ata_port_operations *inherits;
};

struct ata_port_stats {
	long unsigned int unhandled_irq;
	long unsigned int idle_irq;
	long unsigned int rw_reqbuf;
};

struct ata_acpi_drive {
	u32 pio;
	u32 dma;
};

struct ata_acpi_gtm {
	struct ata_acpi_drive drive[2];
	u32 flags;
};

struct ata_port {
	struct Scsi_Host *scsi_host;
	struct ata_port_operations *ops;
	spinlock_t *lock;
	long unsigned int flags;
	unsigned int pflags;
	unsigned int print_id;
	unsigned int local_port_no;
	unsigned int port_no;
	struct ata_ioports ioaddr;
	u8 ctl;
	u8 last_ctl;
	struct ata_link *sff_pio_task_link;
	struct delayed_work sff_pio_task;
	struct ata_bmdma_prd *bmdma_prd;
	dma_addr_t bmdma_prd_dma;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	unsigned int cbl;
	struct ata_queued_cmd qcmd[33];
	long unsigned int sas_tag_allocated;
	u64 qc_active;
	int nr_active_links;
	unsigned int sas_last_tag;
	long: 64;
	struct ata_link link;
	struct ata_link *slave_link;
	int nr_pmp_links;
	struct ata_link *pmp_link;
	struct ata_link *excl_link;
	struct ata_port_stats stats;
	struct ata_host *host;
	struct device *dev;
	struct device tdev;
	struct mutex scsi_scan_mutex;
	struct delayed_work hotplug_task;
	struct work_struct scsi_rescan_task;
	unsigned int hsm_task_state;
	u32 msg_enable;
	struct list_head eh_done_q;
	wait_queue_head_t eh_wait_q;
	int eh_tries;
	struct completion park_req_pending;
	pm_message_t pm_mesg;
	enum ata_lpm_policy target_lpm_policy;
	struct timer_list fastdrain_timer;
	long unsigned int fastdrain_cnt;
	async_cookie_t cookie;
	int em_message_type;
	void *private_data;
	struct ata_acpi_gtm __acpi_init_gtm;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 sector_buf[512];
};

struct ata_port_info {
	long unsigned int flags;
	long unsigned int link_flags;
	long unsigned int pio_mask;
	long unsigned int mwdma_mask;
	long unsigned int udma_mask;
	struct ata_port_operations *port_ops;
	void *private_data;
};

struct ata_timing {
	short unsigned int mode;
	short unsigned int setup;
	short unsigned int act8b;
	short unsigned int rec8b;
	short unsigned int cyc8b;
	short unsigned int active;
	short unsigned int recover;
	short unsigned int dmack_hold;
	short unsigned int cycle;
	short unsigned int udma;
};

struct pci_bits {
	unsigned int reg;
	unsigned int width;
	long unsigned int mask;
	long unsigned int val;
};

enum ata_link_iter_mode {
	ATA_LITER_EDGE = 0,
	ATA_LITER_HOST_FIRST = 1,
	ATA_LITER_PMP_FIRST = 2,
};

enum ata_dev_iter_mode {
	ATA_DITER_ENABLED = 0,
	ATA_DITER_ENABLED_REVERSE = 1,
	ATA_DITER_ALL = 2,
	ATA_DITER_ALL_REVERSE = 3,
};

struct trace_event_raw_ata_qc_issue {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char cmd;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char feature;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	unsigned char proto;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_qc_complete_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char status;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char error;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int eh_action;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy_qc {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int qc_flags;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_data_offsets_ata_qc_issue {};

struct trace_event_data_offsets_ata_qc_complete_template {};

struct trace_event_data_offsets_ata_eh_link_autopsy {};

struct trace_event_data_offsets_ata_eh_link_autopsy_qc {};

typedef void (*btf_trace_ata_qc_issue)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_internal)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_failed)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_done)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_eh_link_autopsy)(void *, struct ata_device *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_eh_link_autopsy_qc)(void *, struct ata_queued_cmd *);

enum {
	ATA_READID_POSTRESET = 1,
	ATA_DNXFER_PIO = 0,
	ATA_DNXFER_DMA = 1,
	ATA_DNXFER_40C = 2,
	ATA_DNXFER_FORCE_PIO = 3,
	ATA_DNXFER_FORCE_PIO0 = 4,
	ATA_DNXFER_QUIET = 2147483648,
};

struct ata_force_param {
	const char *name;
	u8 cbl;
	u8 spd_limit;
	long unsigned int xfer_mask;
	unsigned int horkage_on;
	unsigned int horkage_off;
	u16 lflags;
};

struct ata_force_ent {
	int port;
	int device;
	struct ata_force_param param;
};

struct ata_xfer_ent {
	int shift;
	int bits;
	u8 base;
};

struct ata_blacklist_entry {
	const char *model_num;
	const char *model_rev;
	long unsigned int horkage;
};

typedef unsigned int (*ata_xlat_func_t)(struct ata_queued_cmd *);

struct ata_scsi_args {
	struct ata_device *dev;
	u16 *id;
	struct scsi_cmnd *cmd;
};

enum ata_lpm_hints {
	ATA_LPM_EMPTY = 1,
	ATA_LPM_HIPM = 2,
	ATA_LPM_WAKE_ONLY = 4,
};

enum {
	ATA_EH_SPDN_NCQ_OFF = 1,
	ATA_EH_SPDN_SPEED_DOWN = 2,
	ATA_EH_SPDN_FALLBACK_TO_PIO = 4,
	ATA_EH_SPDN_KEEP_ERRORS = 8,
	ATA_EFLAG_IS_IO = 1,
	ATA_EFLAG_DUBIOUS_XFER = 2,
	ATA_EFLAG_OLD_ER = 2147483648,
	ATA_ECAT_NONE = 0,
	ATA_ECAT_ATA_BUS = 1,
	ATA_ECAT_TOUT_HSM = 2,
	ATA_ECAT_UNK_DEV = 3,
	ATA_ECAT_DUBIOUS_NONE = 4,
	ATA_ECAT_DUBIOUS_ATA_BUS = 5,
	ATA_ECAT_DUBIOUS_TOUT_HSM = 6,
	ATA_ECAT_DUBIOUS_UNK_DEV = 7,
	ATA_ECAT_NR = 8,
	ATA_EH_CMD_DFL_TIMEOUT = 5000,
	ATA_EH_RESET_COOL_DOWN = 5000,
	ATA_EH_PRERESET_TIMEOUT = 10000,
	ATA_EH_FASTDRAIN_INTERVAL = 3000,
	ATA_EH_UA_TRIES = 5,
	ATA_EH_PROBE_TRIAL_INTERVAL = 60000,
	ATA_EH_PROBE_TRIALS = 2,
};

struct ata_eh_cmd_timeout_ent {
	const u8 *commands;
	const long unsigned int *timeouts;
};

struct speed_down_verdict_arg {
	u64 since;
	int xfer_ok;
	int nr_errors[8];
};

struct ata_internal {
	struct scsi_transport_template t;
	struct device_attribute private_port_attrs[3];
	struct device_attribute private_link_attrs[3];
	struct device_attribute private_dev_attrs[9];
	struct transport_container link_attr_cont;
	struct transport_container dev_attr_cont;
	struct device_attribute *link_attrs[4];
	struct device_attribute *port_attrs[4];
	struct device_attribute *dev_attrs[10];
};

struct ata_show_ering_arg {
	char *buf;
	int written;
};

enum hsm_task_states {
	HSM_ST_IDLE = 0,
	HSM_ST_FIRST = 1,
	HSM_ST = 2,
	HSM_ST_LAST = 3,
	HSM_ST_ERR = 4,
};

struct ata_acpi_gtf {
	u8 tf[7];
};

struct ata_acpi_hotplug_context {
	struct acpi_hotplug_context hp;
	union {
		struct ata_port *ap;
		struct ata_device *dev;
	} data;
};

struct rm_feature_desc {
	__be16 feature_code;
	__u8 curr: 1;
	__u8 persistent: 1;
	__u8 feature_version: 4;
	__u8 reserved1: 2;
	__u8 add_len;
	__u8 lock: 1;
	__u8 dbml: 1;
	__u8 pvnt_jmpr: 1;
	__u8 eject: 1;
	__u8 load: 1;
	__u8 mech_type: 3;
	__u8 reserved2;
	__u8 reserved3;
	__u8 reserved4;
};

enum odd_mech_type {
	ODD_MECH_TYPE_SLOT = 0,
	ODD_MECH_TYPE_DRAWER = 1,
	ODD_MECH_TYPE_UNSUPPORTED = 2,
};

struct zpodd {
	enum odd_mech_type mech_type;
	struct ata_device *dev;
	bool from_notify;
	bool zp_ready;
	long unsigned int last_ready;
	bool zp_sampled;
	bool powered_off;
};

struct sensor_device_attribute {
	struct device_attribute dev_attr;
	int index;
};

struct thermal_zone_of_device_ops {
	int (*get_temp)(void *, int *);
	int (*get_trend)(void *, int, enum thermal_trend *);
	int (*set_trips)(void *, int, int);
	int (*set_emul_temp)(void *, int);
	int (*set_trip_temp)(void *, int, int);
};

enum {
	AHCI_MAX_PORTS = 32,
	AHCI_MAX_CLKS = 5,
	AHCI_MAX_SG = 168,
	AHCI_DMA_BOUNDARY = 4294967295,
	AHCI_MAX_CMDS = 32,
	AHCI_CMD_SZ = 32,
	AHCI_CMD_SLOT_SZ = 1024,
	AHCI_RX_FIS_SZ = 256,
	AHCI_CMD_TBL_CDB = 64,
	AHCI_CMD_TBL_HDR_SZ = 128,
	AHCI_CMD_TBL_SZ = 2816,
	AHCI_CMD_TBL_AR_SZ = 90112,
	AHCI_PORT_PRIV_DMA_SZ = 91392,
	AHCI_PORT_PRIV_FBS_DMA_SZ = 95232,
	AHCI_IRQ_ON_SG = 2147483648,
	AHCI_CMD_ATAPI = 32,
	AHCI_CMD_WRITE = 64,
	AHCI_CMD_PREFETCH = 128,
	AHCI_CMD_RESET = 256,
	AHCI_CMD_CLR_BUSY = 1024,
	RX_FIS_PIO_SETUP = 32,
	RX_FIS_D2H_REG = 64,
	RX_FIS_SDB = 88,
	RX_FIS_UNK = 96,
	HOST_CAP = 0,
	HOST_CTL = 4,
	HOST_IRQ_STAT = 8,
	HOST_PORTS_IMPL = 12,
	HOST_VERSION = 16,
	HOST_EM_LOC = 28,
	HOST_EM_CTL = 32,
	HOST_CAP2 = 36,
	HOST_RESET = 1,
	HOST_IRQ_EN = 2,
	HOST_MRSM = 4,
	HOST_AHCI_EN = 2147483648,
	HOST_CAP_SXS = 32,
	HOST_CAP_EMS = 64,
	HOST_CAP_CCC = 128,
	HOST_CAP_PART = 8192,
	HOST_CAP_SSC = 16384,
	HOST_CAP_PIO_MULTI = 32768,
	HOST_CAP_FBS = 65536,
	HOST_CAP_PMP = 131072,
	HOST_CAP_ONLY = 262144,
	HOST_CAP_CLO = 16777216,
	HOST_CAP_LED = 33554432,
	HOST_CAP_ALPM = 67108864,
	HOST_CAP_SSS = 134217728,
	HOST_CAP_MPS = 268435456,
	HOST_CAP_SNTF = 536870912,
	HOST_CAP_NCQ = 1073741824,
	HOST_CAP_64 = 2147483648,
	HOST_CAP2_BOH = 1,
	HOST_CAP2_NVMHCI = 2,
	HOST_CAP2_APST = 4,
	HOST_CAP2_SDS = 8,
	HOST_CAP2_SADM = 16,
	HOST_CAP2_DESO = 32,
	PORT_LST_ADDR = 0,
	PORT_LST_ADDR_HI = 4,
	PORT_FIS_ADDR = 8,
	PORT_FIS_ADDR_HI = 12,
	PORT_IRQ_STAT = 16,
	PORT_IRQ_MASK = 20,
	PORT_CMD = 24,
	PORT_TFDATA = 32,
	PORT_SIG = 36,
	PORT_CMD_ISSUE = 56,
	PORT_SCR_STAT = 40,
	PORT_SCR_CTL = 44,
	PORT_SCR_ERR = 48,
	PORT_SCR_ACT = 52,
	PORT_SCR_NTF = 60,
	PORT_FBS = 64,
	PORT_DEVSLP = 68,
	PORT_IRQ_COLD_PRES = 2147483648,
	PORT_IRQ_TF_ERR = 1073741824,
	PORT_IRQ_HBUS_ERR = 536870912,
	PORT_IRQ_HBUS_DATA_ERR = 268435456,
	PORT_IRQ_IF_ERR = 134217728,
	PORT_IRQ_IF_NONFATAL = 67108864,
	PORT_IRQ_OVERFLOW = 16777216,
	PORT_IRQ_BAD_PMP = 8388608,
	PORT_IRQ_PHYRDY = 4194304,
	PORT_IRQ_DEV_ILCK = 128,
	PORT_IRQ_CONNECT = 64,
	PORT_IRQ_SG_DONE = 32,
	PORT_IRQ_UNK_FIS = 16,
	PORT_IRQ_SDB_FIS = 8,
	PORT_IRQ_DMAS_FIS = 4,
	PORT_IRQ_PIOS_FIS = 2,
	PORT_IRQ_D2H_REG_FIS = 1,
	PORT_IRQ_FREEZE = 683671632,
	PORT_IRQ_ERROR = 2025848912,
	DEF_PORT_IRQ = 2025848959,
	PORT_CMD_ASP = 134217728,
	PORT_CMD_ALPE = 67108864,
	PORT_CMD_ATAPI = 16777216,
	PORT_CMD_FBSCP = 4194304,
	PORT_CMD_ESP = 2097152,
	PORT_CMD_HPCP = 262144,
	PORT_CMD_PMP = 131072,
	PORT_CMD_LIST_ON = 32768,
	PORT_CMD_FIS_ON = 16384,
	PORT_CMD_FIS_RX = 16,
	PORT_CMD_CLO = 8,
	PORT_CMD_POWER_ON = 4,
	PORT_CMD_SPIN_UP = 2,
	PORT_CMD_START = 1,
	PORT_CMD_ICC_MASK = 4026531840,
	PORT_CMD_ICC_ACTIVE = 268435456,
	PORT_CMD_ICC_PARTIAL = 536870912,
	PORT_CMD_ICC_SLUMBER = 1610612736,
	PORT_FBS_DWE_OFFSET = 16,
	PORT_FBS_ADO_OFFSET = 12,
	PORT_FBS_DEV_OFFSET = 8,
	PORT_FBS_DEV_MASK = 3840,
	PORT_FBS_SDE = 4,
	PORT_FBS_DEC = 2,
	PORT_FBS_EN = 1,
	PORT_DEVSLP_DM_OFFSET = 25,
	PORT_DEVSLP_DM_MASK = 503316480,
	PORT_DEVSLP_DITO_OFFSET = 15,
	PORT_DEVSLP_MDAT_OFFSET = 10,
	PORT_DEVSLP_DETO_OFFSET = 2,
	PORT_DEVSLP_DSP = 2,
	PORT_DEVSLP_ADSE = 1,
	AHCI_HFLAG_NO_NCQ = 1,
	AHCI_HFLAG_IGN_IRQ_IF_ERR = 2,
	AHCI_HFLAG_IGN_SERR_INTERNAL = 4,
	AHCI_HFLAG_32BIT_ONLY = 8,
	AHCI_HFLAG_MV_PATA = 16,
	AHCI_HFLAG_NO_MSI = 32,
	AHCI_HFLAG_NO_PMP = 64,
	AHCI_HFLAG_SECT255 = 256,
	AHCI_HFLAG_YES_NCQ = 512,
	AHCI_HFLAG_NO_SUSPEND = 1024,
	AHCI_HFLAG_SRST_TOUT_IS_OFFLINE = 2048,
	AHCI_HFLAG_NO_SNTF = 4096,
	AHCI_HFLAG_NO_FPDMA_AA = 8192,
	AHCI_HFLAG_YES_FBS = 16384,
	AHCI_HFLAG_DELAY_ENGINE = 32768,
	AHCI_HFLAG_NO_DEVSLP = 131072,
	AHCI_HFLAG_NO_FBS = 262144,
	AHCI_HFLAG_MULTI_MSI = 1048576,
	AHCI_HFLAG_WAKE_BEFORE_STOP = 4194304,
	AHCI_HFLAG_YES_ALPM = 8388608,
	AHCI_HFLAG_NO_WRITE_TO_RO = 16777216,
	AHCI_HFLAG_IS_MOBILE = 33554432,
	AHCI_HFLAG_SUSPEND_PHYS = 67108864,
	AHCI_HFLAG_IGN_NOTSUPP_POWER_ON = 134217728,
	AHCI_HFLAG_NO_SXS = 268435456,
	AHCI_FLAG_COMMON = 393346,
	ICH_MAP = 144,
	PCS_6 = 146,
	PCS_7 = 148,
	EM_MAX_SLOTS = 8,
	EM_MAX_RETRY = 5,
	EM_CTL_RST = 512,
	EM_CTL_TM = 256,
	EM_CTL_MR = 1,
	EM_CTL_ALHD = 67108864,
	EM_CTL_XMT = 33554432,
	EM_CTL_SMB = 16777216,
	EM_CTL_SGPIO = 524288,
	EM_CTL_SES = 262144,
	EM_CTL_SAFTE = 131072,
	EM_CTL_LED = 65536,
	EM_MSG_TYPE_LED = 1,
	EM_MSG_TYPE_SAFTE = 2,
	EM_MSG_TYPE_SES2 = 4,
	EM_MSG_TYPE_SGPIO = 8,
};

struct ahci_host_priv {
	unsigned int flags;
	u32 force_port_map;
	u32 mask_port_map;
	void *mmio;
	u32 cap;
	u32 cap2;
	u32 version;
	u32 port_map;
	u32 saved_cap;
	u32 saved_cap2;
	u32 saved_port_map;
	u32 em_loc;
	u32 em_buf_sz;
	u32 em_msg_type;
	u32 remapped_nvme;
	bool got_runtime_pm;
	struct clk *clks[5];
	struct reset_control *rsts;
	struct regulator **target_pwrs;
	struct regulator *ahci_regulator;
	struct regulator *phy_regulator;
	struct phy **phys;
	unsigned int nports;
	void *plat_data;
	unsigned int irq;
	void (*start_engine)(struct ata_port *);
	int (*stop_engine)(struct ata_port *);
	irqreturn_t (*irq_handler)(int, void *);
	int (*get_irq_vector)(struct ata_host *, int);
};

enum {
	IMX_TIMER1MS = 224,
	IMX_P0PHYCR = 376,
	IMX_P0PHYCR_TEST_PDDQ = 1048576,
	IMX_P0PHYCR_CR_READ = 524288,
	IMX_P0PHYCR_CR_WRITE = 262144,
	IMX_P0PHYCR_CR_CAP_DATA = 131072,
	IMX_P0PHYCR_CR_CAP_ADDR = 65536,
	IMX_P0PHYSR = 380,
	IMX_P0PHYSR_CR_ACK = 262144,
	IMX_P0PHYSR_CR_DATA_OUT = 65535,
	IMX_LANE0_OUT_STAT = 8195,
	IMX_LANE0_OUT_STAT_RX_PLL_STATE = 2,
	IMX_CLOCK_RESET = 32575,
	IMX_CLOCK_RESET_RESET = 1,
	IMX8QM_SATA_PHY_RX_IMPED_RATIO_OFFSET = 3,
	IMX8QM_SATA_PHY_TX_IMPED_RATIO_OFFSET = 9,
	IMX8QM_SATA_PHY_IMPED_RATIO_85OHM = 108,
	IMX8QM_LPCG_PHYX2_OFFSET = 0,
	IMX8QM_CSR_PHYX2_OFFSET = 589824,
	IMX8QM_CSR_PHYX1_OFFSET = 655360,
	IMX8QM_CSR_PHYX_STTS0_OFFSET = 4,
	IMX8QM_CSR_PCIEA_OFFSET = 720896,
	IMX8QM_CSR_PCIEB_OFFSET = 786432,
	IMX8QM_CSR_SATA_OFFSET = 851968,
	IMX8QM_CSR_PCIE_CTRL2_OFFSET = 8,
	IMX8QM_CSR_MISC_OFFSET = 917504,
	IMX8QM_LPCG_PHYX2_PCLK0_MASK = 196608,
	IMX8QM_LPCG_PHYX2_PCLK1_MASK = 3145728,
	IMX8QM_PHY_APB_RSTN_0 = 1,
	IMX8QM_PHY_MODE_SATA = 524288,
	IMX8QM_PHY_MODE_MASK = 1966080,
	IMX8QM_PHY_PIPE_RSTN_0 = 16777216,
	IMX8QM_PHY_PIPE_RSTN_OVERRIDE_0 = 33554432,
	IMX8QM_PHY_PIPE_RSTN_1 = 67108864,
	IMX8QM_PHY_PIPE_RSTN_OVERRIDE_1 = 134217728,
	IMX8QM_STTS0_LANE0_TX_PLL_LOCK = 16,
	IMX8QM_MISC_IOB_RXENA = 1,
	IMX8QM_MISC_IOB_TXENA = 2,
	IMX8QM_MISC_PHYX1_EPCS_SEL = 4096,
	IMX8QM_MISC_CLKREQN_OUT_OVERRIDE_1 = 16777216,
	IMX8QM_MISC_CLKREQN_OUT_OVERRIDE_0 = 33554432,
	IMX8QM_MISC_CLKREQN_IN_OVERRIDE_1 = 268435456,
	IMX8QM_MISC_CLKREQN_IN_OVERRIDE_0 = 536870912,
	IMX8QM_SATA_CTRL_RESET_N = 4096,
	IMX8QM_SATA_CTRL_EPCS_PHYRESET_N = 128,
	IMX8QM_CTRL_BUTTON_RST_N = 2097152,
	IMX8QM_CTRL_POWER_UP_RST_N = 8388608,
	IMX8QM_CTRL_LTSSM_ENABLE = 16,
};

enum ahci_imx_type {
	AHCI_IMX53 = 0,
	AHCI_IMX6Q = 1,
	AHCI_IMX6QP = 2,
	AHCI_IMX8QM = 3,
};

struct imx_ahci_priv {
	struct platform_device *ahci_pdev;
	enum ahci_imx_type type;
	struct clk *sata_clk;
	struct clk *sata_ref_clk;
	struct clk *ahb_clk;
	struct clk *epcs_tx_clk;
	struct clk *epcs_rx_clk;
	struct clk *phy_apbclk;
	struct clk *phy_pclk0;
	struct clk *phy_pclk1;
	void *phy_base;
	struct gpio_desc *clkreq_gpiod;
	struct regmap *gpr;
	bool no_device;
	bool first_time;
	u32 phy_params;
	u32 imped_ratio;
};

enum {
	SATA_PHY_CR_CLOCK_CRCMP_LT_LIMIT = 1,
	SATA_PHY_CR_CLOCK_DAC_CTL = 8,
	SATA_PHY_CR_CLOCK_RTUNE_CTL = 9,
	SATA_PHY_CR_CLOCK_ADC_OUT = 10,
	SATA_PHY_CR_CLOCK_MPLL_TST = 23,
};

struct reg_value {
	u32 of_value;
	u32 reg_value;
};

struct reg_property {
	const char *name;
	const struct reg_value *values;
	size_t num_values;
	u32 def_value;
	u32 set_value;
};

struct ahci_cmd_hdr {
	__le32 opts;
	__le32 status;
	__le32 tbl_addr;
	__le32 tbl_addr_hi;
	__le32 reserved[4];
};

struct ahci_sg {
	__le32 addr;
	__le32 addr_hi;
	__le32 reserved;
	__le32 flags_size;
};

struct ahci_em_priv {
	enum sw_activity blink_policy;
	struct timer_list timer;
	long unsigned int saved_activity;
	long unsigned int activity;
	long unsigned int led_state;
	struct ata_link *link;
};

struct ahci_port_priv {
	struct ata_link *active_link;
	struct ahci_cmd_hdr *cmd_slot;
	dma_addr_t cmd_slot_dma;
	void *cmd_tbl;
	dma_addr_t cmd_tbl_dma;
	void *rx_fis;
	dma_addr_t rx_fis_dma;
	unsigned int ncq_saw_d2h: 1;
	unsigned int ncq_saw_dmas: 1;
	unsigned int ncq_saw_sdb: 1;
	spinlock_t lock;
	u32 intr_mask;
	bool fbs_supported;
	bool fbs_enabled;
	int fbs_last_dev;
	struct ahci_em_priv em_priv[8];
	char *irq_desc;
};

struct mipi_dsi_msg {
	u8 channel;
	u8 type;
	u16 flags;
	size_t tx_len;
	const void *tx_buf;
	size_t rx_len;
	void *rx_buf;
};

struct mipi_dsi_packet {
	size_t size;
	u8 header[4];
	size_t payload_length;
	const u8 *payload;
};

struct mipi_dsi_host;

struct mipi_dsi_device;

struct mipi_dsi_host_ops {
	int (*attach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	int (*detach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	ssize_t (*transfer)(struct mipi_dsi_host *, const struct mipi_dsi_msg *);
};

struct mipi_dsi_host {
	struct device *dev;
	const struct mipi_dsi_host_ops *ops;
	struct list_head list;
};

enum mipi_dsi_pixel_format {
	MIPI_DSI_FMT_RGB888 = 0,
	MIPI_DSI_FMT_RGB666 = 1,
	MIPI_DSI_FMT_RGB666_PACKED = 2,
	MIPI_DSI_FMT_RGB565 = 3,
};

struct mipi_dsi_device {
	struct mipi_dsi_host *host;
	struct device dev;
	char name[20];
	unsigned int channel;
	unsigned int lanes;
	enum mipi_dsi_pixel_format format;
	long unsigned int mode_flags;
	long unsigned int hs_rate;
	long unsigned int lp_rate;
};

struct mipi_dsi_device_info {
	char type[20];
	u32 channel;
	struct device_node *node;
};

enum mipi_dsi_dcs_tear_mode {
	MIPI_DSI_DCS_TEAR_MODE_VBLANK = 0,
	MIPI_DSI_DCS_TEAR_MODE_VHBLANK = 1,
};

struct mipi_dsi_driver {
	struct device_driver driver;
	int (*probe)(struct mipi_dsi_device *);
	int (*remove)(struct mipi_dsi_device *);
	void (*shutdown)(struct mipi_dsi_device *);
};

struct drm_dsc_picture_parameter_set {
	u8 dsc_version;
	u8 pps_identifier;
	u8 pps_reserved;
	u8 pps_3;
	u8 pps_4;
	u8 bits_per_pixel_low;
	__be16 pic_height;
	__be16 pic_width;
	__be16 slice_height;
	__be16 slice_width;
	__be16 chunk_size;
	u8 initial_xmit_delay_high;
	u8 initial_xmit_delay_low;
	__be16 initial_dec_delay;
	u8 pps20_reserved;
	u8 initial_scale_value;
	__be16 scale_increment_interval;
	u8 scale_decrement_interval_high;
	u8 scale_decrement_interval_low;
	u8 pps26_reserved;
	u8 first_line_bpg_offset;
	__be16 nfl_bpg_offset;
	__be16 slice_bpg_offset;
	__be16 initial_offset;
	__be16 final_offset;
	u8 flatness_min_qp;
	u8 flatness_max_qp;
	__be16 rc_model_size;
	u8 rc_edge_factor;
	u8 rc_quant_incr_limit0;
	u8 rc_quant_incr_limit1;
	u8 rc_tgt_offset;
	u8 rc_buf_thresh[14];
	__be16 rc_range_parameters[15];
	u8 native_422_420;
	u8 second_line_bpg_offset;
	__be16 nsl_bpg_offset;
	__be16 second_line_offset_adj;
	u32 pps_long_94_reserved;
	u32 pps_long_98_reserved;
	u32 pps_long_102_reserved;
	u32 pps_long_106_reserved;
	u32 pps_long_110_reserved;
	u32 pps_long_114_reserved;
	u32 pps_long_118_reserved;
	u32 pps_long_122_reserved;
	__be16 pps_short_126_reserved;
} __attribute__((packed));

enum {
	MIPI_DSI_V_SYNC_START = 1,
	MIPI_DSI_V_SYNC_END = 17,
	MIPI_DSI_H_SYNC_START = 33,
	MIPI_DSI_H_SYNC_END = 49,
	MIPI_DSI_COMPRESSION_MODE = 7,
	MIPI_DSI_END_OF_TRANSMISSION = 8,
	MIPI_DSI_COLOR_MODE_OFF = 2,
	MIPI_DSI_COLOR_MODE_ON = 18,
	MIPI_DSI_SHUTDOWN_PERIPHERAL = 34,
	MIPI_DSI_TURN_ON_PERIPHERAL = 50,
	MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM = 3,
	MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM = 19,
	MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM = 35,
	MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM = 4,
	MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM = 20,
	MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM = 36,
	MIPI_DSI_DCS_SHORT_WRITE = 5,
	MIPI_DSI_DCS_SHORT_WRITE_PARAM = 21,
	MIPI_DSI_DCS_READ = 6,
	MIPI_DSI_EXECUTE_QUEUE = 22,
	MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE = 55,
	MIPI_DSI_NULL_PACKET = 9,
	MIPI_DSI_BLANKING_PACKET = 25,
	MIPI_DSI_GENERIC_LONG_WRITE = 41,
	MIPI_DSI_DCS_LONG_WRITE = 57,
	MIPI_DSI_PICTURE_PARAMETER_SET = 10,
	MIPI_DSI_COMPRESSED_PIXEL_STREAM = 11,
	MIPI_DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20 = 12,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR24 = 28,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16 = 44,
	MIPI_DSI_PACKED_PIXEL_STREAM_30 = 13,
	MIPI_DSI_PACKED_PIXEL_STREAM_36 = 29,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12 = 61,
	MIPI_DSI_PACKED_PIXEL_STREAM_16 = 14,
	MIPI_DSI_PACKED_PIXEL_STREAM_18 = 30,
	MIPI_DSI_PIXEL_STREAM_3BYTE_18 = 46,
	MIPI_DSI_PACKED_PIXEL_STREAM_24 = 62,
};

enum {
	MIPI_DCS_NOP = 0,
	MIPI_DCS_SOFT_RESET = 1,
	MIPI_DCS_GET_COMPRESSION_MODE = 3,
	MIPI_DCS_GET_DISPLAY_ID = 4,
	MIPI_DCS_GET_ERROR_COUNT_ON_DSI = 5,
	MIPI_DCS_GET_RED_CHANNEL = 6,
	MIPI_DCS_GET_GREEN_CHANNEL = 7,
	MIPI_DCS_GET_BLUE_CHANNEL = 8,
	MIPI_DCS_GET_DISPLAY_STATUS = 9,
	MIPI_DCS_GET_POWER_MODE = 10,
	MIPI_DCS_GET_ADDRESS_MODE = 11,
	MIPI_DCS_GET_PIXEL_FORMAT = 12,
	MIPI_DCS_GET_DISPLAY_MODE = 13,
	MIPI_DCS_GET_SIGNAL_MODE = 14,
	MIPI_DCS_GET_DIAGNOSTIC_RESULT = 15,
	MIPI_DCS_ENTER_SLEEP_MODE = 16,
	MIPI_DCS_EXIT_SLEEP_MODE = 17,
	MIPI_DCS_ENTER_PARTIAL_MODE = 18,
	MIPI_DCS_ENTER_NORMAL_MODE = 19,
	MIPI_DCS_GET_IMAGE_CHECKSUM_RGB = 20,
	MIPI_DCS_GET_IMAGE_CHECKSUM_CT = 21,
	MIPI_DCS_EXIT_INVERT_MODE = 32,
	MIPI_DCS_ENTER_INVERT_MODE = 33,
	MIPI_DCS_SET_GAMMA_CURVE = 38,
	MIPI_DCS_SET_DISPLAY_OFF = 40,
	MIPI_DCS_SET_DISPLAY_ON = 41,
	MIPI_DCS_SET_COLUMN_ADDRESS = 42,
	MIPI_DCS_SET_PAGE_ADDRESS = 43,
	MIPI_DCS_WRITE_MEMORY_START = 44,
	MIPI_DCS_WRITE_LUT = 45,
	MIPI_DCS_READ_MEMORY_START = 46,
	MIPI_DCS_SET_PARTIAL_ROWS = 48,
	MIPI_DCS_SET_PARTIAL_COLUMNS = 49,
	MIPI_DCS_SET_SCROLL_AREA = 51,
	MIPI_DCS_SET_TEAR_OFF = 52,
	MIPI_DCS_SET_TEAR_ON = 53,
	MIPI_DCS_SET_ADDRESS_MODE = 54,
	MIPI_DCS_SET_SCROLL_START = 55,
	MIPI_DCS_EXIT_IDLE_MODE = 56,
	MIPI_DCS_ENTER_IDLE_MODE = 57,
	MIPI_DCS_SET_PIXEL_FORMAT = 58,
	MIPI_DCS_WRITE_MEMORY_CONTINUE = 60,
	MIPI_DCS_SET_3D_CONTROL = 61,
	MIPI_DCS_READ_MEMORY_CONTINUE = 62,
	MIPI_DCS_GET_3D_CONTROL = 63,
	MIPI_DCS_SET_VSYNC_TIMING = 64,
	MIPI_DCS_SET_TEAR_SCANLINE = 68,
	MIPI_DCS_GET_SCANLINE = 69,
	MIPI_DCS_SET_DISPLAY_BRIGHTNESS = 81,
	MIPI_DCS_GET_DISPLAY_BRIGHTNESS = 82,
	MIPI_DCS_WRITE_CONTROL_DISPLAY = 83,
	MIPI_DCS_GET_CONTROL_DISPLAY = 84,
	MIPI_DCS_WRITE_POWER_SAVE = 85,
	MIPI_DCS_GET_POWER_SAVE = 86,
	MIPI_DCS_SET_CABC_MIN_BRIGHTNESS = 94,
	MIPI_DCS_GET_CABC_MIN_BRIGHTNESS = 95,
	MIPI_DCS_READ_DDB_START = 161,
	MIPI_DCS_READ_PPS_START = 162,
	MIPI_DCS_READ_DDB_CONTINUE = 168,
	MIPI_DCS_READ_PPS_CONTINUE = 169,
};

struct drm_dmi_panel_orientation_data {
	int width;
	int height;
	const char * const *bios_dates;
	int orientation;
};

struct vga_device {
	struct list_head list;
	struct pci_dev *pdev;
	unsigned int decodes;
	unsigned int owns;
	unsigned int locks;
	unsigned int io_lock_cnt;
	unsigned int mem_lock_cnt;
	unsigned int io_norm_cnt;
	unsigned int mem_norm_cnt;
	bool bridge_has_one_vga;
	void *cookie;
	void (*irq_set_state)(void *, bool);
	unsigned int (*set_vga_decode)(void *, bool);
};

struct vga_arb_user_card {
	struct pci_dev *pdev;
	unsigned int mem_cnt;
	unsigned int io_cnt;
};

struct vga_arb_private {
	struct list_head list;
	struct pci_dev *target;
	struct vga_arb_user_card cards[16];
	spinlock_t lock;
};

typedef void (*spi_res_release_t)(struct spi_controller *, struct spi_message *, void *);

struct spi_res {
	struct list_head entry;
	spi_res_release_t release;
	long long unsigned int data[0];
};

struct spi_replaced_transfers;

typedef void (*spi_replaced_release_t)(struct spi_controller *, struct spi_message *, struct spi_replaced_transfers *);

struct spi_replaced_transfers {
	spi_replaced_release_t release;
	void *extradata;
	struct list_head replaced_transfers;
	struct list_head *replaced_after;
	size_t inserted;
	struct spi_transfer inserted_transfers[0];
};

struct spi_board_info {
	char modalias[32];
	const void *platform_data;
	const struct software_node *swnode;
	void *controller_data;
	int irq;
	u32 max_speed_hz;
	u16 bus_num;
	u16 chip_select;
	u32 mode;
};

enum spi_mem_data_dir {
	SPI_MEM_NO_DATA = 0,
	SPI_MEM_DATA_IN = 1,
	SPI_MEM_DATA_OUT = 2,
};

struct spi_mem_op {
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		u16 opcode;
	} cmd;
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		u64 val;
	} addr;
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
	} dummy;
	struct {
		u8 buswidth;
		u8 dtr: 1;
		enum spi_mem_data_dir dir;
		unsigned int nbytes;
		union {
			void *in;
			const void *out;
		} buf;
	} data;
};

struct spi_mem_dirmap_info {
	struct spi_mem_op op_tmpl;
	u64 offset;
	u64 length;
};

struct spi_mem_dirmap_desc {
	struct spi_mem *mem;
	struct spi_mem_dirmap_info info;
	unsigned int nodirmap;
	void *priv;
};

struct spi_mem {
	struct spi_device *spi;
	void *drvpriv;
	const char *name;
};

struct trace_event_raw_spi_controller {
	struct trace_entry ent;
	int bus_num;
	char __data[0];
};

struct trace_event_raw_spi_message {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_message *msg;
	char __data[0];
};

struct trace_event_raw_spi_message_done {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_message *msg;
	unsigned int frame;
	unsigned int actual;
	char __data[0];
};

struct trace_event_raw_spi_transfer {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_transfer *xfer;
	int len;
	u32 __data_loc_rx_buf;
	u32 __data_loc_tx_buf;
	char __data[0];
};

struct trace_event_data_offsets_spi_controller {};

struct trace_event_data_offsets_spi_message {};

struct trace_event_data_offsets_spi_message_done {};

struct trace_event_data_offsets_spi_transfer {
	u32 rx_buf;
	u32 tx_buf;
};

typedef void (*btf_trace_spi_controller_idle)(void *, struct spi_controller *);

typedef void (*btf_trace_spi_controller_busy)(void *, struct spi_controller *);

typedef void (*btf_trace_spi_message_submit)(void *, struct spi_message *);

typedef void (*btf_trace_spi_message_start)(void *, struct spi_message *);

typedef void (*btf_trace_spi_message_done)(void *, struct spi_message *);

typedef void (*btf_trace_spi_transfer_start)(void *, struct spi_message *, struct spi_transfer *);

typedef void (*btf_trace_spi_transfer_stop)(void *, struct spi_message *, struct spi_transfer *);

struct boardinfo {
	struct list_head list;
	struct spi_board_info board_info;
};

struct acpi_spi_lookup {
	struct spi_controller *ctlr;
	u32 max_speed_hz;
	u32 mode;
	int irq;
	u8 bits_per_word;
	u8 chip_select;
};

struct spi_mem_driver {
	struct spi_driver spidrv;
	int (*probe)(struct spi_mem *);
	int (*remove)(struct spi_mem *);
	void (*shutdown)(struct spi_mem *);
};

struct fsl_spi_platform_data {
	u32 initial_spmode;
	s16 bus_num;
	unsigned int flags;
	u16 max_chipselect;
	void (*cs_control)(struct spi_device *, bool);
	u32 sysclk;
};

struct spi_pram;

struct mpc8xxx_spi {
	struct device *dev;
	void *reg_base;
	const void *tx;
	void *rx;
	int subblock;
	struct spi_pram *pram;
	struct spi_transfer *xfer_in_progress;
	dma_addr_t tx_dma;
	dma_addr_t rx_dma;
	bool map_tx_dma;
	bool map_rx_dma;
	dma_addr_t dma_dummy_tx;
	dma_addr_t dma_dummy_rx;
	void (*get_rx)(u32, struct mpc8xxx_spi *);
	u32 (*get_tx)(struct mpc8xxx_spi *);
	unsigned int count;
	unsigned int irq;
	unsigned int nsecs;
	u32 spibrg;
	u32 rx_shift;
	u32 tx_shift;
	unsigned int flags;
	int type;
	int native_chipselects;
	u8 max_bits_per_word;
	void (*set_shifts)(u32 *, u32 *, int, int);
	struct completion done;
};

struct mpc8xxx_spi_probe_info {
	struct fsl_spi_platform_data pdata;
	__be32 *immr_spi_cs;
};

struct spi_mpc8xxx_cs {
	void (*get_rx)(u32, struct mpc8xxx_spi *);
	u32 (*get_tx)(struct mpc8xxx_spi *);
	u32 rx_shift;
	u32 tx_shift;
	u32 hw_mode;
};

struct fsl_spi_reg {
	__be32 cap;
	u8 res1[28];
	__be32 mode;
	__be32 event;
	__be32 mask;
	__be32 command;
	__be32 transmit;
	__be32 receive;
	__be32 slvsel;
};

struct fsl_spi_match_data {
	int type;
};

struct omap2_mcspi_platform_config {
	short unsigned int num_cs;
	unsigned int regs_offset;
	unsigned int pin_dir: 1;
	size_t max_xfer_len;
};

struct omap2_mcspi_device_config {
	unsigned int turbo_mode: 1;
	unsigned int cs_per_word: 1;
};

struct omap2_mcspi_dma {
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	struct completion dma_tx_completion;
	struct completion dma_rx_completion;
	char dma_rx_ch_name[14];
	char dma_tx_ch_name[14];
};

struct omap2_mcspi_regs {
	u32 modulctrl;
	u32 wakeupenable;
	struct list_head cs;
};

struct omap2_mcspi {
	struct completion txdone;
	struct spi_controller *master;
	void *base;
	long unsigned int phys;
	struct omap2_mcspi_dma *dma_channels;
	struct device *dev;
	struct omap2_mcspi_regs ctx;
	int fifo_depth;
	bool slave_aborted;
	unsigned int pin_dir: 1;
	size_t max_xfer_len;
};

struct omap2_mcspi_cs {
	void *base;
	long unsigned int phys;
	int word_len;
	u16 mode;
	struct list_head node;
	u32 chconf0;
	u32 chctrl0;
};

enum netdev_state_t {
	__LINK_STATE_START = 0,
	__LINK_STATE_PRESENT = 1,
	__LINK_STATE_NOCARRIER = 2,
	__LINK_STATE_LINKWATCH_PENDING = 3,
	__LINK_STATE_DORMANT = 4,
	__LINK_STATE_TESTING = 5,
};

struct ethtool_cmd {
	__u32 cmd;
	__u32 supported;
	__u32 advertising;
	__u16 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 transceiver;
	__u8 autoneg;
	__u8 mdio_support;
	__u32 maxtxpkt;
	__u32 maxrxpkt;
	__u16 speed_hi;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__u32 lp_advertising;
	__u32 reserved[2];
};

struct mii_ioctl_data {
	__u16 phy_id;
	__u16 reg_num;
	__u16 val_in;
	__u16 val_out;
};

struct mii_if_info {
	int phy_id;
	int advertising;
	int phy_id_mask;
	int reg_num_mask;
	unsigned int full_duplex: 1;
	unsigned int force_media: 1;
	unsigned int supports_gmii: 1;
	struct net_device *dev;
	int (*mdio_read)(struct net_device *, int, int);
	void (*mdio_write)(struct net_device *, int, int, int);
};

struct devprobe2 {
	struct net_device * (*probe)(int);
	int status;
};

enum {
	NETIF_F_SG_BIT = 0,
	NETIF_F_IP_CSUM_BIT = 1,
	__UNUSED_NETIF_F_1 = 2,
	NETIF_F_HW_CSUM_BIT = 3,
	NETIF_F_IPV6_CSUM_BIT = 4,
	NETIF_F_HIGHDMA_BIT = 5,
	NETIF_F_FRAGLIST_BIT = 6,
	NETIF_F_HW_VLAN_CTAG_TX_BIT = 7,
	NETIF_F_HW_VLAN_CTAG_RX_BIT = 8,
	NETIF_F_HW_VLAN_CTAG_FILTER_BIT = 9,
	NETIF_F_VLAN_CHALLENGED_BIT = 10,
	NETIF_F_GSO_BIT = 11,
	NETIF_F_LLTX_BIT = 12,
	NETIF_F_NETNS_LOCAL_BIT = 13,
	NETIF_F_GRO_BIT = 14,
	NETIF_F_LRO_BIT = 15,
	NETIF_F_GSO_SHIFT = 16,
	NETIF_F_TSO_BIT = 16,
	NETIF_F_GSO_ROBUST_BIT = 17,
	NETIF_F_TSO_ECN_BIT = 18,
	NETIF_F_TSO_MANGLEID_BIT = 19,
	NETIF_F_TSO6_BIT = 20,
	NETIF_F_FSO_BIT = 21,
	NETIF_F_GSO_GRE_BIT = 22,
	NETIF_F_GSO_GRE_CSUM_BIT = 23,
	NETIF_F_GSO_IPXIP4_BIT = 24,
	NETIF_F_GSO_IPXIP6_BIT = 25,
	NETIF_F_GSO_UDP_TUNNEL_BIT = 26,
	NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT = 27,
	NETIF_F_GSO_PARTIAL_BIT = 28,
	NETIF_F_GSO_TUNNEL_REMCSUM_BIT = 29,
	NETIF_F_GSO_SCTP_BIT = 30,
	NETIF_F_GSO_ESP_BIT = 31,
	NETIF_F_GSO_UDP_BIT = 32,
	NETIF_F_GSO_UDP_L4_BIT = 33,
	NETIF_F_GSO_FRAGLIST_BIT = 34,
	NETIF_F_GSO_LAST = 34,
	NETIF_F_FCOE_CRC_BIT = 35,
	NETIF_F_SCTP_CRC_BIT = 36,
	NETIF_F_FCOE_MTU_BIT = 37,
	NETIF_F_NTUPLE_BIT = 38,
	NETIF_F_RXHASH_BIT = 39,
	NETIF_F_RXCSUM_BIT = 40,
	NETIF_F_NOCACHE_COPY_BIT = 41,
	NETIF_F_LOOPBACK_BIT = 42,
	NETIF_F_RXFCS_BIT = 43,
	NETIF_F_RXALL_BIT = 44,
	NETIF_F_HW_VLAN_STAG_TX_BIT = 45,
	NETIF_F_HW_VLAN_STAG_RX_BIT = 46,
	NETIF_F_HW_VLAN_STAG_FILTER_BIT = 47,
	NETIF_F_HW_L2FW_DOFFLOAD_BIT = 48,
	NETIF_F_HW_TC_BIT = 49,
	NETIF_F_HW_ESP_BIT = 50,
	NETIF_F_HW_ESP_TX_CSUM_BIT = 51,
	NETIF_F_RX_UDP_TUNNEL_PORT_BIT = 52,
	NETIF_F_HW_TLS_TX_BIT = 53,
	NETIF_F_HW_TLS_RX_BIT = 54,
	NETIF_F_GRO_HW_BIT = 55,
	NETIF_F_HW_TLS_RECORD_BIT = 56,
	NETIF_F_GRO_FRAGLIST_BIT = 57,
	NETIF_F_HW_MACSEC_BIT = 58,
	NETIF_F_GRO_UDP_FWD_BIT = 59,
	NETIF_F_HW_HSR_TAG_INS_BIT = 60,
	NETIF_F_HW_HSR_TAG_RM_BIT = 61,
	NETIF_F_HW_HSR_FWD_BIT = 62,
	NETIF_F_HW_HSR_DUP_BIT = 63,
	NETDEV_FEATURE_COUNT = 64,
};

typedef struct bio_vec skb_frag_t;

struct skb_shared_hwtstamps {
	ktime_t hwtstamp;
};

enum {
	SKBTX_HW_TSTAMP = 1,
	SKBTX_SW_TSTAMP = 2,
	SKBTX_IN_PROGRESS = 4,
	SKBTX_WIFI_STATUS = 16,
	SKBTX_SCHED_TSTAMP = 64,
};

struct skb_shared_info {
	__u8 flags;
	__u8 meta_len;
	__u8 nr_frags;
	__u8 tx_flags;
	short unsigned int gso_size;
	short unsigned int gso_segs;
	struct sk_buff *frag_list;
	struct skb_shared_hwtstamps hwtstamps;
	unsigned int gso_type;
	u32 tskey;
	atomic_t dataref;
	void *destructor_arg;
	skb_frag_t frags[17];
};

enum netdev_priv_flags {
	IFF_802_1Q_VLAN = 1,
	IFF_EBRIDGE = 2,
	IFF_BONDING = 4,
	IFF_ISATAP = 8,
	IFF_WAN_HDLC = 16,
	IFF_XMIT_DST_RELEASE = 32,
	IFF_DONT_BRIDGE = 64,
	IFF_DISABLE_NETPOLL = 128,
	IFF_MACVLAN_PORT = 256,
	IFF_BRIDGE_PORT = 512,
	IFF_OVS_DATAPATH = 1024,
	IFF_TX_SKB_SHARING = 2048,
	IFF_UNICAST_FLT = 4096,
	IFF_TEAM_PORT = 8192,
	IFF_SUPP_NOFCS = 16384,
	IFF_LIVE_ADDR_CHANGE = 32768,
	IFF_MACVLAN = 65536,
	IFF_XMIT_DST_RELEASE_PERM = 131072,
	IFF_L3MDEV_MASTER = 262144,
	IFF_NO_QUEUE = 524288,
	IFF_OPENVSWITCH = 1048576,
	IFF_L3MDEV_SLAVE = 2097152,
	IFF_TEAM = 4194304,
	IFF_RXFH_CONFIGURED = 8388608,
	IFF_PHONY_HEADROOM = 16777216,
	IFF_MACSEC = 33554432,
	IFF_NO_RX_HANDLER = 67108864,
	IFF_FAILOVER = 134217728,
	IFF_FAILOVER_SLAVE = 268435456,
	IFF_L3MDEV_RX_HANDLER = 536870912,
	IFF_LIVE_RENAME_OK = 1073741824,
	IFF_TX_SKB_NO_LINEAR = 2147483648,
};

struct mdio_board_info {
	const char *bus_id;
	char modalias[32];
	int mdio_addr;
	const void *platform_data;
};

struct mdio_board_entry {
	struct list_head list;
	struct mdio_board_info board_info;
};

struct mdiobus_devres {
	struct mii_bus *mii;
};

enum {
	ETHTOOL_MSG_KERNEL_NONE = 0,
	ETHTOOL_MSG_STRSET_GET_REPLY = 1,
	ETHTOOL_MSG_LINKINFO_GET_REPLY = 2,
	ETHTOOL_MSG_LINKINFO_NTF = 3,
	ETHTOOL_MSG_LINKMODES_GET_REPLY = 4,
	ETHTOOL_MSG_LINKMODES_NTF = 5,
	ETHTOOL_MSG_LINKSTATE_GET_REPLY = 6,
	ETHTOOL_MSG_DEBUG_GET_REPLY = 7,
	ETHTOOL_MSG_DEBUG_NTF = 8,
	ETHTOOL_MSG_WOL_GET_REPLY = 9,
	ETHTOOL_MSG_WOL_NTF = 10,
	ETHTOOL_MSG_FEATURES_GET_REPLY = 11,
	ETHTOOL_MSG_FEATURES_SET_REPLY = 12,
	ETHTOOL_MSG_FEATURES_NTF = 13,
	ETHTOOL_MSG_PRIVFLAGS_GET_REPLY = 14,
	ETHTOOL_MSG_PRIVFLAGS_NTF = 15,
	ETHTOOL_MSG_RINGS_GET_REPLY = 16,
	ETHTOOL_MSG_RINGS_NTF = 17,
	ETHTOOL_MSG_CHANNELS_GET_REPLY = 18,
	ETHTOOL_MSG_CHANNELS_NTF = 19,
	ETHTOOL_MSG_COALESCE_GET_REPLY = 20,
	ETHTOOL_MSG_COALESCE_NTF = 21,
	ETHTOOL_MSG_PAUSE_GET_REPLY = 22,
	ETHTOOL_MSG_PAUSE_NTF = 23,
	ETHTOOL_MSG_EEE_GET_REPLY = 24,
	ETHTOOL_MSG_EEE_NTF = 25,
	ETHTOOL_MSG_TSINFO_GET_REPLY = 26,
	ETHTOOL_MSG_CABLE_TEST_NTF = 27,
	ETHTOOL_MSG_CABLE_TEST_TDR_NTF = 28,
	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY = 29,
	ETHTOOL_MSG_FEC_GET_REPLY = 30,
	ETHTOOL_MSG_FEC_NTF = 31,
	ETHTOOL_MSG_MODULE_EEPROM_GET_REPLY = 32,
	ETHTOOL_MSG_STATS_GET_REPLY = 33,
	__ETHTOOL_MSG_KERNEL_CNT = 34,
	ETHTOOL_MSG_KERNEL_MAX = 33,
};

enum {
	ETHTOOL_A_STATS_UNSPEC = 0,
	ETHTOOL_A_STATS_PAD = 1,
	ETHTOOL_A_STATS_HEADER = 2,
	ETHTOOL_A_STATS_GROUPS = 3,
	ETHTOOL_A_STATS_GRP = 4,
	__ETHTOOL_A_STATS_CNT = 5,
	ETHTOOL_A_STATS_MAX = 4,
};

struct phy_led_trigger {
	struct led_trigger trigger;
	char name[76];
	unsigned int speed;
};

struct phy_setting {
	u32 speed;
	u8 duplex;
	u8 bit;
};

struct ethtool_phy_ops {
	int (*get_sset_count)(struct phy_device *);
	int (*get_strings)(struct phy_device *, u8 *);
	int (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*start_cable_test)(struct phy_device *, struct netlink_ext_ack *);
	int (*start_cable_test_tdr)(struct phy_device *, struct netlink_ext_ack *, const struct phy_tdr_config *);
};

struct phy_fixup {
	struct list_head list;
	char bus_id[64];
	u32 phy_uid;
	u32 phy_uid_mask;
	int (*run)(struct phy_device *);
};

struct sfp_eeprom_base {
	u8 phys_id;
	u8 phys_ext_id;
	u8 connector;
	u8 if_1x_copper_passive: 1;
	u8 if_1x_copper_active: 1;
	u8 if_1x_lx: 1;
	u8 if_1x_sx: 1;
	u8 e10g_base_sr: 1;
	u8 e10g_base_lr: 1;
	u8 e10g_base_lrm: 1;
	u8 e10g_base_er: 1;
	u8 sonet_oc3_short_reach: 1;
	u8 sonet_oc3_smf_intermediate_reach: 1;
	u8 sonet_oc3_smf_long_reach: 1;
	u8 unallocated_5_3: 1;
	u8 sonet_oc12_short_reach: 1;
	u8 sonet_oc12_smf_intermediate_reach: 1;
	u8 sonet_oc12_smf_long_reach: 1;
	u8 unallocated_5_7: 1;
	u8 sonet_oc48_short_reach: 1;
	u8 sonet_oc48_intermediate_reach: 1;
	u8 sonet_oc48_long_reach: 1;
	u8 sonet_reach_bit2: 1;
	u8 sonet_reach_bit1: 1;
	u8 sonet_oc192_short_reach: 1;
	u8 escon_smf_1310_laser: 1;
	u8 escon_mmf_1310_led: 1;
	u8 e1000_base_sx: 1;
	u8 e1000_base_lx: 1;
	u8 e1000_base_cx: 1;
	u8 e1000_base_t: 1;
	u8 e100_base_lx: 1;
	u8 e100_base_fx: 1;
	u8 e_base_bx10: 1;
	u8 e_base_px: 1;
	u8 fc_tech_electrical_inter_enclosure: 1;
	u8 fc_tech_lc: 1;
	u8 fc_tech_sa: 1;
	u8 fc_ll_m: 1;
	u8 fc_ll_l: 1;
	u8 fc_ll_i: 1;
	u8 fc_ll_s: 1;
	u8 fc_ll_v: 1;
	u8 unallocated_8_0: 1;
	u8 unallocated_8_1: 1;
	u8 sfp_ct_passive: 1;
	u8 sfp_ct_active: 1;
	u8 fc_tech_ll: 1;
	u8 fc_tech_sl: 1;
	u8 fc_tech_sn: 1;
	u8 fc_tech_electrical_intra_enclosure: 1;
	u8 fc_media_sm: 1;
	u8 unallocated_9_1: 1;
	u8 fc_media_m5: 1;
	u8 fc_media_m6: 1;
	u8 fc_media_tv: 1;
	u8 fc_media_mi: 1;
	u8 fc_media_tp: 1;
	u8 fc_media_tw: 1;
	u8 fc_speed_100: 1;
	u8 unallocated_10_1: 1;
	u8 fc_speed_200: 1;
	u8 fc_speed_3200: 1;
	u8 fc_speed_400: 1;
	u8 fc_speed_1600: 1;
	u8 fc_speed_800: 1;
	u8 fc_speed_1200: 1;
	u8 encoding;
	u8 br_nominal;
	u8 rate_id;
	u8 link_len[6];
	char vendor_name[16];
	u8 extended_cc;
	char vendor_oui[3];
	char vendor_pn[16];
	char vendor_rev[4];
	union {
		__be16 optical_wavelength;
		__be16 cable_compliance;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 reserved60_2: 6;
			u8 reserved61: 8;
		} passive;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 sff8431_lim: 1;
			u8 fc_pi_4_lim: 1;
			u8 reserved60_4: 4;
			u8 reserved61: 8;
		} active;
	};
	u8 reserved62;
	u8 cc_base;
};

struct sfp_eeprom_ext {
	__be16 options;
	u8 br_max;
	u8 br_min;
	char vendor_sn[16];
	char datecode[8];
	u8 diagmon;
	u8 enhopts;
	u8 sff8472_compliance;
	u8 cc_ext;
};

struct sfp_eeprom_id {
	struct sfp_eeprom_base base;
	struct sfp_eeprom_ext ext;
};

struct sfp_upstream_ops {
	void (*attach)(void *, struct sfp_bus *);
	void (*detach)(void *, struct sfp_bus *);
	int (*module_insert)(void *, const struct sfp_eeprom_id *);
	void (*module_remove)(void *);
	int (*module_start)(void *);
	void (*module_stop)(void *);
	void (*link_down)(void *);
	void (*link_up)(void *);
	int (*connect_phy)(void *, struct phy_device *);
	void (*disconnect_phy)(void *);
};

struct trace_event_raw_mdio_access {
	struct trace_entry ent;
	char busid[61];
	char read;
	u8 addr;
	u16 val;
	unsigned int regnum;
	char __data[0];
};

struct trace_event_data_offsets_mdio_access {};

typedef void (*btf_trace_mdio_access)(void *, struct mii_bus *, char, u8, unsigned int, u16, int);

struct mdio_bus_stat_attr {
	int addr;
	unsigned int field_offset;
};

struct fixed_phy_status {
	int link;
	int speed;
	int duplex;
	int pause;
	int asym_pause;
};

struct swmii_regs {
	u16 bmsr;
	u16 lpa;
	u16 lpagb;
	u16 estat;
};

enum {
	SWMII_SPEED_10 = 0,
	SWMII_SPEED_100 = 1,
	SWMII_SPEED_1000 = 2,
	SWMII_DUPLEX_HALF = 0,
	SWMII_DUPLEX_FULL = 1,
};

struct mii_timestamping_ctrl {
	struct mii_timestamper * (*probe_channel)(struct device *, unsigned int);
	void (*release_channel)(struct device *, struct mii_timestamper *);
};

struct mii_timestamping_desc {
	struct list_head list;
	struct mii_timestamping_ctrl *ctrl;
	struct device *device;
};

struct sfp;

struct sfp_socket_ops;

struct sfp_quirk;

struct sfp_bus {
	struct kref kref;
	struct list_head node;
	struct fwnode_handle *fwnode;
	const struct sfp_socket_ops *socket_ops;
	struct device *sfp_dev;
	struct sfp *sfp;
	const struct sfp_quirk *sfp_quirk;
	const struct sfp_upstream_ops *upstream_ops;
	void *upstream;
	struct phy_device *phydev;
	bool registered;
	bool started;
};

enum {
	SFF8024_ID_UNK = 0,
	SFF8024_ID_SFF_8472 = 2,
	SFF8024_ID_SFP = 3,
	SFF8024_ID_DWDM_SFP = 11,
	SFF8024_ID_QSFP_8438 = 12,
	SFF8024_ID_QSFP_8436_8636 = 13,
	SFF8024_ID_QSFP28_8636 = 17,
	SFF8024_ENCODING_UNSPEC = 0,
	SFF8024_ENCODING_8B10B = 1,
	SFF8024_ENCODING_4B5B = 2,
	SFF8024_ENCODING_NRZ = 3,
	SFF8024_ENCODING_8472_MANCHESTER = 4,
	SFF8024_ENCODING_8472_SONET = 5,
	SFF8024_ENCODING_8472_64B66B = 6,
	SFF8024_ENCODING_8436_MANCHESTER = 6,
	SFF8024_ENCODING_8436_SONET = 4,
	SFF8024_ENCODING_8436_64B66B = 5,
	SFF8024_ENCODING_256B257B = 7,
	SFF8024_ENCODING_PAM4 = 8,
	SFF8024_CONNECTOR_UNSPEC = 0,
	SFF8024_CONNECTOR_SC = 1,
	SFF8024_CONNECTOR_FIBERJACK = 6,
	SFF8024_CONNECTOR_LC = 7,
	SFF8024_CONNECTOR_MT_RJ = 8,
	SFF8024_CONNECTOR_MU = 9,
	SFF8024_CONNECTOR_SG = 10,
	SFF8024_CONNECTOR_OPTICAL_PIGTAIL = 11,
	SFF8024_CONNECTOR_MPO_1X12 = 12,
	SFF8024_CONNECTOR_MPO_2X16 = 13,
	SFF8024_CONNECTOR_HSSDC_II = 32,
	SFF8024_CONNECTOR_COPPER_PIGTAIL = 33,
	SFF8024_CONNECTOR_RJ45 = 34,
	SFF8024_CONNECTOR_NOSEPARATE = 35,
	SFF8024_CONNECTOR_MXC_2X16 = 36,
	SFF8024_ECC_UNSPEC = 0,
	SFF8024_ECC_100G_25GAUI_C2M_AOC = 1,
	SFF8024_ECC_100GBASE_SR4_25GBASE_SR = 2,
	SFF8024_ECC_100GBASE_LR4_25GBASE_LR = 3,
	SFF8024_ECC_100GBASE_ER4_25GBASE_ER = 4,
	SFF8024_ECC_100GBASE_SR10 = 5,
	SFF8024_ECC_100GBASE_CR4 = 11,
	SFF8024_ECC_25GBASE_CR_S = 12,
	SFF8024_ECC_25GBASE_CR_N = 13,
	SFF8024_ECC_10GBASE_T_SFI = 22,
	SFF8024_ECC_10GBASE_T_SR = 28,
	SFF8024_ECC_5GBASE_T = 29,
	SFF8024_ECC_2_5GBASE_T = 30,
};

struct sfp_socket_ops {
	void (*attach)(struct sfp *);
	void (*detach)(struct sfp *);
	void (*start)(struct sfp *);
	void (*stop)(struct sfp *);
	int (*module_info)(struct sfp *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct sfp *, struct ethtool_eeprom *, u8 *);
	int (*module_eeprom_by_page)(struct sfp *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);
};

struct sfp_quirk {
	const char *vendor;
	const char *part;
	void (*modes)(const struct sfp_eeprom_id *, long unsigned int *);
};

struct mdio_device_id {
	__u32 phy_id;
	__u32 phy_id_mask;
};

enum {
	MDIO_AN_C22 = 65504,
};

struct fixed_mdio_bus {
	struct mii_bus *mii_bus;
	struct list_head phys;
};

struct fixed_phy {
	int addr;
	struct phy_device *phydev;
	struct fixed_phy_status status;
	bool no_carrier;
	int (*link_update)(struct net_device *, struct fixed_phy_status *);
	struct list_head node;
	struct gpio_desc *link_gpiod;
};

struct mdio_mux_child_bus;

struct mdio_mux_parent_bus {
	struct mii_bus *mii_bus;
	int current_child;
	int parent_id;
	void *switch_data;
	int (*switch_fn)(int, int, void *);
	struct mdio_mux_child_bus *children;
};

struct mdio_mux_child_bus {
	struct mii_bus *mii_bus;
	struct mdio_mux_parent_bus *parent;
	struct mdio_mux_child_bus *next;
	int bus_number;
};

struct iproc_mdiomux_desc {
	void *mux_handle;
	void *base;
	struct device *dev;
	struct mii_bus *mii_bus;
	struct clk *core_clk;
};

struct flow_dissector_key_control {
	u16 thoff;
	u16 addr_type;
	u32 flags;
};

struct flow_dissector_key_basic {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
};

struct flow_keys_basic {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
};

enum {
	SKBFL_ZEROCOPY_ENABLE = 1,
	SKBFL_SHARED_FRAG = 2,
};

struct mmpin {
	struct user_struct *user;
	unsigned int num_pg;
};

struct ubuf_info {
	void (*callback)(struct sk_buff *, struct ubuf_info *, bool);
	union {
		struct {
			long unsigned int desc;
			void *ctx;
		};
		struct {
			u32 id;
			u16 len;
			u16 zerocopy: 1;
			u32 bytelen;
		};
	};
	refcount_t refcnt;
	u8 flags;
	struct mmpin mmp;
};

enum {
	SKB_GSO_TCPV4 = 1,
	SKB_GSO_DODGY = 2,
	SKB_GSO_TCP_ECN = 4,
	SKB_GSO_TCP_FIXEDID = 8,
	SKB_GSO_TCPV6 = 16,
	SKB_GSO_FCOE = 32,
	SKB_GSO_GRE = 64,
	SKB_GSO_GRE_CSUM = 128,
	SKB_GSO_IPXIP4 = 256,
	SKB_GSO_IPXIP6 = 512,
	SKB_GSO_UDP_TUNNEL = 1024,
	SKB_GSO_UDP_TUNNEL_CSUM = 2048,
	SKB_GSO_PARTIAL = 4096,
	SKB_GSO_TUNNEL_REMCSUM = 8192,
	SKB_GSO_SCTP = 16384,
	SKB_GSO_ESP = 32768,
	SKB_GSO_UDP = 65536,
	SKB_GSO_UDP_L4 = 131072,
	SKB_GSO_FRAGLIST = 262144,
};

enum {
	IFLA_TUN_UNSPEC = 0,
	IFLA_TUN_OWNER = 1,
	IFLA_TUN_GROUP = 2,
	IFLA_TUN_TYPE = 3,
	IFLA_TUN_PI = 4,
	IFLA_TUN_VNET_HDR = 5,
	IFLA_TUN_PERSIST = 6,
	IFLA_TUN_MULTI_QUEUE = 7,
	IFLA_TUN_NUM_QUEUES = 8,
	IFLA_TUN_NUM_DISABLED_QUEUES = 9,
	__IFLA_TUN_MAX = 10,
};

enum netdev_queue_state_t {
	__QUEUE_STATE_DRV_XOFF = 0,
	__QUEUE_STATE_STACK_XOFF = 1,
	__QUEUE_STATE_FROZEN = 2,
};

struct ip_tunnel_parm {
	char name[16];
	int link;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	struct iphdr iph;
};

struct wpan_phy;

struct wpan_dev_header_ops;

struct wpan_dev {
	struct wpan_phy *wpan_phy;
	int iftype;
	struct list_head list;
	struct net_device *netdev;
	const struct wpan_dev_header_ops *header_ops;
	struct net_device *lowpan_dev;
	u32 identifier;
	__le16 pan_id;
	__le16 short_addr;
	__le64 extended_addr;
	atomic_t bsn;
	atomic_t dsn;
	u8 min_be;
	u8 max_be;
	u8 csma_retries;
	s8 frame_retries;
	bool lbt;
	bool promiscuous_mode;
	bool ackreq;
};

struct tun_pi {
	__u16 flags;
	__be16 proto;
};

struct tun_filter {
	__u16 flags;
	__u16 count;
	__u8 addr[0];
};

struct virtio_net_hdr {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	__virtio16 csum_start;
	__virtio16 csum_offset;
};

struct tun_msg_ctl {
	short unsigned int type;
	short unsigned int num;
	void *ptr;
};

struct tun_xdp_hdr {
	int buflen;
	struct virtio_net_hdr gso;
};

struct fib_info;

struct fib_nh {
	struct fib_nh_common nh_common;
	struct hlist_node nh_hash;
	struct fib_info *nh_parent;
	__u32 nh_tclassid;
	__be32 nh_saddr;
	int nh_saddr_genid;
};

struct fib_info {
	struct hlist_node fib_hash;
	struct hlist_node fib_lhash;
	struct list_head nh_list;
	struct net *fib_net;
	int fib_treeref;
	refcount_t fib_clntref;
	unsigned int fib_flags;
	unsigned char fib_dead;
	unsigned char fib_protocol;
	unsigned char fib_scope;
	unsigned char fib_type;
	__be32 fib_prefsrc;
	u32 fib_tb_id;
	u32 fib_priority;
	struct dst_metrics *fib_metrics;
	int fib_nhs;
	bool fib_nh_is_v6;
	bool nh_updated;
	struct nexthop *nh;
	struct callback_head rcu;
	struct fib_nh fib_nh[0];
};

struct nh_info;

struct nh_group;

struct nexthop {
	struct rb_node rb_node;
	struct list_head fi_list;
	struct list_head f6i_list;
	struct list_head fdb_list;
	struct list_head grp_list;
	struct net *net;
	u32 id;
	u8 protocol;
	u8 nh_flags;
	bool is_group;
	refcount_t refcnt;
	struct callback_head rcu;
	union {
		struct nh_info *nh_info;
		struct nh_group *nh_grp;
	};
};

struct nh_info {
	struct hlist_node dev_hash;
	struct nexthop *nh_parent;
	u8 family;
	bool reject_nh;
	bool fdb_nh;
	union {
		struct fib_nh_common fib_nhc;
		struct fib_nh fib_nh;
		struct fib6_nh fib6_nh;
	};
};

struct nh_grp_entry;

struct nh_res_bucket {
	struct nh_grp_entry *nh_entry;
	atomic_long_t used_time;
	long unsigned int migrated_time;
	bool occupied;
	u8 nh_flags;
};

struct nh_grp_entry {
	struct nexthop *nh;
	u8 weight;
	union {
		struct {
			atomic_t upper_bound;
		} hthr;
		struct {
			struct list_head uw_nh_entry;
			u16 count_buckets;
			u16 wants_buckets;
		} res;
	};
	struct list_head nh_list;
	struct nexthop *nh_parent;
};

struct nh_res_table {
	struct net *net;
	u32 nhg_id;
	struct delayed_work upkeep_dw;
	struct list_head uw_nh_entries;
	long unsigned int unbalanced_since;
	u32 idle_timer;
	u32 unbalanced_timer;
	u16 num_nh_buckets;
	struct nh_res_bucket nh_buckets[0];
};

struct nh_group {
	struct nh_group *spare;
	u16 num_nh;
	bool is_multipath;
	bool hash_threshold;
	bool resilient;
	bool fdb_nh;
	bool has_v4;
	struct nh_res_table *res_table;
	struct nh_grp_entry nh_entries[0];
};

struct ip_tunnel_encap {
	u16 type;
	u16 flags;
	__be16 sport;
	__be16 dport;
};

struct ip_tunnel_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi4 *);
	int (*err_handler)(struct sk_buff *, u32);
};

typedef struct {
	char ax25_call[7];
} ax25_address;

enum {
	AX25_VALUES_IPDEFMODE = 0,
	AX25_VALUES_AXDEFMODE = 1,
	AX25_VALUES_BACKOFF = 2,
	AX25_VALUES_CONMODE = 3,
	AX25_VALUES_WINDOW = 4,
	AX25_VALUES_EWINDOW = 5,
	AX25_VALUES_T1 = 6,
	AX25_VALUES_T2 = 7,
	AX25_VALUES_T3 = 8,
	AX25_VALUES_IDLE = 9,
	AX25_VALUES_N2 = 10,
	AX25_VALUES_PACLEN = 11,
	AX25_VALUES_PROTOCOL = 12,
	AX25_VALUES_DS_TIMEOUT = 13,
	AX25_MAX_VALUES = 14,
};

typedef struct {
	ax25_address calls[8];
	unsigned char repeated[8];
	unsigned char ndigi;
	signed char lastrepeat;
} ax25_digi;

typedef struct {
	char slave;
	struct timer_list slave_timer;
	short unsigned int slave_timeout;
} ax25_dama_info;

struct ax25_dev {
	struct ax25_dev *next;
	struct net_device *dev;
	struct net_device *forward;
	struct ctl_table_header *sysheader;
	int values[14];
	ax25_dama_info dama;
};

typedef struct ax25_dev ax25_dev;

struct ax25_cb {
	struct hlist_node ax25_node;
	ax25_address source_addr;
	ax25_address dest_addr;
	ax25_digi *digipeat;
	ax25_dev *ax25_dev;
	unsigned char iamdigi;
	unsigned char state;
	unsigned char modulus;
	unsigned char pidincl;
	short unsigned int vs;
	short unsigned int vr;
	short unsigned int va;
	unsigned char condition;
	unsigned char backoff;
	unsigned char n2;
	unsigned char n2count;
	struct timer_list t1timer;
	struct timer_list t2timer;
	struct timer_list t3timer;
	struct timer_list idletimer;
	long unsigned int t1;
	long unsigned int t2;
	long unsigned int t3;
	long unsigned int idle;
	long unsigned int rtt;
	short unsigned int paclen;
	short unsigned int fragno;
	short unsigned int fraglen;
	struct sk_buff_head write_queue;
	struct sk_buff_head reseq_queue;
	struct sk_buff_head ack_queue;
	struct sk_buff_head frag_queue;
	unsigned char window;
	struct timer_list timer;
	struct timer_list dtimer;
	struct sock *sk;
	refcount_t refcount;
};

typedef struct ax25_cb ax25_cb;

struct rose_neigh {
	struct rose_neigh *next;
	ax25_address callsign;
	ax25_digi *digipeat;
	ax25_cb *ax25;
	struct net_device *dev;
	short unsigned int count;
	short unsigned int use;
	unsigned int number;
	char restarted;
	char dce_mode;
	char loopback;
	struct sk_buff_head queue;
	struct timer_list t0timer;
	struct timer_list ftimer;
};

enum nl802154_cca_modes {
	__NL802154_CCA_INVALID = 0,
	NL802154_CCA_ENERGY = 1,
	NL802154_CCA_CARRIER = 2,
	NL802154_CCA_ENERGY_CARRIER = 3,
	NL802154_CCA_ALOHA = 4,
	NL802154_CCA_UWB_SHR = 5,
	NL802154_CCA_UWB_MULTIPLEXED = 6,
	__NL802154_CCA_ATTR_AFTER_LAST = 7,
	NL802154_CCA_ATTR_MAX = 6,
};

enum nl802154_cca_opts {
	NL802154_CCA_OPT_ENERGY_CARRIER_AND = 0,
	NL802154_CCA_OPT_ENERGY_CARRIER_OR = 1,
	__NL802154_CCA_OPT_ATTR_AFTER_LAST = 2,
	NL802154_CCA_OPT_ATTR_MAX = 1,
};

enum nl802154_supported_bool_states {
	NL802154_SUPPORTED_BOOL_FALSE = 0,
	NL802154_SUPPORTED_BOOL_TRUE = 1,
	__NL802154_SUPPORTED_BOOL_INVALD = 2,
	NL802154_SUPPORTED_BOOL_BOTH = 3,
	__NL802154_SUPPORTED_BOOL_AFTER_LAST = 4,
	NL802154_SUPPORTED_BOOL_MAX = 3,
};

struct wpan_phy_supported {
	u32 channels[32];
	u32 cca_modes;
	u32 cca_opts;
	u32 iftypes;
	enum nl802154_supported_bool_states lbt;
	u8 min_minbe;
	u8 max_minbe;
	u8 min_maxbe;
	u8 max_maxbe;
	u8 min_csma_backoffs;
	u8 max_csma_backoffs;
	s8 min_frame_retries;
	s8 max_frame_retries;
	size_t tx_powers_size;
	size_t cca_ed_levels_size;
	const s32 *tx_powers;
	const s32 *cca_ed_levels;
};

struct wpan_phy_cca {
	enum nl802154_cca_modes mode;
	enum nl802154_cca_opts opt;
};

struct wpan_phy {
	const void *privid;
	u32 flags;
	u8 current_channel;
	u8 current_page;
	struct wpan_phy_supported supported;
	s32 transmit_power;
	struct wpan_phy_cca cca;
	__le64 perm_extended_addr;
	s32 cca_ed_level;
	u8 symbol_duration;
	u16 lifs_period;
	u16 sifs_period;
	struct device dev;
	possible_net_t _net;
	long: 64;
	long: 64;
	long: 64;
	char priv[0];
};

struct ieee802154_addr {
	u8 mode;
	__le16 pan_id;
	union {
		__le16 short_addr;
		__le64 extended_addr;
	};
};

struct wpan_dev_header_ops {
	int (*create)(struct sk_buff *, struct net_device *, const struct ieee802154_addr *, const struct ieee802154_addr *, unsigned int);
};

struct tap_filter {
	unsigned int count;
	u32 mask[2];
	unsigned char addr[48];
};

struct tun_struct;

struct tun_file {
	struct sock sk;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct socket socket;
	struct tun_struct *tun;
	struct fasync_struct *fasync;
	unsigned int flags;
	union {
		u16 queue_index;
		unsigned int ifindex;
	};
	struct napi_struct napi;
	bool napi_enabled;
	bool napi_frags_enabled;
	struct mutex napi_mutex;
	struct list_head next;
	struct tun_struct *detached;
	long: 64;
	long: 64;
	long: 64;
	struct ptr_ring tx_ring;
	struct xdp_rxq_info xdp_rxq;
};

struct tun_prog;

struct tun_struct {
	struct tun_file *tfiles[256];
	unsigned int numqueues;
	unsigned int flags;
	kuid_t owner;
	kgid_t group;
	struct net_device *dev;
	netdev_features_t set_features;
	int align;
	int vnet_hdr_sz;
	int sndbuf;
	struct tap_filter txflt;
	struct sock_fprog fprog;
	bool filter_attached;
	u32 msg_enable;
	spinlock_t lock;
	struct hlist_head flows[1024];
	struct timer_list flow_gc_timer;
	long unsigned int ageing_time;
	unsigned int numdisabled;
	struct list_head disabled;
	void *security;
	u32 flow_count;
	u32 rx_batched;
	atomic_long_t rx_frame_errors;
	struct bpf_prog *xdp_prog;
	struct tun_prog *steering_prog;
	struct tun_prog *filter_prog;
	struct ethtool_link_ksettings link_ksettings;
	struct file *file;
	struct ifreq *ifr;
};

struct tun_page {
	struct page *page;
	int count;
};

struct tun_flow_entry {
	struct hlist_node hash_link;
	struct callback_head rcu;
	struct tun_struct *tun;
	u32 rxhash;
	u32 rps_rxhash;
	int queue_index;
	long: 32;
	long: 64;
	long unsigned int updated;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tun_prog {
	struct callback_head rcu;
	struct bpf_prog *prog;
};

struct veth {
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
};

struct bcma_device_id {
	__u16 manuf;
	__u16 id;
	__u8 rev;
	__u8 class;
};

struct bcma_device;

struct bcma_chipcommon_pmu {
	struct bcma_device *core;
	u8 rev;
	u32 crystalfreq;
};

struct bcma_bus;

struct bcma_device {
	struct bcma_bus *bus;
	struct bcma_device_id id;
	struct device dev;
	struct device *dma_dev;
	unsigned int irq;
	bool dev_registered;
	u8 core_index;
	u8 core_unit;
	u32 addr;
	u32 addr_s[8];
	u32 wrap;
	void *io_addr;
	void *io_wrap;
	void *drvdata;
	struct list_head list;
};

struct bcma_sflash {
	bool present;
	u32 blocksize;
	u16 numblocks;
	u32 size;
};

struct bcma_drv_cc {
	struct bcma_device *core;
	u32 status;
	u32 capabilities;
	u32 capabilities_ext;
	u8 setup_done: 1;
	u8 early_setup_done: 1;
	u16 fast_pwrup_delay;
	struct bcma_chipcommon_pmu pmu;
	struct bcma_sflash sflash;
	u32 ticks_per_ms;
	struct platform_device *watchdog;
	spinlock_t gpio_lock;
	struct gpio_chip gpio;
};

struct bcma_drv_cc_b {
	struct bcma_device *core;
	u8 setup_done: 1;
	void *mii;
};

struct bcma_drv_pci {
	struct bcma_device *core;
	u8 early_setup_done: 1;
	u8 setup_done: 1;
	u8 hostmode: 1;
};

struct bcma_drv_pcie2 {
	struct bcma_device *core;
	u16 reqsize;
};

struct bcma_drv_mips {
	struct bcma_device *core;
	u8 setup_done: 1;
	u8 early_setup_done: 1;
};

struct bcma_drv_gmac_cmn {
	struct bcma_device *core;
	struct mutex phy_mutex;
};

struct ssb_sprom_core_pwr_info {
	u8 itssi_2g;
	u8 itssi_5g;
	u8 maxpwr_2g;
	u8 maxpwr_5gl;
	u8 maxpwr_5g;
	u8 maxpwr_5gh;
	u16 pa_2g[4];
	u16 pa_5gl[4];
	u16 pa_5g[4];
	u16 pa_5gh[4];
};

struct ssb_sprom {
	u8 revision;
	char: 8;
	u8 il0mac[6];
	u8 et0mac[6];
	u8 et1mac[6];
	u8 et2mac[6];
	u8 et0phyaddr;
	u8 et1phyaddr;
	u8 et2phyaddr;
	u8 et0mdcport;
	u8 et1mdcport;
	u8 et2mdcport;
	u16 dev_id;
	u16 board_rev;
	u16 board_num;
	u16 board_type;
	u8 country_code;
	char alpha2[2];
	u8 leddc_on_time;
	u8 leddc_off_time;
	u8 ant_available_a;
	u8 ant_available_bg;
	u16 pa0b0;
	u16 pa0b1;
	u16 pa0b2;
	u16 pa1b0;
	u16 pa1b1;
	u16 pa1b2;
	u16 pa1lob0;
	u16 pa1lob1;
	u16 pa1lob2;
	u16 pa1hib0;
	u16 pa1hib1;
	u16 pa1hib2;
	u8 gpio0;
	u8 gpio1;
	u8 gpio2;
	u8 gpio3;
	u8 maxpwr_bg;
	u8 maxpwr_al;
	u8 maxpwr_a;
	u8 maxpwr_ah;
	u8 itssi_a;
	u8 itssi_bg;
	u8 tri2g;
	u8 tri5gl;
	u8 tri5g;
	u8 tri5gh;
	u8 txpid2g[4];
	u8 txpid5gl[4];
	u8 txpid5g[4];
	u8 txpid5gh[4];
	s8 rxpo2g;
	s8 rxpo5g;
	u8 rssisav2g;
	u8 rssismc2g;
	u8 rssismf2g;
	u8 bxa2g;
	u8 rssisav5g;
	u8 rssismc5g;
	u8 rssismf5g;
	u8 bxa5g;
	u16 cck2gpo;
	u32 ofdm2gpo;
	u32 ofdm5glpo;
	u32 ofdm5gpo;
	u32 ofdm5ghpo;
	u32 boardflags;
	u32 boardflags2;
	u32 boardflags3;
	u16 boardflags_lo;
	u16 boardflags_hi;
	u16 boardflags2_lo;
	u16 boardflags2_hi;
	struct ssb_sprom_core_pwr_info core_pwr_info[4];
	struct {
		s8 a0;
		s8 a1;
		s8 a2;
		s8 a3;
	} antenna_gain;
	struct {
		struct {
			u8 tssipos;
			u8 extpa_gain;
			u8 pdet_range;
			u8 tr_iso;
			u8 antswlut;
		} ghz2;
		struct {
			u8 tssipos;
			u8 extpa_gain;
			u8 pdet_range;
			u8 tr_iso;
			u8 antswlut;
		} ghz5;
	} fem;
	u16 mcs2gpo[8];
	u16 mcs5gpo[8];
	u16 mcs5glpo[8];
	u16 mcs5ghpo[8];
	u8 opo;
	u8 rxgainerr2ga[3];
	u8 rxgainerr5gla[3];
	u8 rxgainerr5gma[3];
	u8 rxgainerr5gha[3];
	u8 rxgainerr5gua[3];
	u8 noiselvl2ga[3];
	u8 noiselvl5gla[3];
	u8 noiselvl5gma[3];
	u8 noiselvl5gha[3];
	u8 noiselvl5gua[3];
	u8 regrev;
	u8 txchain;
	u8 rxchain;
	u8 antswitch;
	u16 cddpo;
	u16 stbcpo;
	u16 bw40po;
	u16 bwduppo;
	u8 tempthresh;
	u8 tempoffset;
	u16 rawtempsense;
	u8 measpower;
	u8 tempsense_slope;
	u8 tempcorrx;
	u8 tempsense_option;
	u8 freqoffset_corr;
	u8 iqcal_swp_dis;
	u8 hw_iqcal_en;
	u8 elna2g;
	u8 elna5g;
	u8 phycal_tempdelta;
	u8 temps_period;
	u8 temps_hysteresis;
	u8 measpower1;
	u8 measpower2;
	u8 pcieingress_war;
	u16 cckbw202gpo;
	u16 cckbw20ul2gpo;
	u32 legofdmbw202gpo;
	u32 legofdmbw20ul2gpo;
	u32 legofdmbw205glpo;
	u32 legofdmbw20ul5glpo;
	u32 legofdmbw205gmpo;
	u32 legofdmbw20ul5gmpo;
	u32 legofdmbw205ghpo;
	u32 legofdmbw20ul5ghpo;
	u32 mcsbw202gpo;
	u32 mcsbw20ul2gpo;
	u32 mcsbw402gpo;
	u32 mcsbw205glpo;
	u32 mcsbw20ul5glpo;
	u32 mcsbw405glpo;
	u32 mcsbw205gmpo;
	u32 mcsbw20ul5gmpo;
	u32 mcsbw405gmpo;
	u32 mcsbw205ghpo;
	u32 mcsbw20ul5ghpo;
	u32 mcsbw405ghpo;
	u16 mcs32po;
	u16 legofdm40duppo;
	u8 sar2g;
	u8 sar5g;
};

enum bcma_hosttype {
	BCMA_HOSTTYPE_PCI = 0,
	BCMA_HOSTTYPE_SDIO = 1,
	BCMA_HOSTTYPE_SOC = 2,
};

struct bcma_chipinfo {
	u16 id;
	u8 rev;
	u8 pkg;
};

struct bcma_boardinfo {
	u16 vendor;
	u16 type;
};

struct bcma_host_ops {
	u8 (*read8)(struct bcma_device *, u16);
	u16 (*read16)(struct bcma_device *, u16);
	u32 (*read32)(struct bcma_device *, u16);
	void (*write8)(struct bcma_device *, u16, u8);
	void (*write16)(struct bcma_device *, u16, u16);
	void (*write32)(struct bcma_device *, u16, u32);
	void (*block_read)(struct bcma_device *, void *, size_t, u16, u8);
	void (*block_write)(struct bcma_device *, const void *, size_t, u16, u8);
	u32 (*aread32)(struct bcma_device *, u16);
	void (*awrite32)(struct bcma_device *, u16, u32);
};

struct bcma_bus {
	struct device *dev;
	void *mmio;
	const struct bcma_host_ops *ops;
	enum bcma_hosttype hosttype;
	bool host_is_pcie2;
	struct pci_dev *host_pci;
	struct bcma_chipinfo chipinfo;
	struct bcma_boardinfo boardinfo;
	struct bcma_device *mapped_core;
	struct list_head cores;
	u8 nr_cores;
	u8 num;
	struct bcma_drv_cc drv_cc;
	struct bcma_drv_cc_b drv_cc_b;
	struct bcma_drv_pci drv_pci[2];
	struct bcma_drv_pcie2 drv_pcie2;
	struct bcma_drv_mips drv_mips;
	struct bcma_drv_gmac_cmn drv_gmac_cmn;
	struct ssb_sprom sprom;
};

enum devlink_port_type {
	DEVLINK_PORT_TYPE_NOTSET = 0,
	DEVLINK_PORT_TYPE_AUTO = 1,
	DEVLINK_PORT_TYPE_ETH = 2,
	DEVLINK_PORT_TYPE_IB = 3,
};

enum devlink_port_flavour {
	DEVLINK_PORT_FLAVOUR_PHYSICAL = 0,
	DEVLINK_PORT_FLAVOUR_CPU = 1,
	DEVLINK_PORT_FLAVOUR_DSA = 2,
	DEVLINK_PORT_FLAVOUR_PCI_PF = 3,
	DEVLINK_PORT_FLAVOUR_PCI_VF = 4,
	DEVLINK_PORT_FLAVOUR_VIRTUAL = 5,
	DEVLINK_PORT_FLAVOUR_UNUSED = 6,
	DEVLINK_PORT_FLAVOUR_PCI_SF = 7,
};

struct devlink_port_phys_attrs {
	u32 port_number;
	u32 split_subport_number;
};

struct devlink_port_pci_pf_attrs {
	u32 controller;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_pci_vf_attrs {
	u32 controller;
	u16 pf;
	u16 vf;
	u8 external: 1;
};

struct devlink_port_pci_sf_attrs {
	u32 controller;
	u32 sf;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_attrs {
	u8 split: 1;
	u8 splittable: 1;
	u32 lanes;
	enum devlink_port_flavour flavour;
	struct netdev_phys_item_id switch_id;
	union {
		struct devlink_port_phys_attrs phys;
		struct devlink_port_pci_pf_attrs pci_pf;
		struct devlink_port_pci_vf_attrs pci_vf;
		struct devlink_port_pci_sf_attrs pci_sf;
	};
};

struct devlink;

struct devlink_port {
	struct list_head list;
	struct list_head param_list;
	struct list_head region_list;
	struct devlink *devlink;
	unsigned int index;
	bool registered;
	spinlock_t type_lock;
	enum devlink_port_type type;
	enum devlink_port_type desired_type;
	void *type_dev;
	struct devlink_port_attrs attrs;
	u8 attrs_set: 1;
	u8 switch_port: 1;
	struct delayed_work type_warn_dw;
	struct list_head reporter_list;
	struct mutex reporters_lock;
};

enum phylink_op_type {
	PHYLINK_NETDEV = 0,
	PHYLINK_DEV = 1,
};

struct phylink_link_state;

struct phylink_config {
	struct device *dev;
	enum phylink_op_type type;
	bool pcs_poll;
	bool poll_fixed_state;
	bool ovr_an_inband;
	void (*get_fixed_state)(struct phylink_config *, struct phylink_link_state *);
};

struct dsa_device_ops;

struct dsa_switch_tree;

struct packet_type;

struct dsa_switch;

struct dsa_netdevice_ops;

struct dsa_port {
	union {
		struct net_device *master;
		struct net_device *slave;
	};
	const struct dsa_device_ops *tag_ops;
	struct dsa_switch_tree *dst;
	struct sk_buff * (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *);
	bool (*filter)(const struct sk_buff *, struct net_device *);
	enum {
		DSA_PORT_TYPE_UNUSED = 0,
		DSA_PORT_TYPE_CPU = 1,
		DSA_PORT_TYPE_DSA = 2,
		DSA_PORT_TYPE_USER = 3,
	} type;
	struct dsa_switch *ds;
	unsigned int index;
	const char *name;
	struct dsa_port *cpu_dp;
	u8 mac[6];
	struct device_node *dn;
	unsigned int ageing_time;
	bool vlan_filtering;
	u8 stp_state;
	struct net_device *bridge_dev;
	struct devlink_port devlink_port;
	bool devlink_port_setup;
	struct phylink *pl;
	struct phylink_config pl_config;
	struct net_device *lag_dev;
	bool lag_tx_enabled;
	struct net_device *hsr_dev;
	struct list_head list;
	void *priv;
	const struct ethtool_ops *orig_ethtool_ops;
	const struct dsa_netdevice_ops *netdev_ops;
	bool setup;
};

struct packet_type {
	__be16 type;
	bool ignore_outgoing;
	struct net_device *dev;
	int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	void (*list_func)(struct list_head *, struct packet_type *, struct net_device *);
	bool (*id_match)(struct packet_type *, struct sock *);
	struct net *af_packet_net;
	void *af_packet_priv;
	struct list_head list;
};

enum netdev_lag_tx_type {
	NETDEV_LAG_TX_TYPE_UNKNOWN = 0,
	NETDEV_LAG_TX_TYPE_RANDOM = 1,
	NETDEV_LAG_TX_TYPE_BROADCAST = 2,
	NETDEV_LAG_TX_TYPE_ROUNDROBIN = 3,
	NETDEV_LAG_TX_TYPE_ACTIVEBACKUP = 4,
	NETDEV_LAG_TX_TYPE_HASH = 5,
};

enum netdev_lag_hash {
	NETDEV_LAG_HASH_NONE = 0,
	NETDEV_LAG_HASH_L2 = 1,
	NETDEV_LAG_HASH_L34 = 2,
	NETDEV_LAG_HASH_L23 = 3,
	NETDEV_LAG_HASH_E23 = 4,
	NETDEV_LAG_HASH_E34 = 5,
	NETDEV_LAG_HASH_VLAN_SRCMAC = 6,
	NETDEV_LAG_HASH_UNKNOWN = 7,
};

struct netdev_lag_upper_info {
	enum netdev_lag_tx_type tx_type;
	enum netdev_lag_hash hash_type;
};

struct netdev_notifier_changeupper_info {
	struct netdev_notifier_info info;
	struct net_device *upper_dev;
	bool master;
	bool linking;
	void *upper_info;
};

enum ethtool_stringset {
	ETH_SS_TEST = 0,
	ETH_SS_STATS = 1,
	ETH_SS_PRIV_FLAGS = 2,
	ETH_SS_NTUPLE_FILTERS = 3,
	ETH_SS_FEATURES = 4,
	ETH_SS_RSS_HASH_FUNCS = 5,
	ETH_SS_TUNABLES = 6,
	ETH_SS_PHY_STATS = 7,
	ETH_SS_PHY_TUNABLES = 8,
	ETH_SS_LINK_MODES = 9,
	ETH_SS_MSG_CLASSES = 10,
	ETH_SS_WOL_MODES = 11,
	ETH_SS_SOF_TIMESTAMPING = 12,
	ETH_SS_TS_TX_TYPES = 13,
	ETH_SS_TS_RX_FILTERS = 14,
	ETH_SS_UDP_TUNNEL_TYPES = 15,
	ETH_SS_STATS_STD = 16,
	ETH_SS_STATS_ETH_PHY = 17,
	ETH_SS_STATS_ETH_MAC = 18,
	ETH_SS_STATS_ETH_CTRL = 19,
	ETH_SS_STATS_RMON = 20,
	ETH_SS_COUNT = 21,
};

struct flow_match {
	struct flow_dissector *dissector;
	void *mask;
	void *key;
};

enum flow_action_id {
	FLOW_ACTION_ACCEPT = 0,
	FLOW_ACTION_DROP = 1,
	FLOW_ACTION_TRAP = 2,
	FLOW_ACTION_GOTO = 3,
	FLOW_ACTION_REDIRECT = 4,
	FLOW_ACTION_MIRRED = 5,
	FLOW_ACTION_REDIRECT_INGRESS = 6,
	FLOW_ACTION_MIRRED_INGRESS = 7,
	FLOW_ACTION_VLAN_PUSH = 8,
	FLOW_ACTION_VLAN_POP = 9,
	FLOW_ACTION_VLAN_MANGLE = 10,
	FLOW_ACTION_TUNNEL_ENCAP = 11,
	FLOW_ACTION_TUNNEL_DECAP = 12,
	FLOW_ACTION_MANGLE = 13,
	FLOW_ACTION_ADD = 14,
	FLOW_ACTION_CSUM = 15,
	FLOW_ACTION_MARK = 16,
	FLOW_ACTION_PTYPE = 17,
	FLOW_ACTION_PRIORITY = 18,
	FLOW_ACTION_WAKE = 19,
	FLOW_ACTION_QUEUE = 20,
	FLOW_ACTION_SAMPLE = 21,
	FLOW_ACTION_POLICE = 22,
	FLOW_ACTION_CT = 23,
	FLOW_ACTION_CT_METADATA = 24,
	FLOW_ACTION_MPLS_PUSH = 25,
	FLOW_ACTION_MPLS_POP = 26,
	FLOW_ACTION_MPLS_MANGLE = 27,
	FLOW_ACTION_GATE = 28,
	FLOW_ACTION_PPPOE_PUSH = 29,
	NUM_FLOW_ACTIONS = 30,
};

enum flow_action_hw_stats {
	FLOW_ACTION_HW_STATS_IMMEDIATE = 1,
	FLOW_ACTION_HW_STATS_DELAYED = 2,
	FLOW_ACTION_HW_STATS_ANY = 3,
	FLOW_ACTION_HW_STATS_DISABLED = 4,
	FLOW_ACTION_HW_STATS_DONT_CARE = 7,
};

typedef void (*action_destr)(void *);

enum flow_action_mangle_base {
	FLOW_ACT_MANGLE_UNSPEC = 0,
	FLOW_ACT_MANGLE_HDR_TYPE_ETH = 1,
	FLOW_ACT_MANGLE_HDR_TYPE_IP4 = 2,
	FLOW_ACT_MANGLE_HDR_TYPE_IP6 = 3,
	FLOW_ACT_MANGLE_HDR_TYPE_TCP = 4,
	FLOW_ACT_MANGLE_HDR_TYPE_UDP = 5,
};

struct nf_flowtable;

struct ip_tunnel_info;

struct psample_group;

struct action_gate_entry;

struct flow_action_cookie;

struct flow_action_entry {
	enum flow_action_id id;
	enum flow_action_hw_stats hw_stats;
	action_destr destructor;
	void *destructor_priv;
	union {
		u32 chain_index;
		struct net_device *dev;
		struct {
			u16 vid;
			__be16 proto;
			u8 prio;
		} vlan;
		struct {
			enum flow_action_mangle_base htype;
			u32 offset;
			u32 mask;
			u32 val;
		} mangle;
		struct ip_tunnel_info *tunnel;
		u32 csum_flags;
		u32 mark;
		u16 ptype;
		u32 priority;
		struct {
			u32 ctx;
			u32 index;
			u8 vf;
		} queue;
		struct {
			struct psample_group *psample_group;
			u32 rate;
			u32 trunc_size;
			bool truncate;
		} sample;
		struct {
			u32 index;
			u32 burst;
			u64 rate_bytes_ps;
			u64 burst_pkt;
			u64 rate_pkt_ps;
			u32 mtu;
		} police;
		struct {
			int action;
			u16 zone;
			struct nf_flowtable *flow_table;
		} ct;
		struct {
			long unsigned int cookie;
			u32 mark;
			u32 labels[4];
			bool orig_dir;
		} ct_metadata;
		struct {
			u32 label;
			__be16 proto;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_push;
		struct {
			__be16 proto;
		} mpls_pop;
		struct {
			u32 label;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_mangle;
		struct {
			u32 index;
			s32 prio;
			u64 basetime;
			u64 cycletime;
			u64 cycletimeext;
			u32 num_entries;
			struct action_gate_entry *entries;
		} gate;
		struct {
			u16 sid;
		} pppoe;
	};
	struct flow_action_cookie *cookie;
};

struct flow_action {
	unsigned int num_entries;
	struct flow_action_entry entries[0];
};

struct flow_rule {
	struct flow_match match;
	struct flow_action action;
};

struct dsa_chip_data {
	struct device *host_dev;
	int sw_addr;
	struct device *netdev[12];
	int eeprom_len;
	struct device_node *of_node;
	char *port_names[12];
	struct device_node *port_dn[12];
	s8 rtable[4];
};

struct dsa_platform_data {
	struct device *netdev;
	struct net_device *of_netdev;
	int nr_chips;
	struct dsa_chip_data *chip;
};

struct phylink_link_state {
	long unsigned int advertising[2];
	long unsigned int lp_advertising[2];
	phy_interface_t interface;
	int speed;
	int duplex;
	int pause;
	unsigned int link: 1;
	unsigned int an_enabled: 1;
	unsigned int an_complete: 1;
};

struct flow_action_cookie {
	u32 cookie_len;
	u8 cookie[0];
};

struct flow_stats {
	u64 pkts;
	u64 bytes;
	u64 drops;
	u64 lastused;
	enum flow_action_hw_stats used_hw_stats;
	bool used_hw_stats_valid;
};

enum flow_cls_command {
	FLOW_CLS_REPLACE = 0,
	FLOW_CLS_DESTROY = 1,
	FLOW_CLS_STATS = 2,
	FLOW_CLS_TMPLT_CREATE = 3,
	FLOW_CLS_TMPLT_DESTROY = 4,
};

struct flow_cls_common_offload {
	u32 chain_index;
	__be16 protocol;
	u32 prio;
	struct netlink_ext_ack *extack;
};

struct flow_cls_offload {
	struct flow_cls_common_offload common;
	enum flow_cls_command command;
	long unsigned int cookie;
	struct flow_rule *rule;
	struct flow_stats stats;
	u32 classid;
};

enum devlink_sb_pool_type {
	DEVLINK_SB_POOL_TYPE_INGRESS = 0,
	DEVLINK_SB_POOL_TYPE_EGRESS = 1,
};

enum devlink_sb_threshold_type {
	DEVLINK_SB_THRESHOLD_TYPE_STATIC = 0,
	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC = 1,
};

enum devlink_eswitch_encap_mode {
	DEVLINK_ESWITCH_ENCAP_MODE_NONE = 0,
	DEVLINK_ESWITCH_ENCAP_MODE_BASIC = 1,
};

enum devlink_param_cmode {
	DEVLINK_PARAM_CMODE_RUNTIME = 0,
	DEVLINK_PARAM_CMODE_DRIVERINIT = 1,
	DEVLINK_PARAM_CMODE_PERMANENT = 2,
	__DEVLINK_PARAM_CMODE_MAX = 3,
	DEVLINK_PARAM_CMODE_MAX = 2,
};

enum devlink_trap_action {
	DEVLINK_TRAP_ACTION_DROP = 0,
	DEVLINK_TRAP_ACTION_TRAP = 1,
	DEVLINK_TRAP_ACTION_MIRROR = 2,
};

enum devlink_trap_type {
	DEVLINK_TRAP_TYPE_DROP = 0,
	DEVLINK_TRAP_TYPE_EXCEPTION = 1,
	DEVLINK_TRAP_TYPE_CONTROL = 2,
};

enum devlink_reload_action {
	DEVLINK_RELOAD_ACTION_UNSPEC = 0,
	DEVLINK_RELOAD_ACTION_DRIVER_REINIT = 1,
	DEVLINK_RELOAD_ACTION_FW_ACTIVATE = 2,
	__DEVLINK_RELOAD_ACTION_MAX = 3,
	DEVLINK_RELOAD_ACTION_MAX = 2,
};

enum devlink_reload_limit {
	DEVLINK_RELOAD_LIMIT_UNSPEC = 0,
	DEVLINK_RELOAD_LIMIT_NO_RESET = 1,
	__DEVLINK_RELOAD_LIMIT_MAX = 2,
	DEVLINK_RELOAD_LIMIT_MAX = 1,
};

enum devlink_dpipe_field_mapping_type {
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE = 0,
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX = 1,
};

enum devlink_port_fn_state {
	DEVLINK_PORT_FN_STATE_INACTIVE = 0,
	DEVLINK_PORT_FN_STATE_ACTIVE = 1,
};

enum devlink_port_fn_opstate {
	DEVLINK_PORT_FN_OPSTATE_DETACHED = 0,
	DEVLINK_PORT_FN_OPSTATE_ATTACHED = 1,
};

struct devlink_dev_stats {
	u32 reload_stats[6];
	u32 remote_reload_stats[6];
};

struct devlink_dpipe_headers;

struct devlink_ops;

struct devlink {
	struct list_head list;
	struct list_head port_list;
	struct list_head sb_list;
	struct list_head dpipe_table_list;
	struct list_head resource_list;
	struct list_head param_list;
	struct list_head region_list;
	struct list_head reporter_list;
	struct mutex reporters_lock;
	struct devlink_dpipe_headers *dpipe_headers;
	struct list_head trap_list;
	struct list_head trap_group_list;
	struct list_head trap_policer_list;
	const struct devlink_ops *ops;
	struct xarray snapshot_ids;
	struct devlink_dev_stats stats;
	struct device *dev;
	possible_net_t _net;
	struct mutex lock;
	u8 reload_failed: 1;
	u8 reload_enabled: 1;
	u8 registered: 1;
	long: 61;
	long: 64;
	char priv[0];
};

struct devlink_dpipe_header;

struct devlink_dpipe_headers {
	struct devlink_dpipe_header **headers;
	unsigned int headers_count;
};

struct devlink_sb_pool_info;

struct devlink_info_req;

struct devlink_flash_update_params;

struct devlink_trap;

struct devlink_trap_group;

struct devlink_trap_policer;

struct devlink_port_new_attrs;

struct devlink_ops {
	u32 supported_flash_update_params;
	long unsigned int reload_actions;
	long unsigned int reload_limits;
	int (*reload_down)(struct devlink *, bool, enum devlink_reload_action, enum devlink_reload_limit, struct netlink_ext_ack *);
	int (*reload_up)(struct devlink *, enum devlink_reload_action, enum devlink_reload_limit, u32 *, struct netlink_ext_ack *);
	int (*port_type_set)(struct devlink_port *, enum devlink_port_type);
	int (*port_split)(struct devlink *, unsigned int, unsigned int, struct netlink_ext_ack *);
	int (*port_unsplit)(struct devlink *, unsigned int, struct netlink_ext_ack *);
	int (*sb_pool_get)(struct devlink *, unsigned int, u16, struct devlink_sb_pool_info *);
	int (*sb_pool_set)(struct devlink *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
	int (*sb_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *);
	int (*sb_port_pool_set)(struct devlink_port *, unsigned int, u16, u32, struct netlink_ext_ack *);
	int (*sb_tc_pool_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
	int (*sb_tc_pool_bind_set)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
	int (*sb_occ_snapshot)(struct devlink *, unsigned int);
	int (*sb_occ_max_clear)(struct devlink *, unsigned int);
	int (*sb_occ_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *, u32 *);
	int (*sb_occ_tc_port_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
	int (*eswitch_mode_get)(struct devlink *, u16 *);
	int (*eswitch_mode_set)(struct devlink *, u16, struct netlink_ext_ack *);
	int (*eswitch_inline_mode_get)(struct devlink *, u8 *);
	int (*eswitch_inline_mode_set)(struct devlink *, u8, struct netlink_ext_ack *);
	int (*eswitch_encap_mode_get)(struct devlink *, enum devlink_eswitch_encap_mode *);
	int (*eswitch_encap_mode_set)(struct devlink *, enum devlink_eswitch_encap_mode, struct netlink_ext_ack *);
	int (*info_get)(struct devlink *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*flash_update)(struct devlink *, struct devlink_flash_update_params *, struct netlink_ext_ack *);
	int (*trap_init)(struct devlink *, const struct devlink_trap *, void *);
	void (*trap_fini)(struct devlink *, const struct devlink_trap *, void *);
	int (*trap_action_set)(struct devlink *, const struct devlink_trap *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_group_init)(struct devlink *, const struct devlink_trap_group *);
	int (*trap_group_set)(struct devlink *, const struct devlink_trap_group *, const struct devlink_trap_policer *, struct netlink_ext_ack *);
	int (*trap_group_action_set)(struct devlink *, const struct devlink_trap_group *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_policer_init)(struct devlink *, const struct devlink_trap_policer *);
	void (*trap_policer_fini)(struct devlink *, const struct devlink_trap_policer *);
	int (*trap_policer_set)(struct devlink *, const struct devlink_trap_policer *, u64, u64, struct netlink_ext_ack *);
	int (*trap_policer_counter_get)(struct devlink *, const struct devlink_trap_policer *, u64 *);
	int (*port_function_hw_addr_get)(struct devlink *, struct devlink_port *, u8 *, int *, struct netlink_ext_ack *);
	int (*port_function_hw_addr_set)(struct devlink *, struct devlink_port *, const u8 *, int, struct netlink_ext_ack *);
	int (*port_new)(struct devlink *, const struct devlink_port_new_attrs *, struct netlink_ext_ack *, unsigned int *);
	int (*port_del)(struct devlink *, unsigned int, struct netlink_ext_ack *);
	int (*port_fn_state_get)(struct devlink *, struct devlink_port *, enum devlink_port_fn_state *, enum devlink_port_fn_opstate *, struct netlink_ext_ack *);
	int (*port_fn_state_set)(struct devlink *, struct devlink_port *, enum devlink_port_fn_state, struct netlink_ext_ack *);
};

struct devlink_port_new_attrs {
	enum devlink_port_flavour flavour;
	unsigned int port_index;
	u32 controller;
	u32 sfnum;
	u16 pfnum;
	u8 port_index_valid: 1;
	u8 controller_valid: 1;
	u8 sfnum_valid: 1;
};

struct devlink_sb_pool_info {
	enum devlink_sb_pool_type pool_type;
	u32 size;
	enum devlink_sb_threshold_type threshold_type;
	u32 cell_size;
};

struct devlink_dpipe_field {
	const char *name;
	unsigned int id;
	unsigned int bitwidth;
	enum devlink_dpipe_field_mapping_type mapping_type;
};

struct devlink_dpipe_header {
	const char *name;
	unsigned int id;
	struct devlink_dpipe_field *fields;
	unsigned int fields_count;
	bool global;
};

union devlink_param_value {
	u8 vu8;
	u16 vu16;
	u32 vu32;
	char vstr[32];
	bool vbool;
};

struct devlink_param_gset_ctx {
	union devlink_param_value val;
	enum devlink_param_cmode cmode;
};

struct devlink_flash_update_params {
	const struct firmware *fw;
	const char *component;
	u32 overwrite_mask;
};

struct devlink_trap_policer {
	u32 id;
	u64 init_rate;
	u64 init_burst;
	u64 max_rate;
	u64 min_rate;
	u64 max_burst;
	u64 min_burst;
};

struct devlink_trap_group {
	const char *name;
	u16 id;
	bool generic;
	u32 init_policer_id;
};

struct devlink_trap {
	enum devlink_trap_type type;
	enum devlink_trap_action init_action;
	bool generic;
	u16 id;
	const char *name;
	u16 init_group_id;
	u32 metadata_cap;
};

struct switchdev_brport_flags {
	long unsigned int val;
	long unsigned int mask;
};

enum switchdev_obj_id {
	SWITCHDEV_OBJ_ID_UNDEFINED = 0,
	SWITCHDEV_OBJ_ID_PORT_VLAN = 1,
	SWITCHDEV_OBJ_ID_PORT_MDB = 2,
	SWITCHDEV_OBJ_ID_HOST_MDB = 3,
	SWITCHDEV_OBJ_ID_MRP = 4,
	SWITCHDEV_OBJ_ID_RING_TEST_MRP = 5,
	SWITCHDEV_OBJ_ID_RING_ROLE_MRP = 6,
	SWITCHDEV_OBJ_ID_RING_STATE_MRP = 7,
	SWITCHDEV_OBJ_ID_IN_TEST_MRP = 8,
	SWITCHDEV_OBJ_ID_IN_ROLE_MRP = 9,
	SWITCHDEV_OBJ_ID_IN_STATE_MRP = 10,
};

struct switchdev_obj {
	struct list_head list;
	struct net_device *orig_dev;
	enum switchdev_obj_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
};

struct switchdev_obj_port_vlan {
	struct switchdev_obj obj;
	u16 flags;
	u16 vid;
};

struct switchdev_obj_port_mdb {
	struct switchdev_obj obj;
	unsigned char addr[6];
	u16 vid;
};

struct switchdev_obj_mrp {
	struct switchdev_obj obj;
	struct net_device *p_port;
	struct net_device *s_port;
	u32 ring_id;
	u16 prio;
};

struct switchdev_obj_ring_role_mrp {
	struct switchdev_obj obj;
	u8 ring_role;
	u32 ring_id;
	u8 sw_backup;
};

enum dsa_tag_protocol {
	DSA_TAG_PROTO_NONE = 0,
	DSA_TAG_PROTO_BRCM = 1,
	DSA_TAG_PROTO_BRCM_LEGACY = 22,
	DSA_TAG_PROTO_BRCM_PREPEND = 2,
	DSA_TAG_PROTO_DSA = 3,
	DSA_TAG_PROTO_EDSA = 4,
	DSA_TAG_PROTO_GSWIP = 5,
	DSA_TAG_PROTO_KSZ9477 = 6,
	DSA_TAG_PROTO_KSZ9893 = 7,
	DSA_TAG_PROTO_LAN9303 = 8,
	DSA_TAG_PROTO_MTK = 9,
	DSA_TAG_PROTO_QCA = 10,
	DSA_TAG_PROTO_TRAILER = 11,
	DSA_TAG_PROTO_8021Q = 12,
	DSA_TAG_PROTO_SJA1105 = 13,
	DSA_TAG_PROTO_KSZ8795 = 14,
	DSA_TAG_PROTO_OCELOT = 15,
	DSA_TAG_PROTO_AR9331 = 16,
	DSA_TAG_PROTO_RTL4_A = 17,
	DSA_TAG_PROTO_HELLCREEK = 18,
	DSA_TAG_PROTO_XRS700X = 19,
	DSA_TAG_PROTO_OCELOT_8021Q = 20,
	DSA_TAG_PROTO_SEVILLE = 21,
};

struct dsa_device_ops {
	struct sk_buff * (*xmit)(struct sk_buff *, struct net_device *);
	struct sk_buff * (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *);
	void (*flow_dissect)(const struct sk_buff *, __be16 *, int *);
	bool (*filter)(const struct sk_buff *, struct net_device *);
	unsigned int overhead;
	const char *name;
	enum dsa_tag_protocol proto;
	bool promisc_on_master;
	bool tail_tag;
};

struct dsa_netdevice_ops {
	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
};

struct dsa_switch_tree {
	struct list_head list;
	struct raw_notifier_head nh;
	unsigned int index;
	struct kref refcount;
	bool setup;
	const struct dsa_device_ops *tag_ops;
	enum dsa_tag_protocol default_proto;
	struct dsa_platform_data *pd;
	struct list_head ports;
	struct list_head rtable;
	struct net_device **lags;
	unsigned int lags_len;
};

struct dsa_mall_mirror_tc_entry {
	u8 to_local_port;
	bool ingress;
};

struct dsa_mall_policer_tc_entry {
	u32 burst;
	u64 rate_bytes_per_sec;
};

struct dsa_switch_ops;

struct dsa_switch {
	bool setup;
	struct device *dev;
	struct dsa_switch_tree *dst;
	unsigned int index;
	struct notifier_block nb;
	void *priv;
	struct dsa_chip_data *cd;
	const struct dsa_switch_ops *ops;
	u32 phys_mii_mask;
	struct mii_bus *slave_mii_bus;
	unsigned int ageing_time_min;
	unsigned int ageing_time_max;
	struct devlink *devlink;
	unsigned int num_tx_queues;
	bool vlan_filtering_is_global;
	bool configure_vlan_while_not_filtering;
	bool untag_bridge_pvid;
	bool assisted_learning_on_cpu_port;
	bool vlan_filtering;
	bool pcs_poll;
	bool mtu_enforcement_ingress;
	unsigned int num_lag_ids;
	size_t num_ports;
};

typedef int dsa_fdb_dump_cb_t(const unsigned char *, u16, bool, void *);

struct dsa_switch_ops {
	enum dsa_tag_protocol (*get_tag_protocol)(struct dsa_switch *, int, enum dsa_tag_protocol);
	int (*change_tag_protocol)(struct dsa_switch *, int, enum dsa_tag_protocol);
	int (*setup)(struct dsa_switch *);
	void (*teardown)(struct dsa_switch *);
	int (*port_setup)(struct dsa_switch *, int);
	void (*port_teardown)(struct dsa_switch *, int);
	u32 (*get_phy_flags)(struct dsa_switch *, int);
	int (*phy_read)(struct dsa_switch *, int, int);
	int (*phy_write)(struct dsa_switch *, int, int, u16);
	void (*adjust_link)(struct dsa_switch *, int, struct phy_device *);
	void (*fixed_link_update)(struct dsa_switch *, int, struct fixed_phy_status *);
	void (*phylink_validate)(struct dsa_switch *, int, long unsigned int *, struct phylink_link_state *);
	int (*phylink_mac_link_state)(struct dsa_switch *, int, struct phylink_link_state *);
	void (*phylink_mac_config)(struct dsa_switch *, int, unsigned int, const struct phylink_link_state *);
	void (*phylink_mac_an_restart)(struct dsa_switch *, int);
	void (*phylink_mac_link_down)(struct dsa_switch *, int, unsigned int, phy_interface_t);
	void (*phylink_mac_link_up)(struct dsa_switch *, int, unsigned int, phy_interface_t, struct phy_device *, int, int, bool, bool);
	void (*phylink_fixed_state)(struct dsa_switch *, int, struct phylink_link_state *);
	void (*get_strings)(struct dsa_switch *, int, u32, uint8_t *);
	void (*get_ethtool_stats)(struct dsa_switch *, int, uint64_t *);
	int (*get_sset_count)(struct dsa_switch *, int, int);
	void (*get_ethtool_phy_stats)(struct dsa_switch *, int, uint64_t *);
	void (*get_stats64)(struct dsa_switch *, int, struct rtnl_link_stats64 *);
	void (*self_test)(struct dsa_switch *, int, struct ethtool_test *, u64 *);
	void (*get_wol)(struct dsa_switch *, int, struct ethtool_wolinfo *);
	int (*set_wol)(struct dsa_switch *, int, struct ethtool_wolinfo *);
	int (*get_ts_info)(struct dsa_switch *, int, struct ethtool_ts_info *);
	int (*suspend)(struct dsa_switch *);
	int (*resume)(struct dsa_switch *);
	int (*port_enable)(struct dsa_switch *, int, struct phy_device *);
	void (*port_disable)(struct dsa_switch *, int);
	int (*set_mac_eee)(struct dsa_switch *, int, struct ethtool_eee *);
	int (*get_mac_eee)(struct dsa_switch *, int, struct ethtool_eee *);
	int (*get_eeprom_len)(struct dsa_switch *);
	int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *);
	int (*get_regs_len)(struct dsa_switch *, int);
	void (*get_regs)(struct dsa_switch *, int, struct ethtool_regs *, void *);
	int (*port_prechangeupper)(struct dsa_switch *, int, struct netdev_notifier_changeupper_info *);
	int (*set_ageing_time)(struct dsa_switch *, unsigned int);
	int (*port_bridge_join)(struct dsa_switch *, int, struct net_device *);
	void (*port_bridge_leave)(struct dsa_switch *, int, struct net_device *);
	void (*port_stp_state_set)(struct dsa_switch *, int, u8);
	void (*port_fast_age)(struct dsa_switch *, int);
	int (*port_pre_bridge_flags)(struct dsa_switch *, int, struct switchdev_brport_flags, struct netlink_ext_ack *);
	int (*port_bridge_flags)(struct dsa_switch *, int, struct switchdev_brport_flags, struct netlink_ext_ack *);
	int (*port_vlan_filtering)(struct dsa_switch *, int, bool, struct netlink_ext_ack *);
	int (*port_vlan_add)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *, struct netlink_ext_ack *);
	int (*port_vlan_del)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *);
	int (*port_fdb_add)(struct dsa_switch *, int, const unsigned char *, u16);
	int (*port_fdb_del)(struct dsa_switch *, int, const unsigned char *, u16);
	int (*port_fdb_dump)(struct dsa_switch *, int, dsa_fdb_dump_cb_t *, void *);
	int (*port_mdb_add)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *);
	int (*port_mdb_del)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *);
	int (*get_rxnfc)(struct dsa_switch *, int, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct dsa_switch *, int, struct ethtool_rxnfc *);
	int (*cls_flower_add)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*cls_flower_del)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*cls_flower_stats)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*port_mirror_add)(struct dsa_switch *, int, struct dsa_mall_mirror_tc_entry *, bool);
	void (*port_mirror_del)(struct dsa_switch *, int, struct dsa_mall_mirror_tc_entry *);
	int (*port_policer_add)(struct dsa_switch *, int, struct dsa_mall_policer_tc_entry *);
	void (*port_policer_del)(struct dsa_switch *, int);
	int (*port_setup_tc)(struct dsa_switch *, int, enum tc_setup_type, void *);
	int (*crosschip_bridge_join)(struct dsa_switch *, int, int, int, struct net_device *);
	void (*crosschip_bridge_leave)(struct dsa_switch *, int, int, int, struct net_device *);
	int (*crosschip_lag_change)(struct dsa_switch *, int, int);
	int (*crosschip_lag_join)(struct dsa_switch *, int, int, struct net_device *, struct netdev_lag_upper_info *);
	int (*crosschip_lag_leave)(struct dsa_switch *, int, int, struct net_device *);
	int (*port_hwtstamp_get)(struct dsa_switch *, int, struct ifreq *);
	int (*port_hwtstamp_set)(struct dsa_switch *, int, struct ifreq *);
	void (*port_txtstamp)(struct dsa_switch *, int, struct sk_buff *);
	bool (*port_rxtstamp)(struct dsa_switch *, int, struct sk_buff *, unsigned int);
	int (*devlink_param_get)(struct dsa_switch *, u32, struct devlink_param_gset_ctx *);
	int (*devlink_param_set)(struct dsa_switch *, u32, struct devlink_param_gset_ctx *);
	int (*devlink_info_get)(struct dsa_switch *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*devlink_sb_pool_get)(struct dsa_switch *, unsigned int, u16, struct devlink_sb_pool_info *);
	int (*devlink_sb_pool_set)(struct dsa_switch *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
	int (*devlink_sb_port_pool_get)(struct dsa_switch *, int, unsigned int, u16, u32 *);
	int (*devlink_sb_port_pool_set)(struct dsa_switch *, int, unsigned int, u16, u32, struct netlink_ext_ack *);
	int (*devlink_sb_tc_pool_bind_get)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
	int (*devlink_sb_tc_pool_bind_set)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
	int (*devlink_sb_occ_snapshot)(struct dsa_switch *, unsigned int);
	int (*devlink_sb_occ_max_clear)(struct dsa_switch *, unsigned int);
	int (*devlink_sb_occ_port_pool_get)(struct dsa_switch *, int, unsigned int, u16, u32 *, u32 *);
	int (*devlink_sb_occ_tc_port_bind_get)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
	int (*port_change_mtu)(struct dsa_switch *, int, int);
	int (*port_max_mtu)(struct dsa_switch *, int);
	int (*port_lag_change)(struct dsa_switch *, int);
	int (*port_lag_join)(struct dsa_switch *, int, struct net_device *, struct netdev_lag_upper_info *);
	int (*port_lag_leave)(struct dsa_switch *, int, struct net_device *);
	int (*port_hsr_join)(struct dsa_switch *, int, struct net_device *);
	int (*port_hsr_leave)(struct dsa_switch *, int, struct net_device *);
	int (*port_mrp_add)(struct dsa_switch *, int, const struct switchdev_obj_mrp *);
	int (*port_mrp_del)(struct dsa_switch *, int, const struct switchdev_obj_mrp *);
	int (*port_mrp_add_ring_role)(struct dsa_switch *, int, const struct switchdev_obj_ring_role_mrp *);
	int (*port_mrp_del_ring_role)(struct dsa_switch *, int, const struct switchdev_obj_ring_role_mrp *);
};

struct bgmac_slot_info {
	union {
		struct sk_buff *skb;
		void *buf;
	};
	dma_addr_t dma_addr;
};

struct bgmac_dma_desc {
	__le32 ctl0;
	__le32 ctl1;
	__le32 addr_low;
	__le32 addr_high;
};

enum bgmac_dma_ring_type {
	BGMAC_DMA_RING_TX = 0,
	BGMAC_DMA_RING_RX = 1,
};

struct bgmac_dma_ring {
	u32 start;
	u32 end;
	struct bgmac_dma_desc *cpu_base;
	dma_addr_t dma_base;
	u32 index_base;
	u16 mmio_base;
	bool unaligned;
	struct bgmac_slot_info slots[512];
};

struct bgmac_rx_header {
	__le16 len;
	__le16 flags;
	__le16 pad[12];
};

struct bgmac {
	union {
		struct {
			void *base;
			void *idm_base;
			void *nicpm_base;
		} plat;
		struct {
			struct bcma_device *core;
			struct bcma_device *cmn;
		} bcma;
	};
	struct device *dev;
	struct device *dma_dev;
	u32 feature_flags;
	struct net_device *net_dev;
	struct napi_struct napi;
	struct mii_bus *mii_bus;
	struct bgmac_dma_ring tx_ring[4];
	struct bgmac_dma_ring rx_ring[1];
	bool stats_grabbed;
	u32 mib_tx_regs[43];
	u32 mib_rx_regs[31];
	int irq;
	u32 int_mask;
	int mac_speed;
	int mac_duplex;
	u8 phyaddr;
	bool has_robosw;
	bool loopback;
	u32 (*read)(struct bgmac *, u16);
	void (*write)(struct bgmac *, u16, u32);
	u32 (*idm_read)(struct bgmac *, u16);
	void (*idm_write)(struct bgmac *, u16, u32);
	bool (*clk_enabled)(struct bgmac *);
	void (*clk_enable)(struct bgmac *, u32);
	void (*cco_ctl_maskset)(struct bgmac *, u32, u32, u32);
	u32 (*get_bus_clock)(struct bgmac *);
	void (*cmn_maskset32)(struct bgmac *, u16, u32, u32);
	int (*phy_connect)(struct bgmac *);
};

struct bgmac_stat {
	u8 size;
	u32 offset;
	const char *name;
};

struct netdev_hw_addr {
	struct list_head list;
	unsigned char addr[32];
	unsigned char type;
	bool global_use;
	int sync_cnt;
	int refcount;
	int synced;
	struct callback_head callback_head;
};

enum skb_free_reason {
	SKB_REASON_CONSUMED = 0,
	SKB_REASON_DROPPED = 1,
};

struct vlan_hdr {
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct vlan_ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

enum {
	SOF_TIMESTAMPING_TX_HARDWARE = 1,
	SOF_TIMESTAMPING_TX_SOFTWARE = 2,
	SOF_TIMESTAMPING_RX_HARDWARE = 4,
	SOF_TIMESTAMPING_RX_SOFTWARE = 8,
	SOF_TIMESTAMPING_SOFTWARE = 16,
	SOF_TIMESTAMPING_SYS_HARDWARE = 32,
	SOF_TIMESTAMPING_RAW_HARDWARE = 64,
	SOF_TIMESTAMPING_OPT_ID = 128,
	SOF_TIMESTAMPING_TX_SCHED = 256,
	SOF_TIMESTAMPING_TX_ACK = 512,
	SOF_TIMESTAMPING_OPT_CMSG = 1024,
	SOF_TIMESTAMPING_OPT_TSONLY = 2048,
	SOF_TIMESTAMPING_OPT_STATS = 4096,
	SOF_TIMESTAMPING_OPT_PKTINFO = 8192,
	SOF_TIMESTAMPING_OPT_TX_SWHW = 16384,
	SOF_TIMESTAMPING_LAST = 16384,
	SOF_TIMESTAMPING_MASK = 32767,
};

enum hwtstamp_tx_types {
	HWTSTAMP_TX_OFF = 0,
	HWTSTAMP_TX_ON = 1,
	HWTSTAMP_TX_ONESTEP_SYNC = 2,
	HWTSTAMP_TX_ONESTEP_P2P = 3,
	__HWTSTAMP_TX_CNT = 4,
};

enum hwtstamp_rx_filters {
	HWTSTAMP_FILTER_NONE = 0,
	HWTSTAMP_FILTER_ALL = 1,
	HWTSTAMP_FILTER_SOME = 2,
	HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
	HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
	HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
	HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
	HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
	HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
	HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
	HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
	HWTSTAMP_FILTER_NTP_ALL = 15,
	__HWTSTAMP_FILTER_CNT = 16,
};

enum tunable_id {
	ETHTOOL_ID_UNSPEC = 0,
	ETHTOOL_RX_COPYBREAK = 1,
	ETHTOOL_TX_COPYBREAK = 2,
	ETHTOOL_PFC_PREVENTION_TOUT = 3,
	__ETHTOOL_TUNABLE_COUNT = 4,
};

struct tso_t {
	int next_frag_idx;
	int size;
	void *data;
	u16 ip_id;
	u8 tlen;
	bool ipv6;
	u32 tcp_seq;
};

struct fec_platform_data {
	phy_interface_t phy;
	unsigned char mac[6];
	void (*sleep_mode_enable)(int);
};

struct ptp_clock_time {
	__s64 sec;
	__u32 nsec;
	__u32 reserved;
};

struct ptp_extts_request {
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct ptp_perout_request {
	union {
		struct ptp_clock_time start;
		struct ptp_clock_time phase;
	};
	struct ptp_clock_time period;
	unsigned int index;
	unsigned int flags;
	union {
		struct ptp_clock_time on;
		unsigned int rsv[4];
	};
};

enum ptp_pin_function {
	PTP_PF_NONE = 0,
	PTP_PF_EXTTS = 1,
	PTP_PF_PEROUT = 2,
	PTP_PF_PHYSYNC = 3,
};

struct ptp_pin_desc {
	char name[64];
	unsigned int index;
	unsigned int func;
	unsigned int chan;
	unsigned int rsv[5];
};

struct ptp_clock_request {
	enum {
		PTP_CLK_REQ_EXTTS = 0,
		PTP_CLK_REQ_PEROUT = 1,
		PTP_CLK_REQ_PPS = 2,
	} type;
	union {
		struct ptp_extts_request extts;
		struct ptp_perout_request perout;
	};
};

struct ptp_clock_info {
	struct module *owner;
	char name[16];
	s32 max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int n_pins;
	int pps;
	struct ptp_pin_desc *pin_config;
	int (*adjfine)(struct ptp_clock_info *, long int);
	int (*adjfreq)(struct ptp_clock_info *, s32);
	int (*adjphase)(struct ptp_clock_info *, s32);
	int (*adjtime)(struct ptp_clock_info *, s64);
	int (*gettime64)(struct ptp_clock_info *, struct timespec64 *);
	int (*gettimex64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosststamp)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*settime64)(struct ptp_clock_info *, const struct timespec64 *);
	int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int);
	int (*verify)(struct ptp_clock_info *, unsigned int, enum ptp_pin_function, unsigned int);
	long int (*do_aux_work)(struct ptp_clock_info *);
};

struct bufdesc {
	__le16 cbd_datlen;
	__le16 cbd_sc;
	__le32 cbd_bufaddr;
};

struct bufdesc_ex {
	struct bufdesc desc;
	__le32 cbd_esc;
	__le32 cbd_prot;
	__le32 cbd_bdu;
	__le32 ts;
	__le16 res0[4];
};

struct bufdesc_prop {
	int qid;
	struct bufdesc *base;
	struct bufdesc *last;
	struct bufdesc *cur;
	void *reg_desc_active;
	dma_addr_t dma;
	short unsigned int ring_size;
	unsigned char dsize;
	unsigned char dsize_log2;
};

struct fec_enet_priv_tx_q {
	struct bufdesc_prop bd;
	unsigned char *tx_bounce[512];
	struct sk_buff *tx_skbuff[512];
	short unsigned int tx_stop_threshold;
	short unsigned int tx_wake_threshold;
	struct bufdesc *dirty_tx;
	char *tso_hdrs;
	dma_addr_t tso_hdrs_dma;
};

struct fec_enet_priv_rx_q {
	struct bufdesc_prop bd;
	struct sk_buff *rx_skbuff[512];
};

struct fec_stop_mode_gpr {
	struct regmap *gpr;
	u8 reg;
	u8 bit;
};

struct ptp_clock;

struct fec_enet_private {
	void *hwp;
	struct net_device *netdev;
	struct clk *clk_ipg;
	struct clk *clk_ahb;
	struct clk *clk_ref;
	struct clk *clk_enet_out;
	struct clk *clk_ptp;
	bool ptp_clk_on;
	struct mutex ptp_clk_mutex;
	unsigned int num_tx_queues;
	unsigned int num_rx_queues;
	struct fec_enet_priv_tx_q *tx_queue[3];
	struct fec_enet_priv_rx_q *rx_queue[3];
	unsigned int total_tx_ring_size;
	unsigned int total_rx_ring_size;
	struct platform_device *pdev;
	int dev_id;
	struct mii_bus *mii_bus;
	uint phy_speed;
	phy_interface_t phy_interface;
	struct device_node *phy_node;
	int link;
	int full_duplex;
	int speed;
	int irq[3];
	bool bufdesc_ex;
	int pause_flag;
	int wol_flag;
	u32 quirks;
	struct napi_struct napi;
	int csum_flags;
	struct work_struct tx_timeout_work;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_caps;
	long unsigned int last_overflow_check;
	spinlock_t tmreg_lock;
	struct cyclecounter cc;
	struct timecounter tc;
	int rx_hwtstamp_filter;
	u32 base_incval;
	u32 cycle_speed;
	int hwts_rx_en;
	int hwts_tx_en;
	struct delayed_work time_keep;
	struct regulator *reg_phy;
	struct fec_stop_mode_gpr stop_gpr;
	unsigned int tx_align;
	unsigned int rx_align;
	unsigned int rx_pkts_itr;
	unsigned int rx_time_itr;
	unsigned int tx_pkts_itr;
	unsigned int tx_time_itr;
	unsigned int itr_clk_rate;
	u32 rx_copybreak;
	unsigned int ptp_inc;
	int pps_channel;
	unsigned int reload_period;
	int pps_enable;
	unsigned int next_counter;
	u64 ethtool_stats[0];
};

struct fec_devinfo {
	u32 quirks;
};

enum imx_fec_type {
	IMX25_FEC = 1,
	IMX27_FEC = 2,
	IMX28_FEC = 3,
	IMX6Q_FEC = 4,
	MVF600_FEC = 5,
	IMX6SX_FEC = 6,
	IMX6UL_FEC = 7,
};

struct fec_stat {
	char name[32];
	u16 offset;
};

struct hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
};

struct pps_event_time {
	struct timespec64 ts_real;
};

enum ptp_clock_events {
	PTP_CLOCK_ALARM = 0,
	PTP_CLOCK_EXTTS = 1,
	PTP_CLOCK_PPS = 2,
	PTP_CLOCK_PPSUSR = 3,
};

struct ptp_clock_event {
	int type;
	int index;
	union {
		u64 timestamp;
		struct pps_event_time pps_times;
	};
};

struct tgec_mdio_controller {
	__be32 reserved[12];
	__be32 mdio_stat;
	__be32 mdio_ctl;
	__be32 mdio_data;
	__be32 mdio_addr;
};

struct mdio_fsl_priv {
	struct tgec_mdio_controller *mdio_base;
	bool is_little_endian;
	bool has_a009885;
	bool has_a011043;
};

struct muram_info {
	struct gen_pool *pool;
	void *vbase;
	size_t size;
	phys_addr_t pbase;
};

enum fman_port_type {
	FMAN_PORT_TYPE_TX = 0,
	FMAN_PORT_TYPE_RX = 1,
};

struct fman_rev_info {
	u8 major;
	u8 minor;
};

enum fman_exceptions {
	FMAN_EX_DMA_BUS_ERROR = 0,
	FMAN_EX_DMA_READ_ECC = 1,
	FMAN_EX_DMA_SYSTEM_WRITE_ECC = 2,
	FMAN_EX_DMA_FM_WRITE_ECC = 3,
	FMAN_EX_DMA_SINGLE_PORT_ECC = 4,
	FMAN_EX_FPM_STALL_ON_TASKS = 5,
	FMAN_EX_FPM_SINGLE_ECC = 6,
	FMAN_EX_FPM_DOUBLE_ECC = 7,
	FMAN_EX_QMI_SINGLE_ECC = 8,
	FMAN_EX_QMI_DOUBLE_ECC = 9,
	FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID = 10,
	FMAN_EX_BMI_LIST_RAM_ECC = 11,
	FMAN_EX_BMI_STORAGE_PROFILE_ECC = 12,
	FMAN_EX_BMI_STATISTICS_RAM_ECC = 13,
	FMAN_EX_BMI_DISPATCH_RAM_ECC = 14,
	FMAN_EX_IRAM_ECC = 15,
	FMAN_EX_MURAM_ECC = 16,
};

enum fman_event_modules {
	FMAN_MOD_MAC = 0,
	FMAN_MOD_FMAN_CTRL = 1,
	FMAN_MOD_DUMMY_LAST = 2,
};

enum fman_intr_type {
	FMAN_INTR_TYPE_ERR = 0,
	FMAN_INTR_TYPE_NORMAL = 1,
};

enum fman_inter_module_event {
	FMAN_EV_ERR_MAC0 = 0,
	FMAN_EV_ERR_MAC1 = 1,
	FMAN_EV_ERR_MAC2 = 2,
	FMAN_EV_ERR_MAC3 = 3,
	FMAN_EV_ERR_MAC4 = 4,
	FMAN_EV_ERR_MAC5 = 5,
	FMAN_EV_ERR_MAC6 = 6,
	FMAN_EV_ERR_MAC7 = 7,
	FMAN_EV_ERR_MAC8 = 8,
	FMAN_EV_ERR_MAC9 = 9,
	FMAN_EV_MAC0 = 10,
	FMAN_EV_MAC1 = 11,
	FMAN_EV_MAC2 = 12,
	FMAN_EV_MAC3 = 13,
	FMAN_EV_MAC4 = 14,
	FMAN_EV_MAC5 = 15,
	FMAN_EV_MAC6 = 16,
	FMAN_EV_MAC7 = 17,
	FMAN_EV_MAC8 = 18,
	FMAN_EV_MAC9 = 19,
	FMAN_EV_FMAN_CTRL_0 = 20,
	FMAN_EV_FMAN_CTRL_1 = 21,
	FMAN_EV_FMAN_CTRL_2 = 22,
	FMAN_EV_FMAN_CTRL_3 = 23,
	FMAN_EV_CNT = 24,
};

struct fman_intr_src {
	void (*isr_cb)(void *);
	void *src_handle;
};

struct fman;

typedef irqreturn_t fman_exceptions_cb(struct fman *, enum fman_exceptions);

struct fman_kg_regs;

typedef irqreturn_t fman_bus_error_cb(struct fman *, u8, u64, u8, u16);

struct muram_info___2;

struct fman_keygen;

struct fman_dts_params {
	void *base_addr;
	struct resource *res;
	u8 id;
	int err_irq;
	u16 clk_freq;
	u32 qman_channel_base;
	u32 num_of_qman_channels;
	struct resource muram_res;
};

struct fman_fpm_regs;

struct fman_bmi_regs;

struct fman_qmi_regs;

struct fman_dma_regs;

struct fman_hwp_regs;

struct fman_state_struct;

struct fman_cfg;

struct fman {
	struct device *dev;
	void *base_addr;
	struct fman_intr_src intr_mng[24];
	struct fman_fpm_regs *fpm_regs;
	struct fman_bmi_regs *bmi_regs;
	struct fman_qmi_regs *qmi_regs;
	struct fman_dma_regs *dma_regs;
	struct fman_hwp_regs *hwp_regs;
	struct fman_kg_regs *kg_regs;
	fman_exceptions_cb *exception_cb;
	fman_bus_error_cb *bus_error_cb;
	spinlock_t spinlock;
	struct fman_state_struct *state;
	struct fman_cfg *cfg;
	struct muram_info___2 *muram;
	struct fman_keygen *keygen;
	long unsigned int cam_offset;
	size_t cam_size;
	long unsigned int fifo_offset;
	size_t fifo_size;
	u32 liodn_base[64];
	u32 liodn_offset[64];
	struct fman_dts_params dts_params;
};

struct fman_fpm_regs {
	u32 fmfp_tnc;
	u32 fmfp_prc;
	u32 fmfp_brkc;
	u32 fmfp_mxd;
	u32 fmfp_dist1;
	u32 fmfp_dist2;
	u32 fm_epi;
	u32 fm_rie;
	u32 fmfp_fcev[4];
	u32 res0030[4];
	u32 fmfp_cee[4];
	u32 res0050[4];
	u32 fmfp_tsc1;
	u32 fmfp_tsc2;
	u32 fmfp_tsp;
	u32 fmfp_tsf;
	u32 fm_rcr;
	u32 fmfp_extc;
	u32 fmfp_ext1;
	u32 fmfp_ext2;
	u32 fmfp_drd[16];
	u32 fmfp_dra;
	u32 fm_ip_rev_1;
	u32 fm_ip_rev_2;
	u32 fm_rstc;
	u32 fm_cld;
	u32 fm_npi;
	u32 fmfp_exte;
	u32 fmfp_ee;
	u32 fmfp_cev[4];
	u32 res00f0[4];
	u32 fmfp_ps[50];
	u32 res01c8[14];
	u32 fmfp_clfabc;
	u32 fmfp_clfcc;
	u32 fmfp_clfaval;
	u32 fmfp_clfbval;
	u32 fmfp_clfcval;
	u32 fmfp_clfamsk;
	u32 fmfp_clfbmsk;
	u32 fmfp_clfcmsk;
	u32 fmfp_clfamc;
	u32 fmfp_clfbmc;
	u32 fmfp_clfcmc;
	u32 fmfp_decceh;
	u32 res0230[116];
	u32 fmfp_ts[128];
	u32 res0600[640];
};

struct fman_bmi_regs {
	u32 fmbm_init;
	u32 fmbm_cfg1;
	u32 fmbm_cfg2;
	u32 res000c[5];
	u32 fmbm_ievr;
	u32 fmbm_ier;
	u32 fmbm_ifr;
	u32 res002c[5];
	u32 fmbm_arb[8];
	u32 res0060[12];
	u32 fmbm_dtc[3];
	u32 res009c;
	u32 fmbm_dcv[12];
	u32 fmbm_dcm[12];
	u32 fmbm_gde;
	u32 fmbm_pp[63];
	u32 res0200;
	u32 fmbm_pfs[63];
	u32 res0300;
	u32 fmbm_spliodn[63];
};

struct fman_qmi_regs {
	u32 fmqm_gc;
	u32 res0004;
	u32 fmqm_eie;
	u32 fmqm_eien;
	u32 fmqm_eif;
	u32 fmqm_ie;
	u32 fmqm_ien;
	u32 fmqm_if;
	u32 fmqm_gs;
	u32 fmqm_ts;
	u32 fmqm_etfc;
	u32 fmqm_dtfc;
	u32 fmqm_dc0;
	u32 fmqm_dc1;
	u32 fmqm_dc2;
	u32 fmqm_dc3;
	u32 fmqm_dfdc;
	u32 fmqm_dfcc;
	u32 fmqm_dffc;
	u32 fmqm_dcc;
	u32 res0050[7];
	u32 fmqm_tapc;
	u32 fmqm_dmcvc;
	u32 fmqm_difdcc;
	u32 fmqm_da1v;
	u32 res007c;
	u32 fmqm_dtc;
	u32 fmqm_efddd;
	u32 res0088[2];
	struct {
		u32 fmqm_dtcfg1;
		u32 fmqm_dtval1;
		u32 fmqm_dtm1;
		u32 fmqm_dtc1;
		u32 fmqm_dtcfg2;
		u32 fmqm_dtval2;
		u32 fmqm_dtm2;
		u32 res001c;
	} dbg_traps[3];
	u8 res00f0[784];
};

struct fman_dma_regs {
	u32 fmdmsr;
	u32 fmdmmr;
	u32 fmdmtr;
	u32 fmdmhy;
	u32 fmdmsetr;
	u32 fmdmtah;
	u32 fmdmtal;
	u32 fmdmtcid;
	u32 fmdmra;
	u32 fmdmrd;
	u32 fmdmwcr;
	u32 fmdmebcr;
	u32 fmdmccqdr;
	u32 fmdmccqvr1;
	u32 fmdmccqvr2;
	u32 fmdmcqvr3;
	u32 fmdmcqvr4;
	u32 fmdmcqvr5;
	u32 fmdmsefrc;
	u32 fmdmsqfrc;
	u32 fmdmssrc;
	u32 fmdmdcr;
	u32 fmdmemsr;
	u32 res005c;
	u32 fmdmplr[32];
	u32 res00e0[968];
};

struct fman_hwp_regs {
	u32 res0000[529];
	u32 fmprrpimac;
	u32 res[494];
};

struct fman_state_struct {
	u8 fm_id;
	u16 fm_clk_freq;
	struct fman_rev_info rev_info;
	bool enabled_time_stamp;
	u8 count1_micro_bit;
	u8 total_num_of_tasks;
	u8 accumulated_num_of_tasks;
	u32 accumulated_fifo_size;
	u8 accumulated_num_of_open_dmas;
	u8 accumulated_num_of_deq_tnums;
	u32 exceptions;
	u32 extra_fifo_pool_size;
	u8 extra_tasks_pool_size;
	u8 extra_open_dmas_pool_size;
	u16 port_mfl[10];
	u16 mac_mfl[10];
	u32 fm_iram_size;
	u32 dma_thresh_max_commq;
	u32 dma_thresh_max_buf;
	u32 max_num_of_open_dmas;
	u32 qmi_max_num_of_tnums;
	u32 qmi_def_tnums_thresh;
	u32 bmi_max_num_of_tasks;
	u32 bmi_max_fifo_size;
	u32 fm_port_num_of_cg;
	u32 num_of_rx_ports;
	u32 total_fifo_size;
	u32 qman_channel_base;
	u32 num_of_qman_channels;
	struct resource *res;
};

enum fman_dma_aid_mode {
	FMAN_DMA_AID_OUT_PORT_ID = 0,
	FMAN_DMA_AID_OUT_TNUM = 1,
};

struct fman_cfg {
	u8 disp_limit_tsh;
	u8 prs_disp_tsh;
	u8 plcr_disp_tsh;
	u8 kg_disp_tsh;
	u8 bmi_disp_tsh;
	u8 qmi_enq_disp_tsh;
	u8 qmi_deq_disp_tsh;
	u8 fm_ctl1_disp_tsh;
	u8 fm_ctl2_disp_tsh;
	int dma_cache_override;
	enum fman_dma_aid_mode dma_aid_mode;
	u32 dma_axi_dbg_num_of_beats;
	u32 dma_cam_num_of_entries;
	u32 dma_watchdog;
	u8 dma_comm_qtsh_asrt_emer;
	u32 dma_write_buf_tsh_asrt_emer;
	u32 dma_read_buf_tsh_asrt_emer;
	u8 dma_comm_qtsh_clr_emer;
	u32 dma_write_buf_tsh_clr_emer;
	u32 dma_read_buf_tsh_clr_emer;
	u32 dma_sos_emergency;
	int dma_dbg_cnt_mode;
	int catastrophic_err;
	int dma_err;
	u32 exceptions;
	u16 clk_freq;
	u32 cam_base_addr;
	u32 fifo_base_addr;
	u32 total_fifo_size;
	u32 total_num_of_tasks;
	u32 qmi_def_tnums_thresh;
};

struct fman_port_init_params {
	u8 port_id;
	enum fman_port_type port_type;
	u16 port_speed;
	u16 liodn_offset;
	u8 num_of_tasks;
	u8 num_of_extra_tasks;
	u8 num_of_open_dmas;
	u8 num_of_extra_open_dmas;
	u32 size_of_fifo;
	u32 extra_size_of_fifo;
	u8 deq_pipeline_depth;
	u16 max_frame_length;
	u16 liodn_base;
};

struct fman_iram_regs {
	u32 iadd;
	u32 idata;
	u32 itcfg;
	u32 iready;
};

struct fman_buffer_prefix_content {
	u16 priv_data_size;
	bool pass_prs_result;
	bool pass_time_stamp;
	bool pass_hash_result;
	u16 data_align;
};

struct fman_ext_pool_params {
	u8 id;
	u16 size;
};

struct fman_ext_pools {
	u8 num_of_pools_used;
	struct fman_ext_pool_params ext_buf_pool[8];
};

struct fman_sp_int_context_data_copy {
	u16 ext_buf_offset;
	u8 int_context_offset;
	u16 size;
};

struct fman_sp_buf_margins {
	u16 start_margins;
	u16 end_margins;
};

struct fman_sp_buffer_offsets {
	u32 data_offset;
	u32 prs_result_offset;
	u32 time_stamp_offset;
	u32 hash_result_offset;
};

struct fman_kg_scheme_regs {
	u32 kgse_mode;
	u32 kgse_ekfc;
	u32 kgse_ekdv;
	u32 kgse_bmch;
	u32 kgse_bmcl;
	u32 kgse_fqb;
	u32 kgse_hc;
	u32 kgse_ppc;
	u32 kgse_gec[8];
	u32 kgse_spc;
	u32 kgse_dv0;
	u32 kgse_dv1;
	u32 kgse_ccbs;
	u32 kgse_mv;
	u32 kgse_om;
	u32 kgse_vsp;
};

struct fman_kg_pe_regs {
	u32 fmkg_pe_sp;
	u32 fmkg_pe_cpp;
};

struct fman_kg_regs___2 {
	u32 fmkg_gcr;
	u32 res004;
	u32 res008;
	u32 fmkg_eer;
	u32 fmkg_eeer;
	u32 res014;
	u32 res018;
	u32 fmkg_seer;
	u32 fmkg_seeer;
	u32 fmkg_gsr;
	u32 fmkg_tpc;
	u32 fmkg_serc;
	u32 res030[4];
	u32 fmkg_fdor;
	u32 fmkg_gdv0r;
	u32 fmkg_gdv1r;
	u32 res04c[6];
	u32 fmkg_feer;
	u32 res068[38];
	union {
		u32 fmkg_indirect[63];
		struct fman_kg_scheme_regs fmkg_sch;
		struct fman_kg_pe_regs fmkg_pe;
	};
	u32 fmkg_ar;
};

struct keygen_scheme {
	bool used;
	u8 hw_port_id;
	u32 base_fqid;
	u32 hash_fqid_count;
	bool use_hashing;
	bool symmetric_hash;
	u8 hashShift;
	u32 match_vector;
};

struct fman_keygen___2 {
	struct keygen_scheme schemes[32];
	struct fman_kg_regs___2 *keygen_regs;
};

struct fman_buf_pool_depletion {
	bool pools_grp_mode_enable;
	u8 num_of_pools;
	bool pools_to_consider[64];
	bool single_pool_mode_enable;
	bool pools_to_consider_for_single_mode[64];
};

struct fman_port_rx_params {
	u32 err_fqid;
	u32 dflt_fqid;
	u32 pcd_base_fqid;
	u32 pcd_fqs_count;
	struct fman_ext_pools ext_buf_pools;
};

struct fman_port_non_rx_params {
	u32 err_fqid;
	u32 dflt_fqid;
};

union fman_port_specific_params {
	struct fman_port_rx_params rx_params;
	struct fman_port_non_rx_params non_rx_params;
};

struct fman_port_params {
	void *fm;
	union fman_port_specific_params specific_params;
};

struct fman_port_rx_bmi_regs {
	u32 fmbm_rcfg;
	u32 fmbm_rst;
	u32 fmbm_rda;
	u32 fmbm_rfp;
	u32 fmbm_rfed;
	u32 fmbm_ricp;
	u32 fmbm_rim;
	u32 fmbm_rebm;
	u32 fmbm_rfne;
	u32 fmbm_rfca;
	u32 fmbm_rfpne;
	u32 fmbm_rpso;
	u32 fmbm_rpp;
	u32 fmbm_rccb;
	u32 fmbm_reth;
	u32 reserved003c[1];
	u32 fmbm_rprai[8];
	u32 fmbm_rfqid;
	u32 fmbm_refqid;
	u32 fmbm_rfsdm;
	u32 fmbm_rfsem;
	u32 fmbm_rfene;
	u32 reserved0074[2];
	u32 fmbm_rcmne;
	u32 reserved0080[32];
	u32 fmbm_ebmpi[8];
	u32 fmbm_acnt[8];
	u32 reserved0130[8];
	u32 fmbm_rcgm[8];
	u32 fmbm_mpd;
	u32 reserved0184[31];
	u32 fmbm_rstc;
	u32 fmbm_rfrc;
	u32 fmbm_rfbc;
	u32 fmbm_rlfc;
	u32 fmbm_rffc;
	u32 fmbm_rfdc;
	u32 fmbm_rfldec;
	u32 fmbm_rodc;
	u32 fmbm_rbdc;
	u32 fmbm_rpec;
	u32 reserved0224[22];
	u32 fmbm_rpc;
	u32 fmbm_rpcp;
	u32 fmbm_rccn;
	u32 fmbm_rtuc;
	u32 fmbm_rrquc;
	u32 fmbm_rduc;
	u32 fmbm_rfuc;
	u32 fmbm_rpac;
	u32 reserved02a0[24];
	u32 fmbm_rdcfg[3];
	u32 fmbm_rgpr;
	u32 reserved0310[58];
};

struct fman_port_tx_bmi_regs {
	u32 fmbm_tcfg;
	u32 fmbm_tst;
	u32 fmbm_tda;
	u32 fmbm_tfp;
	u32 fmbm_tfed;
	u32 fmbm_ticp;
	u32 fmbm_tfdne;
	u32 fmbm_tfca;
	u32 fmbm_tcfqid;
	u32 fmbm_tefqid;
	u32 fmbm_tfene;
	u32 fmbm_trlmts;
	u32 fmbm_trlmt;
	u32 reserved0034[14];
	u32 fmbm_tccb;
	u32 fmbm_tfne;
	u32 fmbm_tpfcm[2];
	u32 fmbm_tcmne;
	u32 reserved0080[96];
	u32 fmbm_tstc;
	u32 fmbm_tfrc;
	u32 fmbm_tfdc;
	u32 fmbm_tfledc;
	u32 fmbm_tfufdc;
	u32 fmbm_tbdc;
	u32 reserved0218[26];
	u32 fmbm_tpc;
	u32 fmbm_tpcp;
	u32 fmbm_tccn;
	u32 fmbm_ttuc;
	u32 fmbm_ttcquc;
	u32 fmbm_tduc;
	u32 fmbm_tfuc;
	u32 reserved029c[16];
	u32 fmbm_tdcfg[3];
	u32 fmbm_tgpr;
	u32 reserved0310[58];
};

union fman_port_bmi_regs {
	struct fman_port_rx_bmi_regs rx;
	struct fman_port_tx_bmi_regs tx;
};

struct fman_port_qmi_regs {
	u32 fmqm_pnc;
	u32 fmqm_pns;
	u32 fmqm_pnts;
	u32 reserved00c[4];
	u32 fmqm_pnen;
	u32 fmqm_pnetfc;
	u32 reserved024[2];
	u32 fmqm_pndn;
	u32 fmqm_pndc;
	u32 fmqm_pndtfc;
	u32 fmqm_pndfdc;
	u32 fmqm_pndcc;
};

struct fman_port_hwp_regs {
	struct {
		u32 ssa;
		u32 lcv;
	} pmda[16];
	u32 reserved080[222];
	u32 fmpr_pcac;
};

enum fman_port_deq_prefetch {
	FMAN_PORT_DEQ_NO_PREFETCH = 0,
	FMAN_PORT_DEQ_PART_PREFETCH = 1,
	FMAN_PORT_DEQ_FULL_PREFETCH = 2,
};

struct fman_port_rsrc {
	u32 num;
	u32 extra;
};

enum fman_port_dma_swap {
	FMAN_PORT_DMA_NO_SWAP = 0,
	FMAN_PORT_DMA_SWAP_LE = 1,
	FMAN_PORT_DMA_SWAP_BE = 2,
};

enum fman_port_color {
	FMAN_PORT_COLOR_GREEN = 0,
	FMAN_PORT_COLOR_YELLOW = 1,
	FMAN_PORT_COLOR_RED = 2,
	FMAN_PORT_COLOR_OVERRIDE = 3,
};

enum fman_port_deq_type {
	FMAN_PORT_DEQ_BY_PRI = 0,
	FMAN_PORT_DEQ_ACTIVE_FQ = 1,
	FMAN_PORT_DEQ_ACTIVE_FQ_NO_ICS = 2,
};

struct fman_port_bpools {
	u8 count;
	bool counters_enable;
	u8 grp_bp_depleted_num;
	struct {
		u8 bpid;
		u16 size;
		bool is_backup;
		bool grp_bp_depleted;
		bool single_bp_depleted;
	} bpool[8];
};

struct fman_port_cfg {
	u32 dflt_fqid;
	u32 err_fqid;
	u32 pcd_base_fqid;
	u32 pcd_fqs_count;
	u8 deq_sp;
	bool deq_high_priority;
	enum fman_port_deq_type deq_type;
	enum fman_port_deq_prefetch deq_prefetch_option;
	u16 deq_byte_cnt;
	u8 cheksum_last_bytes_ignore;
	u8 rx_cut_end_bytes;
	struct fman_buf_pool_depletion buf_pool_depletion;
	struct fman_ext_pools ext_buf_pools;
	u32 tx_fifo_min_level;
	u32 tx_fifo_low_comf_level;
	u32 rx_pri_elevation;
	u32 rx_fifo_thr;
	struct fman_sp_buf_margins buf_margins;
	u32 int_buf_start_margin;
	struct fman_sp_int_context_data_copy int_context;
	u32 discard_mask;
	u32 err_mask;
	struct fman_buffer_prefix_content buffer_prefix_content;
	bool dont_release_buf;
	u8 rx_fd_bits;
	u32 tx_fifo_deq_pipeline_depth;
	bool errata_A006320;
	bool excessive_threshold_register;
	bool fmbm_tfne_has_features;
	enum fman_port_dma_swap dma_swap_data;
	enum fman_port_color color;
};

struct fman_port_rx_pools_params {
	u8 num_of_pools;
	u16 largest_buf_size;
};

struct fman_port_dts_params {
	void *base_addr;
	enum fman_port_type type;
	u16 speed;
	u8 id;
	u32 qman_channel_id;
	struct fman *fman;
};

struct fman_port {
	void *fm;
	struct device *dev;
	struct fman_rev_info rev_info;
	u8 port_id;
	enum fman_port_type port_type;
	u16 port_speed;
	union fman_port_bmi_regs *bmi_regs;
	struct fman_port_qmi_regs *qmi_regs;
	struct fman_port_hwp_regs *hwp_regs;
	struct fman_sp_buffer_offsets buffer_offsets;
	u8 internal_buf_offset;
	struct fman_ext_pools ext_buf_pools;
	u16 max_frame_length;
	struct fman_port_rsrc open_dmas;
	struct fman_port_rsrc tasks;
	struct fman_port_rsrc fifo_bufs;
	struct fman_port_rx_pools_params rx_pools_params;
	struct fman_port_cfg *cfg;
	struct fman_port_dts_params dts_params;
	u8 ext_pools_num;
	u32 max_port_fifo_size;
	u32 max_num_of_ext_pools;
	u32 max_num_of_sub_portals;
	u32 bm_max_num_of_pools;
};

typedef u8 enet_addr_t[6];

enum comm_mode {
	COMM_MODE_NONE = 0,
	COMM_MODE_RX = 1,
	COMM_MODE_TX = 2,
	COMM_MODE_RX_AND_TX = 3,
};

enum fman_mac_exceptions {
	FM_MAC_EX_10G_MDIO_SCAN_EVENT = 0,
	FM_MAC_EX_10G_MDIO_CMD_CMPL = 1,
	FM_MAC_EX_10G_REM_FAULT = 2,
	FM_MAC_EX_10G_LOC_FAULT = 3,
	FM_MAC_EX_10G_TX_ECC_ER = 4,
	FM_MAC_EX_10G_TX_FIFO_UNFL = 5,
	FM_MAC_EX_10G_TX_FIFO_OVFL = 6,
	FM_MAC_EX_10G_TX_ER = 7,
	FM_MAC_EX_10G_RX_FIFO_OVFL = 8,
	FM_MAC_EX_10G_RX_ECC_ER = 9,
	FM_MAC_EX_10G_RX_JAB_FRM = 10,
	FM_MAC_EX_10G_RX_OVRSZ_FRM = 11,
	FM_MAC_EX_10G_RX_RUNT_FRM = 12,
	FM_MAC_EX_10G_RX_FRAG_FRM = 13,
	FM_MAC_EX_10G_RX_LEN_ER = 14,
	FM_MAC_EX_10G_RX_CRC_ER = 15,
	FM_MAC_EX_10G_RX_ALIGN_ER = 16,
	FM_MAC_EX_1G_BAB_RX = 17,
	FM_MAC_EX_1G_RX_CTL = 18,
	FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET = 19,
	FM_MAC_EX_1G_BAB_TX = 20,
	FM_MAC_EX_1G_TX_CTL = 21,
	FM_MAC_EX_1G_TX_ERR = 22,
	FM_MAC_EX_1G_LATE_COL = 23,
	FM_MAC_EX_1G_COL_RET_LMT = 24,
	FM_MAC_EX_1G_TX_FIFO_UNDRN = 25,
	FM_MAC_EX_1G_MAG_PCKT = 26,
	FM_MAC_EX_1G_MII_MNG_RD_COMPLET = 27,
	FM_MAC_EX_1G_MII_MNG_WR_COMPLET = 28,
	FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET = 29,
	FM_MAC_EX_1G_DATA_ERR = 30,
	FM_MAC_1G_RX_DATA_ERR = 31,
	FM_MAC_EX_1G_1588_TS_RX_ERR = 32,
	FM_MAC_EX_1G_RX_MIB_CNT_OVFL = 33,
	FM_MAC_EX_TS_FIFO_ECC_ERR = 34,
	FM_MAC_EX_MAGIC_PACKET_INDICATION = 26,
};

typedef void fman_mac_exception_cb(void *, enum fman_mac_exceptions);

struct fman_mac_params {
	void *base_addr;
	enet_addr_t addr;
	u8 mac_id;
	phy_interface_t phy_if;
	u16 max_speed;
	void *fm;
	void *dev_id;
	fman_mac_exception_cb *event_cb;
	fman_mac_exception_cb *exception_cb;
	bool basex_if;
	struct device_node *internal_phy_node;
};

struct fman_port___2;

struct fman_mac;

struct mac_priv_s;

struct mac_device {
	struct resource *res;
	u8 addr[6];
	struct fman_port___2 *port[2];
	u32 if_support;
	struct phy_device *phy_dev;
	phy_interface_t phy_if;
	struct device_node *phy_node;
	bool autoneg_pause;
	bool rx_pause_req;
	bool tx_pause_req;
	bool rx_pause_active;
	bool tx_pause_active;
	bool promisc;
	bool allmulti;
	int (*init)(struct mac_device *);
	int (*start)(struct mac_device *);
	int (*stop)(struct mac_device *);
	void (*adjust_link)(struct mac_device *);
	int (*set_promisc)(struct fman_mac *, bool);
	int (*change_addr)(struct fman_mac *, enet_addr_t *);
	int (*set_allmulti)(struct fman_mac *, bool);
	int (*set_tstamp)(struct fman_mac *, bool);
	int (*set_multi)(struct net_device *, struct mac_device *);
	int (*set_rx_pause)(struct fman_mac *, bool);
	int (*set_tx_pause)(struct fman_mac *, u8, u16, u16);
	int (*set_exception)(struct fman_mac *, enum fman_mac_exceptions, bool);
	int (*add_hash_mac_addr)(struct fman_mac *, enet_addr_t *);
	int (*remove_hash_mac_addr)(struct fman_mac *, enet_addr_t *);
	struct fman_mac *fman_mac;
	struct mac_priv_s *priv;
};

struct mac_priv_s {
	struct device *dev;
	void *vaddr;
	u8 cell_index;
	struct fman *fman;
	struct device_node *internal_phy_node;
	struct list_head mc_addr_list;
	struct platform_device *eth_dev;
	struct fixed_phy_status *fixed_link;
	u16 speed;
	u16 max_speed;
	int (*enable)(struct fman_mac *, enum comm_mode);
	int (*disable)(struct fman_mac *, enum comm_mode);
};

struct dpaa_eth_data {
	struct mac_device *mac_dev;
	int mac_hw_id;
	int fman_hw_id;
};

struct mac_address {
	u8 addr[6];
	struct list_head list;
};

struct eth_hash_entry {
	u64 addr;
	struct list_head node;
};

struct eth_hash_t {
	u16 size;
	struct list_head *lsts;
};

struct dtsec_regs {
	u32 tsec_id;
	u32 tsec_id2;
	u32 ievent;
	u32 imask;
	u32 reserved0010[1];
	u32 ecntrl;
	u32 ptv;
	u32 tbipa;
	u32 tmr_ctrl;
	u32 tmr_pevent;
	u32 tmr_pemask;
	u32 reserved002c[5];
	u32 tctrl;
	u32 reserved0044[3];
	u32 rctrl;
	u32 reserved0054[11];
	u32 igaddr[8];
	u32 gaddr[8];
	u32 reserved00c0[16];
	u32 maccfg1;
	u32 maccfg2;
	u32 ipgifg;
	u32 hafdup;
	u32 maxfrm;
	u32 reserved0114[10];
	u32 ifstat;
	u32 macstnaddr1;
	u32 macstnaddr2;
	struct {
		u32 exact_match1;
		u32 exact_match2;
	} macaddr[15];
	u32 reserved01c0[16];
	u32 tr64;
	u32 tr127;
	u32 tr255;
	u32 tr511;
	u32 tr1k;
	u32 trmax;
	u32 trmgv;
	u32 rbyt;
	u32 rpkt;
	u32 rfcs;
	u32 rmca;
	u32 rbca;
	u32 rxcf;
	u32 rxpf;
	u32 rxuo;
	u32 raln;
	u32 rflr;
	u32 rcde;
	u32 rcse;
	u32 rund;
	u32 rovr;
	u32 rfrg;
	u32 rjbr;
	u32 rdrp;
	u32 tbyt;
	u32 tpkt;
	u32 tmca;
	u32 tbca;
	u32 txpf;
	u32 tdfr;
	u32 tedf;
	u32 tscl;
	u32 tmcl;
	u32 tlcl;
	u32 txcl;
	u32 tncl;
	u32 reserved0290[1];
	u32 tdrp;
	u32 tjbr;
	u32 tfcs;
	u32 txcf;
	u32 tovr;
	u32 tund;
	u32 tfrg;
	u32 car1;
	u32 car2;
	u32 cam1;
	u32 cam2;
	u32 reserved02c0[848];
};

struct dtsec_cfg {
	u16 halfdup_retransmit;
	u16 halfdup_coll_window;
	bool tx_pad_crc;
	u16 tx_pause_time;
	bool ptp_tsu_en;
	bool ptp_exception_en;
	u32 preamble_len;
	u32 rx_prepend;
	u16 tx_pause_time_extd;
	u16 maximum_frame;
	u32 non_back_to_back_ipg1;
	u32 non_back_to_back_ipg2;
	u32 min_ifg_enforcement;
	u32 back_to_back_ipg;
};

struct fman_mac___2 {
	struct dtsec_regs *regs;
	u64 addr;
	phy_interface_t phy_if;
	u16 max_speed;
	void *dev_id;
	fman_mac_exception_cb *exception_cb;
	fman_mac_exception_cb *event_cb;
	u8 num_of_ind_addr_in_regs;
	struct eth_hash_t *multicast_addr_hash;
	struct eth_hash_t *unicast_addr_hash;
	u8 mac_id;
	u32 exceptions;
	bool ptp_tsu_enabled;
	bool en_tsu_err_exception;
	struct dtsec_cfg *dtsec_drv_param;
	void *fm;
	struct fman_rev_info fm_rev_info;
	bool basex_if;
	struct phy_device *tbiphy;
};

struct mac_addr {
	u32 mac_addr_l;
	u32 mac_addr_u;
};

struct memac_regs {
	u32 res0000[2];
	u32 command_config;
	struct mac_addr mac_addr0;
	u32 maxfrm;
	u32 res0018[1];
	u32 rx_fifo_sections;
	u32 tx_fifo_sections;
	u32 res0024[2];
	u32 hashtable_ctrl;
	u32 res0030[4];
	u32 ievent;
	u32 tx_ipg_length;
	u32 res0048;
	u32 imask;
	u32 res0050;
	u32 pause_quanta[4];
	u32 pause_thresh[4];
	u32 rx_pause_status;
	u32 res0078[2];
	struct mac_addr mac_addr[7];
	u32 lpwake_timer;
	u32 sleep_timer;
	u32 res00c0[8];
	u32 statn_config;
	u32 res00e4[7];
	u32 reoct_l;
	u32 reoct_u;
	u32 roct_l;
	u32 roct_u;
	u32 raln_l;
	u32 raln_u;
	u32 rxpf_l;
	u32 rxpf_u;
	u32 rfrm_l;
	u32 rfrm_u;
	u32 rfcs_l;
	u32 rfcs_u;
	u32 rvlan_l;
	u32 rvlan_u;
	u32 rerr_l;
	u32 rerr_u;
	u32 ruca_l;
	u32 ruca_u;
	u32 rmca_l;
	u32 rmca_u;
	u32 rbca_l;
	u32 rbca_u;
	u32 rdrp_l;
	u32 rdrp_u;
	u32 rpkt_l;
	u32 rpkt_u;
	u32 rund_l;
	u32 rund_u;
	u32 r64_l;
	u32 r64_u;
	u32 r127_l;
	u32 r127_u;
	u32 r255_l;
	u32 r255_u;
	u32 r511_l;
	u32 r511_u;
	u32 r1023_l;
	u32 r1023_u;
	u32 r1518_l;
	u32 r1518_u;
	u32 r1519x_l;
	u32 r1519x_u;
	u32 rovr_l;
	u32 rovr_u;
	u32 rjbr_l;
	u32 rjbr_u;
	u32 rfrg_l;
	u32 rfrg_u;
	u32 rcnp_l;
	u32 rcnp_u;
	u32 rdrntp_l;
	u32 rdrntp_u;
	u32 res01d0[12];
	u32 teoct_l;
	u32 teoct_u;
	u32 toct_l;
	u32 toct_u;
	u32 res0210[2];
	u32 txpf_l;
	u32 txpf_u;
	u32 tfrm_l;
	u32 tfrm_u;
	u32 tfcs_l;
	u32 tfcs_u;
	u32 tvlan_l;
	u32 tvlan_u;
	u32 terr_l;
	u32 terr_u;
	u32 tuca_l;
	u32 tuca_u;
	u32 tmca_l;
	u32 tmca_u;
	u32 tbca_l;
	u32 tbca_u;
	u32 res0258[2];
	u32 tpkt_l;
	u32 tpkt_u;
	u32 tund_l;
	u32 tund_u;
	u32 t64_l;
	u32 t64_u;
	u32 t127_l;
	u32 t127_u;
	u32 t255_l;
	u32 t255_u;
	u32 t511_l;
	u32 t511_u;
	u32 t1023_l;
	u32 t1023_u;
	u32 t1518_l;
	u32 t1518_u;
	u32 t1519x_l;
	u32 t1519x_u;
	u32 res02a8[6];
	u32 tcnp_l;
	u32 tcnp_u;
	u32 res02c8[14];
	u32 if_mode;
	u32 if_status;
	u32 res0308[14];
	u32 hg_config;
	u32 res0344[3];
	u32 hg_pause_quanta;
	u32 res0354[3];
	u32 hg_pause_thresh;
	u32 res0364[3];
	u32 hgrx_pause_status;
	u32 hg_fifos_status;
	u32 rhm;
	u32 thm;
};

struct memac_cfg {
	bool reset_on_init;
	bool pause_ignore;
	bool promiscuous_mode_enable;
	struct fixed_phy_status *fixed_link;
	u16 max_frame_length;
	u16 pause_quanta;
	u32 tx_ipg_length;
};

struct fman_mac___3 {
	struct memac_regs *regs;
	u64 addr;
	phy_interface_t phy_if;
	u16 max_speed;
	void *dev_id;
	fman_mac_exception_cb *exception_cb;
	fman_mac_exception_cb *event_cb;
	struct eth_hash_t *multicast_addr_hash;
	struct eth_hash_t *unicast_addr_hash;
	u8 mac_id;
	u32 exceptions;
	struct memac_cfg *memac_drv_param;
	void *fm;
	struct fman_rev_info fm_rev_info;
	bool basex_if;
	struct phy_device *pcsphy;
	bool allmulti_enabled;
};

struct tgec_regs {
	u32 tgec_id;
	u32 reserved001[1];
	u32 command_config;
	u32 mac_addr_0;
	u32 mac_addr_1;
	u32 maxfrm;
	u32 pause_quant;
	u32 rx_fifo_sections;
	u32 tx_fifo_sections;
	u32 rx_fifo_almost_f_e;
	u32 tx_fifo_almost_f_e;
	u32 hashtable_ctrl;
	u32 mdio_cfg_status;
	u32 mdio_command;
	u32 mdio_data;
	u32 mdio_regaddr;
	u32 status;
	u32 tx_ipg_len;
	u32 mac_addr_2;
	u32 mac_addr_3;
	u32 rx_fifo_ptr_rd;
	u32 rx_fifo_ptr_wr;
	u32 tx_fifo_ptr_rd;
	u32 tx_fifo_ptr_wr;
	u32 imask;
	u32 ievent;
	u32 udp_port;
	u32 type_1588v2;
	u32 reserved070[4];
	u32 tfrm_u;
	u32 tfrm_l;
	u32 rfrm_u;
	u32 rfrm_l;
	u32 rfcs_u;
	u32 rfcs_l;
	u32 raln_u;
	u32 raln_l;
	u32 txpf_u;
	u32 txpf_l;
	u32 rxpf_u;
	u32 rxpf_l;
	u32 rlong_u;
	u32 rlong_l;
	u32 rflr_u;
	u32 rflr_l;
	u32 tvlan_u;
	u32 tvlan_l;
	u32 rvlan_u;
	u32 rvlan_l;
	u32 toct_u;
	u32 toct_l;
	u32 roct_u;
	u32 roct_l;
	u32 ruca_u;
	u32 ruca_l;
	u32 rmca_u;
	u32 rmca_l;
	u32 rbca_u;
	u32 rbca_l;
	u32 terr_u;
	u32 terr_l;
	u32 reserved100[2];
	u32 tuca_u;
	u32 tuca_l;
	u32 tmca_u;
	u32 tmca_l;
	u32 tbca_u;
	u32 tbca_l;
	u32 rdrp_u;
	u32 rdrp_l;
	u32 reoct_u;
	u32 reoct_l;
	u32 rpkt_u;
	u32 rpkt_l;
	u32 trund_u;
	u32 trund_l;
	u32 r64_u;
	u32 r64_l;
	u32 r127_u;
	u32 r127_l;
	u32 r255_u;
	u32 r255_l;
	u32 r511_u;
	u32 r511_l;
	u32 r1023_u;
	u32 r1023_l;
	u32 r1518_u;
	u32 r1518_l;
	u32 r1519x_u;
	u32 r1519x_l;
	u32 trovr_u;
	u32 trovr_l;
	u32 trjbr_u;
	u32 trjbr_l;
	u32 trfrg_u;
	u32 trfrg_l;
	u32 rerr_u;
	u32 rerr_l;
};

struct tgec_cfg {
	bool pause_ignore;
	bool promiscuous_mode_enable;
	u16 max_frame_length;
	u16 pause_quant;
	u32 tx_ipg_length;
};

struct fman_mac___4 {
	struct tgec_regs *regs;
	u64 addr;
	u16 max_speed;
	void *dev_id;
	fman_mac_exception_cb *exception_cb;
	fman_mac_exception_cb *event_cb;
	struct eth_hash_t *multicast_addr_hash;
	struct eth_hash_t *unicast_addr_hash;
	u8 mac_id;
	u32 exceptions;
	struct tgec_cfg *cfg;
	void *fm;
	struct fman_rev_info fm_rev_info;
	bool allmulti_enabled;
};

struct smc91x_platdata {
	long unsigned int flags;
	unsigned char leda;
	unsigned char ledb;
	bool pxa_u16_align4;
};

struct smc_local {
	struct sk_buff *pending_tx_skb;
	struct tasklet_struct tx_task;
	struct gpio_desc *power_gpio;
	struct gpio_desc *reset_gpio;
	int version;
	int tcr_cur_mode;
	int rcr_cur_mode;
	int rpc_cur_mode;
	int ctl_rfduplx;
	int ctl_rspeed;
	u32 msg_enable;
	u32 phy_type;
	struct mii_if_info mii;
	struct work_struct phy_configure;
	struct net_device *dev;
	int work_pending;
	spinlock_t lock;
	struct dma_chan *dma_chan;
	void *base;
	void *datacs;
	int io_shift;
	bool half_word_align4;
	struct smc91x_platdata cfg;
};

struct mdio_platform_data {
	long unsigned int bus_freq;
};

struct davinci_mdio_of_param {
	int autosuspend_delay_ms;
};

struct davinci_mdio_regs {
	u32 version;
	u32 control;
	u32 alive;
	u32 link;
	u32 linkintraw;
	u32 linkintmasked;
	u32 __reserved_0[2];
	u32 userintraw;
	u32 userintmasked;
	u32 userintmaskset;
	u32 userintmaskclr;
	u32 __reserved_1[20];
	struct {
		u32 access;
		u32 physel;
	} user[0];
};

struct davinci_mdio_data {
	struct mdio_platform_data pdata;
	struct davinci_mdio_regs *regs;
	struct clk *clk;
	struct device *dev;
	struct mii_bus *bus;
	bool active_in_suspend;
	long unsigned int access_time;
	bool skip_scan;
	u32 clk_div;
};

enum {
	IFLA_UNSPEC = 0,
	IFLA_ADDRESS = 1,
	IFLA_BROADCAST = 2,
	IFLA_IFNAME = 3,
	IFLA_MTU = 4,
	IFLA_LINK = 5,
	IFLA_QDISC = 6,
	IFLA_STATS = 7,
	IFLA_COST = 8,
	IFLA_PRIORITY = 9,
	IFLA_MASTER = 10,
	IFLA_WIRELESS = 11,
	IFLA_PROTINFO = 12,
	IFLA_TXQLEN = 13,
	IFLA_MAP = 14,
	IFLA_WEIGHT = 15,
	IFLA_OPERSTATE = 16,
	IFLA_LINKMODE = 17,
	IFLA_LINKINFO = 18,
	IFLA_NET_NS_PID = 19,
	IFLA_IFALIAS = 20,
	IFLA_NUM_VF = 21,
	IFLA_VFINFO_LIST = 22,
	IFLA_STATS64 = 23,
	IFLA_VF_PORTS = 24,
	IFLA_PORT_SELF = 25,
	IFLA_AF_SPEC = 26,
	IFLA_GROUP = 27,
	IFLA_NET_NS_FD = 28,
	IFLA_EXT_MASK = 29,
	IFLA_PROMISCUITY = 30,
	IFLA_NUM_TX_QUEUES = 31,
	IFLA_NUM_RX_QUEUES = 32,
	IFLA_CARRIER = 33,
	IFLA_PHYS_PORT_ID = 34,
	IFLA_CARRIER_CHANGES = 35,
	IFLA_PHYS_SWITCH_ID = 36,
	IFLA_LINK_NETNSID = 37,
	IFLA_PHYS_PORT_NAME = 38,
	IFLA_PROTO_DOWN = 39,
	IFLA_GSO_MAX_SEGS = 40,
	IFLA_GSO_MAX_SIZE = 41,
	IFLA_PAD = 42,
	IFLA_XDP = 43,
	IFLA_EVENT = 44,
	IFLA_NEW_NETNSID = 45,
	IFLA_IF_NETNSID = 46,
	IFLA_TARGET_NETNSID = 46,
	IFLA_CARRIER_UP_COUNT = 47,
	IFLA_CARRIER_DOWN_COUNT = 48,
	IFLA_NEW_IFINDEX = 49,
	IFLA_MIN_MTU = 50,
	IFLA_MAX_MTU = 51,
	IFLA_PROP_LIST = 52,
	IFLA_ALT_IFNAME = 53,
	IFLA_PERM_ADDRESS = 54,
	IFLA_PROTO_DOWN_REASON = 55,
	__IFLA_MAX = 56,
};

enum {
	IFLA_PPP_UNSPEC = 0,
	IFLA_PPP_DEV_FD = 1,
	__IFLA_PPP_MAX = 2,
};

enum NPmode {
	NPMODE_PASS = 0,
	NPMODE_DROP = 1,
	NPMODE_ERROR = 2,
	NPMODE_QUEUE = 3,
};

struct pppstat {
	__u32 ppp_discards;
	__u32 ppp_ibytes;
	__u32 ppp_ioctects;
	__u32 ppp_ipackets;
	__u32 ppp_ierrors;
	__u32 ppp_ilqrs;
	__u32 ppp_obytes;
	__u32 ppp_ooctects;
	__u32 ppp_opackets;
	__u32 ppp_oerrors;
	__u32 ppp_olqrs;
};

struct vjstat {
	__u32 vjs_packets;
	__u32 vjs_compressed;
	__u32 vjs_searches;
	__u32 vjs_misses;
	__u32 vjs_uncompressedin;
	__u32 vjs_compressedin;
	__u32 vjs_errorin;
	__u32 vjs_tossed;
};

struct compstat {
	__u32 unc_bytes;
	__u32 unc_packets;
	__u32 comp_bytes;
	__u32 comp_packets;
	__u32 inc_bytes;
	__u32 inc_packets;
	__u32 in_count;
	__u32 bytes_out;
	double ratio;
};

struct ppp_stats {
	struct pppstat p;
	struct vjstat vj;
};

struct ppp_comp_stats {
	struct compstat c;
	struct compstat d;
};

struct ppp_idle32 {
	__s32 xmit_idle;
	__s32 recv_idle;
};

struct ppp_idle64 {
	__s64 xmit_idle;
	__s64 recv_idle;
};

struct npioctl {
	int protocol;
	enum NPmode mode;
};

struct ppp_option_data {
	__u8 *ptr;
	__u32 length;
	int transmit;
};

struct ppp_channel;

struct ppp_channel_ops {
	int (*start_xmit)(struct ppp_channel *, struct sk_buff *);
	int (*ioctl)(struct ppp_channel *, unsigned int, long unsigned int);
	int (*fill_forward_path)(struct net_device_path_ctx *, struct net_device_path *, const struct ppp_channel *);
};

struct ppp_channel {
	void *private;
	const struct ppp_channel_ops *ops;
	int mtu;
	int hdrlen;
	void *ppp;
	int speed;
	int latency;
};

struct compressor {
	int compress_proto;
	void * (*comp_alloc)(unsigned char *, int);
	void (*comp_free)(void *);
	int (*comp_init)(void *, unsigned char *, int, int, int, int);
	void (*comp_reset)(void *);
	int (*compress)(void *, unsigned char *, unsigned char *, int, int);
	void (*comp_stat)(void *, struct compstat *);
	void * (*decomp_alloc)(unsigned char *, int);
	void (*decomp_free)(void *);
	int (*decomp_init)(void *, unsigned char *, int, int, int, int, int);
	void (*decomp_reset)(void *);
	int (*decompress)(void *, unsigned char *, int, unsigned char *, int);
	void (*incomp)(void *, unsigned char *, int);
	void (*decomp_stat)(void *, struct compstat *);
	struct module *owner;
	unsigned int comp_extra;
};

typedef __u8 byte_t;

typedef __u32 int32;

struct cstate___2 {
	byte_t cs_this;
	bool initialized;
	struct cstate___2 *next;
	struct iphdr cs_ip;
	struct tcphdr cs_tcp;
	unsigned char cs_ipopt[64];
	unsigned char cs_tcpopt[64];
	int cs_hsize;
};

struct slcompress {
	struct cstate___2 *tstate;
	struct cstate___2 *rstate;
	byte_t tslot_limit;
	byte_t rslot_limit;
	byte_t xmit_oldest;
	byte_t xmit_current;
	byte_t recv_current;
	byte_t flags;
	int32 sls_o_nontcp;
	int32 sls_o_tcp;
	int32 sls_o_uncompressed;
	int32 sls_o_compressed;
	int32 sls_o_searches;
	int32 sls_o_misses;
	int32 sls_i_uncompressed;
	int32 sls_i_compressed;
	int32 sls_i_error;
	int32 sls_i_tossed;
	int32 sls_i_runt;
	int32 sls_i_badcheck;
};

struct ppp_file {
	enum {
		INTERFACE = 1,
		CHANNEL = 2,
	} kind;
	struct sk_buff_head xq;
	struct sk_buff_head rq;
	wait_queue_head_t rwait;
	refcount_t refcnt;
	int hdrlen;
	int index;
	int dead;
};

struct ppp_link_stats {
	u64 rx_packets;
	u64 tx_packets;
	u64 rx_bytes;
	u64 tx_bytes;
};

struct ppp {
	struct ppp_file file;
	struct file *owner;
	struct list_head channels;
	int n_channels;
	spinlock_t rlock;
	spinlock_t wlock;
	int *xmit_recursion;
	int mru;
	unsigned int flags;
	unsigned int xstate;
	unsigned int rstate;
	int debug;
	struct slcompress *vj;
	enum NPmode npmode[6];
	struct sk_buff *xmit_pending;
	struct compressor *xcomp;
	void *xc_state;
	struct compressor *rcomp;
	void *rc_state;
	long unsigned int last_xmit;
	long unsigned int last_recv;
	struct net_device *dev;
	int closing;
	int nxchan;
	u32 nxseq;
	int mrru;
	u32 nextseq;
	u32 minseq;
	struct sk_buff_head mrq;
	struct bpf_prog *pass_filter;
	struct bpf_prog *active_filter;
	struct net *ppp_net;
	struct ppp_link_stats stats64;
};

struct channel {
	struct ppp_file file;
	struct list_head list;
	struct ppp_channel *chan;
	struct rw_semaphore chan_sem;
	spinlock_t downl;
	struct ppp *ppp;
	struct net *chan_net;
	struct list_head clist;
	rwlock_t upl;
	struct channel *bridge;
	u8 avail;
	u8 had_frag;
	u32 lastseq;
	int speed;
};

struct ppp_config {
	struct file *file;
	s32 unit;
	bool ifname_is_set;
};

struct ppp_net {
	struct idr units_idr;
	struct mutex all_ppp_mutex;
	struct list_head all_channels;
	struct list_head new_channels;
	int last_channel_index;
	spinlock_t all_channels_lock;
};

struct sock_fprog32 {
	short unsigned int len;
	compat_caddr_t filter;
};

struct ppp_option_data32 {
	compat_uptr_t ptr;
	u32 length;
	compat_int_t transmit;
};

struct ppp_mp_skb_parm {
	u32 sequence;
	u8 BEbits;
};

struct compressor_entry {
	struct list_head list;
	struct compressor *comp;
};

struct offload_callbacks {
	struct sk_buff * (*gso_segment)(struct sk_buff *, netdev_features_t);
	struct sk_buff * (*gro_receive)(struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sk_buff *, int);
};

struct net_protocol {
	int (*early_demux)(struct sk_buff *);
	int (*early_demux_handler)(struct sk_buff *);
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, u32);
	unsigned int no_policy: 1;
	unsigned int netns_ok: 1;
	unsigned int icmp_strict_tag_validation: 1;
};

struct inet6_protocol {
	void (*early_demux)(struct sk_buff *);
	void (*early_demux_handler)(struct sk_buff *);
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	unsigned int flags;
};

struct net_offload {
	struct offload_callbacks callbacks;
	unsigned int flags;
};

struct wl1251_platform_data {
	int power_gpio;
	int irq;
	bool use_eeprom;
};

enum wwan_port_type {
	WWAN_PORT_AT = 0,
	WWAN_PORT_MBIM = 1,
	WWAN_PORT_QMI = 2,
	WWAN_PORT_QCDM = 3,
	WWAN_PORT_FIREHOSE = 4,
	WWAN_PORT_MAX = 5,
};

struct wwan_port;

struct wwan_port_ops {
	int (*start)(struct wwan_port *);
	void (*stop)(struct wwan_port *);
	int (*tx)(struct wwan_port *, struct sk_buff *);
};

struct wwan_port {
	enum wwan_port_type type;
	unsigned int start_count;
	long unsigned int flags;
	const struct wwan_port_ops *ops;
	struct mutex ops_lock;
	struct device dev;
	struct sk_buff_head rxq;
	wait_queue_head_t waitqueue;
};

struct wwan_device {
	unsigned int id;
	struct device dev;
	atomic_t port_id;
};

struct pp_alloc_cache {
	u32 count;
	struct page *cache[128];
};

struct page_pool_params {
	unsigned int flags;
	unsigned int order;
	unsigned int pool_size;
	int nid;
	struct device *dev;
	enum dma_data_direction dma_dir;
	unsigned int max_len;
	unsigned int offset;
};

struct page_pool {
	struct page_pool_params p;
	struct delayed_work release_dw;
	void (*disconnect)(void *);
	long unsigned int defer_start;
	long unsigned int defer_warn;
	u32 pages_state_hold_cnt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct pp_alloc_cache alloc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ptr_ring ring;
	atomic_t pages_state_release_cnt;
	refcount_t user_cnt;
	u64 destroy_cnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xen_netif_tx_request {
	grant_ref_t gref;
	uint16_t offset;
	uint16_t flags;
	uint16_t id;
	uint16_t size;
};

struct xen_netif_extra_info {
	uint8_t type;
	uint8_t flags;
	union {
		struct {
			uint16_t size;
			uint8_t type;
			uint8_t pad;
			uint16_t features;
		} gso;
		struct {
			uint8_t addr[6];
		} mcast;
		struct {
			uint8_t type;
			uint8_t algorithm;
			uint8_t value[4];
		} hash;
		struct {
			uint16_t headroom;
			uint16_t pad[2];
		} xdp;
		uint16_t pad[3];
	} u;
};

struct xen_netif_tx_response {
	uint16_t id;
	int16_t status;
};

struct xen_netif_rx_request {
	uint16_t id;
	uint16_t pad;
	grant_ref_t gref;
};

struct xen_netif_rx_response {
	uint16_t id;
	uint16_t offset;
	uint16_t flags;
	int16_t status;
};

union xen_netif_tx_sring_entry {
	struct xen_netif_tx_request req;
	struct xen_netif_tx_response rsp;
};

struct xen_netif_tx_sring {
	RING_IDX req_prod;
	RING_IDX req_event;
	RING_IDX rsp_prod;
	RING_IDX rsp_event;
	uint8_t __pad[48];
	union xen_netif_tx_sring_entry ring[1];
};

struct xen_netif_tx_front_ring {
	RING_IDX req_prod_pvt;
	RING_IDX rsp_cons;
	unsigned int nr_ents;
	struct xen_netif_tx_sring *sring;
};

union xen_netif_rx_sring_entry {
	struct xen_netif_rx_request req;
	struct xen_netif_rx_response rsp;
};

struct xen_netif_rx_sring {
	RING_IDX req_prod;
	RING_IDX req_event;
	RING_IDX rsp_prod;
	RING_IDX rsp_event;
	uint8_t __pad[48];
	union xen_netif_rx_sring_entry ring[1];
};

struct xen_netif_rx_front_ring {
	RING_IDX req_prod_pvt;
	RING_IDX rsp_cons;
	unsigned int nr_ents;
	struct xen_netif_rx_sring *sring;
};

enum netif_freeze_state {
	NETIF_FREEZE_STATE_UNFROZEN = 0,
	NETIF_FREEZE_STATE_FREEZING = 1,
	NETIF_FREEZE_STATE_FROZEN = 2,
};

struct netfront_cb {
	int pull_to;
};

struct netfront_stats {
	u64 packets;
	u64 bytes;
	struct u64_stats_sync syncp;
};

struct netfront_info;

struct netfront_queue {
	unsigned int id;
	char name[22];
	struct netfront_info *info;
	struct bpf_prog *xdp_prog;
	struct napi_struct napi;
	unsigned int tx_evtchn;
	unsigned int rx_evtchn;
	unsigned int tx_irq;
	unsigned int rx_irq;
	char tx_irq_name[25];
	char rx_irq_name[25];
	spinlock_t tx_lock;
	struct xen_netif_tx_front_ring tx;
	int tx_ring_ref;
	struct sk_buff *tx_skbs[256];
	short unsigned int tx_link[256];
	grant_ref_t gref_tx_head;
	grant_ref_t grant_tx_ref[256];
	struct page *grant_tx_page[256];
	unsigned int tx_skb_freelist;
	unsigned int tx_pend_queue;
	long: 64;
	spinlock_t rx_lock;
	struct xen_netif_rx_front_ring rx;
	int rx_ring_ref;
	struct timer_list rx_refill_timer;
	struct sk_buff *rx_skbs[256];
	grant_ref_t gref_rx_head;
	grant_ref_t grant_rx_ref[256];
	unsigned int rx_rsp_unconsumed;
	spinlock_t rx_cons_lock;
	struct page_pool *page_pool;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
};

struct netfront_info {
	struct list_head list;
	struct net_device *netdev;
	struct xenbus_device *xbdev;
	struct netfront_queue *queues;
	struct netfront_stats *rx_stats;
	struct netfront_stats *tx_stats;
	bool netback_has_xdp_headroom;
	bool netfront_xdp_enabled;
	bool broken;
	atomic_t rx_gso_checksum_fixup;
	int freeze_state;
	struct completion wait_backend_disconnected;
};

struct netfront_rx_info {
	struct xen_netif_rx_response rx;
	struct xen_netif_extra_info extras[5];
};

struct xennet_gnttab_make_txreq {
	struct netfront_queue *queue;
	struct sk_buff *skb;
	struct page *page;
	struct xen_netif_tx_request *tx;
	struct xen_netif_tx_request tx_local;
	unsigned int size;
};

struct xennet_stat {
	char name[32];
	u16 offset;
};

struct cdrom_msf {
	__u8 cdmsf_min0;
	__u8 cdmsf_sec0;
	__u8 cdmsf_frame0;
	__u8 cdmsf_min1;
	__u8 cdmsf_sec1;
	__u8 cdmsf_frame1;
};

struct cdrom_volctrl {
	__u8 channel0;
	__u8 channel1;
	__u8 channel2;
	__u8 channel3;
};

struct cdrom_subchnl {
	__u8 cdsc_format;
	__u8 cdsc_audiostatus;
	__u8 cdsc_adr: 4;
	__u8 cdsc_ctrl: 4;
	__u8 cdsc_trk;
	__u8 cdsc_ind;
	union cdrom_addr cdsc_absaddr;
	union cdrom_addr cdsc_reladdr;
};

struct cdrom_read_audio {
	union cdrom_addr addr;
	__u8 addr_format;
	int nframes;
	__u8 *buf;
};

struct cdrom_blk {
	unsigned int from;
	short unsigned int len;
};

struct dvd_layer {
	__u8 book_version: 4;
	__u8 book_type: 4;
	__u8 min_rate: 4;
	__u8 disc_size: 4;
	__u8 layer_type: 4;
	__u8 track_path: 1;
	__u8 nlayers: 2;
	char: 1;
	__u8 track_density: 4;
	__u8 linear_density: 4;
	__u8 bca: 1;
	__u32 start_sector;
	__u32 end_sector;
	__u32 end_sector_l0;
};

struct dvd_physical {
	__u8 type;
	__u8 layer_num;
	struct dvd_layer layer[4];
};

struct dvd_copyright {
	__u8 type;
	__u8 layer_num;
	__u8 cpst;
	__u8 rmi;
};

struct dvd_disckey {
	__u8 type;
	unsigned int agid: 2;
	__u8 value[2048];
};

struct dvd_bca {
	__u8 type;
	int len;
	__u8 value[188];
};

struct dvd_manufact {
	__u8 type;
	__u8 layer_num;
	int len;
	__u8 value[2048];
};

typedef union {
	__u8 type;
	struct dvd_physical physical;
	struct dvd_copyright copyright;
	struct dvd_disckey disckey;
	struct dvd_bca bca;
	struct dvd_manufact manufact;
} dvd_struct;

typedef __u8 dvd_key[5];

typedef __u8 dvd_challenge[10];

struct dvd_lu_send_agid {
	__u8 type;
	unsigned int agid: 2;
};

struct dvd_host_send_challenge {
	__u8 type;
	unsigned int agid: 2;
	dvd_challenge chal;
};

struct dvd_send_key {
	__u8 type;
	unsigned int agid: 2;
	dvd_key key;
};

struct dvd_lu_send_challenge {
	__u8 type;
	unsigned int agid: 2;
	dvd_challenge chal;
};

struct dvd_lu_send_title_key {
	__u8 type;
	unsigned int agid: 2;
	dvd_key title_key;
	int lba;
	unsigned int cpm: 1;
	unsigned int cp_sec: 1;
	unsigned int cgms: 2;
};

struct dvd_lu_send_asf {
	__u8 type;
	unsigned int agid: 2;
	unsigned int asf: 1;
};

struct dvd_host_send_rpcstate {
	__u8 type;
	__u8 pdrc;
};

struct dvd_lu_send_rpcstate {
	__u8 type: 2;
	__u8 vra: 3;
	__u8 ucca: 3;
	__u8 region_mask;
	__u8 rpc_scheme;
};

typedef union {
	__u8 type;
	struct dvd_lu_send_agid lsa;
	struct dvd_host_send_challenge hsc;
	struct dvd_send_key lsk;
	struct dvd_lu_send_challenge lsc;
	struct dvd_send_key hsk;
	struct dvd_lu_send_title_key lstk;
	struct dvd_lu_send_asf lsasf;
	struct dvd_host_send_rpcstate hrpcs;
	struct dvd_lu_send_rpcstate lrpcs;
} dvd_authinfo;

struct mrw_feature_desc {
	__be16 feature_code;
	__u8 curr: 1;
	__u8 persistent: 1;
	__u8 feature_version: 4;
	__u8 reserved1: 2;
	__u8 add_len;
	__u8 write: 1;
	__u8 reserved2: 7;
	__u8 reserved3;
	__u8 reserved4;
	__u8 reserved5;
};

struct rwrt_feature_desc {
	__be16 feature_code;
	__u8 curr: 1;
	__u8 persistent: 1;
	__u8 feature_version: 4;
	__u8 reserved1: 2;
	__u8 add_len;
	__u32 last_lba;
	__u32 block_size;
	__u16 blocking;
	__u8 page_present: 1;
	__u8 reserved2: 7;
	__u8 reserved3;
};

typedef struct {
	__be16 disc_information_length;
	__u8 disc_status: 2;
	__u8 border_status: 2;
	__u8 erasable: 1;
	__u8 reserved1: 3;
	__u8 n_first_track;
	__u8 n_sessions_lsb;
	__u8 first_track_lsb;
	__u8 last_track_lsb;
	__u8 mrw_status: 2;
	__u8 dbit: 1;
	__u8 reserved2: 2;
	__u8 uru: 1;
	__u8 dbc_v: 1;
	__u8 did_v: 1;
	__u8 disc_type;
	__u8 n_sessions_msb;
	__u8 first_track_msb;
	__u8 last_track_msb;
	__u32 disc_id;
	__u32 lead_in;
	__u32 lead_out;
	__u8 disc_bar_code[8];
	__u8 reserved3;
	__u8 n_opc;
} disc_information;

typedef struct {
	__be16 track_information_length;
	__u8 track_lsb;
	__u8 session_lsb;
	__u8 reserved1;
	__u8 track_mode: 4;
	__u8 copy: 1;
	__u8 damage: 1;
	__u8 reserved2: 2;
	__u8 data_mode: 4;
	__u8 fp: 1;
	__u8 packet: 1;
	__u8 blank: 1;
	__u8 rt: 1;
	__u8 nwa_v: 1;
	__u8 lra_v: 1;
	__u8 reserved3: 6;
	__be32 track_start;
	__be32 next_writable;
	__be32 free_blocks;
	__be32 fixed_packet_size;
	__be32 track_size;
	__be32 last_rec_address;
} track_information;

struct mode_page_header {
	__be16 mode_data_length;
	__u8 medium_type;
	__u8 reserved1;
	__u8 reserved2;
	__u8 reserved3;
	__be16 desc_length;
};

typedef struct {
	int data;
	int audio;
	int cdi;
	int xa;
	long int error;
} tracktype;

struct cdrom_mechstat_header {
	__u8 curslot: 5;
	__u8 changer_state: 2;
	__u8 fault: 1;
	__u8 reserved1: 4;
	__u8 door_open: 1;
	__u8 mech_state: 3;
	__u8 curlba[3];
	__u8 nslots;
	__u16 slot_tablelen;
};

struct cdrom_slot {
	__u8 change: 1;
	__u8 reserved1: 6;
	__u8 disc_present: 1;
	__u8 reserved2[3];
};

struct cdrom_changer_info {
	struct cdrom_mechstat_header hdr;
	struct cdrom_slot slots[256];
};

struct modesel_head {
	__u8 reserved1;
	__u8 medium;
	__u8 reserved2;
	__u8 block_desc_length;
	__u8 density;
	__u8 number_of_blocks_hi;
	__u8 number_of_blocks_med;
	__u8 number_of_blocks_lo;
	__u8 reserved3;
	__u8 block_length_hi;
	__u8 block_length_med;
	__u8 block_length_lo;
};

typedef struct {
	__u16 report_key_length;
	__u8 reserved1;
	__u8 reserved2;
	__u8 ucca: 3;
	__u8 vra: 3;
	__u8 type_code: 2;
	__u8 region_mask;
	__u8 rpc_scheme;
	__u8 reserved3;
} rpc_state_t;

struct cdrom_sysctl_settings {
	char info[1000];
	int autoclose;
	int autoeject;
	int debug;
	int lock;
	int check;
};

enum cdrom_print_option {
	CTL_NAME = 0,
	CTL_SPEED = 1,
	CTL_SLOTS = 2,
	CTL_CAPABILITY = 3,
};

struct compat_cdrom_read_audio {
	union cdrom_addr addr;
	u8 addr_format;
	compat_int_t nframes;
	compat_caddr_t buf;
};

enum usb_otg_state {
	OTG_STATE_UNDEFINED = 0,
	OTG_STATE_B_IDLE = 1,
	OTG_STATE_B_SRP_INIT = 2,
	OTG_STATE_B_PERIPHERAL = 3,
	OTG_STATE_B_WAIT_ACON = 4,
	OTG_STATE_B_HOST = 5,
	OTG_STATE_A_IDLE = 6,
	OTG_STATE_A_WAIT_VRISE = 7,
	OTG_STATE_A_WAIT_BCON = 8,
	OTG_STATE_A_HOST = 9,
	OTG_STATE_A_SUSPEND = 10,
	OTG_STATE_A_PERIPHERAL = 11,
	OTG_STATE_A_WAIT_VFALL = 12,
	OTG_STATE_A_VBUS_ERR = 13,
};

struct usb_otg_caps {
	u16 otg_rev;
	bool hnp_support;
	bool srp_support;
	bool adp_support;
};

enum usb_dr_mode {
	USB_DR_MODE_UNKNOWN = 0,
	USB_DR_MODE_HOST = 1,
	USB_DR_MODE_PERIPHERAL = 2,
	USB_DR_MODE_OTG = 3,
};

enum usb_led_event {
	USB_LED_EVENT_HOST = 0,
	USB_LED_EVENT_GADGET = 1,
};

struct usb_device_id {
	__u16 match_flags;
	__u16 idVendor;
	__u16 idProduct;
	__u16 bcdDevice_lo;
	__u16 bcdDevice_hi;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 bInterfaceNumber;
	kernel_ulong_t driver_info;
};

struct usb_descriptor_header {
	__u8 bLength;
	__u8 bDescriptorType;
};

enum usb_port_connect_type {
	USB_PORT_CONNECT_TYPE_UNKNOWN = 0,
	USB_PORT_CONNECT_TYPE_HOT_PLUG = 1,
	USB_PORT_CONNECT_TYPE_HARD_WIRED = 2,
	USB_PORT_NOT_USED = 3,
};

struct usb_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct usbdrv_wrap {
	struct device_driver driver;
	int for_devices;
};

struct usb_driver {
	const char *name;
	int (*probe)(struct usb_interface *, const struct usb_device_id *);
	void (*disconnect)(struct usb_interface *);
	int (*unlocked_ioctl)(struct usb_interface *, unsigned int, void *);
	int (*suspend)(struct usb_interface *, pm_message_t);
	int (*resume)(struct usb_interface *);
	int (*reset_resume)(struct usb_interface *);
	int (*pre_reset)(struct usb_interface *);
	int (*post_reset)(struct usb_interface *);
	const struct usb_device_id *id_table;
	const struct attribute_group **dev_groups;
	struct usb_dynids dynids;
	struct usbdrv_wrap drvwrap;
	unsigned int no_dynamic_id: 1;
	unsigned int supports_autosuspend: 1;
	unsigned int disable_hub_initiated_lpm: 1;
	unsigned int soft_unbind: 1;
};

struct usb_device_driver {
	const char *name;
	bool (*match)(struct usb_device *);
	int (*probe)(struct usb_device *);
	void (*disconnect)(struct usb_device *);
	int (*suspend)(struct usb_device *, pm_message_t);
	int (*resume)(struct usb_device *, pm_message_t);
	const struct attribute_group **dev_groups;
	struct usbdrv_wrap drvwrap;
	const struct usb_device_id *id_table;
	unsigned int supports_autosuspend: 1;
	unsigned int generic_subclass: 1;
};

enum usb_phy_type {
	USB_PHY_TYPE_UNDEFINED = 0,
	USB_PHY_TYPE_USB2 = 1,
	USB_PHY_TYPE_USB3 = 2,
};

enum usb_phy_events {
	USB_EVENT_NONE = 0,
	USB_EVENT_VBUS = 1,
	USB_EVENT_ID = 2,
	USB_EVENT_CHARGER = 3,
	USB_EVENT_ENUMERATED = 4,
};

enum usb_charger_type {
	UNKNOWN_TYPE = 0,
	SDP_TYPE = 1,
	DCP_TYPE = 2,
	CDP_TYPE = 3,
	ACA_TYPE = 4,
};

enum usb_charger_state {
	USB_CHARGER_DEFAULT = 0,
	USB_CHARGER_PRESENT = 1,
	USB_CHARGER_ABSENT = 2,
};

struct usb_charger_current {
	unsigned int sdp_min;
	unsigned int sdp_max;
	unsigned int dcp_min;
	unsigned int dcp_max;
	unsigned int cdp_min;
	unsigned int cdp_max;
	unsigned int aca_min;
	unsigned int aca_max;
};

struct usb_otg;

struct usb_phy_io_ops;

struct usb_phy {
	struct device *dev;
	const char *label;
	unsigned int flags;
	enum usb_phy_type type;
	enum usb_phy_events last_event;
	struct usb_otg *otg;
	struct device *io_dev;
	struct usb_phy_io_ops *io_ops;
	void *io_priv;
	struct extcon_dev *edev;
	struct extcon_dev *id_edev;
	struct notifier_block vbus_nb;
	struct notifier_block id_nb;
	struct notifier_block type_nb;
	enum usb_charger_type chg_type;
	enum usb_charger_state chg_state;
	struct usb_charger_current chg_cur;
	struct work_struct chg_work;
	struct atomic_notifier_head notifier;
	u16 port_status;
	u16 port_change;
	struct list_head head;
	int (*init)(struct usb_phy *);
	void (*shutdown)(struct usb_phy *);
	int (*set_vbus)(struct usb_phy *, int);
	int (*set_power)(struct usb_phy *, unsigned int);
	int (*set_suspend)(struct usb_phy *, int);
	int (*set_wakeup)(struct usb_phy *, bool);
	int (*notify_connect)(struct usb_phy *, enum usb_device_speed);
	int (*notify_disconnect)(struct usb_phy *, enum usb_device_speed);
	enum usb_charger_type (*charger_detect)(struct usb_phy *);
};

struct usb_port_status {
	__le16 wPortStatus;
	__le16 wPortChange;
	__le32 dwExtPortStatus;
};

struct usb_hub_status {
	__le16 wHubStatus;
	__le16 wHubChange;
};

struct usb_hub_descriptor {
	__u8 bDescLength;
	__u8 bDescriptorType;
	__u8 bNbrPorts;
	__le16 wHubCharacteristics;
	__u8 bPwrOn2PwrGood;
	__u8 bHubContrCurrent;
	union {
		struct {
			__u8 DeviceRemovable[4];
			__u8 PortPwrCtrlMask[4];
		} hs;
		struct {
			__u8 bHubHdrDecLat;
			__le16 wHubDelay;
			__le16 DeviceRemovable;
		} __attribute__((packed)) ss;
	} u;
} __attribute__((packed));

struct usb_phy_io_ops {
	int (*read)(struct usb_phy *, u32);
	int (*write)(struct usb_phy *, u32, u32);
};

struct usb_gadget;

struct usb_otg {
	u8 default_a;
	struct phy *phy;
	struct usb_phy *usb_phy;
	struct usb_bus *host;
	struct usb_gadget *gadget;
	enum usb_otg_state state;
	int (*set_host)(struct usb_otg *, struct usb_bus *);
	int (*set_peripheral)(struct usb_otg *, struct usb_gadget *);
	int (*set_vbus)(struct usb_otg *, bool);
	int (*start_srp)(struct usb_otg *);
	int (*start_hnp)(struct usb_otg *);
};

typedef u32 usb_port_location_t;

struct usb_port;

struct usb_hub {
	struct device *intfdev;
	struct usb_device *hdev;
	struct kref kref;
	struct urb *urb;
	u8 (*buffer)[8];
	union {
		struct usb_hub_status hub;
		struct usb_port_status port;
	} *status;
	struct mutex status_mutex;
	int error;
	int nerrors;
	long unsigned int event_bits[1];
	long unsigned int change_bits[1];
	long unsigned int removed_bits[1];
	long unsigned int wakeup_bits[1];
	long unsigned int power_bits[1];
	long unsigned int child_usage_bits[1];
	long unsigned int warm_reset_bits[1];
	struct usb_hub_descriptor *descriptor;
	struct usb_tt tt;
	unsigned int mA_per_port;
	unsigned int wakeup_enabled_descendants;
	unsigned int limited_power: 1;
	unsigned int quiescing: 1;
	unsigned int disconnected: 1;
	unsigned int in_reset: 1;
	unsigned int quirk_disable_autosuspend: 1;
	unsigned int quirk_check_port_auto_suspend: 1;
	unsigned int has_indicators: 1;
	u8 indicator[31];
	struct delayed_work leds;
	struct delayed_work init_work;
	struct work_struct events;
	spinlock_t irq_urb_lock;
	struct timer_list irq_urb_retry;
	struct usb_port **ports;
};

struct usb_dev_state;

struct usb_port {
	struct usb_device *child;
	struct device dev;
	struct usb_dev_state *port_owner;
	struct usb_port *peer;
	struct dev_pm_qos_request *req;
	enum usb_port_connect_type connect_type;
	usb_port_location_t location;
	struct mutex status_lock;
	u32 over_current_count;
	u8 portnum;
	u32 quirks;
	unsigned int is_superspeed: 1;
	unsigned int usb3_lpm_u1_permit: 1;
	unsigned int usb3_lpm_u2_permit: 1;
};

struct find_interface_arg {
	int minor;
	struct device_driver *drv;
};

struct each_dev_arg {
	void *data;
	int (*fn)(struct usb_device *, void *);
};

struct each_hub_arg {
	void *data;
	int (*fn)(struct device *, void *);
};

struct usb_qualifier_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__u8 bNumConfigurations;
	__u8 bRESERVED;
};

struct usb_set_sel_req {
	__u8 u1_sel;
	__u8 u1_pel;
	__le16 u2_sel;
	__le16 u2_pel;
};

struct usbdevfs_hub_portinfo {
	char nports;
	char port[127];
};

enum hub_led_mode {
	INDICATOR_AUTO = 0,
	INDICATOR_CYCLE = 1,
	INDICATOR_GREEN_BLINK = 2,
	INDICATOR_GREEN_BLINK_OFF = 3,
	INDICATOR_AMBER_BLINK = 4,
	INDICATOR_AMBER_BLINK_OFF = 5,
	INDICATOR_ALT_BLINK = 6,
	INDICATOR_ALT_BLINK_OFF = 7,
};

struct usb_tt_clear {
	struct list_head clear_list;
	unsigned int tt;
	u16 devinfo;
	struct usb_hcd *hcd;
	struct usb_host_endpoint *ep;
};

enum hub_activation_type {
	HUB_INIT = 0,
	HUB_INIT2 = 1,
	HUB_INIT3 = 2,
	HUB_POST_RESET = 3,
	HUB_RESUME = 4,
	HUB_RESET_RESUME = 5,
};

enum hub_quiescing_type {
	HUB_DISCONNECT = 0,
	HUB_PRE_RESET = 1,
	HUB_SUSPEND = 2,
};

struct usb_ctrlrequest {
	__u8 bRequestType;
	__u8 bRequest;
	__le16 wValue;
	__le16 wIndex;
	__le16 wLength;
};

struct usb_sg_request {
	int status;
	size_t bytes;
	spinlock_t lock;
	struct usb_device *dev;
	int pipe;
	int entries;
	struct urb **urbs;
	int count;
	struct completion complete;
};

struct usb_cdc_header_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdCDC;
} __attribute__((packed));

struct usb_cdc_call_mgmt_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
	__u8 bDataInterface;
};

struct usb_cdc_acm_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
};

struct usb_cdc_union_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bMasterInterface0;
	__u8 bSlaveInterface0;
};

struct usb_cdc_country_functional_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iCountryCodeRelDate;
	__le16 wCountyCode0;
};

struct usb_cdc_network_terminal_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bEntityId;
	__u8 iName;
	__u8 bChannelIndex;
	__u8 bPhysicalInterface;
};

struct usb_cdc_ether_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iMACAddress;
	__le32 bmEthernetStatistics;
	__le16 wMaxSegmentSize;
	__le16 wNumberMCFilters;
	__u8 bNumberPowerFilters;
} __attribute__((packed));

struct usb_cdc_dmm_desc {
	__u8 bFunctionLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u16 bcdVersion;
	__le16 wMaxCommand;
} __attribute__((packed));

struct usb_cdc_mdlm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
	__u8 bGUID[16];
} __attribute__((packed));

struct usb_cdc_mdlm_detail_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bGuidDescriptorType;
	__u8 bDetailData[0];
};

struct usb_cdc_obex_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
} __attribute__((packed));

struct usb_cdc_ncm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdNcmVersion;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMVersion;
	__le16 wMaxControlMessage;
	__u8 bNumberFilters;
	__u8 bMaxFilterSize;
	__le16 wMaxSegmentSize;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_extended_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMExtendedVersion;
	__u8 bMaxOutstandingCommandMessages;
	__le16 wMTU;
} __attribute__((packed));

struct usb_cdc_parsed_header {
	struct usb_cdc_union_desc *usb_cdc_union_desc;
	struct usb_cdc_header_desc *usb_cdc_header_desc;
	struct usb_cdc_call_mgmt_descriptor *usb_cdc_call_mgmt_descriptor;
	struct usb_cdc_acm_descriptor *usb_cdc_acm_descriptor;
	struct usb_cdc_country_functional_desc *usb_cdc_country_functional_desc;
	struct usb_cdc_network_terminal_desc *usb_cdc_network_terminal_desc;
	struct usb_cdc_ether_desc *usb_cdc_ether_desc;
	struct usb_cdc_dmm_desc *usb_cdc_dmm_desc;
	struct usb_cdc_mdlm_desc *usb_cdc_mdlm_desc;
	struct usb_cdc_mdlm_detail_desc *usb_cdc_mdlm_detail_desc;
	struct usb_cdc_obex_desc *usb_cdc_obex_desc;
	struct usb_cdc_ncm_desc *usb_cdc_ncm_desc;
	struct usb_cdc_mbim_desc *usb_cdc_mbim_desc;
	struct usb_cdc_mbim_extended_desc *usb_cdc_mbim_extended_desc;
	bool phonet_magic_present;
};

struct api_context {
	struct completion done;
	int status;
};

struct set_config_request {
	struct usb_device *udev;
	int config;
	struct work_struct work;
	struct list_head node;
};

struct usb_dynid {
	struct list_head node;
	struct usb_device_id id;
};

struct usb_dev_cap_header {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

struct usb_class_driver {
	char *name;
	char * (*devnode)(struct device *, umode_t *);
	const struct file_operations *fops;
	int minor_base;
};

struct usb_class {
	struct kref kref;
	struct class *class;
};

struct ep_device {
	struct usb_endpoint_descriptor *desc;
	struct usb_device *udev;
	struct device dev;
};

struct usbdevfs_ctrltransfer {
	__u8 bRequestType;
	__u8 bRequest;
	__u16 wValue;
	__u16 wIndex;
	__u16 wLength;
	__u32 timeout;
	void *data;
};

struct usbdevfs_bulktransfer {
	unsigned int ep;
	unsigned int len;
	unsigned int timeout;
	void *data;
};

struct usbdevfs_setinterface {
	unsigned int interface;
	unsigned int altsetting;
};

struct usbdevfs_disconnectsignal {
	unsigned int signr;
	void *context;
};

struct usbdevfs_getdriver {
	unsigned int interface;
	char driver[256];
};

struct usbdevfs_connectinfo {
	unsigned int devnum;
	unsigned char slow;
};

struct usbdevfs_conninfo_ex {
	__u32 size;
	__u32 busnum;
	__u32 devnum;
	__u32 speed;
	__u8 num_ports;
	__u8 ports[7];
};

struct usbdevfs_iso_packet_desc {
	unsigned int length;
	unsigned int actual_length;
	unsigned int status;
};

struct usbdevfs_urb {
	unsigned char type;
	unsigned char endpoint;
	int status;
	unsigned int flags;
	void *buffer;
	int buffer_length;
	int actual_length;
	int start_frame;
	union {
		int number_of_packets;
		unsigned int stream_id;
	};
	int error_count;
	unsigned int signr;
	void *usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbdevfs_ioctl {
	int ifno;
	int ioctl_code;
	void *data;
};

struct usbdevfs_disconnect_claim {
	unsigned int interface;
	unsigned int flags;
	char driver[256];
};

struct usbdevfs_streams {
	unsigned int num_streams;
	unsigned int num_eps;
	unsigned char eps[0];
};

struct usbdevfs_ctrltransfer32 {
	u8 bRequestType;
	u8 bRequest;
	u16 wValue;
	u16 wIndex;
	u16 wLength;
	u32 timeout;
	compat_caddr_t data;
};

struct usbdevfs_bulktransfer32 {
	compat_uint_t ep;
	compat_uint_t len;
	compat_uint_t timeout;
	compat_caddr_t data;
};

struct usbdevfs_disconnectsignal32 {
	compat_int_t signr;
	compat_caddr_t context;
};

struct usbdevfs_urb32 {
	unsigned char type;
	unsigned char endpoint;
	compat_int_t status;
	compat_uint_t flags;
	compat_caddr_t buffer;
	compat_int_t buffer_length;
	compat_int_t actual_length;
	compat_int_t start_frame;
	compat_int_t number_of_packets;
	compat_int_t error_count;
	compat_uint_t signr;
	compat_caddr_t usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbdevfs_ioctl32 {
	s32 ifno;
	s32 ioctl_code;
	compat_caddr_t data;
};

struct usb_dev_state___2 {
	struct list_head list;
	struct usb_device *dev;
	struct file *file;
	spinlock_t lock;
	struct list_head async_pending;
	struct list_head async_completed;
	struct list_head memory_list;
	wait_queue_head_t wait;
	wait_queue_head_t wait_for_resume;
	unsigned int discsignr;
	struct pid *disc_pid;
	const struct cred *cred;
	sigval_t disccontext;
	long unsigned int ifclaimed;
	u32 disabled_bulk_eps;
	long unsigned int interface_allowed_mask;
	int not_yet_resumed;
	bool suspend_allowed;
	bool privileges_dropped;
};

struct usb_memory {
	struct list_head memlist;
	int vma_use_count;
	int urb_use_count;
	u32 size;
	void *mem;
	dma_addr_t dma_handle;
	long unsigned int vm_start;
	struct usb_dev_state___2 *ps;
};

struct async {
	struct list_head asynclist;
	struct usb_dev_state___2 *ps;
	struct pid *pid;
	const struct cred *cred;
	unsigned int signr;
	unsigned int ifnum;
	void *userbuffer;
	void *userurb;
	sigval_t userurb_sigval;
	struct urb *urb;
	struct usb_memory *usbm;
	unsigned int mem_usage;
	int status;
	u8 bulk_addr;
	u8 bulk_status;
};

enum snoop_when {
	SUBMIT = 0,
	COMPLETE___2 = 1,
};

struct quirk_entry {
	u16 vid;
	u16 pid;
	u32 flags;
};

struct class_info {
	int class;
	char *class_name;
};

struct usb_phy_roothub___2 {
	struct phy *phy;
	struct list_head list;
};

typedef void (*companion_fn)(struct pci_dev *, struct usb_hcd *, struct pci_dev *, struct usb_hcd *);

struct phy_devm {
	struct usb_phy *phy;
	struct notifier_block *nb;
};

enum usb_phy_interface {
	USBPHY_INTERFACE_MODE_UNKNOWN = 0,
	USBPHY_INTERFACE_MODE_UTMI = 1,
	USBPHY_INTERFACE_MODE_UTMIW = 2,
	USBPHY_INTERFACE_MODE_ULPI = 3,
	USBPHY_INTERFACE_MODE_SERIAL = 4,
	USBPHY_INTERFACE_MODE_HSIC = 5,
};

struct mxs_phy_data {
	unsigned int flags;
};

struct mxs_phy {
	struct usb_phy phy;
	struct clk *clk;
	const struct mxs_phy_data *data;
	struct regmap *regmap_anatop;
	int port_id;
	u32 tx_reg_set;
	u32 tx_reg_mask;
};

struct ulpi_info {
	unsigned int id;
	char *name;
};

struct usb_ep;

struct usb_request {
	void *buf;
	unsigned int length;
	dma_addr_t dma;
	struct scatterlist *sg;
	unsigned int num_sgs;
	unsigned int num_mapped_sgs;
	unsigned int stream_id: 16;
	unsigned int is_last: 1;
	unsigned int no_interrupt: 1;
	unsigned int zero: 1;
	unsigned int short_not_ok: 1;
	unsigned int dma_mapped: 1;
	void (*complete)(struct usb_ep *, struct usb_request *);
	void *context;
	struct list_head list;
	unsigned int frame_number;
	int status;
	unsigned int actual;
};

struct usb_ep_caps {
	unsigned int type_control: 1;
	unsigned int type_iso: 1;
	unsigned int type_bulk: 1;
	unsigned int type_int: 1;
	unsigned int dir_in: 1;
	unsigned int dir_out: 1;
};

struct usb_ep_ops;

struct usb_ep {
	void *driver_data;
	const char *name;
	const struct usb_ep_ops *ops;
	struct list_head ep_list;
	struct usb_ep_caps caps;
	bool claimed;
	bool enabled;
	unsigned int maxpacket: 16;
	unsigned int maxpacket_limit: 16;
	unsigned int max_streams: 16;
	unsigned int mult: 2;
	unsigned int maxburst: 5;
	u8 address;
	const struct usb_endpoint_descriptor *desc;
	const struct usb_ss_ep_comp_descriptor *comp_desc;
};

struct usb_ep_ops {
	int (*enable)(struct usb_ep *, const struct usb_endpoint_descriptor *);
	int (*disable)(struct usb_ep *);
	void (*dispose)(struct usb_ep *);
	struct usb_request * (*alloc_request)(struct usb_ep *, gfp_t);
	void (*free_request)(struct usb_ep *, struct usb_request *);
	int (*queue)(struct usb_ep *, struct usb_request *, gfp_t);
	int (*dequeue)(struct usb_ep *, struct usb_request *);
	int (*set_halt)(struct usb_ep *, int);
	int (*set_wedge)(struct usb_ep *);
	int (*fifo_status)(struct usb_ep *);
	void (*fifo_flush)(struct usb_ep *);
};

struct usb_dcd_config_params {
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
	__u8 besl_baseline;
	__u8 besl_deep;
};

struct usb_gadget_driver;

struct usb_gadget_ops {
	int (*get_frame)(struct usb_gadget *);
	int (*wakeup)(struct usb_gadget *);
	int (*set_selfpowered)(struct usb_gadget *, int);
	int (*vbus_session)(struct usb_gadget *, int);
	int (*vbus_draw)(struct usb_gadget *, unsigned int);
	int (*pullup)(struct usb_gadget *, int);
	int (*ioctl)(struct usb_gadget *, unsigned int, long unsigned int);
	void (*get_config_params)(struct usb_gadget *, struct usb_dcd_config_params *);
	int (*udc_start)(struct usb_gadget *, struct usb_gadget_driver *);
	int (*udc_stop)(struct usb_gadget *);
	void (*udc_set_speed)(struct usb_gadget *, enum usb_device_speed);
	void (*udc_set_ssp_rate)(struct usb_gadget *, enum usb_ssp_rate);
	struct usb_ep * (*match_ep)(struct usb_gadget *, struct usb_endpoint_descriptor *, struct usb_ss_ep_comp_descriptor *);
};

struct usb_udc;

struct usb_gadget {
	struct work_struct work;
	struct usb_udc *udc;
	const struct usb_gadget_ops *ops;
	struct usb_ep *ep0;
	struct list_head ep_list;
	enum usb_device_speed speed;
	enum usb_device_speed max_speed;
	enum usb_ssp_rate ssp_rate;
	enum usb_ssp_rate max_ssp_rate;
	enum usb_device_state state;
	const char *name;
	struct device dev;
	unsigned int isoch_delay;
	unsigned int out_epnum;
	unsigned int in_epnum;
	unsigned int mA;
	struct usb_otg_caps *otg_caps;
	unsigned int sg_supported: 1;
	unsigned int is_otg: 1;
	unsigned int is_a_peripheral: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int a_hnp_support: 1;
	unsigned int a_alt_hnp_support: 1;
	unsigned int hnp_polling_support: 1;
	unsigned int host_request_flag: 1;
	unsigned int quirk_ep_out_aligned_size: 1;
	unsigned int quirk_altset_not_supp: 1;
	unsigned int quirk_stall_not_supp: 1;
	unsigned int quirk_zlp_not_supp: 1;
	unsigned int quirk_avoids_skb_reserve: 1;
	unsigned int is_selfpowered: 1;
	unsigned int deactivated: 1;
	unsigned int connected: 1;
	unsigned int lpm_capable: 1;
	int irq;
};

struct usb_gadget_driver {
	char *function;
	enum usb_device_speed max_speed;
	int (*bind)(struct usb_gadget *, struct usb_gadget_driver *);
	void (*unbind)(struct usb_gadget *);
	int (*setup)(struct usb_gadget *, const struct usb_ctrlrequest *);
	void (*disconnect)(struct usb_gadget *);
	void (*suspend)(struct usb_gadget *);
	void (*resume)(struct usb_gadget *);
	void (*reset)(struct usb_gadget *);
	struct device_driver driver;
	char *udc_name;
	struct list_head pending;
	unsigned int match_existing_only: 1;
};

struct dwc2_dma_desc {
	u32 status;
	u32 buf;
};

struct dwc2_hw_params {
	unsigned int op_mode: 3;
	unsigned int arch: 2;
	unsigned int dma_desc_enable: 1;
	unsigned int enable_dynamic_fifo: 1;
	unsigned int en_multiple_tx_fifo: 1;
	unsigned int rx_fifo_size: 16;
	char: 8;
	unsigned int host_nperio_tx_fifo_size: 16;
	unsigned int dev_nperio_tx_fifo_size: 16;
	unsigned int host_perio_tx_fifo_size: 16;
	unsigned int nperio_tx_q_depth: 3;
	unsigned int host_perio_tx_q_depth: 3;
	unsigned int dev_token_q_depth: 5;
	char: 5;
	unsigned int max_transfer_size: 26;
	char: 6;
	unsigned int max_packet_count: 11;
	unsigned int host_channels: 5;
	unsigned int hs_phy_type: 2;
	unsigned int fs_phy_type: 2;
	unsigned int i2c_enable: 1;
	unsigned int acg_enable: 1;
	unsigned int num_dev_ep: 4;
	unsigned int num_dev_in_eps: 4;
	char: 2;
	unsigned int num_dev_perio_in_ep: 4;
	unsigned int total_fifo_size: 16;
	unsigned int power_optimized: 1;
	unsigned int hibernation: 1;
	unsigned int utmi_phy_data_width: 2;
	unsigned int lpm_mode: 1;
	unsigned int ipg_isoc_en: 1;
	unsigned int service_interval_mode: 1;
	u32 snpsid;
	u32 dev_ep_dirs;
	u32 g_tx_fifo_size[16];
};

struct dwc2_core_params {
	u8 otg_cap;
	u8 phy_type;
	u8 speed;
	u8 phy_utmi_width;
	bool phy_ulpi_ddr;
	bool phy_ulpi_ext_vbus;
	bool enable_dynamic_fifo;
	bool en_multiple_tx_fifo;
	bool i2c_enable;
	bool acg_enable;
	bool ulpi_fs_ls;
	bool ts_dline;
	bool reload_ctl;
	bool uframe_sched;
	bool external_id_pin_ctl;
	int power_down;
	bool no_clock_gating;
	bool lpm;
	bool lpm_clock_gating;
	bool besl;
	bool hird_threshold_en;
	bool service_interval;
	u8 hird_threshold;
	bool activate_stm_fs_transceiver;
	bool activate_stm_id_vb_detection;
	bool ipg_isoc_en;
	u16 max_packet_count;
	u32 max_transfer_size;
	u32 ahbcfg;
	u32 ref_clk_per;
	u16 sof_cnt_wkup_alert;
	bool host_dma;
	bool dma_desc_enable;
	bool dma_desc_fs_enable;
	bool host_support_fs_ls_low_power;
	bool host_ls_low_power_phy_clk;
	bool oc_disable;
	u8 host_channels;
	u16 host_rx_fifo_size;
	u16 host_nperio_tx_fifo_size;
	u16 host_perio_tx_fifo_size;
	bool g_dma;
	bool g_dma_desc;
	u32 g_rx_fifo_size;
	u32 g_np_tx_fifo_size;
	u32 g_tx_fifo_size[16];
	bool change_speed_quirk;
};

enum dwc2_lx_state {
	DWC2_L0 = 0,
	DWC2_L1 = 1,
	DWC2_L2 = 2,
	DWC2_L3 = 3,
};

struct dwc2_gregs_backup {
	u32 gotgctl;
	u32 gintmsk;
	u32 gahbcfg;
	u32 gusbcfg;
	u32 grxfsiz;
	u32 gnptxfsiz;
	u32 gi2cctl;
	u32 glpmcfg;
	u32 pcgcctl;
	u32 pcgcctl1;
	u32 gdfifocfg;
	u32 gpwrdn;
	bool valid;
};

struct dwc2_dregs_backup {
	u32 dcfg;
	u32 dctl;
	u32 daintmsk;
	u32 diepmsk;
	u32 doepmsk;
	u32 diepctl[16];
	u32 dieptsiz[16];
	u32 diepdma[16];
	u32 doepctl[16];
	u32 doeptsiz[16];
	u32 doepdma[16];
	u32 dtxfsiz[16];
	bool valid;
};

struct dwc2_hregs_backup {
	u32 hcfg;
	u32 haintmsk;
	u32 hcintmsk[16];
	u32 hprt0;
	u32 hfir;
	u32 hptxfsiz;
	bool valid;
};

union dwc2_hcd_internal_flags {
	u32 d32;
	struct {
		unsigned int port_connect_status_change: 1;
		unsigned int port_connect_status: 1;
		unsigned int port_reset_change: 1;
		unsigned int port_enable_change: 1;
		unsigned int port_suspend_change: 1;
		unsigned int port_over_current_change: 1;
		unsigned int port_l1_change: 1;
		unsigned int reserved: 25;
	} b;
};

struct usb_role_switch;

struct dwc2_hsotg_plat;

struct dwc2_host_chan;

struct dwc2_hsotg {
	struct device *dev;
	void *regs;
	struct dwc2_hw_params hw_params;
	struct dwc2_core_params params;
	enum usb_otg_state op_state;
	enum usb_dr_mode dr_mode;
	struct usb_role_switch *role_sw;
	unsigned int hcd_enabled: 1;
	unsigned int gadget_enabled: 1;
	unsigned int ll_hw_enabled: 1;
	unsigned int hibernated: 1;
	unsigned int in_ppd: 1;
	bool bus_suspended;
	unsigned int reset_phy_on_wake: 1;
	unsigned int need_phy_for_wake: 1;
	unsigned int phy_off_for_suspend: 1;
	u16 frame_number;
	struct phy *phy;
	struct usb_phy *uphy;
	struct dwc2_hsotg_plat *plat;
	struct regulator_bulk_data supplies[2];
	struct regulator *vbus_supply;
	struct regulator *usb33d;
	spinlock_t lock;
	void *priv;
	int irq;
	struct clk *clk;
	struct reset_control *reset;
	struct reset_control *reset_ecc;
	unsigned int queuing_high_bandwidth: 1;
	unsigned int srp_success: 1;
	struct workqueue_struct *wq_otg;
	struct work_struct wf_otg;
	struct timer_list wkp_timer;
	enum dwc2_lx_state lx_state;
	struct dwc2_gregs_backup gr_backup;
	struct dwc2_dregs_backup dr_backup;
	struct dwc2_hregs_backup hr_backup;
	struct dentry *debug_root;
	struct debugfs_regset32 *regset;
	bool needs_byte_swap;
	union dwc2_hcd_internal_flags flags;
	struct list_head non_periodic_sched_inactive;
	struct list_head non_periodic_sched_waiting;
	struct list_head non_periodic_sched_active;
	struct list_head *non_periodic_qh_ptr;
	struct list_head periodic_sched_inactive;
	struct list_head periodic_sched_ready;
	struct list_head periodic_sched_assigned;
	struct list_head periodic_sched_queued;
	struct list_head split_order;
	u16 periodic_usecs;
	long unsigned int hs_periodic_bitmap[13];
	u16 periodic_qh_count;
	bool new_connection;
	u16 last_frame_num;
	struct list_head free_hc_list;
	int periodic_channels;
	int non_periodic_channels;
	int available_host_channels;
	struct dwc2_host_chan *hc_ptr_array[16];
	u8 *status_buf;
	dma_addr_t status_buf_dma;
	struct delayed_work start_work;
	struct delayed_work reset_work;
	struct work_struct phy_reset_work;
	u8 otg_port;
	u32 *frame_list;
	dma_addr_t frame_list_dma;
	u32 frame_list_sz;
	struct kmem_cache *desc_gen_cache;
	struct kmem_cache *desc_hsisoc_cache;
	struct kmem_cache *unaligned_cache;
};

enum dwc2_halt_status {
	DWC2_HC_XFER_NO_HALT_STATUS = 0,
	DWC2_HC_XFER_COMPLETE = 1,
	DWC2_HC_XFER_URB_COMPLETE = 2,
	DWC2_HC_XFER_ACK = 3,
	DWC2_HC_XFER_NAK = 4,
	DWC2_HC_XFER_NYET = 5,
	DWC2_HC_XFER_STALL = 6,
	DWC2_HC_XFER_XACT_ERR = 7,
	DWC2_HC_XFER_FRAME_OVERRUN = 8,
	DWC2_HC_XFER_BABBLE_ERR = 9,
	DWC2_HC_XFER_DATA_TOGGLE_ERR = 10,
	DWC2_HC_XFER_AHB_ERR = 11,
	DWC2_HC_XFER_PERIODIC_INCOMPLETE = 12,
	DWC2_HC_XFER_URB_DEQUEUE = 13,
};

struct dwc2_qh;

struct dwc2_host_chan {
	u8 hc_num;
	unsigned int dev_addr: 7;
	unsigned int ep_num: 4;
	unsigned int ep_is_in: 1;
	unsigned int speed: 4;
	unsigned int ep_type: 2;
	char: 6;
	unsigned int max_packet: 11;
	unsigned int data_pid_start: 2;
	unsigned int multi_count: 2;
	u8 *xfer_buf;
	dma_addr_t xfer_dma;
	dma_addr_t align_buf;
	u32 xfer_len;
	u32 xfer_count;
	u16 start_pkt_count;
	u8 xfer_started;
	u8 do_ping;
	u8 error_state;
	u8 halt_on_queue;
	u8 halt_pending;
	u8 do_split;
	u8 complete_split;
	u8 hub_addr;
	u8 hub_port;
	u8 xact_pos;
	u8 requests;
	u8 schinfo;
	u16 ntd;
	enum dwc2_halt_status halt_status;
	u32 hcint;
	struct dwc2_qh *qh;
	struct list_head hc_list_entry;
	dma_addr_t desc_list_addr;
	u32 desc_list_sz;
	struct list_head split_order_list_entry;
};

struct dwc2_hs_transfer_time {
	u32 start_schedule_us;
	u16 duration_us;
};

struct dwc2_tt;

struct dwc2_qh {
	struct dwc2_hsotg *hsotg;
	u8 ep_type;
	u8 ep_is_in;
	u16 maxp;
	u16 maxp_mult;
	u8 dev_speed;
	u8 data_toggle;
	u8 ping_state;
	u8 do_split;
	u8 td_first;
	u8 td_last;
	u16 host_us;
	u16 device_us;
	u16 host_interval;
	u16 device_interval;
	u16 next_active_frame;
	u16 start_active_frame;
	s16 num_hs_transfers;
	struct dwc2_hs_transfer_time hs_transfers[8];
	u32 ls_start_schedule_slice;
	u16 ntd;
	u8 *dw_align_buf;
	dma_addr_t dw_align_buf_dma;
	struct list_head qtd_list;
	struct dwc2_host_chan *channel;
	struct list_head qh_list_entry;
	struct dwc2_dma_desc *desc_list;
	dma_addr_t desc_list_dma;
	u32 desc_list_sz;
	u32 *n_bytes;
	struct timer_list unreserve_timer;
	struct hrtimer wait_timer;
	struct dwc2_tt *dwc_tt;
	int ttport;
	unsigned int tt_buffer_dirty: 1;
	unsigned int unreserve_pending: 1;
	unsigned int schedule_low_speed: 1;
	unsigned int want_wait: 1;
	unsigned int wait_timer_cancel: 1;
};

struct dwc2_tt {
	int refcount;
	struct usb_tt *usb_tt;
	long unsigned int periodic_bitmaps[0];
};

enum dwc2_hsotg_dmamode {
	S3C_HSOTG_DMA_NONE = 0,
	S3C_HSOTG_DMA_ONLY = 1,
	S3C_HSOTG_DMA_DRV = 2,
};

struct dwc2_hsotg_plat {
	enum dwc2_hsotg_dmamode dma;
	unsigned int is_osc: 1;
	int phy_type;
	int (*phy_init)(struct platform_device *, int);
	int (*phy_exit)(struct platform_device *, int);
};

enum usb_role {
	USB_ROLE_NONE = 0,
	USB_ROLE_HOST = 1,
	USB_ROLE_DEVICE = 2,
};

typedef int (*usb_role_switch_set_t)(struct usb_role_switch *, enum usb_role);

typedef enum usb_role (*usb_role_switch_get_t)(struct usb_role_switch *);

struct usb_role_switch_desc {
	struct fwnode_handle *fwnode;
	struct device *usb2_port;
	struct device *usb3_port;
	struct device *udc;
	usb_role_switch_set_t set;
	usb_role_switch_get_t get;
	bool allow_userspace_control;
	void *driver_data;
	const char *name;
};

typedef void (*set_params_cb)(struct dwc2_hsotg *);

struct dwc2_hcd_pipe_info {
	u8 dev_addr;
	u8 ep_num;
	u8 pipe_type;
	u8 pipe_dir;
	u16 maxp;
	u16 maxp_mult;
};

struct dwc2_hcd_iso_packet_desc {
	u32 offset;
	u32 length;
	u32 actual_length;
	u32 status;
};

struct dwc2_qtd;

struct dwc2_hcd_urb {
	void *priv;
	struct dwc2_qtd *qtd;
	void *buf;
	dma_addr_t dma;
	void *setup_packet;
	dma_addr_t setup_dma;
	u32 length;
	u32 actual_length;
	u32 status;
	u32 error_count;
	u32 packet_count;
	u32 flags;
	u16 interval;
	struct dwc2_hcd_pipe_info pipe_info;
	struct dwc2_hcd_iso_packet_desc iso_descs[0];
};

enum dwc2_control_phase {
	DWC2_CONTROL_SETUP = 0,
	DWC2_CONTROL_DATA = 1,
	DWC2_CONTROL_STATUS = 2,
};

struct dwc2_qtd {
	enum dwc2_control_phase control_phase;
	u8 in_process;
	u8 data_toggle;
	u8 complete_split;
	u8 isoc_split_pos;
	u16 isoc_frame_index;
	u16 isoc_split_offset;
	u16 isoc_td_last;
	u16 isoc_td_first;
	u32 ssplit_out_xfer_count;
	u8 error_count;
	u8 n_desc;
	u16 isoc_frame_index_last;
	u16 num_naks;
	struct dwc2_hcd_urb *urb;
	struct dwc2_qh *qh;
	struct list_head qtd_list_entry;
};

enum dwc2_transaction_type {
	DWC2_TRANSACTION_NONE = 0,
	DWC2_TRANSACTION_PERIODIC = 1,
	DWC2_TRANSACTION_NON_PERIODIC = 2,
	DWC2_TRANSACTION_ALL = 3,
};

struct wrapper_priv_data {
	struct dwc2_hsotg *hsotg;
};

enum amd_chipset_gen {
	NOT_AMD_CHIPSET = 0,
	AMD_CHIPSET_SB600 = 1,
	AMD_CHIPSET_SB700 = 2,
	AMD_CHIPSET_SB800 = 3,
	AMD_CHIPSET_HUDSON2 = 4,
	AMD_CHIPSET_BOLTON = 5,
	AMD_CHIPSET_YANGTZE = 6,
	AMD_CHIPSET_TAISHAN = 7,
	AMD_CHIPSET_UNKNOWN = 8,
};

struct amd_chipset_type {
	enum amd_chipset_gen gen;
	u8 rev;
};

struct amd_chipset_info {
	struct pci_dev *nb_dev;
	struct pci_dev *smbus_dev;
	int nb_type;
	struct amd_chipset_type sb_type;
	int isoc_reqs;
	int probe_count;
	bool need_pll_quirk;
};

struct ehci_stats {
	long unsigned int normal;
	long unsigned int error;
	long unsigned int iaa;
	long unsigned int lost_iaa;
	long unsigned int complete;
	long unsigned int unlink;
};

struct ehci_per_sched {
	struct usb_device *udev;
	struct usb_host_endpoint *ep;
	struct list_head ps_list;
	u16 tt_usecs;
	u16 cs_mask;
	u16 period;
	u16 phase;
	u8 bw_phase;
	u8 phase_uf;
	u8 usecs;
	u8 c_usecs;
	u8 bw_uperiod;
	u8 bw_period;
};

enum ehci_rh_state {
	EHCI_RH_HALTED = 0,
	EHCI_RH_SUSPENDED = 1,
	EHCI_RH_RUNNING = 2,
	EHCI_RH_STOPPING = 3,
};

enum ehci_hrtimer_event {
	EHCI_HRTIMER_POLL_ASS = 0,
	EHCI_HRTIMER_POLL_PSS = 1,
	EHCI_HRTIMER_POLL_DEAD = 2,
	EHCI_HRTIMER_UNLINK_INTR = 3,
	EHCI_HRTIMER_FREE_ITDS = 4,
	EHCI_HRTIMER_ACTIVE_UNLINK = 5,
	EHCI_HRTIMER_START_UNLINK_INTR = 6,
	EHCI_HRTIMER_ASYNC_UNLINKS = 7,
	EHCI_HRTIMER_IAA_WATCHDOG = 8,
	EHCI_HRTIMER_DISABLE_PERIODIC = 9,
	EHCI_HRTIMER_DISABLE_ASYNC = 10,
	EHCI_HRTIMER_IO_WATCHDOG = 11,
	EHCI_HRTIMER_NUM_EVENTS = 12,
};

struct ehci_caps;

struct ehci_regs;

struct ehci_dbg_port;

struct ehci_qh;

union ehci_shadow;

struct ehci_itd;

struct ehci_sitd;

struct ehci_hcd {
	enum ehci_hrtimer_event next_hrtimer_event;
	unsigned int enabled_hrtimer_events;
	ktime_t hr_timeouts[12];
	struct hrtimer hrtimer;
	int PSS_poll_count;
	int ASS_poll_count;
	int died_poll_count;
	struct ehci_caps *caps;
	struct ehci_regs *regs;
	struct ehci_dbg_port *debug;
	__u32 hcs_params;
	spinlock_t lock;
	enum ehci_rh_state rh_state;
	bool scanning: 1;
	bool need_rescan: 1;
	bool intr_unlinking: 1;
	bool iaa_in_progress: 1;
	bool async_unlinking: 1;
	bool shutdown: 1;
	struct ehci_qh *qh_scan_next;
	struct ehci_qh *async;
	struct ehci_qh *dummy;
	struct list_head async_unlink;
	struct list_head async_idle;
	unsigned int async_unlink_cycle;
	unsigned int async_count;
	__le32 old_current;
	__le32 old_token;
	unsigned int periodic_size;
	__le32 *periodic;
	dma_addr_t periodic_dma;
	struct list_head intr_qh_list;
	unsigned int i_thresh;
	union ehci_shadow *pshadow;
	struct list_head intr_unlink_wait;
	struct list_head intr_unlink;
	unsigned int intr_unlink_wait_cycle;
	unsigned int intr_unlink_cycle;
	unsigned int now_frame;
	unsigned int last_iso_frame;
	unsigned int intr_count;
	unsigned int isoc_count;
	unsigned int periodic_count;
	unsigned int uframe_periodic_max;
	struct list_head cached_itd_list;
	struct ehci_itd *last_itd_to_free;
	struct list_head cached_sitd_list;
	struct ehci_sitd *last_sitd_to_free;
	long unsigned int reset_done[15];
	long unsigned int bus_suspended;
	long unsigned int companion_ports;
	long unsigned int owned_ports;
	long unsigned int port_c_suspend;
	long unsigned int suspended_ports;
	long unsigned int resuming_ports;
	struct dma_pool___2 *qh_pool;
	struct dma_pool___2 *qtd_pool;
	struct dma_pool___2 *itd_pool;
	struct dma_pool___2 *sitd_pool;
	unsigned int random_frame;
	long unsigned int next_statechange;
	ktime_t last_periodic_enable;
	u32 command;
	unsigned int no_selective_suspend: 1;
	unsigned int has_fsl_port_bug: 1;
	unsigned int has_fsl_hs_errata: 1;
	unsigned int has_fsl_susp_errata: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int big_endian_desc: 1;
	unsigned int big_endian_capbase: 1;
	unsigned int has_amcc_usb23: 1;
	unsigned int need_io_watchdog: 1;
	unsigned int amd_pll_fix: 1;
	unsigned int use_dummy_qh: 1;
	unsigned int has_synopsys_hc_bug: 1;
	unsigned int frame_index_bug: 1;
	unsigned int need_oc_pp_cycle: 1;
	unsigned int imx28_write_fix: 1;
	unsigned int spurious_oc: 1;
	unsigned int is_aspeed: 1;
	__le32 *ohci_hcctrl_reg;
	unsigned int has_hostpc: 1;
	unsigned int has_tdi_phy_lpm: 1;
	unsigned int has_ppcd: 1;
	u8 sbrn;
	struct ehci_stats stats;
	struct dentry *debug_dir;
	u8 bandwidth[64];
	u8 tt_budget[64];
	struct list_head tt_list;
	long unsigned int priv[0];
};

struct ehci_caps {
	u32 hc_capbase;
	u32 hcs_params;
	u32 hcc_params;
	u8 portroute[8];
};

struct ehci_regs {
	u32 command;
	u32 status;
	u32 intr_enable;
	u32 frame_index;
	u32 segment;
	u32 frame_list;
	u32 async_next;
	u32 reserved1[2];
	u32 txfill_tuning;
	u32 reserved2[6];
	u32 configured_flag;
	u32 port_status[0];
	u32 reserved3[9];
	u32 usbmode;
	u32 reserved4[6];
	u32 hostpc[0];
	u32 reserved5[17];
	u32 usbmode_ex;
};

struct ehci_dbg_port {
	u32 control;
	u32 pids;
	u32 data03;
	u32 data47;
	u32 address;
};

struct ehci_fstn;

union ehci_shadow {
	struct ehci_qh *qh;
	struct ehci_itd *itd;
	struct ehci_sitd *sitd;
	struct ehci_fstn *fstn;
	__le32 *hw_next;
	void *ptr;
};

struct ehci_qh_hw;

struct ehci_qtd;

struct ehci_qh {
	struct ehci_qh_hw *hw;
	dma_addr_t qh_dma;
	union ehci_shadow qh_next;
	struct list_head qtd_list;
	struct list_head intr_node;
	struct ehci_qtd *dummy;
	struct list_head unlink_node;
	struct ehci_per_sched ps;
	unsigned int unlink_cycle;
	u8 qh_state;
	u8 xacterrs;
	u8 unlink_reason;
	u8 gap_uf;
	unsigned int is_out: 1;
	unsigned int clearing_tt: 1;
	unsigned int dequeue_during_giveback: 1;
	unsigned int should_be_inactive: 1;
};

struct ehci_iso_stream;

struct ehci_itd {
	__le32 hw_next;
	__le32 hw_transaction[8];
	__le32 hw_bufp[7];
	__le32 hw_bufp_hi[7];
	dma_addr_t itd_dma;
	union ehci_shadow itd_next;
	struct urb *urb;
	struct ehci_iso_stream *stream;
	struct list_head itd_list;
	unsigned int frame;
	unsigned int pg;
	unsigned int index[8];
	long: 64;
};

struct ehci_sitd {
	__le32 hw_next;
	__le32 hw_fullspeed_ep;
	__le32 hw_uframe;
	__le32 hw_results;
	__le32 hw_buf[2];
	__le32 hw_backpointer;
	__le32 hw_buf_hi[2];
	dma_addr_t sitd_dma;
	union ehci_shadow sitd_next;
	struct urb *urb;
	struct ehci_iso_stream *stream;
	struct list_head sitd_list;
	unsigned int frame;
	unsigned int index;
};

struct ehci_qtd {
	__le32 hw_next;
	__le32 hw_alt_next;
	__le32 hw_token;
	__le32 hw_buf[5];
	__le32 hw_buf_hi[5];
	dma_addr_t qtd_dma;
	struct list_head qtd_list;
	struct urb *urb;
	size_t length;
};

struct ehci_fstn {
	__le32 hw_next;
	__le32 hw_prev;
	dma_addr_t fstn_dma;
	union ehci_shadow fstn_next;
	long: 64;
};

struct ehci_qh_hw {
	__le32 hw_next;
	__le32 hw_info1;
	__le32 hw_info2;
	__le32 hw_current;
	__le32 hw_qtd_next;
	__le32 hw_alt_next;
	__le32 hw_token;
	__le32 hw_buf[5];
	__le32 hw_buf_hi[5];
	long: 32;
	long: 64;
	long: 64;
	long: 64;
};

struct ehci_iso_packet {
	u64 bufp;
	__le32 transaction;
	u8 cross;
	u32 buf1;
};

struct ehci_iso_sched {
	struct list_head td_list;
	unsigned int span;
	unsigned int first_packet;
	struct ehci_iso_packet packet[0];
};

struct ehci_iso_stream {
	struct ehci_qh_hw *hw;
	u8 bEndpointAddress;
	u8 highspeed;
	struct list_head td_list;
	struct list_head free_list;
	struct ehci_per_sched ps;
	unsigned int next_uframe;
	__le32 splits;
	u16 uperiod;
	u16 maxp;
	unsigned int bandwidth;
	__le32 buf0;
	__le32 buf1;
	__le32 buf2;
	__le32 address;
};

struct ehci_tt {
	u16 bandwidth[8];
	struct list_head tt_list;
	struct list_head ps_list;
	struct usb_tt *usb_tt;
	int tt_port;
};

struct ehci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*port_power)(struct usb_hcd *, int, bool);
};

struct debug_buffer {
	ssize_t (*fill_func)(struct debug_buffer *);
	struct usb_bus *bus;
	struct mutex mutex;
	size_t count;
	char *output_buf;
	size_t alloc_size;
};

enum orion_ehci_phy_ver {
	EHCI_PHY_ORION = 0,
	EHCI_PHY_DD = 1,
	EHCI_PHY_KW = 2,
	EHCI_PHY_NA = 3,
};

struct orion_ehci_data {
	enum orion_ehci_phy_ver phy_version;
};

struct orion_ehci_hcd {
	struct clk *clk;
	struct phy *phy;
};

typedef __u32 __hc32;

typedef __u16 __hc16;

struct td;

struct ed {
	__hc32 hwINFO;
	__hc32 hwTailP;
	__hc32 hwHeadP;
	__hc32 hwNextED;
	dma_addr_t dma;
	struct td *dummy;
	struct ed *ed_next;
	struct ed *ed_prev;
	struct list_head td_list;
	struct list_head in_use_list;
	u8 state;
	u8 type;
	u8 branch;
	u16 interval;
	u16 load;
	u16 last_iso;
	u16 tick;
	unsigned int takeback_wdh_cnt;
	struct td *pending_td;
	long: 64;
};

struct td {
	__hc32 hwINFO;
	__hc32 hwCBP;
	__hc32 hwNextTD;
	__hc32 hwBE;
	__hc16 hwPSW[2];
	__u8 index;
	struct ed *ed;
	struct td *td_hash;
	struct td *next_dl_td;
	struct urb *urb;
	dma_addr_t td_dma;
	dma_addr_t data_dma;
	struct list_head td_list;
	long: 64;
};

struct ohci_hcca {
	__hc32 int_table[32];
	__hc32 frame_no;
	__hc32 done_head;
	u8 reserved_for_hc[116];
	u8 what[4];
};

struct ohci_roothub_regs {
	__hc32 a;
	__hc32 b;
	__hc32 status;
	__hc32 portstatus[15];
};

struct ohci_regs {
	__hc32 revision;
	__hc32 control;
	__hc32 cmdstatus;
	__hc32 intrstatus;
	__hc32 intrenable;
	__hc32 intrdisable;
	__hc32 hcca;
	__hc32 ed_periodcurrent;
	__hc32 ed_controlhead;
	__hc32 ed_controlcurrent;
	__hc32 ed_bulkhead;
	__hc32 ed_bulkcurrent;
	__hc32 donehead;
	__hc32 fminterval;
	__hc32 fmremaining;
	__hc32 fmnumber;
	__hc32 periodicstart;
	__hc32 lsthresh;
	struct ohci_roothub_regs roothub;
	long: 64;
	long: 64;
};

struct urb_priv {
	struct ed *ed;
	u16 length;
	u16 td_cnt;
	struct list_head pending;
	struct td *td[0];
};

typedef struct urb_priv urb_priv_t;

enum ohci_rh_state {
	OHCI_RH_HALTED = 0,
	OHCI_RH_SUSPENDED = 1,
	OHCI_RH_RUNNING = 2,
};

struct ohci_hcd {
	spinlock_t lock;
	struct ohci_regs *regs;
	struct ohci_hcca *hcca;
	dma_addr_t hcca_dma;
	struct ed *ed_rm_list;
	struct ed *ed_bulktail;
	struct ed *ed_controltail;
	struct ed *periodic[32];
	void (*start_hnp)(struct ohci_hcd *);
	struct dma_pool___2 *td_cache;
	struct dma_pool___2 *ed_cache;
	struct td *td_hash[64];
	struct td *dl_start;
	struct td *dl_end;
	struct list_head pending;
	struct list_head eds_in_use;
	enum ohci_rh_state rh_state;
	int num_ports;
	int load[32];
	u32 hc_control;
	long unsigned int next_statechange;
	u32 fminterval;
	unsigned int autostop: 1;
	unsigned int working: 1;
	unsigned int restart_work: 1;
	long unsigned int flags;
	unsigned int prev_frame_no;
	unsigned int wdh_cnt;
	unsigned int prev_wdh_cnt;
	u32 prev_donehead;
	struct timer_list io_watchdog;
	struct work_struct nec_work;
	struct dentry *debug_dir;
	long unsigned int priv[0];
};

struct ohci_driver_overrides {
	const char *product_desc;
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
};

struct debug_buffer___2 {
	ssize_t (*fill_func)(struct debug_buffer___2 *);
	struct ohci_hcd *ohci;
	struct mutex mutex;
	size_t count;
	char *page;
};

struct uhci_td;

struct uhci_qh {
	__le32 link;
	__le32 element;
	dma_addr_t dma_handle;
	struct list_head node;
	struct usb_host_endpoint *hep;
	struct usb_device *udev;
	struct list_head queue;
	struct uhci_td *dummy_td;
	struct uhci_td *post_td;
	struct usb_iso_packet_descriptor *iso_packet_desc;
	long unsigned int advance_jiffies;
	unsigned int unlink_frame;
	unsigned int period;
	short int phase;
	short int load;
	unsigned int iso_frame;
	int state;
	int type;
	int skel;
	unsigned int initial_toggle: 1;
	unsigned int needs_fixup: 1;
	unsigned int is_stopped: 1;
	unsigned int wait_expired: 1;
	unsigned int bandwidth_reserved: 1;
};

struct uhci_td {
	__le32 link;
	__le32 status;
	__le32 token;
	__le32 buffer;
	dma_addr_t dma_handle;
	struct list_head list;
	int frame;
	struct list_head fl_list;
};

enum uhci_rh_state {
	UHCI_RH_RESET = 0,
	UHCI_RH_SUSPENDED = 1,
	UHCI_RH_AUTO_STOPPED = 2,
	UHCI_RH_RESUMING = 3,
	UHCI_RH_SUSPENDING = 4,
	UHCI_RH_RUNNING = 5,
	UHCI_RH_RUNNING_NODEVS = 6,
};

struct uhci_hcd {
	long unsigned int io_addr;
	void *regs;
	struct dma_pool___2 *qh_pool;
	struct dma_pool___2 *td_pool;
	struct uhci_td *term_td;
	struct uhci_qh *skelqh[11];
	struct uhci_qh *next_qh;
	spinlock_t lock;
	dma_addr_t frame_dma_handle;
	__le32 *frame;
	void **frame_cpu;
	enum uhci_rh_state rh_state;
	long unsigned int auto_stop_time;
	unsigned int frame_number;
	unsigned int is_stopped;
	unsigned int last_iso_frame;
	unsigned int cur_iso_frame;
	unsigned int scan_in_progress: 1;
	unsigned int need_rescan: 1;
	unsigned int dead: 1;
	unsigned int RD_enable: 1;
	unsigned int is_initialized: 1;
	unsigned int fsbr_is_on: 1;
	unsigned int fsbr_is_wanted: 1;
	unsigned int fsbr_expiring: 1;
	struct timer_list fsbr_timer;
	unsigned int oc_low: 1;
	unsigned int wait_for_hp: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int big_endian_desc: 1;
	unsigned int is_aspeed: 1;
	long unsigned int port_c_suspend;
	long unsigned int resuming_ports;
	long unsigned int ports_timeout;
	struct list_head idle_qh_list;
	int rh_numports;
	wait_queue_head_t waitqh;
	int num_waiting;
	int total_load;
	short int load[32];
	struct clk *clk;
	void (*reset_hc)(struct uhci_hcd *);
	int (*check_and_reset_hc)(struct uhci_hcd *);
	void (*configure_hc)(struct uhci_hcd *);
	int (*resume_detect_interrupts_are_broken)(struct uhci_hcd *);
	int (*global_suspend_mode_is_broken)(struct uhci_hcd *);
};

struct urb_priv___2 {
	struct list_head node;
	struct urb *urb;
	struct uhci_qh *qh;
	struct list_head td_list;
	unsigned int fsbr: 1;
};

struct uhci_debug {
	int size;
	char *data;
};

struct xhci_cap_regs {
	__le32 hc_capbase;
	__le32 hcs_params1;
	__le32 hcs_params2;
	__le32 hcs_params3;
	__le32 hcc_params;
	__le32 db_off;
	__le32 run_regs_off;
	__le32 hcc_params2;
};

struct xhci_op_regs {
	__le32 command;
	__le32 status;
	__le32 page_size;
	__le32 reserved1;
	__le32 reserved2;
	__le32 dev_notification;
	__le64 cmd_ring;
	__le32 reserved3[4];
	__le64 dcbaa_ptr;
	__le32 config_reg;
	__le32 reserved4[241];
	__le32 port_status_base;
	__le32 port_power_base;
	__le32 port_link_base;
	__le32 reserved5;
	__le32 reserved6[1016];
};

struct xhci_intr_reg {
	__le32 irq_pending;
	__le32 irq_control;
	__le32 erst_size;
	__le32 rsvd;
	__le64 erst_base;
	__le64 erst_dequeue;
};

struct xhci_run_regs {
	__le32 microframe_index;
	__le32 rsvd[7];
	struct xhci_intr_reg ir_set[128];
};

struct xhci_doorbell_array {
	__le32 doorbell[256];
};

struct xhci_container_ctx {
	unsigned int type;
	int size;
	u8 *bytes;
	dma_addr_t dma;
};

struct xhci_slot_ctx {
	__le32 dev_info;
	__le32 dev_info2;
	__le32 tt_info;
	__le32 dev_state;
	__le32 reserved[4];
};

struct xhci_ep_ctx {
	__le32 ep_info;
	__le32 ep_info2;
	__le64 deq;
	__le32 tx_info;
	__le32 reserved[3];
};

struct xhci_input_control_ctx {
	__le32 drop_flags;
	__le32 add_flags;
	__le32 rsvd2[6];
};

union xhci_trb;

struct xhci_command {
	struct xhci_container_ctx *in_ctx;
	u32 status;
	int slot_id;
	struct completion *completion;
	union xhci_trb *command_trb;
	struct list_head cmd_list;
};

struct xhci_link_trb {
	__le64 segment_ptr;
	__le32 intr_target;
	__le32 control;
};

struct xhci_transfer_event {
	__le64 buffer;
	__le32 transfer_len;
	__le32 flags;
};

struct xhci_event_cmd {
	__le64 cmd_trb;
	__le32 status;
	__le32 flags;
};

struct xhci_generic_trb {
	__le32 field[4];
};

union xhci_trb {
	struct xhci_link_trb link;
	struct xhci_transfer_event trans_event;
	struct xhci_event_cmd event_cmd;
	struct xhci_generic_trb generic;
};

struct xhci_stream_ctx {
	__le64 stream_ring;
	__le32 reserved[2];
};

struct xhci_ring;

struct xhci_stream_info {
	struct xhci_ring **stream_rings;
	unsigned int num_streams;
	struct xhci_stream_ctx *stream_ctx_array;
	unsigned int num_stream_ctxs;
	dma_addr_t ctx_array_dma;
	struct xarray trb_address_map;
	struct xhci_command *free_streams_command;
};

enum xhci_ring_type {
	TYPE_CTRL = 0,
	TYPE_ISOC = 1,
	TYPE_BULK = 2,
	TYPE_INTR = 3,
	TYPE_STREAM = 4,
	TYPE_COMMAND = 5,
	TYPE_EVENT = 6,
};

struct xhci_segment;

struct xhci_ring {
	struct xhci_segment *first_seg;
	struct xhci_segment *last_seg;
	union xhci_trb *enqueue;
	struct xhci_segment *enq_seg;
	union xhci_trb *dequeue;
	struct xhci_segment *deq_seg;
	struct list_head td_list;
	u32 cycle_state;
	unsigned int err_count;
	unsigned int stream_id;
	unsigned int num_segs;
	unsigned int num_trbs_free;
	unsigned int num_trbs_free_temp;
	unsigned int bounce_buf_len;
	enum xhci_ring_type type;
	bool last_td_was_short;
	struct xarray *trb_address_map;
};

struct xhci_bw_info {
	unsigned int ep_interval;
	unsigned int mult;
	unsigned int num_packets;
	unsigned int max_packet_size;
	unsigned int max_esit_payload;
	unsigned int type;
};

struct xhci_virt_device;

struct xhci_hcd;

struct xhci_virt_ep {
	struct xhci_virt_device *vdev;
	unsigned int ep_index;
	struct xhci_ring *ring;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *new_ring;
	unsigned int ep_state;
	struct list_head cancelled_td_list;
	struct timer_list stop_cmd_timer;
	struct xhci_hcd *xhci;
	struct xhci_segment *queued_deq_seg;
	union xhci_trb *queued_deq_ptr;
	bool skip;
	struct xhci_bw_info bw_info;
	struct list_head bw_endpoint_list;
	int next_frame_id;
	bool use_extended_tbc;
};

struct xhci_interval_bw_table;

struct xhci_tt_bw_info;

struct xhci_virt_device {
	int slot_id;
	struct usb_device *udev;
	struct xhci_container_ctx *out_ctx;
	struct xhci_container_ctx *in_ctx;
	struct xhci_virt_ep eps[31];
	u8 fake_port;
	u8 real_port;
	struct xhci_interval_bw_table *bw_table;
	struct xhci_tt_bw_info *tt_info;
	long unsigned int flags;
	u16 current_mel;
	void *debugfs_private;
};

struct xhci_erst_entry;

struct xhci_erst {
	struct xhci_erst_entry *entries;
	unsigned int num_entries;
	dma_addr_t erst_dma_addr;
	unsigned int erst_size;
};

struct s3_save {
	u32 command;
	u32 dev_nt;
	u64 dcbaa_ptr;
	u32 config_reg;
	u32 irq_pending;
	u32 irq_control;
	u32 erst_size;
	u64 erst_base;
	u64 erst_dequeue;
};

struct xhci_bus_state {
	long unsigned int bus_suspended;
	long unsigned int next_statechange;
	u32 port_c_suspend;
	u32 suspended_ports;
	u32 port_remote_wakeup;
	long unsigned int resume_done[31];
	long unsigned int resuming_ports;
	long unsigned int rexit_ports;
	struct completion rexit_done[31];
	struct completion u3exit_done[31];
};

struct xhci_port;

struct xhci_hub {
	struct xhci_port **ports;
	unsigned int num_ports;
	struct usb_hcd *hcd;
	struct xhci_bus_state bus_state;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_device_context_array;

struct xhci_scratchpad;

struct xhci_root_port_bw_info;

struct xhci_port_cap;

struct xhci_hcd {
	struct usb_hcd *main_hcd;
	struct usb_hcd *shared_hcd;
	struct xhci_cap_regs *cap_regs;
	struct xhci_op_regs *op_regs;
	struct xhci_run_regs *run_regs;
	struct xhci_doorbell_array *dba;
	struct xhci_intr_reg *ir_set;
	__u32 hcs_params1;
	__u32 hcs_params2;
	__u32 hcs_params3;
	__u32 hcc_params;
	__u32 hcc_params2;
	spinlock_t lock;
	u8 sbrn;
	u16 hci_version;
	u8 max_slots;
	u8 max_interrupters;
	u8 max_ports;
	u8 isoc_threshold;
	u32 imod_interval;
	int event_ring_max;
	int page_size;
	int page_shift;
	int msix_count;
	struct clk *clk;
	struct clk *reg_clk;
	struct reset_control *reset;
	struct xhci_device_context_array *dcbaa;
	struct xhci_ring *cmd_ring;
	unsigned int cmd_ring_state;
	struct list_head cmd_list;
	unsigned int cmd_ring_reserved_trbs;
	struct delayed_work cmd_timer;
	struct completion cmd_ring_stop_completion;
	struct xhci_command *current_cmd;
	struct xhci_ring *event_ring;
	struct xhci_erst erst;
	struct xhci_scratchpad *scratchpad;
	struct list_head lpm_failed_devs;
	struct mutex mutex;
	struct xhci_command *lpm_command;
	struct xhci_virt_device *devs[256];
	struct xhci_root_port_bw_info *rh_bw;
	struct dma_pool___2 *device_pool;
	struct dma_pool___2 *segment_pool;
	struct dma_pool___2 *small_streams_pool;
	struct dma_pool___2 *medium_streams_pool;
	unsigned int xhc_state;
	u32 command;
	struct s3_save s3;
	long long unsigned int quirks;
	unsigned int num_active_eps;
	unsigned int limit_active_eps;
	struct xhci_port *hw_ports;
	struct xhci_hub usb2_rhub;
	struct xhci_hub usb3_rhub;
	unsigned int hw_lpm_support: 1;
	unsigned int broken_suspend: 1;
	u32 *ext_caps;
	unsigned int num_ext_caps;
	struct xhci_port_cap *port_caps;
	unsigned int num_port_caps;
	struct timer_list comp_mode_recovery_timer;
	u32 port_status_u0;
	u16 test_mode;
	struct dentry *debugfs_root;
	struct dentry *debugfs_slots;
	struct list_head regset_list;
	void *dbc;
	long unsigned int priv[0];
};

struct xhci_segment {
	union xhci_trb *trbs;
	struct xhci_segment *next;
	dma_addr_t dma;
	dma_addr_t bounce_dma;
	void *bounce_buf;
	unsigned int bounce_offs;
	unsigned int bounce_len;
};

enum xhci_overhead_type {
	LS_OVERHEAD_TYPE = 0,
	FS_OVERHEAD_TYPE = 1,
	HS_OVERHEAD_TYPE = 2,
};

struct xhci_interval_bw {
	unsigned int num_packets;
	struct list_head endpoints;
	unsigned int overhead[3];
};

struct xhci_interval_bw_table {
	unsigned int interval0_esit_payload;
	struct xhci_interval_bw interval_bw[16];
	unsigned int bw_used;
	unsigned int ss_bw_in;
	unsigned int ss_bw_out;
};

struct xhci_tt_bw_info {
	struct list_head tt_list;
	int slot_id;
	int ttport;
	struct xhci_interval_bw_table bw_table;
	int active_eps;
};

struct xhci_root_port_bw_info {
	struct list_head tts;
	unsigned int num_active_tts;
	struct xhci_interval_bw_table bw_table;
};

struct xhci_device_context_array {
	__le64 dev_context_ptrs[256];
	dma_addr_t dma;
};

enum xhci_setup_dev {
	SETUP_CONTEXT_ONLY = 0,
	SETUP_CONTEXT_ADDRESS = 1,
};

enum xhci_cancelled_td_status {
	TD_DIRTY = 0,
	TD_HALTED = 1,
	TD_CLEARING_CACHE = 2,
	TD_CLEARED = 3,
};

struct xhci_td {
	struct list_head td_list;
	struct list_head cancelled_td_list;
	int status;
	enum xhci_cancelled_td_status cancel_status;
	struct urb *urb;
	struct xhci_segment *start_seg;
	union xhci_trb *first_trb;
	union xhci_trb *last_trb;
	struct xhci_segment *last_trb_seg;
	struct xhci_segment *bounce_seg;
	bool urb_length_set;
	unsigned int num_trbs;
};

struct xhci_erst_entry {
	__le64 seg_addr;
	__le32 seg_size;
	__le32 rsvd;
};

struct xhci_scratchpad {
	u64 *sp_array;
	dma_addr_t sp_dma;
	void **sp_buffers;
};

struct urb_priv___3 {
	int num_tds;
	int num_tds_done;
	struct xhci_td td[0];
};

struct xhci_port_cap {
	u32 *psi;
	u8 psi_count;
	u8 psi_uid_count;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_port {
	__le32 *addr;
	int hw_portnum;
	int hcd_portnum;
	struct xhci_hub *rhub;
	struct xhci_port_cap *port_cap;
};

struct xhci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
};

typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);

enum xhci_ep_reset_type {
	EP_HARD_RESET = 0,
	EP_SOFT_RESET = 1,
};

struct dbc_regs {
	__le32 capability;
	__le32 doorbell;
	__le32 ersts;
	__le32 __reserved_0;
	__le64 erstba;
	__le64 erdp;
	__le32 control;
	__le32 status;
	__le32 portsc;
	__le32 __reserved_1;
	__le64 dccp;
	__le32 devinfo1;
	__le32 devinfo2;
};

struct dbc_str_descs {
	char string0[64];
	char manufacturer[64];
	char product[64];
	char serial[64];
};

enum dbc_state {
	DS_DISABLED = 0,
	DS_INITIALIZED = 1,
	DS_ENABLED = 2,
	DS_CONNECTED = 3,
	DS_CONFIGURED = 4,
	DS_STALLED = 5,
};

struct xhci_dbc;

struct dbc_ep {
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	struct xhci_ring *ring;
	unsigned int direction: 1;
};

struct dbc_driver;

struct xhci_dbc {
	spinlock_t lock;
	struct device *dev;
	struct xhci_hcd *xhci;
	struct dbc_regs *regs;
	struct xhci_ring *ring_evt;
	struct xhci_ring *ring_in;
	struct xhci_ring *ring_out;
	struct xhci_erst erst;
	struct xhci_container_ctx *ctx;
	struct dbc_str_descs *string;
	dma_addr_t string_dma;
	size_t string_size;
	enum dbc_state state;
	struct delayed_work event_work;
	unsigned int resume_required: 1;
	struct dbc_ep eps[2];
	const struct dbc_driver *driver;
	void *priv;
};

struct dbc_driver {
	int (*configure)(struct xhci_dbc *);
	void (*disconnect)(struct xhci_dbc *);
};

struct dbc_request {
	void *buf;
	unsigned int length;
	dma_addr_t dma;
	void (*complete)(struct xhci_dbc *, struct dbc_request *);
	struct list_head list_pool;
	int status;
	unsigned int actual;
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	dma_addr_t trb_dma;
	union xhci_trb *trb;
	unsigned int direction: 1;
};

struct trace_event_raw_xhci_log_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctx {
	struct trace_entry ent;
	int ctx_64;
	unsigned int ctx_type;
	dma_addr_t ctx_dma;
	u8 *ctx_va;
	unsigned int ctx_ep_num;
	int slot_id;
	u32 __data_loc_ctx_data;
	char __data[0];
};

struct trace_event_raw_xhci_log_trb {
	struct trace_entry ent;
	u32 type;
	u32 field0;
	u32 field1;
	u32 field2;
	u32 field3;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_free_virt_dev {
	struct trace_entry ent;
	void *vdev;
	long long unsigned int out_ctx;
	long long unsigned int in_ctx;
	u8 fake_port;
	u8 real_port;
	u16 current_mel;
	char __data[0];
};

struct trace_event_raw_xhci_log_virt_dev {
	struct trace_entry ent;
	void *vdev;
	long long unsigned int out_ctx;
	long long unsigned int in_ctx;
	int devnum;
	int state;
	int speed;
	u8 portnum;
	u8 level;
	int slot_id;
	char __data[0];
};

struct trace_event_raw_xhci_log_urb {
	struct trace_entry ent;
	void *urb;
	unsigned int pipe;
	unsigned int stream;
	int status;
	unsigned int flags;
	int num_mapped_sgs;
	int num_sgs;
	int length;
	int actual;
	int epnum;
	int dir_in;
	int type;
	int slot_id;
	char __data[0];
};

struct trace_event_raw_xhci_log_ep_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u64 deq;
	u32 tx_info;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_slot_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u32 tt_info;
	u32 state;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctrl_ctx {
	struct trace_entry ent;
	u32 drop;
	u32 add;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_ring {
	struct trace_entry ent;
	u32 type;
	void *ring;
	dma_addr_t enq;
	dma_addr_t deq;
	dma_addr_t enq_seg;
	dma_addr_t deq_seg;
	unsigned int num_segs;
	unsigned int stream_id;
	unsigned int cycle_state;
	unsigned int num_trbs_free;
	unsigned int bounce_buf_len;
	char __data[0];
};

struct trace_event_raw_xhci_log_portsc {
	struct trace_entry ent;
	u32 portnum;
	u32 portsc;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_doorbell {
	struct trace_entry ent;
	u32 slot;
	u32 doorbell;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_dbc_log_request {
	struct trace_entry ent;
	struct dbc_request *req;
	bool dir;
	unsigned int actual;
	unsigned int length;
	int status;
	char __data[0];
};

struct trace_event_data_offsets_xhci_log_msg {
	u32 msg;
};

struct trace_event_data_offsets_xhci_log_ctx {
	u32 ctx_data;
};

struct trace_event_data_offsets_xhci_log_trb {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_free_virt_dev {};

struct trace_event_data_offsets_xhci_log_virt_dev {};

struct trace_event_data_offsets_xhci_log_urb {};

struct trace_event_data_offsets_xhci_log_ep_ctx {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_slot_ctx {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_ctrl_ctx {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_ring {};

struct trace_event_data_offsets_xhci_log_portsc {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_doorbell {
	u32 str;
};

struct trace_event_data_offsets_xhci_dbc_log_request {};

typedef void (*btf_trace_xhci_dbg_address)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_context_change)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_quirks)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_reset_ep)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_cancel_urb)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_init)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_ring_expansion)(void *, struct va_format *);

typedef void (*btf_trace_xhci_address_ctx)(void *, struct xhci_hcd *, struct xhci_container_ctx *, unsigned int);

typedef void (*btf_trace_xhci_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_handle_command)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_queue_trb)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_gadget_ep_queue)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_free_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_alloc_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_addressable_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_stop_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_urb_enqueue)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_giveback)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_dequeue)(void *, struct urb *);

typedef void (*btf_trace_xhci_handle_cmd_stop_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_config_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_add_endpoint)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_alloc_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_free_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_disable_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_discover_or_reset_device)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_setup_device_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_addr_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_address_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_ring_alloc)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_free)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_expansion)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_enq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_deq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_handle_port_status)(void *, u32, u32);

typedef void (*btf_trace_xhci_get_port_status)(void *, u32, u32);

typedef void (*btf_trace_xhci_hub_status_data)(void *, u32, u32);

typedef void (*btf_trace_xhci_ring_ep_doorbell)(void *, u32, u32);

typedef void (*btf_trace_xhci_ring_host_doorbell)(void *, u32, u32);

typedef void (*btf_trace_xhci_dbc_alloc_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_free_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_queue_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_giveback_request)(void *, struct dbc_request *);

struct usb_string_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wData[1];
};

struct dbc_info_context {
	__le64 string0;
	__le64 manufacturer;
	__le64 product;
	__le64 serial;
	__le32 length;
	__le32 __reserved_0[7];
};

enum evtreturn {
	EVT_ERR = 4294967295,
	EVT_DONE = 0,
	EVT_GSER = 1,
	EVT_DISC = 2,
};

struct kfifo {
	union {
		struct __kfifo kfifo;
		unsigned char *type;
		const unsigned char *const_type;
		char (*rectype)[0];
		void *ptr;
		const void *ptr_const;
	};
	unsigned char buf[0];
};

struct dbc_port {
	struct tty_port port;
	spinlock_t port_lock;
	struct list_head read_pool;
	struct list_head read_queue;
	unsigned int n_read;
	struct tasklet_struct push;
	struct list_head write_pool;
	struct kfifo write_fifo;
	bool registered;
};

struct xhci_regset {
	char name[32];
	struct debugfs_regset32 regset;
	size_t nregs;
	struct list_head list;
};

struct xhci_file_map {
	const char *name;
	int (*show)(struct seq_file *, void *);
};

struct xhci_ep_priv {
	char name[32];
	struct dentry *root;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *show_ring;
	unsigned int stream_id;
};

struct xhci_slot_priv {
	char name[32];
	struct dentry *root;
	struct xhci_ep_priv *eps[31];
	struct xhci_virt_device *dev;
};

struct usb_role_switch {
	struct device dev;
	struct mutex lock;
	enum usb_role role;
	struct device *usb2_port;
	struct device *usb3_port;
	struct device *udc;
	usb_role_switch_set_t set;
	usb_role_switch_get_t get;
	bool allow_userspace_control;
};

struct serio_device_id {
	__u8 type;
	__u8 extra;
	__u8 id;
	__u8 proto;
};

struct serio_driver;

struct serio {
	void *port_data;
	char name[32];
	char phys[32];
	char firmware_id[128];
	bool manual_bind;
	struct serio_device_id id;
	spinlock_t lock;
	int (*write)(struct serio *, unsigned char);
	int (*open)(struct serio *);
	void (*close)(struct serio *);
	int (*start)(struct serio *);
	void (*stop)(struct serio *);
	struct serio *parent;
	struct list_head child_node;
	struct list_head children;
	unsigned int depth;
	struct serio_driver *drv;
	struct mutex drv_mutex;
	struct device dev;
	struct list_head node;
	struct mutex *ps2_cmd_mutex;
};

struct serio_driver {
	const char *description;
	const struct serio_device_id *id_table;
	bool manual_bind;
	void (*write_wakeup)(struct serio *);
	irqreturn_t (*interrupt)(struct serio *, unsigned char, unsigned int);
	int (*connect)(struct serio *, struct serio_driver *);
	int (*reconnect)(struct serio *);
	int (*fast_reconnect)(struct serio *);
	void (*disconnect)(struct serio *);
	void (*cleanup)(struct serio *);
	struct device_driver driver;
};

enum serio_event_type {
	SERIO_RESCAN_PORT = 0,
	SERIO_RECONNECT_PORT = 1,
	SERIO_RECONNECT_SUBTREE = 2,
	SERIO_REGISTER_PORT = 3,
	SERIO_ATTACH_DRIVER = 4,
};

struct serio_event {
	enum serio_event_type type;
	void *object;
	struct module *owner;
	struct list_head node;
};

struct ps2dev {
	struct serio *serio;
	struct mutex cmd_mutex;
	wait_queue_head_t wait;
	long unsigned int flags;
	u8 cmdbuf[8];
	u8 cmdcnt;
	u8 nak;
};

struct input_mt_slot {
	int abs[14];
	unsigned int frame;
	unsigned int key;
};

struct input_mt {
	int trkid;
	int num_slots;
	int slot;
	unsigned int flags;
	unsigned int frame;
	int *red;
	struct input_mt_slot slots[0];
};

union input_seq_state {
	struct {
		short unsigned int pos;
		bool mutex_acquired;
	};
	void *p;
};

struct input_devres {
	struct input_dev *input;
};

struct input_event {
	__kernel_ulong_t __sec;
	__kernel_ulong_t __usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct input_event_compat {
	compat_ulong_t sec;
	compat_ulong_t usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct ff_periodic_effect_compat {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	compat_uptr_t custom_data;
};

struct ff_effect_compat {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect_compat periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct input_mt_pos {
	s16 x;
	s16 y;
};

struct input_dev_poller {
	void (*poll)(struct input_dev *);
	unsigned int poll_interval;
	unsigned int poll_interval_max;
	unsigned int poll_interval_min;
	struct input_dev *input;
	struct delayed_work work;
};

struct touchscreen_properties {
	unsigned int max_x;
	unsigned int max_y;
	bool invert_x;
	bool invert_y;
	bool swap_x_y;
};

struct mousedev_hw_data {
	int dx;
	int dy;
	int dz;
	int x;
	int y;
	int abs_event;
	long unsigned int buttons;
};

struct mousedev {
	int open;
	struct input_handle handle;
	wait_queue_head_t wait;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device dev;
	struct cdev cdev;
	bool exist;
	struct list_head mixdev_node;
	bool opened_by_mixdev;
	struct mousedev_hw_data packet;
	unsigned int pkt_count;
	int old_x[4];
	int old_y[4];
	int frac_dx;
	int frac_dy;
	long unsigned int touch;
	int (*open_device)(struct mousedev *);
	void (*close_device)(struct mousedev *);
};

enum mousedev_emul {
	MOUSEDEV_EMUL_PS2 = 0,
	MOUSEDEV_EMUL_IMPS = 1,
	MOUSEDEV_EMUL_EXPS = 2,
};

struct mousedev_motion {
	int dx;
	int dy;
	int dz;
	long unsigned int buttons;
};

struct mousedev_client {
	struct fasync_struct *fasync;
	struct mousedev *mousedev;
	struct list_head node;
	struct mousedev_motion packets[16];
	unsigned int head;
	unsigned int tail;
	spinlock_t packet_lock;
	int pos_x;
	int pos_y;
	u8 ps2[6];
	unsigned char ready;
	unsigned char buffer;
	unsigned char bufsiz;
	unsigned char imexseq;
	unsigned char impsseq;
	enum mousedev_emul mode;
	long unsigned int last_buttons;
};

enum {
	FRACTION_DENOM = 128,
};

struct input_mask {
	__u32 type;
	__u32 codes_size;
	__u64 codes_ptr;
};

struct evdev_client;

struct evdev {
	int open;
	struct input_handle handle;
	struct evdev_client *grab;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device dev;
	struct cdev cdev;
	bool exist;
};

struct evdev_client {
	unsigned int head;
	unsigned int tail;
	unsigned int packet_head;
	spinlock_t buffer_lock;
	wait_queue_head_t wait;
	struct fasync_struct *fasync;
	struct evdev *evdev;
	struct list_head node;
	enum input_clock_type clk_type;
	bool revoked;
	long unsigned int *evmasks[32];
	unsigned int bufsize;
	struct input_event buffer[0];
};

struct atkbd {
	struct ps2dev ps2dev;
	struct input_dev *dev;
	char name[64];
	char phys[32];
	short unsigned int id;
	short unsigned int keycode[512];
	long unsigned int force_release_mask[8];
	unsigned char set;
	bool translated;
	bool extra;
	bool write;
	bool softrepeat;
	bool softraw;
	bool scroll;
	bool enabled;
	unsigned char emul;
	bool resend;
	bool release;
	long unsigned int xl_bit;
	unsigned int last;
	long unsigned int time;
	long unsigned int err_count;
	struct delayed_work event_work;
	long unsigned int event_jiffies;
	long unsigned int event_mask;
	struct mutex mutex;
	u32 function_row_physmap[24];
	int num_function_row_keys;
};

struct uinput_ff_upload {
	__u32 request_id;
	__s32 retval;
	struct ff_effect effect;
	struct ff_effect old;
};

struct uinput_ff_erase {
	__u32 request_id;
	__s32 retval;
	__u32 effect_id;
};

struct uinput_setup {
	struct input_id id;
	char name[80];
	__u32 ff_effects_max;
};

struct uinput_abs_setup {
	__u16 code;
	struct input_absinfo absinfo;
};

struct uinput_user_dev {
	char name[80];
	struct input_id id;
	__u32 ff_effects_max;
	__s32 absmax[64];
	__s32 absmin[64];
	__s32 absfuzz[64];
	__s32 absflat[64];
};

enum uinput_state {
	UIST_NEW_DEVICE = 0,
	UIST_SETUP_COMPLETE = 1,
	UIST_CREATED = 2,
};

struct uinput_request {
	unsigned int id;
	unsigned int code;
	int retval;
	struct completion done;
	union {
		unsigned int effect_id;
		struct {
			struct ff_effect *effect;
			struct ff_effect *old;
		} upload;
	} u;
};

struct uinput_device {
	struct input_dev *dev;
	struct mutex mutex;
	enum uinput_state state;
	wait_queue_head_t waitq;
	unsigned char ready;
	unsigned char head;
	unsigned char tail;
	struct input_event buff[16];
	unsigned int ff_effects_max;
	struct uinput_request *requests[16];
	wait_queue_head_t requests_waitq;
	spinlock_t requests_lock;
};

struct uinput_ff_upload_compat {
	__u32 request_id;
	__s32 retval;
	struct ff_effect_compat effect;
	struct ff_effect_compat old;
};

struct trace_event_raw_rtc_time_alarm_class {
	struct trace_entry ent;
	time64_t secs;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_freq {
	struct trace_entry ent;
	int freq;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_state {
	struct trace_entry ent;
	int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_alarm_irq_enable {
	struct trace_entry ent;
	unsigned int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_offset_class {
	struct trace_entry ent;
	long int offset;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_timer_class {
	struct trace_entry ent;
	struct rtc_timer *timer;
	ktime_t expires;
	ktime_t period;
	char __data[0];
};

struct trace_event_data_offsets_rtc_time_alarm_class {};

struct trace_event_data_offsets_rtc_irq_set_freq {};

struct trace_event_data_offsets_rtc_irq_set_state {};

struct trace_event_data_offsets_rtc_alarm_irq_enable {};

struct trace_event_data_offsets_rtc_offset_class {};

struct trace_event_data_offsets_rtc_timer_class {};

typedef void (*btf_trace_rtc_set_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_set_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_irq_set_freq)(void *, int, int);

typedef void (*btf_trace_rtc_irq_set_state)(void *, int, int);

typedef void (*btf_trace_rtc_alarm_irq_enable)(void *, unsigned int, int);

typedef void (*btf_trace_rtc_set_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_read_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_timer_enqueue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_dequeue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_fired)(void *, struct rtc_timer *);

enum {
	none = 0,
	day = 1,
	month = 2,
	year = 3,
};

struct nvmem_cell_info {
	const char *name;
	unsigned int offset;
	unsigned int bytes;
	unsigned int bit_offset;
	unsigned int nbits;
};

typedef int (*nvmem_reg_read_t)(void *, unsigned int, void *, size_t);

typedef int (*nvmem_reg_write_t)(void *, unsigned int, void *, size_t);

enum nvmem_type {
	NVMEM_TYPE_UNKNOWN = 0,
	NVMEM_TYPE_EEPROM = 1,
	NVMEM_TYPE_OTP = 2,
	NVMEM_TYPE_BATTERY_BACKED = 3,
};

struct nvmem_keepout {
	unsigned int start;
	unsigned int end;
	unsigned char value;
};

struct nvmem_config {
	struct device *dev;
	const char *name;
	int id;
	struct module *owner;
	struct gpio_desc *wp_gpio;
	const struct nvmem_cell_info *cells;
	int ncells;
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	enum nvmem_type type;
	bool read_only;
	bool root_only;
	bool no_of_node;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	int size;
	int word_size;
	int stride;
	void *priv;
	bool compat;
	struct device *base_dev;
};

struct nvmem_device;

struct rtc_plat_data {
	struct rtc_device *rtc;
	void *ioaddr;
	int irq;
	struct clk *clk;
};

struct rtd119x_rtc {
	void *base;
	struct clk *clk;
	struct rtc_device *rtcdev;
	unsigned int base_year;
};

struct sun6i_rtc_clk_data {
	long unsigned int rc_osc_rate;
	unsigned int fixed_prescaler: 16;
	unsigned int has_prescaler: 1;
	unsigned int has_out_clk: 1;
	unsigned int export_iosc: 1;
	unsigned int has_losc_en: 1;
	unsigned int has_auto_swt: 1;
};

struct sun6i_rtc_dev {
	struct rtc_device *rtc;
	const struct sun6i_rtc_clk_data *data;
	void *base;
	int irq;
	long unsigned int alarm;
	struct clk_hw hw;
	struct clk_hw *int_osc;
	struct clk *losc;
	struct clk *ext_losc;
	spinlock_t lock;
};

struct xgene_rtc_dev {
	struct rtc_device *rtc;
	void *csr_base;
	struct clk *clk;
	unsigned int irq_wake;
	unsigned int irq_enabled;
};

struct i2c_devinfo {
	struct list_head list;
	int busnum;
	struct i2c_board_info board_info;
};

struct i2c_device_identity {
	u16 manufacturer_id;
	u16 part_id;
	u8 die_revision;
};

struct i2c_timings {
	u32 bus_freq_hz;
	u32 scl_rise_ns;
	u32 scl_fall_ns;
	u32 scl_int_delay_ns;
	u32 sda_fall_ns;
	u32 sda_hold_ns;
	u32 digital_filter_width_ns;
	u32 analog_filter_cutoff_freq_hz;
};

struct trace_event_raw_i2c_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	char __data[0];
};

struct trace_event_raw_i2c_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 nr_msgs;
	__s16 ret;
	char __data[0];
};

struct trace_event_data_offsets_i2c_write {
	u32 buf;
};

struct trace_event_data_offsets_i2c_read {};

struct trace_event_data_offsets_i2c_reply {
	u32 buf;
};

struct trace_event_data_offsets_i2c_result {};

typedef void (*btf_trace_i2c_write)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_read)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_reply)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_result)(void *, const struct i2c_adapter *, int, int);

struct class_compat___2;

struct i2c_cmd_arg {
	unsigned int cmd;
	void *arg;
};

struct i2c_smbus_alert_setup {
	int irq;
};

struct trace_event_raw_smbus_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 flags;
	__u16 addr;
	__u8 command;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 read_write;
	__u8 command;
	__s16 res;
	__u32 protocol;
	char __data[0];
};

struct trace_event_data_offsets_smbus_write {};

struct trace_event_data_offsets_smbus_read {};

struct trace_event_data_offsets_smbus_reply {};

struct trace_event_data_offsets_smbus_result {};

typedef void (*btf_trace_smbus_write)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *);

typedef void (*btf_trace_smbus_read)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int);

typedef void (*btf_trace_smbus_reply)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *, int);

typedef void (*btf_trace_smbus_result)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, int);

struct i2c_acpi_handler_data {
	struct acpi_connection_info info;
	struct i2c_adapter *adapter;
};

struct gsb_buffer {
	u8 status;
	u8 len;
	union {
		u16 wdata;
		u8 bdata;
		u8 data[0];
	};
};

struct i2c_acpi_lookup {
	struct i2c_board_info *info;
	acpi_handle adapter_handle;
	acpi_handle device_handle;
	acpi_handle search_handle;
	int n;
	int index;
	u32 speed;
	u32 min_speed;
	u32 force_speed;
};

struct i2c_smbus_ioctl_data {
	__u8 read_write;
	__u8 command;
	__u32 size;
	union i2c_smbus_data *data;
};

struct i2c_rdwr_ioctl_data {
	struct i2c_msg *msgs;
	__u32 nmsgs;
};

struct i2c_dev {
	struct list_head list;
	struct i2c_adapter *adap;
	struct device dev;
	struct cdev cdev;
};

struct i2c_smbus_ioctl_data32 {
	u8 read_write;
	u8 command;
	u32 size;
	compat_caddr_t data;
};

struct i2c_msg32 {
	u16 addr;
	u16 flags;
	u16 len;
	compat_caddr_t buf;
};

struct i2c_rdwr_ioctl_data32 {
	compat_caddr_t msgs;
	u32 nmsgs;
};

struct dw_i2c_dev {
	struct device *dev;
	struct regmap *map;
	struct regmap *sysmap;
	void *base;
	void *ext;
	struct completion cmd_complete;
	struct clk *clk;
	struct clk *pclk;
	struct reset_control *rst;
	struct i2c_client *slave;
	u32 (*get_clk_rate_khz)(struct dw_i2c_dev *);
	int cmd_err;
	struct i2c_msg *msgs;
	int msgs_num;
	int msg_write_idx;
	u32 tx_buf_len;
	u8 *tx_buf;
	int msg_read_idx;
	u32 rx_buf_len;
	u8 *rx_buf;
	int msg_err;
	unsigned int status;
	u32 abort_source;
	int irq;
	u32 flags;
	struct i2c_adapter adapter;
	u32 functionality;
	u32 master_cfg;
	u32 slave_cfg;
	unsigned int tx_fifo_depth;
	unsigned int rx_fifo_depth;
	int rx_outstanding;
	struct i2c_timings timings;
	u32 sda_hold_time;
	u16 ss_hcnt;
	u16 ss_lcnt;
	u16 fs_hcnt;
	u16 fs_lcnt;
	u16 fp_hcnt;
	u16 fp_lcnt;
	u16 hs_hcnt;
	u16 hs_lcnt;
	int (*acquire_lock)();
	void (*release_lock)();
	bool shared_with_punit;
	void (*disable)(struct dw_i2c_dev *);
	void (*disable_int)(struct dw_i2c_dev *);
	int (*init)(struct dw_i2c_dev *);
	int (*set_sda_hold_time)(struct dw_i2c_dev *);
	int mode;
	struct i2c_bus_recovery_info rinfo;
	bool suspended;
};

struct omap_i2c_bus_platform_data {
	u32 clkrate;
	u32 rev;
	u32 flags;
	void (*set_mpu_wkup_lat)(struct device *, long int);
};

enum {
	OMAP_I2C_REV_REG = 0,
	OMAP_I2C_IE_REG = 1,
	OMAP_I2C_STAT_REG = 2,
	OMAP_I2C_IV_REG = 3,
	OMAP_I2C_WE_REG = 4,
	OMAP_I2C_SYSS_REG = 5,
	OMAP_I2C_BUF_REG = 6,
	OMAP_I2C_CNT_REG = 7,
	OMAP_I2C_DATA_REG = 8,
	OMAP_I2C_SYSC_REG = 9,
	OMAP_I2C_CON_REG = 10,
	OMAP_I2C_OA_REG = 11,
	OMAP_I2C_SA_REG = 12,
	OMAP_I2C_PSC_REG = 13,
	OMAP_I2C_SCLL_REG = 14,
	OMAP_I2C_SCLH_REG = 15,
	OMAP_I2C_SYSTEST_REG = 16,
	OMAP_I2C_BUFSTAT_REG = 17,
	OMAP_I2C_IP_V2_REVNB_LO = 18,
	OMAP_I2C_IP_V2_REVNB_HI = 19,
	OMAP_I2C_IP_V2_IRQSTATUS_RAW = 20,
	OMAP_I2C_IP_V2_IRQENABLE_SET = 21,
	OMAP_I2C_IP_V2_IRQENABLE_CLR = 22,
};

struct omap_i2c_dev {
	struct device *dev;
	void *base;
	int irq;
	int reg_shift;
	struct completion cmd_complete;
	struct resource *ioarea;
	u32 latency;
	void (*set_mpu_wkup_lat)(struct device *, long int);
	u32 speed;
	u32 flags;
	u16 scheme;
	u16 cmd_err;
	u8 *buf;
	u8 *regs;
	size_t buf_len;
	struct i2c_adapter adapter;
	u8 threshold;
	u8 fifo_size;
	u32 rev;
	unsigned int b_hw: 1;
	unsigned int bb_valid: 1;
	unsigned int receiver: 1;
	u16 iestate;
	u16 pscstate;
	u16 scllstate;
	u16 sclhstate;
	u16 syscstate;
	u16 westate;
	u16 errata;
};

struct sprd_i2c {
	struct i2c_adapter adap;
	struct device *dev;
	void *base;
	struct i2c_msg *msg;
	struct clk *clk;
	u32 src_clk;
	u32 bus_freq;
	struct completion complete;
	u8 *buf;
	u32 count;
	int irq;
	int err;
};

struct pps_ktime {
	__s64 sec;
	__s32 nsec;
	__u32 flags;
};

struct pps_ktime_compat {
	__s64 sec;
	__s32 nsec;
	__u32 flags;
};

struct pps_kinfo {
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
};

struct pps_kinfo_compat {
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime_compat assert_tu;
	struct pps_ktime_compat clear_tu;
	int current_mode;
} __attribute__((packed));

struct pps_kparams {
	int api_version;
	int mode;
	struct pps_ktime assert_off_tu;
	struct pps_ktime clear_off_tu;
};

struct pps_fdata {
	struct pps_kinfo info;
	struct pps_ktime timeout;
};

struct pps_fdata_compat {
	struct pps_kinfo_compat info;
	struct pps_ktime_compat timeout;
} __attribute__((packed));

struct pps_bind_args {
	int tsformat;
	int edge;
	int consumer;
};

struct pps_device;

struct pps_source_info {
	char name[32];
	char path[32];
	int mode;
	void (*echo)(struct pps_device *, int, void *);
	struct module *owner;
	struct device *dev;
};

struct pps_device {
	struct pps_source_info info;
	struct pps_kparams params;
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
	unsigned int last_ev;
	wait_queue_head_t queue;
	unsigned int id;
	const void *lookup_cookie;
	struct cdev cdev;
	struct device *dev;
	struct fasync_struct *async_queue;
	spinlock_t lock;
};

struct ptp_extts_event {
	struct ptp_clock_time t;
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct timestamp_event_queue {
	struct ptp_extts_event buf[128];
	int head;
	int tail;
	spinlock_t lock;
};

struct ptp_clock___2 {
	struct posix_clock clock;
	struct device dev;
	struct ptp_clock_info *info;
	dev_t devid;
	int index;
	struct pps_device *pps_source;
	long int dialed_frequency;
	struct timestamp_event_queue tsevq;
	struct mutex tsevq_mux;
	struct mutex pincfg_mux;
	wait_queue_head_t tsev_wq;
	int defunct;
	struct device_attribute *pin_dev_attr;
	struct attribute **pin_attr;
	struct attribute_group pin_attr_group;
	const struct attribute_group *pin_attr_groups[2];
	struct kthread_worker *kworker;
	struct kthread_delayed_work aux_work;
};

struct ptp_clock_caps {
	int max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int pps;
	int n_pins;
	int cross_timestamping;
	int adjust_phase;
	int rsv[12];
};

struct ptp_sys_offset {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[51];
};

struct ptp_sys_offset_extended {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[75];
};

struct ptp_sys_offset_precise {
	struct ptp_clock_time device;
	struct ptp_clock_time sys_realtime;
	struct ptp_clock_time sys_monoraw;
	unsigned int rsv[4];
};

struct as3722_poweroff {
	struct device *dev;
	struct as3722 *as3722;
};

struct gpio_restart {
	struct gpio_desc *reset_gpio;
	struct notifier_block restart_handler;
	u32 active_delay_ms;
	u32 inactive_delay_ms;
	u32 wait_delay_ms;
};

struct mt6323_pwrc {
	struct device *dev;
	struct regmap *regmap;
	u32 base;
};

struct ltc2952_poweroff {
	struct hrtimer timer_trigger;
	struct hrtimer timer_wde;
	ktime_t trigger_delay;
	ktime_t wde_interval;
	struct device *dev;
	struct gpio_desc *gpio_trigger;
	struct gpio_desc *gpio_watchdog;
	struct gpio_desc *gpio_kill;
	bool kernel_panic;
	struct notifier_block panic_notifier;
};

enum vexpress_reset_func {
	FUNC_RESET = 0,
	FUNC_SHUTDOWN = 1,
	FUNC_REBOOT = 2,
};

struct syscon_reboot_context {
	struct regmap *map;
	u32 offset;
	u32 value;
	u32 mask;
	struct notifier_block restart_handler;
};

enum power_supply_notifier_events {
	PSY_EVENT_PROP_CHANGED = 0,
};

struct power_supply_battery_ocv_table {
	int ocv;
	int capacity;
};

struct power_supply_resistance_temp_table {
	int temp;
	int resistance;
};

struct power_supply_battery_info {
	int energy_full_design_uwh;
	int charge_full_design_uah;
	int voltage_min_design_uv;
	int voltage_max_design_uv;
	int tricklecharge_current_ua;
	int precharge_current_ua;
	int precharge_voltage_max_uv;
	int charge_term_current_ua;
	int charge_restart_voltage_uv;
	int overvoltage_limit_uv;
	int constant_charge_current_max_ua;
	int constant_charge_voltage_max_uv;
	int factory_internal_resistance_uohm;
	int ocv_temp[20];
	int temp_ambient_alert_min;
	int temp_ambient_alert_max;
	int temp_alert_min;
	int temp_alert_max;
	int temp_min;
	int temp_max;
	struct power_supply_battery_ocv_table *ocv_table[20];
	int ocv_table_size[20];
	struct power_supply_resistance_temp_table *resist_table;
	int resist_table_size;
};

struct psy_am_i_supplied_data {
	struct power_supply *psy;
	unsigned int count;
};

enum {
	POWER_SUPPLY_CHARGE_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_CHARGE_TYPE_NONE = 1,
	POWER_SUPPLY_CHARGE_TYPE_TRICKLE = 2,
	POWER_SUPPLY_CHARGE_TYPE_FAST = 3,
	POWER_SUPPLY_CHARGE_TYPE_STANDARD = 4,
	POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE = 5,
	POWER_SUPPLY_CHARGE_TYPE_CUSTOM = 6,
	POWER_SUPPLY_CHARGE_TYPE_LONGLIFE = 7,
};

enum {
	POWER_SUPPLY_HEALTH_UNKNOWN = 0,
	POWER_SUPPLY_HEALTH_GOOD = 1,
	POWER_SUPPLY_HEALTH_OVERHEAT = 2,
	POWER_SUPPLY_HEALTH_DEAD = 3,
	POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4,
	POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5,
	POWER_SUPPLY_HEALTH_COLD = 6,
	POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7,
	POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8,
	POWER_SUPPLY_HEALTH_OVERCURRENT = 9,
	POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED = 10,
	POWER_SUPPLY_HEALTH_WARM = 11,
	POWER_SUPPLY_HEALTH_COOL = 12,
	POWER_SUPPLY_HEALTH_HOT = 13,
};

enum {
	POWER_SUPPLY_SCOPE_UNKNOWN = 0,
	POWER_SUPPLY_SCOPE_SYSTEM = 1,
	POWER_SUPPLY_SCOPE_DEVICE = 2,
};

struct power_supply_attr {
	const char *prop_name;
	char attr_name[31];
	struct device_attribute dev_attr;
	const char * const *text_values;
	int text_values_len;
};

enum hwmon_in_attributes {
	hwmon_in_enable = 0,
	hwmon_in_input = 1,
	hwmon_in_min = 2,
	hwmon_in_max = 3,
	hwmon_in_lcrit = 4,
	hwmon_in_crit = 5,
	hwmon_in_average = 6,
	hwmon_in_lowest = 7,
	hwmon_in_highest = 8,
	hwmon_in_reset_history = 9,
	hwmon_in_label = 10,
	hwmon_in_alarm = 11,
	hwmon_in_min_alarm = 12,
	hwmon_in_max_alarm = 13,
	hwmon_in_lcrit_alarm = 14,
	hwmon_in_crit_alarm = 15,
	hwmon_in_rated_min = 16,
	hwmon_in_rated_max = 17,
};

enum hwmon_curr_attributes {
	hwmon_curr_enable = 0,
	hwmon_curr_input = 1,
	hwmon_curr_min = 2,
	hwmon_curr_max = 3,
	hwmon_curr_lcrit = 4,
	hwmon_curr_crit = 5,
	hwmon_curr_average = 6,
	hwmon_curr_lowest = 7,
	hwmon_curr_highest = 8,
	hwmon_curr_reset_history = 9,
	hwmon_curr_label = 10,
	hwmon_curr_alarm = 11,
	hwmon_curr_min_alarm = 12,
	hwmon_curr_max_alarm = 13,
	hwmon_curr_lcrit_alarm = 14,
	hwmon_curr_crit_alarm = 15,
	hwmon_curr_rated_min = 16,
	hwmon_curr_rated_max = 17,
};

struct power_supply_hwmon {
	struct power_supply *psy;
	long unsigned int *props;
};

struct hwmon_type_attr_list {
	const u32 *attrs;
	size_t n_attrs;
};

enum cm_batt_temp {
	CM_BATT_OK = 0,
	CM_BATT_OVERHEAT = 1,
	CM_BATT_COLD = 2,
};

enum hwmon_power_attributes {
	hwmon_power_enable = 0,
	hwmon_power_average = 1,
	hwmon_power_average_interval = 2,
	hwmon_power_average_interval_max = 3,
	hwmon_power_average_interval_min = 4,
	hwmon_power_average_highest = 5,
	hwmon_power_average_lowest = 6,
	hwmon_power_average_max = 7,
	hwmon_power_average_min = 8,
	hwmon_power_input = 9,
	hwmon_power_input_highest = 10,
	hwmon_power_input_lowest = 11,
	hwmon_power_reset_history = 12,
	hwmon_power_accuracy = 13,
	hwmon_power_cap = 14,
	hwmon_power_cap_hyst = 15,
	hwmon_power_cap_max = 16,
	hwmon_power_cap_min = 17,
	hwmon_power_min = 18,
	hwmon_power_max = 19,
	hwmon_power_crit = 20,
	hwmon_power_lcrit = 21,
	hwmon_power_label = 22,
	hwmon_power_alarm = 23,
	hwmon_power_cap_alarm = 24,
	hwmon_power_min_alarm = 25,
	hwmon_power_max_alarm = 26,
	hwmon_power_lcrit_alarm = 27,
	hwmon_power_crit_alarm = 28,
	hwmon_power_rated_min = 29,
	hwmon_power_rated_max = 30,
};

enum hwmon_energy_attributes {
	hwmon_energy_enable = 0,
	hwmon_energy_input = 1,
	hwmon_energy_label = 2,
};

enum hwmon_humidity_attributes {
	hwmon_humidity_enable = 0,
	hwmon_humidity_input = 1,
	hwmon_humidity_label = 2,
	hwmon_humidity_min = 3,
	hwmon_humidity_min_hyst = 4,
	hwmon_humidity_max = 5,
	hwmon_humidity_max_hyst = 6,
	hwmon_humidity_alarm = 7,
	hwmon_humidity_fault = 8,
	hwmon_humidity_rated_min = 9,
	hwmon_humidity_rated_max = 10,
};

enum hwmon_fan_attributes {
	hwmon_fan_enable = 0,
	hwmon_fan_input = 1,
	hwmon_fan_label = 2,
	hwmon_fan_min = 3,
	hwmon_fan_max = 4,
	hwmon_fan_div = 5,
	hwmon_fan_pulses = 6,
	hwmon_fan_target = 7,
	hwmon_fan_alarm = 8,
	hwmon_fan_min_alarm = 9,
	hwmon_fan_max_alarm = 10,
	hwmon_fan_fault = 11,
};

enum hwmon_pwm_attributes {
	hwmon_pwm_input = 0,
	hwmon_pwm_enable = 1,
	hwmon_pwm_mode = 2,
	hwmon_pwm_freq = 3,
};

enum hwmon_intrusion_attributes {
	hwmon_intrusion_alarm = 0,
	hwmon_intrusion_beep = 1,
};

struct trace_event_raw_hwmon_attr_class {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	long int val;
	char __data[0];
};

struct trace_event_raw_hwmon_attr_show_string {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	u32 __data_loc_label;
	char __data[0];
};

struct trace_event_data_offsets_hwmon_attr_class {
	u32 attr_name;
};

struct trace_event_data_offsets_hwmon_attr_show_string {
	u32 attr_name;
	u32 label;
};

typedef void (*btf_trace_hwmon_attr_show)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_store)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_show_string)(void *, int, const char *, const char *);

struct hwmon_device {
	const char *name;
	struct device dev;
	const struct hwmon_chip_info *chip;
	struct list_head tzdata;
	struct attribute_group group;
	const struct attribute_group **groups;
};

struct hwmon_device_attribute {
	struct device_attribute dev_attr;
	const struct hwmon_ops *ops;
	enum hwmon_sensor_types type;
	u32 attr;
	int index;
	char name[32];
};

struct hwmon_thermal_data {
	struct list_head node;
	struct device *dev;
	int index;
	struct thermal_zone_device *tzd;
};

struct thermal_attr {
	struct device_attribute attr;
	char name[20];
};

struct devfreq_dev_status {
	long unsigned int total_time;
	long unsigned int busy_time;
	long unsigned int current_frequency;
	void *private_data;
};

struct trace_event_raw_thermal_temperature {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int temp_prev;
	int temp;
	char __data[0];
};

struct trace_event_raw_cdev_update {
	struct trace_entry ent;
	u32 __data_loc_type;
	long unsigned int target;
	char __data[0];
};

struct trace_event_raw_thermal_zone_trip {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int trip;
	enum thermal_trip_type trip_type;
	char __data[0];
};

struct trace_event_raw_thermal_power_cpu_get_power {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	long unsigned int freq;
	u32 __data_loc_load;
	size_t load_len;
	u32 dynamic_power;
	char __data[0];
};

struct trace_event_raw_thermal_power_cpu_limit {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	unsigned int freq;
	long unsigned int cdev_state;
	u32 power;
	char __data[0];
};

struct trace_event_raw_thermal_power_devfreq_get_power {
	struct trace_entry ent;
	u32 __data_loc_type;
	long unsigned int freq;
	u32 busy_time;
	u32 total_time;
	u32 power;
	char __data[0];
};

struct trace_event_raw_thermal_power_devfreq_limit {
	struct trace_entry ent;
	u32 __data_loc_type;
	unsigned int freq;
	long unsigned int cdev_state;
	u32 power;
	char __data[0];
};

struct trace_event_data_offsets_thermal_temperature {
	u32 thermal_zone;
};

struct trace_event_data_offsets_cdev_update {
	u32 type;
};

struct trace_event_data_offsets_thermal_zone_trip {
	u32 thermal_zone;
};

struct trace_event_data_offsets_thermal_power_cpu_get_power {
	u32 cpumask;
	u32 load;
};

struct trace_event_data_offsets_thermal_power_cpu_limit {
	u32 cpumask;
};

struct trace_event_data_offsets_thermal_power_devfreq_get_power {
	u32 type;
};

struct trace_event_data_offsets_thermal_power_devfreq_limit {
	u32 type;
};

typedef void (*btf_trace_thermal_temperature)(void *, struct thermal_zone_device *);

typedef void (*btf_trace_cdev_update)(void *, struct thermal_cooling_device *, long unsigned int);

typedef void (*btf_trace_thermal_zone_trip)(void *, struct thermal_zone_device *, int, enum thermal_trip_type);

typedef void (*btf_trace_thermal_power_cpu_get_power)(void *, const struct cpumask *, long unsigned int, u32 *, size_t, u32);

typedef void (*btf_trace_thermal_power_cpu_limit)(void *, const struct cpumask *, unsigned int, long unsigned int, u32);

typedef void (*btf_trace_thermal_power_devfreq_get_power)(void *, struct thermal_cooling_device *, struct devfreq_dev_status *, long unsigned int, u32);

typedef void (*btf_trace_thermal_power_devfreq_limit)(void *, struct thermal_cooling_device *, long unsigned int, long unsigned int, u32);

struct thermal_instance {
	int id;
	char name[20];
	struct thermal_zone_device *tz;
	struct thermal_cooling_device *cdev;
	int trip;
	bool initialized;
	long unsigned int upper;
	long unsigned int lower;
	long unsigned int target;
	char attr_name[20];
	struct device_attribute attr;
	char weight_attr_name[20];
	struct device_attribute weight_attr;
	struct list_head tz_node;
	struct list_head cdev_node;
	unsigned int weight;
};

struct cooling_dev_stats {
	spinlock_t lock;
	unsigned int total_trans;
	long unsigned int state;
	long unsigned int max_states;
	ktime_t last_time;
	ktime_t *time_in_state;
	unsigned int *trans_table;
};

struct genl_dumpit_info {
	const struct genl_family *family;
	struct genl_ops op;
	struct nlattr **attrs;
};

enum thermal_genl_attr {
	THERMAL_GENL_ATTR_UNSPEC = 0,
	THERMAL_GENL_ATTR_TZ = 1,
	THERMAL_GENL_ATTR_TZ_ID = 2,
	THERMAL_GENL_ATTR_TZ_TEMP = 3,
	THERMAL_GENL_ATTR_TZ_TRIP = 4,
	THERMAL_GENL_ATTR_TZ_TRIP_ID = 5,
	THERMAL_GENL_ATTR_TZ_TRIP_TYPE = 6,
	THERMAL_GENL_ATTR_TZ_TRIP_TEMP = 7,
	THERMAL_GENL_ATTR_TZ_TRIP_HYST = 8,
	THERMAL_GENL_ATTR_TZ_MODE = 9,
	THERMAL_GENL_ATTR_TZ_NAME = 10,
	THERMAL_GENL_ATTR_TZ_CDEV_WEIGHT = 11,
	THERMAL_GENL_ATTR_TZ_GOV = 12,
	THERMAL_GENL_ATTR_TZ_GOV_NAME = 13,
	THERMAL_GENL_ATTR_CDEV = 14,
	THERMAL_GENL_ATTR_CDEV_ID = 15,
	THERMAL_GENL_ATTR_CDEV_CUR_STATE = 16,
	THERMAL_GENL_ATTR_CDEV_MAX_STATE = 17,
	THERMAL_GENL_ATTR_CDEV_NAME = 18,
	THERMAL_GENL_ATTR_GOV_NAME = 19,
	__THERMAL_GENL_ATTR_MAX = 20,
};

enum thermal_genl_sampling {
	THERMAL_GENL_SAMPLING_TEMP = 0,
	__THERMAL_GENL_SAMPLING_MAX = 1,
};

enum thermal_genl_event {
	THERMAL_GENL_EVENT_UNSPEC = 0,
	THERMAL_GENL_EVENT_TZ_CREATE = 1,
	THERMAL_GENL_EVENT_TZ_DELETE = 2,
	THERMAL_GENL_EVENT_TZ_DISABLE = 3,
	THERMAL_GENL_EVENT_TZ_ENABLE = 4,
	THERMAL_GENL_EVENT_TZ_TRIP_UP = 5,
	THERMAL_GENL_EVENT_TZ_TRIP_DOWN = 6,
	THERMAL_GENL_EVENT_TZ_TRIP_CHANGE = 7,
	THERMAL_GENL_EVENT_TZ_TRIP_ADD = 8,
	THERMAL_GENL_EVENT_TZ_TRIP_DELETE = 9,
	THERMAL_GENL_EVENT_CDEV_ADD = 10,
	THERMAL_GENL_EVENT_CDEV_DELETE = 11,
	THERMAL_GENL_EVENT_CDEV_STATE_UPDATE = 12,
	THERMAL_GENL_EVENT_TZ_GOV_CHANGE = 13,
	__THERMAL_GENL_EVENT_MAX = 14,
};

enum thermal_genl_cmd {
	THERMAL_GENL_CMD_UNSPEC = 0,
	THERMAL_GENL_CMD_TZ_GET_ID = 1,
	THERMAL_GENL_CMD_TZ_GET_TRIP = 2,
	THERMAL_GENL_CMD_TZ_GET_TEMP = 3,
	THERMAL_GENL_CMD_TZ_GET_GOV = 4,
	THERMAL_GENL_CMD_TZ_GET_MODE = 5,
	THERMAL_GENL_CMD_CDEV_GET = 6,
	__THERMAL_GENL_CMD_MAX = 7,
};

struct param {
	struct nlattr **attrs;
	struct sk_buff *msg;
	const char *name;
	int tz_id;
	int cdev_id;
	int trip_id;
	int trip_temp;
	int trip_type;
	int trip_hyst;
	int temp;
	int cdev_state;
	int cdev_max_state;
};

typedef int (*cb_t)(struct param *);

struct thermal_hwmon_device {
	char type[20];
	struct device *device;
	int count;
	struct list_head tz_list;
	struct list_head node;
};

struct thermal_hwmon_attr {
	struct device_attribute attr;
	char name[16];
};

struct thermal_hwmon_temp {
	struct list_head hwmon_node;
	struct thermal_zone_device *tz;
	struct thermal_hwmon_attr temp_input;
	struct thermal_hwmon_attr temp_crit;
};

struct thermal_trip {
	struct device_node *np;
	int temperature;
	int hysteresis;
	enum thermal_trip_type type;
};

struct __thermal_cooling_bind_param {
	struct device_node *cooling_device;
	long unsigned int min;
	long unsigned int max;
};

struct __thermal_bind_params {
	struct __thermal_cooling_bind_param *tcbp;
	unsigned int count;
	unsigned int trip_id;
	unsigned int usage;
};

struct __thermal_zone {
	int passive_delay;
	int polling_delay;
	int slope;
	int offset;
	int ntrips;
	struct thermal_trip *trips;
	int num_tbps;
	struct __thermal_bind_params *tbps;
	void *sensor_data;
	const struct thermal_zone_of_device_ops *ops;
};

struct trace_event_raw_thermal_power_allocator {
	struct trace_entry ent;
	int tz_id;
	u32 __data_loc_req_power;
	u32 total_req_power;
	u32 __data_loc_granted_power;
	u32 total_granted_power;
	size_t num_actors;
	u32 power_range;
	u32 max_allocatable_power;
	int current_temp;
	s32 delta_temp;
	char __data[0];
};

struct trace_event_raw_thermal_power_allocator_pid {
	struct trace_entry ent;
	int tz_id;
	s32 err;
	s32 err_integral;
	s64 p;
	s64 i;
	s64 d;
	s32 output;
	char __data[0];
};

struct trace_event_data_offsets_thermal_power_allocator {
	u32 req_power;
	u32 granted_power;
};

struct trace_event_data_offsets_thermal_power_allocator_pid {};

typedef void (*btf_trace_thermal_power_allocator)(void *, struct thermal_zone_device *, u32 *, u32, u32 *, u32, size_t, u32, u32, int, s32);

typedef void (*btf_trace_thermal_power_allocator_pid)(void *, struct thermal_zone_device *, s32, s32, s64, s64, s64, s32);

struct power_allocator_params {
	bool allocated_tzp;
	s64 err_integral;
	s32 prev_err;
	int trip_switch_on;
	int trip_max_desired_temperature;
	u32 sustainable_power;
};

struct cpufreq_cooling_device {
	u32 last_load;
	unsigned int cpufreq_state;
	unsigned int max_level;
	struct em_perf_domain *em;
	struct cpufreq_policy *policy;
	struct freq_qos_request qos_req;
};

struct idle_inject_device;

struct cpuidle_cooling_device {
	struct idle_inject_device *ii_dev;
	long unsigned int state;
};

enum devfreq_timer {
	DEVFREQ_TIMER_DEFERRABLE = 0,
	DEVFREQ_TIMER_DELAYED = 1,
	DEVFREQ_TIMER_NUM = 2,
};

struct devfreq_dev_profile {
	long unsigned int initial_freq;
	unsigned int polling_ms;
	enum devfreq_timer timer;
	bool is_cooling_device;
	int (*target)(struct device *, long unsigned int *, u32);
	int (*get_dev_status)(struct device *, struct devfreq_dev_status *);
	int (*get_cur_freq)(struct device *, long unsigned int *);
	void (*exit)(struct device *);
	long unsigned int *freq_table;
	unsigned int max_state;
};

struct devfreq_stats {
	unsigned int total_trans;
	unsigned int *trans_table;
	u64 *time_in_state;
	u64 last_update;
};

struct devfreq_governor;

struct devfreq {
	struct list_head node;
	struct mutex lock;
	struct device dev;
	struct devfreq_dev_profile *profile;
	const struct devfreq_governor *governor;
	struct opp_table *opp_table;
	struct notifier_block nb;
	struct delayed_work work;
	long unsigned int previous_freq;
	struct devfreq_dev_status last_status;
	void *data;
	struct dev_pm_qos_request user_min_freq_req;
	struct dev_pm_qos_request user_max_freq_req;
	long unsigned int scaling_min_freq;
	long unsigned int scaling_max_freq;
	bool stop_polling;
	long unsigned int suspend_freq;
	long unsigned int resume_freq;
	atomic_t suspend_count;
	struct devfreq_stats stats;
	struct srcu_notifier_head transition_notifier_list;
	struct thermal_cooling_device *cdev;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct devfreq_governor {
	struct list_head node;
	const char name[16];
	const u64 attrs;
	const u64 flags;
	int (*get_target_freq)(struct devfreq *, long unsigned int *);
	int (*event_handler)(struct devfreq *, unsigned int, void *);
};

struct devfreq_cooling_power {
	int (*get_real_power)(struct devfreq *, u32 *, long unsigned int, long unsigned int);
};

struct devfreq_cooling_device {
	struct thermal_cooling_device *cdev;
	struct devfreq *devfreq;
	long unsigned int cooling_state;
	u32 *freq_table;
	size_t max_state;
	struct devfreq_cooling_power *power_ops;
	u32 res_util;
	int capped_state;
	struct dev_pm_qos_request req_max_freq;
	struct em_perf_domain *em_pd;
};

struct armada_thermal_data;

struct armada_thermal_priv {
	struct device *dev;
	struct regmap *syscon;
	char zone_name[20];
	struct mutex update_lock;
	struct armada_thermal_data *data;
	struct thermal_zone_device *overheat_sensor;
	int interrupt_source;
	int current_channel;
	long int current_threshold;
	long int current_hysteresis;
};

struct armada_thermal_data {
	void (*init)(struct platform_device *, struct armada_thermal_priv *);
	s64 coef_b;
	s64 coef_m;
	u32 coef_div;
	bool inverted;
	bool signed_sample;
	unsigned int temp_shift;
	unsigned int temp_mask;
	unsigned int thresh_shift;
	unsigned int hyst_shift;
	unsigned int hyst_mask;
	u32 is_valid_bit;
	unsigned int syscon_control0_off;
	unsigned int syscon_control1_off;
	unsigned int syscon_status_off;
	unsigned int dfx_irq_cause_off;
	unsigned int dfx_irq_mask_off;
	unsigned int dfx_overheat_irq;
	unsigned int dfx_server_irq_mask_off;
	unsigned int dfx_server_irq_en;
	unsigned int cpu_nr;
};

enum drvtype {
	LEGACY = 0,
	SYSCON = 1,
};

struct armada_drvdata {
	enum drvtype type;
	union {
		struct armada_thermal_priv *priv;
		struct thermal_zone_device *tz;
	} data;
};

struct armada_thermal_sensor {
	struct armada_thermal_priv *priv;
	int id;
};

struct watchdog_info {
	__u32 options;
	__u32 firmware_version;
	__u8 identity[32];
};

struct watchdog_device;

struct watchdog_ops {
	struct module *owner;
	int (*start)(struct watchdog_device *);
	int (*stop)(struct watchdog_device *);
	int (*ping)(struct watchdog_device *);
	unsigned int (*status)(struct watchdog_device *);
	int (*set_timeout)(struct watchdog_device *, unsigned int);
	int (*set_pretimeout)(struct watchdog_device *, unsigned int);
	unsigned int (*get_timeleft)(struct watchdog_device *);
	int (*restart)(struct watchdog_device *, long unsigned int, void *);
	long int (*ioctl)(struct watchdog_device *, unsigned int, long unsigned int);
};

struct watchdog_governor;

struct watchdog_core_data;

struct watchdog_device {
	int id;
	struct device *parent;
	const struct attribute_group **groups;
	const struct watchdog_info *info;
	const struct watchdog_ops *ops;
	const struct watchdog_governor *gov;
	unsigned int bootstatus;
	unsigned int timeout;
	unsigned int pretimeout;
	unsigned int min_timeout;
	unsigned int max_timeout;
	unsigned int min_hw_heartbeat_ms;
	unsigned int max_hw_heartbeat_ms;
	struct notifier_block reboot_nb;
	struct notifier_block restart_nb;
	void *driver_data;
	struct watchdog_core_data *wd_data;
	long unsigned int status;
	struct list_head deferred;
};

struct watchdog_governor {
	const char name[20];
	void (*pretimeout)(struct watchdog_device *);
};

struct watchdog_core_data {
	struct device dev;
	struct cdev cdev;
	struct watchdog_device *wdd;
	struct mutex lock;
	ktime_t last_keepalive;
	ktime_t last_hw_keepalive;
	ktime_t open_deadline;
	struct hrtimer timer;
	struct kthread_work work;
	long unsigned int status;
};

struct watchdog_pretimeout {
	struct watchdog_device *wdd;
	struct list_head entry;
};

struct governor_priv {
	struct watchdog_governor *gov;
	struct list_head entry;
};

struct rtd119x_watchdog_device {
	struct watchdog_device wdt_dev;
	void *base;
	struct clk *clk;
};

struct mdp_device_descriptor_s {
	__u32 number;
	__u32 major;
	__u32 minor;
	__u32 raid_disk;
	__u32 state;
	__u32 reserved[27];
};

typedef struct mdp_device_descriptor_s mdp_disk_t;

struct mdp_superblock_s {
	__u32 md_magic;
	__u32 major_version;
	__u32 minor_version;
	__u32 patch_version;
	__u32 gvalid_words;
	__u32 set_uuid0;
	__u32 ctime;
	__u32 level;
	__u32 size;
	__u32 nr_disks;
	__u32 raid_disks;
	__u32 md_minor;
	__u32 not_persistent;
	__u32 set_uuid1;
	__u32 set_uuid2;
	__u32 set_uuid3;
	__u32 gstate_creserved[16];
	__u32 utime;
	__u32 state;
	__u32 active_disks;
	__u32 working_disks;
	__u32 failed_disks;
	__u32 spare_disks;
	__u32 sb_csum;
	__u32 events_lo;
	__u32 events_hi;
	__u32 cp_events_lo;
	__u32 cp_events_hi;
	__u32 recovery_cp;
	__u64 reshape_position;
	__u32 new_level;
	__u32 delta_disks;
	__u32 new_layout;
	__u32 new_chunk;
	__u32 gstate_sreserved[14];
	__u32 layout;
	__u32 chunk_size;
	__u32 root_pv;
	__u32 root_block;
	__u32 pstate_reserved[60];
	mdp_disk_t disks[27];
	__u32 reserved[0];
	mdp_disk_t this_disk;
};

typedef struct mdp_superblock_s mdp_super_t;

struct mdp_superblock_1 {
	__le32 magic;
	__le32 major_version;
	__le32 feature_map;
	__le32 pad0;
	__u8 set_uuid[16];
	char set_name[32];
	__le64 ctime;
	__le32 level;
	__le32 layout;
	__le64 size;
	__le32 chunksize;
	__le32 raid_disks;
	union {
		__le32 bitmap_offset;
		struct {
			__le16 offset;
			__le16 size;
		} ppl;
	};
	__le32 new_level;
	__le64 reshape_position;
	__le32 delta_disks;
	__le32 new_layout;
	__le32 new_chunk;
	__le32 new_offset;
	__le64 data_offset;
	__le64 data_size;
	__le64 super_offset;
	union {
		__le64 recovery_offset;
		__le64 journal_tail;
	};
	__le32 dev_number;
	__le32 cnt_corrected_read;
	__u8 device_uuid[16];
	__u8 devflags;
	__u8 bblog_shift;
	__le16 bblog_size;
	__le32 bblog_offset;
	__le64 utime;
	__le64 events;
	__le64 resync_offset;
	__le32 sb_csum;
	__le32 max_dev;
	__u8 pad3[32];
	__le16 dev_roles[0];
};

struct mdu_version_s {
	int major;
	int minor;
	int patchlevel;
};

typedef struct mdu_version_s mdu_version_t;

struct mdu_array_info_s {
	int major_version;
	int minor_version;
	int patch_version;
	unsigned int ctime;
	int level;
	int size;
	int nr_disks;
	int raid_disks;
	int md_minor;
	int not_persistent;
	unsigned int utime;
	int state;
	int active_disks;
	int working_disks;
	int failed_disks;
	int spare_disks;
	int layout;
	int chunk_size;
};

typedef struct mdu_array_info_s mdu_array_info_t;

struct mdu_disk_info_s {
	int number;
	int major;
	int minor;
	int raid_disk;
	int state;
};

typedef struct mdu_disk_info_s mdu_disk_info_t;

struct mdu_bitmap_file_s {
	char pathname[4096];
};

typedef struct mdu_bitmap_file_s mdu_bitmap_file_t;

struct mddev;

struct md_rdev;

struct md_cluster_operations {
	int (*join)(struct mddev *, int);
	int (*leave)(struct mddev *);
	int (*slot_number)(struct mddev *);
	int (*resync_info_update)(struct mddev *, sector_t, sector_t);
	void (*resync_info_get)(struct mddev *, sector_t *, sector_t *);
	int (*metadata_update_start)(struct mddev *);
	int (*metadata_update_finish)(struct mddev *);
	void (*metadata_update_cancel)(struct mddev *);
	int (*resync_start)(struct mddev *);
	int (*resync_finish)(struct mddev *);
	int (*area_resyncing)(struct mddev *, int, sector_t, sector_t);
	int (*add_new_disk)(struct mddev *, struct md_rdev *);
	void (*add_new_disk_cancel)(struct mddev *);
	int (*new_disk_ack)(struct mddev *, bool);
	int (*remove_disk)(struct mddev *, struct md_rdev *);
	void (*load_bitmaps)(struct mddev *, int);
	int (*gather_bitmaps)(struct md_rdev *);
	int (*resize_bitmaps)(struct mddev *, sector_t, sector_t);
	int (*lock_all_bitmaps)(struct mddev *);
	void (*unlock_all_bitmaps)(struct mddev *);
	void (*update_size)(struct mddev *, sector_t);
};

struct md_cluster_info;

struct md_personality;

struct md_thread;

struct bitmap;

struct mddev {
	void *private;
	struct md_personality *pers;
	dev_t unit;
	int md_minor;
	struct list_head disks;
	long unsigned int flags;
	long unsigned int sb_flags;
	int suspended;
	atomic_t active_io;
	int ro;
	int sysfs_active;
	struct gendisk *gendisk;
	struct kobject kobj;
	int hold_active;
	int major_version;
	int minor_version;
	int patch_version;
	int persistent;
	int external;
	char metadata_type[17];
	int chunk_sectors;
	time64_t ctime;
	time64_t utime;
	int level;
	int layout;
	char clevel[16];
	int raid_disks;
	int max_disks;
	sector_t dev_sectors;
	sector_t array_sectors;
	int external_size;
	__u64 events;
	int can_decrease_events;
	char uuid[16];
	sector_t reshape_position;
	int delta_disks;
	int new_level;
	int new_layout;
	int new_chunk_sectors;
	int reshape_backwards;
	struct md_thread *thread;
	struct md_thread *sync_thread;
	char *last_sync_action;
	sector_t curr_resync;
	sector_t curr_resync_completed;
	long unsigned int resync_mark;
	sector_t resync_mark_cnt;
	sector_t curr_mark_cnt;
	sector_t resync_max_sectors;
	atomic64_t resync_mismatches;
	sector_t suspend_lo;
	sector_t suspend_hi;
	int sync_speed_min;
	int sync_speed_max;
	int parallel_resync;
	int ok_start_degraded;
	long unsigned int recovery;
	int recovery_disabled;
	int in_sync;
	struct mutex open_mutex;
	struct mutex reconfig_mutex;
	atomic_t active;
	atomic_t openers;
	int changed;
	int degraded;
	atomic_t recovery_active;
	wait_queue_head_t recovery_wait;
	sector_t recovery_cp;
	sector_t resync_min;
	sector_t resync_max;
	struct kernfs_node *sysfs_state;
	struct kernfs_node *sysfs_action;
	struct kernfs_node *sysfs_completed;
	struct kernfs_node *sysfs_degraded;
	struct kernfs_node *sysfs_level;
	struct work_struct del_work;
	spinlock_t lock;
	wait_queue_head_t sb_wait;
	atomic_t pending_writes;
	unsigned int safemode;
	unsigned int safemode_delay;
	struct timer_list safemode_timer;
	struct percpu_ref writes_pending;
	int sync_checkers;
	struct request_queue *queue;
	struct bitmap *bitmap;
	struct {
		struct file *file;
		loff_t offset;
		long unsigned int space;
		loff_t default_offset;
		long unsigned int default_space;
		struct mutex mutex;
		long unsigned int chunksize;
		long unsigned int daemon_sleep;
		long unsigned int max_write_behind;
		int external;
		int nodes;
		char cluster_name[64];
	} bitmap_info;
	atomic_t max_corr_read_errors;
	struct list_head all_mddevs;
	struct attribute_group *to_remove;
	struct bio_set bio_set;
	struct bio_set sync_set;
	struct bio *flush_bio;
	atomic_t flush_pending;
	ktime_t start_flush;
	ktime_t prev_flush_start;
	struct work_struct flush_work;
	struct work_struct event_work;
	mempool_t *serial_info_pool;
	void (*sync_super)(struct mddev *, struct md_rdev *);
	struct md_cluster_info *cluster_info;
	unsigned int good_device_nr;
	unsigned int noio_flag;
	bool has_superblocks: 1;
	bool fail_last_dev: 1;
	bool serialize_policy: 1;
};

struct serial_in_rdev;

struct md_rdev {
	struct list_head same_set;
	sector_t sectors;
	struct mddev *mddev;
	int last_events;
	struct block_device *meta_bdev;
	struct block_device *bdev;
	struct page *sb_page;
	struct page *bb_page;
	int sb_loaded;
	__u64 sb_events;
	sector_t data_offset;
	sector_t new_data_offset;
	sector_t sb_start;
	int sb_size;
	int preferred_minor;
	struct kobject kobj;
	long unsigned int flags;
	wait_queue_head_t blocked_wait;
	int desc_nr;
	int raid_disk;
	int new_raid_disk;
	int saved_raid_disk;
	union {
		sector_t recovery_offset;
		sector_t journal_tail;
	};
	atomic_t nr_pending;
	atomic_t read_errors;
	time64_t last_read_error;
	atomic_t corrected_errors;
	struct serial_in_rdev *serial;
	struct work_struct del_work;
	struct kernfs_node *sysfs_state;
	struct kernfs_node *sysfs_unack_badblocks;
	struct kernfs_node *sysfs_badblocks;
	struct badblocks badblocks;
	struct {
		short int offset;
		unsigned int size;
		sector_t sector;
	} ppl;
};

struct serial_in_rdev {
	struct rb_root_cached serial_rb;
	spinlock_t serial_lock;
	wait_queue_head_t serial_io_wait;
};

enum flag_bits {
	Faulty = 0,
	In_sync = 1,
	Bitmap_sync = 2,
	WriteMostly = 3,
	AutoDetected = 4,
	Blocked = 5,
	WriteErrorSeen = 6,
	FaultRecorded = 7,
	BlockedBadBlocks = 8,
	WantReplacement = 9,
	Replacement = 10,
	Candidate = 11,
	Journal = 12,
	ClusterRemove = 13,
	RemoveSynchronized = 14,
	ExternalBbl = 15,
	FailFast = 16,
	LastDev = 17,
	CollisionCheck = 18,
};

enum mddev_flags {
	MD_ARRAY_FIRST_USE = 0,
	MD_CLOSING = 1,
	MD_JOURNAL_CLEAN = 2,
	MD_HAS_JOURNAL = 3,
	MD_CLUSTER_RESYNC_LOCKED = 4,
	MD_FAILFAST_SUPPORTED = 5,
	MD_HAS_PPL = 6,
	MD_HAS_MULTIPLE_PPLS = 7,
	MD_ALLOW_SB_UPDATE = 8,
	MD_UPDATING_SB = 9,
	MD_NOT_READY = 10,
	MD_BROKEN = 11,
};

enum mddev_sb_flags {
	MD_SB_CHANGE_DEVS = 0,
	MD_SB_CHANGE_CLEAN = 1,
	MD_SB_CHANGE_PENDING = 2,
	MD_SB_NEED_REWRITE = 3,
};

struct md_personality {
	char *name;
	int level;
	struct list_head list;
	struct module *owner;
	bool (*make_request)(struct mddev *, struct bio *);
	int (*run)(struct mddev *);
	int (*start)(struct mddev *);
	void (*free)(struct mddev *, void *);
	void (*status)(struct seq_file *, struct mddev *);
	void (*error_handler)(struct mddev *, struct md_rdev *);
	int (*hot_add_disk)(struct mddev *, struct md_rdev *);
	int (*hot_remove_disk)(struct mddev *, struct md_rdev *);
	int (*spare_active)(struct mddev *);
	sector_t (*sync_request)(struct mddev *, sector_t, int *);
	int (*resize)(struct mddev *, sector_t);
	sector_t (*size)(struct mddev *, sector_t, int);
	int (*check_reshape)(struct mddev *);
	int (*start_reshape)(struct mddev *);
	void (*finish_reshape)(struct mddev *);
	void (*update_reshape_pos)(struct mddev *);
	void (*quiesce)(struct mddev *, int);
	void * (*takeover)(struct mddev *);
	int (*change_consistency_policy)(struct mddev *, const char *);
};

struct md_thread {
	void (*run)(struct md_thread *);
	struct mddev *mddev;
	wait_queue_head_t wqueue;
	long unsigned int flags;
	struct task_struct *tsk;
	long unsigned int timeout;
	void *private;
};

struct bitmap_page;

struct bitmap_counts {
	spinlock_t lock;
	struct bitmap_page *bp;
	long unsigned int pages;
	long unsigned int missing_pages;
	long unsigned int chunkshift;
	long unsigned int chunks;
};

struct bitmap_storage {
	struct file *file;
	struct page *sb_page;
	struct page **filemap;
	long unsigned int *filemap_attr;
	long unsigned int file_pages;
	long unsigned int bytes;
};

struct bitmap {
	struct bitmap_counts counts;
	struct mddev *mddev;
	__u64 events_cleared;
	int need_sync;
	struct bitmap_storage storage;
	long unsigned int flags;
	int allclean;
	atomic_t behind_writes;
	long unsigned int behind_writes_used;
	long unsigned int daemon_lastrun;
	long unsigned int last_end_sync;
	atomic_t pending_writes;
	wait_queue_head_t write_wait;
	wait_queue_head_t overflow_wait;
	wait_queue_head_t behind_wait;
	struct kernfs_node *sysfs_can_clear;
	int cluster_slot;
};

enum recovery_flags {
	MD_RECOVERY_RUNNING = 0,
	MD_RECOVERY_SYNC = 1,
	MD_RECOVERY_RECOVER = 2,
	MD_RECOVERY_INTR = 3,
	MD_RECOVERY_DONE = 4,
	MD_RECOVERY_NEEDED = 5,
	MD_RECOVERY_REQUESTED = 6,
	MD_RECOVERY_CHECK = 7,
	MD_RECOVERY_RESHAPE = 8,
	MD_RECOVERY_FROZEN = 9,
	MD_RECOVERY_ERROR = 10,
	MD_RECOVERY_WAIT = 11,
	MD_RESYNCING_REMOTE = 12,
};

struct md_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct mddev *, char *);
	ssize_t (*store)(struct mddev *, const char *, size_t);
};

struct bitmap_page {
	char *map;
	unsigned int hijacked: 1;
	unsigned int pending: 1;
	unsigned int count: 30;
};

struct super_type {
	char *name;
	struct module *owner;
	int (*load_super)(struct md_rdev *, struct md_rdev *, int);
	int (*validate_super)(struct mddev *, struct md_rdev *);
	void (*sync_super)(struct mddev *, struct md_rdev *);
	long long unsigned int (*rdev_size_change)(struct md_rdev *, sector_t);
	int (*allow_new_offset)(struct md_rdev *, long long unsigned int);
};

struct rdev_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct md_rdev *, char *);
	ssize_t (*store)(struct md_rdev *, const char *, size_t);
};

enum array_state {
	clear = 0,
	inactive = 1,
	suspended = 2,
	readonly = 3,
	read_auto = 4,
	clean = 5,
	active = 6,
	write_pending = 7,
	active_idle = 8,
	broken = 9,
	bad_word = 10,
};

struct detected_devices_node {
	struct list_head list;
	dev_t dev;
};

typedef __u16 bitmap_counter_t;

enum bitmap_state {
	BITMAP_STALE = 1,
	BITMAP_WRITE_ERROR = 2,
	BITMAP_HOSTENDIAN = 15,
};

struct bitmap_super_s {
	__le32 magic;
	__le32 version;
	__u8 uuid[16];
	__le64 events;
	__le64 events_cleared;
	__le64 sync_size;
	__le32 state;
	__le32 chunksize;
	__le32 daemon_sleep;
	__le32 write_behind;
	__le32 sectors_reserved;
	__le32 nodes;
	__u8 cluster_name[64];
	__u8 pad[120];
};

typedef struct bitmap_super_s bitmap_super_t;

enum bitmap_page_attr {
	BITMAP_PAGE_DIRTY = 0,
	BITMAP_PAGE_PENDING = 1,
	BITMAP_PAGE_NEEDWRITE = 2,
};

struct md_setup_args {
	int minor;
	int partitioned;
	int level;
	int chunk;
	char *device_names;
};

struct dm_ioctl {
	__u32 version[3];
	__u32 data_size;
	__u32 data_start;
	__u32 target_count;
	__s32 open_count;
	__u32 flags;
	__u32 event_nr;
	__u32 padding;
	__u64 dev;
	char name[128];
	char uuid[129];
	char data[7];
};

struct dm_target_spec {
	__u64 sector_start;
	__u64 length;
	__s32 status;
	__u32 next;
	char target_type[16];
};

struct dm_device {
	struct dm_ioctl dmi;
	struct dm_target_spec *table[256];
	char *target_args_array[256];
	struct list_head list;
};

typedef enum {
	STATUSTYPE_INFO = 0,
	STATUSTYPE_TABLE = 1,
} status_type_t;

union map_info___2 {
	void *ptr;
};

struct dm_target;

typedef int (*dm_ctr_fn)(struct dm_target *, unsigned int, char **);

struct dm_table;

struct target_type;

struct dm_target {
	struct dm_table *table;
	struct target_type *type;
	sector_t begin;
	sector_t len;
	uint32_t max_io_len;
	unsigned int num_flush_bios;
	unsigned int num_discard_bios;
	unsigned int num_secure_erase_bios;
	unsigned int num_write_same_bios;
	unsigned int num_write_zeroes_bios;
	unsigned int per_io_data_size;
	void *private;
	char *error;
	bool flush_supported: 1;
	bool discards_supported: 1;
	bool limit_swap_bios: 1;
};

typedef void (*dm_dtr_fn)(struct dm_target *);

typedef int (*dm_map_fn)(struct dm_target *, struct bio *);

typedef int (*dm_clone_and_map_request_fn)(struct dm_target *, struct request *, union map_info___2 *, struct request **);

typedef void (*dm_release_clone_request_fn)(struct request *, union map_info___2 *);

typedef int (*dm_endio_fn)(struct dm_target *, struct bio *, blk_status_t *);

typedef int (*dm_request_endio_fn)(struct dm_target *, struct request *, blk_status_t, union map_info___2 *);

typedef void (*dm_presuspend_fn)(struct dm_target *);

typedef void (*dm_presuspend_undo_fn)(struct dm_target *);

typedef void (*dm_postsuspend_fn)(struct dm_target *);

typedef int (*dm_preresume_fn)(struct dm_target *);

typedef void (*dm_resume_fn)(struct dm_target *);

typedef void (*dm_status_fn)(struct dm_target *, status_type_t, unsigned int, char *, unsigned int);

typedef int (*dm_message_fn)(struct dm_target *, unsigned int, char **, char *, unsigned int);

typedef int (*dm_prepare_ioctl_fn)(struct dm_target *, struct block_device **);

struct dm_report_zones_args;

typedef int (*dm_report_zones_fn)(struct dm_target *, struct dm_report_zones_args *, unsigned int);

struct dm_report_zones_args {
	struct dm_target *tgt;
	sector_t next_sector;
	void *orig_data;
	report_zones_cb orig_cb;
	unsigned int zone_idx;
	sector_t start;
};

struct dm_dev;

typedef int (*iterate_devices_callout_fn)(struct dm_target *, struct dm_dev *, sector_t, sector_t, void *);

struct dm_dev {
	struct block_device *bdev;
	struct dax_device *dax_dev;
	fmode_t mode;
	char name[16];
};

typedef int (*dm_iterate_devices_fn)(struct dm_target *, iterate_devices_callout_fn, void *);

typedef void (*dm_io_hints_fn)(struct dm_target *, struct queue_limits *);

typedef int (*dm_busy_fn)(struct dm_target *);

typedef long int (*dm_dax_direct_access_fn)(struct dm_target *, long unsigned int, long int, void **, pfn_t *);

typedef size_t (*dm_dax_copy_iter_fn)(struct dm_target *, long unsigned int, void *, size_t, struct iov_iter *);

typedef int (*dm_dax_zero_page_range_fn)(struct dm_target *, long unsigned int, size_t);

struct target_type {
	uint64_t features;
	const char *name;
	struct module *module;
	unsigned int version[3];
	dm_ctr_fn ctr;
	dm_dtr_fn dtr;
	dm_map_fn map;
	dm_clone_and_map_request_fn clone_and_map_rq;
	dm_release_clone_request_fn release_clone_rq;
	dm_endio_fn end_io;
	dm_request_endio_fn rq_end_io;
	dm_presuspend_fn presuspend;
	dm_presuspend_undo_fn presuspend_undo;
	dm_postsuspend_fn postsuspend;
	dm_preresume_fn preresume;
	dm_resume_fn resume;
	dm_status_fn status;
	dm_message_fn message;
	dm_prepare_ioctl_fn prepare_ioctl;
	dm_report_zones_fn report_zones;
	dm_busy_fn busy;
	dm_iterate_devices_fn iterate_devices;
	dm_io_hints_fn io_hints;
	dm_dax_direct_access_fn direct_access;
	dm_dax_copy_iter_fn dax_copy_from_iter;
	dm_dax_copy_iter_fn dax_copy_to_iter;
	dm_dax_zero_page_range_fn dax_zero_page_range;
	struct list_head list;
};

enum dm_uevent_type {
	DM_UEVENT_PATH_FAILED = 0,
	DM_UEVENT_PATH_REINSTATED = 1,
};

struct mapped_device;

struct dm_uevent {
	struct mapped_device *md;
	enum kobject_action action;
	struct kobj_uevent_env ku_env;
	struct list_head elist;
	char name[128];
	char uuid[129];
};

enum dm_queue_mode {
	DM_TYPE_NONE = 0,
	DM_TYPE_BIO_BASED = 1,
	DM_TYPE_REQUEST_BASED = 2,
	DM_TYPE_DAX_BIO_BASED = 3,
};

struct mapped_device___2;

struct dm_md_mempools;

struct dm_table {
	struct mapped_device___2 *md;
	enum dm_queue_mode type;
	unsigned int depth;
	unsigned int counts[16];
	sector_t *index[16];
	unsigned int num_targets;
	unsigned int num_allocated;
	sector_t *highs;
	struct dm_target *targets;
	struct target_type *immutable_target_type;
	bool integrity_supported: 1;
	bool singleton: 1;
	unsigned int integrity_added: 1;
	fmode_t mode;
	struct list_head devices;
	void (*event_fn)(void *);
	void *event_context;
	struct dm_md_mempools *mempools;
	struct blk_keyslot_manager *ksm;
};

struct dm_stats_last_position;

struct dm_stats {
	struct mutex mutex;
	struct list_head list;
	struct dm_stats_last_position *last;
	sector_t last_sector;
	unsigned int last_rw;
};

struct dm_stats_aux {
	bool merged;
	long long unsigned int duration_ns;
};

struct dm_kobject_holder {
	struct kobject kobj;
	struct completion completion;
};

struct mapped_device___2 {
	struct mutex suspend_lock;
	struct mutex table_devices_lock;
	struct list_head table_devices;
	void *map;
	long unsigned int flags;
	struct mutex type_lock;
	enum dm_queue_mode type;
	int numa_node_id;
	struct request_queue *queue;
	atomic_t holders;
	atomic_t open_count;
	struct dm_target *immutable_target;
	struct target_type *immutable_target_type;
	char name[16];
	struct gendisk *disk;
	struct dax_device *dax_dev;
	struct work_struct work;
	wait_queue_head_t wait;
	spinlock_t deferred_lock;
	struct bio_list deferred;
	void *interface_ptr;
	wait_queue_head_t eventq;
	atomic_t event_nr;
	atomic_t uevent_seq;
	struct list_head uevent_list;
	spinlock_t uevent_lock;
	unsigned int internal_suspend_count;
	struct bio_set io_bs;
	struct bio_set bs;
	struct workqueue_struct *wq;
	struct hd_geometry geometry;
	struct dm_kobject_holder kobj_holder;
	int swap_bios;
	struct semaphore swap_bios_semaphore;
	struct mutex swap_bios_lock;
	struct dm_stats stats;
	struct blk_mq_tag_set *tag_set;
	bool init_tio_pdu: 1;
	struct srcu_struct io_barrier;
};

struct dm_md_mempools {
	struct bio_set bs;
	struct bio_set io_bs;
};

struct dm_io;

struct clone_info {
	struct dm_table *map;
	struct bio *bio;
	struct dm_io *io;
	sector_t sector;
	unsigned int sector_count;
};

struct dm_target_io {
	unsigned int magic;
	struct dm_io *io;
	struct dm_target *ti;
	unsigned int target_bio_nr;
	unsigned int *len_ptr;
	bool inside_dm_io;
	struct bio clone;
};

struct dm_io {
	unsigned int magic;
	struct mapped_device___2 *md;
	blk_status_t status;
	atomic_t io_count;
	struct bio *orig_bio;
	long unsigned int start_time;
	spinlock_t endio_lock;
	struct dm_stats_aux stats_aux;
	struct dm_target_io tio;
};

struct table_device {
	struct list_head list;
	refcount_t count;
	struct dm_dev dm_dev;
};

struct dm_pr {
	u64 old_key;
	u64 new_key;
	u32 flags;
	bool fail_early;
};

struct dm_arg_set {
	unsigned int argc;
	char **argv;
};

struct dm_arg {
	unsigned int min;
	unsigned int max;
	char *error;
};

struct dm_dev_internal {
	struct list_head list;
	refcount_t count;
	struct dm_dev *dm_dev;
};

struct dm_keyslot_manager {
	struct blk_keyslot_manager ksm;
	struct mapped_device___2 *md;
};

struct dm_keyslot_evict_args {
	const struct blk_crypto_key *key;
	int err;
};

enum suspend_mode {
	PRESUSPEND = 0,
	PRESUSPEND_UNDO = 1,
	POSTSUSPEND = 2,
};

struct linear_c {
	struct dm_dev *dev;
	sector_t start;
};

struct stripe {
	struct dm_dev *dev;
	sector_t physical_start;
	atomic_t error_count;
};

struct stripe_c {
	uint32_t stripes;
	int stripes_shift;
	sector_t stripe_width;
	uint32_t chunk_size;
	int chunk_size_shift;
	struct dm_target *ti;
	struct work_struct trigger_event;
	struct stripe stripe[0];
};

struct dm_target_deps {
	__u32 count;
	__u32 padding;
	__u64 dev[0];
};

struct dm_name_list {
	__u64 dev;
	__u32 next;
	char name[0];
};

struct dm_target_versions {
	__u32 next;
	__u32 version[3];
	char name[0];
};

struct dm_target_msg {
	__u64 sector;
	char message[0];
};

enum {
	DM_VERSION_CMD = 0,
	DM_REMOVE_ALL_CMD = 1,
	DM_LIST_DEVICES_CMD = 2,
	DM_DEV_CREATE_CMD = 3,
	DM_DEV_REMOVE_CMD = 4,
	DM_DEV_RENAME_CMD = 5,
	DM_DEV_SUSPEND_CMD = 6,
	DM_DEV_STATUS_CMD = 7,
	DM_DEV_WAIT_CMD = 8,
	DM_TABLE_LOAD_CMD = 9,
	DM_TABLE_CLEAR_CMD = 10,
	DM_TABLE_DEPS_CMD = 11,
	DM_TABLE_STATUS_CMD = 12,
	DM_LIST_VERSIONS_CMD = 13,
	DM_TARGET_MSG_CMD = 14,
	DM_DEV_SET_GEOMETRY_CMD = 15,
	DM_DEV_ARM_POLL_CMD = 16,
	DM_GET_TARGET_VERSION_CMD = 17,
};

struct dm_file {
	volatile unsigned int global_event_nr;
};

struct hash_cell {
	struct rb_node name_node;
	struct rb_node uuid_node;
	bool name_set;
	bool uuid_set;
	char *name;
	char *uuid;
	struct mapped_device___2 *md;
	struct dm_table *new_map;
};

struct vers_iter {
	size_t param_size;
	struct dm_target_versions *vers;
	struct dm_target_versions *old_vers;
	char *end;
	uint32_t flags;
};

typedef int (*ioctl_fn)(struct file *, struct dm_ioctl *, size_t);

struct dm_io_region {
	struct block_device *bdev;
	sector_t sector;
	sector_t count;
};

struct page_list {
	struct page_list *next;
	struct page *page;
};

typedef void (*io_notify_fn)(long unsigned int, void *);

enum dm_io_mem_type {
	DM_IO_PAGE_LIST = 0,
	DM_IO_BIO = 1,
	DM_IO_VMA = 2,
	DM_IO_KMEM = 3,
};

struct dm_io_memory {
	enum dm_io_mem_type type;
	unsigned int offset;
	union {
		struct page_list *pl;
		struct bio *bio;
		void *vma;
		void *addr;
	} ptr;
};

struct dm_io_notify {
	io_notify_fn fn;
	void *context;
};

struct dm_io_client;

struct dm_io_request {
	int bi_op;
	int bi_op_flags;
	struct dm_io_memory mem;
	struct dm_io_notify notify;
	struct dm_io_client *client;
};

struct dm_io_client {
	mempool_t pool;
	struct bio_set bios;
};

struct io {
	long unsigned int error_bits;
	atomic_t count;
	struct dm_io_client *client;
	io_notify_fn callback;
	void *context;
	void *vma_invalidate_address;
	long unsigned int vma_invalidate_size;
	long: 64;
};

struct dpages {
	void (*get_page)(struct dpages *, struct page **, long unsigned int *, unsigned int *);
	void (*next_page)(struct dpages *);
	union {
		unsigned int context_u;
		struct bvec_iter context_bi;
	};
	void *context_ptr;
	void *vma_invalidate_address;
	long unsigned int vma_invalidate_size;
};

struct sync_io {
	long unsigned int error_bits;
	struct completion wait;
};

struct dm_kcopyd_throttle {
	unsigned int throttle;
	unsigned int num_io_jobs;
	unsigned int io_period;
	unsigned int total_period;
	unsigned int last_jiffies;
};

typedef void (*dm_kcopyd_notify_fn)(int, long unsigned int, void *);

struct dm_kcopyd_client {
	struct page_list *pages;
	unsigned int nr_reserved_pages;
	unsigned int nr_free_pages;
	unsigned int sub_job_size;
	struct dm_io_client *io_client;
	wait_queue_head_t destroyq;
	mempool_t job_pool;
	struct workqueue_struct *kcopyd_wq;
	struct work_struct kcopyd_work;
	struct dm_kcopyd_throttle *throttle;
	atomic_t nr_jobs;
	spinlock_t job_lock;
	struct list_head callback_jobs;
	struct list_head complete_jobs;
	struct list_head io_jobs;
	struct list_head pages_jobs;
};

struct kcopyd_job {
	struct dm_kcopyd_client *kc;
	struct list_head list;
	long unsigned int flags;
	int read_err;
	long unsigned int write_err;
	int rw;
	struct dm_io_region source;
	unsigned int num_dests;
	struct dm_io_region dests[8];
	struct page_list *pages;
	dm_kcopyd_notify_fn fn;
	void *context;
	struct mutex lock;
	atomic_t sub_jobs;
	sector_t progress;
	sector_t write_offset;
	struct kcopyd_job *master_job;
};

struct dm_sysfs_attr {
	struct attribute attr;
	ssize_t (*show)(struct mapped_device___2 *, char *);
	ssize_t (*store)(struct mapped_device___2 *, const char *, size_t);
};

struct dm_stats_last_position {
	sector_t last_sector;
	unsigned int last_rw;
};

struct dm_stat_percpu {
	long long unsigned int sectors[2];
	long long unsigned int ios[2];
	long long unsigned int merges[2];
	long long unsigned int ticks[2];
	long long unsigned int io_ticks[2];
	long long unsigned int io_ticks_total;
	long long unsigned int time_in_queue;
	long long unsigned int *histogram;
};

struct dm_stat_shared {
	atomic_t in_flight[2];
	long long unsigned int stamp;
	struct dm_stat_percpu tmp;
};

struct dm_stat {
	struct list_head list_entry;
	int id;
	unsigned int stat_flags;
	size_t n_entries;
	sector_t start;
	sector_t end;
	sector_t step;
	unsigned int n_histogram_entries;
	long long unsigned int *histogram_boundaries;
	const char *program_id;
	const char *aux_data;
	struct callback_head callback_head;
	size_t shared_alloc_size;
	size_t percpu_alloc_size;
	size_t histogram_alloc_size;
	struct dm_stat_percpu *stat_percpu[256];
	struct dm_stat_shared stat_shared[0];
};

struct dm_rq_target_io;

struct dm_rq_clone_bio_info {
	struct bio *orig;
	struct dm_rq_target_io *tio;
	struct bio clone;
};

struct dm_rq_target_io {
	struct mapped_device___2 *md;
	struct dm_target *ti;
	struct request *orig;
	struct request *clone;
	struct kthread_work work;
	blk_status_t error;
	union map_info___2 info;
	struct dm_stats_aux stats_aux;
	long unsigned int duration_jiffies;
	unsigned int n_sectors;
	unsigned int completed;
};

enum dev_type {
	DEV_UNKNOWN = 0,
	DEV_X1 = 1,
	DEV_X2 = 2,
	DEV_X4 = 3,
	DEV_X8 = 4,
	DEV_X16 = 5,
	DEV_X32 = 6,
	DEV_X64 = 7,
};

enum hw_event_mc_err_type {
	HW_EVENT_ERR_CORRECTED = 0,
	HW_EVENT_ERR_UNCORRECTED = 1,
	HW_EVENT_ERR_DEFERRED = 2,
	HW_EVENT_ERR_FATAL = 3,
	HW_EVENT_ERR_INFO = 4,
};

enum mem_type {
	MEM_EMPTY = 0,
	MEM_RESERVED = 1,
	MEM_UNKNOWN = 2,
	MEM_FPM = 3,
	MEM_EDO = 4,
	MEM_BEDO = 5,
	MEM_SDR = 6,
	MEM_RDR = 7,
	MEM_DDR = 8,
	MEM_RDDR = 9,
	MEM_RMBS = 10,
	MEM_DDR2 = 11,
	MEM_FB_DDR2 = 12,
	MEM_RDDR2 = 13,
	MEM_XDR = 14,
	MEM_DDR3 = 15,
	MEM_RDDR3 = 16,
	MEM_LRDDR3 = 17,
	MEM_LPDDR3 = 18,
	MEM_DDR4 = 19,
	MEM_RDDR4 = 20,
	MEM_LRDDR4 = 21,
	MEM_LPDDR4 = 22,
	MEM_DDR5 = 23,
	MEM_NVDIMM = 24,
	MEM_WIO2 = 25,
};

enum edac_type {
	EDAC_UNKNOWN = 0,
	EDAC_NONE = 1,
	EDAC_RESERVED = 2,
	EDAC_PARITY = 3,
	EDAC_EC = 4,
	EDAC_SECDED = 5,
	EDAC_S2ECD2ED = 6,
	EDAC_S4ECD4ED = 7,
	EDAC_S8ECD8ED = 8,
	EDAC_S16ECD16ED = 9,
};

enum scrub_type {
	SCRUB_UNKNOWN = 0,
	SCRUB_NONE = 1,
	SCRUB_SW_PROG = 2,
	SCRUB_SW_SRC = 3,
	SCRUB_SW_PROG_SRC = 4,
	SCRUB_SW_TUNABLE = 5,
	SCRUB_HW_PROG = 6,
	SCRUB_HW_SRC = 7,
	SCRUB_HW_PROG_SRC = 8,
	SCRUB_HW_TUNABLE = 9,
};

enum edac_mc_layer_type {
	EDAC_MC_LAYER_BRANCH = 0,
	EDAC_MC_LAYER_CHANNEL = 1,
	EDAC_MC_LAYER_SLOT = 2,
	EDAC_MC_LAYER_CHIP_SELECT = 3,
	EDAC_MC_LAYER_ALL_MEM = 4,
};

struct edac_mc_layer {
	enum edac_mc_layer_type type;
	unsigned int size;
	bool is_virt_csrow;
};

struct mem_ctl_info;

struct dimm_info {
	struct device dev;
	char label[32];
	unsigned int location[3];
	struct mem_ctl_info *mci;
	unsigned int idx;
	u32 grain;
	enum dev_type dtype;
	enum mem_type mtype;
	enum edac_type edac_mode;
	u32 nr_pages;
	unsigned int csrow;
	unsigned int cschannel;
	u16 smbios_handle;
	u32 ce_count;
	u32 ue_count;
};

struct mcidev_sysfs_attribute;

struct edac_raw_error_desc {
	char location[256];
	char label[296];
	long int grain;
	u16 error_count;
	enum hw_event_mc_err_type type;
	int top_layer;
	int mid_layer;
	int low_layer;
	long unsigned int page_frame_number;
	long unsigned int offset_in_page;
	long unsigned int syndrome;
	const char *msg;
	const char *other_detail;
};

struct csrow_info;

struct mem_ctl_info {
	struct device dev;
	struct bus_type *bus;
	struct list_head link;
	struct module *owner;
	long unsigned int mtype_cap;
	long unsigned int edac_ctl_cap;
	long unsigned int edac_cap;
	long unsigned int scrub_cap;
	enum scrub_type scrub_mode;
	int (*set_sdram_scrub_rate)(struct mem_ctl_info *, u32);
	int (*get_sdram_scrub_rate)(struct mem_ctl_info *);
	void (*edac_check)(struct mem_ctl_info *);
	long unsigned int (*ctl_page_to_phys)(struct mem_ctl_info *, long unsigned int);
	int mc_idx;
	struct csrow_info **csrows;
	unsigned int nr_csrows;
	unsigned int num_cschannel;
	unsigned int n_layers;
	struct edac_mc_layer *layers;
	bool csbased;
	unsigned int tot_dimms;
	struct dimm_info **dimms;
	struct device *pdev;
	const char *mod_name;
	const char *ctl_name;
	const char *dev_name;
	void *pvt_info;
	long unsigned int start_time;
	u32 ce_noinfo_count;
	u32 ue_noinfo_count;
	u32 ue_mc;
	u32 ce_mc;
	struct completion complete;
	const struct mcidev_sysfs_attribute *mc_driver_sysfs_attributes;
	struct delayed_work work;
	struct edac_raw_error_desc error_desc;
	int op_state;
	struct dentry *debugfs;
	u8 fake_inject_layer[3];
	bool fake_inject_ue;
	u16 fake_inject_count;
};

struct rank_info {
	int chan_idx;
	struct csrow_info *csrow;
	struct dimm_info *dimm;
	u32 ce_count;
};

struct csrow_info {
	struct device dev;
	long unsigned int first_page;
	long unsigned int last_page;
	long unsigned int page_mask;
	int csrow_idx;
	u32 ue_count;
	u32 ce_count;
	struct mem_ctl_info *mci;
	u32 nr_channels;
	struct rank_info **channels;
};

struct edac_device_counter {
	u32 ue_count;
	u32 ce_count;
};

struct edac_device_ctl_info;

struct edac_dev_sysfs_attribute {
	struct attribute attr;
	ssize_t (*show)(struct edac_device_ctl_info *, char *);
	ssize_t (*store)(struct edac_device_ctl_info *, const char *, size_t);
};

struct edac_device_instance;

struct edac_device_ctl_info {
	struct list_head link;
	struct module *owner;
	int dev_idx;
	int log_ue;
	int log_ce;
	int panic_on_ue;
	unsigned int poll_msec;
	long unsigned int delay;
	struct edac_dev_sysfs_attribute *sysfs_attributes;
	struct bus_type *edac_subsys;
	int op_state;
	struct delayed_work work;
	void (*edac_check)(struct edac_device_ctl_info *);
	struct device *dev;
	const char *mod_name;
	const char *ctl_name;
	const char *dev_name;
	void *pvt_info;
	long unsigned int start_time;
	struct completion removal_complete;
	char name[32];
	u32 nr_instances;
	struct edac_device_instance *instances;
	struct edac_device_counter counters;
	struct kobject kobj;
};

struct edac_device_block;

struct edac_dev_sysfs_block_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
	struct edac_device_block *block;
	unsigned int value;
};

struct edac_device_block {
	struct edac_device_instance *instance;
	char name[32];
	struct edac_device_counter counters;
	int nr_attribs;
	struct edac_dev_sysfs_block_attribute *block_attributes;
	struct kobject kobj;
};

struct edac_device_instance {
	struct edac_device_ctl_info *ctl;
	char name[35];
	struct edac_device_counter counters;
	u32 nr_blocks;
	struct edac_device_block *blocks;
	struct kobject kobj;
};

struct ctl_info_attribute {
	struct attribute attr;
	ssize_t (*show)(struct edac_device_ctl_info *, char *);
	ssize_t (*store)(struct edac_device_ctl_info *, const char *, size_t);
};

struct instance_attribute {
	struct attribute attr;
	ssize_t (*show)(struct edac_device_instance *, char *);
	ssize_t (*store)(struct edac_device_instance *, const char *, size_t);
};

struct edac_pci_counter {
	atomic_t pe_count;
	atomic_t npe_count;
};

struct edac_pci_ctl_info {
	struct list_head link;
	int pci_idx;
	struct bus_type *edac_subsys;
	int op_state;
	struct delayed_work work;
	void (*edac_check)(struct edac_pci_ctl_info *);
	struct device *dev;
	const char *mod_name;
	const char *ctl_name;
	const char *dev_name;
	void *pvt_info;
	long unsigned int start_time;
	struct completion complete;
	char name[32];
	struct edac_pci_counter counters;
	struct kobject kobj;
};

struct edac_pci_gen_data {
	int edac_idx;
};

struct instance_attribute___2 {
	struct attribute attr;
	ssize_t (*show)(struct edac_pci_ctl_info *, char *);
	ssize_t (*store)(struct edac_pci_ctl_info *, const char *, size_t);
};

struct edac_pci_dev_attribute {
	struct attribute attr;
	void *value;
	ssize_t (*show)(void *, char *);
	ssize_t (*store)(void *, const char *, size_t);
};

typedef void (*pci_parity_check_fn_t)(struct pci_dev *);

struct ghes_pvt {
	struct mem_ctl_info *mci;
	char other_detail[400];
	char msg[80];
};

struct ghes_hw_desc {
	int num_dimms;
	struct dimm_info *dimms;
};

struct memdev_dmi_entry {
	u8 type;
	u8 length;
	u16 handle;
	u16 phys_mem_array_handle;
	u16 mem_err_info_handle;
	u16 total_width;
	u16 data_width;
	u16 size;
	u8 form_factor;
	u8 device_set;
	u8 device_locator;
	u8 bank_locator;
	u8 memory_type;
	u16 type_detail;
	u16 speed;
	u8 manufacturer;
	u8 serial_number;
	u8 asset_tag;
	u8 part_number;
	u8 attributes;
	u32 extended_size;
	u16 conf_mem_clk_speed;
} __attribute__((packed));

enum opp_table_access {
	OPP_TABLE_ACCESS_UNKNOWN = 0,
	OPP_TABLE_ACCESS_EXCLUSIVE = 1,
	OPP_TABLE_ACCESS_SHARED = 2,
};

struct icc_path;

struct dev_pm_opp___2;

struct dev_pm_set_opp_data;

struct dev_pm_opp_supply;

struct opp_table___2 {
	struct list_head node;
	struct list_head lazy;
	struct blocking_notifier_head head;
	struct list_head dev_list;
	struct list_head opp_list;
	struct kref kref;
	struct mutex lock;
	struct device_node *np;
	long unsigned int clock_latency_ns_max;
	unsigned int voltage_tolerance_v1;
	unsigned int parsed_static_opps;
	enum opp_table_access shared_opp;
	long unsigned int current_rate;
	struct dev_pm_opp___2 *current_opp;
	struct dev_pm_opp___2 *suspend_opp;
	struct mutex genpd_virt_dev_lock;
	struct device **genpd_virt_devs;
	struct opp_table___2 **required_opp_tables;
	unsigned int required_opp_count;
	unsigned int *supported_hw;
	unsigned int supported_hw_count;
	const char *prop_name;
	struct clk *clk;
	struct regulator **regulators;
	int regulator_count;
	struct icc_path **paths;
	unsigned int path_count;
	bool enabled;
	bool genpd_performance_state;
	bool is_genpd;
	int (*set_opp)(struct dev_pm_set_opp_data *);
	struct dev_pm_opp_supply *sod_supplies;
	struct dev_pm_set_opp_data *set_opp_data;
	struct dentry *dentry;
	char dentry_name[255];
};

struct dev_pm_opp_icc_bw;

struct dev_pm_opp___2 {
	struct list_head node;
	struct kref kref;
	bool available;
	bool dynamic;
	bool turbo;
	bool suspend;
	bool removed;
	unsigned int pstate;
	long unsigned int rate;
	unsigned int level;
	struct dev_pm_opp_supply *supplies;
	struct dev_pm_opp_icc_bw *bandwidth;
	long unsigned int clock_latency_ns;
	struct dev_pm_opp___2 **required_opps;
	struct opp_table___2 *opp_table;
	struct device_node *np;
	struct dentry *dentry;
};

enum dev_pm_opp_event {
	OPP_EVENT_ADD = 0,
	OPP_EVENT_REMOVE = 1,
	OPP_EVENT_ENABLE = 2,
	OPP_EVENT_DISABLE = 3,
	OPP_EVENT_ADJUST_VOLTAGE = 4,
};

struct dev_pm_opp_supply {
	long unsigned int u_volt;
	long unsigned int u_volt_min;
	long unsigned int u_volt_max;
	long unsigned int u_amp;
};

struct dev_pm_opp_icc_bw {
	u32 avg;
	u32 peak;
};

struct dev_pm_opp_info {
	long unsigned int rate;
	struct dev_pm_opp_supply *supplies;
};

struct dev_pm_set_opp_data {
	struct dev_pm_opp_info old_opp;
	struct dev_pm_opp_info new_opp;
	struct regulator **regulators;
	unsigned int regulator_count;
	struct clk *clk;
	struct device *dev;
};

struct opp_device {
	struct list_head node;
	const struct device *dev;
	struct dentry *dentry;
};

struct cpufreq_policy_data {
	struct cpufreq_cpuinfo cpuinfo;
	struct cpufreq_frequency_table *freq_table;
	unsigned int cpu;
	unsigned int min;
	unsigned int max;
};

struct cpufreq_freqs {
	struct cpufreq_policy *policy;
	unsigned int old;
	unsigned int new;
	u8 flags;
};

struct cpufreq_driver {
	char name[16];
	u16 flags;
	void *driver_data;
	int (*init)(struct cpufreq_policy *);
	int (*verify)(struct cpufreq_policy_data *);
	int (*setpolicy)(struct cpufreq_policy *);
	int (*target)(struct cpufreq_policy *, unsigned int, unsigned int);
	int (*target_index)(struct cpufreq_policy *, unsigned int);
	unsigned int (*fast_switch)(struct cpufreq_policy *, unsigned int);
	void (*adjust_perf)(unsigned int, long unsigned int, long unsigned int, long unsigned int);
	unsigned int (*resolve_freq)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get)(unsigned int);
	void (*update_limits)(unsigned int);
	int (*bios_limit)(int, unsigned int *);
	int (*online)(struct cpufreq_policy *);
	int (*offline)(struct cpufreq_policy *);
	int (*exit)(struct cpufreq_policy *);
	void (*stop_cpu)(struct cpufreq_policy *);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
	void (*ready)(struct cpufreq_policy *);
	struct freq_attr **attr;
	bool boost_enabled;
	int (*set_boost)(struct cpufreq_policy *, int);
};

struct cpufreq_stats {
	unsigned int total_trans;
	long long unsigned int last_time;
	unsigned int max_state;
	unsigned int state_num;
	unsigned int last_index;
	u64 *time_in_state;
	unsigned int *freq_table;
	unsigned int *trans_table;
	unsigned int reset_pending;
	long long unsigned int reset_time;
};

enum {
	OD_NORMAL_SAMPLE = 0,
	OD_SUB_SAMPLE = 1,
};

struct dbs_data {
	struct gov_attr_set attr_set;
	void *tuners;
	unsigned int ignore_nice_load;
	unsigned int sampling_rate;
	unsigned int sampling_down_factor;
	unsigned int up_threshold;
	unsigned int io_is_busy;
};

struct policy_dbs_info {
	struct cpufreq_policy *policy;
	struct mutex update_mutex;
	u64 last_sample_time;
	s64 sample_delay_ns;
	atomic_t work_count;
	struct irq_work irq_work;
	struct work_struct work;
	struct dbs_data *dbs_data;
	struct list_head list;
	unsigned int rate_mult;
	unsigned int idle_periods;
	bool is_shared;
	bool work_in_progress;
};

struct dbs_governor {
	struct cpufreq_governor gov;
	struct kobj_type kobj_type;
	struct dbs_data *gdbs_data;
	unsigned int (*gov_dbs_update)(struct cpufreq_policy *);
	struct policy_dbs_info * (*alloc)();
	void (*free)(struct policy_dbs_info *);
	int (*init)(struct dbs_data *);
	void (*exit)(struct dbs_data *);
	void (*start)(struct cpufreq_policy *);
};

struct od_ops {
	unsigned int (*powersave_bias_target)(struct cpufreq_policy *, unsigned int, unsigned int);
};

struct od_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int freq_lo;
	unsigned int freq_lo_delay_us;
	unsigned int freq_hi_delay_us;
	unsigned int sample_type: 1;
};

struct od_dbs_tuners {
	unsigned int powersave_bias;
};

struct cs_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int down_skip;
	unsigned int requested_freq;
};

struct cs_dbs_tuners {
	unsigned int down_threshold;
	unsigned int freq_step;
};

struct cpu_dbs_info {
	u64 prev_cpu_idle;
	u64 prev_update_time;
	u64 prev_cpu_nice;
	unsigned int prev_load;
	struct update_util_data update_util;
	struct policy_dbs_info *policy_dbs;
};

struct cpufreq_dt_platform_data {
	bool have_governor_per_policy;
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
};

struct private_data {
	struct list_head node;
	cpumask_var_t cpus;
	struct device *cpu_dev;
	struct opp_table *opp_table;
	struct cpufreq_frequency_table *freq_table;
	bool have_static_opps;
};

struct cpuidle_governor {
	char name[16];
	struct list_head governor_list;
	unsigned int rating;
	int (*enable)(struct cpuidle_driver___2 *, struct cpuidle_device *);
	void (*disable)(struct cpuidle_driver___2 *, struct cpuidle_device *);
	int (*select)(struct cpuidle_driver___2 *, struct cpuidle_device *, bool *);
	void (*reflect)(struct cpuidle_device *, int);
};

struct cpuidle_state_kobj {
	struct cpuidle_state *state;
	struct cpuidle_state_usage *state_usage;
	struct completion kobj_unregister;
	struct kobject kobj;
	struct cpuidle_device *device;
};

struct cpuidle_driver_kobj {
	struct cpuidle_driver___2 *drv;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_device_kobj {
	struct cpuidle_device *dev;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_device *, char *);
	ssize_t (*store)(struct cpuidle_device *, const char *, size_t);
};

struct cpuidle_state_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_state *, struct cpuidle_state_usage *, char *);
	ssize_t (*store)(struct cpuidle_state *, struct cpuidle_state_usage *, const char *, size_t);
};

struct cpuidle_driver_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_driver___2 *, char *);
	ssize_t (*store)(struct cpuidle_driver___2 *, const char *, size_t);
};

struct ladder_device_state {
	struct {
		u32 promotion_count;
		u32 demotion_count;
		u64 promotion_time_ns;
		u64 demotion_time_ns;
	} threshold;
	struct {
		int promotion_count;
		int demotion_count;
	} stats;
};

struct ladder_device {
	struct ladder_device_state states[10];
};

struct menu_device {
	int needs_update;
	int tick_wakeup;
	u64 next_timer_ns;
	unsigned int bucket;
	unsigned int correction_factor[12];
	unsigned int intervals[8];
	int interval_ptr;
};

struct teo_idle_state {
	unsigned int early_hits;
	unsigned int hits;
	unsigned int misses;
};

struct teo_cpu {
	s64 time_span_ns;
	s64 sleep_length_ns;
	struct teo_idle_state states[10];
	int interval_idx;
	u64 intervals[8];
};

struct psci_cpuidle_data {
	u32 *psci_states;
	struct device *dev;
};

struct psci_pd_provider {
	struct list_head link;
	struct device_node *node;
};

struct mmc_cid {
	unsigned int manfid;
	char prod_name[8];
	unsigned char prv;
	unsigned int serial;
	short unsigned int oemid;
	short unsigned int year;
	unsigned char hwrev;
	unsigned char fwrev;
	unsigned char month;
};

struct mmc_csd {
	unsigned char structure;
	unsigned char mmca_vsn;
	short unsigned int cmdclass;
	short unsigned int taac_clks;
	unsigned int taac_ns;
	unsigned int c_size;
	unsigned int r2w_factor;
	unsigned int max_dtr;
	unsigned int erase_size;
	unsigned int read_blkbits;
	unsigned int write_blkbits;
	unsigned int capacity;
	unsigned int read_partial: 1;
	unsigned int read_misalign: 1;
	unsigned int write_partial: 1;
	unsigned int write_misalign: 1;
	unsigned int dsr_imp: 1;
};

struct mmc_ext_csd {
	u8 rev;
	u8 erase_group_def;
	u8 sec_feature_support;
	u8 rel_sectors;
	u8 rel_param;
	bool enhanced_rpmb_supported;
	u8 part_config;
	u8 cache_ctrl;
	u8 rst_n_function;
	u8 max_packed_writes;
	u8 max_packed_reads;
	u8 packed_event_en;
	unsigned int part_time;
	unsigned int sa_timeout;
	unsigned int generic_cmd6_time;
	unsigned int power_off_longtime;
	u8 power_off_notification;
	unsigned int hs_max_dtr;
	unsigned int hs200_max_dtr;
	unsigned int sectors;
	unsigned int hc_erase_size;
	unsigned int hc_erase_timeout;
	unsigned int sec_trim_mult;
	unsigned int sec_erase_mult;
	unsigned int trim_timeout;
	bool partition_setting_completed;
	long long unsigned int enhanced_area_offset;
	unsigned int enhanced_area_size;
	unsigned int cache_size;
	bool hpi_en;
	bool hpi;
	unsigned int hpi_cmd;
	bool bkops;
	bool man_bkops_en;
	bool auto_bkops_en;
	unsigned int data_sector_size;
	unsigned int data_tag_unit_size;
	unsigned int boot_ro_lock;
	bool boot_ro_lockable;
	bool ffu_capable;
	bool cmdq_en;
	bool cmdq_support;
	unsigned int cmdq_depth;
	u8 fwrev[8];
	u8 raw_exception_status;
	u8 raw_partition_support;
	u8 raw_rpmb_size_mult;
	u8 raw_erased_mem_count;
	u8 strobe_support;
	u8 raw_ext_csd_structure;
	u8 raw_card_type;
	u8 raw_driver_strength;
	u8 out_of_int_time;
	u8 raw_pwr_cl_52_195;
	u8 raw_pwr_cl_26_195;
	u8 raw_pwr_cl_52_360;
	u8 raw_pwr_cl_26_360;
	u8 raw_s_a_timeout;
	u8 raw_hc_erase_gap_size;
	u8 raw_erase_timeout_mult;
	u8 raw_hc_erase_grp_size;
	u8 raw_sec_trim_mult;
	u8 raw_sec_erase_mult;
	u8 raw_sec_feature_support;
	u8 raw_trim_mult;
	u8 raw_pwr_cl_200_195;
	u8 raw_pwr_cl_200_360;
	u8 raw_pwr_cl_ddr_52_195;
	u8 raw_pwr_cl_ddr_52_360;
	u8 raw_pwr_cl_ddr_200_360;
	u8 raw_bkops_status;
	u8 raw_sectors[4];
	u8 pre_eol_info;
	u8 device_life_time_est_typ_a;
	u8 device_life_time_est_typ_b;
	unsigned int feature_support;
};

struct sd_scr {
	unsigned char sda_vsn;
	unsigned char sda_spec3;
	unsigned char sda_spec4;
	unsigned char sda_specx;
	unsigned char bus_widths;
	unsigned char cmds;
};

struct sd_ssr {
	unsigned int au;
	unsigned int erase_timeout;
	unsigned int erase_offset;
};

struct sd_switch_caps {
	unsigned int hs_max_dtr;
	unsigned int uhs_max_dtr;
	unsigned int sd3_bus_mode;
	unsigned int sd3_drv_type;
	unsigned int sd3_curr_limit;
};

struct sdio_cccr {
	unsigned int sdio_vsn;
	unsigned int sd_vsn;
	unsigned int multi_block: 1;
	unsigned int low_speed: 1;
	unsigned int wide_bus: 1;
	unsigned int high_power: 1;
	unsigned int high_speed: 1;
	unsigned int disable_cd: 1;
};

struct sdio_cis {
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int blksize;
	unsigned int max_dtr;
};

struct mmc_part {
	u64 size;
	unsigned int part_cfg;
	char name[20];
	bool force_ro;
	unsigned int area_type;
};

struct mmc_host;

struct sdio_func;

struct sdio_func_tuple;

struct mmc_card {
	struct mmc_host *host;
	struct device dev;
	u32 ocr;
	unsigned int rca;
	unsigned int type;
	unsigned int state;
	unsigned int quirks;
	unsigned int quirk_max_rate;
	bool reenable_cmdq;
	unsigned int erase_size;
	unsigned int erase_shift;
	unsigned int pref_erase;
	unsigned int eg_boundary;
	unsigned int erase_arg;
	u8 erased_byte;
	u32 raw_cid[4];
	u32 raw_csd[4];
	u32 raw_scr[2];
	u32 raw_ssr[16];
	struct mmc_cid cid;
	struct mmc_csd csd;
	struct mmc_ext_csd ext_csd;
	struct sd_scr scr;
	struct sd_ssr ssr;
	struct sd_switch_caps sw_caps;
	unsigned int sdio_funcs;
	atomic_t sdio_funcs_probed;
	struct sdio_cccr cccr;
	struct sdio_cis cis;
	struct sdio_func *sdio_func[7];
	struct sdio_func *sdio_single_irq;
	u8 major_rev;
	u8 minor_rev;
	unsigned int num_info;
	const char **info;
	struct sdio_func_tuple *tuples;
	unsigned int sd_bus_speed;
	unsigned int mmc_avail_type;
	unsigned int drive_strength;
	struct dentry *debugfs_root;
	struct mmc_part part[7];
	unsigned int nr_parts;
	struct workqueue_struct *complete_wq;
};

typedef unsigned int mmc_pm_flag_t;

struct mmc_ios {
	unsigned int clock;
	short unsigned int vdd;
	unsigned int power_delay_ms;
	unsigned char bus_mode;
	unsigned char chip_select;
	unsigned char power_mode;
	unsigned char bus_width;
	unsigned char timing;
	unsigned char signal_voltage;
	unsigned char drv_type;
	bool enhanced_strobe;
};

struct mmc_ctx {
	struct task_struct *task;
};

struct mmc_slot {
	int cd_irq;
	bool cd_wake_enabled;
	void *handler_priv;
};

struct mmc_supply {
	struct regulator *vmmc;
	struct regulator *vqmmc;
};

struct mmc_host_ops;

struct mmc_pwrseq;

struct mmc_bus_ops;

struct mmc_request;

struct mmc_cqe_ops;

struct mmc_host {
	struct device *parent;
	struct device class_dev;
	int index;
	const struct mmc_host_ops *ops;
	struct mmc_pwrseq *pwrseq;
	unsigned int f_min;
	unsigned int f_max;
	unsigned int f_init;
	u32 ocr_avail;
	u32 ocr_avail_sdio;
	u32 ocr_avail_sd;
	u32 ocr_avail_mmc;
	struct wakeup_source *ws;
	u32 max_current_330;
	u32 max_current_300;
	u32 max_current_180;
	u32 caps;
	u32 caps2;
	int fixed_drv_type;
	mmc_pm_flag_t pm_caps;
	unsigned int max_seg_size;
	short unsigned int max_segs;
	short unsigned int unused;
	unsigned int max_req_size;
	unsigned int max_blk_size;
	unsigned int max_blk_count;
	unsigned int max_busy_timeout;
	spinlock_t lock;
	struct mmc_ios ios;
	unsigned int use_spi_crc: 1;
	unsigned int claimed: 1;
	unsigned int doing_init_tune: 1;
	unsigned int can_retune: 1;
	unsigned int doing_retune: 1;
	unsigned int retune_now: 1;
	unsigned int retune_paused: 1;
	unsigned int retune_crc_disable: 1;
	unsigned int can_dma_map_merge: 1;
	int rescan_disable;
	int rescan_entered;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct timer_list retune_timer;
	bool trigger_card_event;
	struct mmc_card *card;
	wait_queue_head_t wq;
	struct mmc_ctx *claimer;
	int claim_cnt;
	struct mmc_ctx default_ctx;
	struct delayed_work detect;
	int detect_change;
	struct mmc_slot slot;
	const struct mmc_bus_ops *bus_ops;
	unsigned int sdio_irqs;
	struct task_struct *sdio_irq_thread;
	struct delayed_work sdio_irq_work;
	bool sdio_irq_pending;
	atomic_t sdio_irq_thread_abort;
	mmc_pm_flag_t pm_flags;
	struct led_trigger *led;
	bool regulator_enabled;
	struct mmc_supply supply;
	struct dentry *debugfs_root;
	struct mmc_request *ongoing_mrq;
	unsigned int actual_clock;
	unsigned int slotno;
	int dsr_req;
	u32 dsr;
	const struct mmc_cqe_ops *cqe_ops;
	void *cqe_private;
	int cqe_qdepth;
	bool cqe_enabled;
	bool cqe_on;
	struct blk_keyslot_manager ksm;
	bool hsq_enabled;
	long unsigned int private[0];
};

struct mmc_data;

struct mmc_command {
	u32 opcode;
	u32 arg;
	u32 resp[4];
	unsigned int flags;
	unsigned int retries;
	int error;
	unsigned int busy_timeout;
	struct mmc_data *data;
	struct mmc_request *mrq;
};

struct mmc_data {
	unsigned int timeout_ns;
	unsigned int timeout_clks;
	unsigned int blksz;
	unsigned int blocks;
	unsigned int blk_addr;
	int error;
	unsigned int flags;
	unsigned int bytes_xfered;
	struct mmc_command *stop;
	struct mmc_request *mrq;
	unsigned int sg_len;
	int sg_count;
	struct scatterlist *sg;
	s32 host_cookie;
};

struct mmc_request {
	struct mmc_command *sbc;
	struct mmc_command *cmd;
	struct mmc_data *data;
	struct mmc_command *stop;
	struct completion completion;
	struct completion cmd_completion;
	void (*done)(struct mmc_request *);
	void (*recovery_notifier)(struct mmc_request *);
	struct mmc_host *host;
	bool cap_cmd_during_tfr;
	int tag;
	bool crypto_enabled;
	int crypto_key_slot;
	u32 data_unit_num;
};

struct mmc_host_ops {
	void (*post_req)(struct mmc_host *, struct mmc_request *, int);
	void (*pre_req)(struct mmc_host *, struct mmc_request *);
	void (*request)(struct mmc_host *, struct mmc_request *);
	int (*request_atomic)(struct mmc_host *, struct mmc_request *);
	void (*set_ios)(struct mmc_host *, struct mmc_ios *);
	int (*get_ro)(struct mmc_host *);
	int (*get_cd)(struct mmc_host *);
	void (*enable_sdio_irq)(struct mmc_host *, int);
	void (*ack_sdio_irq)(struct mmc_host *);
	void (*init_card)(struct mmc_host *, struct mmc_card *);
	int (*start_signal_voltage_switch)(struct mmc_host *, struct mmc_ios *);
	int (*card_busy)(struct mmc_host *);
	int (*execute_tuning)(struct mmc_host *, u32);
	int (*prepare_hs400_tuning)(struct mmc_host *, struct mmc_ios *);
	int (*hs400_prepare_ddr)(struct mmc_host *);
	void (*hs400_downgrade)(struct mmc_host *);
	void (*hs400_complete)(struct mmc_host *);
	void (*hs400_enhanced_strobe)(struct mmc_host *, struct mmc_ios *);
	int (*select_drive_strength)(struct mmc_card *, unsigned int, int, int, int *);
	void (*hw_reset)(struct mmc_host *);
	void (*card_event)(struct mmc_host *);
	int (*multi_io_quirk)(struct mmc_card *, unsigned int, int);
	int (*init_sd_express)(struct mmc_host *, struct mmc_ios *);
};

struct mmc_cqe_ops {
	int (*cqe_enable)(struct mmc_host *, struct mmc_card *);
	void (*cqe_disable)(struct mmc_host *);
	int (*cqe_request)(struct mmc_host *, struct mmc_request *);
	void (*cqe_post_req)(struct mmc_host *, struct mmc_request *);
	void (*cqe_off)(struct mmc_host *);
	int (*cqe_wait_for_idle)(struct mmc_host *);
	bool (*cqe_timeout)(struct mmc_host *, struct mmc_request *, bool *);
	void (*cqe_recovery_start)(struct mmc_host *);
	void (*cqe_recovery_finish)(struct mmc_host *);
};

struct mmc_pwrseq_ops;

struct mmc_pwrseq {
	const struct mmc_pwrseq_ops *ops;
	struct device *dev;
	struct list_head pwrseq_node;
	struct module *owner;
};

struct mmc_bus_ops {
	void (*remove)(struct mmc_host *);
	void (*detect)(struct mmc_host *);
	int (*pre_suspend)(struct mmc_host *);
	int (*suspend)(struct mmc_host *);
	int (*resume)(struct mmc_host *);
	int (*runtime_suspend)(struct mmc_host *);
	int (*runtime_resume)(struct mmc_host *);
	int (*alive)(struct mmc_host *);
	int (*shutdown)(struct mmc_host *);
	int (*hw_reset)(struct mmc_host *);
	int (*sw_reset)(struct mmc_host *);
	bool (*cache_enabled)(struct mmc_host *);
};

struct trace_event_raw_mmc_request_start {
	struct trace_entry ent;
	u32 cmd_opcode;
	u32 cmd_arg;
	unsigned int cmd_flags;
	unsigned int cmd_retries;
	u32 stop_opcode;
	u32 stop_arg;
	unsigned int stop_flags;
	unsigned int stop_retries;
	u32 sbc_opcode;
	u32 sbc_arg;
	unsigned int sbc_flags;
	unsigned int sbc_retries;
	unsigned int blocks;
	unsigned int blk_addr;
	unsigned int blksz;
	unsigned int data_flags;
	int tag;
	unsigned int can_retune;
	unsigned int doing_retune;
	unsigned int retune_now;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct mmc_request *mrq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_mmc_request_done {
	struct trace_entry ent;
	u32 cmd_opcode;
	int cmd_err;
	u32 cmd_resp[4];
	unsigned int cmd_retries;
	u32 stop_opcode;
	int stop_err;
	u32 stop_resp[4];
	unsigned int stop_retries;
	u32 sbc_opcode;
	int sbc_err;
	u32 sbc_resp[4];
	unsigned int sbc_retries;
	unsigned int bytes_xfered;
	int data_err;
	int tag;
	unsigned int can_retune;
	unsigned int doing_retune;
	unsigned int retune_now;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct mmc_request *mrq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_mmc_request_start {
	u32 name;
};

struct trace_event_data_offsets_mmc_request_done {
	u32 name;
};

typedef void (*btf_trace_mmc_request_start)(void *, struct mmc_host *, struct mmc_request *);

typedef void (*btf_trace_mmc_request_done)(void *, struct mmc_host *, struct mmc_request *);

struct mmc_pwrseq_ops {
	void (*pre_power_on)(struct mmc_host *);
	void (*post_power_on)(struct mmc_host *);
	void (*power_off)(struct mmc_host *);
	void (*reset)(struct mmc_host *);
};

enum mmc_busy_cmd {
	MMC_BUSY_CMD6 = 0,
	MMC_BUSY_ERASE = 1,
	MMC_BUSY_HPI = 2,
};

struct mmc_driver {
	struct device_driver drv;
	int (*probe)(struct mmc_card *);
	void (*remove)(struct mmc_card *);
	void (*shutdown)(struct mmc_card *);
};

struct mmc_clk_phase {
	bool valid;
	u16 in_deg;
	u16 out_deg;
};

struct mmc_clk_phase_map {
	struct mmc_clk_phase phase[11];
};

struct mmc_fixup {
	const char *name;
	u64 rev_start;
	u64 rev_end;
	unsigned int manfid;
	short unsigned int oemid;
	u16 cis_vendor;
	u16 cis_device;
	unsigned int ext_csd_rev;
	void (*vendor_fixup)(struct mmc_card *, int);
	int data;
};

typedef void sdio_irq_handler_t(struct sdio_func *);

struct sdio_func {
	struct mmc_card *card;
	struct device dev;
	sdio_irq_handler_t *irq_handler;
	unsigned int num;
	unsigned char class;
	short unsigned int vendor;
	short unsigned int device;
	unsigned int max_blksize;
	unsigned int cur_blksize;
	unsigned int enable_timeout;
	unsigned int state;
	u8 *tmpbuf;
	u8 major_rev;
	u8 minor_rev;
	unsigned int num_info;
	const char **info;
	struct sdio_func_tuple *tuples;
};

struct sdio_func_tuple {
	struct sdio_func_tuple *next;
	unsigned char code;
	unsigned char size;
	unsigned char data[0];
};

struct sdio_device_id {
	__u8 class;
	__u16 vendor;
	__u16 device;
	kernel_ulong_t driver_data;
};

struct sdio_driver {
	char *name;
	const struct sdio_device_id *id_table;
	int (*probe)(struct sdio_func *, const struct sdio_device_id *);
	void (*remove)(struct sdio_func *);
	struct device_driver drv;
};

typedef int tpl_parse_t(struct mmc_card *, struct sdio_func *, const unsigned char *, unsigned int);

struct cis_tpl {
	unsigned char code;
	unsigned char min_size;
	tpl_parse_t *parse;
};

struct mmc_gpio {
	struct gpio_desc *ro_gpio;
	struct gpio_desc *cd_gpio;
	irqreturn_t (*cd_gpio_isr)(int, void *);
	char *ro_label;
	char *cd_label;
	u32 cd_debounce_delay_ms;
};

enum mmc_issue_type {
	MMC_ISSUE_SYNC = 0,
	MMC_ISSUE_DCMD = 1,
	MMC_ISSUE_ASYNC = 2,
	MMC_ISSUE_MAX = 3,
};

struct mmc_blk_request {
	struct mmc_request mrq;
	struct mmc_command sbc;
	struct mmc_command cmd;
	struct mmc_command stop;
	struct mmc_data data;
};

enum mmc_drv_op {
	MMC_DRV_OP_IOCTL = 0,
	MMC_DRV_OP_IOCTL_RPMB = 1,
	MMC_DRV_OP_BOOT_WP = 2,
	MMC_DRV_OP_GET_CARD_STATUS = 3,
	MMC_DRV_OP_GET_EXT_CSD = 4,
};

struct mmc_queue_req {
	struct mmc_blk_request brq;
	struct scatterlist *sg;
	enum mmc_drv_op drv_op;
	int drv_op_result;
	void *drv_op_data;
	unsigned int ioc_count;
	int retries;
};

struct mmc_ioc_cmd {
	int write_flag;
	int is_acmd;
	__u32 opcode;
	__u32 arg;
	__u32 response[4];
	unsigned int flags;
	unsigned int blksz;
	unsigned int blocks;
	unsigned int postsleep_min_us;
	unsigned int postsleep_max_us;
	unsigned int data_timeout_ns;
	unsigned int cmd_timeout_ms;
	__u32 __pad;
	__u64 data_ptr;
};

struct mmc_ioc_multi_cmd {
	__u64 num_of_cmds;
	struct mmc_ioc_cmd cmds[0];
};

enum mmc_issued {
	MMC_REQ_STARTED = 0,
	MMC_REQ_BUSY = 1,
	MMC_REQ_FAILED_TO_START = 2,
	MMC_REQ_FINISHED = 3,
};

struct mmc_blk_data;

struct mmc_queue {
	struct mmc_card *card;
	struct mmc_ctx ctx;
	struct blk_mq_tag_set tag_set;
	struct mmc_blk_data *blkdata;
	struct request_queue *queue;
	spinlock_t lock;
	int in_flight[3];
	unsigned int cqe_busy;
	bool busy;
	bool recovery_needed;
	bool in_recovery;
	bool rw_wait;
	bool waiting;
	struct work_struct recovery_work;
	wait_queue_head_t wait;
	struct request *recovery_req;
	struct request *complete_req;
	struct mutex complete_lock;
	struct work_struct complete_work;
};

struct mmc_blk_data {
	struct device *parent;
	struct gendisk *disk;
	struct mmc_queue queue;
	struct list_head part;
	struct list_head rpmbs;
	unsigned int flags;
	unsigned int usage;
	unsigned int read_only;
	unsigned int part_type;
	unsigned int reset_done;
	unsigned int part_curr;
	struct device_attribute force_ro;
	struct device_attribute power_ro_lock;
	int area_type;
	struct dentry *status_dentry;
	struct dentry *ext_csd_dentry;
};

struct mmc_rpmb_data {
	struct device dev;
	struct cdev chrdev;
	int id;
	unsigned int part_index;
	struct mmc_blk_data *md;
	struct list_head node;
};

struct mmc_blk_ioc_data {
	struct mmc_ioc_cmd ic;
	unsigned char *buf;
	u64 buf_bytes;
	struct mmc_rpmb_data *rpmb;
};

struct mmci_platform_data {
	unsigned int ocr_mask;
	int (*ios_handler)(struct device *, struct mmc_ios *);
	unsigned int (*status)(struct device *);
};

struct mmci_host;

struct variant_data {
	unsigned int clkreg;
	unsigned int clkreg_enable;
	unsigned int clkreg_8bit_bus_enable;
	unsigned int clkreg_neg_edge_enable;
	unsigned int cmdreg_cpsm_enable;
	unsigned int cmdreg_lrsp_crc;
	unsigned int cmdreg_srsp_crc;
	unsigned int cmdreg_srsp;
	unsigned int cmdreg_stop;
	unsigned int datalength_bits;
	unsigned int fifosize;
	unsigned int fifohalfsize;
	unsigned int data_cmd_enable;
	unsigned int datactrl_mask_ddrmode;
	unsigned int datactrl_mask_sdio;
	unsigned int datactrl_blocksz;
	u8 datactrl_any_blocksz: 1;
	u8 dma_power_of_2: 1;
	u8 datactrl_first: 1;
	u8 datacnt_useless: 1;
	u8 st_sdio: 1;
	u8 st_clkdiv: 1;
	u8 stm32_clkdiv: 1;
	u32 pwrreg_powerup;
	u32 f_max;
	u8 signal_direction: 1;
	u8 pwrreg_clkgate: 1;
	u8 busy_detect: 1;
	u8 busy_timeout: 1;
	u32 busy_dpsm_flag;
	u32 busy_detect_flag;
	u32 busy_detect_mask;
	u8 pwrreg_nopower: 1;
	u8 explicit_mclk_control: 1;
	u8 qcom_fifo: 1;
	u8 qcom_dml: 1;
	u8 reversed_irq_handling: 1;
	u8 mmcimask1: 1;
	unsigned int irq_pio_mask;
	u32 start_err;
	u32 opendrain;
	u8 dma_lli: 1;
	u32 stm32_idmabsize_mask;
	void (*init)(struct mmci_host *);
};

struct mmci_host_ops;

struct mmci_host {
	phys_addr_t phybase;
	void *base;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	struct mmc_command stop_abort;
	struct mmc_data *data;
	struct mmc_host *mmc;
	struct clk *clk;
	u8 singleirq: 1;
	struct reset_control *rst;
	spinlock_t lock;
	unsigned int mclk;
	unsigned int clock_cache;
	unsigned int cclk;
	u32 pwr_reg;
	u32 pwr_reg_add;
	u32 clk_reg;
	u32 clk_reg_add;
	u32 datactrl_reg;
	u32 busy_status;
	u32 mask1_reg;
	u8 vqmmc_enabled: 1;
	struct mmci_platform_data *plat;
	struct mmc_host_ops *mmc_ops;
	struct mmci_host_ops *ops;
	struct variant_data *variant;
	void *variant_priv;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_opendrain;
	u8 hw_designer;
	u8 hw_revision: 4;
	struct timer_list timer;
	unsigned int oldstat;
	u32 irq_action;
	struct sg_mapping_iter sg_miter;
	unsigned int size;
	int (*get_rx_fifocnt)(struct mmci_host *, u32, int);
	u8 use_dma: 1;
	u8 dma_in_progress: 1;
	void *dma_priv;
	s32 next_cookie;
};

struct mmci_host_ops {
	int (*validate_data)(struct mmci_host *, struct mmc_data *);
	int (*prep_data)(struct mmci_host *, struct mmc_data *, bool);
	void (*unprep_data)(struct mmci_host *, struct mmc_data *, int);
	u32 (*get_datactrl_cfg)(struct mmci_host *);
	void (*get_next_data)(struct mmci_host *, struct mmc_data *);
	int (*dma_setup)(struct mmci_host *);
	void (*dma_release)(struct mmci_host *);
	int (*dma_start)(struct mmci_host *, unsigned int *);
	void (*dma_finalize)(struct mmci_host *, struct mmc_data *);
	void (*dma_error)(struct mmci_host *);
	void (*set_clkreg)(struct mmci_host *, unsigned int);
	void (*set_pwrreg)(struct mmci_host *, unsigned int);
	bool (*busy_complete)(struct mmci_host *, u32, u32);
	void (*pre_sig_volt_switch)(struct mmci_host *);
	int (*post_sig_volt_switch)(struct mmci_host *, struct mmc_ios *);
};

struct mmci_dmae_next {
	struct dma_async_tx_descriptor *desc;
	struct dma_chan *chan;
};

struct mmci_dmae_priv {
	struct dma_chan *cur;
	struct dma_chan *rx_channel;
	struct dma_chan *tx_channel;
	struct dma_async_tx_descriptor *desc_current;
	struct mmci_dmae_next next_data;
};

struct sdmmc_lli_desc {
	u32 idmalar;
	u32 idmabase;
	u32 idmasize;
};

struct sdmmc_idma {
	dma_addr_t sg_dma;
	void *sg_cpu;
};

struct sdmmc_dlyb {
	void *base;
	u32 unit;
	u32 max;
};

struct pci_dev___2;

struct sdhci_pci_data {
	struct pci_dev___2 *pdev;
	int slotno;
	int rst_n_gpio;
	int cd_gpio;
	int (*setup)(struct sdhci_pci_data *);
	void (*cleanup)(struct sdhci_pci_data *);
};

struct led_init_data {
	struct fwnode_handle *fwnode;
	const char *default_label;
	const char *devicename;
	bool devname_mandatory;
};

struct led_properties {
	u32 color;
	bool color_present;
	const char *function;
	u32 func_enum;
	bool func_enum_present;
	const char *label;
};

struct syscon_led {
	struct led_classdev cdev;
	struct regmap *map;
	u32 offset;
	u32 mask;
	bool state;
};

enum cpu_led_event {
	CPU_LED_IDLE_START = 0,
	CPU_LED_IDLE_END = 1,
	CPU_LED_START = 2,
	CPU_LED_STOP = 3,
	CPU_LED_HALTED = 4,
};

struct led_trigger_cpu {
	bool is_active;
	char name[8];
	struct led_trigger *_trig;
};

struct sdei_event {
	struct list_head list;
	bool reregister;
	bool reenable;
	u32 event_num;
	u8 type;
	u8 priority;
	union {
		struct sdei_registered_event *registered;
		struct sdei_registered_event *private_registered;
	};
};

struct sdei_crosscall_args {
	struct sdei_event *event;
	atomic_t errors;
	int first_error;
};

struct dmi_memdev_info {
	const char *device;
	const char *bank;
	u64 size;
	u16 handle;
	u8 type;
};

struct dmi_device_attribute {
	struct device_attribute dev_attr;
	int field;
};

struct mafield {
	const char *prefix;
	int field;
};

struct firmware_map_entry {
	u64 start;
	u64 end;
	const char *type;
	struct list_head list;
	struct kobject kobj;
};

struct memmap_attribute {
	struct attribute attr;
	ssize_t (*show)(struct firmware_map_entry *, char *);
};

enum rpi_firmware_property_status {
	RPI_FIRMWARE_STATUS_REQUEST = 0,
	RPI_FIRMWARE_STATUS_SUCCESS = 2147483648,
	RPI_FIRMWARE_STATUS_ERROR = 2147483649,
};

struct rpi_firmware_property_tag_header {
	u32 tag;
	u32 buf_size;
	u32 req_resp_size;
};

struct rpi_firmware___2 {
	struct mbox_client cl;
	struct mbox_chan___2 *chan;
	struct completion c;
	u32 enabled;
	struct kref consumers;
};

struct qcom_scm_hdcp_req {
	u32 addr;
	u32 val;
};

struct qcom_scm_vmperm {
	int vmid;
	int perm;
};

enum qcom_scm_ocmem_client {
	QCOM_SCM_OCMEM_UNUSED_ID = 0,
	QCOM_SCM_OCMEM_GRAPHICS_ID = 1,
	QCOM_SCM_OCMEM_VIDEO_ID = 2,
	QCOM_SCM_OCMEM_LP_AUDIO_ID = 3,
	QCOM_SCM_OCMEM_SENSORS_ID = 4,
	QCOM_SCM_OCMEM_OTHER_OS_ID = 5,
	QCOM_SCM_OCMEM_DEBUG_ID = 6,
};

enum qcom_scm_ice_cipher {
	QCOM_SCM_ICE_CIPHER_AES_128_XTS = 0,
	QCOM_SCM_ICE_CIPHER_AES_128_CBC = 1,
	QCOM_SCM_ICE_CIPHER_AES_256_XTS = 3,
	QCOM_SCM_ICE_CIPHER_AES_256_CBC = 4,
};

enum qcom_scm_convention {
	SMC_CONVENTION_UNKNOWN = 0,
	SMC_CONVENTION_LEGACY = 1,
	SMC_CONVENTION_ARM_32 = 2,
	SMC_CONVENTION_ARM_64 = 3,
};

enum qcom_scm_arg_types {
	QCOM_SCM_VAL = 0,
	QCOM_SCM_RO = 1,
	QCOM_SCM_RW = 2,
	QCOM_SCM_BUFVAL = 3,
};

struct qcom_scm_desc {
	u32 svc;
	u32 cmd;
	u32 arginfo;
	u64 args[10];
	u32 owner;
};

struct qcom_scm_res {
	u64 result[3];
};

struct qcom_scm {
	struct device *dev;
	struct clk *core_clk;
	struct clk *iface_clk;
	struct clk *bus_clk;
	struct reset_controller_dev reset;
	u64 dload_mode_addr;
};

struct qcom_scm_current_perm_info {
	__le32 vmid;
	__le32 perm;
	__le64 ctx;
	__le32 ctx_size;
	__le32 unused;
};

struct qcom_scm_mem_map_info {
	__le64 mem_addr;
	__le64 mem_size;
};

struct qcom_scm_wb_entry {
	int flag;
	void *entry;
};

struct arm_smccc_quirk {
	int id;
	union {
		long unsigned int a6;
	} state;
};

struct arm_smccc_args {
	long unsigned int args[8];
};

struct scm_legacy_command {
	__le32 len;
	__le32 buf_offset;
	__le32 resp_hdr_offset;
	__le32 id;
	__le32 buf[0];
};

struct scm_legacy_response {
	__le32 len;
	__le32 buf_offset;
	__le32 is_complete;
};

struct ti_msgmgr_message {
	size_t len;
	u8 *buf;
};

struct ti_sci_msg_hdr {
	u16 type;
	u8 host;
	u8 seq;
	u32 flags;
};

struct ti_sci_msg_resp_version {
	struct ti_sci_msg_hdr hdr;
	char firmware_description[32];
	u16 firmware_revision;
	u8 abi_major;
	u8 abi_minor;
};

struct ti_sci_msg_req_reboot {
	struct ti_sci_msg_hdr hdr;
};

struct ti_sci_msg_req_set_device_state {
	struct ti_sci_msg_hdr hdr;
	u32 id;
	u32 reserved;
	u8 state;
} __attribute__((packed));

struct ti_sci_msg_req_get_device_state {
	struct ti_sci_msg_hdr hdr;
	u32 id;
};

struct ti_sci_msg_resp_get_device_state {
	struct ti_sci_msg_hdr hdr;
	u32 context_loss_count;
	u32 resets;
	u8 programmed_state;
	u8 current_state;
} __attribute__((packed));

struct ti_sci_msg_req_set_device_resets {
	struct ti_sci_msg_hdr hdr;
	u32 id;
	u32 resets;
};

struct ti_sci_msg_req_set_clock_state {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u8 clk_id;
	u8 request_state;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_req_get_clock_state {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u8 clk_id;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_resp_get_clock_state {
	struct ti_sci_msg_hdr hdr;
	u8 programmed_state;
	u8 current_state;
} __attribute__((packed));

struct ti_sci_msg_req_set_clock_parent {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u8 clk_id;
	u8 parent_id;
	u32 clk_id_32;
	u32 parent_id_32;
} __attribute__((packed));

struct ti_sci_msg_req_get_clock_parent {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u8 clk_id;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_resp_get_clock_parent {
	struct ti_sci_msg_hdr hdr;
	u8 parent_id;
	u32 parent_id_32;
} __attribute__((packed));

struct ti_sci_msg_req_get_clock_num_parents {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u8 clk_id;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_resp_get_clock_num_parents {
	struct ti_sci_msg_hdr hdr;
	u8 num_parents;
	u32 num_parents_32;
} __attribute__((packed));

struct ti_sci_msg_req_query_clock_freq {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u64 min_freq_hz;
	u64 target_freq_hz;
	u64 max_freq_hz;
	u8 clk_id;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_resp_query_clock_freq {
	struct ti_sci_msg_hdr hdr;
	u64 freq_hz;
};

struct ti_sci_msg_req_set_clock_freq {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u64 min_freq_hz;
	u64 target_freq_hz;
	u64 max_freq_hz;
	u8 clk_id;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_req_get_clock_freq {
	struct ti_sci_msg_hdr hdr;
	u32 dev_id;
	u8 clk_id;
	u32 clk_id_32;
} __attribute__((packed));

struct ti_sci_msg_resp_get_clock_freq {
	struct ti_sci_msg_hdr hdr;
	u64 freq_hz;
};

struct ti_sci_msg_req_get_resource_range {
	struct ti_sci_msg_hdr hdr;
	u16 type;
	u8 subtype;
	u8 secondary_host;
};

struct ti_sci_msg_resp_get_resource_range {
	struct ti_sci_msg_hdr hdr;
	u16 range_start;
	u16 range_num;
	u16 range_start_sec;
	u16 range_num_sec;
};

struct ti_sci_msg_req_manage_irq {
	struct ti_sci_msg_hdr hdr;
	u32 valid_params;
	u16 src_id;
	u16 src_index;
	u16 dst_id;
	u16 dst_host_irq;
	u16 ia_id;
	u16 vint;
	u16 global_event;
	u8 vint_status_bit;
	u8 secondary_host;
};

struct ti_sci_msg_rm_ring_cfg_req {
	struct ti_sci_msg_hdr hdr;
	u32 valid_params;
	u16 nav_id;
	u16 index;
	u32 addr_lo;
	u32 addr_hi;
	u32 count;
	u8 mode;
	u8 size;
	u8 order_id;
	u16 virtid;
	u8 asel;
} __attribute__((packed));

struct ti_sci_msg_psil_pair {
	struct ti_sci_msg_hdr hdr;
	u32 nav_id;
	u32 src_thread;
	u32 dst_thread;
};

struct ti_sci_msg_psil_unpair {
	struct ti_sci_msg_hdr hdr;
	u32 nav_id;
	u32 src_thread;
	u32 dst_thread;
};

struct ti_sci_msg_rm_udmap_tx_ch_cfg_req {
	struct ti_sci_msg_hdr hdr;
	u32 valid_params;
	u16 nav_id;
	u16 index;
	u8 tx_pause_on_err;
	u8 tx_filt_einfo;
	u8 tx_filt_pswords;
	u8 tx_atype;
	u8 tx_chan_type;
	u8 tx_supr_tdpkt;
	u16 tx_fetch_size;
	u8 tx_credit_count;
	u16 txcq_qnum;
	u8 tx_priority;
	u8 tx_qos;
	u8 tx_orderid;
	u16 fdepth;
	u8 tx_sched_priority;
	u8 tx_burst_size;
	u8 tx_tdtype;
	u8 extended_ch_type;
} __attribute__((packed));

struct ti_sci_msg_rm_udmap_rx_ch_cfg_req {
	struct ti_sci_msg_hdr hdr;
	u32 valid_params;
	u16 nav_id;
	u16 index;
	u16 rx_fetch_size;
	u16 rxcq_qnum;
	u8 rx_priority;
	u8 rx_qos;
	u8 rx_orderid;
	u8 rx_sched_priority;
	u16 flowid_start;
	u16 flowid_cnt;
	u8 rx_pause_on_err;
	u8 rx_atype;
	u8 rx_chan_type;
	u8 rx_ignore_short;
	u8 rx_ignore_long;
	u8 rx_burst_size;
} __attribute__((packed));

struct ti_sci_msg_rm_udmap_flow_cfg_req {
	struct ti_sci_msg_hdr hdr;
	u32 valid_params;
	u16 nav_id;
	u16 flow_index;
	u8 rx_einfo_present;
	u8 rx_psinfo_present;
	u8 rx_error_handling;
	u8 rx_desc_type;
	u16 rx_sop_offset;
	u16 rx_dest_qnum;
	u8 rx_src_tag_hi;
	u8 rx_src_tag_lo;
	u8 rx_dest_tag_hi;
	u8 rx_dest_tag_lo;
	u8 rx_src_tag_hi_sel;
	u8 rx_src_tag_lo_sel;
	u8 rx_dest_tag_hi_sel;
	u8 rx_dest_tag_lo_sel;
	u16 rx_fdq0_sz0_qnum;
	u16 rx_fdq1_qnum;
	u16 rx_fdq2_qnum;
	u16 rx_fdq3_qnum;
	u8 rx_ps_location;
} __attribute__((packed));

struct ti_sci_msg_req_proc_request {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
} __attribute__((packed));

struct ti_sci_msg_req_proc_release {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
} __attribute__((packed));

struct ti_sci_msg_req_proc_handover {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
	u8 host_id;
} __attribute__((packed));

struct ti_sci_msg_req_set_config {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
	u32 bootvector_low;
	u32 bootvector_high;
	u32 config_flags_set;
	u32 config_flags_clear;
} __attribute__((packed));

struct ti_sci_msg_req_set_ctrl {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
	u32 control_flags_set;
	u32 control_flags_clear;
} __attribute__((packed));

struct ti_sci_msg_req_get_status {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
} __attribute__((packed));

struct ti_sci_msg_resp_get_status {
	struct ti_sci_msg_hdr hdr;
	u8 processor_id;
	u32 bootvector_low;
	u32 bootvector_high;
	u32 config_flags;
	u32 control_flags;
	u32 status_flags;
} __attribute__((packed));

struct ti_sci_xfer {
	struct ti_msgmgr_message tx_message;
	u8 rx_len;
	u8 *xfer_buf;
	struct completion done;
};

struct ti_sci_xfers_info {
	struct semaphore sem_xfer_count;
	struct ti_sci_xfer *xfer_block;
	long unsigned int *xfer_alloc_table;
	spinlock_t xfer_lock;
};

struct ti_sci_desc {
	u8 default_host_id;
	int max_rx_timeout_ms;
	int max_msgs;
	int max_msg_size;
};

struct ti_sci_info {
	struct device *dev;
	struct notifier_block nb;
	const struct ti_sci_desc *desc;
	struct dentry *d;
	void *debug_region;
	char *debug_buffer;
	size_t debug_region_size;
	struct ti_sci_handle handle;
	struct mbox_client cl;
	struct mbox_chan___2 *chan_tx;
	struct mbox_chan___2 *chan_rx;
	struct ti_sci_xfers_info minfo;
	struct list_head node;
	u8 host_id;
	int users;
};

struct scmi_revision_info {
	u16 major_ver;
	u16 minor_ver;
	u8 num_protocols;
	u8 num_agents;
	u32 impl_ver;
	char vendor_id[16];
	char sub_vendor_id[16];
};

struct scmi_xfer_ops;

struct scmi_protocol_handle {
	struct device *dev;
	const struct scmi_xfer_ops *xops;
	int (*set_priv)(const struct scmi_protocol_handle *, void *);
	void * (*get_priv)(const struct scmi_protocol_handle *);
};

struct scmi_device;

struct scmi_handle;

struct scmi_notify_ops {
	int (*devm_event_notifier_register)(struct scmi_device *, u8, u8, const u32 *, struct notifier_block *);
	int (*devm_event_notifier_unregister)(struct scmi_device *, u8, u8, const u32 *, struct notifier_block *);
	int (*event_notifier_register)(const struct scmi_handle *, u8, u8, const u32 *, struct notifier_block *);
	int (*event_notifier_unregister)(const struct scmi_handle *, u8, u8, const u32 *, struct notifier_block *);
};

struct scmi_device {
	u32 id;
	u8 protocol_id;
	const char *name;
	struct device dev;
	struct scmi_handle *handle;
};

struct scmi_handle {
	struct device *dev;
	struct scmi_revision_info *version;
	const void * (*devm_protocol_get)(struct scmi_device *, u8, struct scmi_protocol_handle **);
	void (*devm_protocol_put)(struct scmi_device *, u8);
	const struct scmi_notify_ops *notify_ops;
};

struct scmi_device_id {
	u8 protocol_id;
	const char *name;
};

struct scmi_driver {
	const char *name;
	int (*probe)(struct scmi_device *);
	void (*remove)(struct scmi_device *);
	const struct scmi_device_id *id_table;
	struct device_driver driver;
};

struct scmi_event {
	u8 id;
	size_t max_payld_sz;
	size_t max_report_sz;
};

struct scmi_event_ops {
	int (*get_num_sources)(const struct scmi_protocol_handle *);
	int (*set_notify_enabled)(const struct scmi_protocol_handle *, u8, u32, bool);
	void * (*fill_custom_report)(const struct scmi_protocol_handle *, u8, ktime_t, const void *, size_t, void *, u32 *);
};

struct scmi_protocol_events {
	size_t queue_sz;
	const struct scmi_event_ops *ops;
	const struct scmi_event *evts;
	unsigned int num_events;
	unsigned int num_sources;
};

struct scmi_msg_hdr {
	u8 id;
	u8 protocol_id;
	u16 seq;
	u32 status;
	bool poll_completion;
};

struct scmi_msg {
	void *buf;
	size_t len;
};

struct scmi_xfer {
	int transfer_id;
	struct scmi_msg_hdr hdr;
	struct scmi_msg tx;
	struct scmi_msg rx;
	struct completion done;
	struct completion *async_done;
};

struct scmi_xfer_ops {
	int (*version_get)(const struct scmi_protocol_handle *, u32 *);
	int (*xfer_get_init)(const struct scmi_protocol_handle *, u8, size_t, size_t, struct scmi_xfer **);
	void (*reset_rx_to_maxsz)(const struct scmi_protocol_handle *, struct scmi_xfer *);
	int (*do_xfer)(const struct scmi_protocol_handle *, struct scmi_xfer *);
	int (*do_xfer_with_response)(const struct scmi_protocol_handle *, struct scmi_xfer *);
	void (*xfer_put)(const struct scmi_protocol_handle *, struct scmi_xfer *);
};

typedef int (*scmi_prot_init_ph_fn_t)(const struct scmi_protocol_handle *);

struct scmi_protocol {
	const u8 id;
	struct module *owner;
	const scmi_prot_init_ph_fn_t instance_init;
	const scmi_prot_init_ph_fn_t instance_deinit;
	const void *ops;
	const struct scmi_protocol_events *events;
};

struct scmi_chan_info {
	struct device *dev;
	struct scmi_handle *handle;
	void *transport_info;
};

struct scmi_transport_ops {
	bool (*chan_available)(struct device *, int);
	int (*chan_setup)(struct scmi_chan_info *, struct device *, bool);
	int (*chan_free)(int, void *, void *);
	int (*send_message)(struct scmi_chan_info *, struct scmi_xfer *);
	void (*mark_txdone)(struct scmi_chan_info *, int);
	void (*fetch_response)(struct scmi_chan_info *, struct scmi_xfer *);
	void (*fetch_notification)(struct scmi_chan_info *, size_t, struct scmi_xfer *);
	void (*clear_channel)(struct scmi_chan_info *);
	bool (*poll_done)(struct scmi_chan_info *, struct scmi_xfer *);
};

struct scmi_desc {
	const struct scmi_transport_ops *ops;
	int max_rx_timeout_ms;
	int max_msg;
	int max_msg_size;
};

enum scmi_std_protocol {
	SCMI_PROTOCOL_BASE = 16,
	SCMI_PROTOCOL_POWER = 17,
	SCMI_PROTOCOL_SYSTEM = 18,
	SCMI_PROTOCOL_PERF = 19,
	SCMI_PROTOCOL_CLOCK = 20,
	SCMI_PROTOCOL_SENSOR = 21,
	SCMI_PROTOCOL_RESET = 22,
	SCMI_PROTOCOL_VOLTAGE = 23,
};

enum scmi_common_cmd {
	PROTOCOL_VERSION = 0,
	PROTOCOL_ATTRIBUTES = 1,
	PROTOCOL_MESSAGE_ATTRIBUTES = 2,
};

struct trace_event_raw_scmi_xfer_begin {
	struct trace_entry ent;
	int transfer_id;
	u8 msg_id;
	u8 protocol_id;
	u16 seq;
	bool poll;
	char __data[0];
};

struct trace_event_raw_scmi_xfer_end {
	struct trace_entry ent;
	int transfer_id;
	u8 msg_id;
	u8 protocol_id;
	u16 seq;
	int status;
	char __data[0];
};

struct trace_event_raw_scmi_rx_done {
	struct trace_entry ent;
	int transfer_id;
	u8 msg_id;
	u8 protocol_id;
	u16 seq;
	u8 msg_type;
	char __data[0];
};

struct trace_event_data_offsets_scmi_xfer_begin {};

struct trace_event_data_offsets_scmi_xfer_end {};

struct trace_event_data_offsets_scmi_rx_done {};

typedef void (*btf_trace_scmi_xfer_begin)(void *, int, u8, u8, u16, bool);

typedef void (*btf_trace_scmi_xfer_end)(void *, int, u8, u8, u16, int);

typedef void (*btf_trace_scmi_rx_done)(void *, int, u8, u8, u16, u8);

enum scmi_error_codes {
	SCMI_SUCCESS = 0,
	SCMI_ERR_SUPPORT = 4294967295,
	SCMI_ERR_PARAMS = 4294967294,
	SCMI_ERR_ACCESS = 4294967293,
	SCMI_ERR_ENTRY = 4294967292,
	SCMI_ERR_RANGE = 4294967291,
	SCMI_ERR_BUSY = 4294967290,
	SCMI_ERR_COMMS = 4294967289,
	SCMI_ERR_GENERIC = 4294967288,
	SCMI_ERR_HARDWARE = 4294967287,
	SCMI_ERR_PROTOCOL = 4294967286,
};

struct scmi_requested_dev {
	const struct scmi_device_id *id_table;
	struct list_head node;
};

struct scmi_xfers_info {
	struct scmi_xfer *xfer_block;
	long unsigned int *xfer_alloc_table;
	spinlock_t xfer_lock;
};

struct scmi_protocol_instance {
	const struct scmi_handle *handle;
	const struct scmi_protocol *proto;
	void *gid;
	refcount_t users;
	void *priv;
	struct scmi_protocol_handle ph;
};

struct scmi_info {
	struct device *dev;
	const struct scmi_desc *desc;
	struct scmi_revision_info version;
	struct scmi_handle handle;
	struct scmi_xfers_info tx_minfo;
	struct scmi_xfers_info rx_minfo;
	struct idr tx_idr;
	struct idr rx_idr;
	struct idr protocols;
	struct mutex protocols_mtx;
	u8 *protocols_imp;
	struct idr active_protocols;
	void *notify_priv;
	struct list_head node;
	int users;
};

struct scmi_protocol_devres {
	const struct scmi_handle *handle;
	u8 protocol_id;
};

struct scmi_registered_events_desc;

struct scmi_notify_instance {
	void *gid;
	struct scmi_handle *handle;
	struct work_struct init_work;
	struct workqueue_struct *notify_wq;
	struct mutex pending_mtx;
	struct scmi_registered_events_desc **registered_protocols;
	struct hlist_head pending_events_handlers[16];
};

struct events_queue {
	size_t sz;
	struct kfifo kfifo;
	struct work_struct notify_work;
	struct workqueue_struct *wq;
};

struct scmi_event_header;

struct scmi_registered_event;

struct scmi_registered_events_desc {
	u8 id;
	const struct scmi_event_ops *ops;
	struct events_queue equeue;
	struct scmi_notify_instance *ni;
	struct scmi_event_header *eh;
	size_t eh_sz;
	void *in_flight;
	int num_events;
	struct scmi_registered_event **registered_events;
	struct mutex registered_mtx;
	const struct scmi_protocol_handle *ph;
	struct hlist_head registered_events_handlers[64];
};

struct scmi_event_header {
	ktime_t timestamp;
	size_t payld_sz;
	unsigned char evt_id;
	unsigned char payld[0];
};

struct scmi_registered_event {
	struct scmi_registered_events_desc *proto;
	const struct scmi_event *evt;
	void *report;
	u32 num_sources;
	refcount_t *sources;
	struct mutex sources_mtx;
};

struct scmi_event_handler {
	u32 key;
	refcount_t users;
	struct scmi_registered_event *r_evt;
	struct blocking_notifier_head chain;
	struct hlist_node hash;
	bool enabled;
};

struct scmi_notifier_devres {
	const struct scmi_handle *handle;
	u8 proto_id;
	u8 evt_id;
	u32 __src_id;
	u32 *src_id;
	struct notifier_block *nb;
};

enum scmi_notification_events {
	SCMI_EVENT_POWER_STATE_CHANGED = 0,
	SCMI_EVENT_PERFORMANCE_LIMITS_CHANGED = 0,
	SCMI_EVENT_PERFORMANCE_LEVEL_CHANGED = 1,
	SCMI_EVENT_SENSOR_TRIP_POINT_EVENT = 0,
	SCMI_EVENT_SENSOR_UPDATE = 1,
	SCMI_EVENT_RESET_ISSUED = 0,
	SCMI_EVENT_BASE_ERROR_EVENT = 0,
	SCMI_EVENT_SYSTEM_POWER_STATE_NOTIFIER = 0,
};

struct scmi_base_error_report {
	ktime_t timestamp;
	unsigned int agent_id;
	bool fatal;
	unsigned int cmd_count;
	long long unsigned int reports[0];
};

enum scmi_base_protocol_cmd {
	BASE_DISCOVER_VENDOR = 3,
	BASE_DISCOVER_SUB_VENDOR = 4,
	BASE_DISCOVER_IMPLEMENT_VERSION = 5,
	BASE_DISCOVER_LIST_PROTOCOLS = 6,
	BASE_DISCOVER_AGENT = 7,
	BASE_NOTIFY_ERRORS = 8,
	BASE_SET_DEVICE_PERMISSIONS = 9,
	BASE_SET_PROTOCOL_PERMISSIONS = 10,
	BASE_RESET_AGENT_CONFIGURATION = 11,
};

struct scmi_msg_resp_base_attributes {
	u8 num_protocols;
	u8 num_agents;
	__le16 reserved;
};

struct scmi_msg_resp_base_discover_agent {
	__le32 agent_id;
	u8 name[16];
};

struct scmi_msg_base_error_notify {
	__le32 event_control;
};

struct scmi_base_error_notify_payld {
	__le32 agent_id;
	__le32 error_status;
	__le64 msg_reports[1024];
};

struct scmi_clock_info {
	char name[16];
	bool rate_discrete;
	union {
		struct {
			int num_rates;
			u64 rates[16];
		} list;
		struct {
			u64 min_rate;
			u64 max_rate;
			u64 step_size;
		} range;
	};
};

struct scmi_clk_proto_ops {
	int (*count_get)(const struct scmi_protocol_handle *);
	const struct scmi_clock_info * (*info_get)(const struct scmi_protocol_handle *, u32);
	int (*rate_get)(const struct scmi_protocol_handle *, u32, u64 *);
	int (*rate_set)(const struct scmi_protocol_handle *, u32, u64);
	int (*enable)(const struct scmi_protocol_handle *, u32);
	int (*disable)(const struct scmi_protocol_handle *, u32);
};

enum scmi_clock_protocol_cmd {
	CLOCK_ATTRIBUTES = 3,
	CLOCK_DESCRIBE_RATES = 4,
	CLOCK_RATE_SET = 5,
	CLOCK_RATE_GET = 6,
	CLOCK_CONFIG_SET = 7,
};

struct scmi_msg_resp_clock_protocol_attributes {
	__le16 num_clocks;
	u8 max_async_req;
	u8 reserved;
};

struct scmi_msg_resp_clock_attributes {
	__le32 attributes;
	u8 name[16];
};

struct scmi_clock_set_config {
	__le32 id;
	__le32 attributes;
};

struct scmi_msg_clock_describe_rates {
	__le32 id;
	__le32 rate_index;
};

struct scmi_msg_resp_clock_describe_rates {
	__le32 num_rates_flags;
	struct {
		__le32 value_low;
		__le32 value_high;
	} rate[0];
};

struct scmi_clock_set_rate {
	__le32 flags;
	__le32 id;
	__le32 value_low;
	__le32 value_high;
};

struct clock_info {
	u32 version;
	int num_clocks;
	int max_async_req;
	atomic_t cur_async_req;
	struct scmi_clock_info *clk;
};

struct scmi_perf_proto_ops {
	int (*limits_set)(const struct scmi_protocol_handle *, u32, u32, u32);
	int (*limits_get)(const struct scmi_protocol_handle *, u32, u32 *, u32 *);
	int (*level_set)(const struct scmi_protocol_handle *, u32, u32, bool);
	int (*level_get)(const struct scmi_protocol_handle *, u32, u32 *, bool);
	int (*device_domain_id)(struct device *);
	int (*transition_latency_get)(const struct scmi_protocol_handle *, struct device *);
	int (*device_opps_add)(const struct scmi_protocol_handle *, struct device *);
	int (*freq_set)(const struct scmi_protocol_handle *, u32, long unsigned int, bool);
	int (*freq_get)(const struct scmi_protocol_handle *, u32, long unsigned int *, bool);
	int (*est_power_get)(const struct scmi_protocol_handle *, u32, long unsigned int *, long unsigned int *);
	bool (*fast_switch_possible)(const struct scmi_protocol_handle *, struct device *);
	bool (*power_scale_mw_get)(const struct scmi_protocol_handle *);
};

struct scmi_perf_limits_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int domain_id;
	unsigned int range_max;
	unsigned int range_min;
};

struct scmi_perf_level_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int domain_id;
	unsigned int performance_level;
};

enum scmi_performance_protocol_cmd {
	PERF_DOMAIN_ATTRIBUTES = 3,
	PERF_DESCRIBE_LEVELS = 4,
	PERF_LIMITS_SET = 5,
	PERF_LIMITS_GET = 6,
	PERF_LEVEL_SET = 7,
	PERF_LEVEL_GET = 8,
	PERF_NOTIFY_LIMITS = 9,
	PERF_NOTIFY_LEVEL = 10,
	PERF_DESCRIBE_FASTCHANNEL = 11,
};

struct scmi_opp {
	u32 perf;
	u32 power;
	u32 trans_latency_us;
};

struct scmi_msg_resp_perf_attributes {
	__le16 num_domains;
	__le16 flags;
	__le32 stats_addr_low;
	__le32 stats_addr_high;
	__le32 stats_size;
};

struct scmi_msg_resp_perf_domain_attributes {
	__le32 flags;
	__le32 rate_limit_us;
	__le32 sustained_freq_khz;
	__le32 sustained_perf_level;
	u8 name[16];
};

struct scmi_msg_perf_describe_levels {
	__le32 domain;
	__le32 level_index;
};

struct scmi_perf_set_limits {
	__le32 domain;
	__le32 max_level;
	__le32 min_level;
};

struct scmi_perf_get_limits {
	__le32 max_level;
	__le32 min_level;
};

struct scmi_perf_set_level {
	__le32 domain;
	__le32 level;
};

struct scmi_perf_notify_level_or_limits {
	__le32 domain;
	__le32 notify_enable;
};

struct scmi_perf_limits_notify_payld {
	__le32 agent_id;
	__le32 domain_id;
	__le32 range_max;
	__le32 range_min;
};

struct scmi_perf_level_notify_payld {
	__le32 agent_id;
	__le32 domain_id;
	__le32 performance_level;
};

struct scmi_msg_resp_perf_describe_levels {
	__le16 num_returned;
	__le16 num_remaining;
	struct {
		__le32 perf_val;
		__le32 power;
		__le16 transition_latency_us;
		__le16 reserved;
	} opp[0];
};

struct scmi_perf_get_fc_info {
	__le32 domain;
	__le32 message_id;
};

struct scmi_msg_resp_perf_desc_fc {
	__le32 attr;
	__le32 rate_limit;
	__le32 chan_addr_low;
	__le32 chan_addr_high;
	__le32 chan_size;
	__le32 db_addr_low;
	__le32 db_addr_high;
	__le32 db_set_lmask;
	__le32 db_set_hmask;
	__le32 db_preserve_lmask;
	__le32 db_preserve_hmask;
};

struct scmi_fc_db_info {
	int width;
	u64 set;
	u64 mask;
	void *addr;
};

struct scmi_fc_info {
	void *level_set_addr;
	void *limit_set_addr;
	void *level_get_addr;
	void *limit_get_addr;
	struct scmi_fc_db_info *level_set_db;
	struct scmi_fc_db_info *limit_set_db;
};

struct perf_dom_info {
	bool set_limits;
	bool set_perf;
	bool perf_limit_notify;
	bool perf_level_notify;
	bool perf_fastchannels;
	u32 opp_count;
	u32 sustained_freq_khz;
	u32 sustained_perf_level;
	u32 mult_factor;
	char name[16];
	struct scmi_opp opp[16];
	struct scmi_fc_info *fc_info;
};

struct scmi_perf_info {
	u32 version;
	int num_domains;
	bool power_scale_mw;
	u64 stats_addr;
	u32 stats_size;
	struct perf_dom_info *dom_info;
};

struct scmi_power_proto_ops {
	int (*num_domains_get)(const struct scmi_protocol_handle *);
	char * (*name_get)(const struct scmi_protocol_handle *, u32);
	int (*state_set)(const struct scmi_protocol_handle *, u32, u32);
	int (*state_get)(const struct scmi_protocol_handle *, u32, u32 *);
};

struct scmi_power_state_changed_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int domain_id;
	unsigned int power_state;
};

enum scmi_power_protocol_cmd {
	POWER_DOMAIN_ATTRIBUTES = 3,
	POWER_STATE_SET = 4,
	POWER_STATE_GET = 5,
	POWER_STATE_NOTIFY = 6,
};

struct scmi_msg_resp_power_attributes {
	__le16 num_domains;
	__le16 reserved;
	__le32 stats_addr_low;
	__le32 stats_addr_high;
	__le32 stats_size;
};

struct scmi_msg_resp_power_domain_attributes {
	__le32 flags;
	u8 name[16];
};

struct scmi_power_set_state {
	__le32 flags;
	__le32 domain;
	__le32 state;
};

struct scmi_power_state_notify {
	__le32 domain;
	__le32 notify_enable;
};

struct scmi_power_state_notify_payld {
	__le32 agent_id;
	__le32 domain_id;
	__le32 power_state;
};

struct power_dom_info {
	bool state_set_sync;
	bool state_set_async;
	bool state_set_notify;
	char name[16];
};

struct scmi_power_info {
	u32 version;
	int num_domains;
	u64 stats_addr;
	u32 stats_size;
	struct power_dom_info *dom_info;
};

struct scmi_reset_proto_ops {
	int (*num_domains_get)(const struct scmi_protocol_handle *);
	char * (*name_get)(const struct scmi_protocol_handle *, u32);
	int (*latency_get)(const struct scmi_protocol_handle *, u32);
	int (*reset)(const struct scmi_protocol_handle *, u32);
	int (*assert)(const struct scmi_protocol_handle *, u32);
	int (*deassert)(const struct scmi_protocol_handle *, u32);
};

struct scmi_reset_issued_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int domain_id;
	unsigned int reset_state;
};

enum scmi_reset_protocol_cmd {
	RESET_DOMAIN_ATTRIBUTES = 3,
	RESET = 4,
	RESET_NOTIFY = 5,
};

struct scmi_msg_resp_reset_domain_attributes {
	__le32 attributes;
	__le32 latency;
	u8 name[16];
};

struct scmi_msg_reset_domain_reset {
	__le32 domain_id;
	__le32 flags;
	__le32 reset_state;
};

struct scmi_msg_reset_notify {
	__le32 id;
	__le32 event_control;
};

struct scmi_reset_issued_notify_payld {
	__le32 agent_id;
	__le32 domain_id;
	__le32 reset_state;
};

struct reset_dom_info {
	bool async_reset;
	bool reset_notify;
	u32 latency_us;
	char name[16];
};

struct scmi_reset_info {
	u32 version;
	int num_domains;
	struct reset_dom_info *dom_info;
};

struct scmi_sensor_reading {
	long long int value;
	long long unsigned int timestamp;
};

struct scmi_range_attrs {
	long long int min_range;
	long long int max_range;
};

struct scmi_sensor_axis_info {
	unsigned int id;
	unsigned int type;
	int scale;
	char name[16];
	bool extended_attrs;
	unsigned int resolution;
	int exponent;
	struct scmi_range_attrs attrs;
};

struct scmi_sensor_intervals_info {
	bool segmented;
	unsigned int count;
	unsigned int *desc;
	unsigned int prealloc_pool[16];
};

struct scmi_sensor_info {
	unsigned int id;
	unsigned int type;
	int scale;
	unsigned int num_trip_points;
	bool async;
	bool update;
	bool timestamped;
	int tstamp_scale;
	unsigned int num_axis;
	struct scmi_sensor_axis_info *axis;
	struct scmi_sensor_intervals_info intervals;
	unsigned int sensor_config;
	char name[16];
	bool extended_scalar_attrs;
	unsigned int sensor_power;
	unsigned int resolution;
	int exponent;
	struct scmi_range_attrs scalar_attrs;
};

struct scmi_sensor_proto_ops {
	int (*count_get)(const struct scmi_protocol_handle *);
	const struct scmi_sensor_info * (*info_get)(const struct scmi_protocol_handle *, u32);
	int (*trip_point_config)(const struct scmi_protocol_handle *, u32, u8, u64);
	int (*reading_get)(const struct scmi_protocol_handle *, u32, u64 *);
	int (*reading_get_timestamped)(const struct scmi_protocol_handle *, u32, u8, struct scmi_sensor_reading *);
	int (*config_get)(const struct scmi_protocol_handle *, u32, u32 *);
	int (*config_set)(const struct scmi_protocol_handle *, u32, u32);
};

struct scmi_sensor_trip_point_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int sensor_id;
	unsigned int trip_point_desc;
};

struct scmi_sensor_update_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int sensor_id;
	unsigned int readings_count;
	struct scmi_sensor_reading readings[0];
};

enum scmi_sensor_protocol_cmd {
	SENSOR_DESCRIPTION_GET = 3,
	SENSOR_TRIP_POINT_NOTIFY = 4,
	SENSOR_TRIP_POINT_CONFIG = 5,
	SENSOR_READING_GET = 6,
	SENSOR_AXIS_DESCRIPTION_GET = 7,
	SENSOR_LIST_UPDATE_INTERVALS = 8,
	SENSOR_CONFIG_GET = 9,
	SENSOR_CONFIG_SET = 10,
	SENSOR_CONTINUOUS_UPDATE_NOTIFY = 11,
};

struct scmi_msg_resp_sensor_attributes {
	__le16 num_sensors;
	u8 max_requests;
	u8 reserved;
	__le32 reg_addr_low;
	__le32 reg_addr_high;
	__le32 reg_size;
};

struct scmi_msg_resp_attrs {
	__le32 min_range_low;
	__le32 min_range_high;
	__le32 max_range_low;
	__le32 max_range_high;
};

struct scmi_sensor_descriptor {
	__le32 id;
	__le32 attributes_low;
	__le32 attributes_high;
	u8 name[16];
	__le32 power;
	__le32 resolution;
	struct scmi_msg_resp_attrs scalar_attrs;
};

struct scmi_msg_resp_sensor_description {
	__le16 num_returned;
	__le16 num_remaining;
	struct scmi_sensor_descriptor desc[0];
};

struct scmi_msg_sensor_axis_description_get {
	__le32 id;
	__le32 axis_desc_index;
};

struct scmi_axis_descriptor {
	__le32 id;
	__le32 attributes_low;
	__le32 attributes_high;
	u8 name[16];
	__le32 resolution;
	struct scmi_msg_resp_attrs attrs;
};

struct scmi_msg_resp_sensor_axis_description {
	__le32 num_axis_flags;
	struct scmi_axis_descriptor desc[0];
};

struct scmi_msg_sensor_list_update_intervals {
	__le32 id;
	__le32 index;
};

struct scmi_msg_resp_sensor_list_update_intervals {
	__le32 num_intervals_flags;
	__le32 intervals[0];
};

struct scmi_msg_sensor_request_notify {
	__le32 id;
	__le32 event_control;
};

struct scmi_msg_set_sensor_trip_point {
	__le32 id;
	__le32 event_control;
	__le32 value_low;
	__le32 value_high;
};

struct scmi_msg_sensor_config_set {
	__le32 id;
	__le32 sensor_config;
};

struct scmi_msg_sensor_reading_get {
	__le32 id;
	__le32 flags;
};

struct scmi_resp_sensor_reading_complete {
	__le32 id;
	__le32 readings_low;
	__le32 readings_high;
};

struct scmi_sensor_reading_resp {
	__le32 sensor_value_low;
	__le32 sensor_value_high;
	__le32 timestamp_low;
	__le32 timestamp_high;
};

struct scmi_resp_sensor_reading_complete_v3 {
	__le32 id;
	struct scmi_sensor_reading_resp readings[0];
};

struct scmi_sensor_trip_notify_payld {
	__le32 agent_id;
	__le32 sensor_id;
	__le32 trip_point_desc;
};

struct scmi_sensor_update_notify_payld {
	__le32 agent_id;
	__le32 sensor_id;
	struct scmi_sensor_reading_resp readings[0];
};

struct sensors_info {
	u32 version;
	int num_sensors;
	int max_requests;
	u64 reg_addr;
	u32 reg_size;
	struct scmi_sensor_info *sensors;
};

struct scmi_system_power_state_notifier_report {
	ktime_t timestamp;
	unsigned int agent_id;
	unsigned int flags;
	unsigned int system_state;
};

enum scmi_system_protocol_cmd {
	SYSTEM_POWER_STATE_NOTIFY = 5,
};

struct scmi_system_power_state_notify {
	__le32 notify_enable;
};

struct scmi_system_power_state_notifier_payld {
	__le32 agent_id;
	__le32 flags;
	__le32 system_state;
};

struct scmi_system_info {
	u32 version;
};

struct scmi_voltage_info {
	unsigned int id;
	bool segmented;
	bool negative_volts_allowed;
	unsigned int attributes;
	char name[16];
	unsigned int num_levels;
	int *levels_uv;
};

struct scmi_voltage_proto_ops {
	int (*num_domains_get)(const struct scmi_protocol_handle *);
	const struct scmi_voltage_info * (*info_get)(const struct scmi_protocol_handle *, u32);
	int (*config_set)(const struct scmi_protocol_handle *, u32, u32);
	int (*config_get)(const struct scmi_protocol_handle *, u32, u32 *);
	int (*level_set)(const struct scmi_protocol_handle *, u32, u32, s32);
	int (*level_get)(const struct scmi_protocol_handle *, u32, s32 *);
};

enum scmi_voltage_protocol_cmd {
	VOLTAGE_DOMAIN_ATTRIBUTES = 3,
	VOLTAGE_DESCRIBE_LEVELS = 4,
	VOLTAGE_CONFIG_SET = 5,
	VOLTAGE_CONFIG_GET = 6,
	VOLTAGE_LEVEL_SET = 7,
	VOLTAGE_LEVEL_GET = 8,
};

struct scmi_msg_resp_domain_attributes {
	__le32 attr;
	u8 name[16];
};

struct scmi_msg_cmd_describe_levels {
	__le32 domain_id;
	__le32 level_index;
};

struct scmi_msg_resp_describe_levels {
	__le32 flags;
	__le32 voltage[0];
};

struct scmi_msg_cmd_config_set {
	__le32 domain_id;
	__le32 config;
};

struct scmi_msg_cmd_level_set {
	__le32 domain_id;
	__le32 flags;
	__le32 voltage_level;
};

struct voltage_info {
	unsigned int version;
	unsigned int num_domains;
	struct scmi_voltage_info *domains;
};

struct scmi_shared_mem {
	__le32 reserved;
	__le32 channel_status;
	__le32 reserved1[2];
	__le32 flags;
	__le32 length;
	__le32 msg_header;
	u8 msg_payload[0];
};

struct scmi_shared_mem___2;

struct scmi_mailbox {
	struct mbox_client cl;
	struct mbox_chan___2 *chan;
	struct scmi_chan_info *cinfo;
	struct scmi_shared_mem___2 *shmem;
};

struct scmi_smc {
	struct scmi_chan_info *cinfo;
	struct scmi_shared_mem___2 *shmem;
	struct mutex shmem_lock;
	u32 func_id;
	int irq;
	struct completion tx_complete;
};

struct meson_sm_cmd {
	unsigned int index;
	u32 smc_id;
};

struct meson_sm_chip {
	unsigned int shmem_size;
	u32 cmd_shmem_in_base;
	u32 cmd_shmem_out_base;
	struct meson_sm_cmd cmd[0];
};

struct meson_sm_firmware___2 {
	const struct meson_sm_chip *chip;
	void *sm_shmem_in_base;
	void *sm_shmem_out_base;
};

struct bmp_header {
	u16 id;
	u32 size;
} __attribute__((packed));

typedef efi_status_t efi_query_variable_store_t(u32, long unsigned int, bool);

typedef struct {
	efi_guid_t guid;
	u64 table;
} efi_config_table_64_t;

typedef struct {
	efi_guid_t guid;
	u32 table;
} efi_config_table_32_t;

typedef union {
	struct {
		efi_guid_t guid;
		void *table;
	};
	efi_config_table_32_t mixed_mode;
} efi_config_table_t;

typedef struct {
	efi_guid_t guid;
	long unsigned int *ptr;
	const char name[16];
} efi_config_table_type_t;

typedef struct {
	u16 version;
	u16 length;
	u32 runtime_services_supported;
} efi_rt_properties_table_t;

struct efivar_operations {
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_store_t *query_variable_store;
};

struct efivars {
	struct kset *kset;
	struct kobject *kobject;
	const struct efivar_operations *ops;
};

struct linux_efi_random_seed {
	u32 size;
	u8 bits[0];
};

struct linux_efi_memreserve {
	int size;
	atomic_t count;
	phys_addr_t next;
	struct {
		phys_addr_t base;
		phys_addr_t size;
	} entry[0];
};

struct efi_error_code {
	efi_status_t status;
	int errno;
	const char *description;
};

struct efi_generic_dev_path {
	u8 type;
	u8 sub_type;
	u16 length;
};

struct variable_validate {
	efi_guid_t vendor;
	char *name;
	bool (*validate)(efi_char16_t *, int, u8 *, long unsigned int);
};

typedef struct {
	u32 version;
	u32 num_entries;
	u32 desc_size;
	u32 reserved;
	efi_memory_desc_t entry[0];
} efi_memory_attributes_table_t;

typedef int (*efi_memattr_perm_setter)(struct mm_struct *, efi_memory_desc_t *);

struct efi_memory_map_data {
	phys_addr_t phys_map;
	long unsigned int size;
	long unsigned int desc_version;
	long unsigned int desc_size;
	long unsigned int flags;
};

struct efi_mem_range {
	struct range range;
	u64 attribute;
};

typedef u64 efi_physical_addr_t;

typedef struct {
	u64 length;
	u64 data;
} efi_capsule_block_desc_t;

enum efi_secureboot_mode {
	efi_secureboot_mode_unset = 0,
	efi_secureboot_mode_unknown = 1,
	efi_secureboot_mode_disabled = 2,
	efi_secureboot_mode_enabled = 3,
};

enum {
	SYSTAB = 0,
	MMBASE = 1,
	MMSIZE = 2,
	DCSIZE = 3,
	DCVERS = 4,
	SCBOOT = 5,
	PARAMCOUNT = 6,
};

struct efi_system_resource_entry_v1 {
	efi_guid_t fw_class;
	u32 fw_type;
	u32 fw_version;
	u32 lowest_supported_fw_version;
	u32 capsule_flags;
	u32 last_attempt_version;
	u32 last_attempt_status;
};

struct efi_system_resource_table {
	u32 fw_resource_count;
	u32 fw_resource_count_max;
	u64 fw_resource_version;
	u8 entries[0];
};

struct esre_entry {
	union {
		struct efi_system_resource_entry_v1 *esre1;
	} esre;
	struct kobject kobj;
	struct list_head list;
};

struct esre_attribute {
	struct attribute attr;
	ssize_t (*show)(struct esre_entry *, char *);
	ssize_t (*store)(struct esre_entry *, const char *, size_t);
};

struct cper_sec_proc_generic {
	u64 validation_bits;
	u8 proc_type;
	u8 proc_isa;
	u8 proc_error_type;
	u8 operation;
	u8 flags;
	u8 level;
	u16 reserved;
	u64 cpu_version;
	char cpu_brand[128];
	u64 proc_id;
	u64 target_addr;
	u64 requestor_id;
	u64 responder_id;
	u64 ip;
};

struct cper_mem_err_compact {
	u64 validation_bits;
	u16 node;
	u16 card;
	u16 module;
	u16 bank;
	u16 device;
	u16 row;
	u16 column;
	u16 bit_pos;
	u64 requestor_id;
	u64 responder_id;
	u64 target_id;
	u16 rank;
	u16 mem_array_handle;
	u16 mem_dev_handle;
	u8 extended;
} __attribute__((packed));

struct cper_sec_fw_err_rec_ref {
	u8 record_type;
	u8 revision;
	u8 reserved[6];
	u64 record_identifier;
	guid_t record_identifier_guid;
};

struct efi_mokvar_sysfs_attr {
	struct bin_attribute bin_attr;
	struct list_head node;
};

typedef void *efi_event_t;

typedef void (*efi_event_notify_t)(efi_event_t, void *);

typedef enum {
	EfiTimerCancel = 0,
	EfiTimerPeriodic = 1,
	EfiTimerRelative = 2,
} EFI_TIMER_DELAY;

typedef void *efi_handle_t;

typedef struct efi_generic_dev_path efi_device_path_protocol_t;

union efi_boot_services {
	struct {
		efi_table_hdr_t hdr;
		void *raise_tpl;
		void *restore_tpl;
		efi_status_t (*allocate_pages)(int, int, long unsigned int, efi_physical_addr_t *);
		efi_status_t (*free_pages)(efi_physical_addr_t, long unsigned int);
		efi_status_t (*get_memory_map)(long unsigned int *, void *, long unsigned int *, long unsigned int *, u32 *);
		efi_status_t (*allocate_pool)(int, long unsigned int, void **);
		efi_status_t (*free_pool)(void *);
		efi_status_t (*create_event)(u32, long unsigned int, efi_event_notify_t, void *, efi_event_t *);
		efi_status_t (*set_timer)(efi_event_t, EFI_TIMER_DELAY, u64);
		efi_status_t (*wait_for_event)(long unsigned int, efi_event_t *, long unsigned int *);
		void *signal_event;
		efi_status_t (*close_event)(efi_event_t);
		void *check_event;
		void *install_protocol_interface;
		void *reinstall_protocol_interface;
		void *uninstall_protocol_interface;
		efi_status_t (*handle_protocol)(efi_handle_t, efi_guid_t *, void **);
		void *__reserved;
		void *register_protocol_notify;
		efi_status_t (*locate_handle)(int, efi_guid_t *, void *, long unsigned int *, efi_handle_t *);
		efi_status_t (*locate_device_path)(efi_guid_t *, efi_device_path_protocol_t **, efi_handle_t *);
		efi_status_t (*install_configuration_table)(efi_guid_t *, void *);
		void *load_image;
		void *start_image;
		efi_status_t (*exit)(efi_handle_t, efi_status_t, long unsigned int, efi_char16_t *);
		void *unload_image;
		efi_status_t (*exit_boot_services)(efi_handle_t, long unsigned int);
		void *get_next_monotonic_count;
		efi_status_t (*stall)(long unsigned int);
		void *set_watchdog_timer;
		void *connect_controller;
		efi_status_t (*disconnect_controller)(efi_handle_t, efi_handle_t, efi_handle_t);
		void *open_protocol;
		void *close_protocol;
		void *open_protocol_information;
		void *protocols_per_handle;
		void *locate_handle_buffer;
		efi_status_t (*locate_protocol)(efi_guid_t *, void *, void **);
		void *install_multiple_protocol_interfaces;
		void *uninstall_multiple_protocol_interfaces;
		void *calculate_crc32;
		void *copy_mem;
		void *set_mem;
		void *create_event_ex;
	};
	struct {
		efi_table_hdr_t hdr;
		u32 raise_tpl;
		u32 restore_tpl;
		u32 allocate_pages;
		u32 free_pages;
		u32 get_memory_map;
		u32 allocate_pool;
		u32 free_pool;
		u32 create_event;
		u32 set_timer;
		u32 wait_for_event;
		u32 signal_event;
		u32 close_event;
		u32 check_event;
		u32 install_protocol_interface;
		u32 reinstall_protocol_interface;
		u32 uninstall_protocol_interface;
		u32 handle_protocol;
		u32 __reserved;
		u32 register_protocol_notify;
		u32 locate_handle;
		u32 locate_device_path;
		u32 install_configuration_table;
		u32 load_image;
		u32 start_image;
		u32 exit;
		u32 unload_image;
		u32 exit_boot_services;
		u32 get_next_monotonic_count;
		u32 stall;
		u32 set_watchdog_timer;
		u32 connect_controller;
		u32 disconnect_controller;
		u32 open_protocol;
		u32 close_protocol;
		u32 open_protocol_information;
		u32 protocols_per_handle;
		u32 locate_handle_buffer;
		u32 locate_protocol;
		u32 install_multiple_protocol_interfaces;
		u32 uninstall_multiple_protocol_interfaces;
		u32 calculate_crc32;
		u32 copy_mem;
		u32 set_mem;
		u32 create_event_ex;
	} mixed_mode;
};

typedef union efi_boot_services efi_boot_services_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 fw_vendor;
	u32 fw_revision;
	u32 con_in_handle;
	u32 con_in;
	u32 con_out_handle;
	u32 con_out;
	u32 stderr_handle;
	u32 stderr;
	u32 runtime;
	u32 boottime;
	u32 nr_tables;
	u32 tables;
} efi_system_table_32_t;

typedef struct {
	u16 scan_code;
	efi_char16_t unicode_char;
} efi_input_key_t;

union efi_simple_text_input_protocol;

typedef union efi_simple_text_input_protocol efi_simple_text_input_protocol_t;

union efi_simple_text_input_protocol {
	struct {
		void *reset;
		efi_status_t (*read_keystroke)(efi_simple_text_input_protocol_t *, efi_input_key_t *);
		efi_event_t wait_for_key;
	};
	struct {
		u32 reset;
		u32 read_keystroke;
		u32 wait_for_key;
	} mixed_mode;
};

union efi_simple_text_output_protocol;

typedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;

union efi_simple_text_output_protocol {
	struct {
		void *reset;
		efi_status_t (*output_string)(efi_simple_text_output_protocol_t *, efi_char16_t *);
		void *test_string;
	};
	struct {
		u32 reset;
		u32 output_string;
		u32 test_string;
	} mixed_mode;
};

typedef union {
	struct {
		efi_table_hdr_t hdr;
		long unsigned int fw_vendor;
		u32 fw_revision;
		long unsigned int con_in_handle;
		efi_simple_text_input_protocol_t *con_in;
		long unsigned int con_out_handle;
		efi_simple_text_output_protocol_t *con_out;
		long unsigned int stderr_handle;
		long unsigned int stderr;
		efi_runtime_services_t *runtime;
		efi_boot_services_t *boottime;
		long unsigned int nr_tables;
		long unsigned int tables;
	};
	efi_system_table_32_t mixed_mode;
} efi_system_table_t;

struct cper_arm_ctx_info {
	u16 version;
	u16 type;
	u32 size;
};

enum imx_misc_func {
	IMX_SC_MISC_FUNC_UNKNOWN = 0,
	IMX_SC_MISC_FUNC_SET_CONTROL = 1,
	IMX_SC_MISC_FUNC_GET_CONTROL = 2,
	IMX_SC_MISC_FUNC_SET_MAX_DMA_GROUP = 4,
	IMX_SC_MISC_FUNC_SET_DMA_GROUP = 5,
	IMX_SC_MISC_FUNC_SECO_IMAGE_LOAD = 8,
	IMX_SC_MISC_FUNC_SECO_AUTHENTICATE = 9,
	IMX_SC_MISC_FUNC_DEBUG_OUT = 10,
	IMX_SC_MISC_FUNC_WAVEFORM_CAPTURE = 6,
	IMX_SC_MISC_FUNC_BUILD_INFO = 15,
	IMX_SC_MISC_FUNC_UNIQUE_ID = 19,
	IMX_SC_MISC_FUNC_SET_ARI = 3,
	IMX_SC_MISC_FUNC_BOOT_STATUS = 7,
	IMX_SC_MISC_FUNC_BOOT_DONE = 14,
	IMX_SC_MISC_FUNC_OTP_FUSE_READ = 11,
	IMX_SC_MISC_FUNC_OTP_FUSE_WRITE = 17,
	IMX_SC_MISC_FUNC_SET_TEMP = 12,
	IMX_SC_MISC_FUNC_GET_TEMP = 13,
	IMX_SC_MISC_FUNC_GET_BOOT_DEV = 16,
	IMX_SC_MISC_FUNC_GET_BUTTON_STATUS = 18,
};

struct imx_sc_ipc___2;

struct imx_sc_chan {
	struct imx_sc_ipc___2 *sc_ipc;
	struct mbox_client cl;
	struct mbox_chan___2 *ch;
	int idx;
	struct completion tx_done;
};

struct imx_sc_ipc___2 {
	struct imx_sc_chan chans[8];
	struct device *dev;
	struct mutex lock;
	struct completion done;
	bool fast_ipc;
	u32 *msg;
	u8 rx_size;
	u8 count;
};

enum imx_sc_error_codes {
	IMX_SC_ERR_NONE = 0,
	IMX_SC_ERR_VERSION = 1,
	IMX_SC_ERR_CONFIG = 2,
	IMX_SC_ERR_PARM = 3,
	IMX_SC_ERR_NOACCESS = 4,
	IMX_SC_ERR_LOCKED = 5,
	IMX_SC_ERR_UNAVAILABLE = 6,
	IMX_SC_ERR_NOTFOUND = 7,
	IMX_SC_ERR_NOPOWER = 8,
	IMX_SC_ERR_IPC = 9,
	IMX_SC_ERR_BUSY = 10,
	IMX_SC_ERR_FAIL = 11,
	IMX_SC_ERR_LAST = 12,
};

struct imx_sc_msg_req_misc_set_ctrl {
	struct imx_sc_rpc_msg hdr;
	u32 ctrl;
	u32 val;
	u16 resource;
};

struct imx_sc_msg_req_cpu_start {
	struct imx_sc_rpc_msg hdr;
	u32 address_hi;
	u32 address_lo;
	u16 resource;
	u8 enable;
};

struct imx_sc_msg_req_misc_get_ctrl {
	struct imx_sc_rpc_msg hdr;
	u32 ctrl;
	u16 resource;
};

struct imx_sc_msg_resp_misc_get_ctrl {
	struct imx_sc_rpc_msg hdr;
	u32 val;
};

struct imx_sc_msg_irq_get_status {
	struct imx_sc_rpc_msg hdr;
	union {
		struct {
			u16 resource;
			u8 group;
			u8 reserved;
		} req;
		struct {
			u32 status;
		} resp;
	} data;
};

struct imx_sc_msg_irq_enable {
	struct imx_sc_rpc_msg hdr;
	u32 mask;
	u16 resource;
	u8 group;
	u8 enable;
};

enum imx_sc_rm_func {
	IMX_SC_RM_FUNC_UNKNOWN = 0,
	IMX_SC_RM_FUNC_PARTITION_ALLOC = 1,
	IMX_SC_RM_FUNC_SET_CONFIDENTIAL = 31,
	IMX_SC_RM_FUNC_PARTITION_FREE = 2,
	IMX_SC_RM_FUNC_GET_DID = 26,
	IMX_SC_RM_FUNC_PARTITION_STATIC = 3,
	IMX_SC_RM_FUNC_PARTITION_LOCK = 4,
	IMX_SC_RM_FUNC_GET_PARTITION = 5,
	IMX_SC_RM_FUNC_SET_PARENT = 6,
	IMX_SC_RM_FUNC_MOVE_ALL = 7,
	IMX_SC_RM_FUNC_ASSIGN_RESOURCE = 8,
	IMX_SC_RM_FUNC_SET_RESOURCE_MOVABLE = 9,
	IMX_SC_RM_FUNC_SET_SUBSYS_RSRC_MOVABLE = 28,
	IMX_SC_RM_FUNC_SET_MASTER_ATTRIBUTES = 10,
	IMX_SC_RM_FUNC_SET_MASTER_SID = 11,
	IMX_SC_RM_FUNC_SET_PERIPHERAL_PERMISSIONS = 12,
	IMX_SC_RM_FUNC_IS_RESOURCE_OWNED = 13,
	IMX_SC_RM_FUNC_GET_RESOURCE_OWNER = 33,
	IMX_SC_RM_FUNC_IS_RESOURCE_MASTER = 14,
	IMX_SC_RM_FUNC_IS_RESOURCE_PERIPHERAL = 15,
	IMX_SC_RM_FUNC_GET_RESOURCE_INFO = 16,
	IMX_SC_RM_FUNC_MEMREG_ALLOC = 17,
	IMX_SC_RM_FUNC_MEMREG_SPLIT = 29,
	IMX_SC_RM_FUNC_MEMREG_FRAG = 32,
	IMX_SC_RM_FUNC_MEMREG_FREE = 18,
	IMX_SC_RM_FUNC_FIND_MEMREG = 30,
	IMX_SC_RM_FUNC_ASSIGN_MEMREG = 19,
	IMX_SC_RM_FUNC_SET_MEMREG_PERMISSIONS = 20,
	IMX_SC_RM_FUNC_IS_MEMREG_OWNED = 21,
	IMX_SC_RM_FUNC_GET_MEMREG_INFO = 22,
	IMX_SC_RM_FUNC_ASSIGN_PAD = 23,
	IMX_SC_RM_FUNC_SET_PAD_MOVABLE = 24,
	IMX_SC_RM_FUNC_IS_PAD_OWNED = 25,
	IMX_SC_RM_FUNC_DUMP = 27,
};

struct imx_sc_msg_rm_rsrc_owned {
	struct imx_sc_rpc_msg hdr;
	u16 resource;
	short: 16;
};

struct imx_sc_msg_misc_get_soc_id {
	struct imx_sc_rpc_msg hdr;
	union {
		struct {
			u32 control;
			u16 resource;
		} __attribute__((packed)) req;
		struct {
			u32 id;
		} resp;
	} data;
};

struct imx_sc_msg_misc_get_soc_uid {
	struct imx_sc_rpc_msg hdr;
	u32 uid_low;
	u32 uid_high;
};

struct imx_sc_msg_req_set_resource_power_mode {
	struct imx_sc_rpc_msg hdr;
	u16 resource;
	u8 mode;
};

struct imx_sc_pm_domain {
	struct generic_pm_domain pd;
	char name[20];
	u32 rsrc;
};

struct imx_sc_pd_range {
	char *name;
	u32 rsrc;
	u8 num;
	bool postfix;
	u8 start_from;
};

struct imx_sc_pd_soc {
	const struct imx_sc_pd_range *pd_ranges;
	u8 num_ranges;
};

typedef long unsigned int psci_fn(long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef int (*psci_initcall_t)(const struct device_node *);

enum pm_api_id {
	PM_GET_API_VERSION = 1,
	PM_SYSTEM_SHUTDOWN = 12,
	PM_REQUEST_NODE = 13,
	PM_RELEASE_NODE = 14,
	PM_SET_REQUIREMENT = 15,
	PM_RESET_ASSERT = 17,
	PM_RESET_GET_STATUS = 18,
	PM_PM_INIT_FINALIZE = 21,
	PM_FPGA_LOAD = 22,
	PM_FPGA_GET_STATUS = 23,
	PM_GET_CHIPID = 24,
	PM_PINCTRL_REQUEST = 28,
	PM_PINCTRL_RELEASE = 29,
	PM_PINCTRL_GET_FUNCTION = 30,
	PM_PINCTRL_SET_FUNCTION = 31,
	PM_PINCTRL_CONFIG_PARAM_GET = 32,
	PM_PINCTRL_CONFIG_PARAM_SET = 33,
	PM_IOCTL = 34,
	PM_QUERY_DATA = 35,
	PM_CLOCK_ENABLE = 36,
	PM_CLOCK_DISABLE = 37,
	PM_CLOCK_GETSTATE = 38,
	PM_CLOCK_SETDIVIDER = 39,
	PM_CLOCK_GETDIVIDER = 40,
	PM_CLOCK_SETRATE = 41,
	PM_CLOCK_GETRATE = 42,
	PM_CLOCK_SETPARENT = 43,
	PM_CLOCK_GETPARENT = 44,
	PM_SECURE_AES = 47,
	PM_FEATURE_CHECK = 63,
};

enum pm_ret_status {
	XST_PM_SUCCESS = 0,
	XST_PM_NO_FEATURE = 19,
	XST_PM_INTERNAL = 2000,
	XST_PM_CONFLICT = 2001,
	XST_PM_NO_ACCESS = 2002,
	XST_PM_INVALID_NODE = 2003,
	XST_PM_DOUBLE_REQ = 2004,
	XST_PM_ABORT_SUSPEND = 2005,
	XST_PM_MULT_USER = 2008,
};

enum pm_ioctl_id {
	IOCTL_SD_DLL_RESET = 6,
	IOCTL_SET_SD_TAPDELAY = 7,
	IOCTL_SET_PLL_FRAC_MODE = 8,
	IOCTL_GET_PLL_FRAC_MODE = 9,
	IOCTL_SET_PLL_FRAC_DATA = 10,
	IOCTL_GET_PLL_FRAC_DATA = 11,
	IOCTL_WRITE_GGS = 12,
	IOCTL_READ_GGS = 13,
	IOCTL_WRITE_PGGS = 14,
	IOCTL_READ_PGGS = 15,
	IOCTL_SET_BOOT_HEALTH_STATUS = 17,
};

enum zynqmp_pm_shutdown_type {
	ZYNQMP_PM_SHUTDOWN_TYPE_SHUTDOWN = 0,
	ZYNQMP_PM_SHUTDOWN_TYPE_RESET = 1,
	ZYNQMP_PM_SHUTDOWN_TYPE_SETSCOPE_ONLY = 2,
};

enum zynqmp_pm_shutdown_subtype {
	ZYNQMP_PM_SHUTDOWN_SUBTYPE_SUBSYSTEM = 0,
	ZYNQMP_PM_SHUTDOWN_SUBTYPE_PS_ONLY = 1,
	ZYNQMP_PM_SHUTDOWN_SUBTYPE_SYSTEM = 2,
};

struct pm_api_feature_data {
	u32 pm_api_id;
	int feature_status;
	struct hlist_node hentry;
};

struct zynqmp_pm_shutdown_scope {
	const enum zynqmp_pm_shutdown_subtype subtype;
	const char *name;
};

struct of_timer_irq {
	int irq;
	int index;
	int percpu;
	const char *name;
	long unsigned int flags;
	irq_handler_t handler;
};

struct of_timer_base {
	void *base;
	const char *name;
	int index;
};

struct of_timer_clk {
	struct clk *clk;
	const char *name;
	int index;
	long unsigned int rate;
	long unsigned int period;
};

struct timer_of {
	unsigned int flags;
	struct device_node *np;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct clock_event_device clkevt;
	struct of_timer_base of_base;
	struct of_timer_irq of_irq;
	struct of_timer_clk of_clk;
	void *private_data;
	long: 64;
	long: 64;
};

typedef int (*of_init_fn_1_ret)(struct device_node *);

struct sh_timer_config {
	unsigned int channels_mask;
};

enum sh_cmt_model {
	SH_CMT_16BIT = 0,
	SH_CMT_32BIT = 1,
	SH_CMT_48BIT = 2,
	SH_CMT0_RCAR_GEN2 = 3,
	SH_CMT1_RCAR_GEN2 = 4,
};

struct sh_cmt_info {
	enum sh_cmt_model model;
	unsigned int channels_mask;
	long unsigned int width;
	u32 overflow_bit;
	u32 clear_bits;
	u32 (*read_control)(void *, long unsigned int);
	void (*write_control)(void *, long unsigned int, u32);
	u32 (*read_count)(void *, long unsigned int);
	void (*write_count)(void *, long unsigned int, u32);
};

struct sh_cmt_device;

struct sh_cmt_channel {
	struct sh_cmt_device *cmt;
	unsigned int index;
	unsigned int hwidx;
	void *iostart;
	void *ioctrl;
	unsigned int timer_bit;
	long unsigned int flags;
	u32 match_value;
	u32 next_match_value;
	u32 max_match_value;
	raw_spinlock_t lock;
	struct clock_event_device ced;
	struct clocksource cs;
	u64 total_cycles;
	bool cs_enabled;
	long: 56;
	long: 64;
	long: 64;
	long: 64;
};

struct sh_cmt_device {
	struct platform_device *pdev;
	const struct sh_cmt_info *info;
	void *mapbase;
	struct clk *clk;
	long unsigned int rate;
	raw_spinlock_t lock;
	struct sh_cmt_channel *channels;
	unsigned int num_channels;
	unsigned int hw_channels;
	bool has_clockevent;
	bool has_clocksource;
};

enum sh_tmu_model {
	SH_TMU = 0,
	SH_TMU_SH3 = 1,
};

struct sh_tmu_device;

struct sh_tmu_channel {
	struct sh_tmu_device *tmu;
	unsigned int index;
	void *base;
	int irq;
	long unsigned int periodic;
	long: 64;
	long: 64;
	long: 64;
	struct clock_event_device ced;
	struct clocksource cs;
	bool cs_enabled;
	unsigned int enable_count;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sh_tmu_device {
	struct platform_device *pdev;
	void *mapbase;
	struct clk *clk;
	long unsigned int rate;
	enum sh_tmu_model model;
	raw_spinlock_t lock;
	struct sh_tmu_channel *channels;
	unsigned int num_channels;
	bool has_clockevent;
	bool has_clocksource;
};

struct clocksource_mmio {
	void *reg;
	struct clocksource clksrc;
};

struct dw_apb_timer {
	void *base;
	long unsigned int freq;
	int irq;
};

struct dw_apb_clock_event_device {
	struct clock_event_device ced;
	struct dw_apb_timer timer;
	void (*eoi)(struct dw_apb_timer *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct dw_apb_clocksource {
	struct dw_apb_timer timer;
	struct clocksource cs;
};

struct rk_timer {
	void *base;
	void *ctrl;
	struct clk *clk;
	struct clk *pclk;
	u32 freq;
	int irq;
};

struct rk_clkevt {
	struct clock_event_device ce;
	struct rk_timer timer;
	long: 64;
	long: 64;
	long: 64;
};

enum arch_timer_reg {
	ARCH_TIMER_REG_CTRL = 0,
	ARCH_TIMER_REG_TVAL = 1,
};

enum arch_timer_spi_nr {
	ARCH_TIMER_PHYS_SPI = 0,
	ARCH_TIMER_VIRT_SPI = 1,
	ARCH_TIMER_MAX_TIMER_SPI = 2,
};

struct arch_timer {
	void *base;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct clock_event_device evt;
};

struct ate_acpi_oem_info {
	char oem_id[7];
	char oem_table_id[9];
	u32 oem_revision;
};

typedef bool (*ate_match_fn_t)(const struct arch_timer_erratum_workaround *, const void *);

struct sp804_timer {
	int load;
	int load_h;
	int value;
	int value_h;
	int ctrl;
	int intclr;
	int ris;
	int mis;
	int bgload;
	int bgload_h;
	int timer_base[2];
	int width;
};

struct sp804_clkevt {
	void *base;
	void *load;
	void *load_h;
	void *value;
	void *value_h;
	void *ctrl;
	void *intclr;
	void *ris;
	void *mis;
	void *bgload;
	void *bgload_h;
	long unsigned int reload;
	int width;
};

struct mchp_pit64b_timer {
	void *base;
	struct clk *pclk;
	struct clk *gclk;
	u32 mode;
};

struct mchp_pit64b_clkevt {
	struct mchp_pit64b_timer timer;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct clock_event_device clkevt;
};

struct mchp_pit64b_clksrc {
	struct mchp_pit64b_timer timer;
	struct clocksource clksrc;
};

struct alias_prop {
	struct list_head link;
	const char *alias;
	struct device_node *np;
	int id;
	char stem[0];
};

struct of_endpoint {
	unsigned int port;
	unsigned int id;
	const struct device_node *local_node;
};

struct supplier_bindings {
	struct device_node * (*parse_prop)(struct device_node *, const char *, int);
	bool optional;
	bool node_not_dev;
};

struct of_changeset_entry {
	struct list_head node;
	long unsigned int action;
	struct device_node *np;
	struct property *prop;
	struct property *old_prop;
};

struct of_changeset {
	struct list_head entries;
};

struct of_bus___2 {
	void (*count_cells)(const void *, int, int *, int *);
	u64 (*map)(__be32 *, const __be32 *, int, int, int);
	int (*translate)(__be32 *, u64, int);
};

struct of_bus {
	const char *name;
	const char *addresses;
	int (*match)(struct device_node *);
	void (*count_cells)(struct device_node *, int *, int *);
	u64 (*map)(__be32 *, const __be32 *, int, int, int);
	int (*translate)(__be32 *, u64, int);
	bool has_flags;
	unsigned int (*get_flags)(const __be32 *);
};

struct of_intc_desc {
	struct list_head list;
	of_irq_init_cb_t irq_init_cb;
	struct device_node *dev;
	struct device_node *interrupt_parent;
};

struct nvmem_cell;

struct rmem_assigned_device {
	struct device *dev;
	struct reserved_mem *rmem;
	struct list_head list;
};

enum of_overlay_notify_action {
	OF_OVERLAY_PRE_APPLY = 0,
	OF_OVERLAY_POST_APPLY = 1,
	OF_OVERLAY_PRE_REMOVE = 2,
	OF_OVERLAY_POST_REMOVE = 3,
};

struct of_overlay_notify_data {
	struct device_node *overlay;
	struct device_node *target;
};

struct target {
	struct device_node *np;
	bool in_livetree;
};

struct fragment {
	struct device_node *overlay;
	struct device_node *target;
};

struct overlay_changeset {
	int id;
	struct list_head ovcs_list;
	const void *fdt;
	struct device_node *overlay_tree;
	int count;
	struct fragment *fragments;
	bool symbols_fragment;
	struct of_changeset cset;
};

enum ec_status {
	EC_RES_SUCCESS = 0,
	EC_RES_INVALID_COMMAND = 1,
	EC_RES_ERROR = 2,
	EC_RES_INVALID_PARAM = 3,
	EC_RES_ACCESS_DENIED = 4,
	EC_RES_INVALID_RESPONSE = 5,
	EC_RES_INVALID_VERSION = 6,
	EC_RES_INVALID_CHECKSUM = 7,
	EC_RES_IN_PROGRESS = 8,
	EC_RES_UNAVAILABLE = 9,
	EC_RES_TIMEOUT = 10,
	EC_RES_OVERFLOW = 11,
	EC_RES_INVALID_HEADER = 12,
	EC_RES_REQUEST_TRUNCATED = 13,
	EC_RES_RESPONSE_TOO_BIG = 14,
	EC_RES_BUS_ERROR = 15,
	EC_RES_BUSY = 16,
	EC_RES_INVALID_HEADER_VERSION = 17,
	EC_RES_INVALID_HEADER_CRC = 18,
	EC_RES_INVALID_DATA_CRC = 19,
	EC_RES_DUP_UNAVAILABLE = 20,
};

enum host_event_code {
	EC_HOST_EVENT_LID_CLOSED = 1,
	EC_HOST_EVENT_LID_OPEN = 2,
	EC_HOST_EVENT_POWER_BUTTON = 3,
	EC_HOST_EVENT_AC_CONNECTED = 4,
	EC_HOST_EVENT_AC_DISCONNECTED = 5,
	EC_HOST_EVENT_BATTERY_LOW = 6,
	EC_HOST_EVENT_BATTERY_CRITICAL = 7,
	EC_HOST_EVENT_BATTERY = 8,
	EC_HOST_EVENT_THERMAL_THRESHOLD = 9,
	EC_HOST_EVENT_DEVICE = 10,
	EC_HOST_EVENT_THERMAL = 11,
	EC_HOST_EVENT_USB_CHARGER = 12,
	EC_HOST_EVENT_KEY_PRESSED = 13,
	EC_HOST_EVENT_INTERFACE_READY = 14,
	EC_HOST_EVENT_KEYBOARD_RECOVERY = 15,
	EC_HOST_EVENT_THERMAL_SHUTDOWN = 16,
	EC_HOST_EVENT_BATTERY_SHUTDOWN = 17,
	EC_HOST_EVENT_THROTTLE_START = 18,
	EC_HOST_EVENT_THROTTLE_STOP = 19,
	EC_HOST_EVENT_HANG_DETECT = 20,
	EC_HOST_EVENT_HANG_REBOOT = 21,
	EC_HOST_EVENT_PD_MCU = 22,
	EC_HOST_EVENT_BATTERY_STATUS = 23,
	EC_HOST_EVENT_PANIC = 24,
	EC_HOST_EVENT_KEYBOARD_FASTBOOT = 25,
	EC_HOST_EVENT_RTC = 26,
	EC_HOST_EVENT_MKBP = 27,
	EC_HOST_EVENT_USB_MUX = 28,
	EC_HOST_EVENT_MODE_CHANGE = 29,
	EC_HOST_EVENT_KEYBOARD_RECOVERY_HW_REINIT = 30,
	EC_HOST_EVENT_WOV = 31,
	EC_HOST_EVENT_INVALID = 32,
};

struct ec_host_request {
	uint8_t struct_version;
	uint8_t checksum;
	uint16_t command;
	uint8_t command_version;
	uint8_t reserved;
	uint16_t data_len;
};

struct ec_params_hello {
	uint32_t in_data;
};

struct ec_response_hello {
	uint32_t out_data;
};

struct ec_params_get_cmd_versions {
	uint8_t cmd;
};

struct ec_response_get_cmd_versions {
	uint32_t version_mask;
};

enum ec_comms_status {
	EC_COMMS_STATUS_PROCESSING = 1,
};

struct ec_response_get_comms_status {
	uint32_t flags;
};

struct ec_response_get_protocol_info {
	uint32_t protocol_versions;
	uint16_t max_request_packet_size;
	uint16_t max_response_packet_size;
	uint32_t flags;
};

enum ec_led_colors {
	EC_LED_COLOR_RED = 0,
	EC_LED_COLOR_GREEN = 1,
	EC_LED_COLOR_BLUE = 2,
	EC_LED_COLOR_YELLOW = 3,
	EC_LED_COLOR_WHITE = 4,
	EC_LED_COLOR_AMBER = 5,
	EC_LED_COLOR_COUNT = 6,
};

enum motionsense_command {
	MOTIONSENSE_CMD_DUMP = 0,
	MOTIONSENSE_CMD_INFO = 1,
	MOTIONSENSE_CMD_EC_RATE = 2,
	MOTIONSENSE_CMD_SENSOR_ODR = 3,
	MOTIONSENSE_CMD_SENSOR_RANGE = 4,
	MOTIONSENSE_CMD_KB_WAKE_ANGLE = 5,
	MOTIONSENSE_CMD_DATA = 6,
	MOTIONSENSE_CMD_FIFO_INFO = 7,
	MOTIONSENSE_CMD_FIFO_FLUSH = 8,
	MOTIONSENSE_CMD_FIFO_READ = 9,
	MOTIONSENSE_CMD_PERFORM_CALIB = 10,
	MOTIONSENSE_CMD_SENSOR_OFFSET = 11,
	MOTIONSENSE_CMD_LIST_ACTIVITIES = 12,
	MOTIONSENSE_CMD_SET_ACTIVITY = 13,
	MOTIONSENSE_CMD_LID_ANGLE = 14,
	MOTIONSENSE_CMD_FIFO_INT_ENABLE = 15,
	MOTIONSENSE_CMD_SPOOF = 16,
	MOTIONSENSE_CMD_TABLET_MODE_LID_ANGLE = 17,
	MOTIONSENSE_CMD_SENSOR_SCALE = 18,
	MOTIONSENSE_NUM_CMDS = 19,
};

struct ec_response_motion_sensor_data {
	uint8_t flags;
	uint8_t sensor_num;
	union {
		int16_t data[3];
		struct {
			uint16_t reserved;
			uint32_t timestamp;
		} __attribute__((packed));
		struct {
			uint8_t activity;
			uint8_t state;
			int16_t add_info[2];
		};
	};
} __attribute__((packed));

struct ec_response_motion_sense_fifo_info {
	uint16_t size;
	uint16_t count;
	uint32_t timestamp;
	uint16_t total_lost;
	uint16_t lost[0];
} __attribute__((packed));

struct ec_response_motion_sense_fifo_data {
	uint32_t number_data;
	struct ec_response_motion_sensor_data data[0];
};

struct ec_motion_sense_activity {
	uint8_t sensor_num;
	uint8_t activity;
	uint8_t enable;
	uint8_t reserved;
	uint16_t parameters[3];
};

struct ec_params_motion_sense {
	uint8_t cmd;
	union {
		struct {
			uint8_t max_sensor_count;
		} dump;
		struct {
			int16_t data;
		} kb_wake_angle;
		struct {
			uint8_t sensor_num;
		} info;
		struct {
			uint8_t sensor_num;
		} info_3;
		struct {
			uint8_t sensor_num;
		} data;
		struct {
			uint8_t sensor_num;
		} fifo_flush;
		struct {
			uint8_t sensor_num;
		} perform_calib;
		struct {
			uint8_t sensor_num;
		} list_activities;
		struct {
			uint8_t sensor_num;
			uint8_t roundup;
			uint16_t reserved;
			int32_t data;
		} ec_rate;
		struct {
			uint8_t sensor_num;
			uint8_t roundup;
			uint16_t reserved;
			int32_t data;
		} sensor_odr;
		struct {
			uint8_t sensor_num;
			uint8_t roundup;
			uint16_t reserved;
			int32_t data;
		} sensor_range;
		struct {
			uint8_t sensor_num;
			uint16_t flags;
			int16_t temp;
			int16_t offset[3];
		} __attribute__((packed)) sensor_offset;
		struct {
			uint8_t sensor_num;
			uint16_t flags;
			int16_t temp;
			uint16_t scale[3];
		} __attribute__((packed)) sensor_scale;
		struct {
			uint32_t max_data_vector;
		} fifo_read;
		struct ec_motion_sense_activity set_activity;
		struct {
			int8_t enable;
		} fifo_int_enable;
		struct {
			uint8_t sensor_id;
			uint8_t spoof_enable;
			uint8_t reserved;
			int16_t components[3];
		} __attribute__((packed)) spoof;
		struct {
			int16_t lid_angle;
			int16_t hys_degree;
		} tablet_mode_threshold;
	};
} __attribute__((packed));

struct ec_response_motion_sense {
	union {
		struct {
			uint8_t module_flags;
			uint8_t sensor_count;
			struct ec_response_motion_sensor_data sensor[0];
		} __attribute__((packed)) dump;
		struct {
			uint8_t type;
			uint8_t location;
			uint8_t chip;
		} info;
		struct {
			uint8_t type;
			uint8_t location;
			uint8_t chip;
			uint32_t min_frequency;
			uint32_t max_frequency;
			uint32_t fifo_max_event_count;
		} info_3;
		struct ec_response_motion_sensor_data data;
		struct {
			int32_t ret;
		} ec_rate;
		struct {
			int32_t ret;
		} sensor_odr;
		struct {
			int32_t ret;
		} sensor_range;
		struct {
			int32_t ret;
		} kb_wake_angle;
		struct {
			int32_t ret;
		} fifo_int_enable;
		struct {
			int32_t ret;
		} spoof;
		struct {
			int16_t temp;
			int16_t offset[3];
		} sensor_offset;
		struct {
			int16_t temp;
			int16_t offset[3];
		} perform_calib;
		struct {
			int16_t temp;
			uint16_t scale[3];
		} sensor_scale;
		struct ec_response_motion_sense_fifo_info fifo_info;
		struct ec_response_motion_sense_fifo_info fifo_flush;
		struct ec_response_motion_sense_fifo_data fifo_read;
		struct {
			uint16_t reserved;
			uint32_t enabled;
			uint32_t disabled;
		} __attribute__((packed)) list_activities;
		struct {
			uint16_t value;
		} lid_angle;
		struct {
			uint16_t lid_angle;
			uint16_t hys_degree;
		} tablet_mode_threshold;
	};
};

enum ec_temp_thresholds {
	EC_TEMP_THRESH_WARN = 0,
	EC_TEMP_THRESH_HIGH = 1,
	EC_TEMP_THRESH_HALT = 2,
	EC_TEMP_THRESH_COUNT = 3,
};

enum ec_mkbp_event {
	EC_MKBP_EVENT_KEY_MATRIX = 0,
	EC_MKBP_EVENT_HOST_EVENT = 1,
	EC_MKBP_EVENT_SENSOR_FIFO = 2,
	EC_MKBP_EVENT_BUTTON = 3,
	EC_MKBP_EVENT_SWITCH = 4,
	EC_MKBP_EVENT_FINGERPRINT = 5,
	EC_MKBP_EVENT_SYSRQ = 6,
	EC_MKBP_EVENT_HOST_EVENT64 = 7,
	EC_MKBP_EVENT_CEC_EVENT = 8,
	EC_MKBP_EVENT_CEC_MESSAGE = 9,
	EC_MKBP_EVENT_COUNT = 10,
};

union ec_response_get_next_data_v1 {
	uint8_t key_matrix[16];
	uint32_t host_event;
	uint64_t host_event64;
	struct {
		uint8_t reserved[3];
		struct ec_response_motion_sense_fifo_info info;
	} __attribute__((packed)) sensor_fifo;
	uint32_t buttons;
	uint32_t switches;
	uint32_t fp_events;
	uint32_t sysrq;
	uint32_t cec_events;
	uint8_t cec_message[16];
};

struct ec_response_get_next_event_v1 {
	uint8_t event_type;
	union ec_response_get_next_data_v1 data;
} __attribute__((packed));

struct ec_response_host_event_mask {
	uint32_t mask;
};

enum {
	EC_MSG_TX_HEADER_BYTES = 3,
	EC_MSG_TX_TRAILER_BYTES = 1,
	EC_MSG_TX_PROTO_BYTES = 4,
	EC_MSG_RX_PROTO_BYTES = 3,
	EC_PROTO2_MSG_BYTES = 256,
	EC_MAX_MSG_BYTES = 65536,
};

struct cros_ec_command {
	uint32_t version;
	uint32_t command;
	uint32_t outsize;
	uint32_t insize;
	uint32_t result;
	uint8_t data[0];
};

struct cros_ec_device {
	const char *phys_name;
	struct device *dev;
	bool was_wake_device;
	struct class *cros_class;
	int (*cmd_readmem)(struct cros_ec_device *, unsigned int, unsigned int, void *);
	u16 max_request;
	u16 max_response;
	u16 max_passthru;
	u16 proto_version;
	void *priv;
	int irq;
	u8 *din;
	u8 *dout;
	int din_size;
	int dout_size;
	bool wake_enabled;
	bool suspended;
	int (*cmd_xfer)(struct cros_ec_device *, struct cros_ec_command *);
	int (*pkt_xfer)(struct cros_ec_device *, struct cros_ec_command *);
	struct mutex lock;
	u8 mkbp_event_supported;
	bool host_sleep_v1;
	struct blocking_notifier_head event_notifier;
	struct ec_response_get_next_event_v1 event_data;
	int event_size;
	u32 host_event_wake_mask;
	u32 last_resume_result;
	ktime_t last_event_time;
	struct notifier_block notifier_ready;
	struct platform_device *ec;
	struct platform_device *pd;
};

struct cros_ec_debugfs;

struct cros_ec_dev {
	struct device class_dev;
	struct cros_ec_device *ec_dev;
	struct device *dev;
	struct cros_ec_debugfs *debug_info;
	bool has_kb_wake_angle;
	u16 cmd_offset;
	u32 features[2];
};

enum {
	CROS_EC_SENSOR_LAST_TS = 0,
	CROS_EC_SENSOR_NEW_TS = 1,
	CROS_EC_SENSOR_ALL_TS = 2,
};

struct cros_ec_sensors_ts_filter_state {
	s64 x_offset;
	s64 y_offset;
	s64 x_history[64];
	s64 y_history[64];
	s64 m_history[64];
	int history_len;
	s64 temp_buf[64];
	s64 median_m;
	s64 median_error;
};

struct trace_event_raw_cros_ec_request_start {
	struct trace_entry ent;
	uint32_t version;
	uint32_t offset;
	uint32_t command;
	uint32_t outsize;
	uint32_t insize;
	char __data[0];
};

struct trace_event_raw_cros_ec_request_done {
	struct trace_entry ent;
	uint32_t version;
	uint32_t offset;
	uint32_t command;
	uint32_t outsize;
	uint32_t insize;
	uint32_t result;
	int retval;
	char __data[0];
};

struct trace_event_raw_cros_ec_sensorhub_timestamp {
	struct trace_entry ent;
	u32 ec_sample_timestamp;
	u32 ec_fifo_timestamp;
	s64 fifo_timestamp;
	s64 current_timestamp;
	s64 current_time;
	s64 delta;
	char __data[0];
};

struct trace_event_raw_cros_ec_sensorhub_data {
	struct trace_entry ent;
	u32 ec_sensor_num;
	u32 ec_fifo_timestamp;
	s64 fifo_timestamp;
	s64 current_timestamp;
	s64 current_time;
	s64 delta;
	char __data[0];
};

struct trace_event_raw_cros_ec_sensorhub_filter {
	struct trace_entry ent;
	s64 dx;
	s64 dy;
	s64 median_m;
	s64 median_error;
	s64 history_len;
	s64 x;
	s64 y;
	char __data[0];
};

struct trace_event_data_offsets_cros_ec_request_start {};

struct trace_event_data_offsets_cros_ec_request_done {};

struct trace_event_data_offsets_cros_ec_sensorhub_timestamp {};

struct trace_event_data_offsets_cros_ec_sensorhub_data {};

struct trace_event_data_offsets_cros_ec_sensorhub_filter {};

typedef void (*btf_trace_cros_ec_request_start)(void *, struct cros_ec_command *);

typedef void (*btf_trace_cros_ec_request_done)(void *, struct cros_ec_command *, int);

typedef void (*btf_trace_cros_ec_sensorhub_timestamp)(void *, u32, u32, s64, s64, s64);

typedef void (*btf_trace_cros_ec_sensorhub_data)(void *, u32, u32, s64, s64, s64);

typedef void (*btf_trace_cros_ec_sensorhub_filter)(void *, struct cros_ec_sensors_ts_filter_state *, s64, s64);

struct rockchip_mbox_msg {
	u32 cmd;
	int rx_size;
};

struct rockchip_mbox_data {
	int num_chans;
};

struct rockchip_mbox;

struct rockchip_mbox_chan {
	int idx;
	int irq;
	struct rockchip_mbox_msg *msg;
	struct rockchip_mbox *mb;
};

struct rockchip_mbox {
	struct mbox_controller mbox;
	struct clk *pclk;
	void *mbox_base;
	u32 buf_size;
	struct rockchip_mbox_chan *chans;
};

struct acpi_table_pcct {
	struct acpi_table_header header;
	u32 flags;
	u64 reserved;
};

enum acpi_pcct_type {
	ACPI_PCCT_TYPE_GENERIC_SUBSPACE = 0,
	ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE = 1,
	ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2 = 2,
	ACPI_PCCT_TYPE_EXT_PCC_MASTER_SUBSPACE = 3,
	ACPI_PCCT_TYPE_EXT_PCC_SLAVE_SUBSPACE = 4,
	ACPI_PCCT_TYPE_HW_REG_COMM_SUBSPACE = 5,
	ACPI_PCCT_TYPE_RESERVED = 6,
};

struct acpi_pcct_subspace {
	struct acpi_subtable_header header;
	u8 reserved[6];
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
} __attribute__((packed));

struct acpi_pcct_hw_reduced_type2 {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved;
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
	struct acpi_generic_address platform_ack_register;
	u64 ack_preserve_mask;
	u64 ack_write_mask;
} __attribute__((packed));

struct bcm2835_mbox {
	void *regs;
	spinlock_t lock;
	struct mbox_controller controller;
};

struct ti_msgmgr_valid_queue_desc {
	u8 queue_id;
	u8 proxy_id;
	bool is_tx;
};

struct ti_msgmgr_desc {
	u8 queue_count;
	u8 max_message_size;
	u8 max_messages;
	u8 data_first_reg;
	u8 data_last_reg;
	u32 status_cnt_mask;
	u32 status_err_mask;
	bool tx_polled;
	int tx_poll_timeout_ms;
	const struct ti_msgmgr_valid_queue_desc *valid_queues;
	const char *data_region_name;
	const char *status_region_name;
	const char *ctrl_region_name;
	int num_valid_queues;
	bool is_sproxy;
};

struct ti_queue_inst {
	char name[30];
	u8 queue_id;
	u8 proxy_id;
	int irq;
	bool is_tx;
	void *queue_buff_start;
	void *queue_buff_end;
	void *queue_state;
	void *queue_ctrl;
	struct mbox_chan *chan;
	u32 *rx_buff;
};

struct ti_msgmgr_inst {
	struct device *dev;
	const struct ti_msgmgr_desc *desc;
	void *queue_proxy_region;
	void *queue_state_debug_region;
	void *queue_ctrl_region;
	u8 num_valid_queues;
	struct ti_queue_inst *qinsts;
	struct mbox_controller mbox;
	struct mbox_chan *chans;
};

struct zynqmp_ipi_mchan {
	int is_opened;
	void *req_buf;
	void *resp_buf;
	void *rx_buf;
	size_t req_buf_size;
	size_t resp_buf_size;
	unsigned int chan_type;
};

struct zynqmp_ipi_pdata;

struct zynqmp_ipi_mbox {
	struct zynqmp_ipi_pdata *pdata;
	struct device dev;
	u32 remote_id;
	struct mbox_controller mbox;
	struct zynqmp_ipi_mchan mchans[2];
};

struct zynqmp_ipi_pdata {
	struct device *dev;
	int irq;
	unsigned int method;
	u32 local_id;
	int num_mboxes;
	struct zynqmp_ipi_mbox *ipi_mboxes;
};

struct sun6i_msgbox {
	struct mbox_controller controller;
	struct clk *clk;
	spinlock_t lock;
	void *regs;
};

struct qcom_ipcc_chan_info {
	u16 client_id;
	u16 signal_id;
};

struct qcom_ipcc {
	struct device *dev;
	void *base;
	struct irq_domain *irq_domain;
	struct mbox_chan chan[48];
	struct qcom_ipcc_chan_info mchan[48];
	struct mbox_controller mbox;
	int irq;
};

struct hwspinlock___2;

struct hwspinlock_ops {
	int (*trylock)(struct hwspinlock___2 *);
	void (*unlock)(struct hwspinlock___2 *);
	void (*relax)(struct hwspinlock___2 *);
};

struct hwspinlock_device;

struct hwspinlock___2 {
	struct hwspinlock_device *bank;
	spinlock_t lock;
	void *priv;
};

struct hwspinlock_device {
	struct device *dev;
	const struct hwspinlock_ops *ops;
	int base_id;
	int num_locks;
	struct hwspinlock___2 lock[0];
};

struct resource_table {
	u32 ver;
	u32 num;
	u32 reserved[2];
	u32 offset[0];
};

struct fw_rsc_hdr {
	u32 type;
	u8 data[0];
};

enum fw_resource_type {
	RSC_CARVEOUT = 0,
	RSC_DEVMEM = 1,
	RSC_TRACE = 2,
	RSC_VDEV = 3,
	RSC_LAST = 4,
	RSC_VENDOR_START = 128,
	RSC_VENDOR_END = 512,
};

struct fw_rsc_carveout {
	u32 da;
	u32 pa;
	u32 len;
	u32 flags;
	u32 reserved;
	u8 name[32];
};

struct fw_rsc_devmem {
	u32 da;
	u32 pa;
	u32 len;
	u32 flags;
	u32 reserved;
	u8 name[32];
};

struct fw_rsc_trace {
	u32 da;
	u32 len;
	u32 reserved;
	u8 name[32];
};

struct fw_rsc_vdev_vring {
	u32 da;
	u32 align;
	u32 num;
	u32 notifyid;
	u32 pa;
};

struct fw_rsc_vdev {
	u32 id;
	u32 notifyid;
	u32 dfeatures;
	u32 gfeatures;
	u32 config_len;
	u8 status;
	u8 num_of_vrings;
	u8 reserved[2];
	struct fw_rsc_vdev_vring vring[0];
};

struct rproc;

struct rproc_mem_entry {
	void *va;
	bool is_iomem;
	dma_addr_t dma;
	size_t len;
	u32 da;
	void *priv;
	char name[32];
	struct list_head node;
	u32 rsc_offset;
	u32 flags;
	u32 of_resm_idx;
	int (*alloc)(struct rproc *, struct rproc_mem_entry *);
	int (*release)(struct rproc *, struct rproc_mem_entry *);
};

enum rproc_dump_mechanism {
	RPROC_COREDUMP_DISABLED = 0,
	RPROC_COREDUMP_ENABLED = 1,
	RPROC_COREDUMP_INLINE = 2,
};

struct rproc_ops;

struct rproc {
	struct list_head node;
	struct iommu_domain *domain;
	const char *name;
	const char *firmware;
	void *priv;
	struct rproc_ops *ops;
	struct device dev;
	atomic_t power;
	unsigned int state;
	enum rproc_dump_mechanism dump_conf;
	struct mutex lock;
	struct dentry *dbg_dir;
	struct list_head traces;
	int num_traces;
	struct list_head carveouts;
	struct list_head mappings;
	u64 bootaddr;
	struct list_head rvdevs;
	struct list_head subdevs;
	struct idr notifyids;
	int index;
	struct work_struct crash_handler;
	unsigned int crash_cnt;
	bool recovery_disabled;
	int max_notifyid;
	struct resource_table *table_ptr;
	struct resource_table *clean_table;
	struct resource_table *cached_table;
	size_t table_sz;
	bool has_iommu;
	bool auto_boot;
	struct list_head dump_segments;
	int nb_vdev;
	u8 elf_class;
	u16 elf_machine;
	struct cdev cdev;
	bool cdev_put_on_release;
};

enum rsc_handling_status {
	RSC_HANDLED = 0,
	RSC_IGNORED = 1,
};

struct rproc_ops {
	int (*prepare)(struct rproc *);
	int (*unprepare)(struct rproc *);
	int (*start)(struct rproc *);
	int (*stop)(struct rproc *);
	int (*attach)(struct rproc *);
	int (*detach)(struct rproc *);
	void (*kick)(struct rproc *, int);
	void * (*da_to_va)(struct rproc *, u64, size_t, bool *);
	int (*parse_fw)(struct rproc *, const struct firmware *);
	int (*handle_rsc)(struct rproc *, u32, void *, int, int);
	struct resource_table * (*find_loaded_rsc_table)(struct rproc *, const struct firmware *);
	struct resource_table * (*get_loaded_rsc_table)(struct rproc *, size_t *);
	int (*load)(struct rproc *, const struct firmware *);
	int (*sanity_check)(struct rproc *, const struct firmware *);
	u64 (*get_boot_addr)(struct rproc *, const struct firmware *);
	long unsigned int (*panic)(struct rproc *);
	void (*coredump)(struct rproc *);
};

enum rproc_state {
	RPROC_OFFLINE = 0,
	RPROC_SUSPENDED = 1,
	RPROC_RUNNING = 2,
	RPROC_CRASHED = 3,
	RPROC_DELETED = 4,
	RPROC_ATTACHED = 5,
	RPROC_DETACHED = 6,
	RPROC_LAST = 7,
};

enum rproc_crash_type {
	RPROC_MMUFAULT = 0,
	RPROC_WATCHDOG = 1,
	RPROC_FATAL_ERROR = 2,
};

struct rproc_subdev {
	struct list_head node;
	int (*prepare)(struct rproc_subdev *);
	int (*start)(struct rproc_subdev *);
	void (*stop)(struct rproc_subdev *, bool);
	void (*unprepare)(struct rproc_subdev *);
};

struct rproc_vdev;

struct rproc_vring {
	void *va;
	int len;
	u32 da;
	u32 align;
	int notifyid;
	struct rproc_vdev *rvdev;
	struct virtqueue *vq;
};

struct rproc_vdev {
	struct kref refcount;
	struct rproc_subdev subdev;
	struct device dev;
	unsigned int id;
	struct list_head node;
	struct rproc *rproc;
	struct rproc_vring vring[2];
	u32 rsc_offset;
	u32 index;
};

struct rproc_debug_trace {
	struct rproc *rproc;
	struct dentry *tfile;
	struct list_head node;
	struct rproc_mem_entry trace_mem;
};

typedef int (*rproc_handle_resource_t)(struct rproc *, void *, int, int);

struct rproc_dump_segment {
	struct list_head node;
	dma_addr_t da;
	size_t size;
	void *priv;
	void (*dump)(struct rproc *, struct rproc_dump_segment *, void *, size_t, size_t);
	loff_t offset;
};

struct rproc_coredump_state {
	struct rproc *rproc;
	void *header;
	struct completion dump_done;
};

struct devfreq_freqs {
	long unsigned int old;
	long unsigned int new;
};

struct devfreq_passive_data {
	struct devfreq *parent;
	int (*get_target_freq)(struct devfreq *, long unsigned int *);
	struct devfreq *this;
	struct notifier_block nb;
};

struct trace_event_raw_devfreq_frequency {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	long unsigned int freq;
	long unsigned int prev_freq;
	long unsigned int busy_time;
	long unsigned int total_time;
	char __data[0];
};

struct trace_event_raw_devfreq_monitor {
	struct trace_entry ent;
	long unsigned int freq;
	long unsigned int busy_time;
	long unsigned int total_time;
	unsigned int polling_ms;
	u32 __data_loc_dev_name;
	char __data[0];
};

struct trace_event_data_offsets_devfreq_frequency {
	u32 dev_name;
};

struct trace_event_data_offsets_devfreq_monitor {
	u32 dev_name;
};

typedef void (*btf_trace_devfreq_frequency)(void *, struct devfreq *, long unsigned int, long unsigned int);

typedef void (*btf_trace_devfreq_monitor)(void *, struct devfreq *);

struct devfreq_notifier_devres {
	struct devfreq *devfreq;
	struct notifier_block *nb;
	unsigned int list;
};

struct devfreq_event_desc;

struct devfreq_event_dev {
	struct list_head node;
	struct device dev;
	struct mutex lock;
	u32 enable_count;
	const struct devfreq_event_desc *desc;
};

struct devfreq_event_ops;

struct devfreq_event_desc {
	const char *name;
	u32 event_type;
	void *driver_data;
	const struct devfreq_event_ops *ops;
};

struct devfreq_event_data {
	long unsigned int load_count;
	long unsigned int total_count;
};

struct devfreq_event_ops {
	int (*enable)(struct devfreq_event_dev *);
	int (*disable)(struct devfreq_event_dev *);
	int (*reset)(struct devfreq_event_dev *);
	int (*set_event)(struct devfreq_event_dev *);
	int (*get_event)(struct devfreq_event_dev *, struct devfreq_event_data *);
};

struct devfreq_simple_ondemand_data {
	unsigned int upthreshold;
	unsigned int downdifferential;
};

struct userspace_data {
	long unsigned int user_frequency;
	bool valid;
};

union extcon_property_value {
	int intval;
};

struct extcon_cable;

struct extcon_dev___2 {
	const char *name;
	const unsigned int *supported_cable;
	const u32 *mutually_exclusive;
	struct device dev;
	struct raw_notifier_head nh_all;
	struct raw_notifier_head *nh;
	struct list_head entry;
	int max_supported;
	spinlock_t lock;
	u32 state;
	struct device_type extcon_dev_type;
	struct extcon_cable *cables;
	struct attribute_group attr_g_muex;
	struct attribute **attrs_muex;
	struct device_attribute *d_attrs_muex;
};

struct extcon_cable {
	struct extcon_dev___2 *edev;
	int cable_index;
	struct attribute_group attr_g;
	struct device_attribute attr_name;
	struct device_attribute attr_state;
	struct attribute *attrs[3];
	union extcon_property_value usb_propval[3];
	union extcon_property_value chg_propval[1];
	union extcon_property_value jack_propval[1];
	union extcon_property_value disp_propval[2];
	long unsigned int usb_bits[1];
	long unsigned int chg_bits[1];
	long unsigned int jack_bits[1];
	long unsigned int disp_bits[1];
};

struct __extcon_info {
	unsigned int type;
	unsigned int id;
	const char *name;
};

struct extcon_dev_notifier_devres {
	struct extcon_dev___2 *edev;
	unsigned int id;
	struct notifier_block *nb;
};

enum dpfe_msg_fields {
	MSG_HEADER = 0,
	MSG_COMMAND = 1,
	MSG_ARG_COUNT = 2,
	MSG_ARG0 = 3,
	MSG_FIELD_MAX = 16,
};

enum dpfe_commands {
	DPFE_CMD_GET_INFO = 0,
	DPFE_CMD_GET_REFRESH = 1,
	DPFE_CMD_GET_VENDOR = 2,
	DPFE_CMD_MAX = 3,
};

struct dpfe_firmware_header {
	u32 magic;
	u32 sequence;
	u32 version;
	u32 imem_size;
	u32 dmem_size;
};

struct init_data {
	unsigned int dmem_len;
	unsigned int imem_len;
	unsigned int chksum;
	bool is_big_endian;
};

struct dpfe_api {
	int version;
	const char *fw_name;
	const struct attribute_group **sysfs_attrs;
	u32 command[48];
};

struct brcmstb_dpfe_priv {
	void *regs;
	void *dmem;
	void *imem;
	struct device *dev;
	const struct dpfe_api *dpfe_api;
	struct mutex lock;
};

struct fsl_ifc_nand {
	__be32 ncfgr;
	u32 res1[4];
	__be32 nand_fcr0;
	__be32 nand_fcr1;
	u32 res2[8];
	__be32 row0;
	u32 res3;
	__be32 col0;
	u32 res4;
	__be32 row1;
	u32 res5;
	__be32 col1;
	u32 res6;
	__be32 row2;
	u32 res7;
	__be32 col2;
	u32 res8;
	__be32 row3;
	u32 res9;
	__be32 col3;
	u32 res10[36];
	__be32 nand_fbcr;
	u32 res11;
	__be32 nand_fir0;
	__be32 nand_fir1;
	__be32 nand_fir2;
	u32 res12[16];
	__be32 nand_csel;
	u32 res13;
	__be32 nandseq_strt;
	u32 res14;
	__be32 nand_evter_stat;
	u32 res15;
	__be32 pgrdcmpl_evt_stat;
	u32 res16[2];
	__be32 nand_evter_en;
	u32 res17[2];
	__be32 nand_evter_intr_en;
	__be32 nand_vol_addr_stat;
	u32 res18;
	__be32 nand_erattr0;
	__be32 nand_erattr1;
	u32 res19[16];
	__be32 nand_fsr;
	u32 res20;
	__be32 nand_eccstat[8];
	u32 res21[28];
	__be32 nanndcr;
	u32 res22[2];
	__be32 nand_autoboot_trgr;
	u32 res23;
	__be32 nand_mdr;
	u32 res24[28];
	__be32 nand_dll_lowcfg0;
	__be32 nand_dll_lowcfg1;
	u32 res25;
	__be32 nand_dll_lowstat;
	u32 res26[60];
};

struct fsl_ifc_nor {
	__be32 nor_evter_stat;
	u32 res1[2];
	__be32 nor_evter_en;
	u32 res2[2];
	__be32 nor_evter_intr_en;
	u32 res3[2];
	__be32 nor_erattr0;
	__be32 nor_erattr1;
	__be32 nor_erattr2;
	u32 res4[4];
	__be32 norcr;
	u32 res5[239];
};

struct fsl_ifc_gpcm {
	__be32 gpcm_evter_stat;
	u32 res1[2];
	__be32 gpcm_evter_en;
	u32 res2[2];
	__be32 gpcm_evter_intr_en;
	u32 res3[2];
	__be32 gpcm_erattr0;
	__be32 gpcm_erattr1;
	__be32 gpcm_erattr2;
	__be32 gpcm_stat;
};

struct fsl_ifc_global {
	__be32 ifc_rev;
	u32 res1[2];
	struct {
		__be32 cspr_ext;
		__be32 cspr;
		u32 res2;
	} cspr_cs[8];
	u32 res3[13];
	struct {
		__be32 amask;
		u32 res4[2];
	} amask_cs[8];
	u32 res5[12];
	struct {
		__be32 csor;
		__be32 csor_ext;
		u32 res6;
	} csor_cs[8];
	u32 res7[12];
	struct {
		__be32 ftim[4];
		u32 res8[8];
	} ftim_cs[8];
	u32 res9[48];
	__be32 rb_stat;
	__be32 rb_map;
	__be32 wb_map;
	__be32 ifc_gcr;
	u32 res10[2];
	__be32 cm_evter_stat;
	u32 res11[2];
	__be32 cm_evter_en;
	u32 res12[2];
	__be32 cm_evter_intr_en;
	u32 res13[2];
	__be32 cm_erattr0;
	__be32 cm_erattr1;
	u32 res14[2];
	__be32 ifc_ccr;
	__be32 ifc_csr;
	__be32 ddr_ccr_low;
};

struct fsl_ifc_runtime {
	struct fsl_ifc_nand ifc_nand;
	struct fsl_ifc_nor ifc_nor;
	struct fsl_ifc_gpcm ifc_gpcm;
};

struct fsl_ifc_ctrl {
	struct device *dev;
	struct fsl_ifc_global *gregs;
	struct fsl_ifc_runtime *rregs;
	int irq;
	int nand_irq;
	spinlock_t lock;
	void *nand;
	int version;
	int banks;
	u32 nand_stat;
	wait_queue_head_t nand_wait;
	bool little_endian;
};

enum vme_resource_type {
	VME_MASTER = 0,
	VME_SLAVE = 1,
	VME_DMA = 2,
	VME_LM = 3,
};

struct vme_dma_attr {
	u32 type;
	void *private;
};

struct vme_resource {
	enum vme_resource_type type;
	struct list_head *entry;
};

struct vme_bridge;

struct vme_dev {
	int num;
	struct vme_bridge *bridge;
	struct device dev;
	struct list_head drv_list;
	struct list_head bridge_list;
};

struct vme_callback {
	void (*func)(int, int, void *);
	void *priv_data;
};

struct vme_irq {
	int count;
	struct vme_callback callback[256];
};

struct vme_slave_resource;

struct vme_master_resource;

struct vme_dma_list;

struct vme_lm_resource;

struct vme_bridge {
	char name[16];
	int num;
	struct list_head master_resources;
	struct list_head slave_resources;
	struct list_head dma_resources;
	struct list_head lm_resources;
	struct list_head vme_error_handlers;
	struct list_head devices;
	struct device *parent;
	void *driver_priv;
	struct list_head bus_list;
	struct vme_irq irq[7];
	struct mutex irq_mtx;
	int (*slave_get)(struct vme_slave_resource *, int *, long long unsigned int *, long long unsigned int *, dma_addr_t *, u32 *, u32 *);
	int (*slave_set)(struct vme_slave_resource *, int, long long unsigned int, long long unsigned int, dma_addr_t, u32, u32);
	int (*master_get)(struct vme_master_resource *, int *, long long unsigned int *, long long unsigned int *, u32 *, u32 *, u32 *);
	int (*master_set)(struct vme_master_resource *, int, long long unsigned int, long long unsigned int, u32, u32, u32);
	ssize_t (*master_read)(struct vme_master_resource *, void *, size_t, loff_t);
	ssize_t (*master_write)(struct vme_master_resource *, void *, size_t, loff_t);
	unsigned int (*master_rmw)(struct vme_master_resource *, unsigned int, unsigned int, unsigned int, loff_t);
	int (*dma_list_add)(struct vme_dma_list *, struct vme_dma_attr *, struct vme_dma_attr *, size_t);
	int (*dma_list_exec)(struct vme_dma_list *);
	int (*dma_list_empty)(struct vme_dma_list *);
	void (*irq_set)(struct vme_bridge *, int, int, int);
	int (*irq_generate)(struct vme_bridge *, int, int);
	int (*lm_set)(struct vme_lm_resource *, long long unsigned int, u32, u32);
	int (*lm_get)(struct vme_lm_resource *, long long unsigned int *, u32 *, u32 *);
	int (*lm_attach)(struct vme_lm_resource *, int, void (*)(void *), void *);
	int (*lm_detach)(struct vme_lm_resource *, int);
	int (*slot_get)(struct vme_bridge *);
	void * (*alloc_consistent)(struct device *, size_t, dma_addr_t *);
	void (*free_consistent)(struct device *, size_t, void *, dma_addr_t);
};

struct vme_driver {
	const char *name;
	int (*match)(struct vme_dev *);
	int (*probe)(struct vme_dev *);
	void (*remove)(struct vme_dev *);
	struct device_driver driver;
	struct list_head devices;
};

struct vme_master_resource {
	struct list_head list;
	struct vme_bridge *parent;
	spinlock_t lock;
	int locked;
	int number;
	u32 address_attr;
	u32 cycle_attr;
	u32 width_attr;
	struct resource bus_resource;
	void *kern_base;
};

struct vme_slave_resource {
	struct list_head list;
	struct vme_bridge *parent;
	struct mutex mtx;
	int locked;
	int number;
	u32 address_attr;
	u32 cycle_attr;
};

struct vme_dma_pattern {
	u32 pattern;
	u32 type;
};

struct vme_dma_pci {
	dma_addr_t address;
};

struct vme_dma_vme {
	long long unsigned int address;
	u32 aspace;
	u32 cycle;
	u32 dwidth;
};

struct vme_dma_resource;

struct vme_dma_list {
	struct list_head list;
	struct vme_dma_resource *parent;
	struct list_head entries;
	struct mutex mtx;
};

struct vme_dma_resource {
	struct list_head list;
	struct vme_bridge *parent;
	struct mutex mtx;
	int locked;
	int number;
	struct list_head pending;
	struct list_head running;
	u32 route_attr;
};

struct vme_lm_resource {
	struct list_head list;
	struct vme_bridge *parent;
	struct mutex mtx;
	int locked;
	int number;
	int monitors;
};

struct vme_error_handler {
	struct list_head list;
	long long unsigned int start;
	long long unsigned int end;
	long long unsigned int first_error;
	u32 aspace;
	unsigned int num_errors;
};

struct powercap_control_type;

struct powercap_control_type_ops {
	int (*set_enable)(struct powercap_control_type *, bool);
	int (*get_enable)(struct powercap_control_type *, bool *);
	int (*release)(struct powercap_control_type *);
};

struct powercap_control_type {
	struct device dev;
	struct idr idr;
	int nr_zones;
	const struct powercap_control_type_ops *ops;
	struct mutex lock;
	bool allocated;
	struct list_head node;
};

struct powercap_zone;

struct powercap_zone_ops {
	int (*get_max_energy_range_uj)(struct powercap_zone *, u64 *);
	int (*get_energy_uj)(struct powercap_zone *, u64 *);
	int (*reset_energy_uj)(struct powercap_zone *);
	int (*get_max_power_range_uw)(struct powercap_zone *, u64 *);
	int (*get_power_uw)(struct powercap_zone *, u64 *);
	int (*set_enable)(struct powercap_zone *, bool);
	int (*get_enable)(struct powercap_zone *, bool *);
	int (*release)(struct powercap_zone *);
};

struct powercap_zone_constraint;

struct powercap_zone {
	int id;
	char *name;
	void *control_type_inst;
	const struct powercap_zone_ops *ops;
	struct device dev;
	int const_id_cnt;
	struct idr idr;
	struct idr *parent_idr;
	void *private_data;
	struct attribute **zone_dev_attrs;
	int zone_attr_count;
	struct attribute_group dev_zone_attr_group;
	const struct attribute_group *dev_attr_groups[2];
	bool allocated;
	struct powercap_zone_constraint *constraints;
};

struct powercap_zone_constraint_ops;

struct powercap_zone_constraint {
	int id;
	struct powercap_zone *power_zone;
	const struct powercap_zone_constraint_ops *ops;
};

struct powercap_zone_constraint_ops {
	int (*set_power_limit_uw)(struct powercap_zone *, int, u64);
	int (*get_power_limit_uw)(struct powercap_zone *, int, u64 *);
	int (*set_time_window_us)(struct powercap_zone *, int, u64);
	int (*get_time_window_us)(struct powercap_zone *, int, u64 *);
	int (*get_max_power_uw)(struct powercap_zone *, int, u64 *);
	int (*get_min_power_uw)(struct powercap_zone *, int, u64 *);
	int (*get_max_time_window_us)(struct powercap_zone *, int, u64 *);
	int (*get_min_time_window_us)(struct powercap_zone *, int, u64 *);
	const char * (*get_name)(struct powercap_zone *, int);
};

struct powercap_constraint_attr {
	struct device_attribute power_limit_attr;
	struct device_attribute time_window_attr;
	struct device_attribute max_power_attr;
	struct device_attribute min_power_attr;
	struct device_attribute max_time_window_attr;
	struct device_attribute min_time_window_attr;
	struct device_attribute name_attr;
};

struct idle_inject_thread {
	struct task_struct *tsk;
	int should_run;
};

struct idle_inject_device___2 {
	struct hrtimer timer;
	unsigned int idle_duration_us;
	unsigned int run_duration_us;
	unsigned int latency_us;
	long unsigned int cpumask[0];
};

enum {
	CCI_IF_SLAVE = 0,
	CCI_IF_MASTER = 1,
	CCI_IF_GLOBAL = 2,
	CCI_IF_MAX = 3,
};

struct event_range {
	u32 min;
	u32 max;
};

struct cci_pmu_hw_events {
	struct perf_event **events;
	long unsigned int *used_mask;
	raw_spinlock_t pmu_lock;
};

struct cci_pmu;

struct cci_pmu_model {
	char *name;
	u32 fixed_hw_cntrs;
	u32 num_hw_cntrs;
	u32 cntr_size;
	struct attribute **format_attrs;
	struct attribute **event_attrs;
	struct event_range event_ranges[3];
	int (*validate_hw_event)(struct cci_pmu *, long unsigned int);
	int (*get_event_idx)(struct cci_pmu *, struct cci_pmu_hw_events *, long unsigned int);
	void (*write_counters)(struct cci_pmu *, long unsigned int *);
};

struct cci_pmu {
	void *base;
	void *ctrl_base;
	struct pmu pmu;
	int cpu;
	int nr_irqs;
	int *irqs;
	long unsigned int active_irqs;
	const struct cci_pmu_model *model;
	struct cci_pmu_hw_events hw_events;
	struct platform_device *plat_device;
	int num_cntrs;
	atomic_t active_events;
	struct mutex reserve_mutex;
};

enum cci_models {
	CCI400_R0 = 0,
	CCI400_R1 = 1,
	CCI500_R0 = 2,
	CCI550_R0 = 3,
	CCI_MODEL_MAX = 4,
};

enum cci400_perf_events {
	CCI400_PMU_CYCLES = 255,
};

struct arm_ccn_component {
	void *base;
	u32 type;
	long unsigned int pmu_events_mask[1];
	union {
		struct {
			long unsigned int dt_cmp_mask[1];
		} xp;
	};
};

struct arm_ccn_dt {
	int id;
	void *base;
	spinlock_t config_lock;
	long unsigned int pmu_counters_mask[1];
	struct {
		struct arm_ccn_component *source;
		struct perf_event *event;
	} pmu_counters[9];
	struct {
		u64 l;
		u64 h;
	} cmp_mask[12];
	struct hrtimer hrtimer;
	unsigned int cpu;
	struct hlist_node node;
	struct pmu pmu;
};

struct arm_ccn {
	struct device *dev;
	void *base;
	unsigned int irq;
	unsigned int sbas_present: 1;
	unsigned int sbsx_present: 1;
	int num_nodes;
	struct arm_ccn_component *node;
	int num_xps;
	struct arm_ccn_component *xp;
	struct arm_ccn_dt dt;
	int mn_id;
};

struct arm_ccn_pmu_event {
	struct device_attribute attr;
	u32 type;
	u32 event;
	int num_ports;
	int num_vcs;
	const char *def;
	int mask;
};

struct pmu_irq_ops {
	void (*enable_pmuirq)(unsigned int);
	void (*disable_pmuirq)(unsigned int);
	void (*free_pmuirq)(unsigned int, int, void *);
};

typedef int (*armpmu_init_fn)(struct arm_pmu *);

struct pmu_probe_info {
	unsigned int cpuid;
	unsigned int mask;
	armpmu_init_fn init;
};

struct hisi_pmu;

struct hisi_uncore_ops {
	void (*write_evtype)(struct hisi_pmu *, int, u32);
	int (*get_event_idx)(struct perf_event *);
	u64 (*read_counter)(struct hisi_pmu *, struct hw_perf_event *);
	void (*write_counter)(struct hisi_pmu *, struct hw_perf_event *, u64);
	void (*enable_counter)(struct hisi_pmu *, struct hw_perf_event *);
	void (*disable_counter)(struct hisi_pmu *, struct hw_perf_event *);
	void (*enable_counter_int)(struct hisi_pmu *, struct hw_perf_event *);
	void (*disable_counter_int)(struct hisi_pmu *, struct hw_perf_event *);
	void (*start_counters)(struct hisi_pmu *);
	void (*stop_counters)(struct hisi_pmu *);
	u32 (*get_int_status)(struct hisi_pmu *);
	void (*clear_int_status)(struct hisi_pmu *, int);
	void (*enable_filter)(struct perf_event *);
	void (*disable_filter)(struct perf_event *);
};

struct hisi_pmu_hwevents {
	struct perf_event *hw_events[16];
	long unsigned int used_mask[1];
	const struct attribute_group **attr_groups;
};

struct hisi_pmu {
	struct pmu pmu;
	const struct hisi_uncore_ops *ops;
	struct hisi_pmu_hwevents pmu_events;
	cpumask_t associated_cpus;
	int on_cpu;
	int irq;
	struct device *dev;
	struct hlist_node node;
	int sccl_id;
	int ccl_id;
	void *base;
	u32 index_id;
	u32 sub_id;
	int num_counters;
	int counter_bits;
	int check_event;
	u32 identifier;
};

struct cluster_pmu;

struct l2cache_pmu {
	struct hlist_node node;
	u32 num_pmus;
	struct pmu pmu;
	int num_counters;
	cpumask_t cpumask;
	struct platform_device *pdev;
	struct cluster_pmu **pmu_cluster;
	struct list_head clusters;
};

struct cluster_pmu {
	struct list_head next;
	struct perf_event *events[9];
	struct l2cache_pmu *l2cache_pmu;
	long unsigned int used_counters[1];
	long unsigned int used_groups[1];
	int irq;
	int cluster_id;
	int on_cpu;
	cpumask_t cluster_cpus;
	spinlock_t pmu_lock;
};

struct l3cache_pmu {
	struct pmu pmu;
	struct hlist_node node;
	void *regs;
	struct perf_event *events[8];
	long unsigned int used_mask[1];
	cpumask_t cpumask;
};

struct l3cache_event_ops {
	void (*start)(struct perf_event *);
	void (*stop)(struct perf_event *, int);
	void (*update)(struct perf_event *);
};

struct hw_pmu_info {
	u32 type;
	u32 enable_mask;
	void *csr;
};

struct xgene_pmu;

struct xgene_pmu_dev {
	struct hw_pmu_info *inf;
	struct xgene_pmu *parent;
	struct pmu pmu;
	u8 max_counters;
	long unsigned int cntr_assign_mask[1];
	u64 max_period;
	const struct attribute_group **attr_groups;
	struct perf_event *pmu_counter_event[4];
};

struct xgene_pmu_ops;

struct xgene_pmu {
	struct device *dev;
	struct hlist_node node;
	int version;
	void *pcppmu_csr;
	u32 mcb_active_mask;
	u32 mc_active_mask;
	u32 l3c_active_mask;
	cpumask_t cpu;
	int irq;
	raw_spinlock_t lock;
	const struct xgene_pmu_ops *ops;
	struct list_head l3cpmus;
	struct list_head iobpmus;
	struct list_head mcbpmus;
	struct list_head mcpmus;
};

struct xgene_pmu_ops {
	void (*mask_int)(struct xgene_pmu *);
	void (*unmask_int)(struct xgene_pmu *);
	u64 (*read_counter)(struct xgene_pmu_dev *, int);
	void (*write_counter)(struct xgene_pmu_dev *, int, u64);
	void (*write_evttype)(struct xgene_pmu_dev *, int, u32);
	void (*write_agentmsk)(struct xgene_pmu_dev *, u32);
	void (*write_agent1msk)(struct xgene_pmu_dev *, u32);
	void (*enable_counter)(struct xgene_pmu_dev *, int);
	void (*disable_counter)(struct xgene_pmu_dev *, int);
	void (*enable_counter_int)(struct xgene_pmu_dev *, int);
	void (*disable_counter_int)(struct xgene_pmu_dev *, int);
	void (*reset_counters)(struct xgene_pmu_dev *);
	void (*start_counters)(struct xgene_pmu_dev *);
	void (*stop_counters)(struct xgene_pmu_dev *);
};

struct xgene_pmu_dev_ctx {
	char *name;
	struct list_head next;
	struct xgene_pmu_dev *pmu_dev;
	struct hw_pmu_info inf;
};

struct xgene_pmu_data {
	int id;
	u32 data;
};

enum xgene_pmu_version {
	PCP_PMU_V1 = 1,
	PCP_PMU_V2 = 2,
	PCP_PMU_V3 = 3,
};

enum xgene_pmu_dev_type {
	PMU_TYPE_L3C = 0,
	PMU_TYPE_IOB = 1,
	PMU_TYPE_IOB_SLOW = 2,
	PMU_TYPE_MCB = 3,
	PMU_TYPE_MC = 4,
};

struct trace_event_raw_mc_event {
	struct trace_entry ent;
	unsigned int error_type;
	u32 __data_loc_msg;
	u32 __data_loc_label;
	u16 error_count;
	u8 mc_index;
	s8 top_layer;
	s8 middle_layer;
	s8 lower_layer;
	long int address;
	u8 grain_bits;
	long int syndrome;
	u32 __data_loc_driver_detail;
	char __data[0];
};

struct trace_event_raw_arm_event {
	struct trace_entry ent;
	u64 mpidr;
	u64 midr;
	u32 running_state;
	u32 psci_state;
	u8 affinity;
	char __data[0];
};

struct trace_event_raw_non_standard_event {
	struct trace_entry ent;
	char sec_type[16];
	char fru_id[16];
	u32 __data_loc_fru_text;
	u8 sev;
	u32 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_aer_event {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 status;
	u8 severity;
	u8 tlp_header_valid;
	u32 tlp_header[4];
	char __data[0];
};

struct trace_event_raw_memory_failure_event {
	struct trace_entry ent;
	long unsigned int pfn;
	int type;
	int result;
	char __data[0];
};

struct trace_event_data_offsets_mc_event {
	u32 msg;
	u32 label;
	u32 driver_detail;
};

struct trace_event_data_offsets_arm_event {};

struct trace_event_data_offsets_non_standard_event {
	u32 fru_text;
	u32 buf;
};

struct trace_event_data_offsets_aer_event {
	u32 dev_name;
};

struct trace_event_data_offsets_memory_failure_event {};

typedef void (*btf_trace_mc_event)(void *, const unsigned int, const char *, const char *, const int, const u8, const s8, const s8, const s8, long unsigned int, const u8, long unsigned int, const char *);

typedef void (*btf_trace_arm_event)(void *, const struct cper_sec_proc_arm *);

typedef void (*btf_trace_non_standard_event)(void *, const guid_t *, const guid_t *, const char *, const u8, const u8 *, const u32);

typedef void (*btf_trace_aer_event)(void *, const char *, const u32, const u8, const u8, struct aer_header_log_regs *);

typedef void (*btf_trace_memory_failure_event)(void *, long unsigned int, int, int);

struct nvmem_cell_lookup {
	const char *nvmem_name;
	const char *cell_name;
	const char *dev_id;
	const char *con_id;
	struct list_head node;
};

enum {
	NVMEM_ADD = 1,
	NVMEM_REMOVE = 2,
	NVMEM_CELL_ADD = 3,
	NVMEM_CELL_REMOVE = 4,
};

struct nvmem_cell_table {
	const char *nvmem_name;
	const struct nvmem_cell_info *cells;
	size_t ncells;
	struct list_head node;
};

struct nvmem_device___2 {
	struct module *owner;
	struct device dev;
	int stride;
	int word_size;
	int id;
	struct kref refcnt;
	size_t size;
	bool read_only;
	bool root_only;
	int flags;
	enum nvmem_type type;
	struct bin_attribute eeprom;
	struct device *base_dev;
	struct list_head cells;
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	struct gpio_desc *wp_gpio;
	void *priv;
};

struct nvmem_cell___2 {
	const char *name;
	int offset;
	int bytes;
	int bit_offset;
	int nbits;
	struct device_node *np;
	struct nvmem_device___2 *nvmem;
	struct list_head node;
};

struct zynqmp_nvmem_data {
	struct device *dev;
	struct nvmem_device *nvmem;
};

struct icc_node;

struct icc_req {
	struct hlist_node req_node;
	struct icc_node *node;
	struct device *dev;
	bool enabled;
	u32 tag;
	u32 avg_bw;
	u32 peak_bw;
};

struct icc_path___2 {
	const char *name;
	size_t num_nodes;
	struct icc_req reqs[0];
};

struct icc_node_data {
	struct icc_node *node;
	u32 tag;
};

struct icc_provider;

struct icc_node {
	int id;
	const char *name;
	struct icc_node **links;
	size_t num_links;
	struct icc_provider *provider;
	struct list_head node_list;
	struct list_head search_list;
	struct icc_node *reverse;
	u8 is_traversed: 1;
	struct hlist_head req_list;
	u32 avg_bw;
	u32 peak_bw;
	u32 init_avg;
	u32 init_peak;
	void *data;
};

struct icc_onecell_data {
	unsigned int num_nodes;
	struct icc_node *nodes[0];
};

struct icc_provider {
	struct list_head provider_list;
	struct list_head nodes;
	int (*set)(struct icc_node *, struct icc_node *);
	int (*aggregate)(struct icc_node *, u32, u32, u32, u32 *, u32 *);
	void (*pre_aggregate)(struct icc_node *);
	int (*get_bw)(struct icc_node *, u32 *, u32 *);
	struct icc_node * (*xlate)(struct of_phandle_args *, void *);
	struct icc_node_data * (*xlate_extended)(struct of_phandle_args *, void *);
	struct device *dev;
	int users;
	bool inter_set;
	void *data;
};

struct trace_event_raw_icc_set_bw {
	struct trace_entry ent;
	u32 __data_loc_path_name;
	u32 __data_loc_dev;
	u32 __data_loc_node_name;
	u32 avg_bw;
	u32 peak_bw;
	u32 node_avg_bw;
	u32 node_peak_bw;
	char __data[0];
};

struct trace_event_raw_icc_set_bw_end {
	struct trace_entry ent;
	u32 __data_loc_path_name;
	u32 __data_loc_dev;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_icc_set_bw {
	u32 path_name;
	u32 dev;
	u32 node_name;
};

struct trace_event_data_offsets_icc_set_bw_end {
	u32 path_name;
	u32 dev;
};

typedef void (*btf_trace_icc_set_bw)(void *, struct icc_path___2 *, struct icc_node *, int, u32, u32);

typedef void (*btf_trace_icc_set_bw_end)(void *, struct icc_path___2 *, int);

struct icc_bulk_data {
	struct icc_path *path;
	const char *name;
	u32 avg_bw;
	u32 peak_bw;
};

struct net_device_devres {
	struct net_device *ndev;
};

struct __kernel_old_timespec {
	__kernel_old_time_t tv_sec;
	long int tv_nsec;
};

struct __kernel_sock_timeval {
	__s64 tv_sec;
	__s64 tv_usec;
};

struct mmsghdr {
	struct user_msghdr msg_hdr;
	unsigned int msg_len;
};

struct scm_timestamping_internal {
	struct timespec64 ts[3];
};

struct ifconf {
	int ifc_len;
	union {
		char *ifcu_buf;
		struct ifreq *ifcu_req;
	} ifc_ifcu;
};

struct compat_ifmap {
	compat_ulong_t mem_start;
	compat_ulong_t mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct compat_if_settings {
	unsigned int type;
	unsigned int size;
	compat_uptr_t ifs_ifsu;
};

struct compat_ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		compat_int_t ifru_ivalue;
		compat_int_t ifru_mtu;
		struct compat_ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		compat_caddr_t ifru_data;
		struct compat_if_settings ifru_settings;
	} ifr_ifru;
};

struct compat_ifconf {
	compat_int_t ifc_len;
	compat_caddr_t ifcbuf;
};

enum sock_shutdown_cmd {
	SHUT_RD = 0,
	SHUT_WR = 1,
	SHUT_RDWR = 2,
};

struct net_proto_family {
	int family;
	int (*create)(struct net *, struct socket *, int, int);
	struct module *owner;
};

enum {
	SOCK_WAKE_IO = 0,
	SOCK_WAKE_WAITD = 1,
	SOCK_WAKE_SPACE = 2,
	SOCK_WAKE_URG = 3,
};

struct libipw_device;

struct iw_spy_data;

struct iw_public_data {
	struct iw_spy_data *spy_data;
	struct libipw_device *libipw;
};

struct iw_param {
	__s32 value;
	__u8 fixed;
	__u8 disabled;
	__u16 flags;
};

struct iw_point {
	void *pointer;
	__u16 length;
	__u16 flags;
};

struct iw_freq {
	__s32 m;
	__s16 e;
	__u8 i;
	__u8 flags;
};

struct iw_quality {
	__u8 qual;
	__u8 level;
	__u8 noise;
	__u8 updated;
};

struct iw_discarded {
	__u32 nwid;
	__u32 code;
	__u32 fragment;
	__u32 retries;
	__u32 misc;
};

struct iw_missed {
	__u32 beacon;
};

struct iw_statistics {
	__u16 status;
	struct iw_quality qual;
	struct iw_discarded discard;
	struct iw_missed miss;
};

union iwreq_data {
	char name[16];
	struct iw_point essid;
	struct iw_param nwid;
	struct iw_freq freq;
	struct iw_param sens;
	struct iw_param bitrate;
	struct iw_param txpower;
	struct iw_param rts;
	struct iw_param frag;
	__u32 mode;
	struct iw_param retry;
	struct iw_point encoding;
	struct iw_param power;
	struct iw_quality qual;
	struct sockaddr ap_addr;
	struct sockaddr addr;
	struct iw_param param;
	struct iw_point data;
};

struct iw_priv_args {
	__u32 cmd;
	__u16 set_args;
	__u16 get_args;
	char name[16];
};

struct compat_mmsghdr {
	struct compat_msghdr msg_hdr;
	compat_uint_t msg_len;
};

struct iw_request_info {
	__u16 cmd;
	__u16 flags;
};

struct iw_spy_data {
	int spy_number;
	u_char spy_address[48];
	struct iw_quality spy_stat[8];
	struct iw_quality spy_thr_low;
	struct iw_quality spy_thr_high;
	u_char spy_thr_under[8];
};

struct scm_ts_pktinfo {
	__u32 if_index;
	__u32 pkt_length;
	__u32 reserved[2];
};

struct sock_skb_cb {
	u32 dropcount;
};

struct sock_ee_data_rfc4884 {
	__u16 len;
	__u8 flags;
	__u8 reserved;
};

struct sock_extended_err {
	__u32 ee_errno;
	__u8 ee_origin;
	__u8 ee_type;
	__u8 ee_code;
	__u8 ee_pad;
	__u32 ee_info;
	union {
		__u32 ee_data;
		struct sock_ee_data_rfc4884 ee_rfc4884;
	};
};

struct sock_exterr_skb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	struct sock_extended_err ee;
	u16 addr_offset;
	__be16 port;
	u8 opt_stats: 1;
	u8 unused: 7;
};

struct used_address {
	struct __kernel_sockaddr_storage name;
	unsigned int name_len;
};

struct linger {
	int l_onoff;
	int l_linger;
};

struct cmsghdr {
	__kernel_size_t cmsg_len;
	int cmsg_level;
	int cmsg_type;
};

struct ucred {
	__u32 pid;
	__u32 uid;
	__u32 gid;
};

struct prot_inuse {
	int val[64];
};

enum txtime_flags {
	SOF_TXTIME_DEADLINE_MODE = 1,
	SOF_TXTIME_REPORT_ERRORS = 2,
	SOF_TXTIME_FLAGS_LAST = 2,
	SOF_TXTIME_FLAGS_MASK = 3,
};

struct sock_txtime {
	__kernel_clockid_t clockid;
	__u32 flags;
};

enum sk_pacing {
	SK_PACING_NONE = 0,
	SK_PACING_NEEDED = 1,
	SK_PACING_FQ = 2,
};

struct sockcm_cookie {
	u64 transmit_time;
	u32 mark;
	u16 tsflags;
};

struct fastopen_queue {
	struct request_sock *rskq_rst_head;
	struct request_sock *rskq_rst_tail;
	spinlock_t lock;
	int qlen;
	int max_qlen;
	struct tcp_fastopen_context *ctx;
};

struct request_sock_queue {
	spinlock_t rskq_lock;
	u8 rskq_defer_accept;
	u32 synflood_warned;
	atomic_t qlen;
	atomic_t young;
	struct request_sock *rskq_accept_head;
	struct request_sock *rskq_accept_tail;
	struct fastopen_queue fastopenq;
};

struct inet_bind_bucket;

struct tcp_ulp_ops;

struct inet_connection_sock {
	struct inet_sock icsk_inet;
	struct request_sock_queue icsk_accept_queue;
	struct inet_bind_bucket *icsk_bind_hash;
	long unsigned int icsk_timeout;
	struct timer_list icsk_retransmit_timer;
	struct timer_list icsk_delack_timer;
	__u32 icsk_rto;
	__u32 icsk_rto_min;
	__u32 icsk_delack_max;
	__u32 icsk_pmtu_cookie;
	const struct tcp_congestion_ops *icsk_ca_ops;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	const struct tcp_ulp_ops *icsk_ulp_ops;
	void *icsk_ulp_data;
	void (*icsk_clean_acked)(struct sock *, u32);
	struct hlist_node icsk_listen_portaddr_node;
	unsigned int (*icsk_sync_mss)(struct sock *, u32);
	__u8 icsk_ca_state: 5;
	__u8 icsk_ca_initialized: 1;
	__u8 icsk_ca_setsockopt: 1;
	__u8 icsk_ca_dst_locked: 1;
	__u8 icsk_retransmits;
	__u8 icsk_pending;
	__u8 icsk_backoff;
	__u8 icsk_syn_retries;
	__u8 icsk_probes_out;
	__u16 icsk_ext_hdr_len;
	struct {
		__u8 pending;
		__u8 quick;
		__u8 pingpong;
		__u8 retry;
		__u32 ato;
		long unsigned int timeout;
		__u32 lrcvtime;
		__u16 last_seg_size;
		__u16 rcv_mss;
	} icsk_ack;
	struct {
		int search_high;
		int search_low;
		u32 probe_size: 31;
		u32 enabled: 1;
		u32 probe_timestamp;
	} icsk_mtup;
	u32 icsk_probes_tstamp;
	u32 icsk_user_timeout;
	u64 icsk_ca_priv[13];
};

struct inet_bind_bucket {
	possible_net_t ib_net;
	int l3mdev;
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct in6_addr fast_v6_rcv_saddr;
	__be32 fast_rcv_saddr;
	short unsigned int fast_sk_family;
	bool fast_ipv6_only;
	struct hlist_node node;
	struct hlist_head owners;
};

struct tcp_ulp_ops {
	struct list_head list;
	int (*init)(struct sock *);
	void (*update)(struct sock *, struct proto *, void (*)(struct sock *));
	void (*release)(struct sock *);
	int (*get_info)(const struct sock *, struct sk_buff *);
	size_t (*get_info_size)(const struct sock *);
	void (*clone)(const struct request_sock *, struct sock *, const gfp_t);
	char name[16];
	struct module *owner;
};

struct tcp_sack_block {
	u32 start_seq;
	u32 end_seq;
};

struct tcp_options_received {
	int ts_recent_stamp;
	u32 ts_recent;
	u32 rcv_tsval;
	u32 rcv_tsecr;
	u16 saw_tstamp: 1;
	u16 tstamp_ok: 1;
	u16 dsack: 1;
	u16 wscale_ok: 1;
	u16 sack_ok: 3;
	u16 smc_ok: 1;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u8 saw_unknown: 1;
	u8 unused: 7;
	u8 num_sacks;
	u16 user_mss;
	u16 mss_clamp;
};

struct tcp_rack {
	u64 mstamp;
	u32 rtt_us;
	u32 end_seq;
	u32 last_delivered;
	u8 reo_wnd_steps;
	u8 reo_wnd_persist: 5;
	u8 dsack_seen: 1;
	u8 advanced: 1;
};

struct tcp_sock_af_ops;

struct tcp_md5sig_info;

struct tcp_fastopen_request;

struct tcp_sock {
	struct inet_connection_sock inet_conn;
	u16 tcp_header_len;
	u16 gso_segs;
	__be32 pred_flags;
	u64 bytes_received;
	u32 segs_in;
	u32 data_segs_in;
	u32 rcv_nxt;
	u32 copied_seq;
	u32 rcv_wup;
	u32 snd_nxt;
	u32 segs_out;
	u32 data_segs_out;
	u64 bytes_sent;
	u64 bytes_acked;
	u32 dsack_dups;
	u32 snd_una;
	u32 snd_sml;
	u32 rcv_tstamp;
	u32 lsndtime;
	u32 last_oow_ack_time;
	u32 compressed_ack_rcv_nxt;
	u32 tsoffset;
	struct list_head tsq_node;
	struct list_head tsorted_sent_queue;
	u32 snd_wl1;
	u32 snd_wnd;
	u32 max_window;
	u32 mss_cache;
	u32 window_clamp;
	u32 rcv_ssthresh;
	struct tcp_rack rack;
	u16 advmss;
	u8 compressed_ack;
	u8 dup_ack_counter: 2;
	u8 tlp_retrans: 1;
	u8 unused: 5;
	u32 chrono_start;
	u32 chrono_stat[3];
	u8 chrono_type: 2;
	u8 rate_app_limited: 1;
	u8 fastopen_connect: 1;
	u8 fastopen_no_cookie: 1;
	u8 is_sack_reneg: 1;
	u8 fastopen_client_fail: 2;
	u8 nonagle: 4;
	u8 thin_lto: 1;
	u8 recvmsg_inq: 1;
	u8 repair: 1;
	u8 frto: 1;
	u8 repair_queue;
	u8 save_syn: 2;
	u8 syn_data: 1;
	u8 syn_fastopen: 1;
	u8 syn_fastopen_exp: 1;
	u8 syn_fastopen_ch: 1;
	u8 syn_data_acked: 1;
	u8 is_cwnd_limited: 1;
	u32 tlp_high_seq;
	u32 tcp_tx_delay;
	u64 tcp_wstamp_ns;
	u64 tcp_clock_cache;
	u64 tcp_mstamp;
	u32 srtt_us;
	u32 mdev_us;
	u32 mdev_max_us;
	u32 rttvar_us;
	u32 rtt_seq;
	struct minmax rtt_min;
	u32 packets_out;
	u32 retrans_out;
	u32 max_packets_out;
	u32 max_packets_seq;
	u16 urg_data;
	u8 ecn_flags;
	u8 keepalive_probes;
	u32 reordering;
	u32 reord_seen;
	u32 snd_up;
	struct tcp_options_received rx_opt;
	u32 snd_ssthresh;
	u32 snd_cwnd;
	u32 snd_cwnd_cnt;
	u32 snd_cwnd_clamp;
	u32 snd_cwnd_used;
	u32 snd_cwnd_stamp;
	u32 prior_cwnd;
	u32 prr_delivered;
	u32 prr_out;
	u32 delivered;
	u32 delivered_ce;
	u32 lost;
	u32 app_limited;
	u64 first_tx_mstamp;
	u64 delivered_mstamp;
	u32 rate_delivered;
	u32 rate_interval_us;
	u32 rcv_wnd;
	u32 write_seq;
	u32 notsent_lowat;
	u32 pushed_seq;
	u32 lost_out;
	u32 sacked_out;
	struct hrtimer pacing_timer;
	struct hrtimer compressed_ack_timer;
	struct sk_buff *lost_skb_hint;
	struct sk_buff *retransmit_skb_hint;
	struct rb_root out_of_order_queue;
	struct sk_buff *ooo_last_skb;
	struct tcp_sack_block duplicate_sack[1];
	struct tcp_sack_block selective_acks[4];
	struct tcp_sack_block recv_sack_cache[4];
	struct sk_buff *highest_sack;
	int lost_cnt_hint;
	u32 prior_ssthresh;
	u32 high_seq;
	u32 retrans_stamp;
	u32 undo_marker;
	int undo_retrans;
	u64 bytes_retrans;
	u32 total_retrans;
	u32 urg_seq;
	unsigned int keepalive_time;
	unsigned int keepalive_intvl;
	int linger2;
	u8 bpf_sock_ops_cb_flags;
	u16 timeout_rehash;
	u32 rcv_ooopack;
	u32 rcv_rtt_last_tsecr;
	struct {
		u32 rtt_us;
		u32 seq;
		u64 time;
	} rcv_rtt_est;
	struct {
		u32 space;
		u32 seq;
		u64 time;
	} rcvq_space;
	struct {
		u32 probe_seq_start;
		u32 probe_seq_end;
	} mtu_probe;
	u32 mtu_info;
	bool is_mptcp;
	bool syn_smc;
	const struct tcp_sock_af_ops *af_specific;
	struct tcp_md5sig_info *md5sig_info;
	struct tcp_fastopen_request *fastopen_req;
	struct request_sock *fastopen_rsk;
	struct saved_syn *saved_syn;
};

struct tcp_sock_af_ops {
	struct tcp_md5sig_key * (*md5_lookup)(const struct sock *, const struct sock *);
	int (*calc_md5_hash)(char *, const struct tcp_md5sig_key *, const struct sock *, const struct sk_buff *);
	int (*md5_parse)(struct sock *, int, sockptr_t, int);
};

struct tcp_md5sig_info {
	struct hlist_head head;
	struct callback_head rcu;
};

struct tcp_fastopen_request {
	struct tcp_fastopen_cookie cookie;
	struct msghdr *data;
	size_t size;
	int copied;
	struct ubuf_info *uarg;
};

struct cgroup_cls_state {
	struct cgroup_subsys_state css;
	u32 classid;
};

enum {
	SK_MEMINFO_RMEM_ALLOC = 0,
	SK_MEMINFO_RCVBUF = 1,
	SK_MEMINFO_WMEM_ALLOC = 2,
	SK_MEMINFO_SNDBUF = 3,
	SK_MEMINFO_FWD_ALLOC = 4,
	SK_MEMINFO_WMEM_QUEUED = 5,
	SK_MEMINFO_OPTMEM = 6,
	SK_MEMINFO_BACKLOG = 7,
	SK_MEMINFO_DROPS = 8,
	SK_MEMINFO_VARS = 9,
};

enum sknetlink_groups {
	SKNLGRP_NONE = 0,
	SKNLGRP_INET_TCP_DESTROY = 1,
	SKNLGRP_INET_UDP_DESTROY = 2,
	SKNLGRP_INET6_TCP_DESTROY = 3,
	SKNLGRP_INET6_UDP_DESTROY = 4,
	__SKNLGRP_MAX = 5,
};

struct inet_request_sock {
	struct request_sock req;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u16 tstamp_ok: 1;
	u16 sack_ok: 1;
	u16 wscale_ok: 1;
	u16 ecn_ok: 1;
	u16 acked: 1;
	u16 no_srccheck: 1;
	u16 smc_ok: 1;
	u32 ir_mark;
	union {
		struct ip_options_rcu *ireq_opt;
		struct {
			struct ipv6_txoptions *ipv6_opt;
			struct sk_buff *pktopts;
		};
	};
};

struct tcp_request_sock {
	struct inet_request_sock req;
	const struct tcp_request_sock_ops *af_specific;
	u64 snt_synack;
	bool tfo_listener;
	bool is_mptcp;
	bool drop_req;
	u32 txhash;
	u32 rcv_isn;
	u32 snt_isn;
	u32 ts_off;
	u32 last_oow_ack_time;
	u32 rcv_nxt;
	u8 syn_tos;
};

enum {
	SKB_FCLONE_UNAVAILABLE = 0,
	SKB_FCLONE_ORIG = 1,
	SKB_FCLONE_CLONE = 2,
};

struct sk_buff_fclones {
	struct sk_buff skb1;
	struct sk_buff skb2;
	refcount_t fclone_ref;
};

struct skb_seq_state {
	__u32 lower_offset;
	__u32 upper_offset;
	__u32 frag_idx;
	__u32 stepped_offset;
	struct sk_buff *root_skb;
	struct sk_buff *cur_skb;
	__u8 *frag_data;
	__u32 frag_off;
};

struct skb_gso_cb {
	union {
		int mac_offset;
		int data_offset;
	};
	int encap_level;
	__wsum csum;
	__u16 csum_start;
};

struct napi_gro_cb {
	void *frag0;
	unsigned int frag0_len;
	int data_offset;
	u16 flush;
	u16 flush_id;
	u16 count;
	u16 gro_remcsum_start;
	long unsigned int age;
	u16 proto;
	u8 same_flow: 1;
	u8 encap_mark: 1;
	u8 csum_valid: 1;
	u8 csum_cnt: 3;
	u8 free: 2;
	u8 is_ipv6: 1;
	u8 is_fou: 1;
	u8 is_atomic: 1;
	u8 recursion_counter: 4;
	u8 is_flist: 1;
	__wsum csum;
	struct sk_buff *last;
};

struct qdisc_walker {
	int stop;
	int skip;
	int count;
	int (*fn)(struct Qdisc *, long unsigned int, struct qdisc_walker *);
};

struct ip_auth_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__be16 reserved;
	__be32 spi;
	__be32 seq_no;
	__u8 auth_data[0];
};

struct frag_hdr {
	__u8 nexthdr;
	__u8 reserved;
	__be16 frag_off;
	__be32 identification;
};

enum {
	SCM_TSTAMP_SND = 0,
	SCM_TSTAMP_SCHED = 1,
	SCM_TSTAMP_ACK = 2,
};

struct mpls_shim_hdr {
	__be32 label_stack_entry;
};

struct napi_alloc_cache {
	struct page_frag_cache page;
	unsigned int skb_count;
	void *skb_cache[64];
};

typedef int (*sendmsg_func)(struct sock *, struct msghdr *, struct kvec *, size_t, size_t);

typedef int (*sendpage_func)(struct sock *, struct page *, int, size_t, int);

struct ahash_request___2;

struct scm_cookie {
	struct pid *pid;
	struct scm_fp_list *fp;
	struct scm_creds creds;
	struct lsmblob lsmblob;
};

struct scm_timestamping {
	struct __kernel_old_timespec ts[3];
};

struct scm_timestamping64 {
	struct __kernel_timespec ts[3];
};

enum {
	TCA_STATS_UNSPEC = 0,
	TCA_STATS_BASIC = 1,
	TCA_STATS_RATE_EST = 2,
	TCA_STATS_QUEUE = 3,
	TCA_STATS_APP = 4,
	TCA_STATS_RATE_EST64 = 5,
	TCA_STATS_PAD = 6,
	TCA_STATS_BASIC_HW = 7,
	TCA_STATS_PKT64 = 8,
	__TCA_STATS_MAX = 9,
};

struct gnet_stats_basic {
	__u64 bytes;
	__u32 packets;
};

struct gnet_stats_rate_est {
	__u32 bps;
	__u32 pps;
};

struct gnet_stats_rate_est64 {
	__u64 bps;
	__u64 pps;
};

struct gnet_estimator {
	signed char interval;
	unsigned char ewma_log;
};

struct net_rate_estimator {
	struct gnet_stats_basic_packed *bstats;
	spinlock_t *stats_lock;
	seqcount_t *running;
	struct gnet_stats_basic_cpu *cpu_bstats;
	u8 ewma_log;
	u8 intvl_log;
	seqcount_t seq;
	u64 last_packets;
	u64 last_bytes;
	u64 avpps;
	u64 avbps;
	long unsigned int next_jiffies;
	struct timer_list timer;
	struct callback_head rcu;
};

struct rtgenmsg {
	unsigned char rtgen_family;
};

enum rtnetlink_groups {
	RTNLGRP_NONE = 0,
	RTNLGRP_LINK = 1,
	RTNLGRP_NOTIFY = 2,
	RTNLGRP_NEIGH = 3,
	RTNLGRP_TC = 4,
	RTNLGRP_IPV4_IFADDR = 5,
	RTNLGRP_IPV4_MROUTE = 6,
	RTNLGRP_IPV4_ROUTE = 7,
	RTNLGRP_IPV4_RULE = 8,
	RTNLGRP_IPV6_IFADDR = 9,
	RTNLGRP_IPV6_MROUTE = 10,
	RTNLGRP_IPV6_ROUTE = 11,
	RTNLGRP_IPV6_IFINFO = 12,
	RTNLGRP_DECnet_IFADDR = 13,
	RTNLGRP_NOP2 = 14,
	RTNLGRP_DECnet_ROUTE = 15,
	RTNLGRP_DECnet_RULE = 16,
	RTNLGRP_NOP4 = 17,
	RTNLGRP_IPV6_PREFIX = 18,
	RTNLGRP_IPV6_RULE = 19,
	RTNLGRP_ND_USEROPT = 20,
	RTNLGRP_PHONET_IFADDR = 21,
	RTNLGRP_PHONET_ROUTE = 22,
	RTNLGRP_DCB = 23,
	RTNLGRP_IPV4_NETCONF = 24,
	RTNLGRP_IPV6_NETCONF = 25,
	RTNLGRP_MDB = 26,
	RTNLGRP_MPLS_ROUTE = 27,
	RTNLGRP_NSID = 28,
	RTNLGRP_MPLS_NETCONF = 29,
	RTNLGRP_IPV4_MROUTE_R = 30,
	RTNLGRP_IPV6_MROUTE_R = 31,
	RTNLGRP_NEXTHOP = 32,
	RTNLGRP_BRVLAN = 33,
	__RTNLGRP_MAX = 34,
};

enum {
	NETNSA_NONE = 0,
	NETNSA_NSID = 1,
	NETNSA_PID = 2,
	NETNSA_FD = 3,
	NETNSA_TARGET_NSID = 4,
	NETNSA_CURRENT_NSID = 5,
	__NETNSA_MAX = 6,
};

struct pcpu_gen_cookie {
	local_t nesting;
	u64 last;
};

struct gen_cookie {
	struct pcpu_gen_cookie *local;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t forward_last;
	atomic64_t reverse_last;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum rtnl_link_flags {
	RTNL_FLAG_DOIT_UNLOCKED = 1,
};

struct net_fill_args {
	u32 portid;
	u32 seq;
	int flags;
	int cmd;
	int nsid;
	bool add_ref;
	int ref_nsid;
};

struct rtnl_net_dump_cb {
	struct net *tgt_net;
	struct net *ref_net;
	struct sk_buff *skb;
	struct net_fill_args fillargs;
	int idx;
	int s_idx;
};

enum flow_dissect_ret {
	FLOW_DISSECT_RET_OUT_GOOD = 0,
	FLOW_DISSECT_RET_OUT_BAD = 1,
	FLOW_DISSECT_RET_PROTO_AGAIN = 2,
	FLOW_DISSECT_RET_IPPROTO_AGAIN = 3,
	FLOW_DISSECT_RET_CONTINUE = 4,
};

struct flow_dissector_key_tags {
	u32 flow_label;
};

struct flow_dissector_key_vlan {
	union {
		struct {
			u16 vlan_id: 12;
			u16 vlan_dei: 1;
			u16 vlan_priority: 3;
		};
		__be16 vlan_tci;
	};
	__be16 vlan_tpid;
};

struct flow_dissector_mpls_lse {
	u32 mpls_ttl: 8;
	u32 mpls_bos: 1;
	u32 mpls_tc: 3;
	u32 mpls_label: 20;
};

struct flow_dissector_key_mpls {
	struct flow_dissector_mpls_lse ls[7];
	u8 used_lses;
};

struct flow_dissector_key_enc_opts {
	u8 data[255];
	u8 len;
	__be16 dst_opt_type;
};

struct flow_dissector_key_keyid {
	__be32 keyid;
};

struct flow_dissector_key_ipv4_addrs {
	__be32 src;
	__be32 dst;
};

struct flow_dissector_key_ipv6_addrs {
	struct in6_addr src;
	struct in6_addr dst;
};

struct flow_dissector_key_tipc {
	__be32 key;
};

struct flow_dissector_key_addrs {
	union {
		struct flow_dissector_key_ipv4_addrs v4addrs;
		struct flow_dissector_key_ipv6_addrs v6addrs;
		struct flow_dissector_key_tipc tipckey;
	};
};

struct flow_dissector_key_arp {
	__u32 sip;
	__u32 tip;
	__u8 op;
	unsigned char sha[6];
	unsigned char tha[6];
};

struct flow_dissector_key_ports {
	union {
		__be32 ports;
		struct {
			__be16 src;
			__be16 dst;
		};
	};
};

struct flow_dissector_key_icmp {
	struct {
		u8 type;
		u8 code;
	};
	u16 id;
};

struct flow_dissector_key_eth_addrs {
	unsigned char dst[6];
	unsigned char src[6];
};

struct flow_dissector_key_tcp {
	__be16 flags;
};

struct flow_dissector_key_ip {
	__u8 tos;
	__u8 ttl;
};

struct flow_dissector_key_meta {
	int ingress_ifindex;
	u16 ingress_iftype;
};

struct flow_dissector_key_ct {
	u16 ct_state;
	u16 ct_zone;
	u32 ct_mark;
	u32 ct_labels[4];
};

struct flow_dissector_key_hash {
	u32 hash;
};

struct flow_dissector_key {
	enum flow_dissector_key_id key_id;
	size_t offset;
};

struct flow_keys {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_tags tags;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	struct flow_dissector_key_keyid keyid;
	struct flow_dissector_key_ports ports;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_addrs addrs;
	int: 32;
};

struct flow_keys_digest {
	u8 data[16];
};

struct nf_ct_event;

struct nf_ct_event_notifier {
	int (*fcn)(unsigned int, struct nf_ct_event *);
};

struct nf_exp_event;

struct nf_exp_event_notifier {
	int (*fcn)(unsigned int, struct nf_exp_event *);
};

enum bpf_ret_code {
	BPF_OK = 0,
	BPF_DROP = 2,
	BPF_REDIRECT = 7,
	BPF_LWT_REROUTE = 128,
};

enum {
	BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG = 1,
	BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL = 2,
	BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP = 4,
};

enum {
	TCA_FLOWER_KEY_CT_FLAGS_NEW = 1,
	TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED = 2,
	TCA_FLOWER_KEY_CT_FLAGS_RELATED = 4,
	TCA_FLOWER_KEY_CT_FLAGS_TRACKED = 8,
	TCA_FLOWER_KEY_CT_FLAGS_INVALID = 16,
	TCA_FLOWER_KEY_CT_FLAGS_REPLY = 32,
	__TCA_FLOWER_KEY_CT_FLAGS_MAX = 33,
};

struct ip_tunnel_key {
	__be64 tun_id;
	union {
		struct {
			__be32 src;
			__be32 dst;
		} ipv4;
		struct {
			struct in6_addr src;
			struct in6_addr dst;
		} ipv6;
	} u;
	__be16 tun_flags;
	u8 tos;
	u8 ttl;
	__be32 label;
	__be16 tp_src;
	__be16 tp_dst;
};

struct dst_cache_pcpu;

struct dst_cache {
	struct dst_cache_pcpu *cache;
	long unsigned int reset_ts;
};

struct ip_tunnel_info {
	struct ip_tunnel_key key;
	struct dst_cache dst_cache;
	u8 options_len;
	u8 mode;
};

union tcp_word_hdr {
	struct tcphdr hdr;
	__be32 words[5];
};

struct arphdr {
	__be16 ar_hrd;
	__be16 ar_pro;
	unsigned char ar_hln;
	unsigned char ar_pln;
	__be16 ar_op;
};

enum lwtunnel_encap_types {
	LWTUNNEL_ENCAP_NONE = 0,
	LWTUNNEL_ENCAP_MPLS = 1,
	LWTUNNEL_ENCAP_IP = 2,
	LWTUNNEL_ENCAP_ILA = 3,
	LWTUNNEL_ENCAP_IP6 = 4,
	LWTUNNEL_ENCAP_SEG6 = 5,
	LWTUNNEL_ENCAP_BPF = 6,
	LWTUNNEL_ENCAP_SEG6_LOCAL = 7,
	LWTUNNEL_ENCAP_RPL = 8,
	__LWTUNNEL_ENCAP_MAX = 9,
};

enum metadata_type {
	METADATA_IP_TUNNEL = 0,
	METADATA_HW_PORT_MUX = 1,
};

struct hw_port_info {
	struct net_device *lower_dev;
	u32 port_id;
};

struct metadata_dst {
	struct dst_entry dst;
	enum metadata_type type;
	union {
		struct ip_tunnel_info tun_info;
		struct hw_port_info port_info;
	} u;
};

struct gre_base_hdr {
	__be16 flags;
	__be16 protocol;
};

struct gre_full_hdr {
	struct gre_base_hdr fixed_header;
	__be16 csum;
	__be16 reserved1;
	__be32 key;
	__be32 seq;
};

struct pptp_gre_header {
	struct gre_base_hdr gre_hd;
	__be16 payload_len;
	__be16 call_id;
	__be32 seq;
	__be32 ack;
};

struct tipc_basic_hdr {
	__be32 w[4];
};

struct icmphdr {
	__u8 type;
	__u8 code;
	__sum16 checksum;
	union {
		struct {
			__be16 id;
			__be16 sequence;
		} echo;
		__be32 gateway;
		struct {
			__be16 __unused;
			__be16 mtu;
		} frag;
		__u8 reserved[4];
	} un;
};

enum l2tp_debug_flags {
	L2TP_MSG_DEBUG = 1,
	L2TP_MSG_CONTROL = 2,
	L2TP_MSG_SEQ = 4,
	L2TP_MSG_DATA = 8,
};

struct pppoe_tag {
	__be16 tag_type;
	__be16 tag_len;
	char tag_data[0];
};

struct pppoe_hdr {
	__u8 type: 4;
	__u8 ver: 4;
	__u8 code;
	__be16 sid;
	__be16 length;
	struct pppoe_tag tag[0];
};

struct mpls_label {
	__be32 entry;
};

struct clock_identity {
	u8 id[8];
};

struct port_identity {
	struct clock_identity clock_identity;
	__be16 port_number;
};

struct ptp_header {
	u8 tsmt;
	u8 ver;
	__be16 message_length;
	u8 domain_number;
	u8 reserved1;
	u8 flag_field[2];
	__be64 correction;
	__be32 reserved2;
	struct port_identity source_port_identity;
	__be16 sequence_id;
	u8 control;
	u8 log_message_interval;
} __attribute__((packed));

enum batadv_packettype {
	BATADV_IV_OGM = 0,
	BATADV_BCAST = 1,
	BATADV_CODED = 2,
	BATADV_ELP = 3,
	BATADV_OGM2 = 4,
	BATADV_UNICAST = 64,
	BATADV_UNICAST_FRAG = 65,
	BATADV_UNICAST_4ADDR = 66,
	BATADV_ICMP = 67,
	BATADV_UNICAST_TVLV = 68,
};

struct batadv_unicast_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 ttvn;
	__u8 dest[6];
};

struct nf_conntrack_tuple_mask {
	struct {
		union nf_inet_addr u3;
		union nf_conntrack_man_proto u;
	} src;
};

struct nf_conntrack_l4proto {
	u_int8_t l4proto;
	bool allow_clash;
	u16 nlattr_size;
	bool (*can_early_drop)(const struct nf_conn *);
	int (*to_nlattr)(struct sk_buff *, struct nlattr *, struct nf_conn *, bool);
	int (*from_nlattr)(struct nlattr **, struct nf_conn *);
	int (*tuple_to_nlattr)(struct sk_buff *, const struct nf_conntrack_tuple *);
	unsigned int (*nlattr_tuple_size)();
	int (*nlattr_to_tuple)(struct nlattr **, struct nf_conntrack_tuple *, u_int32_t);
	const struct nla_policy *nla_policy;
	struct {
		int (*nlattr_to_obj)(struct nlattr **, struct net *, void *);
		int (*obj_to_nlattr)(struct sk_buff *, const void *);
		u16 obj_size;
		u16 nlattr_max;
		const struct nla_policy *nla_policy;
	} ctnl_timeout;
};

struct nf_ct_ext {
	u8 offset[9];
	u8 len;
	char data[0];
};

struct nf_conntrack_helper;

struct nf_conntrack_expect {
	struct hlist_node lnode;
	struct hlist_node hnode;
	struct nf_conntrack_tuple tuple;
	struct nf_conntrack_tuple_mask mask;
	void (*expectfn)(struct nf_conn *, struct nf_conntrack_expect *);
	struct nf_conntrack_helper *helper;
	struct nf_conn *master;
	struct timer_list timeout;
	refcount_t use;
	unsigned int flags;
	unsigned int class;
	union nf_inet_addr saved_addr;
	union nf_conntrack_man_proto saved_proto;
	enum ip_conntrack_dir dir;
	struct callback_head rcu;
};

enum nf_ct_ext_id {
	NF_CT_EXT_HELPER = 0,
	NF_CT_EXT_NAT = 1,
	NF_CT_EXT_SEQADJ = 2,
	NF_CT_EXT_ACCT = 3,
	NF_CT_EXT_ECACHE = 4,
	NF_CT_EXT_TSTAMP = 5,
	NF_CT_EXT_TIMEOUT = 6,
	NF_CT_EXT_LABELS = 7,
	NF_CT_EXT_SYNPROXY = 8,
	NF_CT_EXT_NUM = 9,
};

struct nf_ct_event {
	struct nf_conn *ct;
	u32 portid;
	int report;
};

struct nf_exp_event {
	struct nf_conntrack_expect *exp;
	u32 portid;
	int report;
};

struct nf_conn_labels {
	long unsigned int bits[2];
};

struct _flow_keys_digest_data {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
	__be32 ports;
	__be32 src;
	__be32 dst;
};

struct tc_skb_ext {
	__u32 chain;
	__u16 mru;
	__u16 zone;
	u8 post_ct: 1;
	u8 post_ct_snat: 1;
	u8 post_ct_dnat: 1;
};

struct ipv4_devconf {
	void *sysctl;
	int data[32];
	long unsigned int state[1];
};

enum nf_dev_hooks {
	NF_NETDEV_INGRESS = 0,
	NF_NETDEV_NUMHOOKS = 1,
};

enum {
	IF_OPER_UNKNOWN = 0,
	IF_OPER_NOTPRESENT = 1,
	IF_OPER_DOWN = 2,
	IF_OPER_LOWERLAYERDOWN = 3,
	IF_OPER_TESTING = 4,
	IF_OPER_DORMANT = 5,
	IF_OPER_UP = 6,
};

struct ifbond {
	__s32 bond_mode;
	__s32 num_slaves;
	__s32 miimon;
};

typedef struct ifbond ifbond;

struct ifslave {
	__s32 slave_id;
	char slave_name[16];
	__s8 link;
	__s8 state;
	__u32 link_failure_count;
};

typedef struct ifslave ifslave;

struct netdev_boot_setup {
	char name[16];
	struct ifmap map;
};

enum {
	NAPIF_STATE_SCHED = 1,
	NAPIF_STATE_MISSED = 2,
	NAPIF_STATE_DISABLE = 4,
	NAPIF_STATE_NPSVC = 8,
	NAPIF_STATE_LISTED = 16,
	NAPIF_STATE_NO_BUSY_POLL = 32,
	NAPIF_STATE_IN_BUSY_POLL = 64,
	NAPIF_STATE_PREFER_BUSY_POLL = 128,
	NAPIF_STATE_THREADED = 256,
	NAPIF_STATE_SCHED_THREADED = 512,
};

enum gro_result {
	GRO_MERGED = 0,
	GRO_MERGED_FREE = 1,
	GRO_HELD = 2,
	GRO_NORMAL = 3,
	GRO_CONSUMED = 4,
};

typedef enum gro_result gro_result_t;

struct net_device_path_stack {
	int num_paths;
	struct net_device_path path[5];
};

struct bpf_xdp_link {
	struct bpf_link link;
	struct net_device *dev;
	int flags;
};

struct netdev_net_notifier {
	struct list_head list;
	struct notifier_block *nb;
};

struct netpoll;

struct netpoll_info {
	refcount_t refcnt;
	struct semaphore dev_lock;
	struct sk_buff_head txq;
	struct delayed_work tx_work;
	struct netpoll *netpoll;
	struct callback_head rcu;
};

struct in_ifaddr;

struct ip_mc_list;

struct in_device {
	struct net_device *dev;
	refcount_t refcnt;
	int dead;
	struct in_ifaddr *ifa_list;
	struct ip_mc_list *mc_list;
	struct ip_mc_list **mc_hash;
	int mc_count;
	spinlock_t mc_tomb_lock;
	struct ip_mc_list *mc_tomb;
	long unsigned int mr_v1_seen;
	long unsigned int mr_v2_seen;
	long unsigned int mr_maxdelay;
	long unsigned int mr_qi;
	long unsigned int mr_qri;
	unsigned char mr_qrv;
	unsigned char mr_gq_running;
	u32 mr_ifc_count;
	struct timer_list mr_gq_timer;
	struct timer_list mr_ifc_timer;
	struct neigh_parms *arp_parms;
	struct ipv4_devconf cnf;
	struct callback_head callback_head;
};

struct packet_offload {
	__be16 type;
	u16 priority;
	struct offload_callbacks callbacks;
	struct list_head list;
};

struct netdev_notifier_info_ext {
	struct netdev_notifier_info info;
	union {
		u32 mtu;
	} ext;
};

struct netdev_notifier_change_info {
	struct netdev_notifier_info info;
	unsigned int flags_changed;
};

struct netdev_notifier_changelowerstate_info {
	struct netdev_notifier_info info;
	void *lower_state_info;
};

struct netdev_notifier_pre_changeaddr_info {
	struct netdev_notifier_info info;
	const unsigned char *dev_addr;
};

typedef int (*bpf_op_t)(struct net_device *, struct netdev_bpf *);

enum {
	NESTED_SYNC_IMM_BIT = 0,
	NESTED_SYNC_TODO_BIT = 1,
};

struct netdev_nested_priv {
	unsigned char flags;
	void *data;
};

struct netdev_bonding_info {
	ifslave slave;
	ifbond master;
};

struct netdev_notifier_bonding_info {
	struct netdev_notifier_info info;
	struct netdev_bonding_info bonding_info;
};

union inet_addr {
	__u32 all[4];
	__be32 ip;
	__be32 ip6[4];
	struct in_addr in;
	struct in6_addr in6;
};

struct netpoll {
	struct net_device *dev;
	char dev_name[16];
	const char *name;
	union inet_addr local_ip;
	union inet_addr remote_ip;
	bool ipv6;
	u16 local_port;
	u16 remote_port;
	u8 remote_mac[6];
};

enum qdisc_state_t {
	__QDISC_STATE_SCHED = 0,
	__QDISC_STATE_DEACTIVATED = 1,
	__QDISC_STATE_MISSED = 2,
};

struct tcf_walker {
	int stop;
	int skip;
	int count;
	bool nonempty;
	long unsigned int cookie;
	int (*fn)(struct tcf_proto *, void *, struct tcf_walker *);
};

enum {
	IPV4_DEVCONF_FORWARDING = 1,
	IPV4_DEVCONF_MC_FORWARDING = 2,
	IPV4_DEVCONF_PROXY_ARP = 3,
	IPV4_DEVCONF_ACCEPT_REDIRECTS = 4,
	IPV4_DEVCONF_SECURE_REDIRECTS = 5,
	IPV4_DEVCONF_SEND_REDIRECTS = 6,
	IPV4_DEVCONF_SHARED_MEDIA = 7,
	IPV4_DEVCONF_RP_FILTER = 8,
	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE = 9,
	IPV4_DEVCONF_BOOTP_RELAY = 10,
	IPV4_DEVCONF_LOG_MARTIANS = 11,
	IPV4_DEVCONF_TAG = 12,
	IPV4_DEVCONF_ARPFILTER = 13,
	IPV4_DEVCONF_MEDIUM_ID = 14,
	IPV4_DEVCONF_NOXFRM = 15,
	IPV4_DEVCONF_NOPOLICY = 16,
	IPV4_DEVCONF_FORCE_IGMP_VERSION = 17,
	IPV4_DEVCONF_ARP_ANNOUNCE = 18,
	IPV4_DEVCONF_ARP_IGNORE = 19,
	IPV4_DEVCONF_PROMOTE_SECONDARIES = 20,
	IPV4_DEVCONF_ARP_ACCEPT = 21,
	IPV4_DEVCONF_ARP_NOTIFY = 22,
	IPV4_DEVCONF_ACCEPT_LOCAL = 23,
	IPV4_DEVCONF_SRC_VMARK = 24,
	IPV4_DEVCONF_PROXY_ARP_PVLAN = 25,
	IPV4_DEVCONF_ROUTE_LOCALNET = 26,
	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL = 27,
	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL = 28,
	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 29,
	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 30,
	IPV4_DEVCONF_DROP_GRATUITOUS_ARP = 31,
	IPV4_DEVCONF_BC_FORWARDING = 32,
	__IPV4_DEVCONF_MAX = 33,
};

struct tc_skb_cb {
	struct qdisc_skb_cb qdisc_cb;
	u16 mru;
	u8 post_ct: 1;
	u8 post_ct_snat: 1;
	u8 post_ct_dnat: 1;
	u16 zone;
};

struct in_ifaddr {
	struct hlist_node hash;
	struct in_ifaddr *ifa_next;
	struct in_device *ifa_dev;
	struct callback_head callback_head;
	__be32 ifa_local;
	__be32 ifa_address;
	__be32 ifa_mask;
	__u32 ifa_rt_priority;
	__be32 ifa_broadcast;
	unsigned char ifa_scope;
	unsigned char ifa_prefixlen;
	__u32 ifa_flags;
	char ifa_label[16];
	__u32 ifa_valid_lft;
	__u32 ifa_preferred_lft;
	long unsigned int ifa_cstamp;
	long unsigned int ifa_tstamp;
};

struct udp_tunnel_info {
	short unsigned int type;
	sa_family_t sa_family;
	__be16 port;
	u8 hw_priv;
};

struct udp_tunnel_nic_shared {
	struct udp_tunnel_nic *udp_tunnel_nic_info;
	struct list_head devices;
};

struct udp_tunnel_nic_ops {
	void (*get_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	void (*set_port_priv)(struct net_device *, unsigned int, unsigned int, u8);
	void (*add_port)(struct net_device *, struct udp_tunnel_info *);
	void (*del_port)(struct net_device *, struct udp_tunnel_info *);
	void (*reset_ntf)(struct net_device *);
	size_t (*dump_size)(struct net_device *, unsigned int);
	int (*dump_write)(struct net_device *, unsigned int, struct sk_buff *);
};

struct dev_kfree_skb_cb {
	enum skb_free_reason reason;
};

struct netdev_adjacent {
	struct net_device *dev;
	bool master;
	bool ignore;
	u16 ref_nr;
	void *private;
	struct list_head list;
	struct callback_head rcu;
};

enum {
	NDA_UNSPEC = 0,
	NDA_DST = 1,
	NDA_LLADDR = 2,
	NDA_CACHEINFO = 3,
	NDA_PROBES = 4,
	NDA_VLAN = 5,
	NDA_PORT = 6,
	NDA_VNI = 7,
	NDA_IFINDEX = 8,
	NDA_MASTER = 9,
	NDA_LINK_NETNSID = 10,
	NDA_SRC_VNI = 11,
	NDA_PROTOCOL = 12,
	NDA_NH_ID = 13,
	NDA_FDB_EXT_ATTRS = 14,
	__NDA_MAX = 15,
};

struct nda_cacheinfo {
	__u32 ndm_confirmed;
	__u32 ndm_used;
	__u32 ndm_updated;
	__u32 ndm_refcnt;
};

struct ndt_stats {
	__u64 ndts_allocs;
	__u64 ndts_destroys;
	__u64 ndts_hash_grows;
	__u64 ndts_res_failed;
	__u64 ndts_lookups;
	__u64 ndts_hits;
	__u64 ndts_rcv_probes_mcast;
	__u64 ndts_rcv_probes_ucast;
	__u64 ndts_periodic_gc_runs;
	__u64 ndts_forced_gc_runs;
	__u64 ndts_table_fulls;
};

enum {
	NDTPA_UNSPEC = 0,
	NDTPA_IFINDEX = 1,
	NDTPA_REFCNT = 2,
	NDTPA_REACHABLE_TIME = 3,
	NDTPA_BASE_REACHABLE_TIME = 4,
	NDTPA_RETRANS_TIME = 5,
	NDTPA_GC_STALETIME = 6,
	NDTPA_DELAY_PROBE_TIME = 7,
	NDTPA_QUEUE_LEN = 8,
	NDTPA_APP_PROBES = 9,
	NDTPA_UCAST_PROBES = 10,
	NDTPA_MCAST_PROBES = 11,
	NDTPA_ANYCAST_DELAY = 12,
	NDTPA_PROXY_DELAY = 13,
	NDTPA_PROXY_QLEN = 14,
	NDTPA_LOCKTIME = 15,
	NDTPA_QUEUE_LENBYTES = 16,
	NDTPA_MCAST_REPROBES = 17,
	NDTPA_PAD = 18,
	__NDTPA_MAX = 19,
};

struct ndtmsg {
	__u8 ndtm_family;
	__u8 ndtm_pad1;
	__u16 ndtm_pad2;
};

struct ndt_config {
	__u16 ndtc_key_len;
	__u16 ndtc_entry_size;
	__u32 ndtc_entries;
	__u32 ndtc_last_flush;
	__u32 ndtc_last_rand;
	__u32 ndtc_hash_rnd;
	__u32 ndtc_hash_mask;
	__u32 ndtc_hash_chain_gc;
	__u32 ndtc_proxy_qlen;
};

enum {
	NDTA_UNSPEC = 0,
	NDTA_NAME = 1,
	NDTA_THRESH1 = 2,
	NDTA_THRESH2 = 3,
	NDTA_THRESH3 = 4,
	NDTA_CONFIG = 5,
	NDTA_PARMS = 6,
	NDTA_STATS = 7,
	NDTA_GC_INTERVAL = 8,
	NDTA_PAD = 9,
	__NDTA_MAX = 10,
};

enum {
	RTN_UNSPEC = 0,
	RTN_UNICAST = 1,
	RTN_LOCAL = 2,
	RTN_BROADCAST = 3,
	RTN_ANYCAST = 4,
	RTN_MULTICAST = 5,
	RTN_BLACKHOLE = 6,
	RTN_UNREACHABLE = 7,
	RTN_PROHIBIT = 8,
	RTN_THROW = 9,
	RTN_NAT = 10,
	RTN_XRESOLVE = 11,
	__RTN_MAX = 12,
};

enum {
	NEIGH_ARP_TABLE = 0,
	NEIGH_ND_TABLE = 1,
	NEIGH_DN_TABLE = 2,
	NEIGH_NR_TABLES = 3,
	NEIGH_LINK_TABLE = 3,
};

struct neigh_seq_state {
	struct seq_net_private p;
	struct neigh_table *tbl;
	struct neigh_hash_table *nht;
	void * (*neigh_sub_iter)(struct neigh_seq_state *, struct neighbour *, loff_t *);
	unsigned int bucket;
	unsigned int flags;
};

struct neighbour_cb {
	long unsigned int sched_next;
	unsigned int flags;
};

enum netevent_notif_type {
	NETEVENT_NEIGH_UPDATE = 1,
	NETEVENT_REDIRECT = 2,
	NETEVENT_DELAY_PROBE_TIME_UPDATE = 3,
	NETEVENT_IPV4_MPATH_HASH_UPDATE = 4,
	NETEVENT_IPV6_MPATH_HASH_UPDATE = 5,
	NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE = 6,
};

struct neigh_dump_filter {
	int master_idx;
	int dev_idx;
};

struct neigh_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table neigh_vars[21];
};

struct netlink_dump_control {
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	u32 min_dump_alloc;
};

struct rtnl_link_stats {
	__u32 rx_packets;
	__u32 tx_packets;
	__u32 rx_bytes;
	__u32 tx_bytes;
	__u32 rx_errors;
	__u32 tx_errors;
	__u32 rx_dropped;
	__u32 tx_dropped;
	__u32 multicast;
	__u32 collisions;
	__u32 rx_length_errors;
	__u32 rx_over_errors;
	__u32 rx_crc_errors;
	__u32 rx_frame_errors;
	__u32 rx_fifo_errors;
	__u32 rx_missed_errors;
	__u32 tx_aborted_errors;
	__u32 tx_carrier_errors;
	__u32 tx_fifo_errors;
	__u32 tx_heartbeat_errors;
	__u32 tx_window_errors;
	__u32 rx_compressed;
	__u32 tx_compressed;
	__u32 rx_nohandler;
};

struct rtnl_link_ifmap {
	__u64 mem_start;
	__u64 mem_end;
	__u64 base_addr;
	__u16 irq;
	__u8 dma;
	__u8 port;
};

enum {
	IFLA_PROTO_DOWN_REASON_UNSPEC = 0,
	IFLA_PROTO_DOWN_REASON_MASK = 1,
	IFLA_PROTO_DOWN_REASON_VALUE = 2,
	__IFLA_PROTO_DOWN_REASON_CNT = 3,
	IFLA_PROTO_DOWN_REASON_MAX = 2,
};

enum {
	IFLA_BRPORT_UNSPEC = 0,
	IFLA_BRPORT_STATE = 1,
	IFLA_BRPORT_PRIORITY = 2,
	IFLA_BRPORT_COST = 3,
	IFLA_BRPORT_MODE = 4,
	IFLA_BRPORT_GUARD = 5,
	IFLA_BRPORT_PROTECT = 6,
	IFLA_BRPORT_FAST_LEAVE = 7,
	IFLA_BRPORT_LEARNING = 8,
	IFLA_BRPORT_UNICAST_FLOOD = 9,
	IFLA_BRPORT_PROXYARP = 10,
	IFLA_BRPORT_LEARNING_SYNC = 11,
	IFLA_BRPORT_PROXYARP_WIFI = 12,
	IFLA_BRPORT_ROOT_ID = 13,
	IFLA_BRPORT_BRIDGE_ID = 14,
	IFLA_BRPORT_DESIGNATED_PORT = 15,
	IFLA_BRPORT_DESIGNATED_COST = 16,
	IFLA_BRPORT_ID = 17,
	IFLA_BRPORT_NO = 18,
	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
	IFLA_BRPORT_CONFIG_PENDING = 20,
	IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
	IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
	IFLA_BRPORT_HOLD_TIMER = 23,
	IFLA_BRPORT_FLUSH = 24,
	IFLA_BRPORT_MULTICAST_ROUTER = 25,
	IFLA_BRPORT_PAD = 26,
	IFLA_BRPORT_MCAST_FLOOD = 27,
	IFLA_BRPORT_MCAST_TO_UCAST = 28,
	IFLA_BRPORT_VLAN_TUNNEL = 29,
	IFLA_BRPORT_BCAST_FLOOD = 30,
	IFLA_BRPORT_GROUP_FWD_MASK = 31,
	IFLA_BRPORT_NEIGH_SUPPRESS = 32,
	IFLA_BRPORT_ISOLATED = 33,
	IFLA_BRPORT_BACKUP_PORT = 34,
	IFLA_BRPORT_MRP_RING_OPEN = 35,
	IFLA_BRPORT_MRP_IN_OPEN = 36,
	IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT = 37,
	IFLA_BRPORT_MCAST_EHT_HOSTS_CNT = 38,
	__IFLA_BRPORT_MAX = 39,
};

enum {
	IFLA_INFO_UNSPEC = 0,
	IFLA_INFO_KIND = 1,
	IFLA_INFO_DATA = 2,
	IFLA_INFO_XSTATS = 3,
	IFLA_INFO_SLAVE_KIND = 4,
	IFLA_INFO_SLAVE_DATA = 5,
	__IFLA_INFO_MAX = 6,
};

enum {
	IFLA_VF_INFO_UNSPEC = 0,
	IFLA_VF_INFO = 1,
	__IFLA_VF_INFO_MAX = 2,
};

enum {
	IFLA_VF_UNSPEC = 0,
	IFLA_VF_MAC = 1,
	IFLA_VF_VLAN = 2,
	IFLA_VF_TX_RATE = 3,
	IFLA_VF_SPOOFCHK = 4,
	IFLA_VF_LINK_STATE = 5,
	IFLA_VF_RATE = 6,
	IFLA_VF_RSS_QUERY_EN = 7,
	IFLA_VF_STATS = 8,
	IFLA_VF_TRUST = 9,
	IFLA_VF_IB_NODE_GUID = 10,
	IFLA_VF_IB_PORT_GUID = 11,
	IFLA_VF_VLAN_LIST = 12,
	IFLA_VF_BROADCAST = 13,
	__IFLA_VF_MAX = 14,
};

struct ifla_vf_mac {
	__u32 vf;
	__u8 mac[32];
};

struct ifla_vf_broadcast {
	__u8 broadcast[32];
};

struct ifla_vf_vlan {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
};

enum {
	IFLA_VF_VLAN_INFO_UNSPEC = 0,
	IFLA_VF_VLAN_INFO = 1,
	__IFLA_VF_VLAN_INFO_MAX = 2,
};

struct ifla_vf_vlan_info {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
	__be16 vlan_proto;
};

struct ifla_vf_tx_rate {
	__u32 vf;
	__u32 rate;
};

struct ifla_vf_rate {
	__u32 vf;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
};

struct ifla_vf_spoofchk {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_link_state {
	__u32 vf;
	__u32 link_state;
};

struct ifla_vf_rss_query_en {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_STATS_RX_PACKETS = 0,
	IFLA_VF_STATS_TX_PACKETS = 1,
	IFLA_VF_STATS_RX_BYTES = 2,
	IFLA_VF_STATS_TX_BYTES = 3,
	IFLA_VF_STATS_BROADCAST = 4,
	IFLA_VF_STATS_MULTICAST = 5,
	IFLA_VF_STATS_PAD = 6,
	IFLA_VF_STATS_RX_DROPPED = 7,
	IFLA_VF_STATS_TX_DROPPED = 8,
	__IFLA_VF_STATS_MAX = 9,
};

struct ifla_vf_trust {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_PORT_UNSPEC = 0,
	IFLA_VF_PORT = 1,
	__IFLA_VF_PORT_MAX = 2,
};

enum {
	IFLA_PORT_UNSPEC = 0,
	IFLA_PORT_VF = 1,
	IFLA_PORT_PROFILE = 2,
	IFLA_PORT_VSI_TYPE = 3,
	IFLA_PORT_INSTANCE_UUID = 4,
	IFLA_PORT_HOST_UUID = 5,
	IFLA_PORT_REQUEST = 6,
	IFLA_PORT_RESPONSE = 7,
	__IFLA_PORT_MAX = 8,
};

struct if_stats_msg {
	__u8 family;
	__u8 pad1;
	__u16 pad2;
	__u32 ifindex;
	__u32 filter_mask;
};

enum {
	IFLA_STATS_UNSPEC = 0,
	IFLA_STATS_LINK_64 = 1,
	IFLA_STATS_LINK_XSTATS = 2,
	IFLA_STATS_LINK_XSTATS_SLAVE = 3,
	IFLA_STATS_LINK_OFFLOAD_XSTATS = 4,
	IFLA_STATS_AF_SPEC = 5,
	__IFLA_STATS_MAX = 6,
};

enum {
	IFLA_OFFLOAD_XSTATS_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_CPU_HIT = 1,
	__IFLA_OFFLOAD_XSTATS_MAX = 2,
};

enum {
	XDP_ATTACHED_NONE = 0,
	XDP_ATTACHED_DRV = 1,
	XDP_ATTACHED_SKB = 2,
	XDP_ATTACHED_HW = 3,
	XDP_ATTACHED_MULTI = 4,
};

enum {
	IFLA_XDP_UNSPEC = 0,
	IFLA_XDP_FD = 1,
	IFLA_XDP_ATTACHED = 2,
	IFLA_XDP_FLAGS = 3,
	IFLA_XDP_PROG_ID = 4,
	IFLA_XDP_DRV_PROG_ID = 5,
	IFLA_XDP_SKB_PROG_ID = 6,
	IFLA_XDP_HW_PROG_ID = 7,
	IFLA_XDP_EXPECTED_FD = 8,
	__IFLA_XDP_MAX = 9,
};

enum {
	IFLA_EVENT_NONE = 0,
	IFLA_EVENT_REBOOT = 1,
	IFLA_EVENT_FEATURES = 2,
	IFLA_EVENT_BONDING_FAILOVER = 3,
	IFLA_EVENT_NOTIFY_PEERS = 4,
	IFLA_EVENT_IGMP_RESEND = 5,
	IFLA_EVENT_BONDING_OPTIONS = 6,
};

enum {
	IFLA_BRIDGE_FLAGS = 0,
	IFLA_BRIDGE_MODE = 1,
	IFLA_BRIDGE_VLAN_INFO = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_INFO = 3,
	IFLA_BRIDGE_MRP = 4,
	IFLA_BRIDGE_CFM = 5,
	__IFLA_BRIDGE_MAX = 6,
};

enum {
	BR_MCAST_DIR_RX = 0,
	BR_MCAST_DIR_TX = 1,
	BR_MCAST_DIR_SIZE = 2,
};

enum rtattr_type_t {
	RTA_UNSPEC = 0,
	RTA_DST = 1,
	RTA_SRC = 2,
	RTA_IIF = 3,
	RTA_OIF = 4,
	RTA_GATEWAY = 5,
	RTA_PRIORITY = 6,
	RTA_PREFSRC = 7,
	RTA_METRICS = 8,
	RTA_MULTIPATH = 9,
	RTA_PROTOINFO = 10,
	RTA_FLOW = 11,
	RTA_CACHEINFO = 12,
	RTA_SESSION = 13,
	RTA_MP_ALGO = 14,
	RTA_TABLE = 15,
	RTA_MARK = 16,
	RTA_MFC_STATS = 17,
	RTA_VIA = 18,
	RTA_NEWDST = 19,
	RTA_PREF = 20,
	RTA_ENCAP_TYPE = 21,
	RTA_ENCAP = 22,
	RTA_EXPIRES = 23,
	RTA_PAD = 24,
	RTA_UID = 25,
	RTA_TTL_PROPAGATE = 26,
	RTA_IP_PROTO = 27,
	RTA_SPORT = 28,
	RTA_DPORT = 29,
	RTA_NH_ID = 30,
	__RTA_MAX = 31,
};

struct rta_cacheinfo {
	__u32 rta_clntref;
	__u32 rta_lastuse;
	__s32 rta_expires;
	__u32 rta_error;
	__u32 rta_used;
	__u32 rta_id;
	__u32 rta_ts;
	__u32 rta_tsage;
};

struct ifinfomsg {
	unsigned char ifi_family;
	unsigned char __ifi_pad;
	short unsigned int ifi_type;
	int ifi_index;
	unsigned int ifi_flags;
	unsigned int ifi_change;
};

typedef int (*rtnl_doit_func)(struct sk_buff *, struct nlmsghdr *, struct netlink_ext_ack *);

typedef int (*rtnl_dumpit_func)(struct sk_buff *, struct netlink_callback *);

struct rtnl_af_ops {
	struct list_head list;
	int family;
	int (*fill_link_af)(struct sk_buff *, const struct net_device *, u32);
	size_t (*get_link_af_size)(const struct net_device *, u32);
	int (*validate_link_af)(const struct net_device *, const struct nlattr *);
	int (*set_link_af)(struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
	int (*fill_stats_af)(struct sk_buff *, const struct net_device *);
	size_t (*get_stats_af_size)(const struct net_device *);
};

struct rtnl_link {
	rtnl_doit_func doit;
	rtnl_dumpit_func dumpit;
	struct module *owner;
	unsigned int flags;
	struct callback_head rcu;
};

enum {
	IF_LINK_MODE_DEFAULT = 0,
	IF_LINK_MODE_DORMANT = 1,
	IF_LINK_MODE_TESTING = 2,
};

enum lw_bits {
	LW_URGENT = 0,
};

struct seg6_pernet_data {
	struct mutex lock;
	struct in6_addr *tun_src;
	struct rhashtable hmac_infos;
};

enum {
	BPF_F_RECOMPUTE_CSUM = 1,
	BPF_F_INVALIDATE_HASH = 2,
};

enum {
	BPF_F_HDR_FIELD_MASK = 15,
};

enum {
	BPF_F_PSEUDO_HDR = 16,
	BPF_F_MARK_MANGLED_0 = 32,
	BPF_F_MARK_ENFORCE = 64,
};

enum {
	BPF_F_INGRESS = 1,
};

enum {
	BPF_F_TUNINFO_IPV6 = 1,
};

enum {
	BPF_F_ZERO_CSUM_TX = 2,
	BPF_F_DONT_FRAGMENT = 4,
	BPF_F_SEQ_NUMBER = 8,
};

enum {
	BPF_CSUM_LEVEL_QUERY = 0,
	BPF_CSUM_LEVEL_INC = 1,
	BPF_CSUM_LEVEL_DEC = 2,
	BPF_CSUM_LEVEL_RESET = 3,
};

enum {
	BPF_F_ADJ_ROOM_FIXED_GSO = 1,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 = 2,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 = 4,
	BPF_F_ADJ_ROOM_ENCAP_L4_GRE = 8,
	BPF_F_ADJ_ROOM_ENCAP_L4_UDP = 16,
	BPF_F_ADJ_ROOM_NO_CSUM_RESET = 32,
	BPF_F_ADJ_ROOM_ENCAP_L2_ETH = 64,
};

enum {
	BPF_ADJ_ROOM_ENCAP_L2_MASK = 255,
	BPF_ADJ_ROOM_ENCAP_L2_SHIFT = 56,
};

enum {
	BPF_SK_LOOKUP_F_REPLACE = 1,
	BPF_SK_LOOKUP_F_NO_REUSEPORT = 2,
};

enum bpf_adj_room_mode {
	BPF_ADJ_ROOM_NET = 0,
	BPF_ADJ_ROOM_MAC = 1,
};

enum bpf_hdr_start_off {
	BPF_HDR_START_MAC = 0,
	BPF_HDR_START_NET = 1,
};

enum bpf_lwt_encap_mode {
	BPF_LWT_ENCAP_SEG6 = 0,
	BPF_LWT_ENCAP_SEG6_INLINE = 1,
	BPF_LWT_ENCAP_IP = 2,
};

struct bpf_tunnel_key {
	__u32 tunnel_id;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
	__u8 tunnel_tos;
	__u8 tunnel_ttl;
	__u16 tunnel_ext;
	__u32 tunnel_label;
};

struct bpf_xfrm_state {
	__u32 reqid;
	__u32 spi;
	__u16 family;
	__u16 ext;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
};

struct bpf_tcp_sock {
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u64 bytes_received;
	__u64 bytes_acked;
	__u32 dsack_dups;
	__u32 delivered;
	__u32 delivered_ce;
	__u32 icsk_retransmits;
};

struct bpf_sock_tuple {
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
			__be16 sport;
			__be16 dport;
		} ipv4;
		struct {
			__be32 saddr[4];
			__be32 daddr[4];
			__be16 sport;
			__be16 dport;
		} ipv6;
	};
};

struct bpf_xdp_sock {
	__u32 queue_id;
};

enum {
	BPF_SOCK_OPS_RTO_CB_FLAG = 1,
	BPF_SOCK_OPS_RETRANS_CB_FLAG = 2,
	BPF_SOCK_OPS_STATE_CB_FLAG = 4,
	BPF_SOCK_OPS_RTT_CB_FLAG = 8,
	BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG = 16,
	BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG = 32,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG = 64,
	BPF_SOCK_OPS_ALL_CB_FLAGS = 127,
};

enum {
	BPF_SOCK_OPS_VOID = 0,
	BPF_SOCK_OPS_TIMEOUT_INIT = 1,
	BPF_SOCK_OPS_RWND_INIT = 2,
	BPF_SOCK_OPS_TCP_CONNECT_CB = 3,
	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 4,
	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 5,
	BPF_SOCK_OPS_NEEDS_ECN = 6,
	BPF_SOCK_OPS_BASE_RTT = 7,
	BPF_SOCK_OPS_RTO_CB = 8,
	BPF_SOCK_OPS_RETRANS_CB = 9,
	BPF_SOCK_OPS_STATE_CB = 10,
	BPF_SOCK_OPS_TCP_LISTEN_CB = 11,
	BPF_SOCK_OPS_RTT_CB = 12,
	BPF_SOCK_OPS_PARSE_HDR_OPT_CB = 13,
	BPF_SOCK_OPS_HDR_OPT_LEN_CB = 14,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB = 15,
};

enum {
	TCP_BPF_IW = 1001,
	TCP_BPF_SNDCWND_CLAMP = 1002,
	TCP_BPF_DELACK_MAX = 1003,
	TCP_BPF_RTO_MIN = 1004,
	TCP_BPF_SYN = 1005,
	TCP_BPF_SYN_IP = 1006,
	TCP_BPF_SYN_MAC = 1007,
};

enum {
	BPF_LOAD_HDR_OPT_TCP_SYN = 1,
};

enum {
	BPF_FIB_LOOKUP_DIRECT = 1,
	BPF_FIB_LOOKUP_OUTPUT = 2,
};

enum {
	BPF_FIB_LKUP_RET_SUCCESS = 0,
	BPF_FIB_LKUP_RET_BLACKHOLE = 1,
	BPF_FIB_LKUP_RET_UNREACHABLE = 2,
	BPF_FIB_LKUP_RET_PROHIBIT = 3,
	BPF_FIB_LKUP_RET_NOT_FWDED = 4,
	BPF_FIB_LKUP_RET_FWD_DISABLED = 5,
	BPF_FIB_LKUP_RET_UNSUPP_LWT = 6,
	BPF_FIB_LKUP_RET_NO_NEIGH = 7,
	BPF_FIB_LKUP_RET_FRAG_NEEDED = 8,
};

struct bpf_fib_lookup {
	__u8 family;
	__u8 l4_protocol;
	__be16 sport;
	__be16 dport;
	union {
		__u16 tot_len;
		__u16 mtu_result;
	};
	__u32 ifindex;
	union {
		__u8 tos;
		__be32 flowinfo;
		__u32 rt_metric;
	};
	union {
		__be32 ipv4_src;
		__u32 ipv6_src[4];
	};
	union {
		__be32 ipv4_dst;
		__u32 ipv6_dst[4];
	};
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__u8 smac[6];
	__u8 dmac[6];
};

struct bpf_redir_neigh {
	__u32 nh_family;
	union {
		__be32 ipv4_nh;
		__u32 ipv6_nh[4];
	};
};

enum bpf_check_mtu_flags {
	BPF_MTU_CHK_SEGS = 1,
};

enum bpf_check_mtu_ret {
	BPF_MTU_CHK_RET_SUCCESS = 0,
	BPF_MTU_CHK_RET_FRAG_NEEDED = 1,
	BPF_MTU_CHK_RET_SEGS_TOOBIG = 2,
};

enum rt_scope_t {
	RT_SCOPE_UNIVERSE = 0,
	RT_SCOPE_SITE = 200,
	RT_SCOPE_LINK = 253,
	RT_SCOPE_HOST = 254,
	RT_SCOPE_NOWHERE = 255,
};

enum rt_class_t {
	RT_TABLE_UNSPEC = 0,
	RT_TABLE_COMPAT = 252,
	RT_TABLE_DEFAULT = 253,
	RT_TABLE_MAIN = 254,
	RT_TABLE_LOCAL = 255,
	RT_TABLE_MAX = 4294967295,
};

typedef int (*bpf_aux_classic_check_t)(struct sock_filter *, unsigned int);

struct inet_timewait_sock {
	struct sock_common __tw_common;
	__u32 tw_mark;
	volatile unsigned char tw_substate;
	unsigned char tw_rcv_wscale;
	__be16 tw_sport;
	unsigned int tw_kill: 1;
	unsigned int tw_transparent: 1;
	unsigned int tw_flowlabel: 20;
	unsigned int tw_pad: 2;
	unsigned int tw_tos: 8;
	u32 tw_txhash;
	u32 tw_priority;
	struct timer_list tw_timer;
	struct inet_bind_bucket *tw_tb;
};

struct tcp_timewait_sock {
	struct inet_timewait_sock tw_sk;
	u32 tw_rcv_wnd;
	u32 tw_ts_offset;
	u32 tw_ts_recent;
	u32 tw_last_oow_ack_time;
	int tw_ts_recent_stamp;
	u32 tw_tx_delay;
	struct tcp_md5sig_key *tw_md5_key;
};

struct udp_sock {
	struct inet_sock inet;
	int pending;
	unsigned int corkflag;
	__u8 encap_type;
	unsigned char no_check6_tx: 1;
	unsigned char no_check6_rx: 1;
	unsigned char encap_enabled: 1;
	unsigned char gro_enabled: 1;
	unsigned char accept_udp_l4: 1;
	unsigned char accept_udp_fraglist: 1;
	__u16 len;
	__u16 gso_size;
	__u16 pcslen;
	__u16 pcrlen;
	__u8 pcflag;
	__u8 unused[3];
	int (*encap_rcv)(struct sock *, struct sk_buff *);
	int (*encap_err_lookup)(struct sock *, struct sk_buff *);
	void (*encap_destroy)(struct sock *);
	struct sk_buff * (*gro_receive)(struct sock *, struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sock *, struct sk_buff *, int);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head reader_queue;
	int forward_deficit;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct udp6_sock {
	struct udp_sock udp;
	struct ipv6_pinfo inet6;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tcp6_sock {
	struct tcp_sock tcp;
	struct ipv6_pinfo inet6;
};

struct fib_result {
	__be32 prefix;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	u32 tclassid;
	struct fib_nh_common *nhc;
	struct fib_info *fi;
	struct fib_table *table;
	struct hlist_head *fa_head;
};

enum {
	INET_ECN_NOT_ECT = 0,
	INET_ECN_ECT_1 = 1,
	INET_ECN_ECT_0 = 2,
	INET_ECN_CE = 3,
	INET_ECN_MASK = 3,
};

struct tcp_skb_cb {
	__u32 seq;
	__u32 end_seq;
	union {
		__u32 tcp_tw_isn;
		struct {
			u16 tcp_gso_segs;
			u16 tcp_gso_size;
		};
	};
	__u8 tcp_flags;
	__u8 sacked;
	__u8 ip_dsfield;
	__u8 txstamp_ack: 1;
	__u8 eor: 1;
	__u8 has_rxtstamp: 1;
	__u8 unused: 5;
	__u32 ack_seq;
	union {
		struct {
			__u32 in_flight: 30;
			__u32 is_app_limited: 1;
			__u32 unused: 1;
			__u32 delivered;
			u64 first_tx_mstamp;
			u64 delivered_mstamp;
		} tx;
		union {
			struct inet_skb_parm h4;
			struct inet6_skb_parm h6;
		} header;
	};
};

struct strp_msg {
	int full_len;
	int offset;
};

struct _strp_msg {
	struct strp_msg strp;
	int accum_len;
};

struct sk_skb_cb {
	unsigned char data[20];
	struct _strp_msg strp;
	u64 temp_reg;
};

struct xdp_umem {
	void *addrs;
	u64 size;
	u32 headroom;
	u32 chunk_size;
	u32 chunks;
	u32 npgs;
	struct user_struct *user;
	refcount_t users;
	u8 flags;
	bool zc;
	struct page **pgs;
	int id;
	struct list_head xsk_dma_list;
	struct work_struct work;
};

struct xsk_queue;

struct xdp_sock {
	struct sock sk;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xsk_queue *rx;
	struct net_device *dev;
	struct xdp_umem *umem;
	struct list_head flush_node;
	struct xsk_buff_pool *pool;
	u16 queue_id;
	bool zc;
	enum {
		XSK_READY = 0,
		XSK_BOUND = 1,
		XSK_UNBOUND = 2,
	} state;
	long: 64;
	struct xsk_queue *tx;
	struct list_head tx_list;
	spinlock_t rx_lock;
	u64 rx_dropped;
	u64 rx_queue_full;
	struct list_head map_list;
	spinlock_t map_list_lock;
	struct mutex mutex;
	struct xsk_queue *fq_tmp;
	struct xsk_queue *cq_tmp;
	long: 64;
};

struct ipv6_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u8 first_segment;
	__u8 flags;
	__u16 tag;
	struct in6_addr segments[0];
};

enum {
	SEG6_LOCAL_ACTION_UNSPEC = 0,
	SEG6_LOCAL_ACTION_END = 1,
	SEG6_LOCAL_ACTION_END_X = 2,
	SEG6_LOCAL_ACTION_END_T = 3,
	SEG6_LOCAL_ACTION_END_DX2 = 4,
	SEG6_LOCAL_ACTION_END_DX6 = 5,
	SEG6_LOCAL_ACTION_END_DX4 = 6,
	SEG6_LOCAL_ACTION_END_DT6 = 7,
	SEG6_LOCAL_ACTION_END_DT4 = 8,
	SEG6_LOCAL_ACTION_END_B6 = 9,
	SEG6_LOCAL_ACTION_END_B6_ENCAP = 10,
	SEG6_LOCAL_ACTION_END_BM = 11,
	SEG6_LOCAL_ACTION_END_S = 12,
	SEG6_LOCAL_ACTION_END_AS = 13,
	SEG6_LOCAL_ACTION_END_AM = 14,
	SEG6_LOCAL_ACTION_END_BPF = 15,
	__SEG6_LOCAL_ACTION_MAX = 16,
};

struct seg6_bpf_srh_state {
	struct ipv6_sr_hdr *srh;
	u16 hdrlen;
	bool valid;
};

struct tls_crypto_info {
	__u16 version;
	__u16 cipher_type;
};

struct tls12_crypto_info_aes_gcm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aes_gcm_256 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[32];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_chacha20_poly1305 {
	struct tls_crypto_info info;
	unsigned char iv[12];
	unsigned char key[32];
	unsigned char salt[0];
	unsigned char rec_seq[8];
};

struct tls_sw_context_rx {
	struct crypto_aead *aead_recv;
	struct crypto_wait async_wait;
	struct strparser strp;
	struct sk_buff_head rx_list;
	void (*saved_data_ready)(struct sock *);
	struct sk_buff *recv_pkt;
	u8 control;
	u8 async_capable: 1;
	u8 decrypted: 1;
	atomic_t decrypt_pending;
	spinlock_t decrypt_compl_lock;
	bool async_notify;
};

struct cipher_context {
	char *iv;
	char *rec_seq;
};

union tls_crypto_context {
	struct tls_crypto_info info;
	union {
		struct tls12_crypto_info_aes_gcm_128 aes_gcm_128;
		struct tls12_crypto_info_aes_gcm_256 aes_gcm_256;
		struct tls12_crypto_info_chacha20_poly1305 chacha20_poly1305;
	};
};

struct tls_prot_info {
	u16 version;
	u16 cipher_type;
	u16 prepend_size;
	u16 tag_size;
	u16 overhead_size;
	u16 iv_size;
	u16 salt_size;
	u16 rec_seq_size;
	u16 aad_size;
	u16 tail_size;
};

struct tls_context {
	struct tls_prot_info prot_info;
	u8 tx_conf: 3;
	u8 rx_conf: 3;
	int (*push_pending_record)(struct sock *, int);
	void (*sk_write_space)(struct sock *);
	void *priv_ctx_tx;
	void *priv_ctx_rx;
	struct net_device *netdev;
	struct cipher_context tx;
	struct cipher_context rx;
	struct scatterlist *partially_sent_record;
	u16 partially_sent_offset;
	bool in_tcp_sendpages;
	bool pending_open_record_frags;
	struct mutex tx_lock;
	long unsigned int flags;
	struct proto *sk_proto;
	struct sock *sk;
	void (*sk_destruct)(struct sock *);
	union tls_crypto_context crypto_send;
	union tls_crypto_context crypto_recv;
	struct list_head list;
	refcount_t refcount;
	struct callback_head rcu;
};

typedef u64 (*btf_bpf_skb_get_pay_offset)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_get_nlattr)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_get_nlattr_nest)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_load_helper_8)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_8_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_16)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_16_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_32)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_32_no_cache)(const struct sk_buff *, int);

struct bpf_scratchpad {
	union {
		__be32 diff[128];
		u8 buff[512];
	};
};

typedef u64 (*btf_bpf_skb_store_bytes)(struct sk_buff *, u32, const void *, u32, u64);

typedef u64 (*btf_bpf_skb_load_bytes)(const struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_flow_dissector_load_bytes)(const struct bpf_flow_dissector *, u32, void *, u32);

typedef u64 (*btf_bpf_skb_load_bytes_relative)(const struct sk_buff *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_sk_fullsock)(struct sock *);

typedef u64 (*btf_sk_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_l3_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_l4_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_csum_diff)(__be32 *, u32, __be32 *, u32, __wsum);

typedef u64 (*btf_bpf_csum_update)(struct sk_buff *, __wsum);

typedef u64 (*btf_bpf_csum_level)(struct sk_buff *, u64);

enum {
	BPF_F_NEIGH = 2,
	BPF_F_PEER = 4,
	BPF_F_NEXTHOP = 8,
};

typedef u64 (*btf_bpf_clone_redirect)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_redirect)(u32, u64);

typedef u64 (*btf_bpf_redirect_peer)(u32, u64);

typedef u64 (*btf_bpf_redirect_neigh)(u32, struct bpf_redir_neigh *, int, u64);

typedef u64 (*btf_bpf_msg_apply_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_cork_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_pull_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_push_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_pop_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_get_cgroup_classid_curr)();

typedef u64 (*btf_bpf_skb_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_route_realm)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_hash_recalc)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash_invalid)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_skb_vlan_push)(struct sk_buff *, __be16, u16);

typedef u64 (*btf_bpf_skb_vlan_pop)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_change_proto)(struct sk_buff *, __be16, u64);

typedef u64 (*btf_bpf_skb_change_type)(struct sk_buff *, u32);

typedef u64 (*btf_sk_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_xdp_adjust_head)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_tail)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_meta)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_redirect)(u32, u64);

typedef u64 (*btf_bpf_xdp_redirect_map)(struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_skb_event_output)(struct sk_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_key)(struct sk_buff *, struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_opt)(struct sk_buff *, u8 *, u32);

typedef u64 (*btf_bpf_skb_set_tunnel_key)(struct sk_buff *, const struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_set_tunnel_opt)(struct sk_buff *, const u8 *, u32);

typedef u64 (*btf_bpf_skb_under_cgroup)(struct sk_buff *, struct bpf_map *, u32);

typedef u64 (*btf_bpf_skb_cgroup_id)(const struct sk_buff *);

typedef u64 (*btf_bpf_skb_ancestor_cgroup_id)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_sk_cgroup_id)(struct sock *);

typedef u64 (*btf_bpf_sk_ancestor_cgroup_id)(struct sock *, int);

typedef u64 (*btf_bpf_xdp_event_output)(struct xdp_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_socket_cookie)(struct sk_buff *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_socket_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_socket_ptr_cookie)(struct sock *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_socket_uid)(struct sk_buff *);

typedef u64 (*btf_bpf_sock_addr_setsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_getsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_setsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_getsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_cb_flags_set)(struct bpf_sock_ops_kern *, int);

typedef u64 (*btf_bpf_bind)(struct bpf_sock_addr_kern *, struct sockaddr *, int);

typedef u64 (*btf_bpf_skb_get_xfrm_state)(struct sk_buff *, u32, struct bpf_xfrm_state *, u32, u64);

typedef u64 (*btf_bpf_xdp_fib_lookup)(struct xdp_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_skb_fib_lookup)(struct sk_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_skb_check_mtu)(struct sk_buff *, u32, u32 *, s32, u64);

typedef u64 (*btf_bpf_xdp_check_mtu)(struct xdp_buff *, u32, u32 *, s32, u64);

typedef u64 (*btf_bpf_lwt_in_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_xmit_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_seg6_store_bytes)(struct sk_buff *, u32, const void *, u32);

typedef u64 (*btf_bpf_lwt_seg6_action)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_seg6_adjust_srh)(struct sk_buff *, u32, s32);

typedef u64 (*btf_bpf_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_release)(struct sock *);

typedef u64 (*btf_bpf_xdp_sk_lookup_udp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_skc_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_sk_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_sock_addr_skc_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_udp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_get_listener_sock)(struct sock *);

typedef u64 (*btf_bpf_skb_ecn_set_ce)(struct sk_buff *);

typedef u64 (*btf_bpf_tcp_check_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_gen_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_sk_assign)(struct sk_buff *, struct sock *, u64);

typedef u64 (*btf_bpf_sock_ops_load_hdr_opt)(struct bpf_sock_ops_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_store_hdr_opt)(struct bpf_sock_ops_kern *, const void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_reserve_hdr_opt)(struct bpf_sock_ops_kern *, u32, u64);

typedef u64 (*btf_sk_select_reuseport)(struct sk_reuseport_kern *, struct bpf_map *, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes)(const struct sk_reuseport_kern *, u32, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes_relative)(const struct sk_reuseport_kern *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_sk_lookup_assign)(struct bpf_sk_lookup_kern *, struct sock *, u64);

typedef u64 (*btf_bpf_skc_to_tcp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_timewait_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_request_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_udp6_sock)(struct sock *);

typedef u64 (*btf_bpf_sock_from_file)(struct file *);

enum {
	INET_DIAG_REQ_NONE = 0,
	INET_DIAG_REQ_BYTECODE = 1,
	INET_DIAG_REQ_SK_BPF_STORAGES = 2,
	INET_DIAG_REQ_PROTOCOL = 3,
	__INET_DIAG_REQ_MAX = 4,
};

struct sock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
};

struct sock_diag_handler {
	__u8 family;
	int (*dump)(struct sk_buff *, struct nlmsghdr *);
	int (*get_info)(struct sk_buff *, struct sock *);
	int (*destroy)(struct sk_buff *, struct nlmsghdr *);
};

struct broadcast_sk {
	struct sock *sk;
	struct work_struct work;
};

typedef int gifconf_func_t(struct net_device *, char *, int, int);

struct fib_notifier_info {
	int family;
	struct netlink_ext_ack *extack;
};

enum fib_event_type {
	FIB_EVENT_ENTRY_REPLACE = 0,
	FIB_EVENT_ENTRY_APPEND = 1,
	FIB_EVENT_ENTRY_ADD = 2,
	FIB_EVENT_ENTRY_DEL = 3,
	FIB_EVENT_RULE_ADD = 4,
	FIB_EVENT_RULE_DEL = 5,
	FIB_EVENT_NH_ADD = 6,
	FIB_EVENT_NH_DEL = 7,
	FIB_EVENT_VIF_ADD = 8,
	FIB_EVENT_VIF_DEL = 9,
};

struct fib_notifier_net {
	struct list_head fib_notifier_ops;
	struct atomic_notifier_head fib_chain;
};

struct xdp_frame_bulk {
	int count;
	void *xa;
	void *q[16];
};

struct xdp_attachment_info {
	struct bpf_prog *prog;
	u32 flags;
};

struct xdp_buff_xsk;

struct xsk_buff_pool {
	struct device *dev;
	struct net_device *netdev;
	struct list_head xsk_tx_list;
	spinlock_t xsk_tx_list_lock;
	refcount_t users;
	struct xdp_umem *umem;
	struct work_struct work;
	struct list_head free_list;
	u32 heads_cnt;
	u16 queue_id;
	long: 16;
	long: 64;
	long: 64;
	long: 64;
	struct xsk_queue *fq;
	struct xsk_queue *cq;
	dma_addr_t *dma_pages;
	struct xdp_buff_xsk *heads;
	u64 chunk_mask;
	u64 addrs_cnt;
	u32 free_list_cnt;
	u32 dma_pages_cnt;
	u32 free_heads_cnt;
	u32 headroom;
	u32 chunk_size;
	u32 frame_len;
	u8 cached_need_wakeup;
	bool uses_need_wakeup;
	bool dma_need_sync;
	bool unaligned;
	void *addrs;
	spinlock_t cq_lock;
	struct xdp_buff_xsk *free_heads[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_buff_xsk {
	struct xdp_buff xdp;
	dma_addr_t dma;
	dma_addr_t frame_dma;
	struct xsk_buff_pool *pool;
	bool unaligned;
	u64 orig_addr;
	struct list_head free_list_node;
};

struct flow_match_meta {
	struct flow_dissector_key_meta *key;
	struct flow_dissector_key_meta *mask;
};

struct flow_match_basic {
	struct flow_dissector_key_basic *key;
	struct flow_dissector_key_basic *mask;
};

struct flow_match_control {
	struct flow_dissector_key_control *key;
	struct flow_dissector_key_control *mask;
};

struct flow_match_eth_addrs {
	struct flow_dissector_key_eth_addrs *key;
	struct flow_dissector_key_eth_addrs *mask;
};

struct flow_match_vlan {
	struct flow_dissector_key_vlan *key;
	struct flow_dissector_key_vlan *mask;
};

struct flow_match_ipv4_addrs {
	struct flow_dissector_key_ipv4_addrs *key;
	struct flow_dissector_key_ipv4_addrs *mask;
};

struct flow_match_ipv6_addrs {
	struct flow_dissector_key_ipv6_addrs *key;
	struct flow_dissector_key_ipv6_addrs *mask;
};

struct flow_match_ip {
	struct flow_dissector_key_ip *key;
	struct flow_dissector_key_ip *mask;
};

struct flow_match_ports {
	struct flow_dissector_key_ports *key;
	struct flow_dissector_key_ports *mask;
};

struct flow_match_icmp {
	struct flow_dissector_key_icmp *key;
	struct flow_dissector_key_icmp *mask;
};

struct flow_match_tcp {
	struct flow_dissector_key_tcp *key;
	struct flow_dissector_key_tcp *mask;
};

struct flow_match_mpls {
	struct flow_dissector_key_mpls *key;
	struct flow_dissector_key_mpls *mask;
};

struct flow_match_enc_keyid {
	struct flow_dissector_key_keyid *key;
	struct flow_dissector_key_keyid *mask;
};

struct flow_match_enc_opts {
	struct flow_dissector_key_enc_opts *key;
	struct flow_dissector_key_enc_opts *mask;
};

struct flow_match_ct {
	struct flow_dissector_key_ct *key;
	struct flow_dissector_key_ct *mask;
};

enum flow_block_command {
	FLOW_BLOCK_BIND = 0,
	FLOW_BLOCK_UNBIND = 1,
};

enum flow_block_binder_type {
	FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2,
	FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP = 3,
	FLOW_BLOCK_BINDER_TYPE_RED_MARK = 4,
};

struct flow_block_offload {
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	bool block_shared;
	bool unlocked_driver_cb;
	struct net *net;
	struct flow_block *block;
	struct list_head cb_list;
	struct list_head *driver_block_list;
	struct netlink_ext_ack *extack;
	struct Qdisc *sch;
	struct list_head *cb_list_head;
};

struct flow_block_cb;

struct flow_block_indr {
	struct list_head list;
	struct net_device *dev;
	struct Qdisc *sch;
	enum flow_block_binder_type binder_type;
	void *data;
	void *cb_priv;
	void (*cleanup)(struct flow_block_cb *);
};

struct flow_block_cb {
	struct list_head driver_list;
	struct list_head list;
	flow_setup_cb_t *cb;
	void *cb_ident;
	void *cb_priv;
	void (*release)(void *);
	struct flow_block_indr indr;
	unsigned int refcnt;
};

typedef int flow_indr_block_bind_cb_t(struct net_device *, struct Qdisc *, void *, enum tc_setup_type, void *, void *, void (*)(struct flow_block_cb *));

struct flow_indr_dev {
	struct list_head list;
	flow_indr_block_bind_cb_t *cb;
	void *cb_priv;
	refcount_t refcnt;
	struct callback_head rcu;
};

struct flow_indir_dev_info {
	void *data;
	struct net_device *dev;
	struct Qdisc *sch;
	enum tc_setup_type type;
	void (*cleanup)(struct flow_block_cb *);
	struct list_head list;
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	struct list_head *cb_list;
};

struct rx_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_rx_queue *, char *);
	ssize_t (*store)(struct netdev_rx_queue *, const char *, size_t);
};

struct netdev_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_queue *, char *);
	ssize_t (*store)(struct netdev_queue *, const char *, size_t);
};

struct inet6_ifaddr {
	struct in6_addr addr;
	__u32 prefix_len;
	__u32 rt_priority;
	__u32 valid_lft;
	__u32 prefered_lft;
	refcount_t refcnt;
	spinlock_t lock;
	int state;
	__u32 flags;
	__u8 dad_probes;
	__u8 stable_privacy_retry;
	__u16 scope;
	__u64 dad_nonce;
	long unsigned int cstamp;
	long unsigned int tstamp;
	struct delayed_work dad_work;
	struct inet6_dev *idev;
	struct fib6_info *rt;
	struct hlist_node addr_lst;
	struct list_head if_list;
	struct list_head tmp_list;
	struct inet6_ifaddr *ifpub;
	int regen_count;
	bool tokenized;
	struct callback_head rcu;
	struct in6_addr peer_addr;
};

struct fib_rule_uid_range {
	__u32 start;
	__u32 end;
};

enum {
	FRA_UNSPEC = 0,
	FRA_DST = 1,
	FRA_SRC = 2,
	FRA_IIFNAME = 3,
	FRA_GOTO = 4,
	FRA_UNUSED2 = 5,
	FRA_PRIORITY = 6,
	FRA_UNUSED3 = 7,
	FRA_UNUSED4 = 8,
	FRA_UNUSED5 = 9,
	FRA_FWMARK = 10,
	FRA_FLOW = 11,
	FRA_TUN_ID = 12,
	FRA_SUPPRESS_IFGROUP = 13,
	FRA_SUPPRESS_PREFIXLEN = 14,
	FRA_TABLE = 15,
	FRA_FWMASK = 16,
	FRA_OIFNAME = 17,
	FRA_PAD = 18,
	FRA_L3MDEV = 19,
	FRA_UID_RANGE = 20,
	FRA_PROTOCOL = 21,
	FRA_IP_PROTO = 22,
	FRA_SPORT_RANGE = 23,
	FRA_DPORT_RANGE = 24,
	__FRA_MAX = 25,
};

enum {
	FR_ACT_UNSPEC = 0,
	FR_ACT_TO_TBL = 1,
	FR_ACT_GOTO = 2,
	FR_ACT_NOP = 3,
	FR_ACT_RES3 = 4,
	FR_ACT_RES4 = 5,
	FR_ACT_BLACKHOLE = 6,
	FR_ACT_UNREACHABLE = 7,
	FR_ACT_PROHIBIT = 8,
	__FR_ACT_MAX = 9,
};

struct fib_rule_notifier_info {
	struct fib_notifier_info info;
	struct fib_rule *rule;
};

struct trace_event_raw_kfree_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	short unsigned int protocol;
	char __data[0];
};

struct trace_event_raw_consume_skb {
	struct trace_entry ent;
	void *skbaddr;
	char __data[0];
};

struct trace_event_raw_skb_copy_datagram_iovec {
	struct trace_entry ent;
	const void *skbaddr;
	int len;
	char __data[0];
};

struct trace_event_data_offsets_kfree_skb {};

struct trace_event_data_offsets_consume_skb {};

struct trace_event_data_offsets_skb_copy_datagram_iovec {};

typedef void (*btf_trace_kfree_skb)(void *, struct sk_buff *, void *);

typedef void (*btf_trace_consume_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_skb_copy_datagram_iovec)(void *, const struct sk_buff *, int);

struct trace_event_raw_net_dev_start_xmit {
	struct trace_entry ent;
	u32 __data_loc_name;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	unsigned int len;
	unsigned int data_len;
	int network_offset;
	bool transport_offset_valid;
	int transport_offset;
	u8 tx_flags;
	u16 gso_size;
	u16 gso_segs;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	int rc;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit_timeout {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_driver;
	int queue_index;
	char __data[0];
};

struct trace_event_raw_net_dev_template {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_verbose_template {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int napi_id;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	u32 hash;
	bool l4_hash;
	unsigned int len;
	unsigned int data_len;
	unsigned int truesize;
	bool mac_header_valid;
	int mac_header;
	unsigned char nr_frags;
	u16 gso_size;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_exit_template {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_net_dev_start_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit_timeout {
	u32 name;
	u32 driver;
};

struct trace_event_data_offsets_net_dev_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_verbose_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_exit_template {};

typedef void (*btf_trace_net_dev_start_xmit)(void *, const struct sk_buff *, const struct net_device *);

typedef void (*btf_trace_net_dev_xmit)(void *, struct sk_buff *, int, struct net_device *, unsigned int);

typedef void (*btf_trace_net_dev_xmit_timeout)(void *, struct net_device *, int);

typedef void (*btf_trace_net_dev_queue)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_rx)(void *, struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_receive_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_list_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_ni_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_exit)(void *, int);

typedef void (*btf_trace_napi_gro_receive_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_exit)(void *, int);

typedef void (*btf_trace_netif_rx_exit)(void *, int);

typedef void (*btf_trace_netif_rx_ni_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_list_exit)(void *, int);

struct trace_event_raw_napi_poll {
	struct trace_entry ent;
	struct napi_struct *napi;
	u32 __data_loc_dev_name;
	int work;
	int budget;
	char __data[0];
};

struct trace_event_data_offsets_napi_poll {
	u32 dev_name;
};

typedef void (*btf_trace_napi_poll)(void *, struct napi_struct *, int, int);

enum tcp_ca_state {
	TCP_CA_Open = 0,
	TCP_CA_Disorder = 1,
	TCP_CA_CWR = 2,
	TCP_CA_Recovery = 3,
	TCP_CA_Loss = 4,
};

struct trace_event_raw_sock_rcvqueue_full {
	struct trace_entry ent;
	int rmem_alloc;
	unsigned int truesize;
	int sk_rcvbuf;
	char __data[0];
};

struct trace_event_raw_sock_exceed_buf_limit {
	struct trace_entry ent;
	char name[32];
	long int *sysctl_mem;
	long int allocated;
	int sysctl_rmem;
	int rmem_alloc;
	int sysctl_wmem;
	int wmem_alloc;
	int wmem_queued;
	int kind;
	char __data[0];
};

struct trace_event_raw_inet_sock_set_state {
	struct trace_entry ent;
	const void *skaddr;
	int oldstate;
	int newstate;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_data_offsets_sock_rcvqueue_full {};

struct trace_event_data_offsets_sock_exceed_buf_limit {};

struct trace_event_data_offsets_inet_sock_set_state {};

typedef void (*btf_trace_sock_rcvqueue_full)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_sock_exceed_buf_limit)(void *, struct sock *, struct proto *, long int, int);

typedef void (*btf_trace_inet_sock_set_state)(void *, const struct sock *, const int, const int);

struct trace_event_raw_udp_fail_queue_rcv_skb {
	struct trace_entry ent;
	int rc;
	__u16 lport;
	char __data[0];
};

struct trace_event_data_offsets_udp_fail_queue_rcv_skb {};

typedef void (*btf_trace_udp_fail_queue_rcv_skb)(void *, int, struct sock *);

struct trace_event_raw_tcp_event_sk_skb {
	struct trace_entry ent;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_event_sk {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_raw_tcp_retransmit_synack {
	struct trace_entry ent;
	const void *skaddr;
	const void *req;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_probe {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u32 mark;
	__u16 data_len;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 snd_cwnd;
	__u32 ssthresh;
	__u32 snd_wnd;
	__u32 srtt;
	__u32 rcv_wnd;
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_data_offsets_tcp_event_sk_skb {};

struct trace_event_data_offsets_tcp_event_sk {};

struct trace_event_data_offsets_tcp_retransmit_synack {};

struct trace_event_data_offsets_tcp_probe {};

typedef void (*btf_trace_tcp_retransmit_skb)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_send_reset)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_receive_reset)(void *, struct sock *);

typedef void (*btf_trace_tcp_destroy_sock)(void *, struct sock *);

typedef void (*btf_trace_tcp_rcv_space_adjust)(void *, struct sock *);

typedef void (*btf_trace_tcp_retransmit_synack)(void *, const struct sock *, const struct request_sock *);

typedef void (*btf_trace_tcp_probe)(void *, struct sock *, struct sk_buff *);

struct trace_event_raw_fib_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	u8 proto;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[4];
	__u8 dst[4];
	__u8 gw4[4];
	__u8 gw6[16];
	u16 sport;
	u16 dport;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_fib_table_lookup {
	u32 name;
};

typedef void (*btf_trace_fib_table_lookup)(void *, u32, const struct flowi4 *, const struct fib_nh_common *, int);

struct trace_event_raw_qdisc_dequeue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	int packets;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	long unsigned int txq_state;
	char __data[0];
};

struct trace_event_raw_qdisc_reset {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_destroy {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_create {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	char __data[0];
};

struct trace_event_data_offsets_qdisc_dequeue {};

struct trace_event_data_offsets_qdisc_reset {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_destroy {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_create {
	u32 dev;
	u32 kind;
};

typedef void (*btf_trace_qdisc_dequeue)(void *, struct Qdisc *, const struct netdev_queue *, int, struct sk_buff *);

typedef void (*btf_trace_qdisc_reset)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_destroy)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_create)(void *, const struct Qdisc_ops *, struct net_device *, u32);

struct bridge_stp_xstats {
	__u64 transition_blk;
	__u64 transition_fwd;
	__u64 rx_bpdu;
	__u64 tx_bpdu;
	__u64 rx_tcn;
	__u64 tx_tcn;
};

struct br_mcast_stats {
	__u64 igmp_v1queries[2];
	__u64 igmp_v2queries[2];
	__u64 igmp_v3queries[2];
	__u64 igmp_leaves[2];
	__u64 igmp_v1reports[2];
	__u64 igmp_v2reports[2];
	__u64 igmp_v3reports[2];
	__u64 igmp_parse_errors;
	__u64 mld_v1queries[2];
	__u64 mld_v2queries[2];
	__u64 mld_leaves[2];
	__u64 mld_v1reports[2];
	__u64 mld_v2reports[2];
	__u64 mld_parse_errors;
	__u64 mcast_bytes[2];
	__u64 mcast_packets[2];
};

struct br_ip {
	union {
		__be32 ip4;
		struct in6_addr ip6;
	} src;
	union {
		__be32 ip4;
		struct in6_addr ip6;
		unsigned char mac_addr[6];
	} dst;
	__be16 proto;
	__u16 vid;
};

struct bridge_id {
	unsigned char prio[2];
	unsigned char addr[6];
};

typedef struct bridge_id bridge_id;

struct mac_addr___2 {
	unsigned char addr[6];
};

typedef struct mac_addr___2 mac_addr;

typedef __u16 port_id;

struct bridge_mcast_own_query {
	struct timer_list timer;
	u32 startup_sent;
};

struct bridge_mcast_other_query {
	struct timer_list timer;
	long unsigned int delay_time;
};

struct net_bridge_port;

struct bridge_mcast_querier {
	struct br_ip addr;
	struct net_bridge_port *port;
};

struct net_bridge;

struct net_bridge_vlan_group;

struct bridge_mcast_stats;

struct net_bridge_port {
	struct net_bridge *br;
	struct net_device *dev;
	struct list_head list;
	long unsigned int flags;
	struct net_bridge_vlan_group *vlgrp;
	struct net_bridge_port *backup_port;
	u8 priority;
	u8 state;
	u16 port_no;
	unsigned char topology_change_ack;
	unsigned char config_pending;
	port_id port_id;
	port_id designated_port;
	bridge_id designated_root;
	bridge_id designated_bridge;
	u32 path_cost;
	u32 designated_cost;
	long unsigned int designated_age;
	struct timer_list forward_delay_timer;
	struct timer_list hold_timer;
	struct timer_list message_age_timer;
	struct kobject kobj;
	struct callback_head rcu;
	struct bridge_mcast_own_query ip4_own_query;
	struct bridge_mcast_own_query ip6_own_query;
	u32 multicast_eht_hosts_limit;
	u32 multicast_eht_hosts_cnt;
	unsigned char multicast_router;
	struct bridge_mcast_stats *mcast_stats;
	struct timer_list multicast_router_timer;
	struct hlist_head mglist;
	struct hlist_node rlist;
	char sysfs_name[16];
	struct netpoll *np;
	int offload_fwd_mark;
	u16 group_fwd_mask;
	u16 backup_redirected_cnt;
	struct bridge_stp_xstats stp_xstats;
};

struct bridge_mcast_stats {
	struct br_mcast_stats mstats;
	struct u64_stats_sync syncp;
};

struct net_bridge {
	spinlock_t lock;
	spinlock_t hash_lock;
	struct hlist_head frame_type_list;
	struct net_device *dev;
	long unsigned int options;
	__be16 vlan_proto;
	u16 default_pvid;
	struct net_bridge_vlan_group *vlgrp;
	struct rhashtable fdb_hash_tbl;
	struct list_head port_list;
	union {
		struct rtable fake_rtable;
		struct rt6_info fake_rt6_info;
	};
	u16 group_fwd_mask;
	u16 group_fwd_mask_required;
	bridge_id designated_root;
	bridge_id bridge_id;
	unsigned char topology_change;
	unsigned char topology_change_detected;
	u16 root_port;
	long unsigned int max_age;
	long unsigned int hello_time;
	long unsigned int forward_delay;
	long unsigned int ageing_time;
	long unsigned int bridge_max_age;
	long unsigned int bridge_hello_time;
	long unsigned int bridge_forward_delay;
	long unsigned int bridge_ageing_time;
	u32 root_path_cost;
	u8 group_addr[6];
	enum {
		BR_NO_STP = 0,
		BR_KERNEL_STP = 1,
		BR_USER_STP = 2,
	} stp_enabled;
	u32 hash_max;
	u32 multicast_last_member_count;
	u32 multicast_startup_query_count;
	u8 multicast_igmp_version;
	u8 multicast_router;
	u8 multicast_mld_version;
	spinlock_t multicast_lock;
	long unsigned int multicast_last_member_interval;
	long unsigned int multicast_membership_interval;
	long unsigned int multicast_querier_interval;
	long unsigned int multicast_query_interval;
	long unsigned int multicast_query_response_interval;
	long unsigned int multicast_startup_query_interval;
	struct rhashtable mdb_hash_tbl;
	struct rhashtable sg_port_tbl;
	struct hlist_head mcast_gc_list;
	struct hlist_head mdb_list;
	struct hlist_head router_list;
	struct timer_list multicast_router_timer;
	struct bridge_mcast_other_query ip4_other_query;
	struct bridge_mcast_own_query ip4_own_query;
	struct bridge_mcast_querier ip4_querier;
	struct bridge_mcast_stats *mcast_stats;
	struct bridge_mcast_other_query ip6_other_query;
	struct bridge_mcast_own_query ip6_own_query;
	struct bridge_mcast_querier ip6_querier;
	struct work_struct mcast_gc_work;
	struct timer_list hello_timer;
	struct timer_list tcn_timer;
	struct timer_list topology_change_timer;
	struct delayed_work gc_work;
	struct kobject *ifobj;
	u32 auto_cnt;
	int offload_fwd_mark;
	struct hlist_head fdb_list;
	struct hlist_head mrp_list;
	struct hlist_head mep_list;
};

struct net_bridge_vlan_group {
	struct rhashtable vlan_hash;
	struct rhashtable tunnel_hash;
	struct list_head vlan_list;
	u16 num_vlans;
	u16 pvid;
	u8 pvid_state;
};

struct net_bridge_fdb_key {
	mac_addr addr;
	u16 vlan_id;
};

struct net_bridge_fdb_entry {
	struct rhash_head rhnode;
	struct net_bridge_port *dst;
	struct net_bridge_fdb_key key;
	struct hlist_node fdb_node;
	long unsigned int flags;
	long: 64;
	long: 64;
	long unsigned int updated;
	long unsigned int used;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nf_br_ops {
	int (*br_dev_xmit_hook)(struct sk_buff *);
};

struct trace_event_raw_br_fdb_add {
	struct trace_entry ent;
	u8 ndm_flags;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	u16 nlh_flags;
	char __data[0];
};

struct trace_event_raw_br_fdb_external_learn_add {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_fdb_delete {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_br_fdb_update {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_data_offsets_br_fdb_add {
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_external_learn_add {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_fdb_delete {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_update {
	u32 br_dev;
	u32 dev;
};

typedef void (*btf_trace_br_fdb_add)(void *, struct ndmsg *, struct net_device *, const unsigned char *, u16, u16);

typedef void (*btf_trace_br_fdb_external_learn_add)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16);

typedef void (*btf_trace_fdb_delete)(void *, struct net_bridge *, struct net_bridge_fdb_entry *);

typedef void (*btf_trace_br_fdb_update)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16, long unsigned int);

struct trace_event_raw_page_pool_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	s32 inflight;
	u32 hold;
	u32 release;
	u64 cnt;
	char __data[0];
};

struct trace_event_raw_page_pool_state_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 release;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_state_hold {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 hold;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_update_nid {
	struct trace_entry ent;
	const struct page_pool *pool;
	int pool_nid;
	int new_nid;
	char __data[0];
};

struct trace_event_data_offsets_page_pool_release {};

struct trace_event_data_offsets_page_pool_state_release {};

struct trace_event_data_offsets_page_pool_state_hold {};

struct trace_event_data_offsets_page_pool_update_nid {};

typedef void (*btf_trace_page_pool_release)(void *, const struct page_pool *, s32, u32, u32);

typedef void (*btf_trace_page_pool_state_release)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_state_hold)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_update_nid)(void *, const struct page_pool *, int);

struct trace_event_raw_neigh_create {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	int entries;
	u8 created;
	u8 gc_exempt;
	u8 primary_key4[4];
	u8 primary_key6[16];
	char __data[0];
};

struct trace_event_raw_neigh_update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u8 new_lladdr[32];
	u8 new_state;
	u32 update_flags;
	u32 pid;
	char __data[0];
};

struct trace_event_raw_neigh__update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u32 err;
	char __data[0];
};

struct trace_event_data_offsets_neigh_create {
	u32 dev;
};

struct trace_event_data_offsets_neigh_update {
	u32 dev;
};

struct trace_event_data_offsets_neigh__update {
	u32 dev;
};

typedef void (*btf_trace_neigh_create)(void *, struct neigh_table *, struct net_device *, const void *, const struct neighbour *, bool);

typedef void (*btf_trace_neigh_update)(void *, struct neighbour *, const u8 *, u8, u32, u32);

typedef void (*btf_trace_neigh_update_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_timer_handler)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_dead)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_cleanup_and_release)(void *, struct neighbour *, int);

struct net_dm_drop_point {
	__u8 pc[8];
	__u32 count;
};

struct net_dm_alert_msg {
	__u32 entries;
	struct net_dm_drop_point points[0];
};

enum {
	NET_DM_CMD_UNSPEC = 0,
	NET_DM_CMD_ALERT = 1,
	NET_DM_CMD_CONFIG = 2,
	NET_DM_CMD_START = 3,
	NET_DM_CMD_STOP = 4,
	NET_DM_CMD_PACKET_ALERT = 5,
	NET_DM_CMD_CONFIG_GET = 6,
	NET_DM_CMD_CONFIG_NEW = 7,
	NET_DM_CMD_STATS_GET = 8,
	NET_DM_CMD_STATS_NEW = 9,
	_NET_DM_CMD_MAX = 10,
};

enum net_dm_attr {
	NET_DM_ATTR_UNSPEC = 0,
	NET_DM_ATTR_ALERT_MODE = 1,
	NET_DM_ATTR_PC = 2,
	NET_DM_ATTR_SYMBOL = 3,
	NET_DM_ATTR_IN_PORT = 4,
	NET_DM_ATTR_TIMESTAMP = 5,
	NET_DM_ATTR_PROTO = 6,
	NET_DM_ATTR_PAYLOAD = 7,
	NET_DM_ATTR_PAD = 8,
	NET_DM_ATTR_TRUNC_LEN = 9,
	NET_DM_ATTR_ORIG_LEN = 10,
	NET_DM_ATTR_QUEUE_LEN = 11,
	NET_DM_ATTR_STATS = 12,
	NET_DM_ATTR_HW_STATS = 13,
	NET_DM_ATTR_ORIGIN = 14,
	NET_DM_ATTR_HW_TRAP_GROUP_NAME = 15,
	NET_DM_ATTR_HW_TRAP_NAME = 16,
	NET_DM_ATTR_HW_ENTRIES = 17,
	NET_DM_ATTR_HW_ENTRY = 18,
	NET_DM_ATTR_HW_TRAP_COUNT = 19,
	NET_DM_ATTR_SW_DROPS = 20,
	NET_DM_ATTR_HW_DROPS = 21,
	NET_DM_ATTR_FLOW_ACTION_COOKIE = 22,
	__NET_DM_ATTR_MAX = 23,
	NET_DM_ATTR_MAX = 22,
};

enum net_dm_alert_mode {
	NET_DM_ALERT_MODE_SUMMARY = 0,
	NET_DM_ALERT_MODE_PACKET = 1,
};

enum {
	NET_DM_ATTR_PORT_NETDEV_IFINDEX = 0,
	NET_DM_ATTR_PORT_NETDEV_NAME = 1,
	__NET_DM_ATTR_PORT_MAX = 2,
	NET_DM_ATTR_PORT_MAX = 1,
};

enum {
	NET_DM_ATTR_STATS_DROPPED = 0,
	__NET_DM_ATTR_STATS_MAX = 1,
	NET_DM_ATTR_STATS_MAX = 0,
};

enum net_dm_origin {
	NET_DM_ORIGIN_SW = 0,
	NET_DM_ORIGIN_HW = 1,
};

struct devlink_trap_metadata {
	const char *trap_name;
	const char *trap_group_name;
	struct net_device *input_dev;
	const struct flow_action_cookie *fa_cookie;
	enum devlink_trap_type trap_type;
};

struct net_dm_stats {
	u64 dropped;
	struct u64_stats_sync syncp;
};

struct net_dm_hw_entry {
	char trap_name[40];
	u32 count;
};

struct net_dm_hw_entries {
	u32 num_entries;
	struct net_dm_hw_entry entries[0];
};

struct per_cpu_dm_data {
	spinlock_t lock;
	union {
		struct sk_buff *skb;
		struct net_dm_hw_entries *hw_entries;
	};
	struct sk_buff_head drop_queue;
	struct work_struct dm_alert_work;
	struct timer_list send_timer;
	struct net_dm_stats stats;
};

struct dm_hw_stat_delta {
	struct net_device *dev;
	long unsigned int last_rx;
	struct list_head list;
	struct callback_head rcu;
	long unsigned int last_drop_val;
};

struct net_dm_alert_ops {
	void (*kfree_skb_probe)(void *, struct sk_buff *, void *);
	void (*napi_poll_probe)(void *, struct napi_struct *, int, int);
	void (*work_item_func)(struct work_struct *);
	void (*hw_work_item_func)(struct work_struct *);
	void (*hw_trap_probe)(void *, const struct devlink *, struct sk_buff *, const struct devlink_trap_metadata *);
};

struct net_dm_skb_cb {
	union {
		struct devlink_trap_metadata *hw_metadata;
		void *pc;
	};
};

enum ethtool_test_flags {
	ETH_TEST_FL_OFFLINE = 1,
	ETH_TEST_FL_FAILED = 2,
	ETH_TEST_FL_EXTERNAL_LB = 4,
	ETH_TEST_FL_EXTERNAL_LB_DONE = 8,
};

struct net_packet_attrs {
	unsigned char *src;
	unsigned char *dst;
	u32 ip_src;
	u32 ip_dst;
	bool tcp;
	u16 sport;
	u16 dport;
	int timeout;
	int size;
	int max_size;
	u8 id;
	u16 queue_mapping;
};

struct net_test_priv {
	struct net_packet_attrs *packet;
	struct packet_type pt;
	struct completion comp;
	int double_vlan;
	int vlan_id;
	int ok;
};

struct netsfhdr {
	__be32 version;
	__be64 magic;
	u8 id;
} __attribute__((packed));

struct net_test {
	char name[32];
	int (*fn)(struct net_device *);
};

struct update_classid_context {
	u32 classid;
	unsigned int batch;
};

struct rtnexthop {
	short unsigned int rtnh_len;
	unsigned char rtnh_flags;
	unsigned char rtnh_hops;
	int rtnh_ifindex;
};

struct lwtunnel_encap_ops {
	int (*build_state)(struct net *, struct nlattr *, unsigned int, const void *, struct lwtunnel_state **, struct netlink_ext_ack *);
	void (*destroy_state)(struct lwtunnel_state *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*input)(struct sk_buff *);
	int (*fill_encap)(struct sk_buff *, struct lwtunnel_state *);
	int (*get_encap_size)(struct lwtunnel_state *);
	int (*cmp_encap)(struct lwtunnel_state *, struct lwtunnel_state *);
	int (*xmit)(struct sk_buff *);
	struct module *owner;
};

enum {
	LWT_BPF_PROG_UNSPEC = 0,
	LWT_BPF_PROG_FD = 1,
	LWT_BPF_PROG_NAME = 2,
	__LWT_BPF_PROG_MAX = 3,
};

enum {
	LWT_BPF_UNSPEC = 0,
	LWT_BPF_IN = 1,
	LWT_BPF_OUT = 2,
	LWT_BPF_XMIT = 3,
	LWT_BPF_XMIT_HEADROOM = 4,
	__LWT_BPF_MAX = 5,
};

enum {
	LWTUNNEL_XMIT_DONE = 0,
	LWTUNNEL_XMIT_CONTINUE = 1,
};

struct bpf_lwt_prog {
	struct bpf_prog *prog;
	char *name;
};

struct bpf_lwt {
	struct bpf_lwt_prog in;
	struct bpf_lwt_prog out;
	struct bpf_lwt_prog xmit;
	int family;
};

struct dst_cache_pcpu {
	long unsigned int refresh_ts;
	struct dst_entry *dst;
	u32 cookie;
	union {
		struct in_addr in_saddr;
		struct in6_addr in6_saddr;
	};
};

enum devlink_command {
	DEVLINK_CMD_UNSPEC = 0,
	DEVLINK_CMD_GET = 1,
	DEVLINK_CMD_SET = 2,
	DEVLINK_CMD_NEW = 3,
	DEVLINK_CMD_DEL = 4,
	DEVLINK_CMD_PORT_GET = 5,
	DEVLINK_CMD_PORT_SET = 6,
	DEVLINK_CMD_PORT_NEW = 7,
	DEVLINK_CMD_PORT_DEL = 8,
	DEVLINK_CMD_PORT_SPLIT = 9,
	DEVLINK_CMD_PORT_UNSPLIT = 10,
	DEVLINK_CMD_SB_GET = 11,
	DEVLINK_CMD_SB_SET = 12,
	DEVLINK_CMD_SB_NEW = 13,
	DEVLINK_CMD_SB_DEL = 14,
	DEVLINK_CMD_SB_POOL_GET = 15,
	DEVLINK_CMD_SB_POOL_SET = 16,
	DEVLINK_CMD_SB_POOL_NEW = 17,
	DEVLINK_CMD_SB_POOL_DEL = 18,
	DEVLINK_CMD_SB_PORT_POOL_GET = 19,
	DEVLINK_CMD_SB_PORT_POOL_SET = 20,
	DEVLINK_CMD_SB_PORT_POOL_NEW = 21,
	DEVLINK_CMD_SB_PORT_POOL_DEL = 22,
	DEVLINK_CMD_SB_TC_POOL_BIND_GET = 23,
	DEVLINK_CMD_SB_TC_POOL_BIND_SET = 24,
	DEVLINK_CMD_SB_TC_POOL_BIND_NEW = 25,
	DEVLINK_CMD_SB_TC_POOL_BIND_DEL = 26,
	DEVLINK_CMD_SB_OCC_SNAPSHOT = 27,
	DEVLINK_CMD_SB_OCC_MAX_CLEAR = 28,
	DEVLINK_CMD_ESWITCH_GET = 29,
	DEVLINK_CMD_ESWITCH_SET = 30,
	DEVLINK_CMD_DPIPE_TABLE_GET = 31,
	DEVLINK_CMD_DPIPE_ENTRIES_GET = 32,
	DEVLINK_CMD_DPIPE_HEADERS_GET = 33,
	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET = 34,
	DEVLINK_CMD_RESOURCE_SET = 35,
	DEVLINK_CMD_RESOURCE_DUMP = 36,
	DEVLINK_CMD_RELOAD = 37,
	DEVLINK_CMD_PARAM_GET = 38,
	DEVLINK_CMD_PARAM_SET = 39,
	DEVLINK_CMD_PARAM_NEW = 40,
	DEVLINK_CMD_PARAM_DEL = 41,
	DEVLINK_CMD_REGION_GET = 42,
	DEVLINK_CMD_REGION_SET = 43,
	DEVLINK_CMD_REGION_NEW = 44,
	DEVLINK_CMD_REGION_DEL = 45,
	DEVLINK_CMD_REGION_READ = 46,
	DEVLINK_CMD_PORT_PARAM_GET = 47,
	DEVLINK_CMD_PORT_PARAM_SET = 48,
	DEVLINK_CMD_PORT_PARAM_NEW = 49,
	DEVLINK_CMD_PORT_PARAM_DEL = 50,
	DEVLINK_CMD_INFO_GET = 51,
	DEVLINK_CMD_HEALTH_REPORTER_GET = 52,
	DEVLINK_CMD_HEALTH_REPORTER_SET = 53,
	DEVLINK_CMD_HEALTH_REPORTER_RECOVER = 54,
	DEVLINK_CMD_HEALTH_REPORTER_DIAGNOSE = 55,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_GET = 56,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_CLEAR = 57,
	DEVLINK_CMD_FLASH_UPDATE = 58,
	DEVLINK_CMD_FLASH_UPDATE_END = 59,
	DEVLINK_CMD_FLASH_UPDATE_STATUS = 60,
	DEVLINK_CMD_TRAP_GET = 61,
	DEVLINK_CMD_TRAP_SET = 62,
	DEVLINK_CMD_TRAP_NEW = 63,
	DEVLINK_CMD_TRAP_DEL = 64,
	DEVLINK_CMD_TRAP_GROUP_GET = 65,
	DEVLINK_CMD_TRAP_GROUP_SET = 66,
	DEVLINK_CMD_TRAP_GROUP_NEW = 67,
	DEVLINK_CMD_TRAP_GROUP_DEL = 68,
	DEVLINK_CMD_TRAP_POLICER_GET = 69,
	DEVLINK_CMD_TRAP_POLICER_SET = 70,
	DEVLINK_CMD_TRAP_POLICER_NEW = 71,
	DEVLINK_CMD_TRAP_POLICER_DEL = 72,
	DEVLINK_CMD_HEALTH_REPORTER_TEST = 73,
	__DEVLINK_CMD_MAX = 74,
	DEVLINK_CMD_MAX = 73,
};

enum devlink_eswitch_mode {
	DEVLINK_ESWITCH_MODE_LEGACY = 0,
	DEVLINK_ESWITCH_MODE_SWITCHDEV = 1,
};

enum {
	DEVLINK_ATTR_STATS_RX_PACKETS = 0,
	DEVLINK_ATTR_STATS_RX_BYTES = 1,
	DEVLINK_ATTR_STATS_RX_DROPPED = 2,
	__DEVLINK_ATTR_STATS_MAX = 3,
	DEVLINK_ATTR_STATS_MAX = 2,
};

enum {
	DEVLINK_FLASH_OVERWRITE_SETTINGS_BIT = 0,
	DEVLINK_FLASH_OVERWRITE_IDENTIFIERS_BIT = 1,
	__DEVLINK_FLASH_OVERWRITE_MAX_BIT = 2,
	DEVLINK_FLASH_OVERWRITE_MAX_BIT = 1,
};

enum {
	DEVLINK_ATTR_TRAP_METADATA_TYPE_IN_PORT = 0,
	DEVLINK_ATTR_TRAP_METADATA_TYPE_FA_COOKIE = 1,
};

enum devlink_attr {
	DEVLINK_ATTR_UNSPEC = 0,
	DEVLINK_ATTR_BUS_NAME = 1,
	DEVLINK_ATTR_DEV_NAME = 2,
	DEVLINK_ATTR_PORT_INDEX = 3,
	DEVLINK_ATTR_PORT_TYPE = 4,
	DEVLINK_ATTR_PORT_DESIRED_TYPE = 5,
	DEVLINK_ATTR_PORT_NETDEV_IFINDEX = 6,
	DEVLINK_ATTR_PORT_NETDEV_NAME = 7,
	DEVLINK_ATTR_PORT_IBDEV_NAME = 8,
	DEVLINK_ATTR_PORT_SPLIT_COUNT = 9,
	DEVLINK_ATTR_PORT_SPLIT_GROUP = 10,
	DEVLINK_ATTR_SB_INDEX = 11,
	DEVLINK_ATTR_SB_SIZE = 12,
	DEVLINK_ATTR_SB_INGRESS_POOL_COUNT = 13,
	DEVLINK_ATTR_SB_EGRESS_POOL_COUNT = 14,
	DEVLINK_ATTR_SB_INGRESS_TC_COUNT = 15,
	DEVLINK_ATTR_SB_EGRESS_TC_COUNT = 16,
	DEVLINK_ATTR_SB_POOL_INDEX = 17,
	DEVLINK_ATTR_SB_POOL_TYPE = 18,
	DEVLINK_ATTR_SB_POOL_SIZE = 19,
	DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE = 20,
	DEVLINK_ATTR_SB_THRESHOLD = 21,
	DEVLINK_ATTR_SB_TC_INDEX = 22,
	DEVLINK_ATTR_SB_OCC_CUR = 23,
	DEVLINK_ATTR_SB_OCC_MAX = 24,
	DEVLINK_ATTR_ESWITCH_MODE = 25,
	DEVLINK_ATTR_ESWITCH_INLINE_MODE = 26,
	DEVLINK_ATTR_DPIPE_TABLES = 27,
	DEVLINK_ATTR_DPIPE_TABLE = 28,
	DEVLINK_ATTR_DPIPE_TABLE_NAME = 29,
	DEVLINK_ATTR_DPIPE_TABLE_SIZE = 30,
	DEVLINK_ATTR_DPIPE_TABLE_MATCHES = 31,
	DEVLINK_ATTR_DPIPE_TABLE_ACTIONS = 32,
	DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED = 33,
	DEVLINK_ATTR_DPIPE_ENTRIES = 34,
	DEVLINK_ATTR_DPIPE_ENTRY = 35,
	DEVLINK_ATTR_DPIPE_ENTRY_INDEX = 36,
	DEVLINK_ATTR_DPIPE_ENTRY_MATCH_VALUES = 37,
	DEVLINK_ATTR_DPIPE_ENTRY_ACTION_VALUES = 38,
	DEVLINK_ATTR_DPIPE_ENTRY_COUNTER = 39,
	DEVLINK_ATTR_DPIPE_MATCH = 40,
	DEVLINK_ATTR_DPIPE_MATCH_VALUE = 41,
	DEVLINK_ATTR_DPIPE_MATCH_TYPE = 42,
	DEVLINK_ATTR_DPIPE_ACTION = 43,
	DEVLINK_ATTR_DPIPE_ACTION_VALUE = 44,
	DEVLINK_ATTR_DPIPE_ACTION_TYPE = 45,
	DEVLINK_ATTR_DPIPE_VALUE = 46,
	DEVLINK_ATTR_DPIPE_VALUE_MASK = 47,
	DEVLINK_ATTR_DPIPE_VALUE_MAPPING = 48,
	DEVLINK_ATTR_DPIPE_HEADERS = 49,
	DEVLINK_ATTR_DPIPE_HEADER = 50,
	DEVLINK_ATTR_DPIPE_HEADER_NAME = 51,
	DEVLINK_ATTR_DPIPE_HEADER_ID = 52,
	DEVLINK_ATTR_DPIPE_HEADER_FIELDS = 53,
	DEVLINK_ATTR_DPIPE_HEADER_GLOBAL = 54,
	DEVLINK_ATTR_DPIPE_HEADER_INDEX = 55,
	DEVLINK_ATTR_DPIPE_FIELD = 56,
	DEVLINK_ATTR_DPIPE_FIELD_NAME = 57,
	DEVLINK_ATTR_DPIPE_FIELD_ID = 58,
	DEVLINK_ATTR_DPIPE_FIELD_BITWIDTH = 59,
	DEVLINK_ATTR_DPIPE_FIELD_MAPPING_TYPE = 60,
	DEVLINK_ATTR_PAD = 61,
	DEVLINK_ATTR_ESWITCH_ENCAP_MODE = 62,
	DEVLINK_ATTR_RESOURCE_LIST = 63,
	DEVLINK_ATTR_RESOURCE = 64,
	DEVLINK_ATTR_RESOURCE_NAME = 65,
	DEVLINK_ATTR_RESOURCE_ID = 66,
	DEVLINK_ATTR_RESOURCE_SIZE = 67,
	DEVLINK_ATTR_RESOURCE_SIZE_NEW = 68,
	DEVLINK_ATTR_RESOURCE_SIZE_VALID = 69,
	DEVLINK_ATTR_RESOURCE_SIZE_MIN = 70,
	DEVLINK_ATTR_RESOURCE_SIZE_MAX = 71,
	DEVLINK_ATTR_RESOURCE_SIZE_GRAN = 72,
	DEVLINK_ATTR_RESOURCE_UNIT = 73,
	DEVLINK_ATTR_RESOURCE_OCC = 74,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_ID = 75,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_UNITS = 76,
	DEVLINK_ATTR_PORT_FLAVOUR = 77,
	DEVLINK_ATTR_PORT_NUMBER = 78,
	DEVLINK_ATTR_PORT_SPLIT_SUBPORT_NUMBER = 79,
	DEVLINK_ATTR_PARAM = 80,
	DEVLINK_ATTR_PARAM_NAME = 81,
	DEVLINK_ATTR_PARAM_GENERIC = 82,
	DEVLINK_ATTR_PARAM_TYPE = 83,
	DEVLINK_ATTR_PARAM_VALUES_LIST = 84,
	DEVLINK_ATTR_PARAM_VALUE = 85,
	DEVLINK_ATTR_PARAM_VALUE_DATA = 86,
	DEVLINK_ATTR_PARAM_VALUE_CMODE = 87,
	DEVLINK_ATTR_REGION_NAME = 88,
	DEVLINK_ATTR_REGION_SIZE = 89,
	DEVLINK_ATTR_REGION_SNAPSHOTS = 90,
	DEVLINK_ATTR_REGION_SNAPSHOT = 91,
	DEVLINK_ATTR_REGION_SNAPSHOT_ID = 92,
	DEVLINK_ATTR_REGION_CHUNKS = 93,
	DEVLINK_ATTR_REGION_CHUNK = 94,
	DEVLINK_ATTR_REGION_CHUNK_DATA = 95,
	DEVLINK_ATTR_REGION_CHUNK_ADDR = 96,
	DEVLINK_ATTR_REGION_CHUNK_LEN = 97,
	DEVLINK_ATTR_INFO_DRIVER_NAME = 98,
	DEVLINK_ATTR_INFO_SERIAL_NUMBER = 99,
	DEVLINK_ATTR_INFO_VERSION_FIXED = 100,
	DEVLINK_ATTR_INFO_VERSION_RUNNING = 101,
	DEVLINK_ATTR_INFO_VERSION_STORED = 102,
	DEVLINK_ATTR_INFO_VERSION_NAME = 103,
	DEVLINK_ATTR_INFO_VERSION_VALUE = 104,
	DEVLINK_ATTR_SB_POOL_CELL_SIZE = 105,
	DEVLINK_ATTR_FMSG = 106,
	DEVLINK_ATTR_FMSG_OBJ_NEST_START = 107,
	DEVLINK_ATTR_FMSG_PAIR_NEST_START = 108,
	DEVLINK_ATTR_FMSG_ARR_NEST_START = 109,
	DEVLINK_ATTR_FMSG_NEST_END = 110,
	DEVLINK_ATTR_FMSG_OBJ_NAME = 111,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_TYPE = 112,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_DATA = 113,
	DEVLINK_ATTR_HEALTH_REPORTER = 114,
	DEVLINK_ATTR_HEALTH_REPORTER_NAME = 115,
	DEVLINK_ATTR_HEALTH_REPORTER_STATE = 116,
	DEVLINK_ATTR_HEALTH_REPORTER_ERR_COUNT = 117,
	DEVLINK_ATTR_HEALTH_REPORTER_RECOVER_COUNT = 118,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS = 119,
	DEVLINK_ATTR_HEALTH_REPORTER_GRACEFUL_PERIOD = 120,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_RECOVER = 121,
	DEVLINK_ATTR_FLASH_UPDATE_FILE_NAME = 122,
	DEVLINK_ATTR_FLASH_UPDATE_COMPONENT = 123,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_MSG = 124,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_DONE = 125,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TOTAL = 126,
	DEVLINK_ATTR_PORT_PCI_PF_NUMBER = 127,
	DEVLINK_ATTR_PORT_PCI_VF_NUMBER = 128,
	DEVLINK_ATTR_STATS = 129,
	DEVLINK_ATTR_TRAP_NAME = 130,
	DEVLINK_ATTR_TRAP_ACTION = 131,
	DEVLINK_ATTR_TRAP_TYPE = 132,
	DEVLINK_ATTR_TRAP_GENERIC = 133,
	DEVLINK_ATTR_TRAP_METADATA = 134,
	DEVLINK_ATTR_TRAP_GROUP_NAME = 135,
	DEVLINK_ATTR_RELOAD_FAILED = 136,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS_NS = 137,
	DEVLINK_ATTR_NETNS_FD = 138,
	DEVLINK_ATTR_NETNS_PID = 139,
	DEVLINK_ATTR_NETNS_ID = 140,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_DUMP = 141,
	DEVLINK_ATTR_TRAP_POLICER_ID = 142,
	DEVLINK_ATTR_TRAP_POLICER_RATE = 143,
	DEVLINK_ATTR_TRAP_POLICER_BURST = 144,
	DEVLINK_ATTR_PORT_FUNCTION = 145,
	DEVLINK_ATTR_INFO_BOARD_SERIAL_NUMBER = 146,
	DEVLINK_ATTR_PORT_LANES = 147,
	DEVLINK_ATTR_PORT_SPLITTABLE = 148,
	DEVLINK_ATTR_PORT_EXTERNAL = 149,
	DEVLINK_ATTR_PORT_CONTROLLER_NUMBER = 150,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TIMEOUT = 151,
	DEVLINK_ATTR_FLASH_UPDATE_OVERWRITE_MASK = 152,
	DEVLINK_ATTR_RELOAD_ACTION = 153,
	DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED = 154,
	DEVLINK_ATTR_RELOAD_LIMITS = 155,
	DEVLINK_ATTR_DEV_STATS = 156,
	DEVLINK_ATTR_RELOAD_STATS = 157,
	DEVLINK_ATTR_RELOAD_STATS_ENTRY = 158,
	DEVLINK_ATTR_RELOAD_STATS_LIMIT = 159,
	DEVLINK_ATTR_RELOAD_STATS_VALUE = 160,
	DEVLINK_ATTR_REMOTE_RELOAD_STATS = 161,
	DEVLINK_ATTR_RELOAD_ACTION_INFO = 162,
	DEVLINK_ATTR_RELOAD_ACTION_STATS = 163,
	DEVLINK_ATTR_PORT_PCI_SF_NUMBER = 164,
	__DEVLINK_ATTR_MAX = 165,
	DEVLINK_ATTR_MAX = 164,
};

enum devlink_dpipe_match_type {
	DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT = 0,
};

enum devlink_dpipe_action_type {
	DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY = 0,
};

enum devlink_dpipe_field_ethernet_id {
	DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC = 0,
};

enum devlink_dpipe_field_ipv4_id {
	DEVLINK_DPIPE_FIELD_IPV4_DST_IP = 0,
};

enum devlink_dpipe_field_ipv6_id {
	DEVLINK_DPIPE_FIELD_IPV6_DST_IP = 0,
};

enum devlink_dpipe_header_id {
	DEVLINK_DPIPE_HEADER_ETHERNET = 0,
	DEVLINK_DPIPE_HEADER_IPV4 = 1,
	DEVLINK_DPIPE_HEADER_IPV6 = 2,
};

enum devlink_resource_unit {
	DEVLINK_RESOURCE_UNIT_ENTRY = 0,
};

enum devlink_port_function_attr {
	DEVLINK_PORT_FUNCTION_ATTR_UNSPEC = 0,
	DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR = 1,
	DEVLINK_PORT_FN_ATTR_STATE = 2,
	DEVLINK_PORT_FN_ATTR_OPSTATE = 3,
	__DEVLINK_PORT_FUNCTION_ATTR_MAX = 4,
	DEVLINK_PORT_FUNCTION_ATTR_MAX = 3,
};

struct devlink_dpipe_match {
	enum devlink_dpipe_match_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_action {
	enum devlink_dpipe_action_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_value {
	union {
		struct devlink_dpipe_action *action;
		struct devlink_dpipe_match *match;
	};
	unsigned int mapping_value;
	bool mapping_valid;
	unsigned int value_size;
	void *value;
	void *mask;
};

struct devlink_dpipe_entry {
	u64 index;
	struct devlink_dpipe_value *match_values;
	unsigned int match_values_count;
	struct devlink_dpipe_value *action_values;
	unsigned int action_values_count;
	u64 counter;
	bool counter_valid;
};

struct devlink_dpipe_dump_ctx {
	struct genl_info *info;
	enum devlink_command cmd;
	struct sk_buff *skb;
	struct nlattr *nest;
	void *hdr;
};

struct devlink_dpipe_table_ops;

struct devlink_dpipe_table {
	void *priv;
	struct list_head list;
	const char *name;
	bool counters_enabled;
	bool counter_control_extern;
	bool resource_valid;
	u64 resource_id;
	u64 resource_units;
	struct devlink_dpipe_table_ops *table_ops;
	struct callback_head rcu;
};

struct devlink_dpipe_table_ops {
	int (*actions_dump)(void *, struct sk_buff *);
	int (*matches_dump)(void *, struct sk_buff *);
	int (*entries_dump)(void *, bool, struct devlink_dpipe_dump_ctx *);
	int (*counters_set_update)(void *, bool);
	u64 (*size_get)(void *);
};

struct devlink_resource_size_params {
	u64 size_min;
	u64 size_max;
	u64 size_granularity;
	enum devlink_resource_unit unit;
};

typedef u64 devlink_resource_occ_get_t(void *);

struct devlink_resource {
	const char *name;
	u64 id;
	u64 size;
	u64 size_new;
	bool size_valid;
	struct devlink_resource *parent;
	struct devlink_resource_size_params size_params;
	struct list_head list;
	struct list_head resource_list;
	devlink_resource_occ_get_t *occ_get;
	void *occ_get_priv;
};

enum devlink_param_type {
	DEVLINK_PARAM_TYPE_U8 = 0,
	DEVLINK_PARAM_TYPE_U16 = 1,
	DEVLINK_PARAM_TYPE_U32 = 2,
	DEVLINK_PARAM_TYPE_STRING = 3,
	DEVLINK_PARAM_TYPE_BOOL = 4,
};

struct devlink_flash_notify {
	const char *status_msg;
	const char *component;
	long unsigned int done;
	long unsigned int total;
	long unsigned int timeout;
};

struct devlink_param {
	u32 id;
	const char *name;
	bool generic;
	enum devlink_param_type type;
	long unsigned int supported_cmodes;
	int (*get)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*set)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*validate)(struct devlink *, u32, union devlink_param_value, struct netlink_ext_ack *);
};

struct devlink_param_item {
	struct list_head list;
	const struct devlink_param *param;
	union devlink_param_value driverinit_value;
	bool driverinit_value_valid;
	bool published;
};

enum devlink_param_generic_id {
	DEVLINK_PARAM_GENERIC_ID_INT_ERR_RESET = 0,
	DEVLINK_PARAM_GENERIC_ID_MAX_MACS = 1,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_SRIOV = 2,
	DEVLINK_PARAM_GENERIC_ID_REGION_SNAPSHOT = 3,
	DEVLINK_PARAM_GENERIC_ID_IGNORE_ARI = 4,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MAX = 5,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MIN = 6,
	DEVLINK_PARAM_GENERIC_ID_FW_LOAD_POLICY = 7,
	DEVLINK_PARAM_GENERIC_ID_RESET_DEV_ON_DRV_PROBE = 8,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE = 9,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_REMOTE_DEV_RESET = 10,
	__DEVLINK_PARAM_GENERIC_ID_MAX = 11,
	DEVLINK_PARAM_GENERIC_ID_MAX = 10,
};

struct devlink_region_ops {
	const char *name;
	void (*destructor)(const void *);
	int (*snapshot)(struct devlink *, const struct devlink_region_ops *, struct netlink_ext_ack *, u8 **);
	void *priv;
};

struct devlink_port_region_ops {
	const char *name;
	void (*destructor)(const void *);
	int (*snapshot)(struct devlink_port *, const struct devlink_port_region_ops *, struct netlink_ext_ack *, u8 **);
	void *priv;
};

enum devlink_health_reporter_state {
	DEVLINK_HEALTH_REPORTER_STATE_HEALTHY = 0,
	DEVLINK_HEALTH_REPORTER_STATE_ERROR = 1,
};

struct devlink_health_reporter;

struct devlink_fmsg;

struct devlink_health_reporter_ops {
	char *name;
	int (*recover)(struct devlink_health_reporter *, void *, struct netlink_ext_ack *);
	int (*dump)(struct devlink_health_reporter *, struct devlink_fmsg *, void *, struct netlink_ext_ack *);
	int (*diagnose)(struct devlink_health_reporter *, struct devlink_fmsg *, struct netlink_ext_ack *);
	int (*test)(struct devlink_health_reporter *, struct netlink_ext_ack *);
};

struct devlink_health_reporter {
	struct list_head list;
	void *priv;
	const struct devlink_health_reporter_ops *ops;
	struct devlink *devlink;
	struct devlink_port *devlink_port;
	struct devlink_fmsg *dump_fmsg;
	struct mutex dump_lock;
	u64 graceful_period;
	bool auto_recover;
	bool auto_dump;
	u8 health_state;
	u64 dump_ts;
	u64 dump_real_ts;
	u64 error_count;
	u64 recovery_count;
	u64 last_recovery_ts;
	refcount_t refcount;
};

struct devlink_fmsg {
	struct list_head item_list;
	bool putting_binary;
};

enum devlink_trap_generic_id {
	DEVLINK_TRAP_GENERIC_ID_SMAC_MC = 0,
	DEVLINK_TRAP_GENERIC_ID_VLAN_TAG_MISMATCH = 1,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER = 2,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_STP_FILTER = 3,
	DEVLINK_TRAP_GENERIC_ID_EMPTY_TX_LIST = 4,
	DEVLINK_TRAP_GENERIC_ID_PORT_LOOPBACK_FILTER = 5,
	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_ROUTE = 6,
	DEVLINK_TRAP_GENERIC_ID_TTL_ERROR = 7,
	DEVLINK_TRAP_GENERIC_ID_TAIL_DROP = 8,
	DEVLINK_TRAP_GENERIC_ID_NON_IP_PACKET = 9,
	DEVLINK_TRAP_GENERIC_ID_UC_DIP_MC_DMAC = 10,
	DEVLINK_TRAP_GENERIC_ID_DIP_LB = 11,
	DEVLINK_TRAP_GENERIC_ID_SIP_MC = 12,
	DEVLINK_TRAP_GENERIC_ID_SIP_LB = 13,
	DEVLINK_TRAP_GENERIC_ID_CORRUPTED_IP_HDR = 14,
	DEVLINK_TRAP_GENERIC_ID_IPV4_SIP_BC = 15,
	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_RESERVED_SCOPE = 16,
	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_INTERFACE_LOCAL_SCOPE = 17,
	DEVLINK_TRAP_GENERIC_ID_MTU_ERROR = 18,
	DEVLINK_TRAP_GENERIC_ID_UNRESOLVED_NEIGH = 19,
	DEVLINK_TRAP_GENERIC_ID_RPF = 20,
	DEVLINK_TRAP_GENERIC_ID_REJECT_ROUTE = 21,
	DEVLINK_TRAP_GENERIC_ID_IPV4_LPM_UNICAST_MISS = 22,
	DEVLINK_TRAP_GENERIC_ID_IPV6_LPM_UNICAST_MISS = 23,
	DEVLINK_TRAP_GENERIC_ID_NON_ROUTABLE = 24,
	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR = 25,
	DEVLINK_TRAP_GENERIC_ID_OVERLAY_SMAC_MC = 26,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_FLOW_ACTION_DROP = 27,
	DEVLINK_TRAP_GENERIC_ID_EGRESS_FLOW_ACTION_DROP = 28,
	DEVLINK_TRAP_GENERIC_ID_STP = 29,
	DEVLINK_TRAP_GENERIC_ID_LACP = 30,
	DEVLINK_TRAP_GENERIC_ID_LLDP = 31,
	DEVLINK_TRAP_GENERIC_ID_IGMP_QUERY = 32,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V1_REPORT = 33,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_REPORT = 34,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V3_REPORT = 35,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_LEAVE = 36,
	DEVLINK_TRAP_GENERIC_ID_MLD_QUERY = 37,
	DEVLINK_TRAP_GENERIC_ID_MLD_V1_REPORT = 38,
	DEVLINK_TRAP_GENERIC_ID_MLD_V2_REPORT = 39,
	DEVLINK_TRAP_GENERIC_ID_MLD_V1_DONE = 40,
	DEVLINK_TRAP_GENERIC_ID_IPV4_DHCP = 41,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DHCP = 42,
	DEVLINK_TRAP_GENERIC_ID_ARP_REQUEST = 43,
	DEVLINK_TRAP_GENERIC_ID_ARP_RESPONSE = 44,
	DEVLINK_TRAP_GENERIC_ID_ARP_OVERLAY = 45,
	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_SOLICIT = 46,
	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_ADVERT = 47,
	DEVLINK_TRAP_GENERIC_ID_IPV4_BFD = 48,
	DEVLINK_TRAP_GENERIC_ID_IPV6_BFD = 49,
	DEVLINK_TRAP_GENERIC_ID_IPV4_OSPF = 50,
	DEVLINK_TRAP_GENERIC_ID_IPV6_OSPF = 51,
	DEVLINK_TRAP_GENERIC_ID_IPV4_BGP = 52,
	DEVLINK_TRAP_GENERIC_ID_IPV6_BGP = 53,
	DEVLINK_TRAP_GENERIC_ID_IPV4_VRRP = 54,
	DEVLINK_TRAP_GENERIC_ID_IPV6_VRRP = 55,
	DEVLINK_TRAP_GENERIC_ID_IPV4_PIM = 56,
	DEVLINK_TRAP_GENERIC_ID_IPV6_PIM = 57,
	DEVLINK_TRAP_GENERIC_ID_UC_LB = 58,
	DEVLINK_TRAP_GENERIC_ID_LOCAL_ROUTE = 59,
	DEVLINK_TRAP_GENERIC_ID_EXTERNAL_ROUTE = 60,
	DEVLINK_TRAP_GENERIC_ID_IPV6_UC_DIP_LINK_LOCAL_SCOPE = 61,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_NODES = 62,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_ROUTERS = 63,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_SOLICIT = 64,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ADVERT = 65,
	DEVLINK_TRAP_GENERIC_ID_IPV6_REDIRECT = 66,
	DEVLINK_TRAP_GENERIC_ID_IPV4_ROUTER_ALERT = 67,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ALERT = 68,
	DEVLINK_TRAP_GENERIC_ID_PTP_EVENT = 69,
	DEVLINK_TRAP_GENERIC_ID_PTP_GENERAL = 70,
	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_SAMPLE = 71,
	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_TRAP = 72,
	DEVLINK_TRAP_GENERIC_ID_EARLY_DROP = 73,
	DEVLINK_TRAP_GENERIC_ID_VXLAN_PARSING = 74,
	DEVLINK_TRAP_GENERIC_ID_LLC_SNAP_PARSING = 75,
	DEVLINK_TRAP_GENERIC_ID_VLAN_PARSING = 76,
	DEVLINK_TRAP_GENERIC_ID_PPPOE_PPP_PARSING = 77,
	DEVLINK_TRAP_GENERIC_ID_MPLS_PARSING = 78,
	DEVLINK_TRAP_GENERIC_ID_ARP_PARSING = 79,
	DEVLINK_TRAP_GENERIC_ID_IP_1_PARSING = 80,
	DEVLINK_TRAP_GENERIC_ID_IP_N_PARSING = 81,
	DEVLINK_TRAP_GENERIC_ID_GRE_PARSING = 82,
	DEVLINK_TRAP_GENERIC_ID_UDP_PARSING = 83,
	DEVLINK_TRAP_GENERIC_ID_TCP_PARSING = 84,
	DEVLINK_TRAP_GENERIC_ID_IPSEC_PARSING = 85,
	DEVLINK_TRAP_GENERIC_ID_SCTP_PARSING = 86,
	DEVLINK_TRAP_GENERIC_ID_DCCP_PARSING = 87,
	DEVLINK_TRAP_GENERIC_ID_GTP_PARSING = 88,
	DEVLINK_TRAP_GENERIC_ID_ESP_PARSING = 89,
	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_NEXTHOP = 90,
	DEVLINK_TRAP_GENERIC_ID_DMAC_FILTER = 91,
	__DEVLINK_TRAP_GENERIC_ID_MAX = 92,
	DEVLINK_TRAP_GENERIC_ID_MAX = 91,
};

enum devlink_trap_group_generic_id {
	DEVLINK_TRAP_GROUP_GENERIC_ID_L2_DROPS = 0,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_DROPS = 1,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_EXCEPTIONS = 2,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BUFFER_DROPS = 3,
	DEVLINK_TRAP_GROUP_GENERIC_ID_TUNNEL_DROPS = 4,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_DROPS = 5,
	DEVLINK_TRAP_GROUP_GENERIC_ID_STP = 6,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LACP = 7,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LLDP = 8,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MC_SNOOPING = 9,
	DEVLINK_TRAP_GROUP_GENERIC_ID_DHCP = 10,
	DEVLINK_TRAP_GROUP_GENERIC_ID_NEIGH_DISCOVERY = 11,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BFD = 12,
	DEVLINK_TRAP_GROUP_GENERIC_ID_OSPF = 13,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BGP = 14,
	DEVLINK_TRAP_GROUP_GENERIC_ID_VRRP = 15,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PIM = 16,
	DEVLINK_TRAP_GROUP_GENERIC_ID_UC_LB = 17,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LOCAL_DELIVERY = 18,
	DEVLINK_TRAP_GROUP_GENERIC_ID_EXTERNAL_DELIVERY = 19,
	DEVLINK_TRAP_GROUP_GENERIC_ID_IPV6 = 20,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_EVENT = 21,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_GENERAL = 22,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_SAMPLE = 23,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_TRAP = 24,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PARSER_ERROR_DROPS = 25,
	__DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 26,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 25,
};

struct devlink_info_req {
	struct sk_buff *msg;
};

struct trace_event_raw_devlink_hwmsg {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	bool incoming;
	long unsigned int type;
	u32 __data_loc_buf;
	size_t len;
	char __data[0];
};

struct trace_event_raw_devlink_hwerr {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	int err;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_recover_aborted {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	bool health_state;
	u64 time_since_last_recover;
	char __data[0];
};

struct trace_event_raw_devlink_health_reporter_state_update {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u8 new_state;
	char __data[0];
};

struct trace_event_raw_devlink_trap_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_trap_name;
	u32 __data_loc_trap_group_name;
	u32 __data_loc_input_dev_name;
	char __data[0];
};

struct trace_event_data_offsets_devlink_hwmsg {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 buf;
};

struct trace_event_data_offsets_devlink_hwerr {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_recover_aborted {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_health_reporter_state_update {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_trap_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 trap_name;
	u32 trap_group_name;
	u32 input_dev_name;
};

typedef void (*btf_trace_devlink_hwmsg)(void *, const struct devlink *, bool, long unsigned int, const u8 *, size_t);

typedef void (*btf_trace_devlink_hwerr)(void *, const struct devlink *, int, const char *);

typedef void (*btf_trace_devlink_health_report)(void *, const struct devlink *, const char *, const char *);

typedef void (*btf_trace_devlink_health_recover_aborted)(void *, const struct devlink *, const char *, bool, u64);

typedef void (*btf_trace_devlink_health_reporter_state_update)(void *, const struct devlink *, const char *, bool);

typedef void (*btf_trace_devlink_trap_report)(void *, const struct devlink *, struct sk_buff *, const struct devlink_trap_metadata *);

struct devlink_sb {
	struct list_head list;
	unsigned int index;
	u32 size;
	u16 ingress_pools_count;
	u16 egress_pools_count;
	u16 ingress_tc_count;
	u16 egress_tc_count;
};

struct devlink_region {
	struct devlink *devlink;
	struct devlink_port *port;
	struct list_head list;
	union {
		const struct devlink_region_ops *ops;
		const struct devlink_port_region_ops *port_ops;
	};
	struct list_head snapshot_list;
	u32 max_snapshots;
	u32 cur_snapshots;
	u64 size;
};

struct devlink_snapshot {
	struct list_head list;
	struct devlink_region *region;
	u8 *data;
	u32 id;
};

enum devlink_multicast_groups {
	DEVLINK_MCGRP_CONFIG = 0,
};

struct devlink_reload_combination {
	enum devlink_reload_action action;
	enum devlink_reload_limit limit;
};

struct devlink_fmsg_item {
	struct list_head list;
	int attrtype;
	u8 nla_type;
	u16 len;
	int value[0];
};

struct devlink_stats {
	u64 rx_bytes;
	u64 rx_packets;
	struct u64_stats_sync syncp;
};

struct devlink_trap_policer_item {
	const struct devlink_trap_policer *policer;
	u64 rate;
	u64 burst;
	struct list_head list;
};

struct devlink_trap_group_item {
	const struct devlink_trap_group *group;
	struct devlink_trap_policer_item *policer_item;
	struct list_head list;
	struct devlink_stats *stats;
};

struct devlink_trap_item {
	const struct devlink_trap *trap;
	struct devlink_trap_group_item *group_item;
	struct list_head list;
	enum devlink_trap_action action;
	struct devlink_stats *stats;
	void *priv;
};

struct gro_cell;

struct gro_cells {
	struct gro_cell *cells;
};

struct gro_cell {
	struct sk_buff_head napi_skbs;
	struct napi_struct napi;
};

enum __sk_action {
	__SK_DROP = 0,
	__SK_PASS = 1,
	__SK_REDIRECT = 2,
	__SK_NONE = 3,
};

enum sk_psock_state_bits {
	SK_PSOCK_TX_ENABLED = 0,
};

struct sk_psock_link {
	struct list_head list;
	struct bpf_map *map;
	void *link_raw;
};

struct bpf_stab {
	struct bpf_map map;
	struct sock **sks;
	struct sk_psock_progs progs;
	raw_spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
};

typedef u64 (*btf_bpf_sock_map_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_map)(struct sk_buff *, struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_msg_redirect_map)(struct sk_msg *, struct bpf_map *, u32, u64);

struct sock_map_seq_info {
	struct bpf_map *map;
	struct sock *sk;
	u32 index;
};

struct bpf_iter__sockmap {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		struct sock *sk;
	};
};

struct bpf_shtab_elem {
	struct callback_head rcu;
	u32 hash;
	struct sock *sk;
	struct hlist_node node;
	u8 key[0];
};

struct bpf_shtab_bucket {
	struct hlist_head head;
	raw_spinlock_t lock;
};

struct bpf_shtab {
	struct bpf_map map;
	struct bpf_shtab_bucket *buckets;
	u32 buckets_num;
	u32 elem_size;
	struct sk_psock_progs progs;
	atomic_t count;
	long: 32;
	long: 64;
};

typedef u64 (*btf_bpf_sock_hash_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_hash)(struct sk_buff *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_msg_redirect_hash)(struct sk_msg *, struct bpf_map *, void *, u64);

struct sock_hash_seq_info {
	struct bpf_map *map;
	struct bpf_shtab *htab;
	u32 bucket_id;
};

enum {
	SK_DIAG_BPF_STORAGE_REQ_NONE = 0,
	SK_DIAG_BPF_STORAGE_REQ_MAP_FD = 1,
	__SK_DIAG_BPF_STORAGE_REQ_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_REP_NONE = 0,
	SK_DIAG_BPF_STORAGE = 1,
	__SK_DIAG_BPF_STORAGE_REP_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_NONE = 0,
	SK_DIAG_BPF_STORAGE_PAD = 1,
	SK_DIAG_BPF_STORAGE_MAP_ID = 2,
	SK_DIAG_BPF_STORAGE_MAP_VALUE = 3,
	__SK_DIAG_BPF_STORAGE_MAX = 4,
};

typedef u64 (*btf_bpf_sk_storage_get)(struct bpf_map *, struct sock *, void *, u64);

typedef u64 (*btf_bpf_sk_storage_delete)(struct bpf_map *, struct sock *);

typedef u64 (*btf_bpf_sk_storage_get_tracing)(struct bpf_map *, struct sock *, void *, u64);

typedef u64 (*btf_bpf_sk_storage_delete_tracing)(struct bpf_map *, struct sock *);

struct bpf_sk_storage_diag {
	u32 nr_maps;
	struct bpf_map *maps[0];
};

struct bpf_iter_seq_sk_storage_map_info {
	struct bpf_map *map;
	unsigned int bucket_id;
	unsigned int skip_elems;
};

struct bpf_iter__bpf_sk_storage_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		struct sock *sk;
	};
	union {
		void *value;
	};
};

struct compat_cmsghdr {
	compat_size_t cmsg_len;
	compat_int_t cmsg_level;
	compat_int_t cmsg_type;
};

struct fch_hdr {
	__u8 daddr[6];
	__u8 saddr[6];
};

struct fcllc {
	__u8 dsap;
	__u8 ssap;
	__u8 llc;
	__u8 protid[3];
	__be16 ethertype;
};

struct fddi_8022_1_hdr {
	__u8 dsap;
	__u8 ssap;
	__u8 ctrl;
};

struct fddi_8022_2_hdr {
	__u8 dsap;
	__u8 ssap;
	__u8 ctrl_1;
	__u8 ctrl_2;
};

struct fddi_snap_hdr {
	__u8 dsap;
	__u8 ssap;
	__u8 ctrl;
	__u8 oui[3];
	__be16 ethertype;
};

struct fddihdr {
	__u8 fc;
	__u8 daddr[6];
	__u8 saddr[6];
	union {
		struct fddi_8022_1_hdr llc_8022_1;
		struct fddi_8022_2_hdr llc_8022_2;
		struct fddi_snap_hdr llc_snap;
	} hdr;
} __attribute__((packed));

enum macvlan_mode {
	MACVLAN_MODE_PRIVATE = 1,
	MACVLAN_MODE_VEPA = 2,
	MACVLAN_MODE_BRIDGE = 4,
	MACVLAN_MODE_PASSTHRU = 8,
	MACVLAN_MODE_SOURCE = 16,
};

struct tc_ratespec {
	unsigned char cell_log;
	__u8 linklayer;
	short unsigned int overhead;
	short int cell_align;
	short unsigned int mpu;
	__u32 rate;
};

struct tc_prio_qopt {
	int bands;
	__u8 priomap[16];
};

enum {
	TCA_UNSPEC = 0,
	TCA_KIND = 1,
	TCA_OPTIONS = 2,
	TCA_STATS = 3,
	TCA_XSTATS = 4,
	TCA_RATE = 5,
	TCA_FCNT = 6,
	TCA_STATS2 = 7,
	TCA_STAB = 8,
	TCA_PAD = 9,
	TCA_DUMP_INVISIBLE = 10,
	TCA_CHAIN = 11,
	TCA_HW_OFFLOAD = 12,
	TCA_INGRESS_BLOCK = 13,
	TCA_EGRESS_BLOCK = 14,
	TCA_DUMP_FLAGS = 15,
	__TCA_MAX = 16,
};

struct vlan_pcpu_stats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 rx_multicast;
	u64 tx_packets;
	u64 tx_bytes;
	struct u64_stats_sync syncp;
	u32 rx_errors;
	u32 tx_dropped;
};

struct netpoll___2;

struct skb_array {
	struct ptr_ring ring;
};

struct macvlan_port;

struct macvlan_dev {
	struct net_device *dev;
	struct list_head list;
	struct hlist_node hlist;
	struct macvlan_port *port;
	struct net_device *lowerdev;
	void *accel_priv;
	struct vlan_pcpu_stats *pcpu_stats;
	long unsigned int mc_filter[4];
	netdev_features_t set_features;
	enum macvlan_mode mode;
	u16 flags;
	unsigned int macaddr_count;
	u32 bc_queue_len_req;
	struct netpoll___2 *netpoll;
};

struct psched_ratecfg {
	u64 rate_bytes_ps;
	u32 mult;
	u16 overhead;
	u16 mpu;
	u8 linklayer;
	u8 shift;
};

struct psched_pktrate {
	u64 rate_pkts_ps;
	u32 mult;
	u8 shift;
};

struct mini_Qdisc_pair {
	struct mini_Qdisc miniq1;
	struct mini_Qdisc miniq2;
	struct mini_Qdisc **p_miniq;
};

struct pfifo_fast_priv {
	struct skb_array q[3];
};

struct tc_qopt_offload_stats {
	struct gnet_stats_basic_packed *bstats;
	struct gnet_stats_queue *qstats;
};

enum tc_mq_command {
	TC_MQ_CREATE = 0,
	TC_MQ_DESTROY = 1,
	TC_MQ_STATS = 2,
	TC_MQ_GRAFT = 3,
};

struct tc_mq_opt_offload_graft_params {
	long unsigned int queue;
	u32 child_handle;
};

struct tc_mq_qopt_offload {
	enum tc_mq_command command;
	u32 handle;
	union {
		struct tc_qopt_offload_stats stats;
		struct tc_mq_opt_offload_graft_params graft_params;
	};
};

struct mq_sched {
	struct Qdisc **qdiscs;
};

struct sch_frag_data {
	long unsigned int dst;
	struct qdisc_skb_cb cb;
	__be16 inner_protocol;
	u16 vlan_tci;
	__be16 vlan_proto;
	unsigned int l2_len;
	u8 l2_data[18];
	int (*xmit)(struct sk_buff *);
};

enum tc_link_layer {
	TC_LINKLAYER_UNAWARE = 0,
	TC_LINKLAYER_ETHERNET = 1,
	TC_LINKLAYER_ATM = 2,
};

enum {
	TCA_STAB_UNSPEC = 0,
	TCA_STAB_BASE = 1,
	TCA_STAB_DATA = 2,
	__TCA_STAB_MAX = 3,
};

struct qdisc_rate_table {
	struct tc_ratespec rate;
	u32 data[256];
	struct qdisc_rate_table *next;
	int refcnt;
};

struct Qdisc_class_common {
	u32 classid;
	struct hlist_node hnode;
};

struct Qdisc_class_hash {
	struct hlist_head *hash;
	unsigned int hashsize;
	unsigned int hashmask;
	unsigned int hashelems;
};

struct qdisc_watchdog {
	u64 last_expires;
	struct hrtimer timer;
	struct Qdisc *qdisc;
};

enum tc_root_command {
	TC_ROOT_GRAFT = 0,
};

struct tc_root_qopt_offload {
	enum tc_root_command command;
	u32 handle;
	bool ingress;
};

struct check_loop_arg {
	struct qdisc_walker w;
	struct Qdisc *p;
	int depth;
};

struct tcf_bind_args {
	struct tcf_walker w;
	long unsigned int base;
	long unsigned int cl;
	u32 classid;
};

struct tc_bind_class_args {
	struct qdisc_walker w;
	long unsigned int new_cl;
	u32 portid;
	u32 clid;
};

struct qdisc_dump_args {
	struct qdisc_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
};

enum net_xmit_qdisc_t {
	__NET_XMIT_STOLEN = 65536,
	__NET_XMIT_BYPASS = 131072,
};

enum {
	TCA_ACT_UNSPEC = 0,
	TCA_ACT_KIND = 1,
	TCA_ACT_OPTIONS = 2,
	TCA_ACT_INDEX = 3,
	TCA_ACT_STATS = 4,
	TCA_ACT_PAD = 5,
	TCA_ACT_COOKIE = 6,
	TCA_ACT_FLAGS = 7,
	TCA_ACT_HW_STATS = 8,
	TCA_ACT_USED_HW_STATS = 9,
	__TCA_ACT_MAX = 10,
};

enum tca_id {
	TCA_ID_UNSPEC = 0,
	TCA_ID_POLICE = 1,
	TCA_ID_GACT = 5,
	TCA_ID_IPT = 6,
	TCA_ID_PEDIT = 7,
	TCA_ID_MIRRED = 8,
	TCA_ID_NAT = 9,
	TCA_ID_XT = 10,
	TCA_ID_SKBEDIT = 11,
	TCA_ID_VLAN = 12,
	TCA_ID_BPF = 13,
	TCA_ID_CONNMARK = 14,
	TCA_ID_SKBMOD = 15,
	TCA_ID_CSUM = 16,
	TCA_ID_TUNNEL_KEY = 17,
	TCA_ID_SIMP = 22,
	TCA_ID_IFE = 25,
	TCA_ID_SAMPLE = 26,
	TCA_ID_CTINFO = 27,
	TCA_ID_MPLS = 28,
	TCA_ID_CT = 29,
	TCA_ID_GATE = 30,
	__TCA_ID_MAX = 255,
};

struct tcf_t {
	__u64 install;
	__u64 lastuse;
	__u64 expires;
	__u64 firstuse;
};

struct psample_group {
	struct list_head list;
	struct net *net;
	u32 group_num;
	u32 refcount;
	u32 seq;
	struct callback_head rcu;
};

struct action_gate_entry {
	u8 gate_state;
	u32 interval;
	s32 ipv;
	s32 maxoctets;
};

enum qdisc_class_ops_flags {
	QDISC_CLASS_OPS_DOIT_UNLOCKED = 1,
};

enum tcf_proto_ops_flags {
	TCF_PROTO_OPS_DOIT_UNLOCKED = 1,
};

typedef void tcf_chain_head_change_t(struct tcf_proto *, void *);

struct tcf_idrinfo {
	struct mutex lock;
	struct idr action_idr;
	struct net *net;
};

struct tc_action_ops;

struct tc_cookie;

struct tc_action {
	const struct tc_action_ops *ops;
	__u32 type;
	struct tcf_idrinfo *idrinfo;
	u32 tcfa_index;
	refcount_t tcfa_refcnt;
	atomic_t tcfa_bindcnt;
	int tcfa_action;
	struct tcf_t tcfa_tm;
	struct gnet_stats_basic_packed tcfa_bstats;
	struct gnet_stats_basic_packed tcfa_bstats_hw;
	struct gnet_stats_queue tcfa_qstats;
	struct net_rate_estimator *tcfa_rate_est;
	spinlock_t tcfa_lock;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_basic_cpu *cpu_bstats_hw;
	struct gnet_stats_queue *cpu_qstats;
	struct tc_cookie *act_cookie;
	struct tcf_chain *goto_chain;
	u32 tcfa_flags;
	u8 hw_stats;
	u8 used_hw_stats;
	bool used_hw_stats_valid;
};

typedef void (*tc_action_priv_destructor)(void *);

struct tc_action_ops {
	struct list_head head;
	char kind[16];
	enum tca_id id;
	size_t size;
	struct module *owner;
	int (*act)(struct sk_buff *, const struct tc_action *, struct tcf_result *);
	int (*dump)(struct sk_buff *, struct tc_action *, int, int);
	void (*cleanup)(struct tc_action *);
	int (*lookup)(struct net *, struct tc_action **, u32);
	int (*init)(struct net *, struct nlattr *, struct nlattr *, struct tc_action **, int, int, bool, struct tcf_proto *, u32, struct netlink_ext_ack *);
	int (*walk)(struct net *, struct sk_buff *, struct netlink_callback *, int, const struct tc_action_ops *, struct netlink_ext_ack *);
	void (*stats_update)(struct tc_action *, u64, u64, u64, u64, bool);
	size_t (*get_fill_size)(const struct tc_action *);
	struct net_device * (*get_dev)(const struct tc_action *, tc_action_priv_destructor *);
	struct psample_group * (*get_psample_group)(const struct tc_action *, tc_action_priv_destructor *);
};

struct tc_cookie {
	u8 *data;
	u32 len;
	struct callback_head rcu;
};

struct tcf_block_ext_info {
	enum flow_block_binder_type binder_type;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
	u32 block_index;
};

struct tcf_qevent {
	struct tcf_block *block;
	struct tcf_block_ext_info info;
	struct tcf_proto *filter_chain;
};

struct tcf_exts {
	__u32 type;
	int nr_actions;
	struct tc_action **actions;
	struct net *net;
	int action;
	int police;
};

enum pedit_header_type {
	TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK = 0,
	TCA_PEDIT_KEY_EX_HDR_TYPE_ETH = 1,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP4 = 2,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP6 = 3,
	TCA_PEDIT_KEY_EX_HDR_TYPE_TCP = 4,
	TCA_PEDIT_KEY_EX_HDR_TYPE_UDP = 5,
	__PEDIT_HDR_TYPE_MAX = 6,
};

enum pedit_cmd {
	TCA_PEDIT_KEY_EX_CMD_SET = 0,
	TCA_PEDIT_KEY_EX_CMD_ADD = 1,
	__PEDIT_CMD_MAX = 2,
};

struct tc_pedit_key {
	__u32 mask;
	__u32 val;
	__u32 off;
	__u32 at;
	__u32 offmask;
	__u32 shift;
};

struct tcf_pedit_key_ex {
	enum pedit_header_type htype;
	enum pedit_cmd cmd;
};

struct tcf_pedit {
	struct tc_action common;
	unsigned char tcfp_nkeys;
	unsigned char tcfp_flags;
	struct tc_pedit_key *tcfp_keys;
	struct tcf_pedit_key_ex *tcfp_keys_ex;
};

struct tcf_mirred {
	struct tc_action common;
	int tcfm_eaction;
	bool tcfm_mac_header_xmit;
	struct net_device *tcfm_dev;
	struct list_head tcfm_list;
};

struct tcf_vlan_params {
	int tcfv_action;
	unsigned char tcfv_push_dst[6];
	unsigned char tcfv_push_src[6];
	u16 tcfv_push_vid;
	__be16 tcfv_push_proto;
	u8 tcfv_push_prio;
	bool tcfv_push_prio_exists;
	struct callback_head rcu;
};

struct tcf_vlan {
	struct tc_action common;
	struct tcf_vlan_params *vlan_p;
};

struct tcf_tunnel_key_params {
	struct callback_head rcu;
	int tcft_action;
	struct metadata_dst *tcft_enc_metadata;
};

struct tcf_tunnel_key {
	struct tc_action common;
	struct tcf_tunnel_key_params *params;
};

struct tcf_csum_params {
	u32 update_flags;
	struct callback_head rcu;
};

struct tcf_csum {
	struct tc_action common;
	struct tcf_csum_params *params;
};

struct tcf_gact {
	struct tc_action common;
	u16 tcfg_ptype;
	u16 tcfg_pval;
	int tcfg_paction;
	atomic_t packets;
};

struct tcf_police_params {
	int tcfp_result;
	u32 tcfp_ewma_rate;
	s64 tcfp_burst;
	u32 tcfp_mtu;
	s64 tcfp_mtu_ptoks;
	s64 tcfp_pkt_burst;
	struct psched_ratecfg rate;
	bool rate_present;
	struct psched_ratecfg peak;
	bool peak_present;
	struct psched_pktrate ppsrate;
	bool pps_present;
	struct callback_head rcu;
};

struct tcf_police {
	struct tc_action common;
	struct tcf_police_params *params;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t tcfp_lock;
	s64 tcfp_toks;
	s64 tcfp_ptoks;
	s64 tcfp_pkttoks;
	s64 tcfp_t_c;
	long: 64;
	long: 64;
	long: 64;
};

struct tcf_sample {
	struct tc_action common;
	u32 rate;
	bool truncate;
	u32 trunc_size;
	struct psample_group *psample_group;
	u32 psample_group_num;
	struct list_head tcfm_list;
};

struct tcf_skbedit_params {
	u32 flags;
	u32 priority;
	u32 mark;
	u32 mask;
	u16 queue_mapping;
	u16 ptype;
	struct callback_head rcu;
};

struct tcf_skbedit {
	struct tc_action common;
	struct tcf_skbedit_params *params;
};

struct nf_conntrack_l4proto___2;

struct PptpControlHeader {
	__be16 messageType;
	__u16 reserved;
};

struct PptpStartSessionRequest {
	__be16 protocolVersion;
	__u16 reserved1;
	__be32 framingCapability;
	__be32 bearerCapability;
	__be16 maxChannels;
	__be16 firmwareRevision;
	__u8 hostName[64];
	__u8 vendorString[64];
};

struct PptpStartSessionReply {
	__be16 protocolVersion;
	__u8 resultCode;
	__u8 generalErrorCode;
	__be32 framingCapability;
	__be32 bearerCapability;
	__be16 maxChannels;
	__be16 firmwareRevision;
	__u8 hostName[64];
	__u8 vendorString[64];
};

struct PptpStopSessionRequest {
	__u8 reason;
	__u8 reserved1;
	__u16 reserved2;
};

struct PptpStopSessionReply {
	__u8 resultCode;
	__u8 generalErrorCode;
	__u16 reserved1;
};

struct PptpOutCallRequest {
	__be16 callID;
	__be16 callSerialNumber;
	__be32 minBPS;
	__be32 maxBPS;
	__be32 bearerType;
	__be32 framingType;
	__be16 packetWindow;
	__be16 packetProcDelay;
	__be16 phoneNumberLength;
	__u16 reserved1;
	__u8 phoneNumber[64];
	__u8 subAddress[64];
};

struct PptpOutCallReply {
	__be16 callID;
	__be16 peersCallID;
	__u8 resultCode;
	__u8 generalErrorCode;
	__be16 causeCode;
	__be32 connectSpeed;
	__be16 packetWindow;
	__be16 packetProcDelay;
	__be32 physChannelID;
};

struct PptpInCallRequest {
	__be16 callID;
	__be16 callSerialNumber;
	__be32 callBearerType;
	__be32 physChannelID;
	__be16 dialedNumberLength;
	__be16 dialingNumberLength;
	__u8 dialedNumber[64];
	__u8 dialingNumber[64];
	__u8 subAddress[64];
};

struct PptpInCallReply {
	__be16 callID;
	__be16 peersCallID;
	__u8 resultCode;
	__u8 generalErrorCode;
	__be16 packetWindow;
	__be16 packetProcDelay;
	__u16 reserved;
};

struct PptpInCallConnected {
	__be16 peersCallID;
	__u16 reserved;
	__be32 connectSpeed;
	__be16 packetWindow;
	__be16 packetProcDelay;
	__be32 callFramingType;
};

struct PptpClearCallRequest {
	__be16 callID;
	__u16 reserved;
};

struct PptpCallDisconnectNotify {
	__be16 callID;
	__u8 resultCode;
	__u8 generalErrorCode;
	__be16 causeCode;
	__u16 reserved;
	__u8 callStatistics[128];
};

struct PptpWanErrorNotify {
	__be16 peersCallID;
	__u16 reserved;
	__be32 crcErrors;
	__be32 framingErrors;
	__be32 hardwareOverRuns;
	__be32 bufferOverRuns;
	__be32 timeoutErrors;
	__be32 alignmentErrors;
};

struct PptpSetLinkInfo {
	__be16 peersCallID;
	__u16 reserved;
	__be32 sendAccm;
	__be32 recvAccm;
};

union pptp_ctrl_union {
	struct PptpStartSessionRequest sreq;
	struct PptpStartSessionReply srep;
	struct PptpStopSessionRequest streq;
	struct PptpStopSessionReply strep;
	struct PptpOutCallRequest ocreq;
	struct PptpOutCallReply ocack;
	struct PptpInCallRequest icreq;
	struct PptpInCallReply icack;
	struct PptpInCallConnected iccon;
	struct PptpClearCallRequest clrreq;
	struct PptpCallDisconnectNotify disc;
	struct PptpWanErrorNotify wanerr;
	struct PptpSetLinkInfo setlink;
};

struct nf_nat_range2 {
	unsigned int flags;
	union nf_inet_addr min_addr;
	union nf_inet_addr max_addr;
	union nf_conntrack_man_proto min_proto;
	union nf_conntrack_man_proto max_proto;
	union nf_conntrack_man_proto base_proto;
};

struct tcf_ct_flow_table;

struct tcf_ct_params {
	struct nf_conn *tmpl;
	u16 zone;
	u32 mark;
	u32 mark_mask;
	u32 labels[4];
	u32 labels_mask[4];
	struct nf_nat_range2 range;
	bool ipv4_range;
	u16 ct_action;
	struct callback_head rcu;
	struct tcf_ct_flow_table *ct_ft;
	struct nf_flowtable *nf_ft;
};

struct tcf_ct {
	struct tc_action common;
	struct tcf_ct_params *params;
};

struct tcf_mpls_params {
	int tcfm_action;
	u32 tcfm_label;
	u8 tcfm_tc;
	u8 tcfm_ttl;
	u8 tcfm_bos;
	__be16 tcfm_proto;
	struct callback_head rcu;
};

struct tcf_mpls {
	struct tc_action common;
	struct tcf_mpls_params *mpls_p;
};

struct tcfg_gate_entry {
	int index;
	u8 gate_state;
	u32 interval;
	s32 ipv;
	s32 maxoctets;
	struct list_head list;
};

struct tcf_gate_params {
	s32 tcfg_priority;
	u64 tcfg_basetime;
	u64 tcfg_cycletime;
	u64 tcfg_cycletime_ext;
	u32 tcfg_flags;
	s32 tcfg_clockid;
	size_t num_entries;
	struct list_head entries;
};

struct tcf_gate {
	struct tc_action common;
	struct tcf_gate_params param;
	u8 current_gate_status;
	ktime_t current_close_time;
	u32 current_entry_octets;
	s32 current_max_octets;
	struct tcfg_gate_entry *next_entry;
	struct hrtimer hitimer;
	enum tk_offsets tk_offset;
};

struct tcf_filter_chain_list_item {
	struct list_head list;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
};

struct tcf_net {
	spinlock_t idr_lock;
	struct idr idr;
};

struct tcf_block_owner_item {
	struct list_head list;
	struct Qdisc *q;
	enum flow_block_binder_type binder_type;
};

struct tcf_chain_info {
	struct tcf_proto **pprev;
	struct tcf_proto *next;
};

struct tcf_dump_args {
	struct tcf_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct tcf_block *block;
	struct Qdisc *q;
	u32 parent;
	bool terse_dump;
};

struct tcamsg {
	unsigned char tca_family;
	unsigned char tca__pad1;
	short unsigned int tca__pad2;
};

enum {
	TCA_ROOT_UNSPEC = 0,
	TCA_ROOT_TAB = 1,
	TCA_ROOT_FLAGS = 2,
	TCA_ROOT_COUNT = 3,
	TCA_ROOT_TIME_DELTA = 4,
	__TCA_ROOT_MAX = 5,
};

struct tc_action_net {
	struct tcf_idrinfo *idrinfo;
	const struct tc_action_ops *ops;
};

struct tc_fifo_qopt {
	__u32 limit;
};

enum tc_fifo_command {
	TC_FIFO_REPLACE = 0,
	TC_FIFO_DESTROY = 1,
	TC_FIFO_STATS = 2,
};

struct tc_fifo_qopt_offload {
	enum tc_fifo_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_qopt_offload_stats stats;
	};
};

struct tcf_ematch_tree_hdr {
	__u16 nmatches;
	__u16 progid;
};

enum {
	TCA_EMATCH_TREE_UNSPEC = 0,
	TCA_EMATCH_TREE_HDR = 1,
	TCA_EMATCH_TREE_LIST = 2,
	__TCA_EMATCH_TREE_MAX = 3,
};

struct tcf_ematch_hdr {
	__u16 matchid;
	__u16 kind;
	__u16 flags;
	__u16 pad;
};

struct tcf_pkt_info {
	unsigned char *ptr;
	int nexthdr;
};

struct tcf_ematch_ops;

struct tcf_ematch {
	struct tcf_ematch_ops *ops;
	long unsigned int data;
	unsigned int datalen;
	u16 matchid;
	u16 flags;
	struct net *net;
};

struct tcf_ematch_ops {
	int kind;
	int datalen;
	int (*change)(struct net *, void *, int, struct tcf_ematch *);
	int (*match)(struct sk_buff *, struct tcf_ematch *, struct tcf_pkt_info *);
	void (*destroy)(struct tcf_ematch *);
	int (*dump)(struct sk_buff *, struct tcf_ematch *);
	struct module *owner;
	struct list_head link;
};

struct tcf_ematch_tree {
	struct tcf_ematch_tree_hdr hdr;
	struct tcf_ematch *matches;
};

struct sockaddr_nl {
	__kernel_sa_family_t nl_family;
	short unsigned int nl_pad;
	__u32 nl_pid;
	__u32 nl_groups;
};

struct nlmsgerr {
	int error;
	struct nlmsghdr msg;
};

enum nlmsgerr_attrs {
	NLMSGERR_ATTR_UNUSED = 0,
	NLMSGERR_ATTR_MSG = 1,
	NLMSGERR_ATTR_OFFS = 2,
	NLMSGERR_ATTR_COOKIE = 3,
	NLMSGERR_ATTR_POLICY = 4,
	__NLMSGERR_ATTR_MAX = 5,
	NLMSGERR_ATTR_MAX = 4,
};

struct nl_pktinfo {
	__u32 group;
};

enum {
	NETLINK_UNCONNECTED = 0,
	NETLINK_CONNECTED = 1,
};

enum netlink_skb_flags {
	NETLINK_SKB_DST = 8,
};

struct netlink_notify {
	struct net *net;
	u32 portid;
	int protocol;
};

struct netlink_tap {
	struct net_device *dev;
	struct module *module;
	struct list_head list;
};

struct trace_event_raw_netlink_extack {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_netlink_extack {
	u32 msg;
};

typedef void (*btf_trace_netlink_extack)(void *, const char *);

struct netlink_sock {
	struct sock sk;
	u32 portid;
	u32 dst_portid;
	u32 dst_group;
	u32 flags;
	u32 subscriptions;
	u32 ngroups;
	long unsigned int *groups;
	long unsigned int state;
	size_t max_recvmsg_len;
	wait_queue_head_t wait;
	bool bound;
	bool cb_running;
	int dump_done_errno;
	struct netlink_callback cb;
	struct mutex *cb_mutex;
	struct mutex cb_def_mutex;
	void (*netlink_rcv)(struct sk_buff *);
	int (*netlink_bind)(struct net *, int);
	void (*netlink_unbind)(struct net *, int);
	struct module *module;
	struct rhash_head node;
	struct callback_head rcu;
	struct work_struct work;
};

struct listeners;

struct netlink_table {
	struct rhashtable hash;
	struct hlist_head mc_list;
	struct listeners *listeners;
	unsigned int flags;
	unsigned int groups;
	struct mutex *cb_mutex;
	struct module *module;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
	int registered;
};

struct listeners {
	struct callback_head rcu;
	long unsigned int masks[0];
};

struct netlink_tap_net {
	struct list_head netlink_tap_all;
	struct mutex netlink_tap_lock;
};

struct netlink_compare_arg {
	possible_net_t pnet;
	u32 portid;
};

struct netlink_broadcast_data {
	struct sock *exclude_sk;
	struct net *net;
	u32 portid;
	u32 group;
	int failure;
	int delivery_failure;
	int congested;
	int delivered;
	gfp_t allocation;
	struct sk_buff *skb;
	struct sk_buff *skb2;
	int (*tx_filter)(struct sock *, struct sk_buff *, void *);
	void *tx_data;
};

struct netlink_set_err_data {
	struct sock *exclude_sk;
	u32 portid;
	u32 group;
	int code;
};

struct nl_seq_iter {
	struct seq_net_private p;
	struct rhashtable_iter hti;
	int link;
};

struct bpf_iter__netlink {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct netlink_sock *sk;
	};
};

enum {
	CTRL_CMD_UNSPEC = 0,
	CTRL_CMD_NEWFAMILY = 1,
	CTRL_CMD_DELFAMILY = 2,
	CTRL_CMD_GETFAMILY = 3,
	CTRL_CMD_NEWOPS = 4,
	CTRL_CMD_DELOPS = 5,
	CTRL_CMD_GETOPS = 6,
	CTRL_CMD_NEWMCAST_GRP = 7,
	CTRL_CMD_DELMCAST_GRP = 8,
	CTRL_CMD_GETMCAST_GRP = 9,
	CTRL_CMD_GETPOLICY = 10,
	__CTRL_CMD_MAX = 11,
};

enum {
	CTRL_ATTR_UNSPEC = 0,
	CTRL_ATTR_FAMILY_ID = 1,
	CTRL_ATTR_FAMILY_NAME = 2,
	CTRL_ATTR_VERSION = 3,
	CTRL_ATTR_HDRSIZE = 4,
	CTRL_ATTR_MAXATTR = 5,
	CTRL_ATTR_OPS = 6,
	CTRL_ATTR_MCAST_GROUPS = 7,
	CTRL_ATTR_POLICY = 8,
	CTRL_ATTR_OP_POLICY = 9,
	CTRL_ATTR_OP = 10,
	__CTRL_ATTR_MAX = 11,
};

enum {
	CTRL_ATTR_OP_UNSPEC = 0,
	CTRL_ATTR_OP_ID = 1,
	CTRL_ATTR_OP_FLAGS = 2,
	__CTRL_ATTR_OP_MAX = 3,
};

enum {
	CTRL_ATTR_MCAST_GRP_UNSPEC = 0,
	CTRL_ATTR_MCAST_GRP_NAME = 1,
	CTRL_ATTR_MCAST_GRP_ID = 2,
	__CTRL_ATTR_MCAST_GRP_MAX = 3,
};

enum {
	CTRL_ATTR_POLICY_UNSPEC = 0,
	CTRL_ATTR_POLICY_DO = 1,
	CTRL_ATTR_POLICY_DUMP = 2,
	__CTRL_ATTR_POLICY_DUMP_MAX = 3,
	CTRL_ATTR_POLICY_DUMP_MAX = 2,
};

struct genl_start_context {
	const struct genl_family *family;
	struct nlmsghdr *nlh;
	struct netlink_ext_ack *extack;
	const struct genl_ops *ops;
	int hdrlen;
};

struct netlink_policy_dump_state;

struct ctrl_dump_policy_ctx {
	struct netlink_policy_dump_state *state;
	const struct genl_family *rt;
	unsigned int opidx;
	u32 op;
	u16 fam_id;
	u8 policies: 1;
	u8 single_op: 1;
};

enum netlink_attribute_type {
	NL_ATTR_TYPE_INVALID = 0,
	NL_ATTR_TYPE_FLAG = 1,
	NL_ATTR_TYPE_U8 = 2,
	NL_ATTR_TYPE_U16 = 3,
	NL_ATTR_TYPE_U32 = 4,
	NL_ATTR_TYPE_U64 = 5,
	NL_ATTR_TYPE_S8 = 6,
	NL_ATTR_TYPE_S16 = 7,
	NL_ATTR_TYPE_S32 = 8,
	NL_ATTR_TYPE_S64 = 9,
	NL_ATTR_TYPE_BINARY = 10,
	NL_ATTR_TYPE_STRING = 11,
	NL_ATTR_TYPE_NUL_STRING = 12,
	NL_ATTR_TYPE_NESTED = 13,
	NL_ATTR_TYPE_NESTED_ARRAY = 14,
	NL_ATTR_TYPE_BITFIELD32 = 15,
};

enum netlink_policy_type_attr {
	NL_POLICY_TYPE_ATTR_UNSPEC = 0,
	NL_POLICY_TYPE_ATTR_TYPE = 1,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_S = 2,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_S = 3,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_U = 4,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_U = 5,
	NL_POLICY_TYPE_ATTR_MIN_LENGTH = 6,
	NL_POLICY_TYPE_ATTR_MAX_LENGTH = 7,
	NL_POLICY_TYPE_ATTR_POLICY_IDX = 8,
	NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE = 9,
	NL_POLICY_TYPE_ATTR_BITFIELD32_MASK = 10,
	NL_POLICY_TYPE_ATTR_PAD = 11,
	NL_POLICY_TYPE_ATTR_MASK = 12,
	__NL_POLICY_TYPE_ATTR_MAX = 13,
	NL_POLICY_TYPE_ATTR_MAX = 12,
};

struct netlink_policy_dump_state___2 {
	unsigned int policy_idx;
	unsigned int attr_idx;
	unsigned int n_alloc;
	struct {
		const struct nla_policy *policy;
		unsigned int maxtype;
	} policies[0];
};

struct trace_event_raw_bpf_test_finish {
	struct trace_entry ent;
	int err;
	char __data[0];
};

struct trace_event_data_offsets_bpf_test_finish {};

typedef void (*btf_trace_bpf_test_finish)(void *, int *);

struct bpf_test_timer {
	enum {
		NO_PREEMPT = 0,
		NO_MIGRATE = 1,
	} mode;
	u32 i;
	u64 time_start;
	u64 time_spent;
};

struct bpf_fentry_test_t {
	struct bpf_fentry_test_t *a;
};

struct bpf_raw_tp_test_run_info {
	struct bpf_prog *prog;
	void *ctx;
	u32 retval;
};

struct ethtool_value {
	__u32 cmd;
	__u32 data;
};

enum tunable_type_id {
	ETHTOOL_TUNABLE_UNSPEC = 0,
	ETHTOOL_TUNABLE_U8 = 1,
	ETHTOOL_TUNABLE_U16 = 2,
	ETHTOOL_TUNABLE_U32 = 3,
	ETHTOOL_TUNABLE_U64 = 4,
	ETHTOOL_TUNABLE_STRING = 5,
	ETHTOOL_TUNABLE_S8 = 6,
	ETHTOOL_TUNABLE_S16 = 7,
	ETHTOOL_TUNABLE_S32 = 8,
	ETHTOOL_TUNABLE_S64 = 9,
};

enum phy_tunable_id {
	ETHTOOL_PHY_ID_UNSPEC = 0,
	ETHTOOL_PHY_DOWNSHIFT = 1,
	ETHTOOL_PHY_FAST_LINK_DOWN = 2,
	ETHTOOL_PHY_EDPD = 3,
	__ETHTOOL_PHY_TUNABLE_COUNT = 4,
};

struct ethtool_gstrings {
	__u32 cmd;
	__u32 string_set;
	__u32 len;
	__u8 data[0];
};

struct ethtool_sset_info {
	__u32 cmd;
	__u32 reserved;
	__u64 sset_mask;
	__u32 data[0];
};

struct ethtool_perm_addr {
	__u32 cmd;
	__u32 size;
	__u8 data[0];
};

enum ethtool_flags {
	ETH_FLAG_TXVLAN = 128,
	ETH_FLAG_RXVLAN = 256,
	ETH_FLAG_LRO = 32768,
	ETH_FLAG_NTUPLE = 134217728,
	ETH_FLAG_RXHASH = 268435456,
};

struct ethtool_rxfh {
	__u32 cmd;
	__u32 rss_context;
	__u32 indir_size;
	__u32 key_size;
	__u8 hfunc;
	__u8 rsvd8[3];
	__u32 rsvd32;
	__u32 rss_config[0];
};

struct ethtool_get_features_block {
	__u32 available;
	__u32 requested;
	__u32 active;
	__u32 never_changed;
};

struct ethtool_gfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_get_features_block features[0];
};

struct ethtool_set_features_block {
	__u32 valid;
	__u32 requested;
};

struct ethtool_sfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_set_features_block features[0];
};

enum ethtool_sfeatures_retval_bits {
	ETHTOOL_F_UNSUPPORTED__BIT = 0,
	ETHTOOL_F_WISH__BIT = 1,
	ETHTOOL_F_COMPAT__BIT = 2,
};

struct ethtool_per_queue_op {
	__u32 cmd;
	__u32 sub_command;
	__u32 queue_mask[128];
	char data[0];
};

enum ethtool_fec_config_bits {
	ETHTOOL_FEC_NONE_BIT = 0,
	ETHTOOL_FEC_AUTO_BIT = 1,
	ETHTOOL_FEC_OFF_BIT = 2,
	ETHTOOL_FEC_RS_BIT = 3,
	ETHTOOL_FEC_BASER_BIT = 4,
	ETHTOOL_FEC_LLRS_BIT = 5,
};

enum {
	ETH_RSS_HASH_TOP_BIT = 0,
	ETH_RSS_HASH_XOR_BIT = 1,
	ETH_RSS_HASH_CRC32_BIT = 2,
	ETH_RSS_HASH_FUNCS_COUNT = 3,
};

struct ethtool_rx_flow_rule {
	struct flow_rule *rule;
	long unsigned int priv[0];
};

struct ethtool_rx_flow_spec_input {
	const struct ethtool_rx_flow_spec *fs;
	u32 rss_ctx;
};

struct link_mode_info {
	int speed;
	u8 lanes;
	u8 duplex;
};

struct ethtool_link_usettings {
	struct ethtool_link_settings base;
	struct {
		__u32 supported[3];
		__u32 advertising[3];
		__u32 lp_advertising[3];
	} link_modes;
};

struct ethtool_rx_flow_key {
	struct flow_dissector_key_basic basic;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_eth_addrs eth_addrs;
	long: 48;
};

struct ethtool_rx_flow_match {
	struct flow_dissector dissector;
	int: 32;
	struct ethtool_rx_flow_key key;
	struct ethtool_rx_flow_key mask;
};

enum {
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN = 0,
	ETHTOOL_UDP_TUNNEL_TYPE_GENEVE = 1,
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE = 2,
	__ETHTOOL_UDP_TUNNEL_TYPE_CNT = 3,
};

enum {
	ETHTOOL_MSG_USER_NONE = 0,
	ETHTOOL_MSG_STRSET_GET = 1,
	ETHTOOL_MSG_LINKINFO_GET = 2,
	ETHTOOL_MSG_LINKINFO_SET = 3,
	ETHTOOL_MSG_LINKMODES_GET = 4,
	ETHTOOL_MSG_LINKMODES_SET = 5,
	ETHTOOL_MSG_LINKSTATE_GET = 6,
	ETHTOOL_MSG_DEBUG_GET = 7,
	ETHTOOL_MSG_DEBUG_SET = 8,
	ETHTOOL_MSG_WOL_GET = 9,
	ETHTOOL_MSG_WOL_SET = 10,
	ETHTOOL_MSG_FEATURES_GET = 11,
	ETHTOOL_MSG_FEATURES_SET = 12,
	ETHTOOL_MSG_PRIVFLAGS_GET = 13,
	ETHTOOL_MSG_PRIVFLAGS_SET = 14,
	ETHTOOL_MSG_RINGS_GET = 15,
	ETHTOOL_MSG_RINGS_SET = 16,
	ETHTOOL_MSG_CHANNELS_GET = 17,
	ETHTOOL_MSG_CHANNELS_SET = 18,
	ETHTOOL_MSG_COALESCE_GET = 19,
	ETHTOOL_MSG_COALESCE_SET = 20,
	ETHTOOL_MSG_PAUSE_GET = 21,
	ETHTOOL_MSG_PAUSE_SET = 22,
	ETHTOOL_MSG_EEE_GET = 23,
	ETHTOOL_MSG_EEE_SET = 24,
	ETHTOOL_MSG_TSINFO_GET = 25,
	ETHTOOL_MSG_CABLE_TEST_ACT = 26,
	ETHTOOL_MSG_CABLE_TEST_TDR_ACT = 27,
	ETHTOOL_MSG_TUNNEL_INFO_GET = 28,
	ETHTOOL_MSG_FEC_GET = 29,
	ETHTOOL_MSG_FEC_SET = 30,
	ETHTOOL_MSG_MODULE_EEPROM_GET = 31,
	ETHTOOL_MSG_STATS_GET = 32,
	__ETHTOOL_MSG_USER_CNT = 33,
	ETHTOOL_MSG_USER_MAX = 32,
};

enum {
	ETHTOOL_A_HEADER_UNSPEC = 0,
	ETHTOOL_A_HEADER_DEV_INDEX = 1,
	ETHTOOL_A_HEADER_DEV_NAME = 2,
	ETHTOOL_A_HEADER_FLAGS = 3,
	__ETHTOOL_A_HEADER_CNT = 4,
	ETHTOOL_A_HEADER_MAX = 3,
};

enum {
	ETHTOOL_A_STRSET_UNSPEC = 0,
	ETHTOOL_A_STRSET_HEADER = 1,
	ETHTOOL_A_STRSET_STRINGSETS = 2,
	ETHTOOL_A_STRSET_COUNTS_ONLY = 3,
	__ETHTOOL_A_STRSET_CNT = 4,
	ETHTOOL_A_STRSET_MAX = 3,
};

enum {
	ETHTOOL_A_LINKINFO_UNSPEC = 0,
	ETHTOOL_A_LINKINFO_HEADER = 1,
	ETHTOOL_A_LINKINFO_PORT = 2,
	ETHTOOL_A_LINKINFO_PHYADDR = 3,
	ETHTOOL_A_LINKINFO_TP_MDIX = 4,
	ETHTOOL_A_LINKINFO_TP_MDIX_CTRL = 5,
	ETHTOOL_A_LINKINFO_TRANSCEIVER = 6,
	__ETHTOOL_A_LINKINFO_CNT = 7,
	ETHTOOL_A_LINKINFO_MAX = 6,
};

enum {
	ETHTOOL_A_LINKMODES_UNSPEC = 0,
	ETHTOOL_A_LINKMODES_HEADER = 1,
	ETHTOOL_A_LINKMODES_AUTONEG = 2,
	ETHTOOL_A_LINKMODES_OURS = 3,
	ETHTOOL_A_LINKMODES_PEER = 4,
	ETHTOOL_A_LINKMODES_SPEED = 5,
	ETHTOOL_A_LINKMODES_DUPLEX = 6,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG = 7,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE = 8,
	ETHTOOL_A_LINKMODES_LANES = 9,
	__ETHTOOL_A_LINKMODES_CNT = 10,
	ETHTOOL_A_LINKMODES_MAX = 9,
};

enum {
	ETHTOOL_A_LINKSTATE_UNSPEC = 0,
	ETHTOOL_A_LINKSTATE_HEADER = 1,
	ETHTOOL_A_LINKSTATE_LINK = 2,
	ETHTOOL_A_LINKSTATE_SQI = 3,
	ETHTOOL_A_LINKSTATE_SQI_MAX = 4,
	ETHTOOL_A_LINKSTATE_EXT_STATE = 5,
	ETHTOOL_A_LINKSTATE_EXT_SUBSTATE = 6,
	__ETHTOOL_A_LINKSTATE_CNT = 7,
	ETHTOOL_A_LINKSTATE_MAX = 6,
};

enum {
	ETHTOOL_A_DEBUG_UNSPEC = 0,
	ETHTOOL_A_DEBUG_HEADER = 1,
	ETHTOOL_A_DEBUG_MSGMASK = 2,
	__ETHTOOL_A_DEBUG_CNT = 3,
	ETHTOOL_A_DEBUG_MAX = 2,
};

enum {
	ETHTOOL_A_WOL_UNSPEC = 0,
	ETHTOOL_A_WOL_HEADER = 1,
	ETHTOOL_A_WOL_MODES = 2,
	ETHTOOL_A_WOL_SOPASS = 3,
	__ETHTOOL_A_WOL_CNT = 4,
	ETHTOOL_A_WOL_MAX = 3,
};

enum {
	ETHTOOL_A_FEATURES_UNSPEC = 0,
	ETHTOOL_A_FEATURES_HEADER = 1,
	ETHTOOL_A_FEATURES_HW = 2,
	ETHTOOL_A_FEATURES_WANTED = 3,
	ETHTOOL_A_FEATURES_ACTIVE = 4,
	ETHTOOL_A_FEATURES_NOCHANGE = 5,
	__ETHTOOL_A_FEATURES_CNT = 6,
	ETHTOOL_A_FEATURES_MAX = 5,
};

enum {
	ETHTOOL_A_PRIVFLAGS_UNSPEC = 0,
	ETHTOOL_A_PRIVFLAGS_HEADER = 1,
	ETHTOOL_A_PRIVFLAGS_FLAGS = 2,
	__ETHTOOL_A_PRIVFLAGS_CNT = 3,
	ETHTOOL_A_PRIVFLAGS_MAX = 2,
};

enum {
	ETHTOOL_A_RINGS_UNSPEC = 0,
	ETHTOOL_A_RINGS_HEADER = 1,
	ETHTOOL_A_RINGS_RX_MAX = 2,
	ETHTOOL_A_RINGS_RX_MINI_MAX = 3,
	ETHTOOL_A_RINGS_RX_JUMBO_MAX = 4,
	ETHTOOL_A_RINGS_TX_MAX = 5,
	ETHTOOL_A_RINGS_RX = 6,
	ETHTOOL_A_RINGS_RX_MINI = 7,
	ETHTOOL_A_RINGS_RX_JUMBO = 8,
	ETHTOOL_A_RINGS_TX = 9,
	__ETHTOOL_A_RINGS_CNT = 10,
	ETHTOOL_A_RINGS_MAX = 9,
};

enum {
	ETHTOOL_A_CHANNELS_UNSPEC = 0,
	ETHTOOL_A_CHANNELS_HEADER = 1,
	ETHTOOL_A_CHANNELS_RX_MAX = 2,
	ETHTOOL_A_CHANNELS_TX_MAX = 3,
	ETHTOOL_A_CHANNELS_OTHER_MAX = 4,
	ETHTOOL_A_CHANNELS_COMBINED_MAX = 5,
	ETHTOOL_A_CHANNELS_RX_COUNT = 6,
	ETHTOOL_A_CHANNELS_TX_COUNT = 7,
	ETHTOOL_A_CHANNELS_OTHER_COUNT = 8,
	ETHTOOL_A_CHANNELS_COMBINED_COUNT = 9,
	__ETHTOOL_A_CHANNELS_CNT = 10,
	ETHTOOL_A_CHANNELS_MAX = 9,
};

enum {
	ETHTOOL_A_COALESCE_UNSPEC = 0,
	ETHTOOL_A_COALESCE_HEADER = 1,
	ETHTOOL_A_COALESCE_RX_USECS = 2,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES = 3,
	ETHTOOL_A_COALESCE_RX_USECS_IRQ = 4,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ = 5,
	ETHTOOL_A_COALESCE_TX_USECS = 6,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES = 7,
	ETHTOOL_A_COALESCE_TX_USECS_IRQ = 8,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ = 9,
	ETHTOOL_A_COALESCE_STATS_BLOCK_USECS = 10,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX = 11,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX = 12,
	ETHTOOL_A_COALESCE_PKT_RATE_LOW = 13,
	ETHTOOL_A_COALESCE_RX_USECS_LOW = 14,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW = 15,
	ETHTOOL_A_COALESCE_TX_USECS_LOW = 16,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW = 17,
	ETHTOOL_A_COALESCE_PKT_RATE_HIGH = 18,
	ETHTOOL_A_COALESCE_RX_USECS_HIGH = 19,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH = 20,
	ETHTOOL_A_COALESCE_TX_USECS_HIGH = 21,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH = 22,
	ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL = 23,
	__ETHTOOL_A_COALESCE_CNT = 24,
	ETHTOOL_A_COALESCE_MAX = 23,
};

enum {
	ETHTOOL_A_PAUSE_UNSPEC = 0,
	ETHTOOL_A_PAUSE_HEADER = 1,
	ETHTOOL_A_PAUSE_AUTONEG = 2,
	ETHTOOL_A_PAUSE_RX = 3,
	ETHTOOL_A_PAUSE_TX = 4,
	ETHTOOL_A_PAUSE_STATS = 5,
	__ETHTOOL_A_PAUSE_CNT = 6,
	ETHTOOL_A_PAUSE_MAX = 5,
};

enum {
	ETHTOOL_A_EEE_UNSPEC = 0,
	ETHTOOL_A_EEE_HEADER = 1,
	ETHTOOL_A_EEE_MODES_OURS = 2,
	ETHTOOL_A_EEE_MODES_PEER = 3,
	ETHTOOL_A_EEE_ACTIVE = 4,
	ETHTOOL_A_EEE_ENABLED = 5,
	ETHTOOL_A_EEE_TX_LPI_ENABLED = 6,
	ETHTOOL_A_EEE_TX_LPI_TIMER = 7,
	__ETHTOOL_A_EEE_CNT = 8,
	ETHTOOL_A_EEE_MAX = 7,
};

enum {
	ETHTOOL_A_TSINFO_UNSPEC = 0,
	ETHTOOL_A_TSINFO_HEADER = 1,
	ETHTOOL_A_TSINFO_TIMESTAMPING = 2,
	ETHTOOL_A_TSINFO_TX_TYPES = 3,
	ETHTOOL_A_TSINFO_RX_FILTERS = 4,
	ETHTOOL_A_TSINFO_PHC_INDEX = 5,
	__ETHTOOL_A_TSINFO_CNT = 6,
	ETHTOOL_A_TSINFO_MAX = 5,
};

enum {
	ETHTOOL_A_CABLE_TEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_HEADER = 1,
	__ETHTOOL_A_CABLE_TEST_CNT = 2,
	ETHTOOL_A_CABLE_TEST_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG = 2,
	__ETHTOOL_A_CABLE_TEST_TDR_CNT = 3,
	ETHTOOL_A_CABLE_TEST_TDR_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_INFO_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_INFO_HEADER = 1,
	ETHTOOL_A_TUNNEL_INFO_UDP_PORTS = 2,
	__ETHTOOL_A_TUNNEL_INFO_CNT = 3,
	ETHTOOL_A_TUNNEL_INFO_MAX = 2,
};

enum {
	ETHTOOL_A_FEC_UNSPEC = 0,
	ETHTOOL_A_FEC_HEADER = 1,
	ETHTOOL_A_FEC_MODES = 2,
	ETHTOOL_A_FEC_AUTO = 3,
	ETHTOOL_A_FEC_ACTIVE = 4,
	ETHTOOL_A_FEC_STATS = 5,
	__ETHTOOL_A_FEC_CNT = 6,
	ETHTOOL_A_FEC_MAX = 5,
};

enum {
	ETHTOOL_A_MODULE_EEPROM_UNSPEC = 0,
	ETHTOOL_A_MODULE_EEPROM_HEADER = 1,
	ETHTOOL_A_MODULE_EEPROM_OFFSET = 2,
	ETHTOOL_A_MODULE_EEPROM_LENGTH = 3,
	ETHTOOL_A_MODULE_EEPROM_PAGE = 4,
	ETHTOOL_A_MODULE_EEPROM_BANK = 5,
	ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS = 6,
	ETHTOOL_A_MODULE_EEPROM_DATA = 7,
	__ETHTOOL_A_MODULE_EEPROM_CNT = 8,
	ETHTOOL_A_MODULE_EEPROM_MAX = 7,
};

enum {
	ETHTOOL_STATS_ETH_PHY = 0,
	ETHTOOL_STATS_ETH_MAC = 1,
	ETHTOOL_STATS_ETH_CTRL = 2,
	ETHTOOL_STATS_RMON = 3,
	__ETHTOOL_STATS_CNT = 4,
};

enum {
	ETHTOOL_A_STATS_ETH_PHY_5_SYM_ERR = 0,
	__ETHTOOL_A_STATS_ETH_PHY_CNT = 1,
	ETHTOOL_A_STATS_ETH_PHY_MAX = 0,
};

enum {
	ETHTOOL_A_STATS_ETH_MAC_2_TX_PKT = 0,
	ETHTOOL_A_STATS_ETH_MAC_3_SINGLE_COL = 1,
	ETHTOOL_A_STATS_ETH_MAC_4_MULTI_COL = 2,
	ETHTOOL_A_STATS_ETH_MAC_5_RX_PKT = 3,
	ETHTOOL_A_STATS_ETH_MAC_6_FCS_ERR = 4,
	ETHTOOL_A_STATS_ETH_MAC_7_ALIGN_ERR = 5,
	ETHTOOL_A_STATS_ETH_MAC_8_TX_BYTES = 6,
	ETHTOOL_A_STATS_ETH_MAC_9_TX_DEFER = 7,
	ETHTOOL_A_STATS_ETH_MAC_10_LATE_COL = 8,
	ETHTOOL_A_STATS_ETH_MAC_11_XS_COL = 9,
	ETHTOOL_A_STATS_ETH_MAC_12_TX_INT_ERR = 10,
	ETHTOOL_A_STATS_ETH_MAC_13_CS_ERR = 11,
	ETHTOOL_A_STATS_ETH_MAC_14_RX_BYTES = 12,
	ETHTOOL_A_STATS_ETH_MAC_15_RX_INT_ERR = 13,
	ETHTOOL_A_STATS_ETH_MAC_18_TX_MCAST = 14,
	ETHTOOL_A_STATS_ETH_MAC_19_TX_BCAST = 15,
	ETHTOOL_A_STATS_ETH_MAC_20_XS_DEFER = 16,
	ETHTOOL_A_STATS_ETH_MAC_21_RX_MCAST = 17,
	ETHTOOL_A_STATS_ETH_MAC_22_RX_BCAST = 18,
	ETHTOOL_A_STATS_ETH_MAC_23_IR_LEN_ERR = 19,
	ETHTOOL_A_STATS_ETH_MAC_24_OOR_LEN = 20,
	ETHTOOL_A_STATS_ETH_MAC_25_TOO_LONG_ERR = 21,
	__ETHTOOL_A_STATS_ETH_MAC_CNT = 22,
	ETHTOOL_A_STATS_ETH_MAC_MAX = 21,
};

enum {
	ETHTOOL_A_STATS_ETH_CTRL_3_TX = 0,
	ETHTOOL_A_STATS_ETH_CTRL_4_RX = 1,
	ETHTOOL_A_STATS_ETH_CTRL_5_RX_UNSUP = 2,
	__ETHTOOL_A_STATS_ETH_CTRL_CNT = 3,
	ETHTOOL_A_STATS_ETH_CTRL_MAX = 2,
};

enum {
	ETHTOOL_A_STATS_RMON_UNDERSIZE = 0,
	ETHTOOL_A_STATS_RMON_OVERSIZE = 1,
	ETHTOOL_A_STATS_RMON_FRAG = 2,
	ETHTOOL_A_STATS_RMON_JABBER = 3,
	__ETHTOOL_A_STATS_RMON_CNT = 4,
	ETHTOOL_A_STATS_RMON_MAX = 3,
};

enum ethtool_multicast_groups {
	ETHNL_MCGRP_MONITOR = 0,
};

struct ethnl_req_info {
	struct net_device *dev;
	u32 flags;
};

struct ethnl_reply_data {
	struct net_device *dev;
};

struct ethnl_request_ops {
	u8 request_cmd;
	u8 reply_cmd;
	u16 hdr_attr;
	unsigned int req_info_size;
	unsigned int reply_data_size;
	bool allow_nodev_do;
	int (*parse_request)(struct ethnl_req_info *, struct nlattr **, struct netlink_ext_ack *);
	int (*prepare_data)(const struct ethnl_req_info *, struct ethnl_reply_data *, struct genl_info *);
	int (*reply_size)(const struct ethnl_req_info *, const struct ethnl_reply_data *);
	int (*fill_reply)(struct sk_buff *, const struct ethnl_req_info *, const struct ethnl_reply_data *);
	void (*cleanup_data)(struct ethnl_reply_data *);
};

struct ethnl_dump_ctx {
	const struct ethnl_request_ops *ops;
	struct ethnl_req_info *req_info;
	struct ethnl_reply_data *reply_data;
	int pos_hash;
	int pos_idx;
};

typedef void (*ethnl_notify_handler_t)(struct net_device *, unsigned int, const void *);

enum {
	ETHTOOL_A_BITSET_BIT_UNSPEC = 0,
	ETHTOOL_A_BITSET_BIT_INDEX = 1,
	ETHTOOL_A_BITSET_BIT_NAME = 2,
	ETHTOOL_A_BITSET_BIT_VALUE = 3,
	__ETHTOOL_A_BITSET_BIT_CNT = 4,
	ETHTOOL_A_BITSET_BIT_MAX = 3,
};

enum {
	ETHTOOL_A_BITSET_BITS_UNSPEC = 0,
	ETHTOOL_A_BITSET_BITS_BIT = 1,
	__ETHTOOL_A_BITSET_BITS_CNT = 2,
	ETHTOOL_A_BITSET_BITS_MAX = 1,
};

enum {
	ETHTOOL_A_BITSET_UNSPEC = 0,
	ETHTOOL_A_BITSET_NOMASK = 1,
	ETHTOOL_A_BITSET_SIZE = 2,
	ETHTOOL_A_BITSET_BITS = 3,
	ETHTOOL_A_BITSET_VALUE = 4,
	ETHTOOL_A_BITSET_MASK = 5,
	__ETHTOOL_A_BITSET_CNT = 6,
	ETHTOOL_A_BITSET_MAX = 5,
};

typedef const char (* const ethnl_string_array_t)[32];

enum {
	ETHTOOL_A_STRING_UNSPEC = 0,
	ETHTOOL_A_STRING_INDEX = 1,
	ETHTOOL_A_STRING_VALUE = 2,
	__ETHTOOL_A_STRING_CNT = 3,
	ETHTOOL_A_STRING_MAX = 2,
};

enum {
	ETHTOOL_A_STRINGS_UNSPEC = 0,
	ETHTOOL_A_STRINGS_STRING = 1,
	__ETHTOOL_A_STRINGS_CNT = 2,
	ETHTOOL_A_STRINGS_MAX = 1,
};

enum {
	ETHTOOL_A_STRINGSET_UNSPEC = 0,
	ETHTOOL_A_STRINGSET_ID = 1,
	ETHTOOL_A_STRINGSET_COUNT = 2,
	ETHTOOL_A_STRINGSET_STRINGS = 3,
	__ETHTOOL_A_STRINGSET_CNT = 4,
	ETHTOOL_A_STRINGSET_MAX = 3,
};

enum {
	ETHTOOL_A_STRINGSETS_UNSPEC = 0,
	ETHTOOL_A_STRINGSETS_STRINGSET = 1,
	__ETHTOOL_A_STRINGSETS_CNT = 2,
	ETHTOOL_A_STRINGSETS_MAX = 1,
};

struct strset_info {
	bool per_dev;
	bool free_strings;
	unsigned int count;
	const char (*strings)[32];
};

struct strset_req_info {
	struct ethnl_req_info base;
	u32 req_ids;
	bool counts_only;
};

struct strset_reply_data {
	struct ethnl_reply_data base;
	struct strset_info sets[21];
};

struct linkinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
};

struct linkmodes_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
	bool peer_empty;
};

struct linkstate_reply_data {
	struct ethnl_reply_data base;
	int link;
	int sqi;
	int sqi_max;
	bool link_ext_state_provided;
	struct ethtool_link_ext_state_info ethtool_link_ext_state_info;
};

struct debug_reply_data {
	struct ethnl_reply_data base;
	u32 msg_mask;
};

struct wol_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_wolinfo wol;
	bool show_sopass;
};

struct features_reply_data {
	struct ethnl_reply_data base;
	u32 hw[2];
	u32 wanted[2];
	u32 active[2];
	u32 nochange[2];
	u32 all[2];
};

struct privflags_reply_data {
	struct ethnl_reply_data base;
	const char (*priv_flag_names)[32];
	unsigned int n_priv_flags;
	u32 priv_flags;
};

struct rings_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ringparam ringparam;
};

struct channels_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_channels channels;
};

struct coalesce_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_coalesce coalesce;
	u32 supported_params;
};

enum {
	ETHTOOL_A_PAUSE_STAT_UNSPEC = 0,
	ETHTOOL_A_PAUSE_STAT_PAD = 1,
	ETHTOOL_A_PAUSE_STAT_TX_FRAMES = 2,
	ETHTOOL_A_PAUSE_STAT_RX_FRAMES = 3,
	__ETHTOOL_A_PAUSE_STAT_CNT = 4,
	ETHTOOL_A_PAUSE_STAT_MAX = 3,
};

struct pause_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_pauseparam pauseparam;
	struct ethtool_pause_stats pausestat;
};

struct eee_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_eee eee;
};

struct tsinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ts_info ts_info;
};

enum {
	ETHTOOL_A_CABLE_PAIR_A = 0,
	ETHTOOL_A_CABLE_PAIR_B = 1,
	ETHTOOL_A_CABLE_PAIR_C = 2,
	ETHTOOL_A_CABLE_PAIR_D = 3,
};

enum {
	ETHTOOL_A_CABLE_RESULT_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_PAIR = 1,
	ETHTOOL_A_CABLE_RESULT_CODE = 2,
	__ETHTOOL_A_CABLE_RESULT_CNT = 3,
	ETHTOOL_A_CABLE_RESULT_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_FAULT_LENGTH_UNSPEC = 0,
	ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR = 1,
	ETHTOOL_A_CABLE_FAULT_LENGTH_CM = 2,
	__ETHTOOL_A_CABLE_FAULT_LENGTH_CNT = 3,
	ETHTOOL_A_CABLE_FAULT_LENGTH_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_STARTED = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_COMPLETED = 2,
};

enum {
	ETHTOOL_A_CABLE_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_NEST_RESULT = 1,
	ETHTOOL_A_CABLE_NEST_FAULT_LENGTH = 2,
	__ETHTOOL_A_CABLE_NEST_CNT = 3,
	ETHTOOL_A_CABLE_NEST_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS = 2,
	ETHTOOL_A_CABLE_TEST_NTF_NEST = 3,
	__ETHTOOL_A_CABLE_TEST_NTF_CNT = 4,
	ETHTOOL_A_CABLE_TEST_NTF_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_CFG_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST = 2,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP = 3,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR = 4,
	__ETHTOOL_A_CABLE_TEST_TDR_CFG_CNT = 5,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX = 4,
};

enum {
	ETHTOOL_A_CABLE_AMPLITUDE_UNSPEC = 0,
	ETHTOOL_A_CABLE_AMPLITUDE_PAIR = 1,
	ETHTOOL_A_CABLE_AMPLITUDE_mV = 2,
	__ETHTOOL_A_CABLE_AMPLITUDE_CNT = 3,
	ETHTOOL_A_CABLE_AMPLITUDE_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_PULSE_UNSPEC = 0,
	ETHTOOL_A_CABLE_PULSE_mV = 1,
	__ETHTOOL_A_CABLE_PULSE_CNT = 2,
	ETHTOOL_A_CABLE_PULSE_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_STEP_UNSPEC = 0,
	ETHTOOL_A_CABLE_STEP_FIRST_DISTANCE = 1,
	ETHTOOL_A_CABLE_STEP_LAST_DISTANCE = 2,
	ETHTOOL_A_CABLE_STEP_STEP_DISTANCE = 3,
	__ETHTOOL_A_CABLE_STEP_CNT = 4,
	ETHTOOL_A_CABLE_STEP_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TDR_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TDR_NEST_STEP = 1,
	ETHTOOL_A_CABLE_TDR_NEST_AMPLITUDE = 2,
	ETHTOOL_A_CABLE_TDR_NEST_PULSE = 3,
	__ETHTOOL_A_CABLE_TDR_NEST_CNT = 4,
	ETHTOOL_A_CABLE_TDR_NEST_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_ENTRY_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT = 1,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE = 2,
	__ETHTOOL_A_TUNNEL_UDP_ENTRY_CNT = 3,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_TABLE_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE = 1,
	ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES = 2,
	ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY = 3,
	__ETHTOOL_A_TUNNEL_UDP_TABLE_CNT = 4,
	ETHTOOL_A_TUNNEL_UDP_TABLE_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE = 1,
	__ETHTOOL_A_TUNNEL_UDP_CNT = 2,
	ETHTOOL_A_TUNNEL_UDP_MAX = 1,
};

enum udp_parsable_tunnel_type {
	UDP_TUNNEL_TYPE_VXLAN = 1,
	UDP_TUNNEL_TYPE_GENEVE = 2,
	UDP_TUNNEL_TYPE_VXLAN_GPE = 4,
};

enum udp_tunnel_nic_info_flags {
	UDP_TUNNEL_NIC_INFO_MAY_SLEEP = 1,
	UDP_TUNNEL_NIC_INFO_OPEN_ONLY = 2,
	UDP_TUNNEL_NIC_INFO_IPV4_ONLY = 4,
	UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN = 8,
};

struct ethnl_tunnel_info_dump_ctx {
	struct ethnl_req_info req_info;
	int pos_hash;
	int pos_idx;
};

enum {
	ETHTOOL_A_FEC_STAT_UNSPEC = 0,
	ETHTOOL_A_FEC_STAT_PAD = 1,
	ETHTOOL_A_FEC_STAT_CORRECTED = 2,
	ETHTOOL_A_FEC_STAT_UNCORR = 3,
	ETHTOOL_A_FEC_STAT_CORR_BITS = 4,
	__ETHTOOL_A_FEC_STAT_CNT = 5,
	ETHTOOL_A_FEC_STAT_MAX = 4,
};

struct fec_stat_grp {
	u64 stats[9];
	u8 cnt;
};

struct fec_reply_data {
	struct ethnl_reply_data base;
	long unsigned int fec_link_modes[2];
	u32 active_fec;
	u8 fec_auto;
	struct fec_stat_grp corr;
	struct fec_stat_grp uncorr;
	struct fec_stat_grp corr_bits;
};

struct eeprom_req_info {
	struct ethnl_req_info base;
	u32 offset;
	u32 length;
	u8 page;
	u8 bank;
	u8 i2c_address;
};

struct eeprom_reply_data {
	struct ethnl_reply_data base;
	u32 length;
	u8 *data;
};

enum {
	ETHTOOL_A_STATS_GRP_UNSPEC = 0,
	ETHTOOL_A_STATS_GRP_PAD = 1,
	ETHTOOL_A_STATS_GRP_ID = 2,
	ETHTOOL_A_STATS_GRP_SS_ID = 3,
	ETHTOOL_A_STATS_GRP_STAT = 4,
	ETHTOOL_A_STATS_GRP_HIST_RX = 5,
	ETHTOOL_A_STATS_GRP_HIST_TX = 6,
	ETHTOOL_A_STATS_GRP_HIST_BKT_LOW = 7,
	ETHTOOL_A_STATS_GRP_HIST_BKT_HI = 8,
	ETHTOOL_A_STATS_GRP_HIST_VAL = 9,
	__ETHTOOL_A_STATS_GRP_CNT = 10,
	ETHTOOL_A_STATS_GRP_MAX = 4,
};

struct stats_req_info {
	struct ethnl_req_info base;
	long unsigned int stat_mask[1];
};

struct stats_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_eth_phy_stats phy_stats;
	struct ethtool_eth_mac_stats mac_stats;
	struct ethtool_eth_ctrl_stats ctrl_stats;
	struct ethtool_rmon_stats rmon_stats;
	const struct ethtool_rmon_hist_range *rmon_ranges;
};

struct nf_hook_entries_rcu_head {
	struct callback_head head;
	void *allocation;
};

struct nf_loginfo {
	u_int8_t type;
	union {
		struct {
			u_int32_t copy_len;
			u_int16_t group;
			u_int16_t qthreshold;
			u_int16_t flags;
		} ulog;
		struct {
			u_int8_t level;
			u_int8_t logflags;
		} log;
	} u;
};

struct nf_log_buf {
	unsigned int count;
	char buf[1020];
};

struct nf_bridge_info {
	enum {
		BRNF_PROTO_UNCHANGED = 0,
		BRNF_PROTO_8021Q = 1,
		BRNF_PROTO_PPPOE = 2,
	} orig_proto: 8;
	u8 pkt_otherhost: 1;
	u8 in_prerouting: 1;
	u8 bridged_dnat: 1;
	__u16 frag_max_size;
	struct net_device *physindev;
	struct net_device *physoutdev;
	union {
		__be32 ipv4_daddr;
		struct in6_addr ipv6_daddr;
		char neigh_header[8];
	};
};

struct ip_rt_info {
	__be32 daddr;
	__be32 saddr;
	u_int8_t tos;
	u_int32_t mark;
};

struct ip6_rt_info {
	struct in6_addr daddr;
	struct in6_addr saddr;
	u_int32_t mark;
};

struct nf_sockopt_ops {
	struct list_head list;
	u_int8_t pf;
	int set_optmin;
	int set_optmax;
	int (*set)(struct sock *, int, sockptr_t, unsigned int);
	int get_optmin;
	int get_optmax;
	int (*get)(struct sock *, int, void *, int *);
	struct module *owner;
};

struct ip_mreqn {
	struct in_addr imr_multiaddr;
	struct in_addr imr_address;
	int imr_ifindex;
};

struct rtmsg {
	unsigned char rtm_family;
	unsigned char rtm_dst_len;
	unsigned char rtm_src_len;
	unsigned char rtm_tos;
	unsigned char rtm_table;
	unsigned char rtm_protocol;
	unsigned char rtm_scope;
	unsigned char rtm_type;
	unsigned int rtm_flags;
};

struct rtvia {
	__kernel_sa_family_t rtvia_family;
	__u8 rtvia_addr[0];
};

struct ip_sf_list;

struct ip_mc_list {
	struct in_device *interface;
	__be32 multiaddr;
	unsigned int sfmode;
	struct ip_sf_list *sources;
	struct ip_sf_list *tomb;
	long unsigned int sfcount[2];
	union {
		struct ip_mc_list *next;
		struct ip_mc_list *next_rcu;
	};
	struct ip_mc_list *next_hash;
	struct timer_list timer;
	int users;
	refcount_t refcnt;
	spinlock_t lock;
	char tm_running;
	char reporter;
	char unsolicit_count;
	char loaded;
	unsigned char gsquery;
	unsigned char crcount;
	struct callback_head rcu;
};

struct ip_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	__be32 sl_addr[0];
};

struct ip_mc_socklist {
	struct ip_mc_socklist *next_rcu;
	struct ip_mreqn multi;
	unsigned int sfmode;
	struct ip_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ip_sf_list {
	struct ip_sf_list *sf_next;
	long unsigned int sf_count[2];
	__be32 sf_inaddr;
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct ipv4_addr_key {
	__be32 addr;
	int vif;
};

struct inetpeer_addr {
	union {
		struct ipv4_addr_key a4;
		struct in6_addr a6;
		u32 key[4];
	};
	__u16 family;
};

struct inet_peer {
	struct rb_node rb_node;
	struct inetpeer_addr daddr;
	u32 metrics[17];
	u32 rate_tokens;
	u32 n_redirects;
	long unsigned int rate_last;
	union {
		struct {
			atomic_t rid;
		};
		struct callback_head rcu;
	};
	__u32 dtime;
	refcount_t refcnt;
};

struct fib_rt_info {
	struct fib_info *fi;
	u32 tb_id;
	__be32 dst;
	int dst_len;
	u8 tos;
	u8 type;
	u8 offload: 1;
	u8 trap: 1;
	u8 offload_failed: 1;
	u8 unused: 5;
};

struct uncached_list {
	spinlock_t lock;
	struct list_head head;
};

struct rt_cache_stat {
	unsigned int in_slow_tot;
	unsigned int in_slow_mc;
	unsigned int in_no_route;
	unsigned int in_brd;
	unsigned int in_martian_dst;
	unsigned int in_martian_src;
	unsigned int out_slow_tot;
	unsigned int out_slow_mc;
};

struct fib_alias {
	struct hlist_node fa_list;
	struct fib_info *fa_info;
	u8 fa_tos;
	u8 fa_type;
	u8 fa_state;
	u8 fa_slen;
	u32 tb_id;
	s16 fa_default;
	u8 offload: 1;
	u8 trap: 1;
	u8 offload_failed: 1;
	u8 unused: 5;
	struct callback_head rcu;
};

struct fib_prop {
	int error;
	u8 scope;
};

struct raw_hashinfo {
	rwlock_t lock;
	struct hlist_head ht[256];
};

enum ip_defrag_users {
	IP_DEFRAG_LOCAL_DELIVER = 0,
	IP_DEFRAG_CALL_RA_CHAIN = 1,
	IP_DEFRAG_CONNTRACK_IN = 2,
	__IP_DEFRAG_CONNTRACK_IN_END = 65537,
	IP_DEFRAG_CONNTRACK_OUT = 65538,
	__IP_DEFRAG_CONNTRACK_OUT_END = 131073,
	IP_DEFRAG_CONNTRACK_BRIDGE_IN = 131074,
	__IP_DEFRAG_CONNTRACK_BRIDGE_IN = 196609,
	IP_DEFRAG_VS_IN = 196610,
	IP_DEFRAG_VS_OUT = 196611,
	IP_DEFRAG_VS_FWD = 196612,
	IP_DEFRAG_AF_PACKET = 196613,
	IP_DEFRAG_MACVLAN = 196614,
};

enum {
	INET_FRAG_FIRST_IN = 1,
	INET_FRAG_LAST_IN = 2,
	INET_FRAG_COMPLETE = 4,
	INET_FRAG_HASH_DEAD = 8,
};

struct ipq {
	struct inet_frag_queue q;
	u8 ecn;
	u16 max_df_size;
	int iif;
	unsigned int rid;
	struct inet_peer *peer;
};

struct ip_options_data {
	struct ip_options_rcu opt;
	char data[40];
};

struct ipcm_cookie {
	struct sockcm_cookie sockc;
	__be32 addr;
	int oif;
	struct ip_options_rcu *opt;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
};

struct ip_fraglist_iter {
	struct sk_buff *frag;
	struct iphdr *iph;
	int offset;
	unsigned int hlen;
};

struct ip_frag_state {
	bool DF;
	unsigned int hlen;
	unsigned int ll_rs;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	__be16 not_last_frag;
};

struct ip_reply_arg {
	struct kvec iov[1];
	int flags;
	__wsum csum;
	int csumoffset;
	int bound_dev_if;
	u8 tos;
	kuid_t uid;
};

struct ip_mreq_source {
	__be32 imr_multiaddr;
	__be32 imr_interface;
	__be32 imr_sourceaddr;
};

struct ip_msfilter {
	__be32 imsf_multiaddr;
	__be32 imsf_interface;
	__u32 imsf_fmode;
	__u32 imsf_numsrc;
	__be32 imsf_slist[1];
};

struct group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
};

struct group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
};

struct group_filter {
	__u32 gf_interface;
	struct __kernel_sockaddr_storage gf_group;
	__u32 gf_fmode;
	__u32 gf_numsrc;
	struct __kernel_sockaddr_storage gf_slist[1];
};

struct in_pktinfo {
	int ipi_ifindex;
	struct in_addr ipi_spec_dst;
	struct in_addr ipi_addr;
};

struct compat_group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
} __attribute__((packed));

struct compat_group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
} __attribute__((packed));

struct compat_group_filter {
	__u32 gf_interface;
	struct __kernel_sockaddr_storage gf_group;
	__u32 gf_fmode;
	__u32 gf_numsrc;
	struct __kernel_sockaddr_storage gf_slist[1];
} __attribute__((packed));

enum {
	BPFILTER_IPT_SO_SET_REPLACE = 64,
	BPFILTER_IPT_SO_SET_ADD_COUNTERS = 65,
	BPFILTER_IPT_SET_MAX = 66,
};

enum {
	BPFILTER_IPT_SO_GET_INFO = 64,
	BPFILTER_IPT_SO_GET_ENTRIES = 65,
	BPFILTER_IPT_SO_GET_REVISION_MATCH = 66,
	BPFILTER_IPT_SO_GET_REVISION_TARGET = 67,
	BPFILTER_IPT_GET_MAX = 68,
};

struct bpfilter_umh_ops {
	struct umd_info info;
	struct mutex lock;
	int (*sockopt)(struct sock *, int, sockptr_t, unsigned int, bool);
	int (*start)();
};

struct tcpvegas_info {
	__u32 tcpv_enabled;
	__u32 tcpv_rttcnt;
	__u32 tcpv_rtt;
	__u32 tcpv_minrtt;
};

struct tcp_dctcp_info {
	__u16 dctcp_enabled;
	__u16 dctcp_ce_state;
	__u32 dctcp_alpha;
	__u32 dctcp_ab_ecn;
	__u32 dctcp_ab_tot;
};

struct tcp_bbr_info {
	__u32 bbr_bw_lo;
	__u32 bbr_bw_hi;
	__u32 bbr_min_rtt;
	__u32 bbr_pacing_gain;
	__u32 bbr_cwnd_gain;
};

union tcp_cc_info {
	struct tcpvegas_info vegas;
	struct tcp_dctcp_info dctcp;
	struct tcp_bbr_info bbr;
};

enum {
	BPF_TCP_ESTABLISHED = 1,
	BPF_TCP_SYN_SENT = 2,
	BPF_TCP_SYN_RECV = 3,
	BPF_TCP_FIN_WAIT1 = 4,
	BPF_TCP_FIN_WAIT2 = 5,
	BPF_TCP_TIME_WAIT = 6,
	BPF_TCP_CLOSE = 7,
	BPF_TCP_CLOSE_WAIT = 8,
	BPF_TCP_LAST_ACK = 9,
	BPF_TCP_LISTEN = 10,
	BPF_TCP_CLOSING = 11,
	BPF_TCP_NEW_SYN_RECV = 12,
	BPF_TCP_MAX_STATES = 13,
};

enum inet_csk_ack_state_t {
	ICSK_ACK_SCHED = 1,
	ICSK_ACK_TIMER = 2,
	ICSK_ACK_PUSHED = 4,
	ICSK_ACK_PUSHED2 = 8,
	ICSK_ACK_NOW = 16,
};

enum {
	TCP_FLAG_CWR = 32768,
	TCP_FLAG_ECE = 16384,
	TCP_FLAG_URG = 8192,
	TCP_FLAG_ACK = 4096,
	TCP_FLAG_PSH = 2048,
	TCP_FLAG_RST = 1024,
	TCP_FLAG_SYN = 512,
	TCP_FLAG_FIN = 256,
	TCP_RESERVED_BITS = 15,
	TCP_DATA_OFFSET = 240,
};

struct tcp_repair_opt {
	__u32 opt_code;
	__u32 opt_val;
};

struct tcp_repair_window {
	__u32 snd_wl1;
	__u32 snd_wnd;
	__u32 max_window;
	__u32 rcv_wnd;
	__u32 rcv_wup;
};

enum {
	TCP_NO_QUEUE = 0,
	TCP_RECV_QUEUE = 1,
	TCP_SEND_QUEUE = 2,
	TCP_QUEUES_NR = 3,
};

struct tcp_info {
	__u8 tcpi_state;
	__u8 tcpi_ca_state;
	__u8 tcpi_retransmits;
	__u8 tcpi_probes;
	__u8 tcpi_backoff;
	__u8 tcpi_options;
	__u8 tcpi_snd_wscale: 4;
	__u8 tcpi_rcv_wscale: 4;
	__u8 tcpi_delivery_rate_app_limited: 1;
	__u8 tcpi_fastopen_client_fail: 2;
	__u32 tcpi_rto;
	__u32 tcpi_ato;
	__u32 tcpi_snd_mss;
	__u32 tcpi_rcv_mss;
	__u32 tcpi_unacked;
	__u32 tcpi_sacked;
	__u32 tcpi_lost;
	__u32 tcpi_retrans;
	__u32 tcpi_fackets;
	__u32 tcpi_last_data_sent;
	__u32 tcpi_last_ack_sent;
	__u32 tcpi_last_data_recv;
	__u32 tcpi_last_ack_recv;
	__u32 tcpi_pmtu;
	__u32 tcpi_rcv_ssthresh;
	__u32 tcpi_rtt;
	__u32 tcpi_rttvar;
	__u32 tcpi_snd_ssthresh;
	__u32 tcpi_snd_cwnd;
	__u32 tcpi_advmss;
	__u32 tcpi_reordering;
	__u32 tcpi_rcv_rtt;
	__u32 tcpi_rcv_space;
	__u32 tcpi_total_retrans;
	__u64 tcpi_pacing_rate;
	__u64 tcpi_max_pacing_rate;
	__u64 tcpi_bytes_acked;
	__u64 tcpi_bytes_received;
	__u32 tcpi_segs_out;
	__u32 tcpi_segs_in;
	__u32 tcpi_notsent_bytes;
	__u32 tcpi_min_rtt;
	__u32 tcpi_data_segs_in;
	__u32 tcpi_data_segs_out;
	__u64 tcpi_delivery_rate;
	__u64 tcpi_busy_time;
	__u64 tcpi_rwnd_limited;
	__u64 tcpi_sndbuf_limited;
	__u32 tcpi_delivered;
	__u32 tcpi_delivered_ce;
	__u64 tcpi_bytes_sent;
	__u64 tcpi_bytes_retrans;
	__u32 tcpi_dsack_dups;
	__u32 tcpi_reord_seen;
	__u32 tcpi_rcv_ooopack;
	__u32 tcpi_snd_wnd;
};

enum {
	TCP_NLA_PAD = 0,
	TCP_NLA_BUSY = 1,
	TCP_NLA_RWND_LIMITED = 2,
	TCP_NLA_SNDBUF_LIMITED = 3,
	TCP_NLA_DATA_SEGS_OUT = 4,
	TCP_NLA_TOTAL_RETRANS = 5,
	TCP_NLA_PACING_RATE = 6,
	TCP_NLA_DELIVERY_RATE = 7,
	TCP_NLA_SND_CWND = 8,
	TCP_NLA_REORDERING = 9,
	TCP_NLA_MIN_RTT = 10,
	TCP_NLA_RECUR_RETRANS = 11,
	TCP_NLA_DELIVERY_RATE_APP_LMT = 12,
	TCP_NLA_SNDQ_SIZE = 13,
	TCP_NLA_CA_STATE = 14,
	TCP_NLA_SND_SSTHRESH = 15,
	TCP_NLA_DELIVERED = 16,
	TCP_NLA_DELIVERED_CE = 17,
	TCP_NLA_BYTES_SENT = 18,
	TCP_NLA_BYTES_RETRANS = 19,
	TCP_NLA_DSACK_DUPS = 20,
	TCP_NLA_REORD_SEEN = 21,
	TCP_NLA_SRTT = 22,
	TCP_NLA_TIMEOUT_REHASH = 23,
	TCP_NLA_BYTES_NOTSENT = 24,
	TCP_NLA_EDT = 25,
	TCP_NLA_TTL = 26,
};

struct tcp_zerocopy_receive {
	__u64 address;
	__u32 length;
	__u32 recv_skip_hint;
	__u32 inq;
	__s32 err;
	__u64 copybuf_address;
	__s32 copybuf_len;
	__u32 flags;
	__u64 msg_control;
	__u64 msg_controllen;
	__u32 msg_flags;
	__u32 reserved;
};

struct tcp_md5sig_pool {
	struct ahash_request *md5_req;
	void *scratch;
};

enum tcp_chrono {
	TCP_CHRONO_UNSPEC = 0,
	TCP_CHRONO_BUSY = 1,
	TCP_CHRONO_RWND_LIMITED = 2,
	TCP_CHRONO_SNDBUF_LIMITED = 3,
	__TCP_CHRONO_MAX = 4,
};

enum {
	TCP_CMSG_INQ = 1,
	TCP_CMSG_TS = 2,
};

struct tcp_splice_state {
	struct pipe_inode_info *pipe;
	size_t len;
	unsigned int flags;
};

enum tcp_fastopen_client_fail {
	TFO_STATUS_UNSPEC = 0,
	TFO_COOKIE_UNAVAILABLE = 1,
	TFO_DATA_NOT_ACKED = 2,
	TFO_SYN_RETRANSMITTED = 3,
};

struct tcp_sack_block_wire {
	__be32 start_seq;
	__be32 end_seq;
};

struct mptcp_ext {
	union {
		u64 data_ack;
		u32 data_ack32;
	};
	u64 data_seq;
	u32 subflow_seq;
	u16 data_len;
	u8 use_map: 1;
	u8 dsn64: 1;
	u8 data_fin: 1;
	u8 use_ack: 1;
	u8 ack64: 1;
	u8 mpc_map: 1;
	u8 frozen: 1;
	u8 reset_transient: 1;
	u8 reset_reason: 4;
};

enum tcp_queue {
	TCP_FRAG_IN_WRITE_QUEUE = 0,
	TCP_FRAG_IN_RTX_QUEUE = 1,
};

enum tcp_ca_ack_event_flags {
	CA_ACK_SLOWPATH = 1,
	CA_ACK_WIN_UPDATE = 2,
	CA_ACK_ECE = 4,
};

struct tcp_sacktag_state {
	u64 first_sackt;
	u64 last_sackt;
	u32 reord;
	u32 sack_delivered;
	int flag;
	unsigned int mss_now;
	struct rate_sample *rate;
};

enum pkt_hash_types {
	PKT_HASH_TYPE_NONE = 0,
	PKT_HASH_TYPE_L2 = 1,
	PKT_HASH_TYPE_L3 = 2,
	PKT_HASH_TYPE_L4 = 3,
};

enum {
	BPF_WRITE_HDR_TCP_CURRENT_MSS = 1,
	BPF_WRITE_HDR_TCP_SYNACK_COOKIE = 2,
};

enum tsq_flags {
	TSQF_THROTTLED = 1,
	TSQF_QUEUED = 2,
	TCPF_TSQ_DEFERRED = 4,
	TCPF_WRITE_TIMER_DEFERRED = 8,
	TCPF_DELACK_TIMER_DEFERRED = 16,
	TCPF_MTU_REDUCED_DEFERRED = 32,
};

struct mptcp_rm_list {
	u8 ids[8];
	u8 nr;
};

struct mptcp_addr_info {
	u8 id;
	sa_family_t family;
	__be16 port;
	union {
		struct in_addr addr;
		struct in6_addr addr6;
	};
};

struct mptcp_out_options {
	u16 suboptions;
	u64 sndr_key;
	u64 rcvr_key;
	u64 ahmac;
	struct mptcp_addr_info addr;
	struct mptcp_rm_list rm_list;
	u8 join_id;
	u8 backup;
	u8 reset_reason: 4;
	u8 reset_transient: 1;
	u32 nonce;
	u64 thmac;
	u32 token;
	u8 hmac[20];
	struct mptcp_ext ext_copy;
};

struct tcp_out_options {
	u16 options;
	u16 mss;
	u8 ws;
	u8 num_sack_blocks;
	u8 hash_size;
	u8 bpf_opt_len;
	__u8 *hash_location;
	__u32 tsval;
	__u32 tsecr;
	struct tcp_fastopen_cookie *fastopen_cookie;
	struct mptcp_out_options mptcp;
};

struct tsq_tasklet {
	struct tasklet_struct tasklet;
	struct list_head head;
};

struct tcp_md5sig {
	struct __kernel_sockaddr_storage tcpm_addr;
	__u8 tcpm_flags;
	__u8 tcpm_prefixlen;
	__u16 tcpm_keylen;
	int tcpm_ifindex;
	__u8 tcpm_key[80];
};

enum tcp_tw_status {
	TCP_TW_SUCCESS = 0,
	TCP_TW_RST = 1,
	TCP_TW_ACK = 2,
	TCP_TW_SYN = 3,
};

struct tcp4_pseudohdr {
	__be32 saddr;
	__be32 daddr;
	__u8 pad;
	__u8 protocol;
	__be16 len;
};

enum tcp_seq_states {
	TCP_SEQ_STATE_LISTENING = 0,
	TCP_SEQ_STATE_ESTABLISHED = 1,
};

struct tcp_seq_afinfo {
	sa_family_t family;
};

struct tcp_iter_state {
	struct seq_net_private p;
	enum tcp_seq_states state;
	struct sock *syn_wait_sk;
	struct tcp_seq_afinfo *bpf_seq_afinfo;
	int bucket;
	int offset;
	int sbucket;
	int num;
	loff_t last_pos;
};

struct bpf_iter__tcp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct sock_common *sk_common;
	};
	uid_t uid;
};

enum tcp_metric_index {
	TCP_METRIC_RTT = 0,
	TCP_METRIC_RTTVAR = 1,
	TCP_METRIC_SSTHRESH = 2,
	TCP_METRIC_CWND = 3,
	TCP_METRIC_REORDERING = 4,
	TCP_METRIC_RTT_US = 5,
	TCP_METRIC_RTTVAR_US = 6,
	__TCP_METRIC_MAX = 7,
};

enum {
	TCP_METRICS_ATTR_UNSPEC = 0,
	TCP_METRICS_ATTR_ADDR_IPV4 = 1,
	TCP_METRICS_ATTR_ADDR_IPV6 = 2,
	TCP_METRICS_ATTR_AGE = 3,
	TCP_METRICS_ATTR_TW_TSVAL = 4,
	TCP_METRICS_ATTR_TW_TS_STAMP = 5,
	TCP_METRICS_ATTR_VALS = 6,
	TCP_METRICS_ATTR_FOPEN_MSS = 7,
	TCP_METRICS_ATTR_FOPEN_SYN_DROPS = 8,
	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS = 9,
	TCP_METRICS_ATTR_FOPEN_COOKIE = 10,
	TCP_METRICS_ATTR_SADDR_IPV4 = 11,
	TCP_METRICS_ATTR_SADDR_IPV6 = 12,
	TCP_METRICS_ATTR_PAD = 13,
	__TCP_METRICS_ATTR_MAX = 14,
};

enum {
	TCP_METRICS_CMD_UNSPEC = 0,
	TCP_METRICS_CMD_GET = 1,
	TCP_METRICS_CMD_DEL = 2,
	__TCP_METRICS_CMD_MAX = 3,
};

struct tcp_fastopen_metrics {
	u16 mss;
	u16 syn_loss: 10;
	u16 try_exp: 2;
	long unsigned int last_syn_loss;
	struct tcp_fastopen_cookie cookie;
};

struct tcp_metrics_block {
	struct tcp_metrics_block *tcpm_next;
	possible_net_t tcpm_net;
	struct inetpeer_addr tcpm_saddr;
	struct inetpeer_addr tcpm_daddr;
	long unsigned int tcpm_stamp;
	u32 tcpm_lock;
	u32 tcpm_vals[5];
	struct tcp_fastopen_metrics tcpm_fastopen;
	struct callback_head callback_head;
};

struct tcpm_hash_bucket {
	struct tcp_metrics_block *chain;
};

struct icmp_filter {
	__u32 data;
};

struct raw_iter_state {
	struct seq_net_private p;
	int bucket;
};

struct raw_sock {
	struct inet_sock inet;
	struct icmp_filter filter;
	u32 ipmr_table;
};

struct raw_frag_vec {
	struct msghdr *msg;
	union {
		struct icmphdr icmph;
		char c[1];
	} hdr;
	int hlen;
};

struct udp_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	__u16 cscov;
	__u8 partial_cov;
};

struct udp_dev_scratch {
	u32 _tsize_state;
	u16 len;
	bool is_linear;
	bool csum_unnecessary;
};

struct udp_seq_afinfo {
	sa_family_t family;
	struct udp_table *udp_table;
};

struct udp_iter_state {
	struct seq_net_private p;
	int bucket;
	struct udp_seq_afinfo *bpf_seq_afinfo;
};

struct bpf_iter__udp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct udp_sock *udp_sk;
	};
	uid_t uid;
	int: 32;
	int bucket;
};

struct inet_protosw {
	struct list_head list;
	short unsigned int type;
	short unsigned int protocol;
	struct proto *prot;
	const struct proto_ops *ops;
	unsigned char flags;
};

typedef struct sk_buff * (*gro_receive_t)(struct list_head *, struct sk_buff *);

typedef struct sk_buff * (*gro_receive_sk_t)(struct sock *, struct list_head *, struct sk_buff *);

typedef struct sock * (*udp_lookup_t)(const struct sk_buff *, __be16, __be16);

struct arpreq {
	struct sockaddr arp_pa;
	struct sockaddr arp_ha;
	int arp_flags;
	struct sockaddr arp_netmask;
	char arp_dev[16];
};

enum ip_conntrack_status {
	IPS_EXPECTED_BIT = 0,
	IPS_EXPECTED = 1,
	IPS_SEEN_REPLY_BIT = 1,
	IPS_SEEN_REPLY = 2,
	IPS_ASSURED_BIT = 2,
	IPS_ASSURED = 4,
	IPS_CONFIRMED_BIT = 3,
	IPS_CONFIRMED = 8,
	IPS_SRC_NAT_BIT = 4,
	IPS_SRC_NAT = 16,
	IPS_DST_NAT_BIT = 5,
	IPS_DST_NAT = 32,
	IPS_NAT_MASK = 48,
	IPS_SEQ_ADJUST_BIT = 6,
	IPS_SEQ_ADJUST = 64,
	IPS_SRC_NAT_DONE_BIT = 7,
	IPS_SRC_NAT_DONE = 128,
	IPS_DST_NAT_DONE_BIT = 8,
	IPS_DST_NAT_DONE = 256,
	IPS_NAT_DONE_MASK = 384,
	IPS_DYING_BIT = 9,
	IPS_DYING = 512,
	IPS_FIXED_TIMEOUT_BIT = 10,
	IPS_FIXED_TIMEOUT = 1024,
	IPS_TEMPLATE_BIT = 11,
	IPS_TEMPLATE = 2048,
	IPS_UNTRACKED_BIT = 12,
	IPS_UNTRACKED = 4096,
	IPS_NAT_CLASH_BIT = 12,
	IPS_NAT_CLASH = 4096,
	IPS_HELPER_BIT = 13,
	IPS_HELPER = 8192,
	IPS_OFFLOAD_BIT = 14,
	IPS_OFFLOAD = 16384,
	IPS_HW_OFFLOAD_BIT = 15,
	IPS_HW_OFFLOAD = 32768,
	IPS_UNCHANGEABLE_MASK = 56313,
	__IPS_MAX_BIT = 16,
};

enum {
	XFRM_LOOKUP_ICMP = 1,
	XFRM_LOOKUP_QUEUE = 2,
	XFRM_LOOKUP_KEEP_DST_REF = 4,
};

struct icmp_ext_hdr {
	__u8 reserved1: 4;
	__u8 version: 4;
	__u8 reserved2;
	__sum16 checksum;
};

struct icmp_extobj_hdr {
	__be16 length;
	__u8 class_num;
	__u8 class_type;
};

struct icmp_ext_echo_ctype3_hdr {
	__be16 afi;
	__u8 addrlen;
	__u8 reserved;
};

struct icmp_ext_echo_iio {
	struct icmp_extobj_hdr extobj_hdr;
	union {
		char name[16];
		__be32 ifindex;
		struct {
			struct icmp_ext_echo_ctype3_hdr ctype3_hdr;
			union {
				__be32 ipv4_addr;
				struct in6_addr ipv6_addr;
			} ip_addr;
		} addr;
	} ident;
};

struct pingv6_ops {
	int (*ipv6_recv_error)(struct sock *, struct msghdr *, int, int *);
	void (*ip6_datagram_recv_common_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	void (*ip6_datagram_recv_specific_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	int (*icmpv6_err_convert)(u8, u8, int *);
	void (*ipv6_icmp_error)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*ipv6_chk_addr)(struct net *, const struct in6_addr *, const struct net_device *, int);
};

struct icmp_bxm {
	struct sk_buff *skb;
	int offset;
	int data_len;
	struct {
		struct icmphdr icmph;
		__be32 times[3];
	} data;
	int head_len;
	struct ip_options_data replyopts;
};

struct icmp_control {
	bool (*handler)(struct sk_buff *);
	short int error;
};

struct ifaddrmsg {
	__u8 ifa_family;
	__u8 ifa_prefixlen;
	__u8 ifa_flags;
	__u8 ifa_scope;
	__u32 ifa_index;
};

enum {
	IFA_UNSPEC = 0,
	IFA_ADDRESS = 1,
	IFA_LOCAL = 2,
	IFA_LABEL = 3,
	IFA_BROADCAST = 4,
	IFA_ANYCAST = 5,
	IFA_CACHEINFO = 6,
	IFA_MULTICAST = 7,
	IFA_FLAGS = 8,
	IFA_RT_PRIORITY = 9,
	IFA_TARGET_NETNSID = 10,
	__IFA_MAX = 11,
};

struct ifa_cacheinfo {
	__u32 ifa_prefered;
	__u32 ifa_valid;
	__u32 cstamp;
	__u32 tstamp;
};

enum {
	IFLA_INET_UNSPEC = 0,
	IFLA_INET_CONF = 1,
	__IFLA_INET_MAX = 2,
};

struct in_validator_info {
	__be32 ivi_addr;
	struct in_device *ivi_dev;
	struct netlink_ext_ack *extack;
};

struct netconfmsg {
	__u8 ncm_family;
};

enum {
	NETCONFA_UNSPEC = 0,
	NETCONFA_IFINDEX = 1,
	NETCONFA_FORWARDING = 2,
	NETCONFA_RP_FILTER = 3,
	NETCONFA_MC_FORWARDING = 4,
	NETCONFA_PROXY_NEIGH = 5,
	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN = 6,
	NETCONFA_INPUT = 7,
	NETCONFA_BC_FORWARDING = 8,
	__NETCONFA_MAX = 9,
};

struct inet_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
};

struct devinet_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table devinet_vars[33];
};

struct rtentry {
	long unsigned int rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	long unsigned int rt_pad3;
	void *rt_pad4;
	short int rt_metric;
	char *rt_dev;
	long unsigned int rt_mtu;
	long unsigned int rt_window;
	short unsigned int rt_irtt;
};

struct compat_rtentry {
	u32 rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	u32 rt_pad3;
	unsigned char rt_tos;
	unsigned char rt_class;
	short int rt_pad4;
	short int rt_metric;
	compat_uptr_t rt_dev;
	u32 rt_mtu;
	u32 rt_window;
	short unsigned int rt_irtt;
};

struct igmphdr {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
};

struct igmpv3_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	__be32 grec_mca;
	__be32 grec_src[0];
};

struct igmpv3_report {
	__u8 type;
	__u8 resv1;
	__sum16 csum;
	__be16 resv2;
	__be16 ngrec;
	struct igmpv3_grec grec[0];
};

struct igmpv3_query {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
	__u8 qrv: 3;
	__u8 suppress: 1;
	__u8 resv: 4;
	__u8 qqic;
	__be16 nsrcs;
	__be32 srcs[0];
};

struct igmp_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *in_dev;
};

struct igmp_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *idev;
	struct ip_mc_list *im;
};

struct fib_config {
	u8 fc_dst_len;
	u8 fc_tos;
	u8 fc_protocol;
	u8 fc_scope;
	u8 fc_type;
	u8 fc_gw_family;
	u32 fc_table;
	__be32 fc_dst;
	union {
		__be32 fc_gw4;
		struct in6_addr fc_gw6;
	};
	int fc_oif;
	u32 fc_flags;
	u32 fc_priority;
	__be32 fc_prefsrc;
	u32 fc_nh_id;
	struct nlattr *fc_mx;
	struct rtnexthop *fc_mp;
	int fc_mx_len;
	int fc_mp_len;
	u32 fc_flow;
	u32 fc_nlflags;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
};

struct fib_result_nl {
	__be32 fl_addr;
	u32 fl_mark;
	unsigned char fl_tos;
	unsigned char fl_scope;
	unsigned char tb_id_in;
	unsigned char tb_id;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	int err;
};

struct fib_dump_filter {
	u32 table_id;
	bool filter_set;
	bool dump_routes;
	bool dump_exceptions;
	unsigned char protocol;
	unsigned char rt_type;
	unsigned int flags;
	struct net_device *dev;
};

struct fib_nh_notifier_info {
	struct fib_notifier_info info;
	struct fib_nh *fib_nh;
};

struct fib_entry_notifier_info {
	struct fib_notifier_info info;
	u32 dst;
	int dst_len;
	struct fib_info *fi;
	u8 tos;
	u8 type;
	u32 tb_id;
};

typedef unsigned int t_key;

struct key_vector {
	t_key key;
	unsigned char pos;
	unsigned char bits;
	unsigned char slen;
	union {
		struct hlist_head leaf;
		struct key_vector *tnode[0];
	};
};

struct tnode {
	struct callback_head rcu;
	t_key empty_children;
	t_key full_children;
	struct key_vector *parent;
	struct key_vector kv[1];
};

struct trie_use_stats {
	unsigned int gets;
	unsigned int backtrack;
	unsigned int semantic_match_passed;
	unsigned int semantic_match_miss;
	unsigned int null_node_hit;
	unsigned int resize_node_skipped;
};

struct trie_stat {
	unsigned int totdepth;
	unsigned int maxdepth;
	unsigned int tnodes;
	unsigned int leaves;
	unsigned int nullpointers;
	unsigned int prefixes;
	unsigned int nodesizes[32];
};

struct trie {
	struct key_vector kv[1];
	struct trie_use_stats *stats;
};

struct fib_trie_iter {
	struct seq_net_private p;
	struct fib_table *tb;
	struct key_vector *tnode;
	unsigned int index;
	unsigned int depth;
};

struct fib_route_iter {
	struct seq_net_private p;
	struct fib_table *main_tb;
	struct key_vector *tnode;
	loff_t pos;
	t_key key;
};

struct ipfrag_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	};
	struct sk_buff *next_frag;
	int frag_run_len;
};

struct icmpv6_echo {
	__be16 identifier;
	__be16 sequence;
};

struct icmpv6_nd_advt {
	__u32 reserved: 5;
	__u32 override: 1;
	__u32 solicited: 1;
	__u32 router: 1;
	__u32 reserved2: 24;
};

struct icmpv6_nd_ra {
	__u8 hop_limit;
	__u8 reserved: 3;
	__u8 router_pref: 2;
	__u8 home_agent: 1;
	__u8 other: 1;
	__u8 managed: 1;
	__be16 rt_lifetime;
};

struct icmp6hdr {
	__u8 icmp6_type;
	__u8 icmp6_code;
	__sum16 icmp6_cksum;
	union {
		__be32 un_data32[1];
		__be16 un_data16[2];
		__u8 un_data8[4];
		struct icmpv6_echo u_echo;
		struct icmpv6_nd_advt u_nd_advt;
		struct icmpv6_nd_ra u_nd_ra;
	} icmp6_dataun;
};

struct ping_iter_state {
	struct seq_net_private p;
	int bucket;
	sa_family_t family;
};

struct pingfakehdr {
	struct icmphdr icmph;
	struct msghdr *msg;
	sa_family_t family;
	__wsum wcheck;
};

struct ping_table {
	struct hlist_nulls_head hash[64];
	rwlock_t lock;
};

enum lwtunnel_ip_t {
	LWTUNNEL_IP_UNSPEC = 0,
	LWTUNNEL_IP_ID = 1,
	LWTUNNEL_IP_DST = 2,
	LWTUNNEL_IP_SRC = 3,
	LWTUNNEL_IP_TTL = 4,
	LWTUNNEL_IP_TOS = 5,
	LWTUNNEL_IP_FLAGS = 6,
	LWTUNNEL_IP_PAD = 7,
	LWTUNNEL_IP_OPTS = 8,
	__LWTUNNEL_IP_MAX = 9,
};

enum lwtunnel_ip6_t {
	LWTUNNEL_IP6_UNSPEC = 0,
	LWTUNNEL_IP6_ID = 1,
	LWTUNNEL_IP6_DST = 2,
	LWTUNNEL_IP6_SRC = 3,
	LWTUNNEL_IP6_HOPLIMIT = 4,
	LWTUNNEL_IP6_TC = 5,
	LWTUNNEL_IP6_FLAGS = 6,
	LWTUNNEL_IP6_PAD = 7,
	LWTUNNEL_IP6_OPTS = 8,
	__LWTUNNEL_IP6_MAX = 9,
};

enum {
	LWTUNNEL_IP_OPTS_UNSPEC = 0,
	LWTUNNEL_IP_OPTS_GENEVE = 1,
	LWTUNNEL_IP_OPTS_VXLAN = 2,
	LWTUNNEL_IP_OPTS_ERSPAN = 3,
	__LWTUNNEL_IP_OPTS_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_GENEVE_UNSPEC = 0,
	LWTUNNEL_IP_OPT_GENEVE_CLASS = 1,
	LWTUNNEL_IP_OPT_GENEVE_TYPE = 2,
	LWTUNNEL_IP_OPT_GENEVE_DATA = 3,
	__LWTUNNEL_IP_OPT_GENEVE_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_VXLAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_VXLAN_GBP = 1,
	__LWTUNNEL_IP_OPT_VXLAN_MAX = 2,
};

enum {
	LWTUNNEL_IP_OPT_ERSPAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_ERSPAN_VER = 1,
	LWTUNNEL_IP_OPT_ERSPAN_INDEX = 2,
	LWTUNNEL_IP_OPT_ERSPAN_DIR = 3,
	LWTUNNEL_IP_OPT_ERSPAN_HWID = 4,
	__LWTUNNEL_IP_OPT_ERSPAN_MAX = 5,
};

struct ip6_tnl_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi6 *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
};

struct geneve_opt {
	__be16 opt_class;
	u8 type;
	u8 length: 5;
	u8 r3: 1;
	u8 r2: 1;
	u8 r1: 1;
	u8 opt_data[0];
};

struct vxlan_metadata {
	u32 gbp;
};

struct erspan_md2 {
	__be32 timestamp;
	__be16 sgt;
	__u8 hwid_upper: 2;
	__u8 ft: 5;
	__u8 p: 1;
	__u8 o: 1;
	__u8 gra: 2;
	__u8 dir: 1;
	__u8 hwid: 4;
};

struct erspan_metadata {
	int version;
	union {
		__be32 index;
		struct erspan_md2 md2;
	} u;
};

struct nhmsg {
	unsigned char nh_family;
	unsigned char nh_scope;
	unsigned char nh_protocol;
	unsigned char resvd;
	unsigned int nh_flags;
};

struct nexthop_grp {
	__u32 id;
	__u8 weight;
	__u8 resvd1;
	__u16 resvd2;
};

enum {
	NEXTHOP_GRP_TYPE_MPATH = 0,
	NEXTHOP_GRP_TYPE_RES = 1,
	__NEXTHOP_GRP_TYPE_MAX = 2,
};

enum {
	NHA_UNSPEC = 0,
	NHA_ID = 1,
	NHA_GROUP = 2,
	NHA_GROUP_TYPE = 3,
	NHA_BLACKHOLE = 4,
	NHA_OIF = 5,
	NHA_GATEWAY = 6,
	NHA_ENCAP_TYPE = 7,
	NHA_ENCAP = 8,
	NHA_GROUPS = 9,
	NHA_MASTER = 10,
	NHA_FDB = 11,
	NHA_RES_GROUP = 12,
	NHA_RES_BUCKET = 13,
	__NHA_MAX = 14,
};

enum {
	NHA_RES_GROUP_UNSPEC = 0,
	NHA_RES_GROUP_PAD = 0,
	NHA_RES_GROUP_BUCKETS = 1,
	NHA_RES_GROUP_IDLE_TIMER = 2,
	NHA_RES_GROUP_UNBALANCED_TIMER = 3,
	NHA_RES_GROUP_UNBALANCED_TIME = 4,
	__NHA_RES_GROUP_MAX = 5,
};

enum {
	NHA_RES_BUCKET_UNSPEC = 0,
	NHA_RES_BUCKET_PAD = 0,
	NHA_RES_BUCKET_INDEX = 1,
	NHA_RES_BUCKET_IDLE_TIME = 2,
	NHA_RES_BUCKET_NH_ID = 3,
	__NHA_RES_BUCKET_MAX = 4,
};

struct nh_config {
	u32 nh_id;
	u8 nh_family;
	u8 nh_protocol;
	u8 nh_blackhole;
	u8 nh_fdb;
	u32 nh_flags;
	int nh_ifindex;
	struct net_device *dev;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} gw;
	struct nlattr *nh_grp;
	u16 nh_grp_type;
	u16 nh_grp_res_num_buckets;
	long unsigned int nh_grp_res_idle_timer;
	long unsigned int nh_grp_res_unbalanced_timer;
	bool nh_grp_res_has_num_buckets;
	bool nh_grp_res_has_idle_timer;
	bool nh_grp_res_has_unbalanced_timer;
	struct nlattr *nh_encap;
	u16 nh_encap_type;
	u32 nlflags;
	struct nl_info nlinfo;
};

enum nexthop_event_type {
	NEXTHOP_EVENT_DEL = 0,
	NEXTHOP_EVENT_REPLACE = 1,
	NEXTHOP_EVENT_RES_TABLE_PRE_REPLACE = 2,
	NEXTHOP_EVENT_BUCKET_REPLACE = 3,
};

enum nh_notifier_info_type {
	NH_NOTIFIER_INFO_TYPE_SINGLE = 0,
	NH_NOTIFIER_INFO_TYPE_GRP = 1,
	NH_NOTIFIER_INFO_TYPE_RES_TABLE = 2,
	NH_NOTIFIER_INFO_TYPE_RES_BUCKET = 3,
};

struct nh_notifier_single_info {
	struct net_device *dev;
	u8 gw_family;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	};
	u8 is_reject: 1;
	u8 is_fdb: 1;
	u8 has_encap: 1;
};

struct nh_notifier_grp_entry_info {
	u8 weight;
	u32 id;
	struct nh_notifier_single_info nh;
};

struct nh_notifier_grp_info {
	u16 num_nh;
	bool is_fdb;
	struct nh_notifier_grp_entry_info nh_entries[0];
};

struct nh_notifier_res_bucket_info {
	u16 bucket_index;
	unsigned int idle_timer_ms;
	bool force;
	struct nh_notifier_single_info old_nh;
	struct nh_notifier_single_info new_nh;
};

struct nh_notifier_res_table_info {
	u16 num_nh_buckets;
	struct nh_notifier_single_info nhs[0];
};

struct nh_notifier_info {
	struct net *net;
	struct netlink_ext_ack *extack;
	u32 id;
	enum nh_notifier_info_type type;
	union {
		struct nh_notifier_single_info *nh;
		struct nh_notifier_grp_info *nh_grp;
		struct nh_notifier_res_table_info *nh_res_table;
		struct nh_notifier_res_bucket_info *nh_res_bucket;
	};
};

struct nh_dump_filter {
	u32 nh_id;
	int dev_idx;
	int master_idx;
	bool group_filter;
	bool fdb_filter;
	u32 res_bucket_nh_id;
};

struct rtm_dump_nh_ctx {
	u32 idx;
};

struct rtm_dump_res_bucket_ctx {
	struct rtm_dump_nh_ctx nh;
	u16 bucket_index;
	u32 done_nh_idx;
};

struct rtm_dump_nexthop_bucket_data {
	struct rtm_dump_res_bucket_ctx *ctx;
	struct nh_dump_filter filter;
};

struct snmp_mib {
	const char *name;
	int entry;
};

struct fib4_rule {
	struct fib_rule common;
	u8 dst_len;
	u8 src_len;
	u8 tos;
	__be32 src;
	__be32 srcmask;
	__be32 dst;
	__be32 dstmask;
	u32 tclassid;
};

enum {
	PIM_TYPE_HELLO = 0,
	PIM_TYPE_REGISTER = 1,
	PIM_TYPE_REGISTER_STOP = 2,
	PIM_TYPE_JOIN_PRUNE = 3,
	PIM_TYPE_BOOTSTRAP = 4,
	PIM_TYPE_ASSERT = 5,
	PIM_TYPE_GRAFT = 6,
	PIM_TYPE_GRAFT_ACK = 7,
	PIM_TYPE_CANDIDATE_RP_ADV = 8,
};

struct pimreghdr {
	__u8 type;
	__u8 reserved;
	__be16 csum;
	__be32 flags;
};

typedef short unsigned int vifi_t;

struct vifctl {
	vifi_t vifc_vifi;
	unsigned char vifc_flags;
	unsigned char vifc_threshold;
	unsigned int vifc_rate_limit;
	union {
		struct in_addr vifc_lcl_addr;
		int vifc_lcl_ifindex;
	};
	struct in_addr vifc_rmt_addr;
};

struct mfcctl {
	struct in_addr mfcc_origin;
	struct in_addr mfcc_mcastgrp;
	vifi_t mfcc_parent;
	unsigned char mfcc_ttls[32];
	unsigned int mfcc_pkt_cnt;
	unsigned int mfcc_byte_cnt;
	unsigned int mfcc_wrong_if;
	int mfcc_expire;
};

struct sioc_sg_req {
	struct in_addr src;
	struct in_addr grp;
	long unsigned int pktcnt;
	long unsigned int bytecnt;
	long unsigned int wrong_if;
};

struct sioc_vif_req {
	vifi_t vifi;
	long unsigned int icount;
	long unsigned int ocount;
	long unsigned int ibytes;
	long unsigned int obytes;
};

struct igmpmsg {
	__u32 unused1;
	__u32 unused2;
	unsigned char im_msgtype;
	unsigned char im_mbz;
	unsigned char im_vif;
	unsigned char im_vif_hi;
	struct in_addr im_src;
	struct in_addr im_dst;
};

enum {
	IPMRA_TABLE_UNSPEC = 0,
	IPMRA_TABLE_ID = 1,
	IPMRA_TABLE_CACHE_RES_QUEUE_LEN = 2,
	IPMRA_TABLE_MROUTE_REG_VIF_NUM = 3,
	IPMRA_TABLE_MROUTE_DO_ASSERT = 4,
	IPMRA_TABLE_MROUTE_DO_PIM = 5,
	IPMRA_TABLE_VIFS = 6,
	IPMRA_TABLE_MROUTE_DO_WRVIFWHOLE = 7,
	__IPMRA_TABLE_MAX = 8,
};

enum {
	IPMRA_VIF_UNSPEC = 0,
	IPMRA_VIF = 1,
	__IPMRA_VIF_MAX = 2,
};

enum {
	IPMRA_VIFA_UNSPEC = 0,
	IPMRA_VIFA_IFINDEX = 1,
	IPMRA_VIFA_VIF_ID = 2,
	IPMRA_VIFA_FLAGS = 3,
	IPMRA_VIFA_BYTES_IN = 4,
	IPMRA_VIFA_BYTES_OUT = 5,
	IPMRA_VIFA_PACKETS_IN = 6,
	IPMRA_VIFA_PACKETS_OUT = 7,
	IPMRA_VIFA_LOCAL_ADDR = 8,
	IPMRA_VIFA_REMOTE_ADDR = 9,
	IPMRA_VIFA_PAD = 10,
	__IPMRA_VIFA_MAX = 11,
};

enum {
	IPMRA_CREPORT_UNSPEC = 0,
	IPMRA_CREPORT_MSGTYPE = 1,
	IPMRA_CREPORT_VIF_ID = 2,
	IPMRA_CREPORT_SRC_ADDR = 3,
	IPMRA_CREPORT_DST_ADDR = 4,
	IPMRA_CREPORT_PKT = 5,
	IPMRA_CREPORT_TABLE = 6,
	__IPMRA_CREPORT_MAX = 7,
};

struct vif_device {
	struct net_device *dev;
	long unsigned int bytes_in;
	long unsigned int bytes_out;
	long unsigned int pkt_in;
	long unsigned int pkt_out;
	long unsigned int rate_limit;
	unsigned char threshold;
	short unsigned int flags;
	int link;
	struct netdev_phys_item_id dev_parent_id;
	__be32 local;
	__be32 remote;
};

struct vif_entry_notifier_info {
	struct fib_notifier_info info;
	struct net_device *dev;
	short unsigned int vif_index;
	short unsigned int vif_flags;
	u32 tb_id;
};

enum {
	MFC_STATIC = 1,
	MFC_OFFLOAD = 2,
};

struct mr_mfc {
	struct rhlist_head mnode;
	short unsigned int mfc_parent;
	int mfc_flags;
	union {
		struct {
			long unsigned int expires;
			struct sk_buff_head unresolved;
		} unres;
		struct {
			long unsigned int last_assert;
			int minvif;
			int maxvif;
			long unsigned int bytes;
			long unsigned int pkt;
			long unsigned int wrong_if;
			long unsigned int lastuse;
			unsigned char ttls[32];
			refcount_t refcount;
		} res;
	} mfc_un;
	struct list_head list;
	struct callback_head rcu;
	void (*free)(struct callback_head *);
};

struct mfc_entry_notifier_info {
	struct fib_notifier_info info;
	struct mr_mfc *mfc;
	u32 tb_id;
};

struct mr_table_ops {
	const struct rhashtable_params *rht_params;
	void *cmparg_any;
};

struct mr_table {
	struct list_head list;
	possible_net_t net;
	struct mr_table_ops ops;
	u32 id;
	struct sock *mroute_sk;
	struct timer_list ipmr_expire_timer;
	struct list_head mfc_unres_queue;
	struct vif_device vif_table[32];
	struct rhltable mfc_hash;
	struct list_head mfc_cache_list;
	int maxvif;
	atomic_t cache_resolve_queue_len;
	bool mroute_do_assert;
	bool mroute_do_pim;
	bool mroute_do_wrvifwhole;
	int mroute_reg_vif_num;
};

struct mr_vif_iter {
	struct seq_net_private p;
	struct mr_table *mrt;
	int ct;
};

struct mr_mfc_iter {
	struct seq_net_private p;
	struct mr_table *mrt;
	struct list_head *cache;
	spinlock_t *lock;
};

struct mfc_cache_cmp_arg {
	__be32 mfc_mcastgrp;
	__be32 mfc_origin;
};

struct mfc_cache {
	struct mr_mfc _c;
	union {
		struct {
			__be32 mfc_mcastgrp;
			__be32 mfc_origin;
		};
		struct mfc_cache_cmp_arg cmparg;
	};
};

struct ipmr_result {
	struct mr_table *mrt;
};

struct compat_sioc_sg_req {
	struct in_addr src;
	struct in_addr grp;
	compat_ulong_t pktcnt;
	compat_ulong_t bytecnt;
	compat_ulong_t wrong_if;
};

struct compat_sioc_vif_req {
	vifi_t vifi;
	compat_ulong_t icount;
	compat_ulong_t ocount;
	compat_ulong_t ibytes;
	compat_ulong_t obytes;
};

struct rta_mfc_stats {
	__u64 mfcs_packets;
	__u64 mfcs_bytes;
	__u64 mfcs_wrong_if;
};

struct bictcp {
	u32 cnt;
	u32 last_max_cwnd;
	u32 last_cwnd;
	u32 last_time;
	u32 bic_origin_point;
	u32 bic_K;
	u32 delay_min;
	u32 epoch_start;
	u32 ack_cnt;
	u32 tcp_cwnd;
	u16 unused;
	u8 sample_cnt;
	u8 found;
	u32 round_start;
	u32 end_seq;
	u32 last_ack;
	u32 curr_rtt;
};

struct tls_rec {
	struct list_head list;
	int tx_ready;
	int tx_flags;
	struct sk_msg msg_plaintext;
	struct sk_msg msg_encrypted;
	struct scatterlist sg_aead_in[2];
	struct scatterlist sg_aead_out[2];
	char content_type;
	struct scatterlist sg_content_type;
	char aad_space[13];
	u8 iv_data[16];
	long: 24;
	long: 64;
	long: 64;
	struct aead_request aead_req;
	u8 aead_req_ctx[0];
};

struct tx_work {
	struct delayed_work work;
	struct sock *sk;
};

struct tls_sw_context_tx {
	struct crypto_aead *aead_send;
	struct crypto_wait async_wait;
	struct tx_work tx_work;
	struct tls_rec *open_rec;
	struct list_head tx_list;
	atomic_t encrypt_pending;
	spinlock_t encrypt_compl_lock;
	int async_notify;
	u8 async_capable: 1;
	long unsigned int tx_bitmask;
};

enum {
	TCP_BPF_IPV4 = 0,
	TCP_BPF_IPV6 = 1,
	TCP_BPF_NUM_PROTS = 2,
};

enum {
	TCP_BPF_BASE = 0,
	TCP_BPF_TX = 1,
	TCP_BPF_NUM_CFGS = 2,
};

enum {
	UDP_BPF_IPV4 = 0,
	UDP_BPF_IPV6 = 1,
	UDP_BPF_NUM_PROTS = 2,
};

struct cipso_v4_map_cache_bkt {
	spinlock_t lock;
	u32 size;
	struct list_head list;
};

struct cipso_v4_map_cache_entry {
	u32 hash;
	unsigned char *key;
	size_t key_len;
	struct netlbl_lsm_cache *lsm_data;
	u32 activity;
	struct list_head list;
};

struct xfrm_policy_afinfo {
	struct dst_ops *dst_ops;
	struct dst_entry * (*dst_lookup)(struct net *, int, int, const xfrm_address_t *, const xfrm_address_t *, u32);
	int (*get_saddr)(struct net *, int, xfrm_address_t *, xfrm_address_t *, u32);
	int (*fill_dst)(struct xfrm_dst *, struct net_device *, const struct flowi *);
	struct dst_entry * (*blackhole_route)(struct net *, struct dst_entry *);
};

struct xfrm_state_afinfo {
	u8 family;
	u8 proto;
	const struct xfrm_type_offload *type_offload_esp;
	const struct xfrm_type *type_esp;
	const struct xfrm_type *type_ipip;
	const struct xfrm_type *type_ipip6;
	const struct xfrm_type *type_comp;
	const struct xfrm_type *type_ah;
	const struct xfrm_type *type_routing;
	const struct xfrm_type *type_dstopts;
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*transport_finish)(struct sk_buff *, int);
	void (*local_error)(struct sk_buff *, u32);
};

struct ip_tunnel;

struct ip6_tnl;

struct xfrm_tunnel_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	union {
		struct ip_tunnel *ip4;
		struct ip6_tnl *ip6;
	} tunnel;
};

struct xfrm_mode_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	__be16 id;
	__be16 frag_off;
	u8 ihl;
	u8 tos;
	u8 ttl;
	u8 protocol;
	u8 optlen;
	u8 flow_lbl[3];
};

struct xfrm_spi_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	unsigned int daddroff;
	unsigned int family;
	__be32 seq;
};

struct xfrm_input_afinfo {
	u8 family;
	bool is_ipip;
	int (*callback)(struct sk_buff *, u8, int);
};

struct xfrm4_protocol {
	int (*handler)(struct sk_buff *);
	int (*input_handler)(struct sk_buff *, int, __be32, int);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, u32);
	struct xfrm4_protocol *next;
	int priority;
};

typedef u64 (*btf_bpf_tcp_send_ack)(struct tcp_sock *, u32);

enum {
	XFRM_STATE_VOID = 0,
	XFRM_STATE_ACQ = 1,
	XFRM_STATE_VALID = 2,
	XFRM_STATE_ERROR = 3,
	XFRM_STATE_EXPIRED = 4,
	XFRM_STATE_DEAD = 5,
};

struct xfrm_if;

struct xfrm_if_cb {
	struct xfrm_if * (*decode_session)(struct sk_buff *, short unsigned int);
};

struct xfrm_if_parms {
	int link;
	u32 if_id;
};

struct xfrm_if {
	struct xfrm_if *next;
	struct net_device *dev;
	struct net *net;
	struct xfrm_if_parms p;
	struct gro_cells gro_cells;
};

struct xfrm_policy_walk {
	struct xfrm_policy_walk_entry walk;
	u8 type;
	u32 seq;
};

struct xfrmk_spdinfo {
	u32 incnt;
	u32 outcnt;
	u32 fwdcnt;
	u32 inscnt;
	u32 outscnt;
	u32 fwdscnt;
	u32 spdhcnt;
	u32 spdhmcnt;
};

struct ip6_mh {
	__u8 ip6mh_proto;
	__u8 ip6mh_hdrlen;
	__u8 ip6mh_type;
	__u8 ip6mh_reserved;
	__u16 ip6mh_cksum;
	__u8 data[0];
};

struct xfrm_flo {
	struct dst_entry *dst_orig;
	u8 flags;
};

struct xfrm_pol_inexact_node {
	struct rb_node node;
	union {
		xfrm_address_t addr;
		struct callback_head rcu;
	};
	u8 prefixlen;
	struct rb_root root;
	struct hlist_head hhead;
};

struct xfrm_pol_inexact_key {
	possible_net_t net;
	u32 if_id;
	u16 family;
	u8 dir;
	u8 type;
};

struct xfrm_pol_inexact_bin {
	struct xfrm_pol_inexact_key k;
	struct rhash_head head;
	struct hlist_head hhead;
	seqcount_spinlock_t count;
	struct rb_root root_d;
	struct rb_root root_s;
	struct list_head inexact_bins;
	struct callback_head rcu;
};

enum xfrm_pol_inexact_candidate_type {
	XFRM_POL_CAND_BOTH = 0,
	XFRM_POL_CAND_SADDR = 1,
	XFRM_POL_CAND_DADDR = 2,
	XFRM_POL_CAND_ANY = 3,
	XFRM_POL_CAND_MAX = 4,
};

struct xfrm_pol_inexact_candidates {
	struct hlist_head *res[4];
};

enum xfrm_ae_ftype_t {
	XFRM_AE_UNSPEC = 0,
	XFRM_AE_RTHR = 1,
	XFRM_AE_RVAL = 2,
	XFRM_AE_LVAL = 4,
	XFRM_AE_ETHR = 8,
	XFRM_AE_CR = 16,
	XFRM_AE_CE = 32,
	XFRM_AE_CU = 64,
	__XFRM_AE_MAX = 65,
};

enum xfrm_nlgroups {
	XFRMNLGRP_NONE = 0,
	XFRMNLGRP_ACQUIRE = 1,
	XFRMNLGRP_EXPIRE = 2,
	XFRMNLGRP_SA = 3,
	XFRMNLGRP_POLICY = 4,
	XFRMNLGRP_AEVENTS = 5,
	XFRMNLGRP_REPORT = 6,
	XFRMNLGRP_MIGRATE = 7,
	XFRMNLGRP_MAPPING = 8,
	__XFRMNLGRP_MAX = 9,
};

enum {
	XFRM_MODE_FLAG_TUNNEL = 1,
};

struct km_event {
	union {
		u32 hard;
		u32 proto;
		u32 byid;
		u32 aevent;
		u32 type;
	} data;
	u32 seq;
	u32 portid;
	u32 event;
	struct net *net;
};

struct xfrm_kmaddress {
	xfrm_address_t local;
	xfrm_address_t remote;
	u32 reserved;
	u16 family;
};

struct xfrm_migrate {
	xfrm_address_t old_daddr;
	xfrm_address_t old_saddr;
	xfrm_address_t new_daddr;
	xfrm_address_t new_saddr;
	u8 proto;
	u8 mode;
	u16 reserved;
	u32 reqid;
	u16 old_family;
	u16 new_family;
};

struct xfrm_mgr {
	struct list_head list;
	int (*notify)(struct xfrm_state *, const struct km_event *);
	int (*acquire)(struct xfrm_state *, struct xfrm_tmpl *, struct xfrm_policy *);
	struct xfrm_policy * (*compile_policy)(struct sock *, int, u8 *, int, int *);
	int (*new_mapping)(struct xfrm_state *, xfrm_address_t *, __be16);
	int (*notify_policy)(struct xfrm_policy *, int, const struct km_event *);
	int (*report)(struct net *, u8, struct xfrm_selector *, xfrm_address_t *);
	int (*migrate)(const struct xfrm_selector *, u8, u8, const struct xfrm_migrate *, int, const struct xfrm_kmaddress *, const struct xfrm_encap_tmpl *);
	bool (*is_alive)(const struct km_event *);
};

struct xfrmk_sadinfo {
	u32 sadhcnt;
	u32 sadhmcnt;
	u32 sadcnt;
};

struct xfrm_translator {
	int (*alloc_compat)(struct sk_buff *, const struct nlmsghdr *);
	struct nlmsghdr * (*rcv_msg_compat)(const struct nlmsghdr *, int, const struct nla_policy *, struct netlink_ext_ack *);
	int (*xlate_user_policy_sockptr)(u8 **, int);
	struct module *owner;
};

struct ip_beet_phdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 padlen;
	__u8 reserved;
};

struct ip_tunnel_6rd_parm {
	struct in6_addr prefix;
	__be32 relay_prefix;
	u16 prefixlen;
	u16 relay_prefixlen;
};

struct ip_tunnel_fan {
	struct list_head fan_maps;
};

struct ip_tunnel_prl_entry;

struct ip_tunnel {
	struct ip_tunnel *next;
	struct hlist_node hash_node;
	struct net_device *dev;
	struct net *net;
	long unsigned int err_time;
	int err_count;
	u32 i_seqno;
	u32 o_seqno;
	int tun_hlen;
	u32 index;
	u8 erspan_ver;
	u8 dir;
	u16 hwid;
	struct dst_cache dst_cache;
	struct ip_tunnel_parm parms;
	int mlink;
	int encap_hlen;
	int hlen;
	struct ip_tunnel_encap encap;
	struct ip_tunnel_6rd_parm ip6rd;
	struct ip_tunnel_prl_entry *prl;
	unsigned int prl_count;
	struct ip_tunnel_fan fan;
	unsigned int ip_tnl_net_id;
	struct gro_cells gro_cells;
	__u32 fwmark;
	bool collect_md;
	bool ignore_df;
};

struct __ip6_tnl_parm {
	char name[16];
	int link;
	__u8 proto;
	__u8 encap_limit;
	__u8 hop_limit;
	bool collect_md;
	__be32 flowinfo;
	__u32 flags;
	struct in6_addr laddr;
	struct in6_addr raddr;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	__u32 fwmark;
	__u32 index;
	__u8 erspan_ver;
	__u8 dir;
	__u16 hwid;
};

struct ip6_tnl {
	struct ip6_tnl *next;
	struct net_device *dev;
	struct net *net;
	struct __ip6_tnl_parm parms;
	struct flowi fl;
	struct dst_cache dst_cache;
	struct gro_cells gro_cells;
	int err_count;
	long unsigned int err_time;
	__u32 i_seqno;
	__u32 o_seqno;
	int hlen;
	int tun_hlen;
	int encap_hlen;
	struct ip_tunnel_encap encap;
	int mlink;
};

struct xfrm_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	union {
		struct {
			__u32 low;
			__u32 hi;
		} output;
		struct {
			__be32 low;
			__be32 hi;
		} input;
	} seq;
};

struct ip_tunnel_prl_entry {
	struct ip_tunnel_prl_entry *next;
	__be32 addr;
	u16 flags;
	struct callback_head callback_head;
};

struct xfrm_trans_tasklet {
	struct tasklet_struct tasklet;
	struct sk_buff_head queue;
};

struct xfrm_trans_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	int (*finish)(struct net *, struct sock *, struct sk_buff *);
	struct net *net;
};

struct xfrm_user_offload {
	int ifindex;
	__u8 flags;
};

struct espintcp_msg {
	struct sk_buff *skb;
	struct sk_msg skmsg;
	int offset;
	int len;
};

struct espintcp_ctx {
	struct strparser strp;
	struct sk_buff_head ike_queue;
	struct sk_buff_head out_queue;
	struct espintcp_msg partial;
	void (*saved_data_ready)(struct sock *);
	void (*saved_write_space)(struct sock *);
	void (*saved_destruct)(struct sock *);
	struct work_struct work;
	bool tx_running;
};

struct unix_stream_read_state {
	int (*recv_actor)(struct sk_buff *, int, int, struct unix_stream_read_state *);
	struct socket *socket;
	struct msghdr *msg;
	struct pipe_inode_info *pipe;
	size_t size;
	int flags;
	unsigned int splice_flags;
};

enum flowlabel_reflect {
	FLOWLABEL_REFLECT_ESTABLISHED = 1,
	FLOWLABEL_REFLECT_TCP_RESET = 2,
	FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES = 4,
};

struct in6_rtmsg {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	__u32 rtmsg_type;
	__u16 rtmsg_dst_len;
	__u16 rtmsg_src_len;
	__u32 rtmsg_metric;
	long unsigned int rtmsg_info;
	__u32 rtmsg_flags;
	int rtmsg_ifindex;
};

struct compat_in6_rtmsg {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	u32 rtmsg_type;
	u16 rtmsg_dst_len;
	u16 rtmsg_src_len;
	u32 rtmsg_metric;
	u32 rtmsg_info;
	u32 rtmsg_flags;
	s32 rtmsg_ifindex;
};

struct ac6_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct ip6_fraglist_iter {
	struct ipv6hdr *tmp_hdr;
	struct sk_buff *frag;
	int offset;
	unsigned int hlen;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_frag_state {
	u8 *prevhdr;
	unsigned int hlen;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	int hroom;
	int troom;
	__be32 frag_id;
	u8 nexthdr;
};

struct ipcm6_cookie {
	struct sockcm_cookie sockc;
	__s16 hlimit;
	__s16 tclass;
	__s8 dontfrag;
	struct ipv6_txoptions *opt;
	__u16 gso_size;
};

enum {
	IFLA_INET6_UNSPEC = 0,
	IFLA_INET6_FLAGS = 1,
	IFLA_INET6_CONF = 2,
	IFLA_INET6_STATS = 3,
	IFLA_INET6_MCAST = 4,
	IFLA_INET6_CACHEINFO = 5,
	IFLA_INET6_ICMP6STATS = 6,
	IFLA_INET6_TOKEN = 7,
	IFLA_INET6_ADDR_GEN_MODE = 8,
	__IFLA_INET6_MAX = 9,
};

enum in6_addr_gen_mode {
	IN6_ADDR_GEN_MODE_EUI64 = 0,
	IN6_ADDR_GEN_MODE_NONE = 1,
	IN6_ADDR_GEN_MODE_STABLE_PRIVACY = 2,
	IN6_ADDR_GEN_MODE_RANDOM = 3,
};

struct ifla_cacheinfo {
	__u32 max_reasm_len;
	__u32 tstamp;
	__u32 reachable_time;
	__u32 retrans_time;
};

struct prefixmsg {
	unsigned char prefix_family;
	unsigned char prefix_pad1;
	short unsigned int prefix_pad2;
	int prefix_ifindex;
	unsigned char prefix_type;
	unsigned char prefix_len;
	unsigned char prefix_flags;
	unsigned char prefix_pad3;
};

enum {
	PREFIX_UNSPEC = 0,
	PREFIX_ADDRESS = 1,
	PREFIX_CACHEINFO = 2,
	__PREFIX_MAX = 3,
};

struct prefix_cacheinfo {
	__u32 preferred_time;
	__u32 valid_time;
};

struct in6_ifreq {
	struct in6_addr ifr6_addr;
	__u32 ifr6_prefixlen;
	int ifr6_ifindex;
};

enum {
	DEVCONF_FORWARDING = 0,
	DEVCONF_HOPLIMIT = 1,
	DEVCONF_MTU6 = 2,
	DEVCONF_ACCEPT_RA = 3,
	DEVCONF_ACCEPT_REDIRECTS = 4,
	DEVCONF_AUTOCONF = 5,
	DEVCONF_DAD_TRANSMITS = 6,
	DEVCONF_RTR_SOLICITS = 7,
	DEVCONF_RTR_SOLICIT_INTERVAL = 8,
	DEVCONF_RTR_SOLICIT_DELAY = 9,
	DEVCONF_USE_TEMPADDR = 10,
	DEVCONF_TEMP_VALID_LFT = 11,
	DEVCONF_TEMP_PREFERED_LFT = 12,
	DEVCONF_REGEN_MAX_RETRY = 13,
	DEVCONF_MAX_DESYNC_FACTOR = 14,
	DEVCONF_MAX_ADDRESSES = 15,
	DEVCONF_FORCE_MLD_VERSION = 16,
	DEVCONF_ACCEPT_RA_DEFRTR = 17,
	DEVCONF_ACCEPT_RA_PINFO = 18,
	DEVCONF_ACCEPT_RA_RTR_PREF = 19,
	DEVCONF_RTR_PROBE_INTERVAL = 20,
	DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN = 21,
	DEVCONF_PROXY_NDP = 22,
	DEVCONF_OPTIMISTIC_DAD = 23,
	DEVCONF_ACCEPT_SOURCE_ROUTE = 24,
	DEVCONF_MC_FORWARDING = 25,
	DEVCONF_DISABLE_IPV6 = 26,
	DEVCONF_ACCEPT_DAD = 27,
	DEVCONF_FORCE_TLLAO = 28,
	DEVCONF_NDISC_NOTIFY = 29,
	DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL = 30,
	DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL = 31,
	DEVCONF_SUPPRESS_FRAG_NDISC = 32,
	DEVCONF_ACCEPT_RA_FROM_LOCAL = 33,
	DEVCONF_USE_OPTIMISTIC = 34,
	DEVCONF_ACCEPT_RA_MTU = 35,
	DEVCONF_STABLE_SECRET = 36,
	DEVCONF_USE_OIF_ADDRS_ONLY = 37,
	DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT = 38,
	DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 39,
	DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 40,
	DEVCONF_DROP_UNSOLICITED_NA = 41,
	DEVCONF_KEEP_ADDR_ON_DOWN = 42,
	DEVCONF_RTR_SOLICIT_MAX_INTERVAL = 43,
	DEVCONF_SEG6_ENABLED = 44,
	DEVCONF_SEG6_REQUIRE_HMAC = 45,
	DEVCONF_ENHANCED_DAD = 46,
	DEVCONF_ADDR_GEN_MODE = 47,
	DEVCONF_DISABLE_POLICY = 48,
	DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN = 49,
	DEVCONF_NDISC_TCLASS = 50,
	DEVCONF_RPL_SEG_ENABLED = 51,
	DEVCONF_RA_DEFRTR_METRIC = 52,
	DEVCONF_MAX = 53,
};

enum {
	INET6_IFADDR_STATE_PREDAD = 0,
	INET6_IFADDR_STATE_DAD = 1,
	INET6_IFADDR_STATE_POSTDAD = 2,
	INET6_IFADDR_STATE_ERRDAD = 3,
	INET6_IFADDR_STATE_DEAD = 4,
};

union fwnet_hwaddr {
	u8 u[16];
	struct {
		__be64 uniq_id;
		u8 max_rec;
		u8 sspd;
		__be16 fifo_hi;
		__be32 fifo_lo;
	} uc;
};

struct in6_validator_info {
	struct in6_addr i6vi_addr;
	struct inet6_dev *i6vi_dev;
	struct netlink_ext_ack *extack;
};

struct ifa6_config {
	const struct in6_addr *pfx;
	unsigned int plen;
	const struct in6_addr *peer_pfx;
	u32 rt_priority;
	u32 ifa_flags;
	u32 preferred_lft;
	u32 valid_lft;
	u16 scope;
};

enum cleanup_prefix_rt_t {
	CLEANUP_PREFIX_RT_NOP = 0,
	CLEANUP_PREFIX_RT_DEL = 1,
	CLEANUP_PREFIX_RT_EXPIRE = 2,
};

enum {
	IPV6_SADDR_RULE_INIT = 0,
	IPV6_SADDR_RULE_LOCAL = 1,
	IPV6_SADDR_RULE_SCOPE = 2,
	IPV6_SADDR_RULE_PREFERRED = 3,
	IPV6_SADDR_RULE_OIF = 4,
	IPV6_SADDR_RULE_LABEL = 5,
	IPV6_SADDR_RULE_PRIVACY = 6,
	IPV6_SADDR_RULE_ORCHID = 7,
	IPV6_SADDR_RULE_PREFIX = 8,
	IPV6_SADDR_RULE_MAX = 9,
};

struct ipv6_saddr_score {
	int rule;
	int addr_type;
	struct inet6_ifaddr *ifa;
	long unsigned int scorebits[1];
	int scopedist;
	int matchlen;
};

struct ipv6_saddr_dst {
	const struct in6_addr *addr;
	int ifindex;
	int scope;
	int label;
	unsigned int prefs;
};

struct if6_iter_state {
	struct seq_net_private p;
	int bucket;
	int offset;
};

enum addr_type_t {
	UNICAST_ADDR = 0,
	MULTICAST_ADDR = 1,
	ANYCAST_ADDR = 2,
};

struct inet6_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
	enum addr_type_t type;
};

enum {
	DAD_PROCESS = 0,
	DAD_BEGIN = 1,
	DAD_ABORT = 2,
};

struct ifaddrlblmsg {
	__u8 ifal_family;
	__u8 __ifal_reserved;
	__u8 ifal_prefixlen;
	__u8 ifal_flags;
	__u32 ifal_index;
	__u32 ifal_seq;
};

enum {
	IFAL_ADDRESS = 1,
	IFAL_LABEL = 2,
	__IFAL_MAX = 3,
};

struct ip6addrlbl_entry {
	struct in6_addr prefix;
	int prefixlen;
	int ifindex;
	int addrtype;
	u32 label;
	struct hlist_node list;
	struct callback_head rcu;
};

struct ip6addrlbl_init_table {
	const struct in6_addr *prefix;
	int prefixlen;
	u32 label;
};

struct rd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	struct in6_addr dest;
	__u8 opt[0];
};

struct fib6_gc_args {
	int timeout;
	int more;
};

struct rt6_exception {
	struct hlist_node hlist;
	struct rt6_info *rt6i;
	long unsigned int stamp;
	struct callback_head rcu;
};

struct route_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	__u8 reserved_l: 3;
	__u8 route_pref: 2;
	__u8 reserved_h: 3;
	__be32 lifetime;
	__u8 prefix[0];
};

struct rt6_rtnl_dump_arg {
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct net *net;
	struct fib_dump_filter filter;
};

struct netevent_redirect {
	struct dst_entry *old;
	struct dst_entry *new;
	struct neighbour *neigh;
	const void *daddr;
};

struct trace_event_raw_fib6_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[16];
	__u8 dst[16];
	u16 sport;
	u16 dport;
	u8 proto;
	u8 rt_type;
	u32 __data_loc_name;
	__u8 gw[16];
	char __data[0];
};

struct trace_event_data_offsets_fib6_table_lookup {
	u32 name;
};

typedef void (*btf_trace_fib6_table_lookup)(void *, const struct net *, const struct fib6_result *, struct fib6_table *, const struct flowi6 *);

enum rt6_nud_state {
	RT6_NUD_FAIL_HARD = 4294967293,
	RT6_NUD_FAIL_PROBE = 4294967294,
	RT6_NUD_FAIL_DO_RR = 4294967295,
	RT6_NUD_SUCCEED = 1,
};

struct fib6_nh_dm_arg {
	struct net *net;
	const struct in6_addr *saddr;
	int oif;
	int flags;
	struct fib6_nh *nh;
};

struct __rt6_probe_work {
	struct work_struct work;
	struct in6_addr target;
	struct net_device *dev;
};

struct fib6_nh_frl_arg {
	u32 flags;
	int oif;
	int strict;
	int *mpri;
	bool *do_rr;
	struct fib6_nh *nh;
};

struct fib6_nh_excptn_arg {
	struct rt6_info *rt;
	int plen;
};

struct fib6_nh_match_arg {
	const struct net_device *dev;
	const struct in6_addr *gw;
	struct fib6_nh *match;
};

struct fib6_nh_age_excptn_arg {
	struct fib6_gc_args *gc_args;
	long unsigned int now;
};

struct fib6_nh_rd_arg {
	struct fib6_result *res;
	struct flowi6 *fl6;
	const struct in6_addr *gw;
	struct rt6_info **ret;
};

struct ip6rd_flowi {
	struct flowi6 fl6;
	struct in6_addr gateway;
};

struct fib6_nh_del_cached_rt_arg {
	struct fib6_config *cfg;
	struct fib6_info *f6i;
};

struct arg_dev_net_ip {
	struct net_device *dev;
	struct net *net;
	struct in6_addr *addr;
};

struct arg_netdev_event {
	const struct net_device *dev;
	union {
		unsigned char nh_flags;
		long unsigned int event;
	};
};

struct rt6_mtu_change_arg {
	struct net_device *dev;
	unsigned int mtu;
	struct fib6_info *f6i;
};

struct rt6_nh {
	struct fib6_info *fib6_info;
	struct fib6_config r_cfg;
	struct list_head next;
};

struct fib6_nh_exception_dump_walker {
	struct rt6_rtnl_dump_arg *dump;
	struct fib6_info *rt;
	unsigned int flags;
	unsigned int skip;
	unsigned int count;
};

enum fib6_walk_state {
	FWS_S = 0,
	FWS_L = 1,
	FWS_R = 2,
	FWS_C = 3,
	FWS_U = 4,
};

struct fib6_walker {
	struct list_head lh;
	struct fib6_node *root;
	struct fib6_node *node;
	struct fib6_info *leaf;
	enum fib6_walk_state state;
	unsigned int skip;
	unsigned int count;
	unsigned int skip_in_node;
	int (*func)(struct fib6_walker *);
	void *args;
};

struct fib6_entry_notifier_info {
	struct fib_notifier_info info;
	struct fib6_info *rt;
	unsigned int nsiblings;
};

struct ipv6_route_iter {
	struct seq_net_private p;
	struct fib6_walker w;
	loff_t skip;
	struct fib6_table *tbl;
	int sernum;
};

struct bpf_iter__ipv6_route {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct fib6_info *rt;
	};
};

struct fib6_cleaner {
	struct fib6_walker w;
	struct net *net;
	int (*func)(struct fib6_info *, void *);
	int sernum;
	void *arg;
	bool skip_notify;
};

enum {
	FIB6_NO_SERNUM_CHANGE = 0,
};

struct fib6_dump_arg {
	struct net *net;
	struct notifier_block *nb;
	struct netlink_ext_ack *extack;
};

struct fib6_nh_pcpu_arg {
	struct fib6_info *from;
	const struct fib6_table *table;
};

struct lookup_args {
	int offset;
	const struct in6_addr *addr;
};

struct ipv6_mreq {
	struct in6_addr ipv6mr_multiaddr;
	int ipv6mr_ifindex;
};

struct in6_flowlabel_req {
	struct in6_addr flr_dst;
	__be32 flr_label;
	__u8 flr_action;
	__u8 flr_share;
	__u16 flr_flags;
	__u16 flr_expires;
	__u16 flr_linger;
	__u32 __flr_pad;
};

struct ip6_mtuinfo {
	struct sockaddr_in6 ip6m_addr;
	__u32 ip6m_mtu;
};

struct nduseroptmsg {
	unsigned char nduseropt_family;
	unsigned char nduseropt_pad1;
	short unsigned int nduseropt_opts_len;
	int nduseropt_ifindex;
	__u8 nduseropt_icmp_type;
	__u8 nduseropt_icmp_code;
	short unsigned int nduseropt_pad2;
	unsigned int nduseropt_pad3;
};

enum {
	NDUSEROPT_UNSPEC = 0,
	NDUSEROPT_SRCADDR = 1,
	__NDUSEROPT_MAX = 2,
};

struct nd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	__u8 opt[0];
};

struct rs_msg {
	struct icmp6hdr icmph;
	__u8 opt[0];
};

struct ra_msg {
	struct icmp6hdr icmph;
	__be32 reachable_time;
	__be32 retrans_timer;
};

struct icmp6_filter {
	__u32 data[8];
};

struct raw6_sock {
	struct inet_sock inet;
	__u32 checksum;
	__u32 offset;
	struct icmp6_filter filter;
	__u32 ip6mr_table;
	struct ipv6_pinfo inet6;
};

typedef int mh_filter_t(struct sock *, struct sk_buff *);

struct raw6_frag_vec {
	struct msghdr *msg;
	int hlen;
	char c[4];
};

struct ipv6_destopt_hao {
	__u8 type;
	__u8 length;
	struct in6_addr addr;
} __attribute__((packed));

typedef void ip6_icmp_send_t(struct sk_buff *, u8, u8, __u32, const struct in6_addr *, const struct inet6_skb_parm *);

struct icmpv6_msg {
	struct sk_buff *skb;
	int offset;
	uint8_t type;
};

struct icmp6_err {
	int err;
	int fatal;
};

struct mld_msg {
	struct icmp6hdr mld_hdr;
	struct in6_addr mld_mca;
};

struct mld2_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	struct in6_addr grec_mca;
	struct in6_addr grec_src[0];
};

struct mld2_report {
	struct icmp6hdr mld2r_hdr;
	struct mld2_grec mld2r_grec[0];
};

struct mld2_query {
	struct icmp6hdr mld2q_hdr;
	struct in6_addr mld2q_mca;
	__u8 mld2q_qrv: 3;
	__u8 mld2q_suppress: 1;
	__u8 mld2q_resv2: 4;
	__u8 mld2q_qqic;
	__be16 mld2q_nsrcs;
	struct in6_addr mld2q_srcs[0];
};

struct igmp6_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct igmp6_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
	struct ifmcaddr6 *im;
};

enum ip6_defrag_users {
	IP6_DEFRAG_LOCAL_DELIVER = 0,
	IP6_DEFRAG_CONNTRACK_IN = 1,
	__IP6_DEFRAG_CONNTRACK_IN = 65536,
	IP6_DEFRAG_CONNTRACK_OUT = 65537,
	__IP6_DEFRAG_CONNTRACK_OUT = 131072,
	IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 131073,
	__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 196608,
};

struct frag_queue {
	struct inet_frag_queue q;
	int iif;
	__u16 nhoffset;
	u8 ecn;
};

struct tcp6_pseudohdr {
	struct in6_addr saddr;
	struct in6_addr daddr;
	__be32 len;
	__be32 protocol;
};

struct rt0_hdr {
	struct ipv6_rt_hdr rt_hdr;
	__u32 reserved;
	struct in6_addr addr[0];
};

struct ipv6_rpl_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u32 cmpre: 4;
	__u32 cmpri: 4;
	__u32 reserved: 4;
	__u32 pad: 4;
	__u32 reserved1: 16;
	union {
		struct in6_addr addr[0];
		__u8 data[0];
	} segments;
};

struct tlvtype_proc {
	int type;
	bool (*func)(struct sk_buff *, int);
};

struct ip6fl_iter_state {
	struct seq_net_private p;
	struct pid_namespace *pid_ns;
	int bucket;
};

struct sr6_tlv {
	__u8 type;
	__u8 len;
	__u8 data[0];
};

enum {
	SEG6_ATTR_UNSPEC = 0,
	SEG6_ATTR_DST = 1,
	SEG6_ATTR_DSTLEN = 2,
	SEG6_ATTR_HMACKEYID = 3,
	SEG6_ATTR_SECRET = 4,
	SEG6_ATTR_SECRETLEN = 5,
	SEG6_ATTR_ALGID = 6,
	SEG6_ATTR_HMACINFO = 7,
	__SEG6_ATTR_MAX = 8,
};

enum {
	SEG6_CMD_UNSPEC = 0,
	SEG6_CMD_SETHMAC = 1,
	SEG6_CMD_DUMPHMAC = 2,
	SEG6_CMD_SET_TUNSRC = 3,
	SEG6_CMD_GET_TUNSRC = 4,
	__SEG6_CMD_MAX = 5,
};

struct seg6_hmac_info {
	struct rhash_head node;
	struct callback_head rcu;
	u32 hmackeyid;
	char secret[64];
	u8 slen;
	u8 alg_id;
};

typedef short unsigned int mifi_t;

typedef __u32 if_mask;

struct if_set {
	if_mask ifs_bits[8];
};

struct mif6ctl {
	mifi_t mif6c_mifi;
	unsigned char mif6c_flags;
	unsigned char vifc_threshold;
	__u16 mif6c_pifi;
	unsigned int vifc_rate_limit;
};

struct mf6cctl {
	struct sockaddr_in6 mf6cc_origin;
	struct sockaddr_in6 mf6cc_mcastgrp;
	mifi_t mf6cc_parent;
	struct if_set mf6cc_ifset;
};

struct sioc_sg_req6 {
	struct sockaddr_in6 src;
	struct sockaddr_in6 grp;
	long unsigned int pktcnt;
	long unsigned int bytecnt;
	long unsigned int wrong_if;
};

struct sioc_mif_req6 {
	mifi_t mifi;
	long unsigned int icount;
	long unsigned int ocount;
	long unsigned int ibytes;
	long unsigned int obytes;
};

struct mrt6msg {
	__u8 im6_mbz;
	__u8 im6_msgtype;
	__u16 im6_mif;
	__u32 im6_pad;
	struct in6_addr im6_src;
	struct in6_addr im6_dst;
};

enum {
	IP6MRA_CREPORT_UNSPEC = 0,
	IP6MRA_CREPORT_MSGTYPE = 1,
	IP6MRA_CREPORT_MIF_ID = 2,
	IP6MRA_CREPORT_SRC_ADDR = 3,
	IP6MRA_CREPORT_DST_ADDR = 4,
	IP6MRA_CREPORT_PKT = 5,
	__IP6MRA_CREPORT_MAX = 6,
};

struct mfc6_cache_cmp_arg {
	struct in6_addr mf6c_mcastgrp;
	struct in6_addr mf6c_origin;
};

struct mfc6_cache {
	struct mr_mfc _c;
	union {
		struct {
			struct in6_addr mf6c_mcastgrp;
			struct in6_addr mf6c_origin;
		};
		struct mfc6_cache_cmp_arg cmparg;
	};
};

struct ip6mr_result {
	struct mr_table *mrt;
};

struct compat_sioc_sg_req6 {
	struct sockaddr_in6 src;
	struct sockaddr_in6 grp;
	compat_ulong_t pktcnt;
	compat_ulong_t bytecnt;
	compat_ulong_t wrong_if;
};

struct compat_sioc_mif_req6 {
	mifi_t mifi;
	compat_ulong_t icount;
	compat_ulong_t ocount;
	compat_ulong_t ibytes;
	compat_ulong_t obytes;
};

struct xfrm6_protocol {
	int (*handler)(struct sk_buff *);
	int (*input_handler)(struct sk_buff *, int, __be32, int);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	struct xfrm6_protocol *next;
	int priority;
};

struct br_input_skb_cb {
	struct net_device *brdev;
	u16 frag_max_size;
	u8 igmp;
	u8 mrouters_only: 1;
	u8 proxyarp_replied: 1;
	u8 src_port_isolated: 1;
	u8 vlan_filtered: 1;
	u8 br_netfilter_broute: 1;
	int offload_fwd_mark;
};

struct nf_bridge_frag_data;

typedef struct rt6_info * (*pol_lookup_t)(struct net *, struct fib6_table *, struct flowi6 *, const struct sk_buff *, int);

struct fib6_rule {
	struct fib_rule common;
	struct rt6key src;
	struct rt6key dst;
	u8 tclass;
};

struct calipso_doi;

struct netlbl_calipso_ops {
	int (*doi_add)(struct calipso_doi *, struct netlbl_audit *);
	void (*doi_free)(struct calipso_doi *);
	int (*doi_remove)(u32, struct netlbl_audit *);
	struct calipso_doi * (*doi_getdef)(u32);
	void (*doi_putdef)(struct calipso_doi *);
	int (*doi_walk)(u32 *, int (*)(struct calipso_doi *, void *), void *);
	int (*sock_getattr)(struct sock *, struct netlbl_lsm_secattr *);
	int (*sock_setattr)(struct sock *, const struct calipso_doi *, const struct netlbl_lsm_secattr *);
	void (*sock_delattr)(struct sock *);
	int (*req_setattr)(struct request_sock *, const struct calipso_doi *, const struct netlbl_lsm_secattr *);
	void (*req_delattr)(struct request_sock *);
	int (*opt_getattr)(const unsigned char *, struct netlbl_lsm_secattr *);
	unsigned char * (*skbuff_optptr)(const struct sk_buff *);
	int (*skbuff_setattr)(struct sk_buff *, const struct calipso_doi *, const struct netlbl_lsm_secattr *);
	int (*skbuff_delattr)(struct sk_buff *);
	void (*cache_invalidate)();
	int (*cache_add)(const unsigned char *, const struct netlbl_lsm_secattr *);
};

struct calipso_doi {
	u32 doi;
	u32 type;
	refcount_t refcount;
	struct list_head list;
	struct callback_head rcu;
};

struct calipso_map_cache_bkt {
	spinlock_t lock;
	u32 size;
	struct list_head list;
};

struct calipso_map_cache_entry {
	u32 hash;
	unsigned char *key;
	size_t key_len;
	struct netlbl_lsm_cache *lsm_data;
	u32 activity;
	struct list_head list;
};

enum {
	SEG6_IPTUNNEL_UNSPEC = 0,
	SEG6_IPTUNNEL_SRH = 1,
	__SEG6_IPTUNNEL_MAX = 2,
};

struct seg6_iptunnel_encap {
	int mode;
	struct ipv6_sr_hdr srh[0];
};

enum {
	SEG6_IPTUN_MODE_INLINE = 0,
	SEG6_IPTUN_MODE_ENCAP = 1,
	SEG6_IPTUN_MODE_L2ENCAP = 2,
};

struct seg6_lwt {
	struct dst_cache cache;
	struct seg6_iptunnel_encap tuninfo[0];
};

enum l3mdev_type {
	L3MDEV_TYPE_UNSPEC = 0,
	L3MDEV_TYPE_VRF = 1,
	__L3MDEV_TYPE_MAX = 2,
};

enum {
	IP6_FH_F_FRAG = 1,
	IP6_FH_F_AUTH = 2,
	IP6_FH_F_SKIP_RH = 4,
};

enum {
	SEG6_LOCAL_UNSPEC = 0,
	SEG6_LOCAL_ACTION = 1,
	SEG6_LOCAL_SRH = 2,
	SEG6_LOCAL_TABLE = 3,
	SEG6_LOCAL_NH4 = 4,
	SEG6_LOCAL_NH6 = 5,
	SEG6_LOCAL_IIF = 6,
	SEG6_LOCAL_OIF = 7,
	SEG6_LOCAL_BPF = 8,
	SEG6_LOCAL_VRFTABLE = 9,
	SEG6_LOCAL_COUNTERS = 10,
	__SEG6_LOCAL_MAX = 11,
};

enum {
	SEG6_LOCAL_BPF_PROG_UNSPEC = 0,
	SEG6_LOCAL_BPF_PROG = 1,
	SEG6_LOCAL_BPF_PROG_NAME = 2,
	__SEG6_LOCAL_BPF_PROG_MAX = 3,
};

enum {
	SEG6_LOCAL_CNT_UNSPEC = 0,
	SEG6_LOCAL_CNT_PAD = 1,
	SEG6_LOCAL_CNT_PACKETS = 2,
	SEG6_LOCAL_CNT_BYTES = 3,
	SEG6_LOCAL_CNT_ERRORS = 4,
	__SEG6_LOCAL_CNT_MAX = 5,
};

struct seg6_local_lwt;

struct seg6_local_lwtunnel_ops {
	int (*build_state)(struct seg6_local_lwt *, const void *, struct netlink_ext_ack *);
	void (*destroy_state)(struct seg6_local_lwt *);
};

enum seg6_end_dt_mode {
	DT_INVALID_MODE = 4294967274,
	DT_LEGACY_MODE = 0,
	DT_VRF_MODE = 1,
};

struct seg6_end_dt_info {
	enum seg6_end_dt_mode mode;
	struct net *net;
	int vrf_ifindex;
	int vrf_table;
	__be16 proto;
	u16 family;
	int hdrlen;
};

struct pcpu_seg6_local_counters;

struct seg6_action_desc;

struct seg6_local_lwt {
	int action;
	struct ipv6_sr_hdr *srh;
	int table;
	struct in_addr nh4;
	struct in6_addr nh6;
	int iif;
	int oif;
	struct bpf_lwt_prog bpf;
	struct seg6_end_dt_info dt_info;
	struct pcpu_seg6_local_counters *pcpu_counters;
	int headroom;
	struct seg6_action_desc *desc;
	long unsigned int parsed_optattrs;
};

struct seg6_action_desc {
	int action;
	long unsigned int attrs;
	long unsigned int optattrs;
	int (*input)(struct sk_buff *, struct seg6_local_lwt *);
	int static_headroom;
	struct seg6_local_lwtunnel_ops slwt_ops;
};

struct pcpu_seg6_local_counters {
	u64_stats_t packets;
	u64_stats_t bytes;
	u64_stats_t errors;
	struct u64_stats_sync syncp;
};

struct seg6_local_counters {
	__u64 packets;
	__u64 bytes;
	__u64 errors;
};

struct seg6_action_param {
	int (*parse)(struct nlattr **, struct seg6_local_lwt *);
	int (*put)(struct sk_buff *, struct seg6_local_lwt *);
	int (*cmp)(struct seg6_local_lwt *, struct seg6_local_lwt *);
	void (*destroy)(struct seg6_local_lwt *);
};

struct sr6_tlv_hmac {
	struct sr6_tlv tlvhdr;
	__u16 reserved;
	__be32 hmackeyid;
	__u8 hmac[32];
};

enum {
	SEG6_HMAC_ALGO_SHA1 = 1,
	SEG6_HMAC_ALGO_SHA256 = 2,
};

struct seg6_hmac_algo {
	u8 alg_id;
	char name[64];
	struct crypto_shash **tfms;
	struct shash_desc **shashs;
};

struct sockaddr_pkt {
	short unsigned int spkt_family;
	unsigned char spkt_device[14];
	__be16 spkt_protocol;
};

struct sockaddr_ll {
	short unsigned int sll_family;
	__be16 sll_protocol;
	int sll_ifindex;
	short unsigned int sll_hatype;
	unsigned char sll_pkttype;
	unsigned char sll_halen;
	unsigned char sll_addr[8];
};

struct tpacket_stats {
	unsigned int tp_packets;
	unsigned int tp_drops;
};

struct tpacket_stats_v3 {
	unsigned int tp_packets;
	unsigned int tp_drops;
	unsigned int tp_freeze_q_cnt;
};

struct tpacket_rollover_stats {
	__u64 tp_all;
	__u64 tp_huge;
	__u64 tp_failed;
};

union tpacket_stats_u {
	struct tpacket_stats stats1;
	struct tpacket_stats_v3 stats3;
};

struct tpacket_auxdata {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
};

struct tpacket_hdr {
	long unsigned int tp_status;
	unsigned int tp_len;
	unsigned int tp_snaplen;
	short unsigned int tp_mac;
	short unsigned int tp_net;
	unsigned int tp_sec;
	unsigned int tp_usec;
};

struct tpacket2_hdr {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u8 tp_padding[4];
};

struct tpacket_hdr_variant1 {
	__u32 tp_rxhash;
	__u32 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u16 tp_padding;
};

struct tpacket3_hdr {
	__u32 tp_next_offset;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u32 tp_snaplen;
	__u32 tp_len;
	__u32 tp_status;
	__u16 tp_mac;
	__u16 tp_net;
	union {
		struct tpacket_hdr_variant1 hv1;
	};
	__u8 tp_padding[8];
};

struct tpacket_bd_ts {
	unsigned int ts_sec;
	union {
		unsigned int ts_usec;
		unsigned int ts_nsec;
	};
};

struct tpacket_hdr_v1 {
	__u32 block_status;
	__u32 num_pkts;
	__u32 offset_to_first_pkt;
	__u32 blk_len;
	__u64 seq_num;
	struct tpacket_bd_ts ts_first_pkt;
	struct tpacket_bd_ts ts_last_pkt;
};

union tpacket_bd_header_u {
	struct tpacket_hdr_v1 bh1;
};

struct tpacket_block_desc {
	__u32 version;
	__u32 offset_to_priv;
	union tpacket_bd_header_u hdr;
};

enum tpacket_versions {
	TPACKET_V1 = 0,
	TPACKET_V2 = 1,
	TPACKET_V3 = 2,
};

struct tpacket_req {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
};

struct tpacket_req3 {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
	unsigned int tp_retire_blk_tov;
	unsigned int tp_sizeof_priv;
	unsigned int tp_feature_req_word;
};

union tpacket_req_u {
	struct tpacket_req req;
	struct tpacket_req3 req3;
};

struct fanout_args {
	__u16 id;
	__u16 type_flags;
	__u32 max_num_members;
};

struct packet_mclist {
	struct packet_mclist *next;
	int ifindex;
	int count;
	short unsigned int type;
	short unsigned int alen;
	unsigned char addr[32];
};

struct pgv;

struct tpacket_kbdq_core {
	struct pgv *pkbdq;
	unsigned int feature_req_word;
	unsigned int hdrlen;
	unsigned char reset_pending_on_curr_blk;
	unsigned char delete_blk_timer;
	short unsigned int kactive_blk_num;
	short unsigned int blk_sizeof_priv;
	short unsigned int last_kactive_blk_num;
	char *pkblk_start;
	char *pkblk_end;
	int kblk_size;
	unsigned int max_frame_len;
	unsigned int knum_blocks;
	uint64_t knxt_seq_num;
	char *prev;
	char *nxt_offset;
	struct sk_buff *skb;
	rwlock_t blk_fill_in_prog_lock;
	short unsigned int retire_blk_tov;
	short unsigned int version;
	long unsigned int tov_in_jiffies;
	struct timer_list retire_blk_timer;
};

struct pgv {
	char *buffer;
};

struct packet_ring_buffer {
	struct pgv *pg_vec;
	unsigned int head;
	unsigned int frames_per_block;
	unsigned int frame_size;
	unsigned int frame_max;
	unsigned int pg_vec_order;
	unsigned int pg_vec_pages;
	unsigned int pg_vec_len;
	unsigned int *pending_refcnt;
	union {
		long unsigned int *rx_owner_map;
		struct tpacket_kbdq_core prb_bdqc;
	};
};

struct packet_fanout {
	possible_net_t net;
	unsigned int num_members;
	u32 max_num_members;
	u16 id;
	u8 type;
	u8 flags;
	union {
		atomic_t rr_cur;
		struct bpf_prog *bpf_prog;
	};
	struct list_head list;
	spinlock_t lock;
	refcount_t sk_ref;
	long: 64;
	struct packet_type prot_hook;
	struct sock *arr[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct packet_rollover {
	int sock;
	atomic_long_t num;
	atomic_long_t num_huge;
	atomic_long_t num_failed;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 history[16];
};

struct packet_sock {
	struct sock sk;
	struct packet_fanout *fanout;
	union tpacket_stats_u stats;
	struct packet_ring_buffer rx_ring;
	struct packet_ring_buffer tx_ring;
	int copy_thresh;
	spinlock_t bind_lock;
	struct mutex pg_vec_lock;
	unsigned int running;
	unsigned int auxdata: 1;
	unsigned int origdev: 1;
	unsigned int has_vnet_hdr: 1;
	unsigned int tp_loss: 1;
	unsigned int tp_tx_has_off: 1;
	int pressure;
	int ifindex;
	__be16 num;
	struct packet_rollover *rollover;
	struct packet_mclist *mclist;
	atomic_t mapped;
	enum tpacket_versions tp_version;
	unsigned int tp_hdrlen;
	unsigned int tp_reserve;
	unsigned int tp_tstamp;
	struct completion skb_completion;
	struct net_device *cached_dev;
	int (*xmit)(struct sk_buff *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct packet_type prot_hook;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t tp_drops;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct packet_mreq_max {
	int mr_ifindex;
	short unsigned int mr_type;
	short unsigned int mr_alen;
	unsigned char mr_address[32];
};

union tpacket_uhdr {
	struct tpacket_hdr *h1;
	struct tpacket2_hdr *h2;
	struct tpacket3_hdr *h3;
	void *raw;
};

struct packet_skb_cb {
	union {
		struct sockaddr_pkt pkt;
		union {
			unsigned int origlen;
			struct sockaddr_ll ll;
		};
	} sa;
};

struct vlan_group {
	unsigned int nr_vlan_devs;
	struct hlist_node hlist;
	struct net_device **vlan_devices_arrays[16];
};

struct vlan_info {
	struct net_device *real_dev;
	struct vlan_group grp;
	struct list_head vid_list;
	unsigned int nr_vids;
	struct callback_head rcu;
};

enum vlan_flags {
	VLAN_FLAG_REORDER_HDR = 1,
	VLAN_FLAG_GVRP = 2,
	VLAN_FLAG_LOOSE_BINDING = 4,
	VLAN_FLAG_MVRP = 8,
	VLAN_FLAG_BRIDGE_BINDING = 16,
};

struct vlan_priority_tci_mapping {
	u32 priority;
	u16 vlan_qos;
	struct vlan_priority_tci_mapping *next;
};

struct vlan_dev_priv {
	unsigned int nr_ingress_mappings;
	u32 ingress_priority_map[8];
	unsigned int nr_egress_mappings;
	struct vlan_priority_tci_mapping *egress_priority_map[16];
	__be16 vlan_proto;
	u16 vlan_id;
	u16 flags;
	struct net_device *real_dev;
	unsigned char real_dev_addr[6];
	struct proc_dir_entry *dent;
	struct vlan_pcpu_stats *vlan_pcpu_stats;
	struct netpoll *netpoll;
};

enum vlan_protos {
	VLAN_PROTO_8021Q = 0,
	VLAN_PROTO_8021AD = 1,
	VLAN_PROTO_NUM = 2,
};

struct vlan_vid_info {
	struct list_head list;
	__be16 proto;
	u16 vid;
	int refcount;
};

enum nl80211_iftype {
	NL80211_IFTYPE_UNSPECIFIED = 0,
	NL80211_IFTYPE_ADHOC = 1,
	NL80211_IFTYPE_STATION = 2,
	NL80211_IFTYPE_AP = 3,
	NL80211_IFTYPE_AP_VLAN = 4,
	NL80211_IFTYPE_WDS = 5,
	NL80211_IFTYPE_MONITOR = 6,
	NL80211_IFTYPE_MESH_POINT = 7,
	NL80211_IFTYPE_P2P_CLIENT = 8,
	NL80211_IFTYPE_P2P_GO = 9,
	NL80211_IFTYPE_P2P_DEVICE = 10,
	NL80211_IFTYPE_OCB = 11,
	NL80211_IFTYPE_NAN = 12,
	NUM_NL80211_IFTYPES = 13,
	NL80211_IFTYPE_MAX = 12,
};

struct cfg80211_conn;

struct cfg80211_cached_keys;

enum ieee80211_bss_type {
	IEEE80211_BSS_TYPE_ESS = 0,
	IEEE80211_BSS_TYPE_PBSS = 1,
	IEEE80211_BSS_TYPE_IBSS = 2,
	IEEE80211_BSS_TYPE_MBSS = 3,
	IEEE80211_BSS_TYPE_ANY = 4,
};

struct cfg80211_internal_bss;

enum nl80211_chan_width {
	NL80211_CHAN_WIDTH_20_NOHT = 0,
	NL80211_CHAN_WIDTH_20 = 1,
	NL80211_CHAN_WIDTH_40 = 2,
	NL80211_CHAN_WIDTH_80 = 3,
	NL80211_CHAN_WIDTH_80P80 = 4,
	NL80211_CHAN_WIDTH_160 = 5,
	NL80211_CHAN_WIDTH_5 = 6,
	NL80211_CHAN_WIDTH_10 = 7,
	NL80211_CHAN_WIDTH_1 = 8,
	NL80211_CHAN_WIDTH_2 = 9,
	NL80211_CHAN_WIDTH_4 = 10,
	NL80211_CHAN_WIDTH_8 = 11,
	NL80211_CHAN_WIDTH_16 = 12,
};

enum ieee80211_edmg_bw_config {
	IEEE80211_EDMG_BW_CONFIG_4 = 4,
	IEEE80211_EDMG_BW_CONFIG_5 = 5,
	IEEE80211_EDMG_BW_CONFIG_6 = 6,
	IEEE80211_EDMG_BW_CONFIG_7 = 7,
	IEEE80211_EDMG_BW_CONFIG_8 = 8,
	IEEE80211_EDMG_BW_CONFIG_9 = 9,
	IEEE80211_EDMG_BW_CONFIG_10 = 10,
	IEEE80211_EDMG_BW_CONFIG_11 = 11,
	IEEE80211_EDMG_BW_CONFIG_12 = 12,
	IEEE80211_EDMG_BW_CONFIG_13 = 13,
	IEEE80211_EDMG_BW_CONFIG_14 = 14,
	IEEE80211_EDMG_BW_CONFIG_15 = 15,
};

struct ieee80211_edmg {
	u8 channels;
	enum ieee80211_edmg_bw_config bw_config;
};

struct ieee80211_channel;

struct cfg80211_chan_def {
	struct ieee80211_channel *chan;
	enum nl80211_chan_width width;
	u32 center_freq1;
	u32 center_freq2;
	struct ieee80211_edmg edmg;
	u16 freq1_offset;
};

struct ieee80211_mcs_info {
	u8 rx_mask[10];
	__le16 rx_highest;
	u8 tx_params;
	u8 reserved[3];
};

struct ieee80211_ht_cap {
	__le16 cap_info;
	u8 ampdu_params_info;
	struct ieee80211_mcs_info mcs;
	__le16 extended_ht_cap_info;
	__le32 tx_BF_cap_info;
	u8 antenna_selection_info;
} __attribute__((packed));

struct key_params;

struct cfg80211_ibss_params {
	const u8 *ssid;
	const u8 *bssid;
	struct cfg80211_chan_def chandef;
	const u8 *ie;
	u8 ssid_len;
	u8 ie_len;
	u16 beacon_interval;
	u32 basic_rates;
	bool channel_fixed;
	bool privacy;
	bool control_port;
	bool control_port_over_nl80211;
	bool userspace_handles_dfs;
	int: 24;
	int mcast_rate[5];
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct key_params *wep_keys;
	int wep_tx_key;
	int: 32;
} __attribute__((packed));

enum nl80211_auth_type {
	NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
	NL80211_AUTHTYPE_SHARED_KEY = 1,
	NL80211_AUTHTYPE_FT = 2,
	NL80211_AUTHTYPE_NETWORK_EAP = 3,
	NL80211_AUTHTYPE_SAE = 4,
	NL80211_AUTHTYPE_FILS_SK = 5,
	NL80211_AUTHTYPE_FILS_SK_PFS = 6,
	NL80211_AUTHTYPE_FILS_PK = 7,
	__NL80211_AUTHTYPE_NUM = 8,
	NL80211_AUTHTYPE_MAX = 7,
	NL80211_AUTHTYPE_AUTOMATIC = 8,
};

enum nl80211_mfp {
	NL80211_MFP_NO = 0,
	NL80211_MFP_REQUIRED = 1,
	NL80211_MFP_OPTIONAL = 2,
};

enum nl80211_sae_pwe_mechanism {
	NL80211_SAE_PWE_UNSPECIFIED = 0,
	NL80211_SAE_PWE_HUNT_AND_PECK = 1,
	NL80211_SAE_PWE_HASH_TO_ELEMENT = 2,
	NL80211_SAE_PWE_BOTH = 3,
};

struct cfg80211_crypto_settings {
	u32 wpa_versions;
	u32 cipher_group;
	int n_ciphers_pairwise;
	u32 ciphers_pairwise[5];
	int n_akm_suites;
	u32 akm_suites[2];
	bool control_port;
	__be16 control_port_ethertype;
	bool control_port_no_encrypt;
	bool control_port_over_nl80211;
	bool control_port_no_preauth;
	struct key_params *wep_keys;
	int wep_tx_key;
	const u8 *psk;
	const u8 *sae_pwd;
	u8 sae_pwd_len;
	enum nl80211_sae_pwe_mechanism sae_pwe;
};

struct ieee80211_vht_mcs_info {
	__le16 rx_mcs_map;
	__le16 rx_highest;
	__le16 tx_mcs_map;
	__le16 tx_highest;
};

struct ieee80211_vht_cap {
	__le32 vht_cap_info;
	struct ieee80211_vht_mcs_info supp_mcs;
};

enum nl80211_bss_select_attr {
	__NL80211_BSS_SELECT_ATTR_INVALID = 0,
	NL80211_BSS_SELECT_ATTR_RSSI = 1,
	NL80211_BSS_SELECT_ATTR_BAND_PREF = 2,
	NL80211_BSS_SELECT_ATTR_RSSI_ADJUST = 3,
	__NL80211_BSS_SELECT_ATTR_AFTER_LAST = 4,
	NL80211_BSS_SELECT_ATTR_MAX = 3,
};

enum nl80211_band {
	NL80211_BAND_2GHZ = 0,
	NL80211_BAND_5GHZ = 1,
	NL80211_BAND_60GHZ = 2,
	NL80211_BAND_6GHZ = 3,
	NL80211_BAND_S1GHZ = 4,
	NUM_NL80211_BANDS = 5,
};

struct cfg80211_bss_select_adjust {
	enum nl80211_band band;
	s8 delta;
};

struct cfg80211_bss_selection {
	enum nl80211_bss_select_attr behaviour;
	union {
		enum nl80211_band band_pref;
		struct cfg80211_bss_select_adjust adjust;
	} param;
};

struct cfg80211_connect_params {
	struct ieee80211_channel *channel;
	struct ieee80211_channel *channel_hint;
	const u8 *bssid;
	const u8 *bssid_hint;
	const u8 *ssid;
	size_t ssid_len;
	enum nl80211_auth_type auth_type;
	int: 32;
	const u8 *ie;
	size_t ie_len;
	bool privacy;
	int: 24;
	enum nl80211_mfp mfp;
	struct cfg80211_crypto_settings crypto;
	const u8 *key;
	u8 key_len;
	u8 key_idx;
	short: 16;
	u32 flags;
	int bg_scan_period;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
	bool pbss;
	int: 24;
	struct cfg80211_bss_selection bss_select;
	const u8 *prev_bssid;
	const u8 *fils_erp_username;
	size_t fils_erp_username_len;
	const u8 *fils_erp_realm;
	size_t fils_erp_realm_len;
	u16 fils_erp_next_seq_num;
	long: 48;
	const u8 *fils_erp_rrk;
	size_t fils_erp_rrk_len;
	bool want_1x;
	int: 24;
	struct ieee80211_edmg edmg;
	int: 32;
} __attribute__((packed));

struct cfg80211_cqm_config;

struct wiphy;

struct wireless_dev {
	struct wiphy *wiphy;
	enum nl80211_iftype iftype;
	struct list_head list;
	struct net_device *netdev;
	u32 identifier;
	struct list_head mgmt_registrations;
	u8 mgmt_registrations_need_update: 1;
	struct mutex mtx;
	bool use_4addr;
	bool is_running;
	bool registered;
	bool registering;
	u8 address[6];
	u8 ssid[32];
	u8 ssid_len;
	u8 mesh_id_len;
	u8 mesh_id_up_len;
	struct cfg80211_conn *conn;
	struct cfg80211_cached_keys *connect_keys;
	enum ieee80211_bss_type conn_bss_type;
	u32 conn_owner_nlportid;
	struct work_struct disconnect_wk;
	u8 disconnect_bssid[6];
	struct list_head event_list;
	spinlock_t event_lock;
	struct cfg80211_internal_bss *current_bss;
	struct cfg80211_chan_def preset_chandef;
	struct cfg80211_chan_def chandef;
	bool ibss_fixed;
	bool ibss_dfs_possible;
	bool ps;
	int ps_timeout;
	int beacon_interval;
	u32 ap_unexpected_nlportid;
	u32 owner_nlportid;
	bool nl_owner_dead;
	bool cac_started;
	long unsigned int cac_start_time;
	unsigned int cac_time_ms;
	struct {
		struct cfg80211_ibss_params ibss;
		struct cfg80211_connect_params connect;
		struct cfg80211_cached_keys *keys;
		const u8 *ie;
		size_t ie_len;
		u8 bssid[6];
		u8 prev_bssid[6];
		u8 ssid[32];
		s8 default_key;
		s8 default_mgmt_key;
		bool prev_bssid_valid;
	} wext;
	struct cfg80211_cqm_config *cqm_config;
	struct list_head pmsr_list;
	spinlock_t pmsr_lock;
	struct work_struct pmsr_free_wk;
	long unsigned int unprot_beacon_reported;
};

struct iw_encode_ext {
	__u32 ext_flags;
	__u8 tx_seq[8];
	__u8 rx_seq[8];
	struct sockaddr addr;
	__u16 alg;
	__u16 key_len;
	__u8 key[0];
};

struct iwreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union iwreq_data u;
};

struct iw_event {
	__u16 len;
	__u16 cmd;
	union iwreq_data u;
};

struct compat_iw_point {
	compat_caddr_t pointer;
	__u16 length;
	__u16 flags;
};

struct __compat_iw_event {
	__u16 len;
	__u16 cmd;
	compat_caddr_t pointer;
};

enum nl80211_reg_initiator {
	NL80211_REGDOM_SET_BY_CORE = 0,
	NL80211_REGDOM_SET_BY_USER = 1,
	NL80211_REGDOM_SET_BY_DRIVER = 2,
	NL80211_REGDOM_SET_BY_COUNTRY_IE = 3,
};

enum nl80211_dfs_regions {
	NL80211_DFS_UNSET = 0,
	NL80211_DFS_FCC = 1,
	NL80211_DFS_ETSI = 2,
	NL80211_DFS_JP = 3,
};

enum nl80211_user_reg_hint_type {
	NL80211_USER_REG_HINT_USER = 0,
	NL80211_USER_REG_HINT_CELL_BASE = 1,
	NL80211_USER_REG_HINT_INDOOR = 2,
};

enum nl80211_mntr_flags {
	__NL80211_MNTR_FLAG_INVALID = 0,
	NL80211_MNTR_FLAG_FCSFAIL = 1,
	NL80211_MNTR_FLAG_PLCPFAIL = 2,
	NL80211_MNTR_FLAG_CONTROL = 3,
	NL80211_MNTR_FLAG_OTHER_BSS = 4,
	NL80211_MNTR_FLAG_COOK_FRAMES = 5,
	NL80211_MNTR_FLAG_ACTIVE = 6,
	__NL80211_MNTR_FLAG_AFTER_LAST = 7,
	NL80211_MNTR_FLAG_MAX = 6,
};

enum nl80211_key_mode {
	NL80211_KEY_RX_TX = 0,
	NL80211_KEY_NO_TX = 1,
	NL80211_KEY_SET_TX = 2,
};

enum nl80211_bss_scan_width {
	NL80211_BSS_CHAN_WIDTH_20 = 0,
	NL80211_BSS_CHAN_WIDTH_10 = 1,
	NL80211_BSS_CHAN_WIDTH_5 = 2,
	NL80211_BSS_CHAN_WIDTH_1 = 3,
	NL80211_BSS_CHAN_WIDTH_2 = 4,
};

struct nl80211_wowlan_tcp_data_seq {
	__u32 start;
	__u32 offset;
	__u32 len;
};

struct nl80211_wowlan_tcp_data_token {
	__u32 offset;
	__u32 len;
	__u8 token_stream[0];
};

struct nl80211_wowlan_tcp_data_token_feature {
	__u32 min_len;
	__u32 max_len;
	__u32 bufsize;
};

enum nl80211_ext_feature_index {
	NL80211_EXT_FEATURE_VHT_IBSS = 0,
	NL80211_EXT_FEATURE_RRM = 1,
	NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER = 2,
	NL80211_EXT_FEATURE_SCAN_START_TIME = 3,
	NL80211_EXT_FEATURE_BSS_PARENT_TSF = 4,
	NL80211_EXT_FEATURE_SET_SCAN_DWELL = 5,
	NL80211_EXT_FEATURE_BEACON_RATE_LEGACY = 6,
	NL80211_EXT_FEATURE_BEACON_RATE_HT = 7,
	NL80211_EXT_FEATURE_BEACON_RATE_VHT = 8,
	NL80211_EXT_FEATURE_FILS_STA = 9,
	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA = 10,
	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED = 11,
	NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI = 12,
	NL80211_EXT_FEATURE_CQM_RSSI_LIST = 13,
	NL80211_EXT_FEATURE_FILS_SK_OFFLOAD = 14,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK = 15,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X = 16,
	NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME = 17,
	NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP = 18,
	NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE = 19,
	NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION = 20,
	NL80211_EXT_FEATURE_MFP_OPTIONAL = 21,
	NL80211_EXT_FEATURE_LOW_SPAN_SCAN = 22,
	NL80211_EXT_FEATURE_LOW_POWER_SCAN = 23,
	NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN = 24,
	NL80211_EXT_FEATURE_DFS_OFFLOAD = 25,
	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211 = 26,
	NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT = 27,
	NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT = 27,
	NL80211_EXT_FEATURE_TXQS = 28,
	NL80211_EXT_FEATURE_SCAN_RANDOM_SN = 29,
	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT = 30,
	NL80211_EXT_FEATURE_CAN_REPLACE_PTK0 = 31,
	NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER = 32,
	NL80211_EXT_FEATURE_AIRTIME_FAIRNESS = 33,
	NL80211_EXT_FEATURE_AP_PMKSA_CACHING = 34,
	NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD = 35,
	NL80211_EXT_FEATURE_EXT_KEY_ID = 36,
	NL80211_EXT_FEATURE_STA_TX_PWR = 37,
	NL80211_EXT_FEATURE_SAE_OFFLOAD = 38,
	NL80211_EXT_FEATURE_VLAN_OFFLOAD = 39,
	NL80211_EXT_FEATURE_AQL = 40,
	NL80211_EXT_FEATURE_BEACON_PROTECTION = 41,
	NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH = 42,
	NL80211_EXT_FEATURE_PROTECTED_TWT = 43,
	NL80211_EXT_FEATURE_DEL_IBSS_STA = 44,
	NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS = 45,
	NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT = 46,
	NL80211_EXT_FEATURE_SCAN_FREQ_KHZ = 47,
	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS = 48,
	NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION = 49,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK = 50,
	NL80211_EXT_FEATURE_SAE_OFFLOAD_AP = 51,
	NL80211_EXT_FEATURE_FILS_DISCOVERY = 52,
	NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP = 53,
	NL80211_EXT_FEATURE_BEACON_RATE_HE = 54,
	NL80211_EXT_FEATURE_SECURE_LTF = 55,
	NL80211_EXT_FEATURE_SECURE_RTT = 56,
	NL80211_EXT_FEATURE_PROT_RANGE_NEGO_AND_MEASURE = 57,
	NUM_NL80211_EXT_FEATURES = 58,
	MAX_NL80211_EXT_FEATURES = 57,
};

enum nl80211_dfs_state {
	NL80211_DFS_USABLE = 0,
	NL80211_DFS_UNAVAILABLE = 1,
	NL80211_DFS_AVAILABLE = 2,
};

struct nl80211_vendor_cmd_info {
	__u32 vendor_id;
	__u32 subcmd;
};

enum nl80211_sar_type {
	NL80211_SAR_TYPE_POWER = 0,
	NUM_NL80211_SAR_TYPE = 1,
};

struct ieee80211_he_cap_elem {
	u8 mac_cap_info[6];
	u8 phy_cap_info[11];
};

struct ieee80211_he_mcs_nss_supp {
	__le16 rx_mcs_80;
	__le16 tx_mcs_80;
	__le16 rx_mcs_160;
	__le16 tx_mcs_160;
	__le16 rx_mcs_80p80;
	__le16 tx_mcs_80p80;
};

struct ieee80211_he_6ghz_capa {
	__le16 capa;
};

enum environment_cap {
	ENVIRON_ANY = 0,
	ENVIRON_INDOOR = 1,
	ENVIRON_OUTDOOR = 2,
};

struct regulatory_request {
	struct callback_head callback_head;
	int wiphy_idx;
	enum nl80211_reg_initiator initiator;
	enum nl80211_user_reg_hint_type user_reg_hint_type;
	char alpha2[3];
	enum nl80211_dfs_regions dfs_region;
	bool intersect;
	bool processed;
	enum environment_cap country_ie_env;
	struct list_head list;
};

struct ieee80211_freq_range {
	u32 start_freq_khz;
	u32 end_freq_khz;
	u32 max_bandwidth_khz;
};

struct ieee80211_power_rule {
	u32 max_antenna_gain;
	u32 max_eirp;
};

struct ieee80211_wmm_ac {
	u16 cw_min;
	u16 cw_max;
	u16 cot;
	u8 aifsn;
};

struct ieee80211_wmm_rule {
	struct ieee80211_wmm_ac client[4];
	struct ieee80211_wmm_ac ap[4];
};

struct ieee80211_reg_rule {
	struct ieee80211_freq_range freq_range;
	struct ieee80211_power_rule power_rule;
	struct ieee80211_wmm_rule wmm_rule;
	u32 flags;
	u32 dfs_cac_ms;
	bool has_wmm;
};

struct ieee80211_regdomain {
	struct callback_head callback_head;
	u32 n_reg_rules;
	char alpha2[3];
	enum nl80211_dfs_regions dfs_region;
	struct ieee80211_reg_rule reg_rules[0];
};

struct ieee80211_channel {
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	u16 hw_value;
	u32 flags;
	int max_antenna_gain;
	int max_power;
	int max_reg_power;
	bool beacon_found;
	u32 orig_flags;
	int orig_mag;
	int orig_mpwr;
	enum nl80211_dfs_state dfs_state;
	long unsigned int dfs_state_entered;
	unsigned int dfs_cac_ms;
};

struct ieee80211_rate {
	u32 flags;
	u16 bitrate;
	u16 hw_value;
	u16 hw_value_short;
};

struct ieee80211_sta_ht_cap {
	u16 cap;
	bool ht_supported;
	u8 ampdu_factor;
	u8 ampdu_density;
	struct ieee80211_mcs_info mcs;
	char: 8;
} __attribute__((packed));

struct ieee80211_sta_vht_cap {
	bool vht_supported;
	u32 cap;
	struct ieee80211_vht_mcs_info vht_mcs;
};

struct ieee80211_sta_he_cap {
	bool has_he;
	struct ieee80211_he_cap_elem he_cap_elem;
	struct ieee80211_he_mcs_nss_supp he_mcs_nss_supp;
	u8 ppe_thres[25];
} __attribute__((packed));

struct ieee80211_sband_iftype_data {
	u16 types_mask;
	struct ieee80211_sta_he_cap he_cap;
	struct ieee80211_he_6ghz_capa he_6ghz_capa;
	char: 8;
} __attribute__((packed));

struct ieee80211_sta_s1g_cap {
	bool s1g;
	u8 cap[10];
	u8 nss_mcs[5];
};

struct ieee80211_supported_band {
	struct ieee80211_channel *channels;
	struct ieee80211_rate *bitrates;
	enum nl80211_band band;
	int n_channels;
	int n_bitrates;
	struct ieee80211_sta_ht_cap ht_cap;
	struct ieee80211_sta_vht_cap vht_cap;
	struct ieee80211_sta_s1g_cap s1g_cap;
	struct ieee80211_edmg edmg_cap;
	u16 n_iftype_data;
	const struct ieee80211_sband_iftype_data *iftype_data;
};

struct key_params {
	const u8 *key;
	const u8 *seq;
	int key_len;
	int seq_len;
	u16 vlan_id;
	u32 cipher;
	enum nl80211_key_mode mode;
};

struct mac_address___2 {
	u8 addr[6];
};

struct cfg80211_sar_freq_ranges {
	u32 start_freq;
	u32 end_freq;
};

struct cfg80211_sar_capa {
	enum nl80211_sar_type type;
	u32 num_freq_ranges;
	const struct cfg80211_sar_freq_ranges *freq_ranges;
};

struct cfg80211_ssid {
	u8 ssid[32];
	u8 ssid_len;
};

enum cfg80211_signal_type {
	CFG80211_SIGNAL_TYPE_NONE = 0,
	CFG80211_SIGNAL_TYPE_MBM = 1,
	CFG80211_SIGNAL_TYPE_UNSPEC = 2,
};

struct ieee80211_txrx_stypes;

struct ieee80211_iface_combination;

struct wiphy_iftype_akm_suites;

struct wiphy_wowlan_support;

struct cfg80211_wowlan;

struct wiphy_iftype_ext_capab;

struct wiphy_coalesce_support;

struct wiphy_vendor_command;

struct cfg80211_pmsr_capabilities;

struct wiphy {
	struct mutex mtx;
	u8 perm_addr[6];
	u8 addr_mask[6];
	struct mac_address___2 *addresses;
	const struct ieee80211_txrx_stypes *mgmt_stypes;
	const struct ieee80211_iface_combination *iface_combinations;
	int n_iface_combinations;
	u16 software_iftypes;
	u16 n_addresses;
	u16 interface_modes;
	u16 max_acl_mac_addrs;
	u32 flags;
	u32 regulatory_flags;
	u32 features;
	u8 ext_features[8];
	u32 ap_sme_capa;
	enum cfg80211_signal_type signal_type;
	int bss_priv_size;
	u8 max_scan_ssids;
	u8 max_sched_scan_reqs;
	u8 max_sched_scan_ssids;
	u8 max_match_sets;
	u16 max_scan_ie_len;
	u16 max_sched_scan_ie_len;
	u32 max_sched_scan_plans;
	u32 max_sched_scan_plan_interval;
	u32 max_sched_scan_plan_iterations;
	int n_cipher_suites;
	const u32 *cipher_suites;
	int n_akm_suites;
	const u32 *akm_suites;
	const struct wiphy_iftype_akm_suites *iftype_akm_suites;
	unsigned int num_iftype_akm_suites;
	u8 retry_short;
	u8 retry_long;
	u32 frag_threshold;
	u32 rts_threshold;
	u8 coverage_class;
	char fw_version[32];
	u32 hw_version;
	const struct wiphy_wowlan_support *wowlan;
	struct cfg80211_wowlan *wowlan_config;
	u16 max_remain_on_channel_duration;
	u8 max_num_pmkids;
	u32 available_antennas_tx;
	u32 available_antennas_rx;
	u32 probe_resp_offload;
	const u8 *extended_capabilities;
	const u8 *extended_capabilities_mask;
	u8 extended_capabilities_len;
	const struct wiphy_iftype_ext_capab *iftype_ext_capab;
	unsigned int num_iftype_ext_capab;
	const void *privid;
	struct ieee80211_supported_band *bands[5];
	void (*reg_notifier)(struct wiphy *, struct regulatory_request *);
	const struct ieee80211_regdomain *regd;
	struct device dev;
	bool registered;
	struct dentry *debugfsdir;
	const struct ieee80211_ht_cap *ht_capa_mod_mask;
	const struct ieee80211_vht_cap *vht_capa_mod_mask;
	struct list_head wdev_list;
	possible_net_t _net;
	const struct iw_handler_def *wext;
	const struct wiphy_coalesce_support *coalesce;
	const struct wiphy_vendor_command *vendor_commands;
	const struct nl80211_vendor_cmd_info *vendor_events;
	int n_vendor_commands;
	int n_vendor_events;
	u16 max_ap_assoc_sta;
	u8 max_num_csa_counters;
	u32 bss_select_support;
	u8 nan_supported_bands;
	u32 txq_limit;
	u32 txq_memory_limit;
	u32 txq_quantum;
	long unsigned int tx_queue_len;
	u8 support_mbssid: 1;
	u8 support_only_he_mbssid: 1;
	const struct cfg80211_pmsr_capabilities *pmsr_capa;
	struct {
		u64 peer;
		u64 vif;
		u8 max_retry;
	} tid_config_support;
	u8 max_data_retry_count;
	const struct cfg80211_sar_capa *sar_capa;
	long: 64;
	char priv[0];
};

struct cfg80211_match_set {
	struct cfg80211_ssid ssid;
	u8 bssid[6];
	s32 rssi_thold;
	s32 per_band_rssi_thold[5];
};

struct cfg80211_sched_scan_plan {
	u32 interval;
	u32 iterations;
};

struct cfg80211_sched_scan_request {
	u64 reqid;
	struct cfg80211_ssid *ssids;
	int n_ssids;
	u32 n_channels;
	enum nl80211_bss_scan_width scan_width;
	const u8 *ie;
	size_t ie_len;
	u32 flags;
	struct cfg80211_match_set *match_sets;
	int n_match_sets;
	s32 min_rssi_thold;
	u32 delay;
	struct cfg80211_sched_scan_plan *scan_plans;
	int n_scan_plans;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	bool relative_rssi_set;
	s8 relative_rssi;
	struct cfg80211_bss_select_adjust rssi_adjust;
	struct wiphy *wiphy;
	struct net_device *dev;
	long unsigned int scan_start;
	bool report_results;
	struct callback_head callback_head;
	u32 owner_nlportid;
	bool nl_owner_dead;
	struct list_head list;
	struct ieee80211_channel *channels[0];
};

struct cfg80211_pkt_pattern {
	const u8 *mask;
	const u8 *pattern;
	int pattern_len;
	int pkt_offset;
};

struct cfg80211_wowlan_tcp {
	struct socket *sock;
	__be32 src;
	__be32 dst;
	u16 src_port;
	u16 dst_port;
	u8 dst_mac[6];
	int payload_len;
	const u8 *payload;
	struct nl80211_wowlan_tcp_data_seq payload_seq;
	u32 data_interval;
	u32 wake_len;
	const u8 *wake_data;
	const u8 *wake_mask;
	u32 tokens_size;
	struct nl80211_wowlan_tcp_data_token payload_tok;
};

struct cfg80211_wowlan {
	bool any;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	struct cfg80211_pkt_pattern *patterns;
	struct cfg80211_wowlan_tcp *tcp;
	int n_patterns;
	struct cfg80211_sched_scan_request *nd_config;
};

struct ieee80211_iface_limit {
	u16 max;
	u16 types;
};

struct ieee80211_iface_combination {
	const struct ieee80211_iface_limit *limits;
	u32 num_different_channels;
	u16 max_interfaces;
	u8 n_limits;
	bool beacon_int_infra_match;
	u8 radar_detect_widths;
	u8 radar_detect_regions;
	u32 beacon_int_min_gcd;
};

struct ieee80211_txrx_stypes {
	u16 tx;
	u16 rx;
};

struct wiphy_wowlan_tcp_support {
	const struct nl80211_wowlan_tcp_data_token_feature *tok;
	u32 data_payload_max;
	u32 data_interval_max;
	u32 wake_payload_max;
	bool seq;
};

struct wiphy_wowlan_support {
	u32 flags;
	int n_patterns;
	int pattern_max_len;
	int pattern_min_len;
	int max_pkt_offset;
	int max_nd_match_sets;
	const struct wiphy_wowlan_tcp_support *tcp;
};

struct wiphy_coalesce_support {
	int n_rules;
	int max_delay;
	int n_patterns;
	int pattern_max_len;
	int pattern_min_len;
	int max_pkt_offset;
};

struct wiphy_vendor_command {
	struct nl80211_vendor_cmd_info info;
	u32 flags;
	int (*doit)(struct wiphy *, struct wireless_dev *, const void *, int);
	int (*dumpit)(struct wiphy *, struct wireless_dev *, struct sk_buff *, const void *, int, long unsigned int *);
	const struct nla_policy *policy;
	unsigned int maxattr;
};

struct wiphy_iftype_ext_capab {
	enum nl80211_iftype iftype;
	const u8 *extended_capabilities;
	const u8 *extended_capabilities_mask;
	u8 extended_capabilities_len;
};

struct cfg80211_pmsr_capabilities {
	unsigned int max_peers;
	u8 report_ap_tsf: 1;
	u8 randomize_mac_addr: 1;
	struct {
		u32 preambles;
		u32 bandwidths;
		s8 max_bursts_exponent;
		u8 max_ftms_per_burst;
		u8 supported: 1;
		u8 asap: 1;
		u8 non_asap: 1;
		u8 request_lci: 1;
		u8 request_civicloc: 1;
		u8 trigger_based: 1;
		u8 non_trigger_based: 1;
	} ftm;
};

struct wiphy_iftype_akm_suites {
	u16 iftypes_mask;
	const u32 *akm_suites;
	int n_akm_suites;
};

struct iw_ioctl_description {
	__u8 header_type;
	__u8 token_type;
	__u16 token_size;
	__u16 min_tokens;
	__u16 max_tokens;
	__u32 flags;
};

typedef int (*wext_ioctl_func)(struct net_device *, struct iwreq *, unsigned int, struct iw_request_info *, iw_handler);

struct iw_thrspy {
	struct sockaddr addr;
	struct iw_quality qual;
	struct iw_quality low;
	struct iw_quality high;
};

struct netlbl_af4list {
	__be32 addr;
	__be32 mask;
	u32 valid;
	struct list_head list;
};

struct netlbl_af6list {
	struct in6_addr addr;
	struct in6_addr mask;
	u32 valid;
	struct list_head list;
};

struct netlbl_domaddr_map {
	struct list_head list4;
	struct list_head list6;
};

struct netlbl_dommap_def {
	u32 type;
	union {
		struct netlbl_domaddr_map *addrsel;
		struct cipso_v4_doi *cipso;
		struct calipso_doi *calipso;
	};
};

struct netlbl_domaddr4_map {
	struct netlbl_dommap_def def;
	struct netlbl_af4list list;
};

struct netlbl_domaddr6_map {
	struct netlbl_dommap_def def;
	struct netlbl_af6list list;
};

struct netlbl_dom_map {
	char *domain;
	u16 family;
	struct netlbl_dommap_def def;
	u32 valid;
	struct list_head list;
	struct callback_head rcu;
};

struct netlbl_domhsh_tbl {
	struct list_head *tbl;
	u32 size;
};

enum {
	NLBL_MGMT_C_UNSPEC = 0,
	NLBL_MGMT_C_ADD = 1,
	NLBL_MGMT_C_REMOVE = 2,
	NLBL_MGMT_C_LISTALL = 3,
	NLBL_MGMT_C_ADDDEF = 4,
	NLBL_MGMT_C_REMOVEDEF = 5,
	NLBL_MGMT_C_LISTDEF = 6,
	NLBL_MGMT_C_PROTOCOLS = 7,
	NLBL_MGMT_C_VERSION = 8,
	__NLBL_MGMT_C_MAX = 9,
};

enum {
	NLBL_MGMT_A_UNSPEC = 0,
	NLBL_MGMT_A_DOMAIN = 1,
	NLBL_MGMT_A_PROTOCOL = 2,
	NLBL_MGMT_A_VERSION = 3,
	NLBL_MGMT_A_CV4DOI = 4,
	NLBL_MGMT_A_IPV6ADDR = 5,
	NLBL_MGMT_A_IPV6MASK = 6,
	NLBL_MGMT_A_IPV4ADDR = 7,
	NLBL_MGMT_A_IPV4MASK = 8,
	NLBL_MGMT_A_ADDRSELECTOR = 9,
	NLBL_MGMT_A_SELECTORLIST = 10,
	NLBL_MGMT_A_FAMILY = 11,
	NLBL_MGMT_A_CLPDOI = 12,
	__NLBL_MGMT_A_MAX = 13,
};

struct netlbl_domhsh_walk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

enum {
	NLBL_UNLABEL_C_UNSPEC = 0,
	NLBL_UNLABEL_C_ACCEPT = 1,
	NLBL_UNLABEL_C_LIST = 2,
	NLBL_UNLABEL_C_STATICADD = 3,
	NLBL_UNLABEL_C_STATICREMOVE = 4,
	NLBL_UNLABEL_C_STATICLIST = 5,
	NLBL_UNLABEL_C_STATICADDDEF = 6,
	NLBL_UNLABEL_C_STATICREMOVEDEF = 7,
	NLBL_UNLABEL_C_STATICLISTDEF = 8,
	__NLBL_UNLABEL_C_MAX = 9,
};

enum {
	NLBL_UNLABEL_A_UNSPEC = 0,
	NLBL_UNLABEL_A_ACPTFLG = 1,
	NLBL_UNLABEL_A_IPV6ADDR = 2,
	NLBL_UNLABEL_A_IPV6MASK = 3,
	NLBL_UNLABEL_A_IPV4ADDR = 4,
	NLBL_UNLABEL_A_IPV4MASK = 5,
	NLBL_UNLABEL_A_IFACE = 6,
	NLBL_UNLABEL_A_SECCTX = 7,
	__NLBL_UNLABEL_A_MAX = 8,
};

struct netlbl_unlhsh_tbl {
	struct list_head *tbl;
	u32 size;
};

struct netlbl_unlhsh_addr4 {
	struct lsmblob lsmblob;
	struct netlbl_af4list list;
	struct callback_head rcu;
};

struct netlbl_unlhsh_addr6 {
	struct lsmblob lsmblob;
	struct netlbl_af6list list;
	struct callback_head rcu;
};

struct netlbl_unlhsh_iface {
	int ifindex;
	struct list_head addr4_list;
	struct list_head addr6_list;
	u32 valid;
	struct list_head list;
	struct callback_head rcu;
};

struct netlbl_unlhsh_walk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

enum {
	NLBL_CIPSOV4_C_UNSPEC = 0,
	NLBL_CIPSOV4_C_ADD = 1,
	NLBL_CIPSOV4_C_REMOVE = 2,
	NLBL_CIPSOV4_C_LIST = 3,
	NLBL_CIPSOV4_C_LISTALL = 4,
	__NLBL_CIPSOV4_C_MAX = 5,
};

enum {
	NLBL_CIPSOV4_A_UNSPEC = 0,
	NLBL_CIPSOV4_A_DOI = 1,
	NLBL_CIPSOV4_A_MTYPE = 2,
	NLBL_CIPSOV4_A_TAG = 3,
	NLBL_CIPSOV4_A_TAGLST = 4,
	NLBL_CIPSOV4_A_MLSLVLLOC = 5,
	NLBL_CIPSOV4_A_MLSLVLREM = 6,
	NLBL_CIPSOV4_A_MLSLVL = 7,
	NLBL_CIPSOV4_A_MLSLVLLST = 8,
	NLBL_CIPSOV4_A_MLSCATLOC = 9,
	NLBL_CIPSOV4_A_MLSCATREM = 10,
	NLBL_CIPSOV4_A_MLSCAT = 11,
	NLBL_CIPSOV4_A_MLSCATLST = 12,
	__NLBL_CIPSOV4_A_MAX = 13,
};

struct netlbl_cipsov4_doiwalk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

struct netlbl_domhsh_walk_arg___2 {
	struct netlbl_audit *audit_info;
	u32 doi;
};

enum {
	NLBL_CALIPSO_C_UNSPEC = 0,
	NLBL_CALIPSO_C_ADD = 1,
	NLBL_CALIPSO_C_REMOVE = 2,
	NLBL_CALIPSO_C_LIST = 3,
	NLBL_CALIPSO_C_LISTALL = 4,
	__NLBL_CALIPSO_C_MAX = 5,
};

enum {
	NLBL_CALIPSO_A_UNSPEC = 0,
	NLBL_CALIPSO_A_DOI = 1,
	NLBL_CALIPSO_A_MTYPE = 2,
	__NLBL_CALIPSO_A_MAX = 3,
};

struct netlbl_calipso_doiwalk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

enum rfkill_type {
	RFKILL_TYPE_ALL = 0,
	RFKILL_TYPE_WLAN = 1,
	RFKILL_TYPE_BLUETOOTH = 2,
	RFKILL_TYPE_UWB = 3,
	RFKILL_TYPE_WIMAX = 4,
	RFKILL_TYPE_WWAN = 5,
	RFKILL_TYPE_GPS = 6,
	RFKILL_TYPE_FM = 7,
	RFKILL_TYPE_NFC = 8,
	NUM_RFKILL_TYPES = 9,
};

enum rfkill_operation {
	RFKILL_OP_ADD = 0,
	RFKILL_OP_DEL = 1,
	RFKILL_OP_CHANGE = 2,
	RFKILL_OP_CHANGE_ALL = 3,
};

enum rfkill_hard_block_reasons {
	RFKILL_HARD_BLOCK_SIGNAL = 1,
	RFKILL_HARD_BLOCK_NOT_OWNER = 2,
};

struct rfkill_event_ext {
	__u32 idx;
	__u8 type;
	__u8 op;
	__u8 soft;
	__u8 hard;
	__u8 hard_block_reasons;
} __attribute__((packed));

enum rfkill_user_states {
	RFKILL_USER_STATE_SOFT_BLOCKED = 0,
	RFKILL_USER_STATE_UNBLOCKED = 1,
	RFKILL_USER_STATE_HARD_BLOCKED = 2,
};

struct rfkill;

struct rfkill_ops {
	void (*poll)(struct rfkill *, void *);
	void (*query)(struct rfkill *, void *);
	int (*set_block)(void *, bool);
};

struct rfkill {
	spinlock_t lock;
	enum rfkill_type type;
	long unsigned int state;
	long unsigned int hard_block_reasons;
	u32 idx;
	bool registered;
	bool persistent;
	bool polling_paused;
	bool suspended;
	const struct rfkill_ops *ops;
	void *data;
	struct led_trigger led_trigger;
	const char *ledtrigname;
	struct device dev;
	struct list_head node;
	struct delayed_work poll_work;
	struct work_struct uevent_work;
	struct work_struct sync_work;
	char name[0];
};

struct rfkill_int_event {
	struct list_head list;
	struct rfkill_event_ext ev;
};

struct rfkill_data {
	struct list_head list;
	struct list_head events;
	struct mutex mtx;
	wait_queue_head_t read_wait;
	bool input_handler;
};

enum rfkill_input_master_mode {
	RFKILL_INPUT_MASTER_UNLOCK = 0,
	RFKILL_INPUT_MASTER_RESTORE = 1,
	RFKILL_INPUT_MASTER_UNBLOCKALL = 2,
	NUM_RFKILL_INPUT_MASTER_MODES = 3,
};

enum rfkill_sched_op {
	RFKILL_GLOBAL_OP_EPO = 0,
	RFKILL_GLOBAL_OP_RESTORE = 1,
	RFKILL_GLOBAL_OP_UNLOCK = 2,
	RFKILL_GLOBAL_OP_UNBLOCK = 3,
};

struct dcbmsg {
	__u8 dcb_family;
	__u8 cmd;
	__u16 dcb_pad;
};

enum dcbnl_commands {
	DCB_CMD_UNDEFINED = 0,
	DCB_CMD_GSTATE = 1,
	DCB_CMD_SSTATE = 2,
	DCB_CMD_PGTX_GCFG = 3,
	DCB_CMD_PGTX_SCFG = 4,
	DCB_CMD_PGRX_GCFG = 5,
	DCB_CMD_PGRX_SCFG = 6,
	DCB_CMD_PFC_GCFG = 7,
	DCB_CMD_PFC_SCFG = 8,
	DCB_CMD_SET_ALL = 9,
	DCB_CMD_GPERM_HWADDR = 10,
	DCB_CMD_GCAP = 11,
	DCB_CMD_GNUMTCS = 12,
	DCB_CMD_SNUMTCS = 13,
	DCB_CMD_PFC_GSTATE = 14,
	DCB_CMD_PFC_SSTATE = 15,
	DCB_CMD_BCN_GCFG = 16,
	DCB_CMD_BCN_SCFG = 17,
	DCB_CMD_GAPP = 18,
	DCB_CMD_SAPP = 19,
	DCB_CMD_IEEE_SET = 20,
	DCB_CMD_IEEE_GET = 21,
	DCB_CMD_GDCBX = 22,
	DCB_CMD_SDCBX = 23,
	DCB_CMD_GFEATCFG = 24,
	DCB_CMD_SFEATCFG = 25,
	DCB_CMD_CEE_GET = 26,
	DCB_CMD_IEEE_DEL = 27,
	__DCB_CMD_ENUM_MAX = 28,
	DCB_CMD_MAX = 27,
};

enum dcbnl_attrs {
	DCB_ATTR_UNDEFINED = 0,
	DCB_ATTR_IFNAME = 1,
	DCB_ATTR_STATE = 2,
	DCB_ATTR_PFC_STATE = 3,
	DCB_ATTR_PFC_CFG = 4,
	DCB_ATTR_NUM_TC = 5,
	DCB_ATTR_PG_CFG = 6,
	DCB_ATTR_SET_ALL = 7,
	DCB_ATTR_PERM_HWADDR = 8,
	DCB_ATTR_CAP = 9,
	DCB_ATTR_NUMTCS = 10,
	DCB_ATTR_BCN = 11,
	DCB_ATTR_APP = 12,
	DCB_ATTR_IEEE = 13,
	DCB_ATTR_DCBX = 14,
	DCB_ATTR_FEATCFG = 15,
	DCB_ATTR_CEE = 16,
	__DCB_ATTR_ENUM_MAX = 17,
	DCB_ATTR_MAX = 16,
};

enum ieee_attrs {
	DCB_ATTR_IEEE_UNSPEC = 0,
	DCB_ATTR_IEEE_ETS = 1,
	DCB_ATTR_IEEE_PFC = 2,
	DCB_ATTR_IEEE_APP_TABLE = 3,
	DCB_ATTR_IEEE_PEER_ETS = 4,
	DCB_ATTR_IEEE_PEER_PFC = 5,
	DCB_ATTR_IEEE_PEER_APP = 6,
	DCB_ATTR_IEEE_MAXRATE = 7,
	DCB_ATTR_IEEE_QCN = 8,
	DCB_ATTR_IEEE_QCN_STATS = 9,
	DCB_ATTR_DCB_BUFFER = 10,
	__DCB_ATTR_IEEE_MAX = 11,
};

enum ieee_attrs_app {
	DCB_ATTR_IEEE_APP_UNSPEC = 0,
	DCB_ATTR_IEEE_APP = 1,
	__DCB_ATTR_IEEE_APP_MAX = 2,
};

enum cee_attrs {
	DCB_ATTR_CEE_UNSPEC = 0,
	DCB_ATTR_CEE_PEER_PG = 1,
	DCB_ATTR_CEE_PEER_PFC = 2,
	DCB_ATTR_CEE_PEER_APP_TABLE = 3,
	DCB_ATTR_CEE_TX_PG = 4,
	DCB_ATTR_CEE_RX_PG = 5,
	DCB_ATTR_CEE_PFC = 6,
	DCB_ATTR_CEE_APP_TABLE = 7,
	DCB_ATTR_CEE_FEAT = 8,
	__DCB_ATTR_CEE_MAX = 9,
};

enum peer_app_attr {
	DCB_ATTR_CEE_PEER_APP_UNSPEC = 0,
	DCB_ATTR_CEE_PEER_APP_INFO = 1,
	DCB_ATTR_CEE_PEER_APP = 2,
	__DCB_ATTR_CEE_PEER_APP_MAX = 3,
};

enum dcbnl_pfc_up_attrs {
	DCB_PFC_UP_ATTR_UNDEFINED = 0,
	DCB_PFC_UP_ATTR_0 = 1,
	DCB_PFC_UP_ATTR_1 = 2,
	DCB_PFC_UP_ATTR_2 = 3,
	DCB_PFC_UP_ATTR_3 = 4,
	DCB_PFC_UP_ATTR_4 = 5,
	DCB_PFC_UP_ATTR_5 = 6,
	DCB_PFC_UP_ATTR_6 = 7,
	DCB_PFC_UP_ATTR_7 = 8,
	DCB_PFC_UP_ATTR_ALL = 9,
	__DCB_PFC_UP_ATTR_ENUM_MAX = 10,
	DCB_PFC_UP_ATTR_MAX = 9,
};

enum dcbnl_pg_attrs {
	DCB_PG_ATTR_UNDEFINED = 0,
	DCB_PG_ATTR_TC_0 = 1,
	DCB_PG_ATTR_TC_1 = 2,
	DCB_PG_ATTR_TC_2 = 3,
	DCB_PG_ATTR_TC_3 = 4,
	DCB_PG_ATTR_TC_4 = 5,
	DCB_PG_ATTR_TC_5 = 6,
	DCB_PG_ATTR_TC_6 = 7,
	DCB_PG_ATTR_TC_7 = 8,
	DCB_PG_ATTR_TC_MAX = 9,
	DCB_PG_ATTR_TC_ALL = 10,
	DCB_PG_ATTR_BW_ID_0 = 11,
	DCB_PG_ATTR_BW_ID_1 = 12,
	DCB_PG_ATTR_BW_ID_2 = 13,
	DCB_PG_ATTR_BW_ID_3 = 14,
	DCB_PG_ATTR_BW_ID_4 = 15,
	DCB_PG_ATTR_BW_ID_5 = 16,
	DCB_PG_ATTR_BW_ID_6 = 17,
	DCB_PG_ATTR_BW_ID_7 = 18,
	DCB_PG_ATTR_BW_ID_MAX = 19,
	DCB_PG_ATTR_BW_ID_ALL = 20,
	__DCB_PG_ATTR_ENUM_MAX = 21,
	DCB_PG_ATTR_MAX = 20,
};

enum dcbnl_tc_attrs {
	DCB_TC_ATTR_PARAM_UNDEFINED = 0,
	DCB_TC_ATTR_PARAM_PGID = 1,
	DCB_TC_ATTR_PARAM_UP_MAPPING = 2,
	DCB_TC_ATTR_PARAM_STRICT_PRIO = 3,
	DCB_TC_ATTR_PARAM_BW_PCT = 4,
	DCB_TC_ATTR_PARAM_ALL = 5,
	__DCB_TC_ATTR_PARAM_ENUM_MAX = 6,
	DCB_TC_ATTR_PARAM_MAX = 5,
};

enum dcbnl_cap_attrs {
	DCB_CAP_ATTR_UNDEFINED = 0,
	DCB_CAP_ATTR_ALL = 1,
	DCB_CAP_ATTR_PG = 2,
	DCB_CAP_ATTR_PFC = 3,
	DCB_CAP_ATTR_UP2TC = 4,
	DCB_CAP_ATTR_PG_TCS = 5,
	DCB_CAP_ATTR_PFC_TCS = 6,
	DCB_CAP_ATTR_GSP = 7,
	DCB_CAP_ATTR_BCN = 8,
	DCB_CAP_ATTR_DCBX = 9,
	__DCB_CAP_ATTR_ENUM_MAX = 10,
	DCB_CAP_ATTR_MAX = 9,
};

enum dcbnl_numtcs_attrs {
	DCB_NUMTCS_ATTR_UNDEFINED = 0,
	DCB_NUMTCS_ATTR_ALL = 1,
	DCB_NUMTCS_ATTR_PG = 2,
	DCB_NUMTCS_ATTR_PFC = 3,
	__DCB_NUMTCS_ATTR_ENUM_MAX = 4,
	DCB_NUMTCS_ATTR_MAX = 3,
};

enum dcbnl_bcn_attrs {
	DCB_BCN_ATTR_UNDEFINED = 0,
	DCB_BCN_ATTR_RP_0 = 1,
	DCB_BCN_ATTR_RP_1 = 2,
	DCB_BCN_ATTR_RP_2 = 3,
	DCB_BCN_ATTR_RP_3 = 4,
	DCB_BCN_ATTR_RP_4 = 5,
	DCB_BCN_ATTR_RP_5 = 6,
	DCB_BCN_ATTR_RP_6 = 7,
	DCB_BCN_ATTR_RP_7 = 8,
	DCB_BCN_ATTR_RP_ALL = 9,
	DCB_BCN_ATTR_BCNA_0 = 10,
	DCB_BCN_ATTR_BCNA_1 = 11,
	DCB_BCN_ATTR_ALPHA = 12,
	DCB_BCN_ATTR_BETA = 13,
	DCB_BCN_ATTR_GD = 14,
	DCB_BCN_ATTR_GI = 15,
	DCB_BCN_ATTR_TMAX = 16,
	DCB_BCN_ATTR_TD = 17,
	DCB_BCN_ATTR_RMIN = 18,
	DCB_BCN_ATTR_W = 19,
	DCB_BCN_ATTR_RD = 20,
	DCB_BCN_ATTR_RU = 21,
	DCB_BCN_ATTR_WRTT = 22,
	DCB_BCN_ATTR_RI = 23,
	DCB_BCN_ATTR_C = 24,
	DCB_BCN_ATTR_ALL = 25,
	__DCB_BCN_ATTR_ENUM_MAX = 26,
	DCB_BCN_ATTR_MAX = 25,
};

enum dcb_general_attr_values {
	DCB_ATTR_VALUE_UNDEFINED = 255,
};

enum dcbnl_app_attrs {
	DCB_APP_ATTR_UNDEFINED = 0,
	DCB_APP_ATTR_IDTYPE = 1,
	DCB_APP_ATTR_ID = 2,
	DCB_APP_ATTR_PRIORITY = 3,
	__DCB_APP_ATTR_ENUM_MAX = 4,
	DCB_APP_ATTR_MAX = 3,
};

enum dcbnl_featcfg_attrs {
	DCB_FEATCFG_ATTR_UNDEFINED = 0,
	DCB_FEATCFG_ATTR_ALL = 1,
	DCB_FEATCFG_ATTR_PG = 2,
	DCB_FEATCFG_ATTR_PFC = 3,
	DCB_FEATCFG_ATTR_APP = 4,
	__DCB_FEATCFG_ATTR_ENUM_MAX = 5,
	DCB_FEATCFG_ATTR_MAX = 4,
};

struct dcb_app_type {
	int ifindex;
	struct dcb_app app;
	struct list_head list;
	u8 dcbx;
};

struct dcb_ieee_app_prio_map {
	u64 map[8];
};

struct dcb_ieee_app_dscp_map {
	u8 map[64];
};

enum dcbevent_notif_type {
	DCB_APP_EVENT = 1,
};

struct reply_func {
	int type;
	int (*cb)(struct net_device *, struct nlmsghdr *, u32, struct nlattr **, struct sk_buff *);
};

enum dns_payload_content_type {
	DNS_PAYLOAD_IS_SERVER_LIST = 0,
};

struct dns_payload_header {
	__u8 zero;
	__u8 content;
	__u8 version;
};

enum {
	dns_key_data = 0,
	dns_key_error = 1,
};

enum switchdev_attr_id {
	SWITCHDEV_ATTR_ID_UNDEFINED = 0,
	SWITCHDEV_ATTR_ID_PORT_STP_STATE = 1,
	SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS = 2,
	SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS = 3,
	SWITCHDEV_ATTR_ID_PORT_MROUTER = 4,
	SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME = 5,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING = 6,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_PROTOCOL = 7,
	SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED = 8,
	SWITCHDEV_ATTR_ID_BRIDGE_MROUTER = 9,
	SWITCHDEV_ATTR_ID_MRP_PORT_ROLE = 10,
};

struct switchdev_attr {
	struct net_device *orig_dev;
	enum switchdev_attr_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
	union {
		u8 stp_state;
		struct switchdev_brport_flags brport_flags;
		bool mrouter;
		clock_t ageing_time;
		bool vlan_filtering;
		u16 vlan_protocol;
		bool mc_disabled;
		u8 mrp_port_role;
	} u;
};

enum switchdev_notifier_type {
	SWITCHDEV_FDB_ADD_TO_BRIDGE = 1,
	SWITCHDEV_FDB_DEL_TO_BRIDGE = 2,
	SWITCHDEV_FDB_ADD_TO_DEVICE = 3,
	SWITCHDEV_FDB_DEL_TO_DEVICE = 4,
	SWITCHDEV_FDB_OFFLOADED = 5,
	SWITCHDEV_FDB_FLUSH_TO_BRIDGE = 6,
	SWITCHDEV_PORT_OBJ_ADD = 7,
	SWITCHDEV_PORT_OBJ_DEL = 8,
	SWITCHDEV_PORT_ATTR_SET = 9,
	SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE = 10,
	SWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE = 11,
	SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE = 12,
	SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE = 13,
	SWITCHDEV_VXLAN_FDB_OFFLOADED = 14,
};

struct switchdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct switchdev_notifier_port_obj_info {
	struct switchdev_notifier_info info;
	const struct switchdev_obj *obj;
	bool handled;
};

struct switchdev_notifier_port_attr_info {
	struct switchdev_notifier_info info;
	const struct switchdev_attr *attr;
	bool handled;
};

typedef void switchdev_deferred_func_t(struct net_device *, const void *);

struct switchdev_deferred_item {
	struct list_head list;
	struct net_device *dev;
	switchdev_deferred_func_t *func;
	long unsigned int data[0];
};

typedef int (*lookup_by_table_id_t)(struct net *, u32);

struct l3mdev_handler {
	lookup_by_table_id_t dev_lookup;
};

struct ncsi_dev {
	int state;
	int link_up;
	struct net_device *dev;
	void (*handler)(struct ncsi_dev *);
};

struct ncsi_channel_version {
	u32 version;
	u32 alpha2;
	u8 fw_name[12];
	u32 fw_version;
	u16 pci_ids[4];
	u32 mf_id;
};

struct ncsi_channel_cap {
	u32 index;
	u32 cap;
};

struct ncsi_channel_mode {
	u32 index;
	u32 enable;
	u32 size;
	u32 data[8];
};

struct ncsi_channel_mac_filter {
	u8 n_uc;
	u8 n_mc;
	u8 n_mixed;
	u64 bitmap;
	unsigned char *addrs;
};

struct ncsi_channel_vlan_filter {
	u8 n_vids;
	u64 bitmap;
	u16 *vids;
};

struct ncsi_channel_stats {
	u32 hnc_cnt_hi;
	u32 hnc_cnt_lo;
	u32 hnc_rx_bytes;
	u32 hnc_tx_bytes;
	u32 hnc_rx_uc_pkts;
	u32 hnc_rx_mc_pkts;
	u32 hnc_rx_bc_pkts;
	u32 hnc_tx_uc_pkts;
	u32 hnc_tx_mc_pkts;
	u32 hnc_tx_bc_pkts;
	u32 hnc_fcs_err;
	u32 hnc_align_err;
	u32 hnc_false_carrier;
	u32 hnc_runt_pkts;
	u32 hnc_jabber_pkts;
	u32 hnc_rx_pause_xon;
	u32 hnc_rx_pause_xoff;
	u32 hnc_tx_pause_xon;
	u32 hnc_tx_pause_xoff;
	u32 hnc_tx_s_collision;
	u32 hnc_tx_m_collision;
	u32 hnc_l_collision;
	u32 hnc_e_collision;
	u32 hnc_rx_ctl_frames;
	u32 hnc_rx_64_frames;
	u32 hnc_rx_127_frames;
	u32 hnc_rx_255_frames;
	u32 hnc_rx_511_frames;
	u32 hnc_rx_1023_frames;
	u32 hnc_rx_1522_frames;
	u32 hnc_rx_9022_frames;
	u32 hnc_tx_64_frames;
	u32 hnc_tx_127_frames;
	u32 hnc_tx_255_frames;
	u32 hnc_tx_511_frames;
	u32 hnc_tx_1023_frames;
	u32 hnc_tx_1522_frames;
	u32 hnc_tx_9022_frames;
	u32 hnc_rx_valid_bytes;
	u32 hnc_rx_runt_pkts;
	u32 hnc_rx_jabber_pkts;
	u32 ncsi_rx_cmds;
	u32 ncsi_dropped_cmds;
	u32 ncsi_cmd_type_errs;
	u32 ncsi_cmd_csum_errs;
	u32 ncsi_rx_pkts;
	u32 ncsi_tx_pkts;
	u32 ncsi_tx_aen_pkts;
	u32 pt_tx_pkts;
	u32 pt_tx_dropped;
	u32 pt_tx_channel_err;
	u32 pt_tx_us_err;
	u32 pt_rx_pkts;
	u32 pt_rx_dropped;
	u32 pt_rx_channel_err;
	u32 pt_rx_us_err;
	u32 pt_rx_os_err;
};

struct ncsi_package;

struct ncsi_channel {
	unsigned char id;
	int state;
	bool reconfigure_needed;
	spinlock_t lock;
	struct ncsi_package *package;
	struct ncsi_channel_version version;
	struct ncsi_channel_cap caps[6];
	struct ncsi_channel_mode modes[8];
	struct ncsi_channel_mac_filter mac_filter;
	struct ncsi_channel_vlan_filter vlan_filter;
	struct ncsi_channel_stats stats;
	struct {
		struct timer_list timer;
		bool enabled;
		unsigned int state;
	} monitor;
	struct list_head node;
	struct list_head link;
};

struct ncsi_dev_priv;

struct ncsi_package {
	unsigned char id;
	unsigned char uuid[16];
	struct ncsi_dev_priv *ndp;
	spinlock_t lock;
	unsigned int channel_num;
	struct list_head channels;
	struct list_head node;
	bool multi_channel;
	u32 channel_whitelist;
	struct ncsi_channel *preferred_channel;
};

struct ncsi_request {
	unsigned char id;
	bool used;
	unsigned int flags;
	struct ncsi_dev_priv *ndp;
	struct sk_buff *cmd;
	struct sk_buff *rsp;
	struct timer_list timer;
	bool enabled;
	u32 snd_seq;
	u32 snd_portid;
	struct nlmsghdr nlhdr;
};

struct ncsi_dev_priv {
	struct ncsi_dev ndev;
	unsigned int flags;
	unsigned int gma_flag;
	spinlock_t lock;
	unsigned int package_probe_id;
	unsigned int package_num;
	struct list_head packages;
	struct ncsi_channel *hot_channel;
	struct ncsi_request requests[256];
	unsigned int request_id;
	unsigned int pending_req_num;
	struct ncsi_package *active_package;
	struct ncsi_channel *active_channel;
	struct list_head channel_queue;
	struct work_struct work;
	struct packet_type ptype;
	struct list_head node;
	struct list_head vlan_vids;
	bool multi_package;
	bool mlx_multi_host;
	u32 package_whitelist;
};

struct ncsi_cmd_arg {
	struct ncsi_dev_priv *ndp;
	unsigned char type;
	unsigned char id;
	unsigned char package;
	unsigned char channel;
	short unsigned int payload;
	unsigned int req_flags;
	union {
		unsigned char bytes[16];
		short unsigned int words[8];
		unsigned int dwords[4];
	};
	unsigned char *data;
	struct genl_info *info;
};

struct ncsi_pkt_hdr {
	unsigned char mc_id;
	unsigned char revision;
	unsigned char reserved;
	unsigned char id;
	unsigned char type;
	unsigned char channel;
	__be16 length;
	__be32 reserved1[2];
};

struct ncsi_cmd_pkt_hdr {
	struct ncsi_pkt_hdr common;
};

struct ncsi_cmd_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	__be32 checksum;
	unsigned char pad[26];
};

struct ncsi_cmd_sp_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	unsigned char reserved[3];
	unsigned char hw_arbitration;
	__be32 checksum;
	unsigned char pad[22];
};

struct ncsi_cmd_dc_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	unsigned char reserved[3];
	unsigned char ald;
	__be32 checksum;
	unsigned char pad[22];
};

struct ncsi_cmd_rc_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	__be32 reserved;
	__be32 checksum;
	unsigned char pad[22];
};

struct ncsi_cmd_ae_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	unsigned char reserved[3];
	unsigned char mc_id;
	__be32 mode;
	__be32 checksum;
	unsigned char pad[18];
};

struct ncsi_cmd_sl_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	__be32 mode;
	__be32 oem_mode;
	__be32 checksum;
	unsigned char pad[18];
};

struct ncsi_cmd_svf_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	__be16 reserved;
	__be16 vlan;
	__be16 reserved1;
	unsigned char index;
	unsigned char enable;
	__be32 checksum;
	unsigned char pad[18];
};

struct ncsi_cmd_ev_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	unsigned char reserved[3];
	unsigned char mode;
	__be32 checksum;
	unsigned char pad[22];
};

struct ncsi_cmd_sma_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	unsigned char mac[6];
	unsigned char index;
	unsigned char at_e;
	__be32 checksum;
	unsigned char pad[18];
};

struct ncsi_cmd_ebf_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	__be32 mode;
	__be32 checksum;
	unsigned char pad[22];
};

struct ncsi_cmd_egmf_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	__be32 mode;
	__be32 checksum;
	unsigned char pad[22];
};

struct ncsi_cmd_snfc_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	unsigned char reserved[3];
	unsigned char mode;
	__be32 checksum;
	unsigned char pad[22];
};

struct ncsi_cmd_oem_pkt {
	struct ncsi_cmd_pkt_hdr cmd;
	__be32 mfr_id;
	unsigned char data[0];
};

struct ncsi_cmd_handler {
	unsigned char type;
	int payload;
	int (*handler)(struct sk_buff *, struct ncsi_cmd_arg *);
};

enum {
	NCSI_CAP_BASE = 0,
	NCSI_CAP_GENERIC = 0,
	NCSI_CAP_BC = 1,
	NCSI_CAP_MC = 2,
	NCSI_CAP_BUFFER = 3,
	NCSI_CAP_AEN = 4,
	NCSI_CAP_VLAN = 5,
	NCSI_CAP_MAX = 6,
};

enum {
	NCSI_CAP_GENERIC_HWA = 1,
	NCSI_CAP_GENERIC_HDS = 2,
	NCSI_CAP_GENERIC_FC = 4,
	NCSI_CAP_GENERIC_FC1 = 8,
	NCSI_CAP_GENERIC_MC = 16,
	NCSI_CAP_GENERIC_HWA_UNKNOWN = 0,
	NCSI_CAP_GENERIC_HWA_SUPPORT = 32,
	NCSI_CAP_GENERIC_HWA_NOT_SUPPORT = 64,
	NCSI_CAP_GENERIC_HWA_RESERVED = 96,
	NCSI_CAP_GENERIC_HWA_MASK = 96,
	NCSI_CAP_GENERIC_MASK = 127,
	NCSI_CAP_BC_ARP = 1,
	NCSI_CAP_BC_DHCPC = 2,
	NCSI_CAP_BC_DHCPS = 4,
	NCSI_CAP_BC_NETBIOS = 8,
	NCSI_CAP_BC_MASK = 15,
	NCSI_CAP_MC_IPV6_NEIGHBOR = 1,
	NCSI_CAP_MC_IPV6_ROUTER = 2,
	NCSI_CAP_MC_DHCPV6_RELAY = 4,
	NCSI_CAP_MC_DHCPV6_WELL_KNOWN = 8,
	NCSI_CAP_MC_IPV6_MLD = 16,
	NCSI_CAP_MC_IPV6_NEIGHBOR_S = 32,
	NCSI_CAP_MC_MASK = 63,
	NCSI_CAP_AEN_LSC = 1,
	NCSI_CAP_AEN_CR = 2,
	NCSI_CAP_AEN_HDS = 4,
	NCSI_CAP_AEN_MASK = 7,
	NCSI_CAP_VLAN_ONLY = 1,
	NCSI_CAP_VLAN_NO = 2,
	NCSI_CAP_VLAN_ANY = 4,
	NCSI_CAP_VLAN_MASK = 7,
};

enum {
	NCSI_MODE_BASE = 0,
	NCSI_MODE_ENABLE = 0,
	NCSI_MODE_TX_ENABLE = 1,
	NCSI_MODE_LINK = 2,
	NCSI_MODE_VLAN = 3,
	NCSI_MODE_BC = 4,
	NCSI_MODE_MC = 5,
	NCSI_MODE_AEN = 6,
	NCSI_MODE_FC = 7,
	NCSI_MODE_MAX = 8,
};

struct ncsi_rsp_pkt_hdr {
	struct ncsi_pkt_hdr common;
	__be16 code;
	__be16 reason;
};

struct ncsi_rsp_pkt {
	struct ncsi_rsp_pkt_hdr rsp;
	__be32 checksum;
	unsigned char pad[22];
};

struct ncsi_rsp_oem_pkt {
	struct ncsi_rsp_pkt_hdr rsp;
	__be32 mfr_id;
	unsigned char data[0];
};

struct ncsi_rsp_oem_mlx_pkt {
	unsigned char cmd_rev;
	unsigned char cmd;
	unsigned char param;
	unsigned char optional;
	unsigned char data[0];
};

struct ncsi_rsp_oem_bcm_pkt {
	unsigned char ver;
	unsigned char type;
	__be16 len;
	unsigned char data[0];
};

struct ncsi_rsp_gls_pkt {
	struct ncsi_rsp_pkt_hdr rsp;
	__be32 status;
	__be32 other;
	__be32 oem_status;
	__be32 checksum;
	unsigned char pad[10];
};

struct ncsi_rsp_gvi_pkt {
	struct ncsi_rsp_pkt_hdr rsp;
	__be32 ncsi_version;
	unsigned char reserved[3];
	unsigned char alpha2;
	unsigned char fw_name[12];
	__be32 fw_version;
	__be16 pci_ids[4];
	__be32 mf_id;
	__be32 checksum;
};

struct ncsi_rsp_gc_pkt {
	struct ncsi_rsp_pkt_hdr rsp;
	__be32 cap;
	__be32 bc_cap;
	__be32 mc_cap;
	__be32 buf_cap;
	__be32 aen_cap;
	unsigned char vlan_cnt;
	unsigned char mixed_cnt;
	unsigned char mc_cnt;
	unsigned char uc_cnt;
	unsigned char reserved[2];
	unsigned char vlan_mode;
	unsigned char channel_cnt;
	__be32 checksum;
};

struct ncsi_rsp_gp_pkt {
	struct ncsi_rsp_pkt_hdr rsp;
	unsigned char mac_cnt;
	unsigned char reserved[2];
	unsigned char mac_enable;
	unsigned char vlan_cnt;
	unsigned char reserved1;
	__be16 vlan_enable;
	__be32 link_mode;
	__be32 bc_mode;
	__be32 valid_modes;
	unsigned char vlan_mode;
	unsigned char fc_mode;
	unsigned char reserved2[2];
	__be32 aen_mode;
	unsigned char mac[6];
	__be16 vlan;
	__be32 checksum;
};

struct ncsi_rsp_gcps_pkt {
	struct ncsi_rsp_pkt_hdr rsp;
	__be32 cnt_hi;
	__be32 cnt_lo;
	__be32 rx_bytes;
	__be32 tx_bytes;
	__be32 rx_uc_pkts;
	__be32 rx_mc_pkts;
	__be32 rx_bc_pkts;
	__be32 tx_uc_pkts;
	__be32 tx_mc_pkts;
	__be32 tx_bc_pkts;
	__be32 fcs_err;
	__be32 align_err;
	__be32 false_carrier;
	__be32 runt_pkts;
	__be32 jabber_pkts;
	__be32 rx_pause_xon;
	__be32 rx_pause_xoff;
	__be32 tx_pause_xon;
	__be32 tx_pause_xoff;
	__be32 tx_s_collision;
	__be32 tx_m_collision;
	__be32 l_collision;
	__be32 e_collision;
	__be32 rx_ctl_frames;
	__be32 rx_64_frames;
	__be32 rx_127_frames;
	__be32 rx_255_frames;
	__be32 rx_511_frames;
	__be32 rx_1023_frames;
	__be32 rx_1522_frames;
	__be32 rx_9022_frames;
	__be32 tx_64_frames;
	__be32 tx_127_frames;
	__be32 tx_255_frames;
	__be32 tx_511_frames;
	__be32 tx_1023_frames;
	__be32 tx_1522_frames;
	__be32 tx_9022_frames;
	__be32 rx_valid_bytes;
	__be32 rx_runt_pkts;
	__be32 rx_jabber_pkts;
	__be32 checksum;
};

struct ncsi_rsp_gns_pkt {
	struct ncsi_rsp_pkt_hdr rsp;
	__be32 rx_cmds;
	__be32 dropped_cmds;
	__be32 cmd_type_errs;
	__be32 cmd_csum_errs;
	__be32 rx_pkts;
	__be32 tx_pkts;
	__be32 tx_aen_pkts;
	__be32 checksum;
};

struct ncsi_rsp_gnpts_pkt {
	struct ncsi_rsp_pkt_hdr rsp;
	__be32 tx_pkts;
	__be32 tx_dropped;
	__be32 tx_channel_err;
	__be32 tx_us_err;
	__be32 rx_pkts;
	__be32 rx_dropped;
	__be32 rx_channel_err;
	__be32 rx_us_err;
	__be32 rx_os_err;
	__be32 checksum;
};

struct ncsi_rsp_gps_pkt {
	struct ncsi_rsp_pkt_hdr rsp;
	__be32 status;
	__be32 checksum;
};

struct ncsi_rsp_gpuuid_pkt {
	struct ncsi_rsp_pkt_hdr rsp;
	unsigned char uuid[16];
	__be32 checksum;
};

struct ncsi_rsp_oem_handler {
	unsigned int mfr_id;
	int (*handler)(struct ncsi_request *);
};

struct ncsi_rsp_handler {
	unsigned char type;
	int payload;
	int (*handler)(struct ncsi_request *);
};

struct ncsi_aen_pkt_hdr {
	struct ncsi_pkt_hdr common;
	unsigned char reserved2[3];
	unsigned char type;
};

struct ncsi_aen_lsc_pkt {
	struct ncsi_aen_pkt_hdr aen;
	__be32 status;
	__be32 oem_status;
	__be32 checksum;
	unsigned char pad[14];
};

struct ncsi_aen_hncdsc_pkt {
	struct ncsi_aen_pkt_hdr aen;
	__be32 status;
	__be32 checksum;
	unsigned char pad[18];
};

struct ncsi_aen_handler {
	unsigned char type;
	int payload;
	int (*handler)(struct ncsi_dev_priv *, struct ncsi_aen_pkt_hdr *);
};

enum {
	ncsi_dev_state_registered = 0,
	ncsi_dev_state_functional = 256,
	ncsi_dev_state_probe = 512,
	ncsi_dev_state_config = 768,
	ncsi_dev_state_suspend = 1024,
};

enum {
	MLX_MC_RBT_SUPPORT = 1,
	MLX_MC_RBT_AVL = 8,
};

enum {
	ncsi_dev_state_major = 65280,
	ncsi_dev_state_minor = 255,
	ncsi_dev_state_probe_deselect = 513,
	ncsi_dev_state_probe_package = 514,
	ncsi_dev_state_probe_channel = 515,
	ncsi_dev_state_probe_mlx_gma = 516,
	ncsi_dev_state_probe_mlx_smaf = 517,
	ncsi_dev_state_probe_cis = 518,
	ncsi_dev_state_probe_gvi = 519,
	ncsi_dev_state_probe_gc = 520,
	ncsi_dev_state_probe_gls = 521,
	ncsi_dev_state_probe_dp = 522,
	ncsi_dev_state_config_sp = 769,
	ncsi_dev_state_config_cis = 770,
	ncsi_dev_state_config_oem_gma = 771,
	ncsi_dev_state_config_clear_vids = 772,
	ncsi_dev_state_config_svf = 773,
	ncsi_dev_state_config_ev = 774,
	ncsi_dev_state_config_sma = 775,
	ncsi_dev_state_config_ebf = 776,
	ncsi_dev_state_config_dgmf = 777,
	ncsi_dev_state_config_ecnt = 778,
	ncsi_dev_state_config_ec = 779,
	ncsi_dev_state_config_ae = 780,
	ncsi_dev_state_config_gls = 781,
	ncsi_dev_state_config_done = 782,
	ncsi_dev_state_suspend_select = 1025,
	ncsi_dev_state_suspend_gls = 1026,
	ncsi_dev_state_suspend_dcnt = 1027,
	ncsi_dev_state_suspend_dc = 1028,
	ncsi_dev_state_suspend_deselect = 1029,
	ncsi_dev_state_suspend_done = 1030,
};

struct vlan_vid {
	struct list_head list;
	__be16 proto;
	u16 vid;
};

struct ncsi_oem_gma_handler {
	unsigned int mfr_id;
	int (*handler)(struct ncsi_cmd_arg *);
};

enum ncsi_nl_commands {
	NCSI_CMD_UNSPEC = 0,
	NCSI_CMD_PKG_INFO = 1,
	NCSI_CMD_SET_INTERFACE = 2,
	NCSI_CMD_CLEAR_INTERFACE = 3,
	NCSI_CMD_SEND_CMD = 4,
	NCSI_CMD_SET_PACKAGE_MASK = 5,
	NCSI_CMD_SET_CHANNEL_MASK = 6,
	__NCSI_CMD_AFTER_LAST = 7,
	NCSI_CMD_MAX = 6,
};

enum ncsi_nl_attrs {
	NCSI_ATTR_UNSPEC = 0,
	NCSI_ATTR_IFINDEX = 1,
	NCSI_ATTR_PACKAGE_LIST = 2,
	NCSI_ATTR_PACKAGE_ID = 3,
	NCSI_ATTR_CHANNEL_ID = 4,
	NCSI_ATTR_DATA = 5,
	NCSI_ATTR_MULTI_FLAG = 6,
	NCSI_ATTR_PACKAGE_MASK = 7,
	NCSI_ATTR_CHANNEL_MASK = 8,
	__NCSI_ATTR_AFTER_LAST = 9,
	NCSI_ATTR_MAX = 8,
};

enum ncsi_nl_pkg_attrs {
	NCSI_PKG_ATTR_UNSPEC = 0,
	NCSI_PKG_ATTR = 1,
	NCSI_PKG_ATTR_ID = 2,
	NCSI_PKG_ATTR_FORCED = 3,
	NCSI_PKG_ATTR_CHANNEL_LIST = 4,
	__NCSI_PKG_ATTR_AFTER_LAST = 5,
	NCSI_PKG_ATTR_MAX = 4,
};

enum ncsi_nl_channel_attrs {
	NCSI_CHANNEL_ATTR_UNSPEC = 0,
	NCSI_CHANNEL_ATTR = 1,
	NCSI_CHANNEL_ATTR_ID = 2,
	NCSI_CHANNEL_ATTR_VERSION_MAJOR = 3,
	NCSI_CHANNEL_ATTR_VERSION_MINOR = 4,
	NCSI_CHANNEL_ATTR_VERSION_STR = 5,
	NCSI_CHANNEL_ATTR_LINK_STATE = 6,
	NCSI_CHANNEL_ATTR_ACTIVE = 7,
	NCSI_CHANNEL_ATTR_FORCED = 8,
	NCSI_CHANNEL_ATTR_VLAN_LIST = 9,
	NCSI_CHANNEL_ATTR_VLAN_ID = 10,
	__NCSI_CHANNEL_ATTR_AFTER_LAST = 11,
	NCSI_CHANNEL_ATTR_MAX = 10,
};

struct sockaddr_xdp {
	__u16 sxdp_family;
	__u16 sxdp_flags;
	__u32 sxdp_ifindex;
	__u32 sxdp_queue_id;
	__u32 sxdp_shared_umem_fd;
};

struct xdp_ring_offset {
	__u64 producer;
	__u64 consumer;
	__u64 desc;
	__u64 flags;
};

struct xdp_mmap_offsets {
	struct xdp_ring_offset rx;
	struct xdp_ring_offset tx;
	struct xdp_ring_offset fr;
	struct xdp_ring_offset cr;
};

struct xdp_umem_reg {
	__u64 addr;
	__u64 len;
	__u32 chunk_size;
	__u32 headroom;
	__u32 flags;
};

struct xdp_statistics {
	__u64 rx_dropped;
	__u64 rx_invalid_descs;
	__u64 tx_invalid_descs;
	__u64 rx_ring_full;
	__u64 rx_fill_ring_empty_descs;
	__u64 tx_ring_empty_descs;
};

struct xdp_options {
	__u32 flags;
};

struct xdp_desc {
	__u64 addr;
	__u32 len;
	__u32 options;
};

struct xsk_map {
	struct bpf_map map;
	spinlock_t lock;
	struct xdp_sock *xsk_map[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_ring;

struct xsk_queue {
	u32 ring_mask;
	u32 nentries;
	u32 cached_prod;
	u32 cached_cons;
	struct xdp_ring *ring;
	u64 invalid_descs;
	u64 queue_empty_descs;
};

struct xdp_ring_offset_v1 {
	__u64 producer;
	__u64 consumer;
	__u64 desc;
};

struct xdp_mmap_offsets_v1 {
	struct xdp_ring_offset_v1 rx;
	struct xdp_ring_offset_v1 tx;
	struct xdp_ring_offset_v1 fr;
	struct xdp_ring_offset_v1 cr;
};

struct xsk_map_node {
	struct list_head node;
	struct xsk_map *map;
	struct xdp_sock **map_entry;
};

struct xdp_ring {
	u32 producer;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 pad1;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 consumer;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 pad2;
	u32 flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 pad3;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_rxtx_ring {
	struct xdp_ring ptrs;
	struct xdp_desc desc[0];
};

struct xdp_umem_ring {
	struct xdp_ring ptrs;
	u64 desc[0];
};

struct xsk_dma_map {
	dma_addr_t *dma_pages;
	struct device *dev;
	struct net_device *netdev;
	refcount_t users;
	struct list_head list;
	u32 dma_pages_cnt;
	bool dma_need_sync;
};

struct mptcp_mib {
	long unsigned int mibs[35];
};

enum mptcp_event_type {
	MPTCP_EVENT_UNSPEC = 0,
	MPTCP_EVENT_CREATED = 1,
	MPTCP_EVENT_ESTABLISHED = 2,
	MPTCP_EVENT_CLOSED = 3,
	MPTCP_EVENT_ANNOUNCED = 6,
	MPTCP_EVENT_REMOVED = 7,
	MPTCP_EVENT_SUB_ESTABLISHED = 10,
	MPTCP_EVENT_SUB_CLOSED = 11,
	MPTCP_EVENT_SUB_PRIORITY = 13,
};

struct mptcp_options_received {
	u64 sndr_key;
	u64 rcvr_key;
	u64 data_ack;
	u64 data_seq;
	u32 subflow_seq;
	u16 data_len;
	u16 mp_capable: 1;
	u16 mp_join: 1;
	u16 fastclose: 1;
	u16 reset: 1;
	u16 dss: 1;
	u16 add_addr: 1;
	u16 rm_addr: 1;
	u16 mp_prio: 1;
	u16 echo: 1;
	u16 backup: 1;
	u32 token;
	u32 nonce;
	u64 thmac;
	u8 hmac[20];
	u8 join_id;
	u8 use_map: 1;
	u8 dsn64: 1;
	u8 data_fin: 1;
	u8 use_ack: 1;
	u8 ack64: 1;
	u8 mpc_map: 1;
	u8 __unused: 2;
	struct mptcp_addr_info addr;
	struct mptcp_rm_list rm_list;
	u64 ahmac;
	u8 reset_reason: 4;
	u8 reset_transient: 1;
};

struct mptcp_pm_data {
	struct mptcp_addr_info local;
	struct mptcp_addr_info remote;
	struct list_head anno_list;
	spinlock_t lock;
	u8 addr_signal;
	bool server_side;
	bool work_pending;
	bool accept_addr;
	bool accept_subflow;
	u8 add_addr_signaled;
	u8 add_addr_accepted;
	u8 local_addr_used;
	u8 subflows;
	u8 status;
	struct mptcp_rm_list rm_list_tx;
	struct mptcp_rm_list rm_list_rx;
};

struct mptcp_data_frag {
	struct list_head list;
	u64 data_seq;
	u16 data_len;
	u16 offset;
	u16 overhead;
	u16 already_sent;
	struct page *page;
};

struct mptcp_sock {
	struct inet_connection_sock sk;
	u64 local_key;
	u64 remote_key;
	u64 write_seq;
	u64 snd_nxt;
	u64 ack_seq;
	u64 rcv_wnd_sent;
	u64 rcv_data_fin_seq;
	int wmem_reserved;
	struct sock *last_snd;
	int snd_burst;
	int old_wspace;
	u64 snd_una;
	u64 wnd_end;
	long unsigned int timer_ival;
	u32 token;
	int rmem_released;
	long unsigned int flags;
	bool can_ack;
	bool fully_established;
	bool rcv_data_fin;
	bool snd_data_fin_enable;
	bool rcv_fastclose;
	bool use_64bit_ack;
	spinlock_t join_list_lock;
	struct work_struct work;
	struct sk_buff *ooo_last_skb;
	struct rb_root out_of_order_queue;
	struct sk_buff_head receive_queue;
	struct sk_buff_head skb_tx_cache;
	int tx_pending_data;
	int size_goal_cache;
	struct list_head conn_list;
	struct list_head rtx_queue;
	struct mptcp_data_frag *first_pending;
	struct list_head join_list;
	struct socket *subflow;
	struct sock *first;
	struct mptcp_pm_data pm;
	struct {
		u32 space;
		u32 copied;
		u64 time;
		u64 rtt_us;
	} rcvq_space;
	u32 setsockopt_seq;
	char ca_name[16];
};

struct mptcp_subflow_request_sock {
	struct tcp_request_sock sk;
	u16 mp_capable: 1;
	u16 mp_join: 1;
	u16 backup: 1;
	u8 local_id;
	u8 remote_id;
	u64 local_key;
	u64 idsn;
	u32 token;
	u32 ssn_offset;
	u64 thmac;
	u32 local_nonce;
	u32 remote_nonce;
	struct mptcp_sock *msk;
	struct hlist_nulls_node token_node;
};

enum mptcp_data_avail {
	MPTCP_SUBFLOW_NODATA = 0,
	MPTCP_SUBFLOW_DATA_AVAIL = 1,
};

struct mptcp_delegated_action {
	struct napi_struct napi;
	struct list_head head;
};

struct mptcp_subflow_context {
	struct list_head node;
	u64 local_key;
	u64 remote_key;
	u64 idsn;
	u64 map_seq;
	u32 snd_isn;
	u32 token;
	u32 rel_write_seq;
	u32 map_subflow_seq;
	u32 ssn_offset;
	u32 map_data_len;
	u32 request_mptcp: 1;
	u32 request_join: 1;
	u32 request_bkup: 1;
	u32 mp_capable: 1;
	u32 mp_join: 1;
	u32 fully_established: 1;
	u32 pm_notified: 1;
	u32 conn_finished: 1;
	u32 map_valid: 1;
	u32 mpc_map: 1;
	u32 backup: 1;
	u32 send_mp_prio: 1;
	u32 rx_eof: 1;
	u32 can_ack: 1;
	u32 disposable: 1;
	enum mptcp_data_avail data_avail;
	u32 remote_nonce;
	u64 thmac;
	u32 local_nonce;
	u32 remote_token;
	u8 hmac[20];
	u8 local_id;
	u8 remote_id;
	u8 reset_seen: 1;
	u8 reset_transient: 1;
	u8 reset_reason: 4;
	long int delegated_status;
	struct list_head delegated_node;
	u32 setsockopt_seq;
	struct sock *tcp_sock;
	struct sock *conn;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	void (*tcp_data_ready)(struct sock *);
	void (*tcp_state_change)(struct sock *);
	void (*tcp_write_space)(struct sock *);
	void (*tcp_error_report)(struct sock *);
	struct callback_head rcu;
};

enum linux_mptcp_mib_field {
	MPTCP_MIB_NUM = 0,
	MPTCP_MIB_MPCAPABLEPASSIVE = 1,
	MPTCP_MIB_MPCAPABLEACTIVE = 2,
	MPTCP_MIB_MPCAPABLEACTIVEACK = 3,
	MPTCP_MIB_MPCAPABLEPASSIVEACK = 4,
	MPTCP_MIB_MPCAPABLEPASSIVEFALLBACK = 5,
	MPTCP_MIB_MPCAPABLEACTIVEFALLBACK = 6,
	MPTCP_MIB_TOKENFALLBACKINIT = 7,
	MPTCP_MIB_RETRANSSEGS = 8,
	MPTCP_MIB_JOINNOTOKEN = 9,
	MPTCP_MIB_JOINSYNRX = 10,
	MPTCP_MIB_JOINSYNACKRX = 11,
	MPTCP_MIB_JOINSYNACKMAC = 12,
	MPTCP_MIB_JOINACKRX = 13,
	MPTCP_MIB_JOINACKMAC = 14,
	MPTCP_MIB_DSSNOMATCH = 15,
	MPTCP_MIB_INFINITEMAPRX = 16,
	MPTCP_MIB_OFOQUEUETAIL = 17,
	MPTCP_MIB_OFOQUEUE = 18,
	MPTCP_MIB_OFOMERGE = 19,
	MPTCP_MIB_NODSSWINDOW = 20,
	MPTCP_MIB_DUPDATA = 21,
	MPTCP_MIB_ADDADDR = 22,
	MPTCP_MIB_ECHOADD = 23,
	MPTCP_MIB_PORTADD = 24,
	MPTCP_MIB_JOINPORTSYNRX = 25,
	MPTCP_MIB_JOINPORTSYNACKRX = 26,
	MPTCP_MIB_JOINPORTACKRX = 27,
	MPTCP_MIB_MISMATCHPORTSYNRX = 28,
	MPTCP_MIB_MISMATCHPORTACKRX = 29,
	MPTCP_MIB_RMADDR = 30,
	MPTCP_MIB_RMSUBFLOW = 31,
	MPTCP_MIB_MPPRIOTX = 32,
	MPTCP_MIB_MPPRIORX = 33,
	MPTCP_MIB_RCVPRUNED = 34,
	__MPTCP_MIB_MAX = 35,
};

struct trace_event_raw_mptcp_subflow_get_send {
	struct trace_entry ent;
	bool active;
	bool free;
	u32 snd_wnd;
	u32 pace;
	u8 backup;
	u64 ratio;
	char __data[0];
};

struct trace_event_raw_mptcp_dump_mpext {
	struct trace_entry ent;
	u64 data_ack;
	u64 data_seq;
	u32 subflow_seq;
	u16 data_len;
	u8 use_map;
	u8 dsn64;
	u8 data_fin;
	u8 use_ack;
	u8 ack64;
	u8 mpc_map;
	u8 frozen;
	u8 reset_transient;
	u8 reset_reason;
	char __data[0];
};

struct trace_event_raw_ack_update_msk {
	struct trace_entry ent;
	u64 data_ack;
	u64 old_snd_una;
	u64 new_snd_una;
	u64 new_wnd_end;
	u64 msk_wnd_end;
	char __data[0];
};

struct trace_event_raw_subflow_check_data_avail {
	struct trace_entry ent;
	u8 status;
	const void *skb;
	char __data[0];
};

struct trace_event_data_offsets_mptcp_subflow_get_send {};

struct trace_event_data_offsets_mptcp_dump_mpext {};

struct trace_event_data_offsets_ack_update_msk {};

struct trace_event_data_offsets_subflow_check_data_avail {};

typedef void (*btf_trace_mptcp_subflow_get_send)(void *, struct mptcp_subflow_context *);

typedef void (*btf_trace_get_mapping_status)(void *, struct mptcp_ext *);

typedef void (*btf_trace_ack_update_msk)(void *, u64, u64, u64, u64, u64);

typedef void (*btf_trace_subflow_check_data_avail)(void *, __u8, struct sk_buff *);

struct mptcp_skb_cb {
	u64 map_seq;
	u64 end_seq;
	u32 offset;
};

struct mptcp_sendmsg_info {
	int mss_now;
	int size_goal;
	u16 limit;
	u16 sent;
	unsigned int flags;
};

struct subflow_send_info {
	struct sock *ssk;
	u64 ratio;
};

enum mapping_status {
	MAPPING_OK = 0,
	MAPPING_INVALID = 1,
	MAPPING_EMPTY = 2,
	MAPPING_DATA_FIN = 3,
	MAPPING_DUMMY = 4,
};

enum mptcp_addr_signal_status {
	MPTCP_ADD_ADDR_SIGNAL = 0,
	MPTCP_ADD_ADDR_ECHO = 1,
	MPTCP_ADD_ADDR_IPV6 = 2,
	MPTCP_ADD_ADDR_PORT = 3,
	MPTCP_RM_ADDR_SIGNAL = 4,
};

struct token_bucket {
	spinlock_t lock;
	int chain_len;
	struct hlist_nulls_head req_chain;
	struct hlist_nulls_head msk_chain;
};

struct mptcp_pernet {
	struct ctl_table_header *ctl_table_hdr;
	int mptcp_enabled;
	unsigned int add_addr_timeout;
};

enum mptcp_pm_status {
	MPTCP_PM_ADD_ADDR_RECEIVED = 0,
	MPTCP_PM_ADD_ADDR_SEND_ACK = 1,
	MPTCP_PM_RM_ADDR_RECEIVED = 2,
	MPTCP_PM_ESTABLISHED = 3,
	MPTCP_PM_ALREADY_ESTABLISHED = 4,
	MPTCP_PM_SUBFLOW_ESTABLISHED = 5,
};

enum {
	INET_ULP_INFO_UNSPEC = 0,
	INET_ULP_INFO_NAME = 1,
	INET_ULP_INFO_TLS = 2,
	INET_ULP_INFO_MPTCP = 3,
	__INET_ULP_INFO_MAX = 4,
};

enum {
	MPTCP_SUBFLOW_ATTR_UNSPEC = 0,
	MPTCP_SUBFLOW_ATTR_TOKEN_REM = 1,
	MPTCP_SUBFLOW_ATTR_TOKEN_LOC = 2,
	MPTCP_SUBFLOW_ATTR_RELWRITE_SEQ = 3,
	MPTCP_SUBFLOW_ATTR_MAP_SEQ = 4,
	MPTCP_SUBFLOW_ATTR_MAP_SFSEQ = 5,
	MPTCP_SUBFLOW_ATTR_SSN_OFFSET = 6,
	MPTCP_SUBFLOW_ATTR_MAP_DATALEN = 7,
	MPTCP_SUBFLOW_ATTR_FLAGS = 8,
	MPTCP_SUBFLOW_ATTR_ID_REM = 9,
	MPTCP_SUBFLOW_ATTR_ID_LOC = 10,
	MPTCP_SUBFLOW_ATTR_PAD = 11,
	__MPTCP_SUBFLOW_ATTR_MAX = 12,
};

enum {
	MPTCP_PM_ATTR_UNSPEC = 0,
	MPTCP_PM_ATTR_ADDR = 1,
	MPTCP_PM_ATTR_RCV_ADD_ADDRS = 2,
	MPTCP_PM_ATTR_SUBFLOWS = 3,
	__MPTCP_PM_ATTR_MAX = 4,
};

enum {
	MPTCP_PM_ADDR_ATTR_UNSPEC = 0,
	MPTCP_PM_ADDR_ATTR_FAMILY = 1,
	MPTCP_PM_ADDR_ATTR_ID = 2,
	MPTCP_PM_ADDR_ATTR_ADDR4 = 3,
	MPTCP_PM_ADDR_ATTR_ADDR6 = 4,
	MPTCP_PM_ADDR_ATTR_PORT = 5,
	MPTCP_PM_ADDR_ATTR_FLAGS = 6,
	MPTCP_PM_ADDR_ATTR_IF_IDX = 7,
	__MPTCP_PM_ADDR_ATTR_MAX = 8,
};

enum {
	MPTCP_PM_CMD_UNSPEC = 0,
	MPTCP_PM_CMD_ADD_ADDR = 1,
	MPTCP_PM_CMD_DEL_ADDR = 2,
	MPTCP_PM_CMD_GET_ADDR = 3,
	MPTCP_PM_CMD_FLUSH_ADDRS = 4,
	MPTCP_PM_CMD_SET_LIMITS = 5,
	MPTCP_PM_CMD_GET_LIMITS = 6,
	MPTCP_PM_CMD_SET_FLAGS = 7,
	__MPTCP_PM_CMD_AFTER_LAST = 8,
};

enum mptcp_event_attr {
	MPTCP_ATTR_UNSPEC = 0,
	MPTCP_ATTR_TOKEN = 1,
	MPTCP_ATTR_FAMILY = 2,
	MPTCP_ATTR_LOC_ID = 3,
	MPTCP_ATTR_REM_ID = 4,
	MPTCP_ATTR_SADDR4 = 5,
	MPTCP_ATTR_SADDR6 = 6,
	MPTCP_ATTR_DADDR4 = 7,
	MPTCP_ATTR_DADDR6 = 8,
	MPTCP_ATTR_SPORT = 9,
	MPTCP_ATTR_DPORT = 10,
	MPTCP_ATTR_BACKUP = 11,
	MPTCP_ATTR_ERROR = 12,
	MPTCP_ATTR_FLAGS = 13,
	MPTCP_ATTR_TIMEOUT = 14,
	MPTCP_ATTR_IF_IDX = 15,
	MPTCP_ATTR_RESET_REASON = 16,
	MPTCP_ATTR_RESET_FLAGS = 17,
	__MPTCP_ATTR_AFTER_LAST = 18,
};

struct mptcp_pm_addr_entry {
	struct list_head list;
	struct mptcp_addr_info addr;
	u8 flags;
	int ifindex;
	struct callback_head rcu;
	struct socket *lsk;
};

struct mptcp_pm_add_entry {
	struct list_head list;
	struct mptcp_addr_info addr;
	struct timer_list add_timer;
	struct mptcp_sock *sock;
	u8 retrans_times;
};

struct pm_nl_pernet {
	spinlock_t lock;
	struct list_head local_addr_list;
	unsigned int addrs;
	unsigned int add_addr_signal_max;
	unsigned int add_addr_accept_max;
	unsigned int local_addr_max;
	unsigned int subflows_max;
	unsigned int next_id;
	long unsigned int id_bitmap[4];
};

struct join_entry {
	u32 token;
	u32 remote_nonce;
	u32 local_nonce;
	u8 join_id;
	u8 local_id;
	u8 backup;
	u8 valid;
};

typedef struct {
	u32 version;
	u32 length;
	u64 memory_protection_attribute;
} efi_properties_table_t;

typedef union {
	struct {
		u32 revision;
		efi_handle_t parent_handle;
		efi_system_table_t *system_table;
		efi_handle_t device_handle;
		void *file_path;
		void *reserved;
		u32 load_options_size;
		void *load_options;
		void *image_base;
		__u64 image_size;
		unsigned int image_code_type;
		unsigned int image_data_type;
		efi_status_t (*unload)(efi_handle_t);
	};
	struct {
		u32 revision;
		u32 parent_handle;
		u32 system_table;
		u32 device_handle;
		u32 file_path;
		u32 reserved;
		u32 load_options_size;
		u32 load_options;
		u32 image_base;
		__u64 image_size;
		u32 image_code_type;
		u32 image_data_type;
		u32 unload;
	} mixed_mode;
} efi_loaded_image_t;

struct efi_boot_memmap {
	efi_memory_desc_t **map;
	long unsigned int *map_size;
	long unsigned int *desc_size;
	u32 *desc_ver;
	long unsigned int *key_ptr;
	long unsigned int *buff_size;
};

struct exit_boot_struct {
	efi_memory_desc_t *runtime_map;
	int *runtime_entry_count;
	void *new_fdt_addr;
};

typedef struct {
	u32 red_mask;
	u32 green_mask;
	u32 blue_mask;
	u32 reserved_mask;
} efi_pixel_bitmask_t;

typedef struct {
	u32 version;
	u32 horizontal_resolution;
	u32 vertical_resolution;
	int pixel_format;
	efi_pixel_bitmask_t pixel_information;
	u32 pixels_per_scan_line;
} efi_graphics_output_mode_info_t;

union efi_graphics_output_protocol_mode {
	struct {
		u32 max_mode;
		u32 mode;
		efi_graphics_output_mode_info_t *info;
		long unsigned int size_of_info;
		efi_physical_addr_t frame_buffer_base;
		long unsigned int frame_buffer_size;
	};
	struct {
		u32 max_mode;
		u32 mode;
		u32 info;
		u32 size_of_info;
		u64 frame_buffer_base;
		u32 frame_buffer_size;
	} mixed_mode;
};

typedef union efi_graphics_output_protocol_mode efi_graphics_output_protocol_mode_t;

union efi_graphics_output_protocol;

typedef union efi_graphics_output_protocol efi_graphics_output_protocol_t;

union efi_graphics_output_protocol {
	struct {
		efi_status_t (*query_mode)(efi_graphics_output_protocol_t *, u32, long unsigned int *, efi_graphics_output_mode_info_t **);
		efi_status_t (*set_mode)(efi_graphics_output_protocol_t *, u32);
		void *blt;
		efi_graphics_output_protocol_mode_t *mode;
	};
	struct {
		u32 query_mode;
		u32 set_mode;
		u32 blt;
		u32 mode;
	} mixed_mode;
};

enum efi_cmdline_option {
	EFI_CMDLINE_NONE = 0,
	EFI_CMDLINE_MODE_NUM = 1,
	EFI_CMDLINE_RES = 2,
	EFI_CMDLINE_AUTO = 3,
	EFI_CMDLINE_LIST = 4,
};

union efi_rng_protocol;

typedef union efi_rng_protocol efi_rng_protocol_t;

union efi_rng_protocol {
	struct {
		efi_status_t (*get_info)(efi_rng_protocol_t *, long unsigned int *, efi_guid_t *);
		efi_status_t (*get_rng)(efi_rng_protocol_t *, efi_guid_t *, long unsigned int, u8 *);
	};
	struct {
		u32 get_info;
		u32 get_rng;
	} mixed_mode;
};

typedef u32 efi_tcg2_event_log_format;

union efi_tcg2_protocol;

typedef union efi_tcg2_protocol efi_tcg2_protocol_t;

union efi_tcg2_protocol {
	struct {
		void *get_capability;
		efi_status_t (*get_event_log)(efi_tcg2_protocol_t *, efi_tcg2_event_log_format, efi_physical_addr_t *, efi_physical_addr_t *, efi_bool_t *);
		void *hash_log_extend_event;
		void *submit_command;
		void *get_active_pcr_banks;
		void *set_active_pcr_banks;
		void *get_result_of_set_active_pcr_banks;
	};
	struct {
		u32 get_capability;
		u32 get_event_log;
		u32 hash_log_extend_event;
		u32 submit_command;
		u32 get_active_pcr_banks;
		u32 set_active_pcr_banks;
		u32 get_result_of_set_active_pcr_banks;
	} mixed_mode;
};

struct efi_vendor_dev_path {
	struct efi_generic_dev_path header;
	efi_guid_t vendorguid;
	u8 vendordata[0];
};

union efi_load_file_protocol;

typedef union efi_load_file_protocol efi_load_file_protocol_t;

union efi_load_file_protocol {
	struct {
		efi_status_t (*load_file)(efi_load_file_protocol_t *, efi_device_path_protocol_t *, bool, long unsigned int *, void *);
	};
	struct {
		u32 load_file;
	} mixed_mode;
};

typedef union efi_load_file_protocol efi_load_file2_protocol_t;

typedef struct {
	u32 attributes;
	u16 file_path_list_length;
	u8 variable_data[0];
} __attribute__((packed)) efi_load_option_t;

typedef struct {
	u32 attributes;
	u16 file_path_list_length;
	const efi_char16_t *description;
	const efi_device_path_protocol_t *file_path_list;
	size_t optional_data_size;
	const void *optional_data;
} efi_load_option_unpacked_t;

typedef efi_status_t (*efi_exit_boot_map_processing)(struct efi_boot_memmap *, void *);

typedef struct {
	u64 size;
	u64 file_size;
	u64 phys_size;
	efi_time_t create_time;
	efi_time_t last_access_time;
	efi_time_t modification_time;
	__u64 attribute;
	efi_char16_t filename[0];
} efi_file_info_t;

struct efi_file_protocol;

typedef struct efi_file_protocol efi_file_protocol_t;

struct efi_file_protocol {
	u64 revision;
	efi_status_t (*open)(efi_file_protocol_t *, efi_file_protocol_t **, efi_char16_t *, u64, u64);
	efi_status_t (*close)(efi_file_protocol_t *);
	efi_status_t (*delete)(efi_file_protocol_t *);
	efi_status_t (*read)(efi_file_protocol_t *, long unsigned int *, void *);
	efi_status_t (*write)(efi_file_protocol_t *, long unsigned int, void *);
	efi_status_t (*get_position)(efi_file_protocol_t *, u64 *);
	efi_status_t (*set_position)(efi_file_protocol_t *, u64);
	efi_status_t (*get_info)(efi_file_protocol_t *, efi_guid_t *, long unsigned int *, void *);
	efi_status_t (*set_info)(efi_file_protocol_t *, efi_guid_t *, long unsigned int, void *);
	efi_status_t (*flush)(efi_file_protocol_t *);
};

struct efi_simple_file_system_protocol;

typedef struct efi_simple_file_system_protocol efi_simple_file_system_protocol_t;

struct efi_simple_file_system_protocol {
	u64 revision;
	int (*open_volume)(efi_simple_file_system_protocol_t *, efi_file_protocol_t **);
};

struct finfo {
	efi_file_info_t info;
	efi_char16_t filename[256];
};

typedef enum {
	EfiPciIoWidthUint8 = 0,
	EfiPciIoWidthUint16 = 1,
	EfiPciIoWidthUint32 = 2,
	EfiPciIoWidthUint64 = 3,
	EfiPciIoWidthFifoUint8 = 4,
	EfiPciIoWidthFifoUint16 = 5,
	EfiPciIoWidthFifoUint32 = 6,
	EfiPciIoWidthFifoUint64 = 7,
	EfiPciIoWidthFillUint8 = 8,
	EfiPciIoWidthFillUint16 = 9,
	EfiPciIoWidthFillUint32 = 10,
	EfiPciIoWidthFillUint64 = 11,
	EfiPciIoWidthMaximum = 12,
} EFI_PCI_IO_PROTOCOL_WIDTH;

typedef struct {
	u32 read;
	u32 write;
} efi_pci_io_protocol_access_32_t;

typedef struct {
	void *read;
	void *write;
} efi_pci_io_protocol_access_t;

union efi_pci_io_protocol;

typedef union efi_pci_io_protocol efi_pci_io_protocol_t;

typedef efi_status_t (*efi_pci_io_protocol_cfg_t)(efi_pci_io_protocol_t *, EFI_PCI_IO_PROTOCOL_WIDTH, u32, long unsigned int, void *);

typedef struct {
	efi_pci_io_protocol_cfg_t read;
	efi_pci_io_protocol_cfg_t write;
} efi_pci_io_protocol_config_access_t;

union efi_pci_io_protocol {
	struct {
		void *poll_mem;
		void *poll_io;
		efi_pci_io_protocol_access_t mem;
		efi_pci_io_protocol_access_t io;
		efi_pci_io_protocol_config_access_t pci;
		void *copy_mem;
		void *map;
		void *unmap;
		void *allocate_buffer;
		void *free_buffer;
		void *flush;
		efi_status_t (*get_location)(efi_pci_io_protocol_t *, long unsigned int *, long unsigned int *, long unsigned int *, long unsigned int *);
		void *attributes;
		void *get_bar_attributes;
		void *set_bar_attributes;
		uint64_t romsize;
		void *romimage;
	};
	struct {
		u32 poll_mem;
		u32 poll_io;
		efi_pci_io_protocol_access_32_t mem;
		efi_pci_io_protocol_access_32_t io;
		efi_pci_io_protocol_access_32_t pci;
		u32 copy_mem;
		u32 map;
		u32 unmap;
		u32 allocate_buffer;
		u32 free_buffer;
		u32 flush;
		u32 get_location;
		u32 attributes;
		u32 get_bar_attributes;
		u32 set_bar_attributes;
		u64 romsize;
		u32 romimage;
	} mixed_mode;
};

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute pop
#endif

#endif /* __VMLINUX_H__ */

#endif /* defined(bpf_target_arm64) */

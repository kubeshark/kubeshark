on:
  push:
    # Sequence of patterns matched against refs/tags
    tags:
    - 'v*' # Push events to matching v*, i.e. v1.0, v20.15.10
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run - build and generate but skip actual publishing'
        type: boolean
        default: true
      version:
        description: 'Version tag (e.g., v52.13.0) - required for manual runs'
        type: string
        required: false

name: Release

concurrency:
  group: kubeshark-publish-${{ github.ref }}
  cancel-in-progress: true

jobs:
  release:
    name: Build and publish a new release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.tag }}
    steps:
      - name: Check out the repo
        uses: actions/checkout@v3

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version-file: 'go.mod'

      - name: Version
        id: version
        shell: bash
        run: |
          # Handle both tag-triggered and manual workflow_dispatch runs
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
            if [ -z "$VERSION" ]; then
              VERSION="v0.0.0-dev"
            fi
          else
            VERSION="${GITHUB_REF#refs/*/}"
          fi
          {
            echo "tag=${VERSION}"
            echo "build_timestamp=$(date +%s)"
            echo "branch=${GITHUB_REF#refs/heads/}"
          } >> "$GITHUB_OUTPUT"

      - name: Build
        run: make build-all VER='${{ steps.version.outputs.tag }}' BUILD_TIMESTAMP='${{ steps.version.outputs.build_timestamp }}'

      - name: Log the version into a .txt file
        shell: bash
        run: |
          echo '${{ steps.version.outputs.tag }}' >> bin/version.txt

      - name: Create MCP Registry artifacts
        shell: bash
        run: |
          cd bin
          # Create .mcpb copies for MCP Registry (URL must contain "mcp")
          for f in kubeshark_linux_amd64 kubeshark_linux_arm64 kubeshark_darwin_amd64 kubeshark_darwin_arm64; do
            if [ -f "$f" ]; then
              cp "$f" "${f/kubeshark_/kubeshark-mcp_}.mcpb"
              shasum -a 256 "${f/kubeshark_/kubeshark-mcp_}.mcpb" > "${f/kubeshark_/kubeshark-mcp_}.mcpb.sha256"
            fi
          done
          # Handle Windows executable
          if [ -f "kubeshark.exe" ]; then
            cp kubeshark.exe kubeshark-mcp_windows_amd64.mcpb
            shasum -a 256 kubeshark-mcp_windows_amd64.mcpb > kubeshark-mcp_windows_amd64.mcpb.sha256
          fi

      - name: Release
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.dry_run != 'true'
        uses: ncipollo/release-action@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          artifacts: "bin/*"
          tag: ${{ steps.version.outputs.tag }}
          prerelease: false
          bodyFile: 'bin/README.md'

      - name: Upload artifacts for dry-run
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts
          path: bin/

  mcp-publish:
    name: Publish to MCP Registry
    needs: [release]
    runs-on: ubuntu-latest
    steps:
      - name: Check out the repo
        uses: actions/checkout@v3

      - name: Download release artifacts (dry-run)
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run == 'true'
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts
          path: bin/

      - name: Download SHA256 files from release
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.dry_run != 'true'
        shell: bash
        run: |
          VERSION="${{ needs.release.outputs.version }}"
          mkdir -p bin
          for platform in darwin_arm64 darwin_amd64 linux_arm64 linux_amd64 windows_amd64; do
            curl -sL "https://github.com/kubeshark/kubeshark/releases/download/${VERSION}/kubeshark-mcp_${platform}.mcpb.sha256" \
              -o "bin/kubeshark-mcp_${platform}.mcpb.sha256" || true
          done

      - name: Generate server.json
        id: generate
        shell: bash
        run: |
          VERSION="${{ needs.release.outputs.version }}"
          CLEAN_VERSION="${VERSION#v}"

          # Read SHA256 hashes
          get_sha256() {
            local file="bin/kubeshark-mcp_$1.mcpb.sha256"
            if [ -f "$file" ]; then
              cat "$file" | awk '{print $1}'
            else
              echo "HASH_NOT_FOUND"
            fi
          }

          DARWIN_ARM64_SHA256=$(get_sha256 "darwin_arm64")
          DARWIN_AMD64_SHA256=$(get_sha256 "darwin_amd64")
          LINUX_ARM64_SHA256=$(get_sha256 "linux_arm64")
          LINUX_AMD64_SHA256=$(get_sha256 "linux_amd64")
          WINDOWS_AMD64_SHA256=$(get_sha256 "windows_amd64")

          # Generate server.json using jq for proper formatting
          jq -n \
            --arg version "$CLEAN_VERSION" \
            --arg full_version "$VERSION" \
            --arg darwin_arm64_sha "$DARWIN_ARM64_SHA256" \
            --arg darwin_amd64_sha "$DARWIN_AMD64_SHA256" \
            --arg linux_arm64_sha "$LINUX_ARM64_SHA256" \
            --arg linux_amd64_sha "$LINUX_AMD64_SHA256" \
            --arg windows_amd64_sha "$WINDOWS_AMD64_SHA256" \
            '{
              "$schema": "https://static.modelcontextprotocol.io/schemas/2025-12-11/server.schema.json",
              "name": "io.github.kubeshark/mcp",
              "displayName": "Kubeshark",
              "description": "Real-time Kubernetes network traffic visibility and API analysis for HTTP, gRPC, Redis, Kafka, DNS.",
              "icon": "https://raw.githubusercontent.com/kubeshark/assets/refs/heads/master/logo/ico/icon.ico",
              "repository": { "url": "https://github.com/kubeshark/kubeshark", "source": "github" },
              "homepage": "https://kubeshark.com",
              "license": "Apache-2.0",
              "version": $version,
              "authors": [{ "name": "Kubeshark", "url": "https://kubeshark.com" }],
              "categories": ["kubernetes", "networking", "observability", "debugging", "security"],
              "tags": ["kubernetes", "network", "traffic", "api", "http", "grpc", "kafka", "redis", "dns", "pcap", "wireshark", "tcpdump", "observability", "debugging", "microservices"],
              "packages": [
                { "registryType": "mcpb", "identifier": ("https://github.com/kubeshark/kubeshark/releases/download/" + $full_version + "/kubeshark-mcp_darwin_arm64.mcpb"), "fileSha256": $darwin_arm64_sha, "transport": { "type": "stdio" } },
                { "registryType": "mcpb", "identifier": ("https://github.com/kubeshark/kubeshark/releases/download/" + $full_version + "/kubeshark-mcp_darwin_amd64.mcpb"), "fileSha256": $darwin_amd64_sha, "transport": { "type": "stdio" } },
                { "registryType": "mcpb", "identifier": ("https://github.com/kubeshark/kubeshark/releases/download/" + $full_version + "/kubeshark-mcp_linux_arm64.mcpb"), "fileSha256": $linux_arm64_sha, "transport": { "type": "stdio" } },
                { "registryType": "mcpb", "identifier": ("https://github.com/kubeshark/kubeshark/releases/download/" + $full_version + "/kubeshark-mcp_linux_amd64.mcpb"), "fileSha256": $linux_amd64_sha, "transport": { "type": "stdio" } },
                { "registryType": "mcpb", "identifier": ("https://github.com/kubeshark/kubeshark/releases/download/" + $full_version + "/kubeshark-mcp_windows_amd64.mcpb"), "fileSha256": $windows_amd64_sha, "transport": { "type": "stdio" } }
              ],
              "tools": [
                { "name": "check_kubeshark_status", "description": "Check if Kubeshark is currently running in the cluster.", "mode": "proxy" },
                { "name": "start_kubeshark", "description": "Deploy Kubeshark to the Kubernetes cluster. Requires --allow-destructive flag.", "mode": "proxy", "destructive": true },
                { "name": "stop_kubeshark", "description": "Remove Kubeshark from the Kubernetes cluster. Requires --allow-destructive flag.", "mode": "proxy", "destructive": true },
                { "name": "list_workloads", "description": "List pods, services, namespaces, and nodes with observed L7 traffic.", "mode": "all" },
                { "name": "list_api_calls", "description": "Query L7 API transactions (HTTP, gRPC, Redis, Kafka, DNS) with KFL filtering.", "mode": "all" },
                { "name": "get_api_call", "description": "Get detailed information about a specific API call including headers and body.", "mode": "all" },
                { "name": "get_api_stats", "description": "Get aggregated API statistics and metrics.", "mode": "all" },
                { "name": "list_l4_flows", "description": "List L4 (TCP/UDP) network flows with traffic statistics.", "mode": "all" },
                { "name": "get_l4_flow_summary", "description": "Get L4 connectivity summary including top talkers and cross-namespace traffic.", "mode": "all" },
                { "name": "list_snapshots", "description": "List all PCAP snapshots.", "mode": "all" },
                { "name": "create_snapshot", "description": "Create a new PCAP snapshot of captured traffic.", "mode": "all" },
                { "name": "get_dissection_status", "description": "Check L7 protocol parsing status.", "mode": "all" },
                { "name": "enable_dissection", "description": "Enable L7 protocol dissection.", "mode": "all" },
                { "name": "disable_dissection", "description": "Disable L7 protocol dissection.", "mode": "all" }
              ],
              "prompts": [
                { "name": "analyze_traffic", "description": "Analyze API traffic patterns and identify issues" },
                { "name": "find_errors", "description": "Find and summarize API errors and failures" },
                { "name": "trace_request", "description": "Trace a request path through microservices" },
                { "name": "show_topology", "description": "Show service communication topology" },
                { "name": "latency_analysis", "description": "Analyze latency patterns and identify slow endpoints" },
                { "name": "security_audit", "description": "Audit traffic for security concerns" },
                { "name": "compare_traffic", "description": "Compare traffic patterns between time periods" },
                { "name": "debug_connection", "description": "Debug connectivity issues between services" }
              ],
              "configuration": {
                "properties": {
                  "url": { "type": "string", "description": "Direct URL to Kubeshark Hub (e.g., https://kubeshark.example.com). When set, connects directly without kubectl/proxy.", "examples": ["https://kubeshark.example.com", "http://localhost:8899"] },
                  "kubeconfig": { "type": "string", "description": "Path to kubeconfig file for proxy mode.", "examples": ["~/.kube/config", "/path/to/.kube/config"] },
                  "allow-destructive": { "type": "boolean", "description": "Enable destructive operations (start_kubeshark, stop_kubeshark). Default: false for safety.", "default": false }
                }
              },
              "modes": {
                "url": { "description": "Connect directly to an existing Kubeshark deployment via URL. Cluster management tools are disabled.", "args": ["mcp", "--url", "${url}"] },
                "proxy": { "description": "Connect via kubectl port-forward. Requires kubeconfig access to the cluster.", "args": ["mcp", "--kubeconfig", "${kubeconfig}"] },
                "proxy-destructive": { "description": "Proxy mode with destructive operations enabled.", "args": ["mcp", "--kubeconfig", "${kubeconfig}", "--allow-destructive"] }
              }
            }' > mcp/server.json

          echo "Generated server.json:"
          cat mcp/server.json

      - name: Install mcp-publisher
        shell: bash
        run: |
          curl -sL "https://github.com/modelcontextprotocol/registry/releases/latest/download/mcp-publisher_linux_amd64.tar.gz" | tar xz
          chmod +x mcp-publisher
          sudo mv mcp-publisher /usr/local/bin/

      - name: Publish to MCP Registry
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.dry_run != 'true'
        shell: bash
        run: |
          cd mcp
          echo "Publishing to MCP Registry..."
          if ! mcp-publisher publish; then
            echo "::error::Failed to publish to MCP Registry"
            exit 1
          fi
          echo "Successfully published to MCP Registry"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Dry-run summary
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run == 'true'
        shell: bash
        run: |
          echo "=== DRY RUN - Would publish the following server.json ==="
          cat mcp/server.json
          echo ""
          echo "=== SHA256 hashes found ==="
          cat bin/*.sha256 2>/dev/null || echo "No SHA256 files found (expected in dry-run from workflow_dispatch)"
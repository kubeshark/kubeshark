<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kubeshark L4 Flows Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
            min-height: 100vh;
        }

        h1 {
            color: #00d4ff;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h1 svg {
            width: 32px;
            height: 32px;
        }

        .filters {
            background: #16213e;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: flex-end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-group label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
        }

        .filter-group input,
        .filter-group select {
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #0f0f23;
            color: #eee;
            font-size: 14px;
            min-width: 150px;
        }

        .filter-group input:focus,
        .filter-group select:focus {
            outline: none;
            border-color: #00d4ff;
        }

        button {
            padding: 8px 20px;
            background: #00d4ff;
            color: #1a1a2e;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover {
            background: #00b8e6;
        }

        button.secondary {
            background: #333;
            color: #eee;
        }

        button.secondary:hover {
            background: #444;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #16213e;
            padding: 15px 25px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-card .value {
            font-size: 28px;
            font-weight: bold;
            color: #00d4ff;
        }

        .stat-card .label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .table-container {
            background: #16213e;
            border-radius: 8px;
            overflow: hidden;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: #0f0f23;
            padding: 12px 15px;
            text-align: left;
            font-size: 12px;
            text-transform: uppercase;
            color: #888;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            color: #00d4ff;
        }

        th.sorted {
            color: #00d4ff;
        }

        th.sorted::after {
            content: ' ▼';
        }

        th.sorted.asc::after {
            content: ' ▲';
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #0f0f23;
            font-size: 13px;
        }

        tr:hover {
            background: #1f2b4d;
        }

        .protocol {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
        }

        .protocol.tcp {
            background: #2d5a27;
            color: #7fff7f;
        }

        .protocol.udp {
            background: #5a4827;
            color: #ffcf7f;
        }

        .endpoint {
            font-family: monospace;
        }

        .endpoint .pod {
            color: #00d4ff;
        }

        .endpoint .ip {
            color: #888;
            font-size: 11px;
        }

        .endpoint .port {
            color: #ff6b6b;
        }

        .bytes {
            text-align: right;
            font-family: monospace;
        }

        .latency {
            font-family: monospace;
        }

        .latency.good {
            color: #7fff7f;
        }

        .latency.medium {
            color: #ffcf7f;
        }

        .latency.bad {
            color: #ff6b6b;
        }

        .no-data {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #00d4ff;
        }

        .refresh-info {
            font-size: 12px;
            color: #666;
            margin-left: auto;
        }
    </style>
</head>
<body>
    <h1>
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
        </svg>
        Kubeshark L4 Flows
    </h1>

    <div class="filters">
        <div class="filter-group">
            <label>Namespace</label>
            <select id="filterNamespace">
                <option value="">All Namespaces</option>
            </select>
        </div>
        <div class="filter-group">
            <label>Protocol</label>
            <select id="filterProtocol">
                <option value="">All Protocols</option>
                <option value="tcp">TCP</option>
                <option value="udp">UDP</option>
            </select>
        </div>
        <div class="filter-group">
            <label>Source Pod</label>
            <input type="text" id="filterSrcPod" placeholder="Filter by source...">
        </div>
        <div class="filter-group">
            <label>Destination Pod</label>
            <input type="text" id="filterDstPod" placeholder="Filter by destination...">
        </div>
        <div class="filter-group">
            <label>Min Bytes</label>
            <input type="number" id="filterMinBytes" placeholder="0">
        </div>
        <button onclick="applyFilters()">Apply Filters</button>
        <button class="secondary" onclick="resetFilters()">Reset</button>
        <span class="refresh-info">Last updated: <span id="lastUpdate">-</span></span>
    </div>

    <div class="stats">
        <div class="stat-card">
            <div class="value" id="totalFlows">0</div>
            <div class="label">Total Flows</div>
        </div>
        <div class="stat-card">
            <div class="value" id="totalBytes">0</div>
            <div class="label">Total Bytes</div>
        </div>
        <div class="stat-card">
            <div class="value" id="avgLatency">0</div>
            <div class="label">Avg Latency (ms)</div>
        </div>
        <div class="stat-card">
            <div class="value" id="activeConnections">0</div>
            <div class="label">Active Connections</div>
        </div>
    </div>

    <div class="table-container">
        <table>
            <thead>
                <tr>
                    <th data-sort="protocol">Protocol</th>
                    <th data-sort="srcNs">Src NS</th>
                    <th data-sort="srcPod">Source</th>
                    <th data-sort="dstNs">Dst NS</th>
                    <th data-sort="dstPod">Destination</th>
                    <th data-sort="bytesIn">Bytes In</th>
                    <th data-sort="bytesOut">Bytes Out</th>
                    <th data-sort="packets">Packets</th>
                    <th data-sort="latencyP50">P50 Latency</th>
                    <th data-sort="latencyP99">P99 Latency</th>
                </tr>
            </thead>
            <tbody id="flowsTable">
                <tr><td colspan="10" class="loading">Loading flows...</td></tr>
            </tbody>
        </table>
    </div>

    <script>
        // Configuration - Update this URL to your Kubeshark instance
        const KUBESHARK_URL = 'https://kubeshark.ag-237.dev.kubehq.org';

        // Transform MCP flow response to our UI format
        function transformMcpFlows(flows) {
            if (!Array.isArray(flows)) return [];
            return flows.map(f => ({
                protocol: f.l4_proto || f.protocol || 'tcp',
                srcNs: f.src?.namespace || f.client?.namespace || 'unknown',
                srcPod: f.src?.pod || f.client?.pod || f.src?.name || 'unknown',
                srcIp: f.src?.ip || f.client?.ip || '',
                srcPort: f.src?.port || f.client?.port || 0,
                dstNs: f.dst?.namespace || f.server?.namespace || 'unknown',
                dstPod: f.dst?.pod || f.server?.pod || f.dst?.name || 'unknown',
                dstIp: f.dst?.ip || f.server?.ip || '',
                dstPort: f.dst?.port || f.server?.port || 0,
                bytesIn: f.bytes_in || f.rx_bytes || 0,
                bytesOut: f.bytes_out || f.tx_bytes || 0,
                packets: f.packets || f.pkt_count || 0,
                latencyP50: (f.tcp_handshake_p50_us || 0) / 1000,
                latencyP90: (f.tcp_handshake_p90_us || 0) / 1000,
                latencyP99: (f.tcp_handshake_p99_us || 0) / 1000
            }));
        }

        // Sample data for demonstration (will be replaced by real API data)
        const sampleFlows = [
            {
                protocol: 'tcp',
                srcNs: 'default',
                srcPod: 'frontend-7d8f9b6c5-x2k4m',
                srcIp: '10.244.0.15',
                srcPort: 45632,
                dstNs: 'default',
                dstPod: 'api-gateway-5c9d8f7b6-j3h2k',
                dstIp: '10.244.0.22',
                dstPort: 8080,
                bytesIn: 245678,
                bytesOut: 1234567,
                packets: 4521,
                latencyP50: 2.3,
                latencyP90: 8.7,
                latencyP99: 45.2
            },
            {
                protocol: 'tcp',
                srcNs: 'default',
                srcPod: 'api-gateway-5c9d8f7b6-j3h2k',
                srcIp: '10.244.0.22',
                srcPort: 52341,
                dstNs: 'database',
                dstPod: 'postgres-0',
                dstIp: '10.244.1.10',
                dstPort: 5432,
                bytesIn: 89234,
                bytesOut: 567890,
                packets: 2341,
                latencyP50: 1.2,
                latencyP90: 3.4,
                latencyP99: 12.8
            },
            {
                protocol: 'tcp',
                srcNs: 'monitoring',
                srcPod: 'prometheus-server-0',
                srcIp: '10.244.2.5',
                srcPort: 38472,
                dstNs: 'default',
                dstPod: 'api-gateway-5c9d8f7b6-j3h2k',
                dstIp: '10.244.0.22',
                dstPort: 9090,
                bytesIn: 12345,
                bytesOut: 98765,
                packets: 876,
                latencyP50: 0.8,
                latencyP90: 2.1,
                latencyP99: 5.6
            },
            {
                protocol: 'udp',
                srcNs: 'kube-system',
                srcPod: 'coredns-5d78c9869d-abc12',
                srcIp: '10.244.0.2',
                srcPort: 53,
                dstNs: 'default',
                dstPod: 'frontend-7d8f9b6c5-x2k4m',
                dstIp: '10.244.0.15',
                dstPort: 48293,
                bytesIn: 5678,
                bytesOut: 2345,
                packets: 234,
                latencyP50: 0.3,
                latencyP90: 0.8,
                latencyP99: 1.5
            },
            {
                protocol: 'tcp',
                srcNs: 'default',
                srcPod: 'worker-batch-8f7d6c5b4-m2n1p',
                srcIp: '10.244.0.30',
                srcPort: 41234,
                dstNs: 'messaging',
                dstPod: 'rabbitmq-0',
                dstIp: '10.244.3.8',
                dstPort: 5672,
                bytesIn: 345678,
                bytesOut: 789012,
                packets: 5678,
                latencyP50: 3.5,
                latencyP90: 12.3,
                latencyP99: 78.9
            },
            {
                protocol: 'tcp',
                srcNs: 'ingress',
                srcPod: 'nginx-ingress-controller-abc123',
                srcIp: '10.244.4.2',
                srcPort: 33456,
                dstNs: 'default',
                dstPod: 'frontend-7d8f9b6c5-x2k4m',
                dstIp: '10.244.0.15',
                dstPort: 3000,
                bytesIn: 2345678,
                bytesOut: 8901234,
                packets: 12345,
                latencyP50: 1.8,
                latencyP90: 5.6,
                latencyP99: 23.4
            },
            {
                protocol: 'tcp',
                srcNs: 'default',
                srcPod: 'cache-redis-0',
                srcIp: '10.244.0.40',
                srcPort: 6379,
                dstNs: 'default',
                dstPod: 'api-gateway-5c9d8f7b6-j3h2k',
                dstIp: '10.244.0.22',
                dstPort: 52847,
                bytesIn: 123456,
                bytesOut: 654321,
                packets: 3456,
                latencyP50: 0.5,
                latencyP90: 1.2,
                latencyP99: 3.8
            },
            {
                protocol: 'udp',
                srcNs: 'default',
                srcPod: 'metrics-agent-ds-xyz789',
                srcIp: '10.244.0.50',
                srcPort: 8125,
                dstNs: 'monitoring',
                dstPod: 'statsd-exporter-6d5c4b3a2-k1j2h',
                dstIp: '10.244.2.15',
                dstPort: 9125,
                bytesIn: 45678,
                bytesOut: 12345,
                packets: 890,
                latencyP50: 0.2,
                latencyP90: 0.5,
                latencyP99: 1.2
            }
        ];

        let allFlows = [];
        let filteredFlows = [];
        let sortColumn = 'bytesOut';
        let sortAsc = false;

        // Format bytes to human readable
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // Get latency class based on value
        function getLatencyClass(ms) {
            if (ms < 5) return 'good';
            if (ms < 50) return 'medium';
            return 'bad';
        }

        // Render flows table
        function renderTable() {
            const tbody = document.getElementById('flowsTable');

            if (filteredFlows.length === 0) {
                tbody.innerHTML = '<tr><td colspan="10" class="no-data">No flows match the current filters</td></tr>';
                return;
            }

            tbody.innerHTML = filteredFlows.map(flow => `
                <tr>
                    <td><span class="protocol ${flow.protocol}">${flow.protocol.toUpperCase()}</span></td>
                    <td>${flow.srcNs}</td>
                    <td class="endpoint">
                        <span class="pod">${flow.srcPod}</span><br>
                        <span class="ip">${flow.srcIp}:<span class="port">${flow.srcPort}</span></span>
                    </td>
                    <td>${flow.dstNs}</td>
                    <td class="endpoint">
                        <span class="pod">${flow.dstPod}</span><br>
                        <span class="ip">${flow.dstIp}:<span class="port">${flow.dstPort}</span></span>
                    </td>
                    <td class="bytes">${formatBytes(flow.bytesIn)}</td>
                    <td class="bytes">${formatBytes(flow.bytesOut)}</td>
                    <td class="bytes">${flow.packets.toLocaleString()}</td>
                    <td class="latency ${getLatencyClass(flow.latencyP50)}">${flow.latencyP50.toFixed(1)} ms</td>
                    <td class="latency ${getLatencyClass(flow.latencyP99)}">${flow.latencyP99.toFixed(1)} ms</td>
                </tr>
            `).join('');
        }

        // Update statistics
        function updateStats() {
            const totalBytes = filteredFlows.reduce((sum, f) => sum + f.bytesIn + f.bytesOut, 0);
            const avgLatency = filteredFlows.length > 0
                ? filteredFlows.reduce((sum, f) => sum + f.latencyP50, 0) / filteredFlows.length
                : 0;

            document.getElementById('totalFlows').textContent = filteredFlows.length;
            document.getElementById('totalBytes').textContent = formatBytes(totalBytes);
            document.getElementById('avgLatency').textContent = avgLatency.toFixed(1);
            document.getElementById('activeConnections').textContent = filteredFlows.filter(f => f.protocol === 'tcp').length;
        }

        // Populate namespace filter
        function populateNamespaceFilter() {
            const namespaces = new Set();
            allFlows.forEach(f => {
                namespaces.add(f.srcNs);
                namespaces.add(f.dstNs);
            });

            const select = document.getElementById('filterNamespace');
            select.innerHTML = '<option value="">All Namespaces</option>' +
                Array.from(namespaces).sort().map(ns => `<option value="${ns}">${ns}</option>`).join('');
        }

        // Apply filters
        function applyFilters() {
            const ns = document.getElementById('filterNamespace').value.toLowerCase();
            const protocol = document.getElementById('filterProtocol').value.toLowerCase();
            const srcPod = document.getElementById('filterSrcPod').value.toLowerCase();
            const dstPod = document.getElementById('filterDstPod').value.toLowerCase();
            const minBytes = parseInt(document.getElementById('filterMinBytes').value) || 0;

            filteredFlows = allFlows.filter(flow => {
                if (ns && flow.srcNs.toLowerCase() !== ns && flow.dstNs.toLowerCase() !== ns) return false;
                if (protocol && flow.protocol.toLowerCase() !== protocol) return false;
                if (srcPod && !flow.srcPod.toLowerCase().includes(srcPod)) return false;
                if (dstPod && !flow.dstPod.toLowerCase().includes(dstPod)) return false;
                if (flow.bytesIn + flow.bytesOut < minBytes) return false;
                return true;
            });

            sortFlows();
            renderTable();
            updateStats();
        }

        // Reset filters
        function resetFilters() {
            document.getElementById('filterNamespace').value = '';
            document.getElementById('filterProtocol').value = '';
            document.getElementById('filterSrcPod').value = '';
            document.getElementById('filterDstPod').value = '';
            document.getElementById('filterMinBytes').value = '';
            applyFilters();
        }

        // Sort flows
        function sortFlows() {
            filteredFlows.sort((a, b) => {
                let aVal = a[sortColumn];
                let bVal = b[sortColumn];

                if (typeof aVal === 'string') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }

                if (aVal < bVal) return sortAsc ? -1 : 1;
                if (aVal > bVal) return sortAsc ? 1 : -1;
                return 0;
            });
        }

        // Handle column header click
        document.querySelectorAll('th[data-sort]').forEach(th => {
            th.addEventListener('click', () => {
                const column = th.dataset.sort;

                // Update sort state
                if (sortColumn === column) {
                    sortAsc = !sortAsc;
                } else {
                    sortColumn = column;
                    sortAsc = true;
                }

                // Update header styles
                document.querySelectorAll('th').forEach(h => {
                    h.classList.remove('sorted', 'asc');
                });
                th.classList.add('sorted');
                if (sortAsc) th.classList.add('asc');

                sortFlows();
                renderTable();
            });
        });

        // Fetch flows from Kubeshark MCP API
        async function fetchFlows() {
            try {
                // Call Kubeshark Hub's MCP tools/call endpoint
                const response = await fetch(`${KUBESHARK_URL}/api/mcp/tools/call`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        name: 'list_l4_flows',
                        arguments: {
                            format: 'full',
                            limit: 100
                        }
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    // Parse the MCP response - it returns content array with text
                    if (data.content && data.content[0] && data.content[0].text) {
                        const parsed = JSON.parse(data.content[0].text);
                        allFlows = transformMcpFlows(parsed.flows || parsed);
                    } else {
                        throw new Error('Unexpected response format');
                    }
                } else {
                    throw new Error('API not available: ' + response.status);
                }
            } catch (error) {
                console.log('Using sample data (API unavailable):', error.message);
                // Use sample data when API is not available
                allFlows = sampleFlows;
            }

            filteredFlows = [...allFlows];
            populateNamespaceFilter();
            sortFlows();
            renderTable();
            updateStats();
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        // Initial load
        fetchFlows();

        // Auto-refresh every 30 seconds
        setInterval(fetchFlows, 30000);
    </script>
</body>
</html>
